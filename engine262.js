/*
 * engine262 0.0.1
 *
 * Copyright (c) 2018 engine262 Contributors
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('acorn'), require('nearley')) :
  typeof define === 'function' && define.amd ? define(['exports', 'acorn', 'nearley'], factory) :
  (global = global || self, factory(global.engine262 = {}, global.acorn, global.nearley));
}(this, function (exports, acorn, nearley) { 'use strict';

  acorn = acorn && acorn.hasOwnProperty('default') ? acorn['default'] : acorn;
  nearley = nearley && nearley.hasOwnProperty('default') ? nearley['default'] : nearley;

  function Completion(type, value, target) {
    if (new.target === Completion) {
      if (typeof type !== 'string') {
        throw new TypeError('Completion type is not a string');
      }

      this.Type = type;
      this.Value = value;
      this.Target = target;
    }

    return type;
  } // 6.2.3.2 #sec-normalcompletion

  class NormalCompletion {
    constructor(value) {
      return new Completion('normal', value);
    }

    static [Symbol.hasInstance](v) {
      return v instanceof Completion && v.Type === 'normal';
    }

  }
  class AbruptCompletion {
    static [Symbol.hasInstance](v) {
      return v instanceof Completion && v.Type !== 'normal';
    }

  }
  class BreakCompletion {
    constructor(target) {
      return new Completion('break', undefined, target);
    }

    static [Symbol.hasInstance](v) {
      return v instanceof Completion && v.Type === 'break';
    }

  }
  class ContinueCompletion {
    constructor(target) {
      return new Completion('continue', undefined, target);
    }

    static [Symbol.hasInstance](v) {
      return v instanceof Completion && v.Type === 'continue';
    }

  } // 6.2.3.2 #sec-normalcompletion

  class ReturnCompletion {
    constructor(value) {
      return new Completion('return', value);
    }

    static [Symbol.hasInstance](v) {
      return v instanceof Completion && v.Type === 'return';
    }

  } // 6.2.3.3 #sec-throwcompletion

  class ThrowCompletion {
    constructor(value) {
      return new Completion('throw', value);
    }

    static [Symbol.hasInstance](v) {
      return v instanceof Completion && v.Type === 'throw';
    }

  } // 6.2.3.4 #sec-updateempty

  function UpdateEmpty(completionRecord, value) {
    Assert(completionRecord instanceof Completion, "completionRecord instanceof Completion");

    if (completionRecord.Type === 'return' || completionRecord.Type === 'throw') {
      Assert(completionRecord.Value !== undefined, "completionRecord.Value !== undefined");
    }

    if (completionRecord.Value !== undefined) {
      return completionRecord;
    }

    return new Completion(completionRecord.Type, value, completionRecord.Target);
  } // 5.2.3.3 #sec-returnifabrupt
  function EnsureCompletion(val) {
    if (val instanceof Completion) {
      return val;
    }

    if (val instanceof Reference) {
      return val;
    }

    return new NormalCompletion(val);
  }

  function AwaitFulfilledFunctions([value]) {
    const F = surroundingAgent.activeFunctionObject;
    const asyncContext = F.AsyncContext;
    const prevContext = surroundingAgent.runningExecutionContext; // Suspend prevContext

    surroundingAgent.executionContextStack.push(asyncContext);
    resume(asyncContext, new NormalCompletion(value));
    Assert(surroundingAgent.runningExecutionContext === prevContext, "surroundingAgent.runningExecutionContext === prevContext");
    return Value.undefined;
  }

  function AwaitRejectedFunctions([reason]) {
    const F = surroundingAgent.activeFunctionObject;
    const asyncContext = F.AsyncContext;
    const prevContext = surroundingAgent.runningExecutionContext; // Suspend prevContext

    surroundingAgent.executionContextStack.push(asyncContext);
    resume(asyncContext, new ThrowCompletion(reason));
    Assert(surroundingAgent.runningExecutionContext === prevContext, "surroundingAgent.runningExecutionContext === prevContext");
    return Value.undefined;
  }

  function* Await(value) {
    const asyncContext = surroundingAgent.runningExecutionContext;
    let promise = PromiseResolve(surroundingAgent.intrinsic('%Promise%'), value);

    if (promise instanceof AbruptCompletion) {
      return promise;
    }

    if (promise instanceof Completion) {
      promise = promise.Value;
    }

    const stepsFulfilled = AwaitFulfilledFunctions;
    let onFulfilled = CreateBuiltinFunction(stepsFulfilled, ['AsyncContext']);
    Assert(!(onFulfilled instanceof AbruptCompletion), "");

    if (onFulfilled instanceof Completion) {
      onFulfilled = onFulfilled.Value;
    }

    Assert(!(SetFunctionLength(onFulfilled, new Value(1)) instanceof AbruptCompletion), "");
    onFulfilled.AsyncContext = asyncContext;
    const stepsRejected = AwaitRejectedFunctions;
    let onRejected = CreateBuiltinFunction(stepsRejected, ['AsyncContext']);
    Assert(!(onRejected instanceof AbruptCompletion), "");

    if (onRejected instanceof Completion) {
      onRejected = onRejected.Value;
    }

    Assert(!(SetFunctionLength(onRejected, new Value(1)) instanceof AbruptCompletion), "");
    onRejected.AsyncContext = asyncContext;
    Assert(!(PerformPromiseThen(promise, onFulfilled, onRejected) instanceof AbruptCompletion), "");
    surroundingAgent.executionContextStack.pop(asyncContext);
    const completion = yield Value.undefined;
    return completion;
  }

  class OutOfRange extends RangeError {
    constructor(fn, detail) {
      super(`${fn}() argument out of range`);
      this.detail = detail;
    }

  }
  function unwind(iterator, maxSteps = 1) {
    let steps = 0;

    while (true) {
      const {
        done,
        value
      } = iterator.next('Unwind');

      if (done) {
        return value;
      }

      steps += 1;

      if (steps > maxSteps) {
        throw new RangeError('Max steps exceeded');
      }
    }
  }
  const kSafeToResume = Symbol('kSameToResume');
  function handleInResume(fn, ...args) {
    const bound = () => fn(...args);

    bound[kSafeToResume] = true;
    return bound;
  }
  function resume(context, completion) {
    const {
      value
    } = context.codeEvaluationState.next(completion);

    if (typeof value === 'function' && value[kSafeToResume] === true) {
      let _val = value();

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      return _val;
    }

    return value;
  }
  function captureStack(O) {
    const stack = surroundingAgent.executionContextStack.filter(e => e.Function !== Value.null).slice(0, -1) // remove error constructor
    .map(e => {
      let string = '\n  at ';
      const functionName = e.Function.properties.get(new Value('name'));

      if (functionName) {
        let _val2 = ToString(functionName.Value);

        Assert(!(_val2 instanceof AbruptCompletion), "");

        if (_val2 instanceof Completion) {
          _val2 = _val2.Value;
        }

        string += _val2.stringValue();
      } else {
        string += '<anonymous>';
      }

      if (e.ScriptOrModule instanceof AbstractModuleRecord) {
        string += e.ScriptOrModule.HostDefined.specifier;
      }

      return string;
    }).reverse();

    let _val3 = ToString(O);

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    const errorString = _val3.stringValue();

    const trace = `${errorString}${stack.join('')}`;
    Assert(!(DefinePropertyOrThrow(O, new Value('stack'), Descriptor({
      Value: new Value(trace),
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
  }

  function inlineInspect(V) {
    if (V instanceof Value) {
      return inspect(V, surroundingAgent.currentRealmRecord, true);
    }

    return `${V}`;
  }

  const messages = {
    AlreadyDeclared: n => `${inlineInspect(n)} is already declared`,
    ArrayPastSafeLength: () => 'Cannot make length of array-like object surpass the bounds of an integer index',
    BufferDetachKeyMismatch: (k, b) => `${inlineInspect(k)} is not the [[ArrayBufferDetachKey]] of ${inlineInspect(b)}`,
    BufferDetached: () => 'Cannot operate on detached ArrayBuffer',
    CannotConvertSymbol: t => `Cannot convert a Symbol value to a ${t}`,
    CannotConvertToObject: t => `Cannot convert ${t} to object`,
    CannotSetProperty: (p, o) => `Cannot set property ${inlineInspect(p)} on ${inlineInspect(o)}`,
    ConstructorRequiresNew: n => `${n} constructor requires new`,
    CouldNotResolveModule: s => `Could not resolve module ${inlineInspect(s)}`,
    DataViewOOB: () => 'Offset is outside the bounds of the DataView',
    InternalSlotMissing: (o, s) => `Internal slot ${s} is missing for ${inlineInspect(o)}`,
    InvalidHint: v => `Invalid hint: ${inlineInspect(v)}`,
    InvalidRegExpFlags: f => `Invalid RegExp flags: ${f}`,
    NegativeIndex: (n = 'Index') => `${n} cannot be negative`,
    NotAConstructor: v => `${inlineInspect(v)} is not a constructor`,
    NotAFunction: v => `${inlineInspect(v)} is not a function`,
    NotATypeObject: (t, v) => `${inlineInspect(v)} is not a ${t} object`,
    NotAnObject: v => `${inlineInspect(v)} is not an object`,
    NotAnTypeObject: (t, v) => `${inlineInspect(v)} is not an ${t} object`,
    NotDefined: n => `${inlineInspect(n)} is not defined`,
    ObjectToPrimitive: () => 'Cannot convert object to primitive value',
    OutOfRange: n => `${n} is out of range`,
    PromiseRejectFunction: v => `Promise reject function ${inlineInspect(v)} is not callable`,
    PromiseResolveFunction: v => `Promise resolve function ${inlineInspect(v)} is not callable`,
    ProxyRevoked: n => `Cannot perform '${n}' on a proxy that has been revoked`,
    RegExpArgumentNotAllowed: m => `First argument to ${m} must not be a regular expression`,
    ResolutionNullOrAmbiguous: (r, n, m) => r === null ? `Could not resolve import ${inlineInspect(n)} from ${m.HostDefined.specifier}` : `Star export ${inlineInspect(n)} from ${m.HostDefined.specifier} is ambiguous`,
    StrictModeDelete: n => `Cannot not delete property ${inlineInspect(n)}`,
    StringRepeatCount: v => `Count ${inlineInspect(v)} is invalid`,
    SubclassLengthTooSmall: v => `Subclass constructor returned a smaller-than-requested object ${inlineInspect(v)}`,
    SubclassSameValue: v => `Subclass constructor returned the same object ${inlineInspect(v)}`,
    TypedArrayCreationOOB: () => 'Sum of start offset and byte length should be less than the size of underlying buffer',
    TypedArrayLengthAlignment: (n, m) => `Size of ${n} should be a multiple of ${m}`,
    TypedArrayOOB: () => 'Sum of start offset and byte length should be less than the size of the TypedArray',
    TypedArrayOffsetAlignment: (n, m) => `Start offset of ${n} should be a multiple of ${m}`,
    TypedArrayTooSmall: () => 'Derived TypedArray constructor created an array which was too small'
  };
  function msg(key, ...args) {
    return messages[key](...args);
  }

  function Assert(invariant, source) {
    if (!invariant) {
      throw new TypeError(`Assert failed${source ? `: ${source}` : ''}`.trim());
    }
  } // 9.1.15 #sec-requireinternalslot

  function RequireInternalSlot(O, internalSlot) {
    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotAnObject', O));
    }

    if (!(internalSlot in O)) {
      return surroundingAgent.Throw('TypeError', msg('InternalSlotMissing', O, internalSlot));
    }
  }
  function sourceTextMatchedBy(node) {
    return new Value(node.sourceText());
  } // An ECMAScript Script syntactic unit may be processed using either unrestricted or strict mode syntax and semantics.
  // Code is interpreted as strict mode code in the following situations:
  //
  //  - Global code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive.
  //
  //  - Module code is always strict mode code.
  //
  //  - All parts of a ClassDeclaration or a ClassExpression are strict mode code.
  //
  //  - Eval code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive or
  //    if the call to eval is a direct eval that is contained in strict mode code.
  //
  //  - Function code is strict mode code if the associated FunctionDeclaration, FunctionExpression, GeneratorDeclaration,
  //    GeneratorExpression, AsyncFunctionDeclaration, AsyncFunctionExpression, AsyncGeneratorDeclaration,
  //    AsyncGeneratorExpression, MethodDefinition, ArrowFunction, or AsyncArrowFunction is contained in strict mode code
  //    or if the code that produces the value of the function's [[ECMAScriptCode]] internal slot begins with a Directive
  //    Prologue that contains a Use Strict Directive.
  //
  //  - Function code that is supplied as the arguments to the built-in Function, Generator, AsyncFunction, and
  //    AsyncGenerator constructors is strict mode code if the last argument is a String that when processed is a
  //    FunctionBody that begins with a Directive Prologue that contains a Use Strict Directive.

  function isStrictModeCode(node) {
    if (node.strict === true) {
      return true;
    }

    if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') {
      return isStrictModeCode(node.body);
    }

    if (Array.isArray(node)) {
      return directivePrologueContainsUseStrictDirective(node);
    }

    return false;
  }

  function isNullLiteral(node) {
    return node.type === 'Literal' && node.value === null;
  } // #prod-BooleanLiteral

  function isBooleanLiteral(node) {
    return node.type === 'Literal' && typeof node.value === 'boolean';
  } // #prod-NumericLiteral

  function isNumericLiteral(node) {
    return node.type === 'Literal' && typeof node.value === 'number';
  } // #prod-StringLiteral

  function isStringLiteral(node) {
    return node.type === 'Literal' && typeof node.value === 'string';
  }
  function isSpreadElement(node) {
    return node.type === 'SpreadElement';
  } // #prod-RegularExpressionLiteral

  function isRegularExpressionLiteral(node) {
    return node.type === 'Literal' && typeof node.regex === 'object';
  } // #prod-Identifier
  // Not exact, as we allow reserved words when appropriate. (This is more like
  // IdentifierReference.)

  function isIdentifier(node) {
    return node.type === 'Identifier';
  } // #prod-IdentifierReference

  const isIdentifierReference = isIdentifier; // #prod-IdentifierName

  const isIdentifierName = isIdentifier; // #prod-BindingIdentifier

  const isBindingIdentifier = isIdentifier; // #prod-LabelIdentifier

  function isThis(node) {
    return node.type === 'ThisExpression';
  } // #prod-Literal

  function isLiteral(node) {
    // Just checking node.type is not enough as RegularExpressionLiteral also
    // uses 'Literal' as node.type.
    return isNullLiteral(node) || isBooleanLiteral(node) || isNumericLiteral(node) || isStringLiteral(node);
  } // #prod-ArrayLiteral

  function isArrayLiteral(node) {
    return node.type === 'ArrayExpression';
  } // #prod-ObjectLiteral

  function isObjectLiteral(node) {
    return node.type === 'ObjectExpression';
  } // #prod-GeneratorMethod

  function isGeneratorMethod(node) {
    return (node.type === 'Property' && !node.shorthand && node.method && node.kind === 'init' || node.type === 'MethodDefinition' && node.kind === 'method') && isGeneratorExpression(node.value);
  } // #prod-AsyncMethod

  function isAsyncMethod(node) {
    return (node.type === 'Property' && !node.shorthand && node.method && node.kind === 'init' || node.type === 'MethodDefinition' && node.kind === 'method') && isAsyncFunctionExpression(node.value);
  } // #prod-AsyncGeneratorMethod

  function isAsyncGeneratorMethod(node) {
    return (node.type === 'Property' && !node.shorthand && node.method && node.kind === 'init' || node.type === 'MethodDefinition' && node.kind === 'method') && isAsyncGeneratorExpression(node.value);
  } // Used in #prod-MethodDefinition

  function isMethodDefinitionRegularFunction(node) {
    return (node.type === 'Property' && !node.shorthand && node.method && node.kind === 'init' || node.type === 'MethodDefinition' && node.kind === 'method') && isFunctionExpression(node.value);
  } // Used in #prod-MethodDefinition

  function isMethodDefinitionGetter(node) {
    return (node.type === 'Property' && !node.shorthand && !node.method || node.type === 'MethodDefinition') && node.kind === 'get';
  } // Used in #prod-MethodDefinition

  function isMethodDefinitionSetter(node) {
    return (node.type === 'Property' && !node.shorthand && !node.method || node.type === 'MethodDefinition') && node.kind === 'set';
  } // #prod-MethodDefinition

  function isMethodDefinition(node) {
    return isMethodDefinitionRegularFunction(node) || isGeneratorMethod(node) || isAsyncMethod(node) || isAsyncGeneratorMethod(node) || isMethodDefinitionGetter(node) || isMethodDefinitionSetter(node);
  } // Used in #prod-PropertyDefinition

  function isPropertyDefinitionIdentifierReference(node) {
    return node.type === 'Property' && node.shorthand && !node.method && !node.computed && node.kind === 'init';
  } // Used in #prod-PropertyDefinition

  function isPropertyDefinitionKeyValue(node) {
    return node.type === 'Property' && !node.shorthand && !node.method && node.kind === 'init';
  } // Used in #prod-PropertyDefinition

  function isPropertyDefinitionSpread(node) {
    return node.type === 'SpreadElement';
  } // #prod-FunctionExpression

  function isFunctionExpression(node) {
    return node.type === 'FunctionExpression' && !node.generator && !node.async;
  }
  function isFunctionExpressionWithBindingIdentifier(node) {
    return isFunctionExpression(node) && node.id !== null;
  }
  function isAsyncFunctionExpressionWithBindingIdentifier(node) {
    return isAsyncFunctionExpression(node) && node.id !== null;
  } // #prod-ClassExpression

  function isClassExpression(node) {
    return node.type === 'ClassExpression';
  } // #prod-GeneratorExpression

  function isGeneratorExpression(node) {
    return node.type === 'FunctionExpression' && node.generator && !node.async;
  } // #prod-AsyncFunctionExpression

  function isAsyncFunctionExpression(node) {
    return node.type === 'FunctionExpression' && !node.generator && node.async;
  } // #prod-AsyncGeneratorExpression

  function isAsyncGeneratorExpression(node) {
    return node.type === 'FunctionExpression' && node.generator && node.async;
  } // #prod-TemplateLiteral

  function isTemplateLiteral(node) {
    return node.type === 'TemplateLiteral';
  } // #prod-NoSubstitutionTemplate

  function isNoSubstitutionTemplate(node) {
    return isTemplateLiteral(node) && node.expressions.length === 0;
  } // #prod-SubstitutionTemplate

  function isSubstitutionTemplate(node) {
    return isTemplateLiteral(node) && node.expressions.length !== 0;
  }
  function unrollTemplateLiteral(TemplateLiteral) {
    const all = [TemplateLiteral.quasis[0]];

    for (let i = 1; i < TemplateLiteral.quasis.length; i += 1) {
      all.push(TemplateLiteral.expressions[i - 1]);
      all.push(TemplateLiteral.quasis[i]);
    }

    return all;
  }
  function isTaggedTemplate(node) {
    return node.type === 'TaggedTemplateExpression';
  } // Used in #prod-MemberExpression and #prod-CallExpression

  function isActualMemberExpression(node) {
    return node.type === 'MemberExpression' && node.object.type !== 'Super';
  } // Used in #prod-MemberExpression and #prod-CallExpression

  function isActualMemberExpressionWithBrackets(node) {
    return isActualMemberExpression(node) && node.computed;
  } // Used in #prod-MemberExpression and #prod-CallExpression

  function isActualMemberExpressionWithDot(node) {
    return isActualMemberExpression(node) && !node.computed;
  } // #prod-SuperProperty

  function isSuperProperty(node) {
    return node.type === 'MemberExpression' && node.object.type === 'Super';
  } // #prod-MetaProperty

  function isMetaProperty(node) {
    return node.type === 'MetaProperty';
  } // #prod-NewTarget

  function isActualNewExpression(node) {
    return node.type === 'NewExpression';
  } // Used in #prod-CallExpression and #prod-CallMemberExpression

  function isActualCallExpression(node) {
    return node.type === 'CallExpression' && node.callee.type !== 'Super';
  } // #prod-SuperCall

  function isSuperCall(node) {
    return node.type === 'CallExpression' && node.callee.type === 'Super';
  } // #prod-ImportCall

  function isImportCall(node) {
    return node.type === 'CallExpression' && node.callee.type === 'Import';
  } // Used in #prod-UpdateExpression

  function isActualUpdateExpression(node) {
    return node.type === 'UpdateExpression';
  } // Used in #prod-UnaryExpression

  function isActualUnaryExpression(node) {
    return node.type === 'UnaryExpression';
  } // Used in #prod-UnaryExpression

  function isUnaryExpressionWithDelete(node) {
    return node.type === 'UnaryExpression' && node.operator === 'delete';
  } // Used in #prod-UnaryExpression

  function isUnaryExpressionWithVoid(node) {
    return node.type === 'UnaryExpression' && node.operator === 'void';
  } // Used in #prod-UnaryExpression

  function isUnaryExpressionWithTypeof(node) {
    return node.type === 'UnaryExpression' && node.operator === 'typeof';
  } // Used in #prod-UnaryExpression

  function isUnaryExpressionWithPlus(node) {
    return node.type === 'UnaryExpression' && node.operator === '+';
  } // Used in #prod-UnaryExpression

  function isUnaryExpressionWithMinus(node) {
    return node.type === 'UnaryExpression' && node.operator === '-';
  } // Used in #prod-UnaryExpression

  function isUnaryExpressionWithTilde(node) {
    return node.type === 'UnaryExpression' && node.operator === '~';
  } // Used in #prod-UnaryExpression

  function isUnaryExpressionWithBang(node) {
    return node.type === 'UnaryExpression' && node.operator === '!';
  } // #prod-AwaitExpression

  function isAwaitExpression(node) {
    return node.type === 'AwaitExpression';
  } // Used in #prod-ExponentiationExpression

  function isActualExponentiationExpression(node) {
    return node.type === 'BinaryExpression' && node.operator === '**';
  } // Used in #prod-MultiplicativeExpression

  function isActualMultiplicativeExpression(node) {
    return node.type === 'BinaryExpression' && (node.operator === '*' || node.operator === '/' || node.operator === '%');
  } // Used in #prod-AdditiveExpression

  function isActualAdditiveExpression(node) {
    return node.type === 'BinaryExpression' && (node.operator === '+' || node.operator === '-');
  } // Used in #prod-AdditiveExpression

  function isAdditiveExpressionWithPlus(node) {
    return isActualAdditiveExpression(node) && node.operator === '+';
  } // Used in #prod-AdditiveExpression

  function isAdditiveExpressionWithMinus(node) {
    return isActualAdditiveExpression(node) && node.operator === '-';
  } // Used in #prod-ShiftExpression

  function isActualShiftExpression(node) {
    return node.type === 'BinaryExpression' && (node.operator === '<<' || node.operator === '>>' || node.operator === '>>>');
  } // Used in #prod-RelationalExpression

  function isActualRelationalExpression(node) {
    return node.type === 'BinaryExpression' && (node.operator === '<' || node.operator === '>' || node.operator === '<=' || node.operator === '>=' || node.operator === 'instanceof' || node.operator === 'in');
  } // Used in #prod-EqualityExpression

  function isActualEqualityExpression(node) {
    return node.type === 'BinaryExpression' && (node.operator === '==' || node.operator === '!=' || node.operator === '===' || node.operator === '!==');
  } // Used in #prod-BitwiseANDExpression

  function isActualBitwiseANDExpression(node) {
    return node.type === 'BinaryExpression' && node.operator === '&';
  } // Used in #prod-BitwiseXORExpression

  function isActualBitwiseXORExpression(node) {
    return node.type === 'BinaryExpression' && node.operator === '^';
  } // Used in #prod-BitwiseORExpression

  function isActualBitwiseORExpression(node) {
    return node.type === 'BinaryExpression' && node.operator === '|';
  } // Used in #prod-LogicalANDExpression

  function isActualLogicalANDExpression(node) {
    return node.type === 'LogicalExpression' && node.operator === '&&';
  } // Used in #prod-LogicalORExpression

  function isActualLogicalORExpression(node) {
    return node.type === 'LogicalExpression' && node.operator === '||';
  } // Used in #prod-ConditionalExpression

  function isActualConditionalExpression(node) {
    return node.type === 'ConditionalExpression';
  } // #prod-YieldExpression

  function isYieldExpression(node) {
    return node.type === 'YieldExpression';
  } // Used in #prod-YieldExpression.

  function isYieldExpressionWithStar(node) {
    return isYieldExpression(node) && node.delegate;
  } // #prod-ArrowFunction

  function isArrowFunction(node) {
    return node.type === 'ArrowFunctionExpression' && !node.async && !node.generator;
  } // #prod-AsyncArrowFunction

  function isAsyncArrowFunction(node) {
    return node.type === 'ArrowFunctionExpression' && node.async && !node.generator;
  } // Used in #prod-AssignmentExpression

  function isActualAssignmentExpression(node) {
    return node.type === 'AssignmentExpression';
  } // Used in #prod-AssignmentExpression

  function isExpressionWithComma(node) {
    return node.type === 'SequenceExpression';
  }
  function isParenthesizedExpression(node) {
    return node.type === 'ParenthesizedExpression';
  } // https://tc39.es/proposal-nullish-coalescing

  function isActualCoalesceExpression(node) {
    return node.type === 'BinaryExpression' && node.operator === '??';
  } // https://tc39.es/proposal-optional-chaining

  function isOptionalExpression(node) {
    return node.type === 'OptionalExpression';
  } // https://tc39.es/proposal-optional-chaining

  function isOptionalChain(node) {
    return node.type === 'OptionalChain';
  }
  function isOptionalChainWithOptionalChain(node) {
    return isOptionalChain(node) && node.base !== null;
  }
  function isOptionalChainWithExpression(node) {
    return isOptionalChain(node) && node.property && isExpression(node.property) && !isIdentifierReference(node.property);
  }
  function isOptionalChainWithIdentifierName(node) {
    return isOptionalChain(node) && node.property && isIdentifier(node.property);
  }
  function isOptionalChainWithArguments(node) {
    return isOptionalChain(node) && Array.isArray(node.arguments);
  } // #prod-Expression

  function isExpression(node) {
    return (// PrimaryExpression
      isThis(node) || isIdentifierReference(node) || isLiteral(node) || isArrayLiteral(node) || isObjectLiteral(node) || isFunctionExpression(node) || isClassExpression(node) || isGeneratorExpression(node) || isAsyncFunctionExpression(node) || isAsyncGeneratorExpression(node) || isRegularExpressionLiteral(node) || isTemplateLiteral(node) || isParenthesizedExpression(node) // LeftHandSideExpression (including MemberExpression, NewExpression, and
      // CallExpression)
      || isActualMemberExpression(node) || isOptionalExpression(node) || isSuperProperty(node) || isSuperCall(node) || isImportCall(node) || isMetaProperty(node) || isActualNewExpression(node) || isActualCallExpression(node) || isTaggedTemplate(node) // UpdateExpression
      || isActualUpdateExpression(node) // UnaryExpression
      || isActualUnaryExpression(node) || isAwaitExpression(node) // ExponentiationExpression
      || isActualExponentiationExpression(node) // MultiplicativeExpression
      || isActualMultiplicativeExpression(node) // AdditiveExpression
      || isActualAdditiveExpression(node) // ShiftExpression
      || isActualShiftExpression(node) // RelationalExpression
      || isActualRelationalExpression(node) // EqualityExpression
      || isActualEqualityExpression(node) // BitwiseANDExpression
      || isActualBitwiseANDExpression(node) // BitwiseXORExpression
      || isActualBitwiseXORExpression(node) // BitwiseORExpression
      || isActualBitwiseORExpression(node) // LogicalANDExpression
      || isActualLogicalANDExpression(node) // LogicalORExpression
      || isActualLogicalORExpression(node) // CoalesceExpression
      || isActualCoalesceExpression(node) // ConditionalExpression
      || isActualConditionalExpression(node) // AssignmentExpression
      || isYieldExpression(node) || isArrowFunction(node) || isAsyncArrowFunction(node) || isActualAssignmentExpression(node) // Expression
      || isExpressionWithComma(node)
    );
  } // #prod-ExpressionBody

  const isExpressionBody = isExpression; // Used in #prod-SingleNameBinding

  function isBindingIdentifierAndInitializer(node) {
    return node.type === 'AssignmentPattern' && isBindingIdentifier(node.left);
  } // #prod-SingleNameBinding
  //
  // Use isBindingPropertyWithSingleNameBinding() instead if SingleNameBinding is
  // used as a child of BindingProperty.

  function isSingleNameBinding(node) {
    return isBindingIdentifier(node) || isBindingIdentifierAndInitializer(node);
  } // Used in #prod-BindingElement

  function isBindingPatternAndInitializer(node) {
    return node.type === 'AssignmentPattern' && isBindingPattern(node.left);
  } // #prod-BindingElement

  function isBindingElement(node) {
    return isSingleNameBinding(node) || isBindingPattern(node) || isBindingPatternAndInitializer(node);
  } // #prod-FormalParameter

  const isFormalParameter = isBindingElement; // #prod-BindingRestElement

  function isBindingRestElement(node) {
    return node.type === 'RestElement';
  } // #prod-FunctionRestParameter

  const isFunctionRestParameter = isBindingRestElement; // #prod-BindingProperty

  function isBindingProperty(node) {
    // ESTree puts the SingleNameBinding in node.value.
    return node.type === 'Property' && isBindingElement(node.value);
  } // Used in #prod-BindingProperty.

  function isBindingPropertyWithSingleNameBinding(node) {
    return isBindingProperty(node) && node.shorthand;
  } // Used in #prod-BindingProperty.

  function isBindingPropertyWithColon(node) {
    return isBindingProperty(node) && !node.shorthand;
  } // #prod-BindingRestProperty

  function isBindingRestProperty(node) {
    return node.type === 'RestElement';
  } // #prod-BlockStatement

  function isBlockStatement(node) {
    return node.type === 'BlockStatement';
  } // #prod-BindingPattern

  function isBindingPattern(node) {
    return isObjectBindingPattern(node) || isArrayBindingPattern(node);
  } // #prod-ObjectBindingPattern

  function isObjectBindingPattern(node) {
    return node.type === 'ObjectPattern';
  }

  function isArrayBindingPattern(node) {
    return node.type === 'ArrayPattern';
  } // #prod-AssignmentPattern

  const isAssignmentPattern = isBindingPattern; // #prod-ObjectAssignmentPattern

  const isObjectAssignmentPattern = isObjectBindingPattern; // #prod-ArrayAssignmentPattern

  const isArrayAssignmentPattern = isArrayBindingPattern; // #prod-AssignmentRestProperty

  const isAssignmentRestProperty = isBindingRestElement; // #prod-Block

  function isVariableStatement(node) {
    return node.type === 'VariableDeclaration' && node.kind === 'var';
  } // #prod-VariableDeclaration

  function isVariableDeclaration(node) {
    return node.type === 'VariableDeclarator';
  } // #prod-EmptyStatement

  function isEmptyStatement(node) {
    return node.type === 'EmptyStatement';
  } // #prod-ExpressionStatement

  function isExpressionStatement(node) {
    return node.type === 'ExpressionStatement';
  } // #prod-IfStatement

  function isIfStatement(node) {
    return node.type === 'IfStatement';
  } // #prod-BreakableStatement

  function isBreakableStatement(node) {
    return isIterationStatement(node) || isSwitchStatement(node);
  } // #prod-IterationStatement

  function isIterationStatement(node) {
    // for-await-of is ForOfStatement with await = true
    return node.type === 'DoWhileStatement' || node.type === 'WhileStatement' || node.type === 'ForStatement' || node.type === 'ForInStatement' || node.type === 'ForOfStatement';
  } // Used in #prod-IterationStatement

  function isDoWhileStatement(node) {
    return node.type === 'DoWhileStatement';
  } // Used in #prod-IterationStatement

  function isWhileStatement(node) {
    return node.type === 'WhileStatement';
  } // Used in #prod-IterationStatement

  function isForStatement(node) {
    return node.type === 'ForStatement';
  } // Used in #prod-IterationStatement

  function isForStatementWithExpression(node) {
    return isForStatement(node) && (node.init === null || isExpression(node.init));
  } // Used in #prod-IterationStatement

  function isForStatementWithVariableStatement(node) {
    return isForStatement(node) && isVariableStatement(node.init);
  } // Used in #prod-IterationStatement

  function isForStatementWithLexicalDeclaration(node) {
    return isForStatement(node) && isLexicalDeclaration(node.init);
  } // Used in #prod-IterationStatement

  function isForInStatement(node) {
    return node.type === 'ForInStatement';
  } // Used in #prod-IterationStatement
  // This covers cases like for ({ a } in b), in which case the { a } is in fact
  // parsed as an ObjectLiteral per spec.

  function isForInStatementWithExpression(node) {
    return isForInStatement(node) && node.left.type !== 'VariableDeclaration';
  } // Used in #prod-IterationStatement

  function isForInStatementWithVarForBinding(node) {
    return isForInStatement(node) && isVariableStatement(node.left) && !node.left.declarations[0].init;
  } // Used in #prod-IterationStatement

  function isForInStatementWithForDeclaration(node) {
    return isForInStatement(node) && isForDeclaration(node.left);
  } // Used in #prod-IterationStatement

  function isForOfStatement(node) {
    return node.type === 'ForOfStatement';
  } // Used in #prod-IterationStatement
  // This covers cases like for ({ a } of b), in which case the { a } is in fact
  // parsed as an ObjectLiteral per spec.

  function isForOfStatementWithExpression(node) {
    return isForOfStatement(node) && node.left.type !== 'VariableDeclaration';
  } // Used in #prod-IterationStatement

  function isForOfStatementWithVarForBinding(node) {
    return isForOfStatement(node) && isVariableStatement(node.left) && !node.left.declarations[0].init;
  } // Used in #prod-IterationStatement

  function isForOfStatementWithForDeclaration(node) {
    return isForOfStatement(node) && isForDeclaration(node.left);
  } // #prod-ForBinding

  function isForBinding(node) {
    return isBindingIdentifier(node) || isBindingPattern(node);
  } // #prod-SwitchStatement

  function isSwitchStatement(node) {
    return node.type === 'SwitchStatement';
  }
  function isSwitchCase(node) {
    return node.type === 'SwitchCase';
  } // #prod-ContinueStatement

  function isContinueStatement(node) {
    return node.type === 'ContinueStatement';
  } // #prod-BreakStatement

  function isBreakStatement(node) {
    return node.type === 'BreakStatement';
  } // #prod-ReturnStatement

  function isReturnStatement(node) {
    return node.type === 'ReturnStatement';
  } // #prod-WithStatement

  function isWithStatement(node) {
    return node.type === 'WithStatement';
  } // #prod-LabelledStatement

  function isLabelledStatement(node) {
    return node.type === 'LabeledStatement'; // sic
  } // #prod-ThrowStatement

  function isThrowStatement(node) {
    return node.type === 'ThrowStatement';
  } // #prod-TryStatement

  function isTryStatement(node) {
    return node.type === 'TryStatement';
  } // Used in #prod-TryStatement

  function isTryStatementWithCatch(node) {
    return isTryStatement(node) && node.handler !== null;
  } // Used in #prod-TryStatement

  function isTryStatementWithFinally(node) {
    return isTryStatement(node) && node.finalizer !== null;
  } // #prod-DebuggerStatement

  function isDebuggerStatement(node) {
    return node.type === 'DebuggerStatement';
  } // #prod-Statement

  function isStatement(node) {
    return isBlockStatement(node) || isVariableStatement(node) || isEmptyStatement(node) || isExpressionStatement(node) || isIfStatement(node) || isBreakableStatement(node) || isContinueStatement(node) || isBreakStatement(node) || isReturnStatement(node) || isWithStatement(node) || isLabelledStatement(node) || isThrowStatement(node) || isTryStatement(node) || isDebuggerStatement(node);
  } // #prod-Declaration

  function isDeclaration(node) {
    return isHoistableDeclaration(node) || isClassDeclaration(node) || isLexicalDeclaration(node);
  } // #prod-HoistableDeclaration
  // The other kinds of HoistableDeclarations are grouped under
  // FunctionDeclaration in ESTree.

  function isHoistableDeclaration(node) {
    return node.type === 'FunctionDeclaration';
  } // #prod-FunctionDeclaration

  function isFunctionDeclaration(node) {
    return node.type === 'FunctionDeclaration' && !node.generator && !node.async;
  } // #prod-GeneratorDeclaration

  function isGeneratorDeclaration(node) {
    return node.type === 'FunctionDeclaration' && node.generator && !node.async;
  } // #prod-AsyncFunctionDeclaration

  function isAsyncFunctionDeclaration(node) {
    return node.type === 'FunctionDeclaration' && !node.generator && node.async;
  } // #prod-AsyncGeneratorDeclaration

  function isAsyncGeneratorDeclaration(node) {
    return node.type === 'FunctionDeclaration' && node.generator && node.async;
  } // #prod-ClassDeclaration

  function isClassDeclaration(node) {
    return node.type === 'ClassDeclaration';
  } // #prod-LexicalDeclaration

  function isLexicalDeclaration(node) {
    return node.type === 'VariableDeclaration' && (node.kind === 'let' || node.kind === 'const');
  } // #prod-StatementListItem

  function isStatementListItem(node) {
    return isStatement(node) || isDeclaration(node);
  } // #prod-ForDeclaration

  const isForDeclaration = isLexicalDeclaration; // #prod-LexicalBinding
  //
  // Note:
  //     import {} from 'abc';
  // is treated the same as
  //     import 'abc';
  // and this method returns false with such constructs.

  function isImportDeclarationWithClause(node) {
    return isImportDeclaration(node) && node.specifiers.length !== 0;
  } // Used in #prod-ImportDeclaration
  //
  // Note:
  //     import {} from 'abc';
  // is treated the same as
  //     import 'abc';
  // and this method returns true with such constructs.

  function isImportDeclarationWithSpecifierOnly(node) {
    return isImportDeclaration(node) && node.specifiers.length === 0;
  } // #prod-ImportDeclaration

  function isImportDeclaration(node) {
    return node.type === 'ImportDeclaration';
  } // #prod-ImportedDefaultBinding

  function isImportedDefaultBinding(node) {
    return node.type === 'ImportDefaultSpecifier';
  } // #prod-NameSpaceImport

  function isNameSpaceImport(node) {
    return node.type === 'ImportNamespaceSpecifier';
  } // #prod-ImportSpecifier

  function isImportSpecifier(node) {
    return node.type === 'ImportSpecifier';
  } // Used in #prod-ExportDeclaration

  function isExportDeclarationWithStar(node) {
    return node.type === 'ExportAllDeclaration';
  } // Used in #prod-ExportDeclaration

  function isExportDeclarationWithExportAndFrom(node) {
    return node.type === 'ExportNamedDeclaration' && node.declaration === null && node.source !== null;
  } // Used in #prod-ExportDeclaration

  function isExportDeclarationWithExport(node) {
    return node.type === 'ExportNamedDeclaration' && node.declaration === null && node.source === null;
  } // Used in #prod-ExportDeclaration

  function isExportDeclarationWithVariable(node) {
    return node.type === 'ExportNamedDeclaration' && node.declaration !== null && isVariableStatement(node.declaration);
  } // Used in #prod-ExportDeclaration

  function isExportDeclarationWithDeclaration(node) {
    return node.type === 'ExportNamedDeclaration' && node.declaration !== null && isDeclaration(node.declaration);
  } // Used in #prod-ExportDeclaration

  function isExportDeclarationWithDefaultAndHoistable(node) {
    return node.type === 'ExportDefaultDeclaration' && isHoistableDeclaration(node.declaration);
  } // Used in #prod-ExportDeclaration

  function isExportDeclarationWithDefaultAndClass(node) {
    return node.type === 'ExportDefaultDeclaration' && isClassDeclaration(node.declaration);
  } // Used in #prod-ExportDeclaration

  function isExportDeclarationWithDefaultAndExpression(node) {
    return node.type === 'ExportDefaultDeclaration' && isExpression(node.declaration);
  } // #prod-ExportDeclaration

  function isExportDeclaration(node) {
    return isExportDeclarationWithStar(node) || isExportDeclarationWithExportAndFrom(node) || isExportDeclarationWithExport(node) || isExportDeclarationWithVariable(node) || isExportDeclarationWithDeclaration(node) || isExportDeclarationWithDefaultAndHoistable(node) || isExportDeclarationWithDefaultAndClass(node) || isExportDeclarationWithDefaultAndExpression(node);
  } // 14.1.1 #sec-directive-prologues-and-the-use-strict-directive

  function directivePrologueContainsUseStrictDirective(nodes) {
    for (const node of nodes) {
      if (isExpressionStatement(node) && isStringLiteral(node.expression)) {
        Assert(typeof node.directive === 'string', "typeof node.directive === 'string'");

        if (node.directive === 'use strict') {
          return true;
        }
      } else {
        Assert(typeof node.directive !== 'string', "typeof node.directive !== 'string'");
        return false;
      }
    }

    return false;
  }

  //   BindingIdentifier :
  //     Identifier
  //     `yield`
  //     `await`

  function BoundNames_BindingIdentifier(BindingIdentifier) {
    return [BindingIdentifier.name];
  } // 13.3.1.2 #sec-let-and-const-declarations-static-semantics-boundnames
  //   LexicalDeclaration : LetOrConst BindingList `;`
  //   BindingList : BindingList `,` LexicalBinding
  //   LexicalBinding :
  //     BindingIdentifier Initializer
  //     BindingPattern Initializer
  //
  // (implicit)
  //   BindingList : LexicalBinding

  function BoundNames_LexicalDeclaration(LexicalDeclaration) {
    const names = [];

    for (const declarator of LexicalDeclaration.declarations) {
      switch (true) {
        case isBindingIdentifier(declarator.id):
          names.push(...BoundNames_BindingIdentifier(declarator.id));
          break;

        case isBindingPattern(declarator.id):
          names.push(...BoundNames_BindingPattern(declarator.id));
          break;

        default:
          throw new OutOfRange('BoundNames_LexicalDeclaration', LexicalDeclaration);
      }
    }

    return names;
  } // 13.3.2.1 #sec-variable-statement-static-semantics-boundnames
  //   VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration
  //
  // (implicit)
  //   VariableDeclarationList : VariableDeclaration

  function BoundNames_VariableDeclarationList(VariableDeclarationList) {
    const names = [];

    for (const VariableDeclaration of VariableDeclarationList) {
      names.push(...BoundNames_VariableDeclaration(VariableDeclaration));
    }

    return names;
  } // 13.3.2.1 #sec-variable-statement-static-semantics-boundnames
  //   VariableDeclaration :
  //     BindingIdentifier Initializer
  //     BindingPattern Initializer

  function BoundNames_VariableDeclaration(VariableDeclaration) {
    switch (true) {
      case isBindingIdentifier(VariableDeclaration.id):
        return BoundNames_BindingIdentifier(VariableDeclaration.id);

      case isBindingPattern(VariableDeclaration.id):
        return BoundNames_BindingPattern(VariableDeclaration.id);

      default:
        throw new OutOfRange('BoundNames_VariableDeclaration', VariableDeclaration);
    }
  } // (implicit)
  //   VariableStatement : `var` VariableDeclarationList `;`

  function BoundNames_VariableStatement(VariableStatement) {
    return BoundNames_VariableDeclarationList(VariableStatement.declarations);
  } // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
  //   SingleNameBinding : BindingIdentifier Initializer
  //
  // (implicit)
  //   SingleNameBinding : BindingIdentifier

  function BoundNames_SingleNameBinding(SingleNameBinding) {
    switch (true) {
      case isBindingIdentifier(SingleNameBinding):
        return BoundNames_BindingIdentifier(SingleNameBinding);

      case isBindingIdentifierAndInitializer(SingleNameBinding):
        return BoundNames_BindingIdentifier(SingleNameBinding.left);

      default:
        throw new OutOfRange('BoundNames_SingleNameBinding', SingleNameBinding);
    }
  } // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
  //   BindingElement : BindingPattern Initializer
  //
  // (implicit)
  //   BindingElement :
  //     SingleNameBinding
  //     BindingPattern

  function BoundNames_BindingElement(BindingElement) {
    switch (true) {
      case isSingleNameBinding(BindingElement):
        return BoundNames_SingleNameBinding(BindingElement);

      case isBindingPattern(BindingElement):
        return BoundNames_BindingPattern(BindingElement);

      case isBindingPatternAndInitializer(BindingElement):
        return BoundNames_BindingPattern(BindingElement.left);

      default:
        throw new OutOfRange('BoundNames_BindingElement', BindingElement);
    }
  } // (implicit)
  //   BindingRestElement :
  //     `...` BindingIdentifier
  //     `...` BindingPattern

  function BoundNames_BindingRestElement(BindingRestElement) {
    switch (true) {
      case isBindingIdentifier(BindingRestElement.argument):
        return BoundNames_BindingIdentifier(BindingRestElement.argument);

      case isBindingPattern(BindingRestElement.argument):
        return BoundNames_BindingPattern(BindingRestElement.argument);

      default:
        throw new OutOfRange('BoundNames_BindingRestElement argument', BindingRestElement.argument);
    }
  } // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
  //   ArrayBindingPattern :
  //     `[` Elision `]`
  //     `[` Elision BindingRestElement `]`
  //     `[` BindingElementList `,` Elision `]`
  //     `[` BindingElementList `,` Elision BindingRestElement `]`
  //   BindingElementList : BindingElementList `,` BindingElisionElement
  //   BindingElisionElement : Elision BindingElement

  function BoundNames_ArrayBindingPattern(ArrayBindingPattern) {
    const names = [];

    for (const BindingElisionElementOrBindingRestElement of ArrayBindingPattern.elements) {
      switch (true) {
        case BindingElisionElementOrBindingRestElement === null:
          // This is an elision.
          break;

        case isBindingElement(BindingElisionElementOrBindingRestElement):
          {
            const BindingElement = BindingElisionElementOrBindingRestElement;
            names.push(...BoundNames_BindingElement(BindingElement));
            break;
          }

        case isBindingRestElement(BindingElisionElementOrBindingRestElement):
          {
            const BindingRestElement = BindingElisionElementOrBindingRestElement;
            names.push(...BoundNames_BindingRestElement(BindingRestElement));
            break;
          }

        default:
          throw new OutOfRange('BoundNames_ArrayBindingPattern element', BindingElisionElementOrBindingRestElement);
      }
    }

    return names;
  } // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
  //   BindingProperty : PropertyName `:` BindingElement
  //
  // (implicit)
  //   BindingProperty : SingleNameBinding

  function BoundNames_BindingProperty(BindingProperty) {
    switch (true) {
      case isBindingPropertyWithSingleNameBinding(BindingProperty):
        return BoundNames_SingleNameBinding(BindingProperty.value);

      case isBindingPropertyWithColon(BindingProperty):
        return BoundNames_BindingElement(BindingProperty.value);

      default:
        throw new OutOfRange('BoundNames_BindingProperty', BindingProperty);
    }
  } // (implicit)
  //   BindingRestProperty : `...` BindingIdentifier

  function BoundNames_BindingRestProperty(BindingRestProperty) {
    if (!isBindingIdentifier(BindingRestProperty.argument)) {
      throw new OutOfRange('BoundNames_BindingRestProperty argument', BindingRestProperty.argument);
    }

    return BoundNames_BindingIdentifier(BindingRestProperty.argument);
  } // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
  //   ObjectBindingPattern :
  //     `{` `}`
  //     `{` BindingRestProperty `}`
  //   BindingPropertyList : BindingPropertyList `,` BindingProperty
  //
  // (implicit)
  //   ObjectBindingPattern :
  //     `{` BindingPropertyList `}`
  //     `{` BindingPropertyList `,` `}`
  //     `{` BindingPropertyList `,` BindingRestProperty `}`

  function BoundNames_ObjectBindingPattern(ObjectBindingPattern) {
    const names = [];

    for (const BindingPropertyOrBindingRestProperty of ObjectBindingPattern.properties) {
      switch (true) {
        case isBindingProperty(BindingPropertyOrBindingRestProperty):
          {
            const BindingProperty = BindingPropertyOrBindingRestProperty;
            names.push(...BoundNames_BindingProperty(BindingProperty));
            break;
          }

        case isBindingRestProperty(BindingPropertyOrBindingRestProperty):
          {
            const BindingRestProperty = BindingPropertyOrBindingRestProperty;
            names.push(...BoundNames_BindingRestProperty(BindingRestProperty));
            break;
          }

        default:
          throw new OutOfRange('BoundNames_ObjectBindingPattern property', BindingPropertyOrBindingRestProperty);
      }
    }

    return names;
  } // (implicit)
  //   BindingPattern :
  //     ObjectBindingPattern
  //     ArrayBindingPattern


  function BoundNames_BindingPattern(BindingPattern) {
    switch (true) {
      case isObjectBindingPattern(BindingPattern):
        return BoundNames_ObjectBindingPattern(BindingPattern);

      case isArrayBindingPattern(BindingPattern):
        return BoundNames_ArrayBindingPattern(BindingPattern);

      default:
        throw new OutOfRange('BoundNames_BindingPattern', BindingPattern);
    }
  } // 13.7.5.2 #sec-for-in-and-for-of-statements-static-semantics-boundnames
  //   ForDeclaration : LetOrConst ForBinding


  function BoundNames_ForDeclaration(ForDeclaration) {
    const ForBinding = ForDeclaration.declarations[0].id;
    return BoundNames_ForBinding(ForBinding);
  }

  function BoundNames_BindingIdentifierOrBindingPattern(targetTypeForErrorMessage, BindingIdentifierOrBindingPattern) {
    switch (true) {
      case isBindingIdentifier(BindingIdentifierOrBindingPattern):
        return BoundNames_BindingIdentifier(BindingIdentifierOrBindingPattern);

      case isBindingPattern(BindingIdentifierOrBindingPattern):
        return BoundNames_BindingPattern(BindingIdentifierOrBindingPattern);

      default:
        throw new OutOfRange(`BoundNames_BindingIdentifierOrBindingPattern ${targetTypeForErrorMessage}`, BindingIdentifierOrBindingPattern);
    }
  } // (implicit)
  //   ForBinding :
  //     BindingIdentifier
  //     BindingPattern


  function BoundNames_ForBinding(node) {
    return BoundNames_BindingIdentifierOrBindingPattern('ForBinding', node);
  } // (implicit)
  //   CatchParameter :
  //     BindingIdentifier
  //     BindingPattern

  function BoundNames_CatchParameter(node) {
    return BoundNames_BindingIdentifierOrBindingPattern('CatchParameter', node);
  } // (implicit)
  //   FormalParameter : BindingElement

  const BoundNames_FormalParameter = BoundNames_BindingElement; // (implicit)
  //   FunctionRestParameter : BindingRestElement

  const BoundNames_FunctionRestParameter = BoundNames_BindingRestElement; // 14.1.3 #sec-function-definitions-static-semantics-boundnames
  //   FormalParameters :
  //     [empty]
  //     FormalParameterList `,` FunctionRestParameter
  //
  //   FormalParameterList :
  //     FormalParameterList `,` FormalParameter
  //
  // (implicit)
  //   FormalParameters :
  //     FunctionRestParameter
  //     FormalParameterList
  //     FormalParameterList `,`
  //
  //   FormalParameterList : FormalParameter

  function BoundNames_FormalParameters(FormalParameters) {
    const names = [];

    for (const FormalParameterOrFunctionRestParameter of FormalParameters) {
      switch (true) {
        case isFormalParameter(FormalParameterOrFunctionRestParameter):
          names.push(...BoundNames_FormalParameter(FormalParameterOrFunctionRestParameter));
          break;

        case isFunctionRestParameter(FormalParameterOrFunctionRestParameter):
          names.push(...BoundNames_FunctionRestParameter(FormalParameterOrFunctionRestParameter));
          break;

        default:
          throw new OutOfRange('BoundNames_FormalParameters element', FormalParameterOrFunctionRestParameter);
      }
    }

    return names;
  } // 14.1.3 #sec-function-definitions-static-semantics-boundnames
  //   FunctionDeclaration :
  //     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
  //     `function` `(` FormalParameters `)` `{` FunctionBody `}`
  //
  // 14.4.2 #sec-generator-function-definitions-static-semantics-boundnames
  //   GeneratorDeclaration :
  //     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
  //     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
  //
  // 14.5.2 #sec-async-generator-function-definitions-static-semantics-boundnames
  //   AsyncGeneratorDeclaration :
  //     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  //     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  //
  // 14.7.2 #sec-async-function-definitions-static-semantics-BoundNames
  //   AsyncFunctionDeclaration :
  //     `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)`
  //       `{` AsyncFunctionBody `}`
  //     `async` [no LineTerminator here] `function` `(` FormalParameters `)`
  //       `{` AsyncFunctionBody `}`
  //
  // (implicit)
  //   HoistableDeclaration :
  //     FunctionDeclaration
  //     GeneratorDeclaration
  //     AsyncFunctionDeclaration
  //     AsyncGeneratorDeclaration

  function BoundNames_HoistableDeclaration(HoistableDeclaration) {
    if (HoistableDeclaration.id === null) {
      return ['*default*'];
    }

    return BoundNames_BindingIdentifier(HoistableDeclaration.id);
  }
  const BoundNames_FunctionDeclaration = BoundNames_HoistableDeclaration;
  //   ClassDeclaration :
  //     `class` BindingIdentifier ClassTail
  //     `class` ClassTail

  function BoundNames_ClassDeclaration(ClassDeclaration) {
    if (ClassDeclaration.id === null) {
      return ['*default*'];
    }

    return BoundNames_BindingIdentifier(ClassDeclaration.id);
  } // (implicit)
  //   Declaration :
  //     HoistableDeclaration
  //     ClassDeclaration
  //     LexicalDeclaration

  function BoundNames_Declaration(Declaration) {
    switch (true) {
      case isHoistableDeclaration(Declaration):
        return BoundNames_HoistableDeclaration(Declaration);

      case isClassDeclaration(Declaration):
        return BoundNames_ClassDeclaration(Declaration);

      case isLexicalDeclaration(Declaration):
        return BoundNames_LexicalDeclaration(Declaration);

      default:
        throw new OutOfRange('BoundNames_Declaration', Declaration);
    }
  } // (implict)
  //   ImportedBinding : BindingIdentifier

  const BoundNames_ImportedBinding = BoundNames_BindingIdentifier; // 15.2.2.2 #sec-imports-static-semantics-boundnames
  //   ImportDeclaration :
  //     `import` ImportClause FromClause `;`
  //     `import` ModuleSpecifier `;`

  function BoundNames_ImportDeclaration(ImportDeclaration) {
    switch (true) {
      case isImportDeclarationWithClause(ImportDeclaration):
        // return BoundNames_ImportClause(ImportDeclaration.specifiers);
        return ImportDeclaration.specfiers.map(s => s.local);

      case isImportDeclarationWithSpecifierOnly(ImportDeclaration):
        return [];

      default:
        throw new OutOfRange('BoundNames_ImportDeclaration', ImportDeclaration);
    }
  } // 15.2.3.2 #sec-exports-static-semantics-boundnames
  //   ExportDeclaration :
  //     `export` `*` FromClause `;`
  //     `export` ExportClause FromClause `;`
  //     `export` ExportClause `;`
  //     `export` VariableStatement
  //     `export` Declaration
  //     `export` `default` HoistableDeclaration
  //     `export` `default` ClassDeclaration
  //     `export` `default` AssignmentExpression `;`

  function BoundNames_ExportDeclaration(ExportDeclaration) {
    switch (true) {
      case isExportDeclarationWithStar(ExportDeclaration):
      case isExportDeclarationWithExportAndFrom(ExportDeclaration):
      case isExportDeclarationWithExport(ExportDeclaration):
        return [];

      case isExportDeclarationWithVariable(ExportDeclaration):
        return BoundNames_VariableStatement(ExportDeclaration.declaration);

      case isExportDeclarationWithDeclaration(ExportDeclaration):
        return BoundNames_Declaration(ExportDeclaration.declaration);

      case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
        {
          const declarationNames = BoundNames_HoistableDeclaration(ExportDeclaration.declaration);

          if (!declarationNames.includes('*default*')) {
            declarationNames.push('*default*');
          }

          return declarationNames;
        }

      case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
        {
          const declarationNames = BoundNames_ClassDeclaration(ExportDeclaration.declaration);

          if (!declarationNames.includes('*default*')) {
            declarationNames.push('*default*');
          }

          return declarationNames;
        }

      case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
        return ['*default*'];

      default:
        throw new OutOfRange('BoundNames_ExportDeclaration', ExportDeclaration);
    }
  } // (implicit)
  //   ModuleItem :
  //     ImportDeclaration
  //     ExportDeclaration
  //     StatementListItem
  //
  //   StatementListItem : Declaration

  function BoundNames_ModuleItem(ModuleItem) {
    switch (true) {
      case isImportDeclaration(ModuleItem):
        return BoundNames_ImportDeclaration(ModuleItem);

      case isExportDeclaration(ModuleItem):
        return BoundNames_ExportDeclaration(ModuleItem);

      case isDeclaration(ModuleItem):
        return BoundNames_Declaration(ModuleItem);

      default:
        throw new OutOfRange('BoundNames_ModuleItem', ModuleItem);
    }
  }

  // 14.6.3 #sec-static-semantics-constructormethod
  //   ClassElementList :
  //     ClassElement
  //     ClassElementList ClassElement
  function ConstructorMethod_ClassElementList(ClassElementList) {
    return ClassElementList.find(ClassElement => ClassElement.kind === 'constructor');
  } // (implicit)
  //   ClassBody : ClassElementList


  const ConstructorMethod_ClassBody = ConstructorMethod_ClassElementList;

  //   SingleNameBinding :
  //     BindingIdentifier
  //     BindingIdentifier Initializer

  function ContainsExpression_SingleNameBinding(SingleNameBinding) {
    switch (true) {
      case isBindingIdentifier(SingleNameBinding):
        return false;

      case isBindingIdentifierAndInitializer(SingleNameBinding):
        return true;

      default:
        throw new OutOfRange('ContainsExpression_SingleNameBinding', SingleNameBinding);
    }
  } // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
  //   BindingElement : BindingPattern Initializer
  //
  // (implicit)
  //   BindingElement :
  //     SingleNameBinding
  //     BindingPattern

  function ContainsExpression_BindingElement(BindingElement) {
    switch (true) {
      case isSingleNameBinding(BindingElement):
        return ContainsExpression_SingleNameBinding(BindingElement);

      case isBindingPattern(BindingElement):
        return ContainsExpression_BindingPattern(BindingElement);

      case isBindingPatternAndInitializer(BindingElement):
        return true;

      default:
        throw new OutOfRange('ContainsExpression_BindingElement', BindingElement);
    }
  } // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
  //   BindingRestElement :
  //     `...` BindingIdentifier
  //     `...` BindingPattern

  function ContainsExpression_BindingRestElement(BindingRestElement) {
    switch (true) {
      case isBindingIdentifier(BindingRestElement.argument):
        return false;

      case isBindingPattern(BindingRestElement.argument):
        return ContainsExpression_BindingPattern(BindingRestElement.argument);

      default:
        throw new OutOfRange('ContainsExpression_BindingRestElement', BindingRestElement);
    }
  } // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
  //   ArrayBindingPattern :
  //     `[` Elision `]`
  //     `[` Elision BindingRestElement `]`
  //     `[` BindingElementList `,` Elision `]`
  //     `[` BindingElementList `,` Elision BindingRestElement `]`
  //   BindingElementList : BindingElementList `,` BindingElisionElement
  //   BindingElisionElement : Elision BindingElement
  //
  // (implicit)
  //   BindingElementList : BindingElisionElement
  //   BindingElisionElement : BindingElement

  function ContainsExpression_ArrayBindingPattern(ArrayBindingPattern) {
    for (const BindingElisionElementOrBindingRestElement of ArrayBindingPattern.elements) {
      switch (true) {
        case BindingElisionElementOrBindingRestElement === null:
          // This is an elision.
          break;

        case isBindingElement(BindingElisionElementOrBindingRestElement):
          {
            const BindingElement = BindingElisionElementOrBindingRestElement;
            const has = ContainsExpression_BindingElement(BindingElement);
            if (has === true) return true;
            break;
          }

        case isBindingRestElement(BindingElisionElementOrBindingRestElement):
          {
            const BindingRestElement = BindingElisionElementOrBindingRestElement;
            const has = ContainsExpression_BindingRestElement(BindingRestElement);
            if (has === true) return true;
            break;
          }

        default:
          throw new OutOfRange('ContainsExpression_ArrayBindingPattern element', BindingElisionElementOrBindingRestElement);
      }
    }

    return false;
  } // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
  //   BindingProperty : PropertyName `:` BindingElement
  //
  // (implicit)
  //   BindingProperty : SingleNameBinding

  function ContainsExpression_BindingProperty(BindingProperty) {
    switch (true) {
      case isBindingPropertyWithColon(BindingProperty):
        {
          const has = BindingProperty.computed;
          if (has === true) return true;
          return ContainsExpression_BindingElement(BindingProperty.value);
        }

      case isBindingPropertyWithSingleNameBinding(BindingProperty):
        return ContainsExpression_SingleNameBinding(BindingProperty.value);

      default:
        throw new OutOfRange('ContainsExpression_BindingProperty', BindingProperty);
    }
  } // https://github.com/tc39/ecma262/pull/1301
  //   BindingRestProperty : `...` BindingIdentifier

  function ContainsExpression_BindingRestProperty(BindingRestProperty) {
    if (!isBindingIdentifier(BindingRestProperty.argument)) {
      throw new OutOfRange('ContainsExpression_BindingRestProperty argument', BindingRestProperty.argument);
    }

    return false;
  } // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
  //   ObjectBindingPattern : `{` `}`
  //
  //   BindingPropertyList : BindingPropertyList `,` BindingProperty
  //
  // (implicit)
  //   ObjectBindingPattern :
  //     `{` BindingRestProperty `}`
  //     `{` BindingPropertyList `}`
  //     `{` BindingPropertyList `,` `}`
  //
  //   BindingPropertyList : BindingProperty
  //
  // https://github.com/tc39/ecma262/pull/1301
  //   ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`

  function ContainsExpression_ObjectBindingPattern(ObjectBindingPattern) {
    for (const prop of ObjectBindingPattern.properties) {
      switch (true) {
        case isBindingProperty(prop):
          {
            const BindingProperty = prop;
            const has = ContainsExpression_BindingProperty(BindingProperty);
            if (has === true) return true;
            break;
          }

        case isBindingRestProperty(prop):
          {
            const BindingRestProperty = prop;
            const has = ContainsExpression_BindingRestProperty(BindingRestProperty);
            break;
          }

        default:
          throw new OutOfRange('ContainsExpression_ObjectBindingPattern property', prop);
      }
    }

    return false;
  } // (implicit)
  //   BindingPattern :
  //     ObjectBindingPattern
  //     ArrayBindingPattern

  function ContainsExpression_BindingPattern(BindingPattern) {
    switch (true) {
      case isObjectBindingPattern(BindingPattern):
        return ContainsExpression_ObjectBindingPattern(BindingPattern);

      case isArrayBindingPattern(BindingPattern):
        return ContainsExpression_ArrayBindingPattern(BindingPattern);

      default:
        throw new OutOfRange('ContainsExpression_BindingPattern', BindingPattern);
    }
  } // (implicit)
  //   FormalParameter : BindingElement


  const ContainsExpression_FormalParameter = ContainsExpression_BindingElement; // (implicit)
  //   FunctionRestParameter : BindingRestElement

  const ContainsExpression_FunctionRestParameter = ContainsExpression_BindingRestElement; // 14.1.5 #sec-function-definitions-static-semantics-containsexpression
  //   FormalParameters :
  //     [empty]
  //     FormalParameterList `,` FunctionRestParameter
  //
  //   FormalParameterList :
  //     FormalParameterList `,` FormalParameter
  //
  // (implicit)
  //   FormalParameters :
  //     FunctionRestParameter
  //     FormalParameterList
  //     FormalParameterList `,`
  //
  //   FormalParameterList : FormalParameter

  function ContainsExpression_FormalParameters(FormalParameters) {
    for (const FormalParameterOrFunctionRestParameter of FormalParameters) {
      switch (true) {
        case isFormalParameter(FormalParameterOrFunctionRestParameter):
          if (ContainsExpression_FormalParameter(FormalParameterOrFunctionRestParameter) === true) {
            return true;
          }

          break;

        case isFunctionRestParameter(FormalParameterOrFunctionRestParameter):
          if (ContainsExpression_FunctionRestParameter(FormalParameterOrFunctionRestParameter) === true) {
            return true;
          }

          break;

        default:
          throw new OutOfRange('ContainsExpression_FormalParameters element', FormalParameterOrFunctionRestParameter);
      }
    }

    return false;
  }

  //   FunctionBody : FunctionStatementList

  function ContainsUseStrict_FunctionBody(FunctionBody) {
    return directivePrologueContainsUseStrictDirective(FunctionBody);
  } // 14.2.5 #sec-arrow-function-definitions-static-semantics-containsusestrict

  // 13.1.4 #sec-static-semantics-declarationpart
  //   HoistableDeclaration :
  //     FunctionDeclaration
  //     GeneratorDeclaration
  //     AsyncFunctionDeclaration
  //     AsyncGeneratorDeclaration
  //   Declaration :
  //     ClassDeclaration
  //     LexicalDeclaration
  //
  // (implicit)
  //   Declaration : HoistableDeclaration
  //
  // What a weird set of static semantics
  function DeclarationPart_Declaration(Declaration) {
    return Declaration;
  }
  const DeclarationPart_HoistableDeclaration = DeclarationPart_Declaration;

  //   FormalParameters :
  //     [empty]
  //     FormalParameterList `,` FunctionRestParameter
  //
  //   FormalParameterList : FormalParameterList `,` FormalParameter
  //
  // (implicit)
  //   FormalParameters :
  //     FunctionRestParameter
  //     FormalParameterList
  //     FormalParameterList `,`
  //
  //   FormalParameterList : FormalParameter

  function ExpectedArgumentCount_FormalParameters(FormalParameters) {
    if (FormalParameters.length === 0) {
      return 0;
    }

    let count = 0;

    for (const FormalParameter of FormalParameters.slice(0, -1)) {
      Assert(isBindingElement(FormalParameter), "isBindingElement(FormalParameter)");
      const BindingElement = FormalParameter;

      if (HasInitializer_BindingElement(BindingElement)) {
        return count;
      }

      count += 1;
    }

    const last = FormalParameters[FormalParameters.length - 1];

    if (isFunctionRestParameter(last)) {
      return count;
    }

    Assert(isBindingElement(last), "isBindingElement(last)");

    if (HasInitializer_BindingElement(last)) {
      return count;
    }

    return count + 1;
  } // 14.2.6 #sec-arrow-function-definitions-static-semantics-expectedargumentcount
  //   ArrowParameters : BindingIdentifier
  //
  // (implicit)
  //   ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
  //   ArrowFormalParameters : `(` UniqueFormalParameters `)`
  //   UniqueFormalParameters : FormalParameters

  const ExpectedArgumentCount_ArrowParameters = ExpectedArgumentCount_FormalParameters; // 14.3.3 #sec-method-definitions-static-semantics-expectedargumentcount
  //   PropertySetParameterList : FormalParameter
  //
  // Not implemented. Use ExpectedArgumentCount_FormalParameters instead.
  // 14.8.6 #sec-async-arrow-function-definitions-static-semantics-ExpectedArgumentCount
  //   AsyncArrowBindingIdentifier : BindingIdentifier
  //
  // Not implemented. Use ExpectedArgumentCount_ArrowParameters instead.

  //   ExportList : ExportList `,` ExportSpecifier
  //
  // (implicit)
  //   ExportList : ExportSpecifier

  function ExportEntriesForModule_ExportList(ExportList, module) {
    const specs = [];

    for (const ExportSpecifier of ExportList) {
      specs.push(...ExportEntriesForModule_ExportSpecifier(ExportSpecifier, module));
    }

    return specs;
  } // 15.2.3.6 #sec-static-semantics-exportentriesformodule
  //   ExportClause : `{` `}`
  //
  // (implicit)
  //   ExportClause :
  //     `{` ExportList `}`
  //     `{` ExportList `,` `}`

  const ExportEntriesForModule_ExportClause = ExportEntriesForModule_ExportList; // 15.2.3.6 #sec-static-semantics-exportentriesformodule
  //   ExportSpecifier :
  //     IdentifierName
  //     IdentifierName `as` IdentifierName

  function ExportEntriesForModule_ExportSpecifier(ExportSpecifier, module) {
    const sourceName = new Value(ExportSpecifier.local.name);
    const exportName = new Value(ExportSpecifier.exported.name);
    let localName;
    let importName;

    if (module === Value.null) {
      localName = sourceName;
      importName = Value.null;
    } else {
      localName = Value.null;
      importName = sourceName;
    }

    return [new ExportEntryRecord({
      ModuleRequest: module,
      ImportName: importName,
      LocalName: localName,
      ExportName: exportName
    })];
  }

  //   ModuleItemList : ModuleItemList ModuleItem
  //
  // (implicit)
  //   ModuleItemList : ModuleItem

  function ModuleRequests_ModuleItemList(ModuleItemList) {
    const moduleNames = new Set();

    for (const ModuleItem of ModuleItemList) {
      for (const additionalName of ModuleRequests_ModuleItem(ModuleItem)) {
        moduleNames.add(additionalName);
      }
    }

    return [...moduleNames];
  } // (implicit)
  //   ModuleItem : StatementListItem
  //
  // (implicit)
  //   ModuleItem : ImportDeclaration
  //   ModuleItem : ExportDeclaration

  function ModuleRequests_ModuleItem(ModuleItem) {
    switch (true) {
      case isStatementListItem(ModuleItem):
        return [];

      case isImportDeclaration(ModuleItem):
        return ModuleRequests_ImportDeclaration(ModuleItem);

      case isExportDeclaration(ModuleItem):
        return ModuleRequests_ExportDeclaration(ModuleItem);

      default:
        throw new OutOfRange('ModuleRequests_ModuleItem', ModuleItem);
    }
  } // 15.2.2.5 #sec-imports-static-semantics-modulerequests
  //   ImportDeclaration : `import` ImportClause FromClause `;`

  function ModuleRequests_ImportDeclaration(ImportDeclaration) {
    const {
      source: FromClause
    } = ImportDeclaration;
    return ModuleRequests_FromClause(FromClause);
  } // 15.2.2.5 #sec-imports-static-semantics-modulerequests
  //   ModuleSpecifier : StringLiteral
  //
  // (implicit)
  //   FromClause : `from` ModuleSpecifier

  function ModuleRequests_FromClause(FromClause) {
    return [new Value(FromClause.value)];
  } // 15.2.3.9 #sec-exports-static-semantics-modulerequests
  //   ExportDeclaration :
  //     `export` `*` FromClause `;`
  //     `export` ExportClause FromClause `;`
  //     `export` ExportClause `;`
  //     `export` VariableStatement
  //     `export` Declaration
  //     `export` `default` HoistableDeclaration
  //     `export` `default` ClassDeclaration
  //     `export` `default` AssignmentExpression `;`

  function ModuleRequests_ExportDeclaration(ExportDeclaration) {
    switch (true) {
      case isExportDeclarationWithStar(ExportDeclaration):
      case isExportDeclarationWithExportAndFrom(ExportDeclaration):
        return ModuleRequests_FromClause(ExportDeclaration.source);

      case isExportDeclarationWithExport(ExportDeclaration):
      case isExportDeclarationWithVariable(ExportDeclaration):
      case isExportDeclarationWithDeclaration(ExportDeclaration):
      case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
      case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
      case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
        return [];

      default:
        throw new OutOfRange('ModuleRequests_ExportDeclaration', ExportDeclaration);
    }
  }

  //   ModuleItemList : ModuleItemList ModuleItem
  //
  // (implicit)
  //   ModuleItemList : ModuleItem

  function ExportEntries_ModuleItemList(ModuleItemList) {
    const entries = [];

    for (const ModuleItem of ModuleItemList) {
      entries.push(...ExportEntries_ModuleItem(ModuleItem));
    }

    return entries;
  } // (implicit)
  //   ModuleItem :
  //     ImportDeclaration
  //     StatementListItem
  //
  // (implicit)
  //   ModuleItem : ExportDeclaration

  function ExportEntries_ModuleItem(ModuleItem) {
    switch (true) {
      case isImportDeclaration(ModuleItem):
      case isStatementListItem(ModuleItem):
        return [];

      case isExportDeclaration(ModuleItem):
        return ExportEntries_ExportDeclaration(ModuleItem);

      default:
        throw new OutOfRange('ExportEntries_ModuleItem', ModuleItem);
    }
  } // 15.2.3.5 #sec-exports-static-semantics-exportentries
  //   ExportDeclaration :
  //     `export` `*` FromClause `;`
  //     `export` ExportClause FromClause `;`
  //     `export` ExportClause `;`
  //     `export` VariableStatement
  //     `export` Declaration
  //     `export` `default` HoistableDeclaration
  //     `export` `default` ClassDeclaration
  //     `export` `default` AssignmentExpression `;`

  function ExportEntries_ExportDeclaration(ExportDeclaration) {
    switch (true) {
      case isExportDeclarationWithStar(ExportDeclaration):
        {
          const FromClause = ExportDeclaration.source;
          const modules = ModuleRequests_FromClause(FromClause);
          Assert(modules.length === 1, "modules.length === 1");
          const [module] = modules;
          const entry = new ExportEntryRecord({
            ModuleRequest: module,
            ImportName: new Value('*'),
            LocalName: Value.null,
            ExportName: Value.null
          });
          return [entry];
        }

      case isExportDeclarationWithExportAndFrom(ExportDeclaration):
        {
          const {
            specifiers: ExportClause,
            source: FromClause
          } = ExportDeclaration;
          const modules = ModuleRequests_FromClause(FromClause);
          Assert(modules.length === 1, "modules.length === 1");
          const [module] = modules;
          return ExportEntriesForModule_ExportClause(ExportClause, module);
        }

      case isExportDeclarationWithExport(ExportDeclaration):
        {
          const ExportClause = ExportDeclaration.specifiers;
          return ExportEntriesForModule_ExportClause(ExportClause, Value.null);
        }

      case isExportDeclarationWithVariable(ExportDeclaration):
        {
          const VariableStatement = ExportDeclaration.declaration;
          const entries = [];
          const names = BoundNames_VariableStatement(VariableStatement);

          for (const name of names) {
            entries.push(new ExportEntryRecord({
              ModuleRequest: Value.null,
              ImportName: Value.null,
              LocalName: new Value(name),
              ExportName: new Value(name)
            }));
          }

          return entries;
        }

      case isExportDeclarationWithDeclaration(ExportDeclaration):
        {
          const Declaration = ExportDeclaration.declaration;
          const entries = [];
          const names = BoundNames_Declaration(Declaration);

          for (const name of names) {
            entries.push(new ExportEntryRecord({
              ModuleRequest: Value.null,
              ImportName: Value.null,
              LocalName: new Value(name),
              ExportName: new Value(name)
            }));
          }

          return entries;
        }

      case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
        {
          const HoistableDeclaration = ExportDeclaration.declaration;
          const names = BoundNames_HoistableDeclaration(HoistableDeclaration);
          Assert(names.length === 1, "names.length === 1");
          const [localName] = names;
          return [new ExportEntryRecord({
            ModuleRequest: Value.null,
            ImportName: Value.null,
            LocalName: new Value(localName),
            ExportName: new Value('default')
          })];
        }

      case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
        {
          const ClassDeclaration = ExportDeclaration.declaration;
          const names = BoundNames_ClassDeclaration(ClassDeclaration);
          Assert(names.length === 1, "names.length === 1");
          const [localName] = names;
          return [new ExportEntryRecord({
            ModuleRequest: Value.null,
            ImportName: Value.null,
            LocalName: new Value(localName),
            ExportName: new Value('default')
          })];
        }

      case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
        return [new ExportEntryRecord({
          ModuleRequest: Value.null,
          ImportName: Value.null,
          LocalName: new Value('*default*'),
          ExportName: new Value('default')
        })];

      default:
        throw new OutOfRange('ExportEntries_ExportDeclaration', ExportDeclaration);
    }
  }

  //   SingleNameBinding :
  //     BindingIdentifier
  //     BindingIdentifier Initializer

  function HasInitializer_SingleNameBinding(SingleNameBinding) {
    switch (true) {
      case isBindingIdentifier(SingleNameBinding):
        return false;

      case isBindingIdentifierAndInitializer(SingleNameBinding):
        return true;

      default:
        throw new OutOfRange('HasInitializer_SingleNameBinding', SingleNameBinding);
    }
  } // 13.3.3.3 #sec-destructuring-binding-patterns-static-semantics-hasinitializer
  //   BindingElement :
  //     BindingPattern
  //     BindingPattern Initializer
  //
  // (implicit)
  //   BindingElement : SingleNameBinding

  function HasInitializer_BindingElement(BindingElement) {
    switch (true) {
      case isBindingPattern(BindingElement):
        return false;

      case isBindingPatternAndInitializer(BindingElement):
        return true;

      case isSingleNameBinding(BindingElement):
        return HasInitializer_SingleNameBinding(BindingElement);

      default:
        throw new OutOfRange('HasInitializer_BindingElement', BindingElement);
    }
  } // 14.1.8 #sec-function-definitions-static-semantics-hasinitializer
  //   FormalParameterList : FormalParameterList `,` FormalParameter
  // is implemented directly as part of ExpectedArgumentCount for FormalParameters.

  //   PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
  //
  // 14.1.9 #sec-function-definitions-static-semantics-hasname
  //   FunctionExpression :
  //     `function` `(` FormalParameters `)` `{` FunctionBody `}`
  //     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
  //
  // 14.2.7 #sec-arrow-function-definitions-static-semantics-hasname
  //   ArrowFunction : ArrowParameters `=>` ConciseBody
  //
  // 14.4.6 #sec-generator-function-definitions-static-semantics-hasname
  //   GeneratorExpression :
  //     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
  //     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
  //
  // 14.5.6 #sec-async-generator-function-definitions-static-semantics-hasname
  //   AsyncGeneratorExpression :
  //     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  //     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  //
  // 14.6.6 #sec-class-definitions-static-semantics-hasname
  //   ClassExpression :
  //     `class` ClassTail
  //     `class` BindingIdentifier ClassTail
  //
  // 14.7.6 #sec-async-function-definitions-static-semantics-HasName
  //   AsyncFunctionExpression :
  //     `async` [no LineTerminator here] `function` `(` FormalParameters `)`
  //       `{` AsyncFunctionBody `}`
  //     `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)`
  //       `{` AsyncFunctionBody `}`
  //
  // 14.8.7 #sec-async-arrow-function-definitions-static-semantics-HasName
  //   AsyncArrowFunction:
  //     `async` [no LineTerminator here] AsyncArrowBindingIdentifier [no LineTerminator here]
  //       `=>` AsyncConciseBody
  //     CoverCallExpressionAndAsyncArrowHead [no LineTerminator here] `=>` AsyncConciseBody
  //
  // (implicit)
  //   ParenthesizedExpression : `(` Expression `)`
  //
  //   PrimaryExpression :
  //     FunctionExpression
  //     ClassExpression
  //     GeneratorExpression
  //     AsyncFunctionExpression
  //     AsyncGeneratorExpression
  //     ArrowFunction
  //
  //   MemberExpression : PrimaryExpression
  //
  //   (From MemberExpression to ConditionalExpression omitted.)
  //
  //   AssignmentExpression :
  //     ConditionalExpression
  //     ArrowFunction
  //     AsyncArrowFunction
  //
  //   Expression : AssignmentExpression

  function HasName_Expression(Expression) {
    switch (true) {
      case isFunctionExpression(Expression):
      case isGeneratorExpression(Expression):
      case isAsyncGeneratorExpression(Expression):
      case isClassExpression(Expression):
      case isAsyncFunctionExpression(Expression):
        return Expression.id !== null;

      case isArrowFunction(Expression):
      case isAsyncArrowFunction(Expression):
        return false;

      case isParenthesizedExpression(Expression):
        {
          const expr = Expression.expression;

          if (!IsFunctionDefinition_Expression(expr)) {
            return false;
          }

          return HasName_Expression(expr);
        }

      default:
        throw new OutOfRange('HasName_Expression', Expression);
    }
  }

  //   ImportClause :
  //     ImportedDefaultBinding `,` NameSpaceImport
  //     ImportedDefaultBinding `,` NamedImports
  //
  //   NamedImports : `{` `}`
  //
  //   ImportsList : ImportsList `,` ImportSpecifier
  //
  // (implicit)
  //   ImportClause :
  //     ImportedDefaultBinding
  //     NameSpaceImport
  //     NamedImports
  //
  //   NamedImports :
  //     `{` ImportsList `}`
  //     `{` ImportsList `,` `}`
  //
  //   ImportsList : ImportSpecifier

  function ImportEntriesForModule_ImportClause(ImportClause, module) {
    const entries = [];

    for (const binding of ImportClause) {
      switch (true) {
        case isImportedDefaultBinding(binding):
          entries.push(...ImportEntriesForModule_ImportedDefaultBinding(binding, module));
          break;

        case isNameSpaceImport(binding):
          entries.push(...ImportEntriesForModule_NameSpaceImport(binding, module));
          break;

        case isImportSpecifier(binding):
          entries.push(...ImportEntriesForModule_ImportSpecifier(binding, module));
          break;

        default:
          throw new OutOfRange('ImportEntriesForModule_ImportClause binding', binding);
      }
    }

    return entries;
  } // 15.2.2.4 #sec-static-semantics-importentriesformodule
  //   ImportedDefaultBinding : ImportedBinding

  function ImportEntriesForModule_ImportedDefaultBinding(ImportedDefaultBinding, module) {
    const ImportedBinding = ImportedDefaultBinding.local;
    const localNames = BoundNames_ImportedBinding(ImportedBinding);
    Assert(localNames.length === 1, "localNames.length === 1");
    const [localName] = localNames;
    const defaultEntry = new ImportEntryRecord({
      ModuleRequest: module,
      ImportName: new Value('default'),
      LocalName: new Value(localName)
    });
    return [defaultEntry];
  } // 15.2.2.4 #sec-static-semantics-importentriesformodule
  //   NameSpaceImport : `*` `as` ImportedBinding

  function ImportEntriesForModule_NameSpaceImport(NameSpaceImport, module) {
    const ImportedBinding = NameSpaceImport.local;
    const localNames = BoundNames_ImportedBinding(ImportedBinding);
    Assert(localNames.length === 1, "localNames.length === 1");
    const [localName] = localNames;
    const entry = new ImportEntryRecord({
      ModuleRequest: module,
      ImportName: new Value('*'),
      LocalName: new Value(localName)
    });
    return [entry];
  } // 15.2.2.4 #sec-static-semantics-importentriesformodule
  //   ImportSpecifier :
  //     ImportedBinding
  //     IdentifierName `as` ImportedBinding

  function ImportEntriesForModule_ImportSpecifier(ImportSpecifier, module) {
    const {
      imported: IdentifierName,
      local: ImportedBinding
    } = ImportSpecifier;
    const importName = IdentifierName.name;
    const localName = ImportedBinding.name;
    const entry = new ImportEntryRecord({
      ModuleRequest: module,
      ImportName: new Value(importName),
      LocalName: new Value(localName)
    });
    return [entry];
  }

  //   ModuleItemList : ModuleItemList ModuleItem
  //
  // (implicit)
  //   ModuleItemList : ModuleItem

  function ImportEntries_ModuleItemList(ModuleItemList) {
    const entries = [];

    for (const ModuleItem of ModuleItemList) {
      entries.push(...ImportEntries_ModuleItem(ModuleItem));
    }

    return entries;
  } // (implicit)
  //   ModuleItem :
  //     ExportDeclaration
  //     StatementListItem
  //
  // (implicit)
  //   ModuleItem : ImportDeclaration

  function ImportEntries_ModuleItem(ModuleItem) {
    switch (true) {
      case isExportDeclaration(ModuleItem):
      case isStatementListItem(ModuleItem):
        return [];

      case isImportDeclaration(ModuleItem):
        return ImportEntries_ImportDeclaration(ModuleItem);

      default:
        throw new OutOfRange('ImportEntries_ModuleItem', ModuleItem);
    }
  } // 15.2.2.3 #sec-imports-static-semantics-importentries
  //   ImportDeclaration :
  //     `import` ImportClause FromClause `;`
  //     `import` ModuleSpecifier `;`

  function ImportEntries_ImportDeclaration(ImportDeclaration) {
    switch (true) {
      case isImportDeclarationWithClause(ImportDeclaration):
        {
          const {
            specifiers: ImportClause,
            source: FromClause
          } = ImportDeclaration;
          const reqs = ModuleRequests_FromClause(FromClause);
          Assert(reqs.length === 1, "reqs.length === 1");
          const [module] = reqs;
          return ImportEntriesForModule_ImportClause(ImportClause, module);
        }

      case isImportDeclarationWithSpecifierOnly(ImportDeclaration):
        return [];

      default:
        throw new OutOfRange('ImportEntries_ImportDeclaration', ImportDeclaration);
    }
  }

  // 15.2.1.9 #sec-importedlocalnames
  function ImportedLocalNames(importEntries) {
    const localNames = [];

    for (const i of importEntries) {
      localNames.push(i.LocalName);
    }

    return localNames;
  }

  function IsAnonymousFunctionDefinition(expr) {
    if (IsFunctionDefinition_Expression(expr) === false) {
      return false;
    }

    const hasName = HasName_Expression(expr);

    if (hasName === true) {
      return false;
    }

    return true;
  }

  function IsConstantDeclaration(node) {
    return node.kind === 'const';
  }

  //   MemberExpression :
  //     PrimaryExpression
  //     MemberExpression `[` Expression `]`
  //     MemberExpression `.` IdentifierName
  //     MemberExpression TemplateLiteral
  //     SuperProperty
  //     MetaProperty
  //     `new` MemberExpression Arguments
  //
  //   NewExpression : `new` NewExpression
  //
  //   LeftHandSideExpression : CallExpression
  //
  // (implicit)
  //   NewExpression : MemberExpression
  //
  //   LeftHandSideExpression : NewExpression

  function IsDestructuring_LeftHandSideExpression(LeftHandSideExpression) {
    switch (true) {
      case isExpression(LeftHandSideExpression):
        Assert(!isBindingPattern(LeftHandSideExpression), "!isBindingPattern(LeftHandSideExpression)");
        return false;

      case isBindingPattern(LeftHandSideExpression):
        return true;

      default:
        throw new OutOfRange('IsDestructuring_LeftHandSideExpression', LeftHandSideExpression);
    }
  } // 13.7.5.6 #sec-for-in-and-for-of-statements-static-semantics-isdestructuring
  //   ForDeclaration : LetOrConst ForBinding

  function IsDestructuring_ForDeclaration(ForDeclaration) {
    return IsDestructuring_ForBinding(ForDeclaration.declarations[0].id);
  } // 13.7.5.6 #sec-for-in-and-for-of-statements-static-semantics-isdestructuring
  //   ForBinding :
  //     BindingIdentifier
  //     BindingPattern

  function IsDestructuring_ForBinding(ForBinding) {
    switch (true) {
      case isBindingIdentifier(ForBinding):
        return false;

      case isBindingPattern(ForBinding):
        return true;

      default:
        throw new OutOfRange('IsDestructuring_ForBinding', ForBinding);
    }
  }

  // for this static semantic:
  //
  // 12.15.2 #sec-assignment-operators-static-semantics-isfunctiondefinition
  //   AssignmentExpression :
  //     ArrowFunction
  //     AsyncArrowFunction
  //
  // 14.1.12 #sec-function-definitions-static-semantics-isfunctiondefinition
  //   FunctionExpression :
  //     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
  //
  // 14.4.8 #sec-generator-function-definitions-static-semantics-isfunctiondefinition
  //   GeneratorExpression :
  //     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
  //
  // 14.5.8 #sec-async-generator-function-definitions-static-semantics-isfunctiondefinition
  //   AsyncGeneratorExpression :
  //     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  //
  // 14.6.8 #sec-class-definitions-static-semantics-isfunctiondefinition
  //   ClassExpression : `class` BindingIdentifier_opt ClassTail
  //
  // 14.7.8 #sec-async-function-definitions-static-semantics-IsFunctionDefinition
  //   AsyncFunctionExpression :
  //     `async` [no LineTerminator here] `function` `(` FormalParameters `)`
  //       `{` AsyncFunctionBody `}`
  //     `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)`
  //       `{` AsyncFunctionBody `}`
  //
  // The following sections contain other special cases for
  // ParenthesizedExpressions:
  //
  // 12.2.1.3 #sec-semantics-static-semantics-isfunctiondefinition
  //   PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
  //
  // 12.2.10.2 #sec-grouping-operator-static-semantics-isfunctiondefinition
  //   ParenthesizedExpression : `(` Expression `)`
  //
  // All other explicit and implicit productions return false, including those
  // specified at the following anchors:
  //
  // 12.2.1.3 #sec-semantics-static-semantics-isfunctiondefinition
  // 12.3.1.3 #sec-static-semantics-static-semantics-isfunctiondefinition
  // 12.4.2 #sec-update-expressions-static-semantics-isfunctiondefinition
  // 12.5.1 #sec-unary-operators-static-semantics-isfunctiondefinition
  // 12.6.1 #sec-exp-operator-static-semantics-isfunctiondefinition
  // 12.7.1 #sec-multiplicative-operators-static-semantics-isfunctiondefinition
  // 12.8.1 #sec-additive-operators-static-semantics-isfunctiondefinition
  // 12.9.1 #sec-bitwise-shift-operators-static-semantics-isfunctiondefinition
  // 12.10.1 #sec-relational-operators-static-semantics-isfunctiondefinition
  // 12.11.1 #sec-equality-operators-static-semantics-isfunctiondefinition
  // 12.12.1 #sec-binary-bitwise-operators-static-semantics-isfunctiondefinition
  // 12.13.1 #sec-binary-logical-operators-static-semantics-isfunctiondefinition
  // 12.14.1 #sec-conditional-operator-static-semantics-isfunctiondefinition
  // 12.15.2 #sec-assignment-operators-static-semantics-isfunctiondefinition
  // 12.16.1 #sec-comma-operator-static-semantics-isfunctiondefinition

  function IsFunctionDefinition_Expression(Expression) {
    if (isParenthesizedExpression(Expression)) {
      const expr = Expression.expression;
      return IsFunctionDefinition_Expression(expr);
    }

    return isArrowFunction(Expression) || isAsyncArrowFunction(Expression) || isFunctionExpression(Expression) || isGeneratorExpression(Expression) || isAsyncGeneratorExpression(Expression) || isClassExpression(Expression) || isAsyncFunctionExpression(Expression);
  }

  //   PrimaryExpression :
  //     IdentifierReference
  //     ... (omitted)
  //
  // 12.3.1.5 #sec-static-semantics-static-semantics-isidentifierref
  //   ... (omitted)

  function IsIdentifierRef(node) {
    return isIdentifierReference(node);
  }

  //   BindingElement :
  //     BindingPattern
  //     BindingPattern Initializer
  //
  // (implicit)
  //   BindingElement : SingleNameBinding

  function IsSimpleParameterList_BindingElement(BindingElement) {
    switch (true) {
      case isSingleNameBinding(BindingElement):
        return IsSimpleParameterList_SingleNameBinding(BindingElement);

      case isBindingPattern(BindingElement):
      case isBindingPatternAndInitializer(BindingElement):
        return false;

      default:
        throw new OutOfRange('IsSimpleParameterList_BindingElement', BindingElement);
    }
  } // 13.3.3.4 #sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist
  //   SingleNameBinding :
  //     BindingIdentifier
  //     BindingIdentifier Initializer

  function IsSimpleParameterList_SingleNameBinding(SingleNameBinding) {
    switch (true) {
      case isBindingIdentifier(SingleNameBinding):
        return true;

      case isBindingIdentifierAndInitializer(SingleNameBinding):
        return false;

      default:
        throw new OutOfRange('IsSimpleParameterList_SingleNameBinding', SingleNameBinding);
    }
  } // 14.1.13 #sec-function-definitions-static-semantics-issimpleparameterlist
  //   FormalParameters :
  //     [empty]
  //     FormalParameterList `,` FunctionRestParameter
  //
  // (implicit)
  //   FormalParameters :
  //     FormalParameterList
  //     FormalParameterList `,`
  //
  // https://github.com/tc39/ecma262/pull/1301
  //   FormalParameters : FunctionRestParameter

  function IsSimpleParameterList_FormalParameters(FormalParameters) {
    if (FormalParameters.length === 0) {
      return true;
    }

    if (isFunctionRestParameter(FormalParameters[FormalParameters.length - 1])) {
      return false;
    }

    return IsSimpleParameterList_FormalParameterList(FormalParameters);
  } // 14.1.13 #sec-function-definitions-static-semantics-issimpleparameterlist
  //   FormalParameterList :
  //     FormalParameter
  //     FormalParameterList `,` FormalParameter

  function IsSimpleParameterList_FormalParameterList(FormalParameterList) {
    for (const FormalParameter of FormalParameterList) {
      if (IsSimpleParameterList_FormalParameter(FormalParameter) === false) {
        return false;
      }
    }

    return true;
  } // TODO(TimothyGu): does not need to be explicitly declared
  // 14.1.13 #sec-function-definitions-static-semantics-issimpleparameterlist
  //   FormalParameter : BindingElement

  const IsSimpleParameterList_FormalParameter = IsSimpleParameterList_BindingElement;

  // 14.6.9 #sec-static-semantics-isstatic
  //   ClassElement :
  //     MethodDefinition
  //     `static` MethodDefinition
  //     `;`
  function IsStatic_ClassElement(ClassElement) {
    return ClassElement.static;
  }

  function IsStrict(node) {
    return isStrictModeCode(node);
  }

  //   StatementList : StatementList StatementListItem
  //
  // (implicit)
  //   StatementList : StatementListItem

  function TopLevelLexicallyDeclaredNames_StatementList(StatementList) {
    const names = [];

    for (const StatementListItem of StatementList) {
      names.push(...TopLevelLexicallyDeclaredNames_StatementListItem(StatementListItem));
    }

    return names;
  } // 13.2.7 #sec-block-static-semantics-toplevellexicallydeclarednames
  //   StatementListItem :
  //     Statement
  //     Declaration

  function TopLevelLexicallyDeclaredNames_StatementListItem(StatementListItem) {
    switch (true) {
      case isStatement(StatementListItem):
        return [];

      case isDeclaration(StatementListItem):
        if (isHoistableDeclaration(StatementListItem)) {
          return [];
        }

        return BoundNames_Declaration(StatementListItem);

      default:
        throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
    }
  }

  //   StatementList : StatementList StatementListItem

  function TopLevelVarDeclaredNames_StatementList(StatementList) {
    const names = [];

    for (const StatementListItem of StatementList) {
      names.push(...TopLevelVarDeclaredNames_StatementListItem(StatementListItem));
    }

    return names;
  } // 13.2.9 #sec-block-static-semantics-toplevelvardeclarednames
  //   StatementListItem :
  //     Declaration
  //     Statement

  function TopLevelVarDeclaredNames_StatementListItem(StatementListItem) {
    switch (true) {
      case isDeclaration(StatementListItem):
        if (isHoistableDeclaration(StatementListItem)) {
          return BoundNames_HoistableDeclaration(StatementListItem);
        }

        return [];

      case isStatement(StatementListItem):
        if (isLabelledStatement(StatementListItem)) {
          return TopLevelVarDeclaredNames_LabelledStatement(StatementListItem);
        }

        return VarDeclaredNames_Statement(StatementListItem);

      default:
        throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
    }
  } // 13.13.10 #sec-labelled-statements-static-semantics-toplevelvardeclarednames
  //   LabelledStatement : LabelIdentifier `:` LabelledItem

  function TopLevelVarDeclaredNames_LabelledStatement(LabelledStatement) {
    return TopLevelVarDeclaredNames_LabelledItem(LabelledStatement.body);
  } // 13.13.10 #sec-labelled-statements-static-semantics-toplevelvardeclarednames
  //   LabelledItem :
  //     Statement
  //     FunctionDeclaration

  function TopLevelVarDeclaredNames_LabelledItem(LabelledItem) {
    switch (true) {
      case isStatement(LabelledItem):
        if (isLabelledStatement(LabelledItem)) {
          return TopLevelVarDeclaredNames_LabelledItem(LabelledItem.body);
        }

        return VarDeclaredNames_Statement(LabelledItem);

      case isFunctionDeclaration(LabelledItem):
        return BoundNames_FunctionDeclaration(LabelledItem);

      default:
        throw new TypeError(`Unexpected LabelledItem: ${LabelledItem.type}`);
    }
  }

  //   Statement :
  //     EmptyStatement
  //     ExpressionStatement
  //     ContinueStatement
  //     ContinueStatement
  //     BreakStatement
  //     ReturnStatement
  //     ThrowStatement
  //     DebuggerStatement
  //
  // (implicit)
  //   Statement :
  //     BlockStatement
  //     VariableStatement
  //     IfStatement
  //     BreakableStatement
  //     WithStatement
  //     LabelledStatement
  //     TryStatement
  //   BreakableStatement :
  //     IterationStatement
  //     SwitchStatement

  function VarDeclaredNames_Statement(Statement) {
    switch (true) {
      case isEmptyStatement(Statement):
      case isExpressionStatement(Statement):
      case isContinueStatement(Statement):
      case isBreakStatement(Statement):
      case isReturnStatement(Statement):
      case isThrowStatement(Statement):
      case isDebuggerStatement(Statement):
        return [];

      case isBlockStatement(Statement):
        return VarDeclaredNames_BlockStatement(Statement);

      case isVariableStatement(Statement):
        return VarDeclaredNames_VariableStatement(Statement);

      case isIfStatement(Statement):
        return VarDeclaredNames_IfStatement(Statement);

      case isWithStatement(Statement):
        return VarDeclaredNames_WithStatement(Statement);

      case isLabelledStatement(Statement):
        return VarDeclaredNames_LabelledStatement(Statement);

      case isTryStatement(Statement):
        return VarDeclaredNames_TryStatement(Statement);

      case isIterationStatement(Statement):
        return VarDeclaredNames_IterationStatement(Statement);

      case isSwitchStatement(Statement):
        return VarDeclaredNames_SwitchStatement(Statement);

      default:
        throw new TypeError(`Invalid Statement: ${Statement.type}`);
    }
  } // 13.2.11 #sec-block-static-semantics-vardeclarednames
  //   StatementList : StatementList StatementListItem
  //
  // (implicit)
  //   StatementList : StatementListItem

  function VarDeclaredNames_StatementList(StatementList) {
    const names = [];

    for (const StatementListItem of StatementList) {
      names.push(...VarDeclaredNames_StatementListItem(StatementListItem));
    }

    return names;
  } // 13.2.11 #sec-block-static-semantics-vardeclarednames
  //   Block : `{` `}`
  //
  // (implicit)
  //   Block : `{` StatementList `}`

  function VarDeclaredNames_Block(Block) {
    return VarDeclaredNames_StatementList(Block.body);
  } // (implicit)
  //   BlockStatement : Block

  const VarDeclaredNames_BlockStatement = VarDeclaredNames_Block; // 13.2.11 #sec-block-static-semantics-vardeclarednames
  //   StatementListItem : Declaration
  //
  // (implicit)
  //   StatementListItem : Statement

  function VarDeclaredNames_StatementListItem(StatementListItem) {
    switch (true) {
      case isDeclaration(StatementListItem):
        return [];

      case isStatement(StatementListItem):
        return VarDeclaredNames_Statement(StatementListItem);

      default:
        throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
    }
  } // 13.3.2.2 #sec-variable-statement-static-semantics-vardeclarednames
  //   VariableStatement : `var` VariableDeclarationList `;`

  const VarDeclaredNames_VariableStatement = BoundNames_VariableStatement; // 13.6.5 #sec-if-statement-static-semantics-vardeclarednames
  //   IfStatement :
  //     `if` `(` Expression `)` Statement `else` Statement
  //     `if` `(` Expression `)` Statement

  function VarDeclaredNames_IfStatement(IfStatement) {
    if (IfStatement.alternate) {
      return [...VarDeclaredNames_Statement(IfStatement.consequent), ...VarDeclaredNames_Statement(IfStatement.alternate)];
    }

    return VarDeclaredNames_Statement(IfStatement.consequent);
  } // 13.7.2.4 #sec-do-while-statement-static-semantics-vardeclarednames
  //   IterationStatement : `do` Statement `while` `(` Expression `)` `;`
  //
  // 13.7.3.4 #sec-while-statement-static-semantics-vardeclarednames
  //   IterationStatement : `while` `(` Expression `)` Statement
  //
  // 13.7.4.5 #sec-for-statement-static-semantics-vardeclarednames
  //   IterationStatement :
  //     `for` `(` Expression `;` Expression `;` Expression `)` Statement
  //     `for` `(` `var` VariableDeclarationList `;` Expression `;` Expression `)` Statement
  //     `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
  //
  // 13.7.5.7 #sec-for-in-and-for-of-statements-static-semantics-vardeclarednames
  //   IterationStatement :
  //     `for` `(` LeftHandSideExpression `in` Expression `)` Statement
  //     `for` `(` `var` ForBinding `in` Expression `)` Statement
  //     `for` `(` ForDeclaration `in` Expression `)` Statement
  //     `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
  //     `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
  //     `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  //     `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  //     `for` `(` ForDeclaration `of` Expression `)` Statement
  //     `for` `await` `(` ForDeclaration `of` Expression `)` Statement

  function VarDeclaredNames_IterationStatement(IterationStatement) {
    let namesFromBinding = [];

    switch (IterationStatement.type) {
      case 'DoWhileStatement':
      case 'WhileStatement':
        break;

      case 'ForStatement':
        if (IterationStatement.init && isVariableStatement(IterationStatement.init)) {
          const VariableDeclarationList = IterationStatement.init.declarations;
          namesFromBinding = BoundNames_VariableDeclarationList(VariableDeclarationList);
        }

        break;

      case 'ForInStatement':
      case 'ForOfStatement':
        // https://github.com/tc39/ecma262/pull/1284
        if (isVariableStatement(IterationStatement.left)) {
          const ForBinding = IterationStatement.left.declarations[0].id;
          namesFromBinding = BoundNames_ForBinding(ForBinding);
        }

        break;

      default:
        throw new TypeError(`Invalid IterationStatement: ${IterationStatement.type}`);
    }

    return [...namesFromBinding, ...VarDeclaredNames_Statement(IterationStatement.body)];
  } // 13.11.6 #sec-with-statement-static-semantics-varscopeddeclarations
  //   WithStatement : `with` `(` Expression `)` Statement

  function VarDeclaredNames_WithStatement(WithStatement) {
    return VarDeclaredNames_Statement(WithStatement.body);
  } // 13.12.7 #sec-switch-statement-static-semantics-vardeclarednames
  //   SwitchStatement : `switch` `(` Expression `)` CaseBlock

  function VarDeclaredNames_SwitchStatement(SwitchStatement) {
    return VarDeclaredNames_CaseBlock(SwitchStatement.cases);
  } // 13.12.7 #sec-switch-statement-static-semantics-vardeclarednames
  //   CaseBlock :
  //     `{` `}`
  //     `{` CaseClauses_opt DefaultClause CaseClauses_opt `}`
  //   CaseClauses : CaseClauses CaseClause
  //   CaseClause : `case` Expression `:` StatementList_opt
  //   DefaultClause : `default` `:` StatementList_opt
  //
  // (implicit)
  //   CaseBlock : `{` CaseClauses `}`
  //   CaseClauses : CaseClause

  function VarDeclaredNames_CaseBlock(CaseBlock) {
    const names = [];

    for (const CaseClauseOrDefaultClause of CaseBlock) {
      names.push(...VarDeclaredNames_StatementList(CaseClauseOrDefaultClause.consequent));
    }

    return names;
  } // 13.13.12 #sec-labelled-statements-static-semantics-vardeclarednames
  //   LabelledStatement : LabelIdentifier `:` LabelledItem
  //   LabelledItem : FunctionDeclaration
  //
  // (implicit)
  //   LabelledItem : Statement

  function VarDeclaredNames_LabelledStatement(LabelledStatement) {
    const LabelledItem = LabelledStatement.body;

    switch (true) {
      case isFunctionDeclaration(LabelledItem):
        return [];

      case isStatement(LabelledItem):
        return VarDeclaredNames_Statement(LabelledItem);

      default:
        throw new TypeError(`Invalid LabelledItem: ${LabelledItem.type}`);
    }
  } // 13.15.5 #sec-try-statement-static-semantics-vardeclarednames
  //   TryStatement :
  //     `try` Block Catch
  //     `try` Block Finally
  //     `try` Block Catch Finally
  //   Catch : `catch` `(` CatchParameter `)` Block
  //
  // (implicit)
  //   Catch : `catch` Block
  //   Finally : `finally` Block

  function VarDeclaredNames_TryStatement(TryStatement) {
    const namesBlock = VarDeclaredNames_Block(TryStatement.block);
    const namesCatch = TryStatement.handler !== null ? VarDeclaredNames_Block(TryStatement.handler.body) : [];
    const namesFinally = TryStatement.finalizer !== null ? VarDeclaredNames_Block(TryStatement.finalizer) : [];
    return [...namesBlock, ...namesCatch, ...namesFinally];
  } // 14.1.16 #sec-function-definitions-static-semantics-vardeclarednames
  //   FunctionStatementList :
  //     [empty]
  //     StatementList

  const VarDeclaredNames_FunctionStatementList = TopLevelVarDeclaredNames_StatementList; // (implicit)
  //   FunctionBody : FunctionStatementList

  const VarDeclaredNames_FunctionBody = VarDeclaredNames_FunctionStatementList; // (implicit)
  //   GeneratorBody : FunctionBody

  const VarDeclaredNames_GeneratorBody = VarDeclaredNames_FunctionBody; // (implicit)
  //   AsyncFunctionBody : FunctionBody

  const VarDeclaredNames_AsyncFunctionBody = VarDeclaredNames_FunctionBody; // 14.2.12 #sec-arrow-function-definitions-static-semantics-vardeclarednames
  //   ConciseBody : ExpressionBody
  //
  // (implicit)
  //   ConciseBody : `{` FunctionBody `}`

  function VarDeclaredNames_ConciseBody(ConciseBody) {
    switch (true) {
      case isExpressionBody(ConciseBody):
        return [];

      case isBlockStatement(ConciseBody):
        return VarDeclaredNames_FunctionBody(ConciseBody.body);

      default:
        throw new TypeError(`Unexpected ConciseBody: ${ConciseBody.type}`);
    }
  } // 14.8.11 #sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames
  //   ScriptBody : StatementList

  const VarDeclaredNames_ScriptBody = TopLevelVarDeclaredNames_StatementList; // (implicit)

  //   FunctionStatementList :
  //     [empty]
  //     StatementList

  const LexicallyDeclaredNames_FunctionStatementList = TopLevelLexicallyDeclaredNames_StatementList; // (implicit)
  //   FunctionBody : FunctionStatementList

  const LexicallyDeclaredNames_FunctionBody = LexicallyDeclaredNames_FunctionStatementList; // (implicit)
  //   GeneratorBody : FunctionBody

  const LexicallyDeclaredNames_GeneratorBody = LexicallyDeclaredNames_FunctionBody; // (implicit)
  //   AsyncFunctionBody : FunctionBody

  const LexicallyDeclaredNames_AsyncFunctionBody = LexicallyDeclaredNames_FunctionBody; // (implicit)
  //   ConciseBody : ExpressionBody
  //
  // (implicit)
  //   ConciseBody : `{` FunctionBody `}`

  function LexicallyDeclaredNames_ConciseBody(ConciseBody) {
    switch (true) {
      case isExpressionBody(ConciseBody):
        return [];

      case isBlockStatement(ConciseBody):
        return LexicallyDeclaredNames_FunctionBody(ConciseBody.body);

      default:
        throw new TypeError(`Unexpected ConciseBody: ${ConciseBody.type}`);
    }
  } // 14.8.9 #sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames
  //   ScriptBody : StatementList

  const LexicallyDeclaredNames_ScriptBody = TopLevelLexicallyDeclaredNames_StatementList;

  //   StatementList : StatementList StatementListItem
  //
  // (implicit)
  //   StatementList : StatementListItem

  function LexicallyScopedDeclarations_StatementList(StatementList) {
    const declarations = [];

    for (const StatementListItem of StatementList) {
      declarations.push(...LexicallyScopedDeclarations_StatementListItem(StatementListItem));
    }

    return declarations;
  } // 13.2.6 #sec-block-static-semantics-lexicallyscopeddeclarations
  //   StatementListItem :
  //     Statement
  //     Declaration

  function LexicallyScopedDeclarations_StatementListItem(StatementListItem) {
    switch (true) {
      case isStatement(StatementListItem):
        if (isLabelledStatement(StatementListItem)) {
          return LexicallyScopedDeclarations_LabelledStatement(StatementListItem);
        }

        return [];

      case isDeclaration(StatementListItem):
        return [DeclarationPart_Declaration(StatementListItem)];

      case isSwitchCase(StatementListItem):
        return LexicallyScopedDeclarations_StatementList(StatementListItem.consequent);

      default:
        throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
    }
  } // 13.13.7 #sec-labelled-statements-static-semantics-lexicallyscopeddeclarations
  //   LabelledStatement : LabelIdentifier `:` LabelledItem

  function LexicallyScopedDeclarations_LabelledStatement(LabelledStatement) {
    return LexicallyScopedDeclarations_LabelledItem(LabelledStatement.body);
  } // 13.13.7 #sec-labelled-statements-static-semantics-lexicallyscopeddeclarations
  //   LabelledItem :
  //     Statement
  //     FunctionDeclaration

  function LexicallyScopedDeclarations_LabelledItem(LabelledItem) {
    switch (true) {
      case isStatement(LabelledItem):
        return [];

      case isFunctionDeclaration(LabelledItem):
        return [LabelledItem];

      default:
        throw new TypeError(`Unexpected LabelledItem: ${LabelledItem.type}`);
    }
  } // 14.1.14 #sec-function-definitions-static-semantics-lexicallydeclarednames
  //   FunctionStatementList :
  //     [empty]
  //     StatementList

  const // eslint-disable-next-line max-len
  LexicallyScopedDeclarations_FunctionStatementList = TopLevelLexicallyScopedDeclarations_StatementList; // (implicit)
  //   FunctionBody : FunctionStatementList

  const LexicallyScopedDeclarations_FunctionBody = LexicallyScopedDeclarations_FunctionStatementList; // (implicit)
  //   GeneratorBody : FunctionBody
  //   AsyncFunctionBody : FunctionBody

  const LexicallyScopedDeclarations_GeneratorBody = LexicallyScopedDeclarations_FunctionBody;
  const LexicallyScopedDeclarations_AsyncFunctionBody = LexicallyScopedDeclarations_FunctionBody; // 14.2.11 #sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations
  //   ConciseBody : ExpressionBody
  //
  // (implicit)
  //   ConciseBody : `{` FunctionBody `}`

  function LexicallyScopedDeclarations_ConciseBody(ConciseBody) {
    switch (true) {
      case isExpressionBody(ConciseBody):
        return [];

      case isBlockStatement(ConciseBody):
        return LexicallyScopedDeclarations_FunctionBody(ConciseBody.body);

      default:
        throw new TypeError(`Unexpected ConciseBody: ${ConciseBody.type}`);
    }
  } // 14.8.10 #sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations
  //   ScriptBody : StatementList

  const LexicallyScopedDeclarations_ScriptBody = TopLevelLexicallyScopedDeclarations_StatementList; // 15.2.3.8 #sec-exports-static-semantics-lexicallyscopeddeclarations
  //   ExportDeclaration :
  //     `export` `*` FromClause `;`
  //     `export` ExportClause FromClause `;`
  //     `export` ExportClause `;`
  //     `export` VariableStatement
  //     `export` Declaration
  //     `export` `default` HoistableDeclaration
  //     `export` `default` ClassDeclaration
  //     `export` `default` AssignmentExpression `;`

  function LexicallyScopedDeclarations_ExportDeclaration(ExportDeclaration) {
    switch (true) {
      case isExportDeclarationWithStar(ExportDeclaration):
      case isExportDeclarationWithExportAndFrom(ExportDeclaration):
      case isExportDeclarationWithExport(ExportDeclaration):
      case isExportDeclarationWithVariable(ExportDeclaration):
        return [];

      case isExportDeclarationWithDeclaration(ExportDeclaration):
        return [DeclarationPart_Declaration(ExportDeclaration.declaration)];

      case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
        return [DeclarationPart_HoistableDeclaration(ExportDeclaration.declaration)];

      case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
        return [ExportDeclaration.declaration];

      case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
        return [ExportDeclaration];

      default:
        throw new OutOfRange('LexicallyScopedDeclarations_ExportDeclaration', ExportDeclaration);
    }
  } // 15.2.1.12 #sec-module-semantics-static-semantics-lexicallyscopeddeclarations
  //   ModuleItem : ImportDeclaration
  //
  // (implicit)
  //   ModuleItem :
  //     ExportDeclaration
  //     StatementListItem

  function LexicallyScopedDeclarations_ModuleItem(ModuleItem) {
    switch (true) {
      case isImportDeclaration(ModuleItem):
        return [];

      case isExportDeclaration(ModuleItem):
        return LexicallyScopedDeclarations_ExportDeclaration(ModuleItem);

      case isStatementListItem(ModuleItem):
        return LexicallyScopedDeclarations_StatementListItem(ModuleItem);

      default:
        throw new OutOfRange('LexicallyScopedDeclarations_ModuleItem', ModuleItem);
    }
  } // 15.2.1.12 #sec-module-semantics-static-semantics-lexicallyscopeddeclarations
  //   ModuleItemList : ModuleItemList ModuleItem
  //
  // (implicit)
  //   ModuleItemList : ModuleItem

  function LexicallyScopedDeclarations_ModuleItemList(ModuleItemList) {
    const declarations = [];

    for (const ModuleItem of ModuleItemList) {
      declarations.push(...LexicallyScopedDeclarations_ModuleItem(ModuleItem));
    }

    return declarations;
  } // (implicit)
  //   ModuleBody : ModuleItemList

  const LexicallyScopedDeclarations_ModuleBody = LexicallyScopedDeclarations_ModuleItemList; // 15.2.1.12 #sec-module-semantics-static-semantics-lexicallyscopeddeclarations
  //   Module : [empty]
  //
  // (implicit)
  //   Module : ModuleBody

  const LexicallyScopedDeclarations_Module = LexicallyScopedDeclarations_ModuleBody;

  /* eslint-disable no-bitwise */
  // Divide a non-negative `num` by a positive `den`. The quotient is rounded to
  // its nearest integer, or the even integer if there are two equally near
  // integer.
  function roundQuotientBigInt(num, den) {
    const quo = num / den;
    const rem = num % den;
    const rem2 = rem * 2n;

    if (rem2 > den || rem2 === den && quo % 2n !== 0n) {
      return quo + 1n;
    } else {
      return quo;
    }
  }

  const throwawayArray = new Float64Array(1);
  const throwawayArrayInt = new Uint32Array(throwawayArray.buffer); // Find out if the host's [[BigEndian]] is true or false, by checking the
  // representation for -0.

  throwawayArray[0] = -0;
  const float64High = throwawayArrayInt[0] === 0 ? 1 : 0; // Return x * 2 ** exp where x is a Number, and exp is an integer.
  //
  // Derived from
  // https://github.com/JuliaMath/openlibm/blob/0f22aeb0a9104c52106f42ce1fa8ebe96fb498f1/src/s_scalbn.c.
  //
  // License:
  //
  //     Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
  //     Developed at SunPro, a Sun Microsystems, Inc. business.
  //     Permission to use, copy, modify, and distribute this
  //     software is freely granted, provided that this notice
  //     is preserved.

  function scalb(x, exp) {
    if (x === 0 || exp === 0 || !Number.isFinite(x)) {
      return x;
    }

    if (exp >= 2000) {
      return x * Infinity;
    } else if (exp <= -2000) {
      return x * 0;
    }

    throwawayArray[0] = x;
    let origExp = throwawayArrayInt[float64High] >>> 20 & 0x7ff;

    if (origExp === 0) {
      // x is denormalized. Multiply x by 2**54 (1 + number of mantissa bits),
      // and correspondingly reduce exp by 54.
      throwawayArray[0] *= 18014398509481984;
      exp -= 54;
      if (exp === 0) return throwawayArray[0];
      origExp = throwawayArrayInt[float64High] >>> 20 & 0x7ff;
    }

    const newExp = origExp + exp;

    if (newExp > 0x7fe) {
      // Overflow. Return Infinity, but of the appropriate sign.
      return throwawayArray[0] * Infinity;
    }

    if (newExp > 0) {
      // Normalized, okay.
      throwawayArrayInt[float64High] ^= (origExp ^ newExp) << 20;
      return throwawayArray[0];
    }

    if (newExp <= -54) {
      // Underflow. Return 0, but of the appropriate sign.
      return throwawayArray[0] * 0;
    } // Denormalized result. Add 54 to newExp and multiply the resultant number by
    // 2**-54.


    throwawayArrayInt[float64High] ^= (origExp ^ newExp + 54) << 20;
    return throwawayArray[0] * 5.55111512312578270212e-17;
  } // Return the minimum number of bits it takes to store `bint`. This function
  // assumes a host implementation on which a BigInt value cannot exceed 2^(4n),
  // where n is the maximum length of a String value on that host (usually around
  // 2^31, but can be up to 2^53 - 1 by spec).


  function bitLengthBigInt(bint) {
    if (bint < 0n) {
      bint = -bint;
    }

    let increment = 0;

    if (bint > (1n << 32n) - 1n) {
      // This number is larger than 2^32 - 1, which is just huge. Let's form an
      // estimate of how many bits it requires first, accurate to the nearest
      // multiple of log2(16) = 4, by converting it to a hexadecimal string and
      // measuring the resulting length.
      const hexLength = bint.toString(16).length;
      const estimatedBitLength = (hexLength - 1) * 4;
      increment += estimatedBitLength;
      bint >>= BigInt(estimatedBitLength);
    } // As we are sure that bint is within the range of an unsigned 32-bit
    // integer, we can use Math.clz32().


    return 32 - Math.clz32(Number(bint)) + increment;
  }

  function approximateLog10BigInt(bint) {
    return bint.toString(10).length;
  } // Number of mantissa bits in a IEEE 754-2008 binary64 value.


  const MANTISSA_BITS = 53; // A class representing a decimal number in scientific notation, or otherwise
  // known as a decimal floating-point number.

  class Scientific {
    constructor(num, exp = 0n) {
      if (typeof num !== 'bigint') {
        // eslint-disable-line valid-typeof
        throw new TypeError('Numerator must be a BigInt');
      }

      if (typeof exp !== 'bigint') {
        // eslint-disable-line valid-typeof
        throw new TypeError('Numerator must be a BigInt');
      }

      this.num = num;
      this.exp = exp;
    }

    negate() {
      return new this.constructor(-this.num, this.exp);
    }

    convExp(exp) {
      if (this.exp === exp) {
        return this;
      } else if (this.exp > exp) {
        return new this.constructor(this.num * 10n ** (this.exp - exp), exp);
      }

      throw new RangeError('Requested exponent must be less than or equal to the current exponent');
    }

    expAdd(e) {
      return new this.constructor(this.num, this.exp + e);
    }

    addSci(sci) {
      const expectedExp = this.exp < sci.exp ? this.exp : sci.exp;
      const conv1 = this.convExp(expectedExp);
      const conv2 = sci.convExp(expectedExp);
      return new this.constructor(conv1.num + conv2.num, expectedExp);
    } // Derived from "Easy Accurate Reading and Writing of Floating-Point Numbers"
    // by Aubrey Jaffer, <https://arxiv.org/abs/1310.8121v7>.


    toNumber() {
      if (this.num === 0n) {
        return 0;
      }

      if (this.num < 0) {
        return -new this.constructor(-this.num, this.exp).toNumber();
      }

      let {
        num,
        exp
      } = this; // According to V8, the "Maximum number of significant digits in decimal
      // representation" for a binary64 value is 772. See [1]. Let's first make
      // sure we have a reasonably small this.num ( 10**800) while not losing
      // accuracy, so that we can fast-path numbers with astronomical exponents.
      //
      // [1]: https://cs.chromium.org/chromium/src/v8/src/conversions.cc?l=565-571&rcl=dadf4cbe89c1e9ee9fed6181216cb4d3ba647a68

      const approximateDecimalDigits = approximateLog10BigInt(this.num);

      if (approximateDecimalDigits > 800) {
        const comp = BigInt(approximateDecimalDigits - 800); // We don't care about rounding as we still have quite a large margin of
        // error.

        num /= 10n ** comp;
        exp += comp;
      }

      if (exp > 310n) {
        // Largest possible value is < 2e308.
        return Infinity;
      } else if (exp < -1150n) {
        // Smallest possible value is 5e-324, but num may be at most 1e801, so we
        // are slightly more careful and only fast-path truly miniscule
        // exponents.
        return 0;
      }

      const expNum = Number(exp);

      if (expNum >= 0) {
        const numScaled = num * 5n ** exp;
        const bex = bitLengthBigInt(numScaled) - MANTISSA_BITS;

        if (bex <= 0) {
          return scalb(Number(numScaled), expNum);
        }

        const quo = roundQuotientBigInt(numScaled, 1n << BigInt(bex));
        return scalb(Number(quo), bex + expNum);
      }

      const scl = 5n ** -exp;
      let mantlen = MANTISSA_BITS;
      let bex = bitLengthBigInt(num) - bitLengthBigInt(scl) - mantlen;
      const tmp = bex + expNum + 1021 + mantlen;

      if (tmp < 0) {
        bex -= tmp + 1;
        mantlen += tmp;
      }

      const numScaled = num << BigInt(-bex);
      let quo = roundQuotientBigInt(numScaled, scl);

      if (bitLengthBigInt(quo) > mantlen) {
        bex += 1;
        quo = roundQuotientBigInt(numScaled, scl << 1n);
      }

      return scalb(Number(quo), bex + expNum);
    }

  }

  // Generated automatically by nearley, version 2.16.0

  function c(val) {
    return () => val;
  }

  let Lexer = undefined;
  let ParserRules = [{
    "name": "StrNumericLiteral",
    "symbols": ["StrDecimalLiteral"],
    "postprocess": ([StrDecimalLiteral]) => StrDecimalLiteral
  }, {
    "name": "StrNumericLiteral",
    "symbols": ["BinaryIntegerLiteral"],
    "postprocess": ([BinaryIntegerLiteral]) => BinaryIntegerLiteral
  }, {
    "name": "StrNumericLiteral",
    "symbols": ["OctalIntegerLiteral"],
    "postprocess": ([OctalIntegerLiteral]) => OctalIntegerLiteral
  }, {
    "name": "StrNumericLiteral",
    "symbols": ["HexIntegerLiteral"],
    "postprocess": ([HexIntegerLiteral]) => HexIntegerLiteral
  }, {
    "name": "StrDecimalLiteral",
    "symbols": ["StrUnsignedDecimalLiteral"],
    "postprocess": ([StrUnsignedDecimalLiteral]) => StrUnsignedDecimalLiteral
  }, {
    "name": "StrDecimalLiteral",
    "symbols": [{
      "literal": "+"
    }, "StrUnsignedDecimalLiteral"],
    "postprocess": ([_, StrUnsignedDecimalLiteral]) => StrUnsignedDecimalLiteral
  }, {
    "name": "StrDecimalLiteral",
    "symbols": [{
      "literal": "-"
    }, "StrUnsignedDecimalLiteral"],
    "postprocess": ([_, StrUnsignedDecimalLiteral]) => StrUnsignedDecimalLiteral.negate()
  }, {
    "name": "StrUnsignedDecimalLiteral$string$1",
    "symbols": [{
      "literal": "I"
    }, {
      "literal": "n"
    }, {
      "literal": "f"
    }, {
      "literal": "i"
    }, {
      "literal": "n"
    }, {
      "literal": "i"
    }, {
      "literal": "t"
    }, {
      "literal": "y"
    }],
    "postprocess": function joiner(d) {
      return d.join('');
    }
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": ["StrUnsignedDecimalLiteral$string$1"],
    "postprocess": () => new Scientific(1n, 10000n)
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": ["DecimalDigits", {
      "literal": "."
    }],
    "postprocess": ([[DecimalDigits]]) => new Scientific(DecimalDigits)
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": ["DecimalDigits", {
      "literal": "."
    }, "DecimalDigits"],
    "postprocess": ([[first], _, [second, n]]) => new Scientific(first).addSci(new Scientific(second, -n))
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": ["DecimalDigits", {
      "literal": "."
    }, "ExponentPart"],
    "postprocess": ([[DecimalDigits], _, e]) => new Scientific(DecimalDigits, e)
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": ["DecimalDigits", {
      "literal": "."
    }, "DecimalDigits", "ExponentPart"],
    "postprocess": ([[first], _, [second, n], e]) => new Scientific(first).addSci(new Scientific(second, -n)).expAdd(e)
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": [{
      "literal": "."
    }, "DecimalDigits"],
    "postprocess": ([_, [DecimalDigits, n]]) => new Scientific(DecimalDigits, -n)
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": [{
      "literal": "."
    }, "DecimalDigits", "ExponentPart"],
    "postprocess": ([_, [DecimalDigits, n], e]) => new Scientific(DecimalDigits, e - n)
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": ["DecimalDigits"],
    "postprocess": ([[DecimalDigits]]) => new Scientific(DecimalDigits)
  }, {
    "name": "StrUnsignedDecimalLiteral",
    "symbols": ["DecimalDigits", "ExponentPart"],
    "postprocess": ([[DecimalDigits], e]) => new Scientific(DecimalDigits, e)
  }, {
    "name": "NumericLiteral",
    "symbols": ["DecimalLiteral"],
    "postprocess": ([DecimalLiteral]) => DecimalLiteral
  }, {
    "name": "NumericLiteral",
    "symbols": ["BinaryIntegerLiteral"],
    "postprocess": ([BinaryIntegerLiteral]) => BinaryIntegerLiteral
  }, {
    "name": "NumericLiteral",
    "symbols": ["OctalIntegerLiteral"],
    "postprocess": ([OctalIntegerLiteral]) => OctalIntegerLiteral
  }, {
    "name": "NumericLiteral",
    "symbols": ["HexIntegerLiteral"],
    "postprocess": ([HexIntegerLiteral]) => HexIntegerLiteral
  }, {
    "name": "DecimalLiteral",
    "symbols": ["DecimalIntegerLiteral", {
      "literal": "."
    }],
    "postprocess": ([DecimalIntegerLiteral]) => new Scientific(DecimalIntegerLiteral)
  }, {
    "name": "DecimalLiteral",
    "symbols": ["DecimalIntegerLiteral", {
      "literal": "."
    }, "DecimalDigits"],
    "postprocess": ([DecimalIntegerLiteral, _, [DecimalDigits, n]]) => new Scientific(DecimalIntegerLiteral).addSci(new Scientific(DecimalDigits, -n))
  }, {
    "name": "DecimalLiteral",
    "symbols": ["DecimalIntegerLiteral", {
      "literal": "."
    }, "ExponentPart"],
    "postprocess": ([DecimalIntegerLiteral, _, e]) => new Scientific(DecimalIntegerLiteral, e)
  }, {
    "name": "DecimalLiteral",
    "symbols": ["DecimalIntegerLiteral", {
      "literal": "."
    }, "DecimalDigits", "ExponentPart"],
    "postprocess": ([DecimalIntegerLiteral, _, [DecimalDigits, n], e]) => new Scientific(DecimalIntegerLiteral).addSci(new Scientific(DecimalDigits, -n)).expAdd(e)
  }, {
    "name": "DecimalLiteral",
    "symbols": [{
      "literal": "."
    }, "DecimalDigits"],
    "postprocess": ([_, [DecimalDigits, n]]) => new Scientific(DecimalDigits, -n)
  }, {
    "name": "DecimalLiteral",
    "symbols": [{
      "literal": "."
    }, "DecimalDigits", "ExponentPart"],
    "postprocess": ([_, [DecimalDigits, n], e]) => new Scientific(DecimalDigits, e - n)
  }, {
    "name": "DecimalLiteral",
    "symbols": ["DecimalIntegerLiteral"],
    "postprocess": ([DecimalIntegerLiteral]) => new Scientific(DecimalIntegerLiteral)
  }, {
    "name": "DecimalLiteral",
    "symbols": ["DecimalIntegerLiteral", "ExponentPart"],
    "postprocess": ([DecimalIntegerLiteral, e]) => new Scientific(DecimalIntegerLiteral, e)
  }, {
    "name": "DecimalIntegerLiteral",
    "symbols": [{
      "literal": "0"
    }],
    "postprocess": c(0n)
  }, {
    "name": "DecimalIntegerLiteral",
    "symbols": ["NonZeroDigit"],
    "postprocess": ([NonZeroDigit]) => NonZeroDigit
  }, {
    "name": "DecimalIntegerLiteral",
    "symbols": ["NonZeroDigit", "DecimalDigits"],
    "postprocess": ([NonZeroDigit, [DecimalDigits, n]]) => NonZeroDigit * 10n ** n + DecimalDigits
  }, {
    "name": "DecimalDigits",
    "symbols": ["DecimalDigit"],
    "postprocess": ([DecimalDigit]) => [DecimalDigit, 1n]
  }, {
    "name": "DecimalDigits",
    "symbols": ["DecimalDigits", "DecimalDigit"],
    "postprocess": ([[DecimalDigits, n], DecimalDigit]) => [DecimalDigits * 10n + DecimalDigit, n + 1n]
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "0"
    }],
    "postprocess": c(0n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "1"
    }],
    "postprocess": c(1n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "2"
    }],
    "postprocess": c(2n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "3"
    }],
    "postprocess": c(3n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "4"
    }],
    "postprocess": c(4n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "5"
    }],
    "postprocess": c(5n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "6"
    }],
    "postprocess": c(6n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "7"
    }],
    "postprocess": c(7n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "8"
    }],
    "postprocess": c(8n)
  }, {
    "name": "DecimalDigit",
    "symbols": [{
      "literal": "9"
    }],
    "postprocess": c(9n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "1"
    }],
    "postprocess": c(1n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "2"
    }],
    "postprocess": c(2n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "3"
    }],
    "postprocess": c(3n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "4"
    }],
    "postprocess": c(4n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "5"
    }],
    "postprocess": c(5n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "6"
    }],
    "postprocess": c(6n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "7"
    }],
    "postprocess": c(7n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "8"
    }],
    "postprocess": c(8n)
  }, {
    "name": "NonZeroDigit",
    "symbols": [{
      "literal": "9"
    }],
    "postprocess": c(9n)
  }, {
    "name": "ExponentPart",
    "symbols": ["ExponentIndicator", "SignedInteger"],
    "postprocess": ([_, SignedInteger]) => SignedInteger
  }, {
    "name": "ExponentIndicator$subexpression$1",
    "symbols": [/[eE]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "ExponentIndicator",
    "symbols": ["ExponentIndicator$subexpression$1"]
  }, {
    "name": "SignedInteger",
    "symbols": ["DecimalDigits"],
    "postprocess": ([[DecimalDigits]]) => DecimalDigits
  }, {
    "name": "SignedInteger",
    "symbols": [{
      "literal": "+"
    }, "DecimalDigits"],
    "postprocess": ([_, [DecimalDigits]]) => DecimalDigits
  }, {
    "name": "SignedInteger",
    "symbols": [{
      "literal": "-"
    }, "DecimalDigits"],
    "postprocess": ([_, [DecimalDigits]]) => -DecimalDigits
  }, {
    "name": "BinaryIntegerLiteral$subexpression$1",
    "symbols": [{
      "literal": "0"
    }, /[bB]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "BinaryIntegerLiteral",
    "symbols": ["BinaryIntegerLiteral$subexpression$1", "BinaryDigits"],
    "postprocess": ([_, BinaryDigits]) => new Scientific(BinaryDigits)
  }, {
    "name": "BinaryDigits",
    "symbols": ["BinaryDigit"],
    "postprocess": ([BinaryDigit]) => BinaryDigit
  }, {
    "name": "BinaryDigits",
    "symbols": ["BinaryDigits", "BinaryDigit"],
    "postprocess": ([BinaryDigits, BinaryDigit]) => BinaryDigits * 2n + BinaryDigit
  }, {
    "name": "BinaryDigit",
    "symbols": [{
      "literal": "0"
    }],
    "postprocess": c(0n)
  }, {
    "name": "BinaryDigit",
    "symbols": [{
      "literal": "1"
    }],
    "postprocess": c(1n)
  }, {
    "name": "OctalIntegerLiteral$subexpression$1",
    "symbols": [{
      "literal": "0"
    }, /[oO]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "OctalIntegerLiteral",
    "symbols": ["OctalIntegerLiteral$subexpression$1", "OctalDigits"],
    "postprocess": ([_, OctalDigits]) => new Scientific(OctalDigits)
  }, {
    "name": "OctalDigits",
    "symbols": ["OctalDigit"],
    "postprocess": ([OctalDigit]) => OctalDigit
  }, {
    "name": "OctalDigits",
    "symbols": ["OctalDigits", "OctalDigit"],
    "postprocess": ([OctalDigits, OctalDigit]) => OctalDigits * 8n + OctalDigit
  }, {
    "name": "OctalDigit",
    "symbols": [{
      "literal": "0"
    }],
    "postprocess": c(0n)
  }, {
    "name": "OctalDigit",
    "symbols": [{
      "literal": "1"
    }],
    "postprocess": c(1n)
  }, {
    "name": "OctalDigit",
    "symbols": [{
      "literal": "2"
    }],
    "postprocess": c(2n)
  }, {
    "name": "OctalDigit",
    "symbols": [{
      "literal": "3"
    }],
    "postprocess": c(3n)
  }, {
    "name": "OctalDigit",
    "symbols": [{
      "literal": "4"
    }],
    "postprocess": c(4n)
  }, {
    "name": "OctalDigit",
    "symbols": [{
      "literal": "5"
    }],
    "postprocess": c(5n)
  }, {
    "name": "OctalDigit",
    "symbols": [{
      "literal": "6"
    }],
    "postprocess": c(6n)
  }, {
    "name": "OctalDigit",
    "symbols": [{
      "literal": "7"
    }],
    "postprocess": c(7n)
  }, {
    "name": "HexIntegerLiteral$subexpression$1",
    "symbols": [{
      "literal": "0"
    }, /[xX]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "HexIntegerLiteral",
    "symbols": ["HexIntegerLiteral$subexpression$1", "HexDigits"],
    "postprocess": ([_, HexDigits]) => new Scientific(HexDigits)
  }, {
    "name": "HexDigits",
    "symbols": ["HexDigit"],
    "postprocess": ([HexDigit]) => HexDigit
  }, {
    "name": "HexDigits",
    "symbols": ["HexDigits", "HexDigit"],
    "postprocess": ([HexDigits, HexDigit]) => HexDigits * 16n + HexDigit
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "0"
    }],
    "postprocess": c(0n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "1"
    }],
    "postprocess": c(1n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "2"
    }],
    "postprocess": c(2n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "3"
    }],
    "postprocess": c(3n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "4"
    }],
    "postprocess": c(4n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "5"
    }],
    "postprocess": c(5n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "6"
    }],
    "postprocess": c(6n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "7"
    }],
    "postprocess": c(7n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "8"
    }],
    "postprocess": c(8n)
  }, {
    "name": "HexDigit",
    "symbols": [{
      "literal": "9"
    }],
    "postprocess": c(9n)
  }, {
    "name": "HexDigit$subexpression$1",
    "symbols": [/[aA]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "HexDigit",
    "symbols": ["HexDigit$subexpression$1"],
    "postprocess": c(10n)
  }, {
    "name": "HexDigit$subexpression$2",
    "symbols": [/[bB]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "HexDigit",
    "symbols": ["HexDigit$subexpression$2"],
    "postprocess": c(11n)
  }, {
    "name": "HexDigit$subexpression$3",
    "symbols": [/[cC]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "HexDigit",
    "symbols": ["HexDigit$subexpression$3"],
    "postprocess": c(12n)
  }, {
    "name": "HexDigit$subexpression$4",
    "symbols": [/[dD]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "HexDigit",
    "symbols": ["HexDigit$subexpression$4"],
    "postprocess": c(13n)
  }, {
    "name": "HexDigit$subexpression$5",
    "symbols": [/[eE]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "HexDigit",
    "symbols": ["HexDigit$subexpression$5"],
    "postprocess": c(14n)
  }, {
    "name": "HexDigit$subexpression$6",
    "symbols": [/[fF]/],
    "postprocess": function (d) {
      return d.join("");
    }
  }, {
    "name": "HexDigit",
    "symbols": ["HexDigit$subexpression$6"],
    "postprocess": c(15n)
  }];
  let ParserStart = "StrNumericLiteral";
  var grammar = {
    Lexer,
    ParserRules,
    ParserStart
  };

  const {
    ParserRules: ParserRules$1
  } = grammar;
  const NumericLiteralGrammar = nearley.Grammar.fromCompiled({
    ParserRules: ParserRules$1,
    ParserStart: 'NumericLiteral'
  }); // 11.8.3.1 #sec-static-semantics-mv
  //   NumericLiteral ::
  //     DecimalLiteral
  //     BinaryIntegerLiteral
  //     OctalIntegerLiteral
  //     HexIntegerLiteral

  function MV_NumericLiteral(NumericLiteral) {
    const parser = new nearley.Parser(NumericLiteralGrammar);

    try {
      parser.feed(NumericLiteral);
    } catch (err) {
      return NaN;
    }

    Assert(parser.results.length === 1, "parser.results.length === 1");
    return parser.results[0].toNumber();
  }

  // 14.6.10 #sec-static-semantics-nonconstructormethoddefinitions
  //   ClassElementList :
  //     ClassElement
  //     ClassElementList ClassElement
  function NonConstructorMethodDefinitions_ClassElementList(ClassElementList) {
    return ClassElementList.filter(ClassElement => ClassElement.kind !== 'constructor');
  } // (implicit)
  //   ClassBody : ClassElementList


  const NonConstructorMethodDefinitions_ClassBody = NonConstructorMethodDefinitions_ClassElementList;

  //   NoSubstitutionTemplate ::
  //     `\`` `\``
  //     `\`` TemplateCharacters `\``

  function TRV_NoSubstitutionTemplate(NoSubstitutionTemplate) {
    if (NoSubstitutionTemplate.quasis.length !== 1) {
      throw new OutOfRange('TRV_NoSubstitutionTemplate', NoSubstitutionTemplate);
    }

    return TRV_TemplateCharacters(NoSubstitutionTemplate.quasis[0]);
  } // 11.8.6.1 #sec-static-semantics-tv-and-trv
  //   TemplateCharacters ::
  //     TemplateCharacter
  //     TemplateCharacter TemplateCharacters

  function TRV_TemplateCharacters(TemplateCharacters) {
    Assert(typeof TemplateCharacters.value.raw === 'string', "typeof TemplateCharacters.value.raw === 'string'");
    return TemplateCharacters.value.raw;
  } // 11.8.6.1 #sec-static-semantics-tv-and-trv
  //   TemplateHead ::
  //     `\`` `${`
  //     `\`` TemplateCharacters `${`

  const TRV_TemplateHead = TRV_TemplateCharacters; // 11.8.6.1 #sec-static-semantics-tv-and-trv
  //   TemplateMiddle ::
  //     `}` `${`
  //     `}` TemplateCharacters `${`

  const TRV_TemplateMiddle = TRV_TemplateCharacters; // 11.8.6.1 #sec-static-semantics-tv-and-trv
  //   TemplateTail ::
  //     `}` `\``
  //     `}` TemplateCharacters `\``

  const TRV_TemplateTail = TRV_TemplateCharacters;

  //   NoSubstitutionTemplate ::
  //     `\`` `\``
  //     `\`` TemplateCharacters `\``

  function TV_NoSubstitutionTemplate(NoSubstitutionTemplate) {
    if (NoSubstitutionTemplate.quasis.length !== 1) {
      throw new OutOfRange('TV_NoSubstitutionTemplate', NoSubstitutionTemplate);
    }

    return TV_TemplateCharacters(NoSubstitutionTemplate.quasis[0]);
  } // 11.8.6.1 #sec-static-semantics-tv-and-trv
  //   TemplateCharacters ::
  //     TemplateCharacter
  //     TemplateCharacter TemplateCharacters

  function TV_TemplateCharacters(TemplateCharacters) {
    if (TemplateCharacters.value.cooked === null) {
      return undefined;
    }

    return TemplateCharacters.value.cooked;
  } // 11.8.6.1 #sec-static-semantics-tv-and-trv
  //   TemplateHead ::
  //     `\`` `${`
  //     `\`` TemplateCharacters `${`

  const TV_TemplateHead = TV_TemplateCharacters; // 11.8.6.1 #sec-static-semantics-tv-and-trv
  //   TemplateMiddle ::
  //     `}` `${`
  //     `}` TemplateCharacters `${`

  const TV_TemplateMiddle = TV_TemplateCharacters; // 11.8.6.1 #sec-static-semantics-tv-and-trv
  //   TemplateTail ::
  //     `}` `\``
  //     `}` TemplateCharacters `\``

  const TV_TemplateTail = TV_TemplateCharacters;

  //   TemplateLiteral : NoSubstitutionTemplate
  //
  // (implicit)
  //   TemplateLiteral : SubstitutionTemplate

  function TemplateStrings_TemplateLiteral(TemplateLiteral, raw) {
    switch (true) {
      case isNoSubstitutionTemplate(TemplateLiteral):
        {
          let string;

          if (raw === false) {
            string = TV_NoSubstitutionTemplate(TemplateLiteral);
          } else {
            string = TRV_NoSubstitutionTemplate(TemplateLiteral);
          }

          return [string];
        }

      case isSubstitutionTemplate(TemplateLiteral):
        return TemplateStrings_SubstitutionTemplate(TemplateLiteral, raw);

      default:
        throw new OutOfRange('TemplateStrings_TemplateLiteral', TemplateLiteral);
    }
  } // 12.2.9.2 #sec-static-semantics-templatestrings
  //   SubstitutionTemplate : TemplateHead Expression TemplateSpans

  function TemplateStrings_SubstitutionTemplate(SubstitutionTemplate, raw) {
    const [TemplateHead,,
    /* Expression */
    ...TemplateSpans] = unrollTemplateLiteral(SubstitutionTemplate);
    let head;

    if (raw === false) {
      head = TV_TemplateHead(TemplateHead);
    } else {
      head = TRV_TemplateHead(TemplateHead);
    }

    const tail = TemplateStrings_TemplateSpans(TemplateSpans, raw);
    return [head, ...tail];
  } // 12.2.9.2 #sec-static-semantics-templatestrings
  //   TemplateSpans :
  //     TemplateTail
  //     TemplateMiddleList TemplateTail

  function TemplateStrings_TemplateSpans(TemplateSpans, raw) {
    let middle = [];
    Assert(TemplateSpans.length % 2 === 1, "TemplateSpans.length % 2 === 1");

    if (TemplateSpans.length > 1) {
      middle = TemplateStrings_TemplateMiddleList(TemplateSpans.slice(0, -1), raw);
    }

    const TemplateTail = TemplateSpans[TemplateSpans.length - 1];
    let tail;

    if (raw === false) {
      tail = TV_TemplateTail(TemplateTail);
    } else {
      tail = TRV_TemplateTail(TemplateTail);
    }

    return [...middle, tail];
  } // 12.2.9.2 #sec-static-semantics-templatestrings
  //   TemplateMiddleList :
  //     TemplateMiddle Expression
  //     TemplateMiddleList TemplateMiddle Expression

  function TemplateStrings_TemplateMiddleList(TemplateMiddleList, raw) {
    const front = [];
    Assert(TemplateMiddleList.length % 2 === 0, "TemplateMiddleList.length % 2 === 0");

    for (let i = 0; i < TemplateMiddleList.length; i += 2) {
      const TemplateMiddle = TemplateMiddleList[i];
      let last;

      if (raw === false) {
        last = TV_TemplateMiddle(TemplateMiddle);
      } else {
        last = TRV_TemplateMiddle(TemplateMiddle);
      }

      front.push(last);
    }

    return front;
  }

  //   StatementList : StatementList StatementListItem
  //
  // (implicit)
  //   StatementList : StatementListItem

  function TopLevelLexicallyScopedDeclarations_StatementList(StatementList) {
    const declarations = [];

    for (const StatementListItem of StatementList) {
      declarations.push(...TopLevelLexicallyScopedDeclarations_StatementListItem(StatementListItem));
    }

    return declarations;
  } // 13.2.8 #sec-block-static-semantics-toplevellexicallyscopeddeclarations
  //   StatementListItem :
  //     Statement
  //     Declaration

  function TopLevelLexicallyScopedDeclarations_StatementListItem(StatementListItem) {
    switch (true) {
      case isStatement(StatementListItem):
        return [];

      case isDeclaration(StatementListItem):
        if (isHoistableDeclaration(StatementListItem)) {
          return [];
        }

        return [StatementListItem];

      default:
        throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
    }
  }

  //   Statement :
  //     EmptyStatement
  //     ExpressionStatement
  //     ContinueStatement
  //     BreakStatement
  //     ReturnStatement
  //     ThrowStatement
  //     DebuggerStatement
  //
  // (implicit)
  //   Statement :
  //     BlockStatement
  //     VariableStatement
  //     IfStatement
  //     BreakableStatement
  //     WithStatement
  //     LabelledStatement
  //     TryStatement
  //   BreakableStatement :
  //     IterationStatement
  //     SwitchStatement

  function VarScopedDeclarations_Statement(Statement) {
    switch (true) {
      case isEmptyStatement(Statement):
      case isExpressionStatement(Statement):
      case isContinueStatement(Statement):
      case isBreakStatement(Statement):
      case isReturnStatement(Statement):
      case isThrowStatement(Statement):
      case isDebuggerStatement(Statement):
        return [];

      case isBlockStatement(Statement):
        return VarScopedDeclarations_BlockStatement(Statement);

      case isVariableStatement(Statement):
        return VarScopedDeclarations_VariableStatement(Statement);

      case isIfStatement(Statement):
        return VarScopedDeclarations_IfStatement(Statement);

      case isWithStatement(Statement):
        return VarScopedDeclarations_WithStatement(Statement);

      case isLabelledStatement(Statement):
        return VarScopedDeclarations_LabelledStatement(Statement);

      case isTryStatement(Statement):
        return VarScopedDeclarations_TryStatement(Statement);

      case isIterationStatement(Statement):
        return VarScopedDeclarations_IterationStatement(Statement);

      case isSwitchStatement(Statement):
        return VarScopedDeclarations_SwitchStatement(Statement);

      default:
        throw new TypeError(`Invalid Statement: ${Statement.type}`);
    }
  } // 13.2.12 #sec-block-static-semantics-varscopeddeclarations
  //   StatementList : StatementList StatementListItem
  //
  // (implicit)
  //   StatementList : StatementListItem

  function VarScopedDeclarations_StatementList(StatementList) {
    const declarations = [];

    for (const StatementListItem of StatementList) {
      declarations.push(...VarScopedDeclarations_StatementListItem(StatementListItem));
    }

    return declarations;
  } // 13.2.12 #sec-block-static-semantics-varscopeddeclarations
  //   Block : `{` `}`
  //
  // (implicit)
  //   Block : `{` StatementList `}`

  function VarScopedDeclarations_Block(Block) {
    return VarScopedDeclarations_StatementList(Block.body);
  } // (implicit)
  //   BlockStatement : Block

  const VarScopedDeclarations_BlockStatement = VarScopedDeclarations_Block; // 13.2.12 #sec-block-static-semantics-varscopeddeclarations
  //   StatementListItem : Declaration
  //
  // (implicit)
  //   StatementListItem : Statement

  function VarScopedDeclarations_StatementListItem(StatementListItem) {
    switch (true) {
      case isDeclaration(StatementListItem):
        return [];

      case isStatement(StatementListItem):
        return VarScopedDeclarations_Statement(StatementListItem);

      default:
        throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
    }
  } // 13.3.2.3 #sec-variable-statement-static-semantics-varscopeddeclarations
  //   VariableDeclarationList :
  //     VariableDeclaration
  //     VariableDeclarationList `,` VariableDeclaration

  function VarScopedDeclarations_VariableDeclarationList(VariableDeclarationList) {
    return VariableDeclarationList;
  } // (implicit)
  //   VariableStatement : `var` VariableDeclarationList `;`

  function VarScopedDeclarations_VariableStatement(VariableStatement) {
    return VarScopedDeclarations_VariableDeclarationList(VariableStatement.declarations);
  } // 13.6.6 #sec-if-statement-static-semantics-varscopeddeclarations
  //   IfStatement :
  //     `if` `(` Expression `)` Statement `else` Statement
  //     `if` `(` Expression `)` Statement

  function VarScopedDeclarations_IfStatement(IfStatement) {
    if (IfStatement.alternate) {
      return [...VarScopedDeclarations_Statement(IfStatement.consequent), ...VarScopedDeclarations_Statement(IfStatement.alternate)];
    }

    return VarScopedDeclarations_Statement(IfStatement.consequent);
  } // 13.7.2.5 #sec-do-while-statement-static-semantics-varscopeddeclarations
  //   IterationStatement : `do` Statement `while` `(` Expression `)` `;`
  //
  // 13.7.3.5 #sec-while-statement-static-semantics-varscopeddeclarations
  //   IterationStatement : `while` `(` Expression `)` Statement
  //
  // 13.7.4.6 #sec-for-statement-static-semantics-varscopeddeclarations
  //   IterationStatement :
  //     `for` `(` Expression `;` Expression `;` Expression `)` Statement
  //     `for` `(` `var` VariableDeclarationList `;` Expression `;` Expression `)` Statement
  //     `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
  //
  // 13.7.5.8 #sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations
  //   IterationStatement :
  //     `for` `(` LeftHandSideExpression `in` Expression `)` Statement
  //     `for` `(` `var` ForBinding `in` Expression `)` Statement
  //     `for` `(` ForDeclaration `in` Expression `)` Statement
  //     `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
  //     `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
  //     `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  //     `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  //     `for` `(` ForDeclaration `of` Expression `)` Statement
  //     `for` `await` `(` ForDeclaration `of` Expression `)` Statement

  function VarScopedDeclarations_IterationStatement(IterationStatement) {
    let declarationsFromBinding = [];

    switch (IterationStatement.type) {
      case 'DoWhileStatement':
      case 'WhileStatement':
        break;

      case 'ForStatement':
        if (IterationStatement.init && isVariableStatement(IterationStatement.init)) {
          const VariableDeclarationList = IterationStatement.init.declarations;
          declarationsFromBinding = VarScopedDeclarations_VariableDeclarationList(VariableDeclarationList);
        }

        break;

      case 'ForInStatement':
      case 'ForOfStatement':
        if (isVariableStatement(IterationStatement.left)) {
          const ForBinding = IterationStatement.left.declarations[0].id;
          declarationsFromBinding = [ForBinding];
        }

        break;

      default:
        throw new TypeError(`Invalid IterationStatement: ${IterationStatement.type}`);
    }

    return [...declarationsFromBinding, ...VarScopedDeclarations_Statement(IterationStatement.body)];
  } // 13.11.6 #sec-with-statement-static-semantics-varscopeddeclarations
  //   WithStatement : `with` `(` Expression `)` Statement

  function VarScopedDeclarations_WithStatement(WithStatement) {
    return VarScopedDeclarations_Statement(WithStatement.body);
  } // 13.12.8 #sec-switch-statement-static-semantics-varscopeddeclarations
  //   SwitchStatement : `switch` `(` Expression `)` CaseBlock

  function VarScopedDeclarations_SwitchStatement(SwitchStatement) {
    return VarScopedDeclarations_CaseBlock(SwitchStatement.cases);
  } // 13.12.8 #sec-switch-statement-static-semantics-varscopeddeclarations
  //   CaseBlock :
  //     `{` `}`
  //     `{` CaseClauses_opt DefaultClause CaseClauses_opt `}`
  //   CaseClauses : CaseClauses CaseClause
  //   CaseClause : `case` Expression `:` StatementList_opt
  //   DefaultClause : `default` `:` StatementList_opt
  //
  // (implicit)
  //   CaseBlock : `{` CaseClauses `}`
  //   CaseClauses : CaseClause

  function VarScopedDeclarations_CaseBlock(CaseBlock) {
    const declarations = [];

    for (const CaseClauseOrDefaultClause of CaseBlock) {
      declarations.push(...VarScopedDeclarations_StatementList(CaseClauseOrDefaultClause.consequent));
    }

    return declarations;
  } // 13.13.13 #sec-labelled-statements-static-semantics-varscopeddeclarations
  //   LabelledStatement : LabelIdentifier `:` LabelledItem
  //   LabelledItem : FunctionDeclaration
  //
  // (implicit)
  //   LabelledItem : Statement

  function VarScopedDeclarations_LabelledStatement(LabelledStatement) {
    const LabelledItem = LabelledStatement.body;

    switch (true) {
      case isFunctionDeclaration(LabelledItem):
        return [];

      case isStatement(LabelledItem):
        return VarScopedDeclarations_Statement(LabelledItem);

      default:
        throw new TypeError(`Invalid LabelledItem: ${LabelledItem.type}`);
    }
  } // 13.15.6 #sec-try-statement-static-semantics-varscopeddeclarations
  //   TryStatement :
  //     `try` Block Catch
  //     `try` Block Finally
  //     `try` Block Catch Finally
  //   Catch : `catch` `(` CatchParameter `)` Block
  //
  // (implicit)
  //   Catch : `catch` Block
  //   Finally : `finally` Block

  function VarScopedDeclarations_TryStatement(TryStatement) {
    const declarationsBlock = VarScopedDeclarations_Block(TryStatement.block);
    const declarationsCatch = TryStatement.handler !== null ? VarScopedDeclarations_Block(TryStatement.handler.body) : [];
    const declarationsFinally = TryStatement.finalizer !== null ? VarScopedDeclarations_Block(TryStatement.finalizer) : [];
    return [...declarationsBlock, ...declarationsCatch, ...declarationsFinally];
  } // 14.1.17 #sec-function-definitions-static-semantics-varscopeddeclarations
  //   FunctionStatementList :
  //     [empty]
  //     StatementList

  const VarScopedDeclarations_FunctionStatementList = TopLevelVarScopedDeclarations_StatementList; // (implicit)
  //   FunctionBody : FunctionStatementList

  const VarScopedDeclarations_FunctionBody = VarScopedDeclarations_FunctionStatementList; // (implicit)
  //   GeneratorBody : FunctionBody

  const VarScopedDeclarations_GeneratorBody = VarScopedDeclarations_FunctionBody; // (implicit)
  //   AsyncFunctionBody : FunctionBody

  const VarScopedDeclarations_AsyncFunctionBody = VarScopedDeclarations_FunctionBody; // 14.2.13 #sec-arrow-function-definitions-static-semantics-varscopeddeclarations
  //   ConciseBody : ExpressionBody
  //
  // (implicit)
  //   ConciseBody : `{` FunctionBody `}`

  function VarScopedDeclarations_ConciseBody(ConciseBody) {
    switch (true) {
      case isExpressionBody(ConciseBody):
        return [];

      case isBlockStatement(ConciseBody):
        return VarScopedDeclarations_FunctionBody(ConciseBody.body);

      default:
        throw new TypeError(`Unexpected ConciseBody: ${ConciseBody.type}`);
    }
  } // 14.8.12 #sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations
  //   ScriptBody : StatementList

  const VarScopedDeclarations_ScriptBody = TopLevelVarScopedDeclarations_StatementList; // (implicit)
  //   ModuleItemList : ModuleItemList ModuleItem
  //
  // (implicit)
  //   ModuleItemList : ModuleItem

  function VarScopedDeclarations_ModuleItemList(ModuleItemList) {
    const declarations = [];

    for (const ModuleItem of ModuleItemList) {
      declarations.push(...VarScopedDeclarations_ModuleItem(ModuleItem));
    }

    return declarations;
  } // (implicit)
  //   ModuleBody : ModuleItemList

  const VarScopedDeclarations_ModuleBody = VarScopedDeclarations_ModuleItemList; // 15.2.1.14 #sec-module-semantics-static-semantics-varscopeddeclarations
  //   ModuleItem :
  //     ImportDeclaration
  //     ExportDeclaration
  //
  // (implicit)
  //   ModuleItem : StatementListItem

  function VarScopedDeclarations_ModuleItem(ModuleItem) {
    switch (true) {
      case isImportDeclaration(ModuleItem):
        return [];

      case isExportDeclaration(ModuleItem):
        if (isExportDeclarationWithVariable(ModuleItem)) {
          return VarScopedDeclarations_VariableStatement(ModuleItem.declaration);
        }

        return [];

      default:
        return VarScopedDeclarations_StatementListItem(ModuleItem);
    }
  }

  //   StatementList : StatementList StatementListItem

  function TopLevelVarScopedDeclarations_StatementList(StatementList) {
    const declarations = [];

    for (const StatementListItem of StatementList) {
      declarations.push(...TopLevelVarScopedDeclarations_StatementListItem(StatementListItem));
    }

    return declarations;
  } // 13.2.10 #sec-block-static-semantics-toplevelvarscopeddeclarations
  //   StatementListItem :
  //     Statement
  //     Declaration

  function TopLevelVarScopedDeclarations_StatementListItem(StatementListItem) {
    switch (true) {
      case isStatement(StatementListItem):
        if (isLabelledStatement(StatementListItem)) {
          return TopLevelVarScopedDeclarations_LabelledStatement(StatementListItem);
        }

        return VarScopedDeclarations_Statement(StatementListItem);

      case isDeclaration(StatementListItem):
        if (isHoistableDeclaration(StatementListItem)) {
          return [DeclarationPart_Declaration(StatementListItem)];
        }

        return [];

      default:
        throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
    }
  } // 13.13.11 #sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations
  //   LabelledStatement : LabelIdentifier `:` LabelledItem

  function TopLevelVarScopedDeclarations_LabelledStatement(LabelledStatement) {
    return TopLevelVarScopedDeclarations_LabelledItem(LabelledStatement.body);
  } // 13.13.11 #sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations
  //   LabelledItem :
  //     Statement
  //     FunctionDeclaration

  function TopLevelVarScopedDeclarations_LabelledItem(LabelledItem) {
    switch (true) {
      case isStatement(LabelledItem):
        if (isLabelledStatement(LabelledItem)) {
          return TopLevelVarScopedDeclarations_LabelledItem(LabelledItem.body);
        }

        return VarScopedDeclarations_Statement(LabelledItem);

      case isFunctionDeclaration(LabelledItem):
        return [LabelledItem];

      default:
        throw new TypeError(`Unexpected LabelledItem: ${LabelledItem.type}`);
    }
  }

  // 9.4.4 #sec-arguments-exotic-objects
  // 9.4.4.6 #sec-createunmappedargumentsobject

  function CreateUnmappedArgumentsObject(argumentsList) {
    const len = argumentsList.length;
    const obj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'), ['ParameterMap']);
    obj.ParameterMap = Value.undefined;
    DefinePropertyOrThrow(obj, new Value('length'), Descriptor({
      Value: new Value(len),
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    let index = 0;

    while (index < len) {
      const val = argumentsList[index];
      let idxStr = ToString(new Value(index));
      Assert(!(idxStr instanceof AbruptCompletion), "");

      if (idxStr instanceof Completion) {
        idxStr = idxStr.Value;
      }

      Assert(!(CreateDataProperty(obj, idxStr, val) instanceof AbruptCompletion), "");
      index += 1;
    }

    Assert(!(DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, Descriptor({
      Value: surroundingAgent.intrinsic('%ArrayProto_values%'),
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    Assert(!(DefinePropertyOrThrow(obj, new Value('callee'), Descriptor({
      Get: surroundingAgent.intrinsic('%ThrowTypeError%'),
      Set: surroundingAgent.intrinsic('%ThrowTypeError%'),
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    return obj;
  }

  function ArgGetterSteps() {
    const f = this;
    const name = f.Name;
    const env = f.Env;
    return env.GetBindingValue(name, Value.false);
  } // 9.4.4.7.1 #sec-makearggetter


  function MakeArgGetter(name, env) {
    const steps = ArgGetterSteps;
    let getter = CreateBuiltinFunction(steps, ['Name', 'Env']);
    Assert(!(getter instanceof AbruptCompletion), "");

    if (getter instanceof Completion) {
      getter = getter.Value;
    }

    getter.Name = name;
    getter.Env = env;
    return getter;
  }

  function ArgSetterSteps([value]) {
    Assert(value !== undefined, "value !== undefined");
    const f = this;
    const name = f.Name;
    const env = f.Env;
    return env.SetMutableBinding(name, value, Value.false);
  } // 9.4.4.7.2 #sec-makeargsetter


  function MakeArgSetter(name, env) {
    const steps = ArgSetterSteps;
    let setter = CreateBuiltinFunction(steps, ['Name', 'Env']);
    Assert(!(setter instanceof AbruptCompletion), "");

    if (setter instanceof Completion) {
      setter = setter.Value;
    }

    SetFunctionLength(setter, new Value(1));
    setter.Name = name;
    setter.Env = env;
    return setter;
  } // 9.4.4.7 #sec-createmappedargumentsobject


  function CreateMappedArgumentsObject(func, formals, argumentsList, env) {
    // Assert: formals does not contain a rest parameter, any binding
    // patterns, or any initializers. It may contain duplicate identifiers.
    const len = argumentsList.length;
    const obj = new ArgumentsExoticObjectValue();
    obj.Prototype = surroundingAgent.intrinsic('%ObjectPrototype%');
    obj.Extensible = Value.true;
    const map = ObjectCreate(Value.null);
    obj.ParameterMap = map;
    const parameterNames = BoundNames_FormalParameters(formals).map(Value);
    const numberOfParameters = parameterNames.length;
    let index = 0;

    while (index < len) {
      const val = argumentsList[index];
      let idxStr = ToString(new Value(index));
      Assert(!(idxStr instanceof AbruptCompletion), "");

      if (idxStr instanceof Completion) {
        idxStr = idxStr.Value;
      }

      Assert(!(CreateDataProperty(obj, idxStr, val) instanceof AbruptCompletion), "");
      index += 1;
    }

    Assert(!(DefinePropertyOrThrow(obj, new Value('length'), Descriptor({
      Value: new Value(len),
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    const mappedNames = [];
    index = numberOfParameters - 1;

    while (index >= 0) {
      const name = parameterNames[index];

      if (!mappedNames.includes(name)) {
        mappedNames.push(name);

        if (index < len) {
          const g = MakeArgGetter(name, env);
          const p = MakeArgSetter(name, env);

          let _val = ToString(new Value(index));

          Assert(!(_val instanceof AbruptCompletion), "");

          if (_val instanceof Completion) {
            _val = _val.Value;
          }

          Assert(!(map.DefineOwnProperty(_val, Descriptor({
            Set: p,
            Get: g,
            Enumerable: Value.false,
            Configurable: Value.true
          })) instanceof AbruptCompletion), "");
        }
      }

      index -= 1;
    }

    Assert(!(DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, Descriptor({
      Value: surroundingAgent.intrinsic('%ArrayProto_values%'),
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    Assert(!(DefinePropertyOrThrow(obj, new Value('callee'), Descriptor({
      Value: func,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    return obj;
  }

  // 9.4.2 #sec-array-exotic-objects
  // and
  // 22.1 #sec-array-objects
  // 9.4.2.2 #sec-arraycreate

  function ArrayCreate(length, proto) {
    Assert(length.numberValue() >= 0, "length.numberValue() >= 0");

    if (Object.is(length.numberValue(), -0)) {
      length = new Value(0);
    }

    if (length.numberValue() > 2 ** 32 - 1) {
      return surroundingAgent.Throw('RangeError');
    }

    if (proto === undefined) {
      proto = surroundingAgent.intrinsic('%ArrayPrototype%');
    }

    const A = new ArrayExoticObjectValue();
    A.Prototype = proto;
    A.Extensible = Value.true;
    Assert(!(OrdinaryDefineOwnProperty(A, new Value('length'), Descriptor({
      Value: length,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    return A;
  } // 9.4.2.3 #sec-arrayspeciescreate

  function ArraySpeciesCreate(originalArray, length) {
    Assert(Type(length) === 'Number' && Number.isInteger(length.numberValue()) && length.numberValue() >= 0, "Type(length) === 'Number' && Number.isInteger(length.numberValue()) && length.numberValue() >= 0");

    if (Object.is(length.numberValue(), -0)) {
      length = new Value(+0);
    }

    let isArray = IsArray(originalArray);

    if (isArray instanceof AbruptCompletion) {
      return isArray;
    }

    if (isArray instanceof Completion) {
      isArray = isArray.Value;
    }

    if (isArray === Value.false) {
      return ArrayCreate(length);
    }

    let C = Get(originalArray, new Value('constructor'));

    if (C instanceof AbruptCompletion) {
      return C;
    }

    if (C instanceof Completion) {
      C = C.Value;
    }

    if (IsConstructor(C) === Value.true) {
      const thisRealm = surroundingAgent.currentRealmRecord;
      let realmC = GetFunctionRealm(C);

      if (realmC instanceof AbruptCompletion) {
        return realmC;
      }

      if (realmC instanceof Completion) {
        realmC = realmC.Value;
      }

      if (thisRealm !== realmC) {
        if (SameValue(C, realmC.Intrinsics['%Array%']) === Value.true) {
          C = Value.undefined;
        }
      }
    }

    if (Type(C) === 'Object') {
      C = Get(C, wellKnownSymbols.species);

      if (C instanceof AbruptCompletion) {
        return C;
      }

      if (C instanceof Completion) {
        C = C.Value;
      }

      if (C === Value.null) {
        C = Value.undefined;
      }
    }

    if (C === Value.undefined) {
      return ArrayCreate(length);
    }

    if (IsConstructor(C) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAConstructor', C));
    }

    return Construct(C, [length]);
  } // 9.4.2.4 #sec-arraysetlength

  function ArraySetLength(A, Desc) {
    if (Desc.Value === undefined) {
      return OrdinaryDefineOwnProperty(A, new Value('length'), Desc);
    }

    const newLenDesc = Descriptor({ ...Desc
    });

    let _hygienicTemp = ToUint32(Desc.Value);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const newLen = _hygienicTemp.numberValue();

    let _hygienicTemp2 = ToNumber(Desc.Value);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const numberLen = _hygienicTemp2.numberValue();

    if (newLen !== numberLen) {
      return surroundingAgent.Throw('RangeError', 'Invalid array length');
    }

    newLenDesc.Value = new Value(newLen);
    const oldLenDesc = OrdinaryGetOwnProperty(A, new Value('length'));
    Assert(Type(oldLenDesc) !== 'Undefined' && !IsAccessorDescriptor(oldLenDesc), "Type(oldLenDesc) !== 'Undefined' && !IsAccessorDescriptor(oldLenDesc)");
    let oldLen = oldLenDesc.Value.numberValue();

    if (newLen >= oldLen) {
      return OrdinaryDefineOwnProperty(A, new Value('length'), newLenDesc);
    }

    if (oldLenDesc.Writable === Value.false) {
      return Value.false;
    }

    let newWritable;

    if (newLenDesc.Writable === undefined || newLenDesc.Writable === Value.true) {
      newWritable = true;
    } else {
      newWritable = false;
      newLenDesc.Writable = Value.true;
    }

    let succeeded = OrdinaryDefineOwnProperty(A, new Value('length'), newLenDesc);
    Assert(!(succeeded instanceof AbruptCompletion), "");

    if (succeeded instanceof Completion) {
      succeeded = succeeded.Value;
    }

    if (succeeded === Value.false) {
      return Value.false;
    }

    while (newLen < oldLen) {
      oldLen -= 1;
      let idxToDelete = ToString(new Value(oldLen));
      Assert(!(idxToDelete instanceof AbruptCompletion), "");

      if (idxToDelete instanceof Completion) {
        idxToDelete = idxToDelete.Value;
      }

      let deleteSucceeded = A.Delete(idxToDelete);
      Assert(!(deleteSucceeded instanceof AbruptCompletion), "");

      if (deleteSucceeded instanceof Completion) {
        deleteSucceeded = deleteSucceeded.Value;
      }

      if (deleteSucceeded === Value.false) {
        newLenDesc.Value = new Value(oldLen + 1);

        if (newWritable === false) {
          newLenDesc.Writable = Value.false;
        }

        Assert(!(OrdinaryDefineOwnProperty(A, new Value('length'), newLenDesc) instanceof AbruptCompletion), "");
        return Value.false;
      }
    }

    if (newWritable === false) {
      OrdinaryDefineOwnProperty(A, new Value('length'), Descriptor({
        Writable: Value.false
      }));
    }

    return Value.true;
  } // 22.1.3.1.1 #sec-isconcatspreadable

  function IsConcatSpreadable(O) {
    if (Type(O) !== 'Object') {
      return Value.false;
    }

    let spreadable = Get(O, wellKnownSymbols.isConcatSpreadable);

    if (spreadable instanceof AbruptCompletion) {
      return spreadable;
    }

    if (spreadable instanceof Completion) {
      spreadable = spreadable.Value;
    }

    if (spreadable !== Value.undefined) {
      return ToBoolean(spreadable);
    }

    return IsArray(O);
  } // 22.1.3.27.1 #sec-sortcompare

  function SortCompare(x, y, comparefn) {
    if (x === Value.undefined && y === Value.undefined) {
      return new Value(+0);
    }

    if (x === Value.undefined) {
      return new Value(1);
    }

    if (y === Value.undefined) {
      return new Value(-1);
    }

    if (comparefn !== Value.undefined) {
      let callRes = Call(comparefn, Value.undefined, [x, y]);

      if (callRes instanceof AbruptCompletion) {
        return callRes;
      }

      if (callRes instanceof Completion) {
        callRes = callRes.Value;
      }

      let v = ToNumber(callRes);

      if (v instanceof AbruptCompletion) {
        return v;
      }

      if (v instanceof Completion) {
        v = v.Value;
      }

      if (v.isNaN()) {
        return new Value(+0);
      }

      return v;
    }

    let xString = ToString(x);

    if (xString instanceof AbruptCompletion) {
      return xString;
    }

    if (xString instanceof Completion) {
      xString = xString.Value;
    }

    let yString = ToString(y);

    if (yString instanceof AbruptCompletion) {
      return yString;
    }

    if (yString instanceof Completion) {
      yString = yString.Value;
    }

    const xSmaller = AbstractRelationalComparison(xString, yString);

    if (xSmaller === Value.true) {
      return new Value(-1);
    }

    const ySmaller = AbstractRelationalComparison(yString, xString);

    if (ySmaller === Value.true) {
      return new Value(1);
    }

    return new Value(+0);
  } // 22.1.5.1 #sec-createarrayiterator

  function CreateArrayIterator(array, kind) {
    Assert(Type(array) === 'Object', "Type(array) === 'Object'");
    const iterator = ObjectCreate(surroundingAgent.intrinsic('%ArrayIteratorPrototype%'), ['IteratedObject', 'ArrayIteratorNextIndex', 'ArrayIterationKind']);
    iterator.IteratedObject = array;
    iterator.ArrayIteratorNextIndex = 0;
    iterator.ArrayIterationKind = kind;
    return iterator;
  }

  // 24.1 #sec-arraybuffer-objects
  // and, for now
  // 24.2 #sec-sharedarraybuffer-objects
  // 24.1.1.1 #sec-allocatearraybuffer

  function AllocateArrayBuffer(constructor, byteLength) {
    let obj = OrdinaryCreateFromConstructor(constructor, '%ArrayBufferPrototype%', ['ArrayBufferData', 'ArrayBufferByteLength', 'ArrayBufferDetachKey']);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    Assert(byteLength.numberValue() >= 0, "byteLength.numberValue() >= 0");
    Assert(Number.isInteger(byteLength.numberValue()), "Number.isInteger(byteLength.numberValue())");
    let block = CreateByteDataBlock(byteLength);

    if (block instanceof AbruptCompletion) {
      return block;
    }

    if (block instanceof Completion) {
      block = block.Value;
    }

    obj.ArrayBufferData = block;
    obj.ArrayBufferByteLength = byteLength;
    return obj;
  } // 24.1.1.2 #sec-isdetachedbuffer

  function IsDetachedBuffer(arrayBuffer) {
    Assert(Type(arrayBuffer) === 'Object' && 'ArrayBufferData' in arrayBuffer, "Type(arrayBuffer) === 'Object' && 'ArrayBufferData' in arrayBuffer");

    if (Type(arrayBuffer.ArrayBufferData) === 'Null') {
      return true;
    }

    return false;
  } // 24.1.1.3 #sec-detacharraybuffer

  function DetachArrayBuffer(arrayBuffer, key) {
    Assert(Type(arrayBuffer) === 'Object' && 'ArrayBufferData' in arrayBuffer && 'ArrayBufferByteLength' in arrayBuffer && 'ArrayBufferDetachKey' in arrayBuffer, "Type(arrayBuffer) === 'Object' && 'ArrayBufferData' in arrayBuffer && 'ArrayBufferByteLength' in arrayBuffer && 'ArrayBufferDetachKey' in arrayBuffer");
    Assert(IsSharedArrayBuffer(arrayBuffer) === Value.false, "IsSharedArrayBuffer(arrayBuffer) === Value.false");

    if (key === undefined) {
      key = Value.undefined;
    }

    if (SameValue(arrayBuffer.ArrayBufferDetachKey, key) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetachKeyMismatch', key, arrayBuffer));
    }

    arrayBuffer.ArrayBufferData = Value.null;
    arrayBuffer.ArrayBufferByteLength = new Value(0);
    return new NormalCompletion(Value.null);
  } // 24.1.1.4 #sec-clonearraybuffer

  function CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor) {
    Assert(Type(srcBuffer) === 'Object' && 'ArrayBufferData' in srcBuffer, "Type(srcBuffer) === 'Object' && 'ArrayBufferData' in srcBuffer");
    Assert(IsConstructor(cloneConstructor) === Value.true, "IsConstructor(cloneConstructor) === Value.true");
    let targetBuffer = AllocateArrayBuffer(cloneConstructor, srcLength);

    if (targetBuffer instanceof AbruptCompletion) {
      return targetBuffer;
    }

    if (targetBuffer instanceof Completion) {
      targetBuffer = targetBuffer.Value;
    }

    if (IsDetachedBuffer(srcBuffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const srcBlock = srcBuffer.ArrayBufferData;
    const targetBlock = targetBuffer.ArrayBufferData;
    CopyDataBlockBytes(targetBlock, new Value(0), srcBlock, srcByteOffset, srcLength);
    return targetBuffer;
  }
  const throwawayBuffer = new ArrayBuffer(8);
  const throwawayDataView = new DataView(throwawayBuffer);
  const throwawayArray$1 = new Uint8Array(throwawayBuffer); // 24.1.1.5 #sec-rawbytestonumber
  // Sigh

  function RawBytesToNumber(type, rawBytes, isLittleEndian) {
    isLittleEndian = isLittleEndian === Value.true;
    const elementSize = numericTypeInfo.get(type).ElementSize;
    Assert(elementSize === rawBytes.length, "elementSize === rawBytes.length");
    const dataViewType = type === 'Uint8C' ? 'Uint8' : type;
    Object.assign(throwawayArray$1, rawBytes);
    return new Value(throwawayDataView[`get${dataViewType}`](0, isLittleEndian));
  } // 24.1.1.6 #sec-getvaluefrombuffer

  function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order, isLittleEndian) {
    byteIndex = byteIndex.numberValue();
    Assert(!IsDetachedBuffer(arrayBuffer), "!IsDetachedBuffer(arrayBuffer)");
    const info = numericTypeInfo.get(type);
    Assert(info !== undefined, "info !== undefined");
    Assert(arrayBuffer.ArrayBufferByteLength.numberValue() - byteIndex >= info.ElementSize, "arrayBuffer.ArrayBufferByteLength.numberValue() - byteIndex >= info.ElementSize");
    Assert(byteIndex >= 0 && Number.isInteger(byteIndex), "byteIndex >= 0 && Number.isInteger(byteIndex)");
    const block = arrayBuffer.ArrayBufferData;
    const elementSize = info.ElementSize; // if (IsSharedArrayBuffer(arrayBuffer) === Value.true) {
    //
    // } else {

    const rawValue = [...block.subarray(byteIndex, byteIndex + elementSize)]; // }

    if (isLittleEndian === undefined) {
      isLittleEndian = surroundingAgent.LittleEndian;
    }

    return RawBytesToNumber(type, rawValue, isLittleEndian);
  } // An implementation must always choose the same encoding for each
  // implementation distinguishable NaN value.

  const float32NaNLE = Object.freeze([0, 0, 192, 127]);
  const float32NaNBE = Object.freeze([127, 192, 0, 0]);
  const float64NaNLE = Object.freeze([0, 0, 0, 0, 0, 0, 248, 127]);
  const float64NaNBE = Object.freeze([127, 248, 0, 0, 0, 0, 0, 0]); // 24.1.1.7 #sec-numbertorawbytes

  function NumberToRawBytes(type, value, isLittleEndian) {
    Assert(Type(isLittleEndian) === 'Boolean', "Type(isLittleEndian) === 'Boolean'");
    isLittleEndian = isLittleEndian === Value.true;
    let rawBytes; // One day, we will write our own IEEE 754 and two's complement encoder

    if (type === 'Float32') {
      if (Number.isNaN(value.numberValue())) {
        rawBytes = isLittleEndian ? [...float32NaNLE] : [...float32NaNBE];
      } else {
        throwawayDataView.setFloat32(0, value.numberValue(), isLittleEndian);
        rawBytes = [...throwawayArray$1.subarray(0, 4)];
      }
    } else if (type === 'Float64') {
      if (Number.isNaN(value.numberValue())) {
        rawBytes = isLittleEndian ? [...float64NaNLE] : [...float64NaNBE];
      } else {
        throwawayDataView.setFloat64(0, value.numberValue(), isLittleEndian);
        rawBytes = [...throwawayArray$1.subarray(0, 8)];
      }
    } else {
      const info = numericTypeInfo.get(type);
      const n = info.ElementSize;
      const convOp = info.ConversionOperation;

      let _val = convOp(value);

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      const intValue = _val.numberValue();

      const dataViewType = type === 'Uint8C' ? 'Uint8' : type;
      throwawayDataView[`set${dataViewType}`](0, intValue, isLittleEndian);
      rawBytes = [...throwawayArray$1.subarray(0, n)];
    }

    return rawBytes;
  } // 24.1.1.8 #sec-setvalueinbuffer

  function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order, isLittleEndian) {
    byteIndex = byteIndex.numberValue();
    Assert(!IsDetachedBuffer(arrayBuffer), "!IsDetachedBuffer(arrayBuffer)");
    const info = numericTypeInfo.get(type);
    Assert(info !== undefined, "info !== undefined");
    Assert(arrayBuffer.ArrayBufferByteLength.numberValue() - byteIndex >= info.ElementSize, "arrayBuffer.ArrayBufferByteLength.numberValue() - byteIndex >= info.ElementSize");
    Assert(byteIndex >= 0 && Number.isInteger(byteIndex), "byteIndex >= 0 && Number.isInteger(byteIndex)");
    Assert(Type(value) === 'Number', "Type(value) === 'Number'");
    const block = arrayBuffer.ArrayBufferData; // const elementSize = info.ElementSize;

    if (isLittleEndian === undefined) {
      isLittleEndian = surroundingAgent.LittleEndian;
    }

    const rawBytes = NumberToRawBytes(type, value, isLittleEndian); // if (IsSharedArrayBuffer(arrayBuffer) === Value.true) {
    //
    // } else {

    for (let i = 0; i < rawBytes.length; i += 1) {
      block[byteIndex + i] = rawBytes[i];
    } // }


    return new NormalCompletion(Value.undefined);
  } // 24.2.1.2 #sec-issharedarraybuffer

  function IsSharedArrayBuffer(obj) {
    Assert(Type(obj) === 'Object' && 'ArrayBufferData' in obj, "Type(obj) === 'Object' && 'ArrayBufferData' in obj");
    const bufferData = obj.ArrayBufferData;

    if (Type(bufferData) === 'Null') {
      return Value.false;
    }

    if (Type(bufferData) === 'Data Block') {
      return Value.false;
    }

    Assert(Type(bufferData) === 'Shared Data Block', "Type(bufferData) === 'Shared Data Block'");
    return Value.true;
  }

  //   StatementList : StatementList StatementListItem
  //
  // (implicit)
  //   StatementList : StatementListItem

  function* Evaluate_StatementList(StatementList) {
    if (StatementList.length === 0) {
      return new NormalCompletion(undefined);
    }

    let sl = yield* Evaluate(StatementList[0]);

    if (StatementList.length === 1) {
      return sl;
    }

    for (const StatementListItem of StatementList.slice(1)) {
      if (sl instanceof AbruptCompletion) {
        return sl;
      }

      if (sl instanceof Completion) {
        sl = sl.Value;
      }

      let s = yield* Evaluate(StatementListItem); // We don't always return a Completion value, but here we actually need it
      // to be a Completion.

      s = EnsureCompletion(s);
      sl = UpdateEmpty(s, sl);
    }

    return sl;
  } // 15.2.1.23 #sec-module-semantics-runtime-semantics-evaluation
  //   ModuleItemList :
  //     ModuleItem
  //     ModuleItemList ModuleItem

  function* Evaluate_ModuleItemList(ModuleItemList) {
    if (ModuleItemList.length === 0) {
      return new NormalCompletion(undefined);
    }

    let sl = yield* Evaluate(ModuleItemList[0]);

    if (ModuleItemList.length === 1) {
      return sl;
    }

    for (const ModuleItemListItem of ModuleItemList.slice(1)) {
      if (sl instanceof AbruptCompletion) {
        return sl;
      }

      if (sl instanceof Completion) {
        sl = sl.Value;
      }

      let s = yield* Evaluate(ModuleItemListItem); // We don't always return a Completion value, but here we actually need it
      // to be a Completion.

      s = EnsureCompletion(s);
      sl = UpdateEmpty(s, sl);
    }

    return sl;
  } // (implicit)
  //   StatementListItem :
  //     Statement
  //     Declaration
  //
  //   Statement :
  //     BlockStatement
  //     ExpressionStatement
  //     VariableStatement
  //     EmptyStatement
  //     ExpressionStatement
  //     IfStatement
  //     BreakableStatement
  //     ContinueStatement
  //     BreakStatement
  //     ReturnStatement
  //     WithStatement
  //     LabelledStatement
  //     ThrowStatement
  //     TryStatement
  //     DebuggerStatement
  //
  //   Declaration :
  //     HoistableDeclaration
  //     ClassDeclaration
  //     LexicalDeclaration

  function* Evaluate_StatementListItem(StatementListItem) {
    switch (true) {
      case isBlockStatement(StatementListItem):
        return yield* Evaluate_BlockStatement(StatementListItem);

      case isVariableStatement(StatementListItem):
        return yield* Evaluate_VariableStatement(StatementListItem);

      case isEmptyStatement(StatementListItem):
        return Evaluate_EmptyStatement();

      case isExpressionStatement(StatementListItem):
        return yield* Evaluate_ExpressionStatement(StatementListItem);

      case isIfStatement(StatementListItem):
        return yield* Evaluate_IfStatement(StatementListItem);

      case isBreakableStatement(StatementListItem):
        return yield* Evaluate_BreakableStatement(StatementListItem);

      case isContinueStatement(StatementListItem):
        return Evaluate_ContinueStatement(StatementListItem);

      case isBreakStatement(StatementListItem):
        return Evaluate_BreakStatement(StatementListItem);

      case isReturnStatement(StatementListItem):
        return yield* Evaluate_ReturnStatement(StatementListItem);

      case isWithStatement(StatementListItem):
        return yield* Evaluate_WithStatement(StatementListItem);

      case isLabelledStatement(StatementListItem):
        return yield* Evaluate_LabelledStatement(StatementListItem);

      case isThrowStatement(StatementListItem):
        return yield* Evaluate_ThrowStatement(StatementListItem.argument);

      case isTryStatement(StatementListItem):
        return yield* Evaluate_TryStatement(StatementListItem);

      case isDebuggerStatement(StatementListItem):
        return Evaluate_DebuggerStatement();

      case isHoistableDeclaration(StatementListItem):
        return Evaluate_HoistableDeclaration(StatementListItem);

      case isClassDeclaration(StatementListItem):
        return yield* Evaluate_ClassDeclaration(StatementListItem);

      case isLexicalDeclaration(StatementListItem):
        return yield* Evaluate_LexicalDeclaration(StatementListItem);

      default:
        throw new OutOfRange('Evaluate_StatementListItem', StatementListItem);
    }
  }

  const Evaluate_Statement = Evaluate_StatementListItem; // 13.5.1 #sec-expression-statement-runtime-semantics-evaluation
  //   ExpressionStatement : Expression `;`

  function* Evaluate_ExpressionStatement(ExpressionStatement) {
    const exprRef = yield* Evaluate(ExpressionStatement.expression);
    return GetValue(exprRef);
  }

  function EvaluateBinopValues(operator, lval, rval) {
    switch (operator) {
      case '*':
      case '/':
      case '%':
        return EvaluateBinopValues_MultiplicativeExpression(operator, lval, rval);

      case '+':
        return EvaluateBinopValues_AdditiveExpression_Plus(lval, rval);

      case '-':
        return EvaluateBinopValues_AdditiveExpression_Minus(lval, rval);

      case '<<':
      case '>>':
      case '>>>':
        return EvaluateBinopValues_ShiftExpression(operator, lval, rval);

      case '&':
        return EvaluateBinopValues_BitwiseANDExpression(lval, rval);

      case '^':
        return EvaluateBinopValues_BitwiseXORExpression(lval, rval);

      case '|':
        return EvaluateBinopValues_BitwiseORExpression(lval, rval);

      case '**':
        return EvaluateBinopValues_ExponentiationExpression(lval, rval);

      default:
        throw new OutOfRange('EvaluateBinopValues', operator);
    }
  }
  function* Evaluate_Expression(Expression) {
    return EnsureCompletion((yield* Inner_Evaluate_Expression(Expression)));
  } // (implicit)

  function* Inner_Evaluate_Expression(Expression) {
    switch (true) {
      case isThis(Expression):
        return Evaluate_ThisExpression();

      case isIdentifierReference(Expression):
        return Evaluate_Identifier(Expression);

      case isLiteral(Expression):
        return Evaluate_Literal(Expression);

      case isArrayLiteral(Expression):
        return yield* Evaluate_ArrayLiteral(Expression);

      case isObjectLiteral(Expression):
        return yield* Evaluate_ObjectLiteral(Expression);

      case isFunctionExpression(Expression):
        return Evaluate_FunctionExpression(Expression);

      case isClassExpression(Expression):
        return yield* Evaluate_ClassExpression(Expression);

      case isGeneratorExpression(Expression):
        return Evaluate_GeneratorExpression(Expression);

      case isAsyncFunctionExpression(Expression):
        return Evaluate_AsyncFunctionExpression(Expression);

      case isAsyncGeneratorExpression(Expression):
        return Evaluate_AsyncGeneratorExpression(Expression);

      case isRegularExpressionLiteral(Expression):
        return Evaluate_RegularExpressionLiteral(Expression);

      case isTemplateLiteral(Expression):
        return yield* Evaluate_TemplateLiteral(Expression);

      case isActualMemberExpression(Expression):
        return yield* Evaluate_MemberExpression(Expression);

      case isOptionalExpression(Expression):
        return yield* Evaluate_OptionalExpression(Expression);

      case isSuperProperty(Expression):
        return yield* Evaluate_SuperProperty(Expression);

      case isSuperCall(Expression):
        return yield* Evaluate_SuperCall(Expression);

      case isImportCall(Expression):
        return yield* Evaluate_ImportCall(Expression);

      case isTaggedTemplate(Expression):
        return yield* Evaluate_TaggedTemplate(Expression);

      case isMetaProperty(Expression):
        return yield* Evaluate_MetaProperty();

      case isActualNewExpression(Expression):
        return yield* Evaluate_NewExpression(Expression);

      case isActualCallExpression(Expression):
        return yield* Evaluate_CallExpression(Expression);

      case isActualUpdateExpression(Expression):
        return yield* Evaluate_UpdateExpression(Expression);

      case isActualUnaryExpression(Expression):
        return yield* Evaluate_UnaryExpression(Expression);

      case isAwaitExpression(Expression):
        return yield* Evaluate_AwaitExpression(Expression);

      case isActualExponentiationExpression(Expression):
        return yield* Evaluate_ExponentiationExpression(Expression);

      case isActualMultiplicativeExpression(Expression):
        return yield* Evaluate_MultiplicativeExpression(Expression);

      case isActualAdditiveExpression(Expression):
        return yield* Evaluate_AdditiveExpression(Expression);

      case isActualShiftExpression(Expression):
        return yield* Evaluate_ShiftExpression(Expression);

      case isActualRelationalExpression(Expression):
        return yield* Evaluate_RelationalExpression(Expression);

      case isActualEqualityExpression(Expression):
        return yield* Evaluate_EqualityExpression(Expression);

      case isActualBitwiseANDExpression(Expression):
      case isActualBitwiseXORExpression(Expression):
      case isActualBitwiseORExpression(Expression):
        return yield* Evaluate_BinaryBitwiseExpression(Expression);

      case isActualLogicalANDExpression(Expression):
        return yield* Evaluate_LogicalANDExpression(Expression);

      case isActualLogicalORExpression(Expression):
        return yield* Evaluate_LogicalORExpression(Expression);

      case isActualCoalesceExpression(Expression):
        return yield* Evaluate_CoalesceExpression(Expression);

      case isActualConditionalExpression(Expression):
        return yield* Evaluate_ConditionalExpression(Expression);

      case isYieldExpression(Expression):
        return yield* Evaluate_YieldExpression(Expression);

      case isArrowFunction(Expression):
        return Evaluate_ArrowFunction(Expression);

      case isAsyncArrowFunction(Expression):
        return Evaluate_AsyncArrowFunction(Expression);

      case isActualAssignmentExpression(Expression):
        return yield* Evaluate_AssignmentExpression(Expression);

      case isExpressionWithComma(Expression):
        return yield* Evaluate_ExpressionWithComma(Expression);
      // 12.2.10.5 #sec-grouping-operator-runtime-semantics-evaluation

      case isParenthesizedExpression(Expression):
        return yield* Evaluate(Expression.expression);

      default:
        throw new OutOfRange('Evaluate_Expression', Expression);
    }
  } // 15.1.7 #sec-script-semantics-runtime-semantics-evaluation
  //   Script : [empty]
  //
  // (implicit)
  //   Script : ScriptBody
  //   ScriptBody : StatementList


  function Evaluate_Script(Script) {
    if (Script.length === 0) {
      return new NormalCompletion(Value.undefined);
    }

    return unwind(Evaluate_StatementList(Script));
  } // 15.2.1.23 #sec-module-semantics-runtime-semantics-evaluation
  //   ModuleBody : ModuleItemList

  function* Evaluate_ModuleBody(ModuleBody) {
    const ModuleItemList = ModuleBody;
    const result = EnsureCompletion((yield* Evaluate_ModuleItemList(ModuleItemList)));

    if (result.Type === 'normal' && result.Value === undefined) {
      return new NormalCompletion(Value.undefined);
    }

    return Completion(result);
  } // 15.2.1.23 #sec-module-semantics-runtime-semantics-evaluation
  //   Module : [empty]
  //
  // (implicit)
  //   Module : ModuleBody

  function Evaluate_Module(Module) {
    if (Module.length === 0) {
      return new NormalCompletion(Value.undefined);
    }

    return unwind(Evaluate_ModuleBody(Module));
  }
  function* Evaluate(Production) {
    if (surroundingAgent.hostDefinedOptions.onNodeEvaluation) {
      surroundingAgent.hostDefinedOptions.onNodeEvaluation(Production, surroundingAgent.currentRealmRecord);
    }

    switch (true) {
      case isImportDeclaration(Production):
        return new NormalCompletion(undefined);

      case isExportDeclaration(Production):
        return yield* Evaluate_ExportDeclaration(Production);

      case isStatement(Production):
      case isDeclaration(Production):
        return yield* Evaluate_Statement(Production);

      case isExpression(Production):
        return yield* Evaluate_Expression(Production);

      default:
        throw new OutOfRange('Evaluate', Production);
    }
  }

  function EvaluateBinopValues_AdditiveExpression_Plus(lval, rval) {
    let lprim = ToPrimitive(lval);

    if (lprim instanceof AbruptCompletion) {
      return lprim;
    }

    if (lprim instanceof Completion) {
      lprim = lprim.Value;
    }

    let rprim = ToPrimitive(rval);

    if (rprim instanceof AbruptCompletion) {
      return rprim;
    }

    if (rprim instanceof Completion) {
      rprim = rprim.Value;
    }

    if (Type(lprim) === 'String' || Type(rprim) === 'String') {
      let lstr = ToString(lprim);

      if (lstr instanceof AbruptCompletion) {
        return lstr;
      }

      if (lstr instanceof Completion) {
        lstr = lstr.Value;
      }

      let rstr = ToString(rprim);

      if (rstr instanceof AbruptCompletion) {
        return rstr;
      }

      if (rstr instanceof Completion) {
        rstr = rstr.Value;
      }

      return new Value(lstr.stringValue() + rstr.stringValue());
    }

    let lnum = ToNumber(lprim);

    if (lnum instanceof AbruptCompletion) {
      return lnum;
    }

    if (lnum instanceof Completion) {
      lnum = lnum.Value;
    }

    let rnum = ToNumber(rprim);

    if (rnum instanceof AbruptCompletion) {
      return rnum;
    }

    if (rnum instanceof Completion) {
      rnum = rnum.Value;
    }

    return new Value(lnum.numberValue() + rnum.numberValue());
  } // 12.8.3.1 #sec-addition-operator-plus-runtime-semantics-evaluation
  //  AdditiveExpression : AdditiveExpression + MultiplicativeExpression

  function* Evaluate_AdditiveExpression_Plus(AdditiveExpression, MultiplicativeExpression) {
    const lref = yield* Evaluate(AdditiveExpression);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    const rref = yield* Evaluate(MultiplicativeExpression);
    let rval = GetValue(rref);

    if (rval instanceof AbruptCompletion) {
      return rval;
    }

    if (rval instanceof Completion) {
      rval = rval.Value;
    }

    return EvaluateBinopValues_AdditiveExpression_Plus(lval, rval);
  }

  function EvaluateBinopValues_AdditiveExpression_Minus(lval, rval) {
    let lnum = ToNumber(lval);

    if (lnum instanceof AbruptCompletion) {
      return lnum;
    }

    if (lnum instanceof Completion) {
      lnum = lnum.Value;
    }

    let rnum = ToNumber(rval);

    if (rnum instanceof AbruptCompletion) {
      return rnum;
    }

    if (rnum instanceof Completion) {
      rnum = rnum.Value;
    }

    return new Value(lnum.numberValue() - rnum.numberValue());
  } // 12.8.4.1 #sec-subtraction-operator-minus-runtime-semantics-evaluation

  function* Evaluate_AdditiveExpression_Minus(AdditiveExpression, MultiplicativeExpression) {
    const lref = yield* Evaluate(AdditiveExpression);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    const rref = yield* Evaluate(MultiplicativeExpression);
    let rval = GetValue(rref);

    if (rval instanceof AbruptCompletion) {
      return rval;
    }

    if (rval instanceof Completion) {
      rval = rval.Value;
    }

    return EvaluateBinopValues_AdditiveExpression_Minus(lval, rval);
  }

  function* Evaluate_AdditiveExpression(AdditiveExpression) {
    switch (true) {
      case isAdditiveExpressionWithPlus(AdditiveExpression):
        return yield* Evaluate_AdditiveExpression_Plus(AdditiveExpression.left, AdditiveExpression.right);

      case isAdditiveExpressionWithMinus(AdditiveExpression):
        return yield* Evaluate_AdditiveExpression_Minus(AdditiveExpression.left, AdditiveExpression.right);

      default:
        throw new OutOfRange('Evaluate_AdditiveExpression', AdditiveExpression);
    }
  }

  //   TemplateSpans :
  //     TemplateTail
  //     TemplateMiddleList TemplateTail
  //
  //   TemplateMiddleList :
  //     TemplateMiddle Expression
  //     TemplateMiddleList TemplateMiddle Expression

  function* SubstitutionEvaluation_TemplateSpans(TemplateSpans) {
    const preceding = [];

    for (let i = 1; i < TemplateSpans.length; i += 2) {
      const Expression = TemplateSpans[i];
      const nextRef = yield* Evaluate(Expression);
      let next = GetValue(nextRef);

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      preceding.push(next);
    }

    return preceding;
  } // 12.2.9.3 #sec-template-literals-runtime-semantics-argumentlistevaluation
  //   TemplateLiteral : NoSubstitutionTemplate
  //
  // https://github.com/tc39/ecma262/pull/1402
  //   TemplateLiteral : SubstitutionTemplate


  function* ArgumentListEvaluation_TemplateLiteral(TemplateLiteral) {
    switch (true) {
      case isNoSubstitutionTemplate(TemplateLiteral):
        {
          const templateLiteral = TemplateLiteral;
          const siteObj = GetTemplateObject(templateLiteral);
          return [siteObj];
        }

      case isSubstitutionTemplate(TemplateLiteral):
        {
          const templateLiteral = TemplateLiteral;
          const siteObj = GetTemplateObject(templateLiteral);
          const [,
          /* TemplateHead */
          first
          /* Expression */
          , ...rest
          /* TemplateSpans */
          ] = unrollTemplateLiteral(templateLiteral);
          const firstSubRef = yield* Evaluate(first);
          let firstSub = GetValue(firstSubRef);

          if (firstSub instanceof AbruptCompletion) {
            return firstSub;
          }

          if (firstSub instanceof Completion) {
            firstSub = firstSub.Value;
          }

          let restSub = yield* SubstitutionEvaluation_TemplateSpans(rest);

          if (restSub instanceof AbruptCompletion) {
            return restSub;
          }

          if (restSub instanceof Completion) {
            restSub = restSub.Value;
          }

          Assert(Array.isArray(restSub), "Array.isArray(restSub)");
          return [siteObj, firstSub, ...restSub];
        }

      default:
        throw new OutOfRange('ArgumentListEvaluation_TemplateLiteral', TemplateLiteral);
    }
  } // 12.3.6.1 #sec-argument-lists-runtime-semantics-argumentlistevaluation
  //   Arguments : `(` `)`
  //   ArgumentList :
  //     AssignmentExpression
  //     `...` AssignmentExpression
  //     ArgumentList `,` AssignmentExpression
  //     ArgumentList `,` `...` AssignmentExpression
  //
  // (implicit)
  //   Arguments :
  //     `(` ArgumentList `)`
  //     `(` ArgumentList `,` `)`

  function* ArgumentListEvaluation_Arguments(Arguments) {
    const precedingArgs = [];

    for (const AssignmentExpressionOrSpreadElement of Arguments) {
      if (AssignmentExpressionOrSpreadElement.type === 'SpreadElement') {
        const AssignmentExpression = AssignmentExpressionOrSpreadElement.argument;
        const spreadRef = yield* Evaluate(AssignmentExpression);
        let spreadObj = GetValue(spreadRef);

        if (spreadObj instanceof AbruptCompletion) {
          return spreadObj;
        }

        if (spreadObj instanceof Completion) {
          spreadObj = spreadObj.Value;
        }

        let iteratorRecord = GetIterator(spreadObj);

        if (iteratorRecord instanceof AbruptCompletion) {
          return iteratorRecord;
        }

        if (iteratorRecord instanceof Completion) {
          iteratorRecord = iteratorRecord.Value;
        }

        while (true) {
          let next = IteratorStep(iteratorRecord);

          if (next instanceof AbruptCompletion) {
            return next;
          }

          if (next instanceof Completion) {
            next = next.Value;
          }

          if (next === Value.false) {
            break;
          }

          let nextArg = IteratorValue(next);

          if (nextArg instanceof AbruptCompletion) {
            return nextArg;
          }

          if (nextArg instanceof Completion) {
            nextArg = nextArg.Value;
          }

          precedingArgs.push(nextArg);
        }
      } else {
        const AssignmentExpression = AssignmentExpressionOrSpreadElement;
        Assert(isExpression(AssignmentExpression), "isExpression(AssignmentExpression)");
        const ref = yield* Evaluate(AssignmentExpression);
        let arg = GetValue(ref);

        if (arg instanceof AbruptCompletion) {
          return arg;
        }

        if (arg instanceof Completion) {
          arg = arg.Value;
        }

        precedingArgs.push(arg);
      }
    }

    return precedingArgs;
  }
  function ArgumentListEvaluation(ArgumentsOrTemplateLiteral) {
    switch (true) {
      case isTemplateLiteral(ArgumentsOrTemplateLiteral):
        return ArgumentListEvaluation_TemplateLiteral(ArgumentsOrTemplateLiteral);

      case Array.isArray(ArgumentsOrTemplateLiteral):
        return ArgumentListEvaluation_Arguments(ArgumentsOrTemplateLiteral);

      default:
        throw new OutOfRange('ArgumentListEvaluation', ArgumentsOrTemplateLiteral);
    }
  }

  function* ArrayAccumulation_SpreadElement(SpreadElement, array, nextIndex) {
    const spreadRef = yield* Evaluate(SpreadElement.argument);
    let spreadObj = GetValue(spreadRef);

    if (spreadObj instanceof AbruptCompletion) {
      return spreadObj;
    }

    if (spreadObj instanceof Completion) {
      spreadObj = spreadObj.Value;
    }

    let iteratorRecord = GetIterator(spreadObj);

    if (iteratorRecord instanceof AbruptCompletion) {
      return iteratorRecord;
    }

    if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    while (true) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        return nextIndex;
      }

      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      let idxNum = ToUint32(new Value(nextIndex));
      Assert(!(idxNum instanceof AbruptCompletion), "");

      if (idxNum instanceof Completion) {
        idxNum = idxNum.Value;
      }

      let idxStr = ToString(idxNum);
      Assert(!(idxStr instanceof AbruptCompletion), "");

      if (idxStr instanceof Completion) {
        idxStr = idxStr.Value;
      }

      let status = CreateDataProperty(array, idxStr, nextValue);
      Assert(!(status instanceof AbruptCompletion), "");

      if (status instanceof Completion) {
        status = status.Value;
      }

      Assert(status === Value.true, "status === Value.true");
      nextIndex += 1;
    }
  }

  function* ArrayAccumulation_AssignmentExpression(AssignmentExpression, array, nextIndex) {
    const initResult = yield* Evaluate(AssignmentExpression);
    let initValue = GetValue(initResult);

    if (initValue instanceof AbruptCompletion) {
      return initValue;
    }

    if (initValue instanceof Completion) {
      initValue = initValue.Value;
    }

    let idxNum = ToUint32(new Value(nextIndex));
    Assert(!(idxNum instanceof AbruptCompletion), "");

    if (idxNum instanceof Completion) {
      idxNum = idxNum.Value;
    }

    let idxStr = ToString(idxNum);
    Assert(!(idxStr instanceof AbruptCompletion), "");

    if (idxStr instanceof Completion) {
      idxStr = idxStr.Value;
    }

    let created = CreateDataProperty(array, idxStr, initValue);
    Assert(!(created instanceof AbruptCompletion), "");

    if (created instanceof Completion) {
      created = created.Value;
    }

    Assert(created === Value.true, "created === Value.true");
    return nextIndex + 1;
  }

  function* ArrayAccumulation(ElementList, array, nextIndex) {
    let postIndex = nextIndex;

    for (const element of ElementList) {
      switch (true) {
        case !element:
          // Elision
          postIndex += 1;
          break;

        case isExpression(element):
          postIndex = yield* ArrayAccumulation_AssignmentExpression(element, array, postIndex);

          if (postIndex instanceof AbruptCompletion) {
            return postIndex;
          }

          if (postIndex instanceof Completion) {
            postIndex = postIndex.Value;
          }

          break;

        case isSpreadElement(element):
          postIndex = yield* ArrayAccumulation_SpreadElement(element, array, postIndex);

          if (postIndex instanceof AbruptCompletion) {
            return postIndex;
          }

          if (postIndex instanceof Completion) {
            postIndex = postIndex.Value;
          }

          break;

        default:
          throw new OutOfRange('ArrayAccumulation', element);
      }
    }

    return postIndex;
  } // 12.2.5.3 #sec-array-initializer-runtime-semantics-evaluation
  // ArrayLiteral :
  //   `[` Elision `]`
  //   `[` ElementList `]`
  //   `[` ElementList `,` Elision `]`


  function* Evaluate_ArrayLiteral(ArrayLiteral) {
    let array = ArrayCreate(new Value(0));
    Assert(!(array instanceof AbruptCompletion), "");

    if (array instanceof Completion) {
      array = array.Value;
    }

    let len = yield* ArrayAccumulation(ArrayLiteral.elements, array, 0);

    if (len instanceof AbruptCompletion) {
      return len;
    }

    if (len instanceof Completion) {
      len = len.Value;
    }

    Assert(!(Set$1(array, new Value('length'), ToUint32(new Value(len)), Value.false) instanceof AbruptCompletion), ""); // NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.

    return array;
  }

  //   ArrowFunction : ArrowParameters `=>` ConciseBody

  function Evaluate_ArrowFunction(ArrowFunction) {
    const {
      params: ArrowParameters
    } = ArrowFunction;
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const parameters = ArrowParameters;
    const closure = FunctionCreate('Arrow', parameters, ArrowFunction, scope);
    closure.SourceText = sourceTextMatchedBy(ArrowFunction);
    return closure;
  } // https://github.com/tc39/ecma262/pull/1406
  //   ExpressionBody : AssignmentExpression

  function* Evaluate_ExpressionBody(ExpressionBody) {
    const AssignmentExpression = ExpressionBody;
    const exprRef = yield* Evaluate(AssignmentExpression);
    let exprValue = GetValue(exprRef);

    if (exprValue instanceof AbruptCompletion) {
      return exprValue;
    }

    if (exprValue instanceof Completion) {
      exprValue = exprValue.Value;
    }

    return new ReturnCompletion(exprValue);
  }

  //   AssignmentExpression :
  //     LeftHandSideExpression `=` AssignmentExpression
  //     LeftHandSideExpression AssignmentOperator AssignmentExpression

  function* Evaluate_AssignmentExpression(node) {
    const LeftHandSideExpression = node.left;
    const AssignmentExpression = node.right;

    if (node.operator === '=') {
      if (!isAssignmentPattern(LeftHandSideExpression)) {
        let lref = yield* Evaluate(LeftHandSideExpression);

        if (lref instanceof AbruptCompletion) {
          return lref;
        }

        if (lref instanceof Completion) {
          lref = lref.Value;
        }

        let rval;

        if (IsAnonymousFunctionDefinition(AssignmentExpression) && IsIdentifierRef(LeftHandSideExpression)) {
          rval = yield* NamedEvaluation_Expression(AssignmentExpression, GetReferencedName(lref));
        } else {
          const rref = yield* Evaluate(AssignmentExpression);
          rval = GetValue(rref);

          if (rval instanceof AbruptCompletion) {
            return rval;
          }

          if (rval instanceof Completion) {
            rval = rval.Value;
          }
        }

        {
          const hygienicTemp = PutValue(lref, rval);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        return rval;
      }

      const assignmentPattern = LeftHandSideExpression;
      const rref = yield* Evaluate(AssignmentExpression);
      let rval = GetValue(rref);

      if (rval instanceof AbruptCompletion) {
        return rval;
      }

      if (rval instanceof Completion) {
        rval = rval.Value;
      }

      {
        const hygienicTemp = yield* DestructuringAssignmentEvaluation_AssignmentPattern(assignmentPattern, rval);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      return rval;
    } else {
      const AssignmentOperator = node.operator;
      const lref = yield* Evaluate(LeftHandSideExpression);
      let lval = GetValue(lref);

      if (lval instanceof AbruptCompletion) {
        return lval;
      }

      if (lval instanceof Completion) {
        lval = lval.Value;
      }

      const rref = yield* Evaluate(AssignmentExpression);
      let rval = GetValue(rref);

      if (rval instanceof AbruptCompletion) {
        return rval;
      }

      if (rval instanceof Completion) {
        rval = rval.Value;
      }

      // Let op be the @ where AssignmentOperator is @=.
      const op = AssignmentOperator.slice(0, -1); // Let r be the result of applying op to lval and rval
      // as if evaluating the expression lval op rval.

      const r = EvaluateBinopValues(op, lval, rval);
      {
        const hygienicTemp = PutValue(lref, r);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      return r;
    }
  }

  //   AsyncArrowFunction :
  //     `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
  //     CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody

  function Evaluate_AsyncArrowFunction(AsyncArrowFunction) {
    const {
      params: ArrowFormalParameters
    } = AsyncArrowFunction;
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const parameters = ArrowFormalParameters;
    let closure = AsyncFunctionCreate('Arrow', parameters, AsyncArrowFunction, scope);
    Assert(!(closure instanceof AbruptCompletion), "");

    if (closure instanceof Completion) {
      closure = closure.Value;
    }

    closure.SourceText = sourceTextMatchedBy(AsyncArrowFunction);
    return closure;
  }

  function Evaluate_AsyncFunctionExpression_BindingIdentifier(AsyncFunctionExpression) {
    const {
      id: BindingIdentifier,
      params: FormalParameters
    } = AsyncFunctionExpression;
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const funcEnv = NewDeclarativeEnvironment(scope);
    const envRec = funcEnv.EnvironmentRecord;
    const name = new Value(BindingIdentifier.name);
    Assert(!(envRec.CreateImmutableBinding(name, Value.false) instanceof AbruptCompletion), "");
    let closure = AsyncFunctionCreate('Normal', FormalParameters, AsyncFunctionExpression, funcEnv);
    Assert(!(closure instanceof AbruptCompletion), "");

    if (closure instanceof Completion) {
      closure = closure.Value;
    }

    Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
    Assert(!(envRec.InitializeBinding(name, closure) instanceof AbruptCompletion), "");
    closure.SourceText = sourceTextMatchedBy(AsyncFunctionExpression);
    return closure;
  }

  function Evaluate_AsyncFunctionExpression(AsyncFunctionExpression) {
    if (isAsyncFunctionExpressionWithBindingIdentifier(AsyncFunctionExpression)) {
      return Evaluate_AsyncFunctionExpression_BindingIdentifier(AsyncFunctionExpression);
    }

    const {
      params: FormalParameters
    } = AsyncFunctionExpression;
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    let closure = AsyncFunctionCreate('Normal', FormalParameters, AsyncFunctionExpression, scope);
    Assert(!(closure instanceof AbruptCompletion), "");

    if (closure instanceof Completion) {
      closure = closure.Value;
    }

    closure.SourceText = sourceTextMatchedBy(AsyncFunctionExpression);
    return closure;
  }

  //   AsyncGeneratorExpression :
  //     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  //     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

  function Evaluate_AsyncGeneratorExpression(AsyncGeneratorExpression) {
    const {
      id: BindingIdentifier,
      params: FormalParameters
    } = AsyncGeneratorExpression;
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    let funcEnv = scope;
    let envRec;
    let name;

    if (BindingIdentifier) {
      funcEnv = NewDeclarativeEnvironment(scope);
      envRec = funcEnv.EnvironmentRecord;
      name = new Value(BindingIdentifier.name);
      envRec.CreateImmutableBinding(name, Value.false);
    }

    let closure = AsyncGeneratorFunctionCreate('Normal', FormalParameters, AsyncGeneratorExpression, funcEnv);
    Assert(!(closure instanceof AbruptCompletion), "");

    if (closure instanceof Completion) {
      closure = closure.Value;
    }

    const prototype = ObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorPrototype%'));
    Assert(!(DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    closure.SourceText = sourceTextMatchedBy(AsyncGeneratorExpression);

    if (BindingIdentifier) {
      Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
      envRec.InitializeBinding(name, closure);
    }

    return closure;
  }

  // AwaitExpression : `await` UnaryExpression

  function* Evaluate_AwaitExpression({
    argument: UnaryExpression
  }) {
    const exprRef = yield* Evaluate(UnaryExpression);
    let value = GetValue(exprRef);

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    return yield* Await(value);
  }

  function InitializeBoundName(name, value, environment) {
    Assert(Type(name) === 'String', "Type(name) === 'String'");

    if (Type(environment) !== 'Undefined') {
      const env = environment.EnvironmentRecord;
      env.InitializeBinding(name, value);
      return new NormalCompletion(Value.undefined);
    } else {
      const lhs = ResolveBinding(name, undefined, false);
      return PutValue(lhs, value);
    }
  } // 12.1.5 #sec-identifiers-runtime-semantics-bindinginitialization
  //   BindingIdentifier :
  //     Identifier
  //     `yield`
  //     `await`

  function BindingInitialization_BindingIdentifier(BindingIdentifier, value, environment) {
    const name = new Value(BindingIdentifier.name);
    return InitializeBoundName(name, value, environment);
  } // 13.3.3.5 #sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization
  //   BindingPattern :
  //     ObjectBindingPattern
  //     ArrayBindingPattern

  function* BindingInitialization_BindingPattern(BindingPattern, value, environment) {
    switch (true) {
      case isObjectBindingPattern(BindingPattern):
        {
          const hygienicTemp = RequireObjectCoercible(value);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        return yield* BindingInitialization_ObjectBindingPattern(BindingPattern, value, environment);

      case isArrayBindingPattern(BindingPattern):
        {
          let iteratorRecord = GetIterator(value);

          if (iteratorRecord instanceof AbruptCompletion) {
            return iteratorRecord;
          }

          if (iteratorRecord instanceof Completion) {
            iteratorRecord = iteratorRecord.Value;
          }

          const result = yield* IteratorBindingInitialization_ArrayBindingPattern(BindingPattern, iteratorRecord, environment);

          if (iteratorRecord.Done === Value.false) {
            return IteratorClose(iteratorRecord, result);
          }

          return result;
        }

      default:
        throw new OutOfRange('BindingInitialization_BindingPattern', BindingPattern);
    }
  } // (implicit)
  //   ForBinding :
  //     BindingIdentifier
  //     BindingPattern

  function* BindingInitialization_ForBinding(ForBinding, value, environment) {
    switch (true) {
      case isBindingIdentifier(ForBinding):
        return BindingInitialization_BindingIdentifier(ForBinding, value, environment);

      case isBindingPattern(ForBinding):
        return yield* BindingInitialization_BindingPattern(ForBinding, value, environment);

      default:
        throw new OutOfRange('BindingInitialization_ForBinding', ForBinding);
    }
  } // 13.3.3.5 #sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization
  //   ObjectBindingPattern :
  //     `{` `}`
  //     `{` BindingPropertyList `}`
  //     `{` BindingPropertyList `,` `}`
  //     `{` BindingRestProperty `}`
  //     `{` BindingPropertyList `,` BindingRestProperty `}`

  function* BindingInitialization_ObjectBindingPattern(ObjectBindingPattern, value, environment) {
    if (ObjectBindingPattern.properties.length === 0) {
      return new NormalCompletion(undefined);
    }

    let BindingRestProperty;
    let BindingPropertyList = ObjectBindingPattern.properties;
    const last = ObjectBindingPattern.properties[ObjectBindingPattern.properties.length - 1];

    if (isBindingRestProperty(last)) {
      BindingRestProperty = last;
      BindingPropertyList = BindingPropertyList.slice(0, -1);
    }

    let excludedNames = yield* PropertyBindingInitialization_BindingPropertyList(BindingPropertyList, value, environment);

    if (excludedNames instanceof AbruptCompletion) {
      return excludedNames;
    }

    if (excludedNames instanceof Completion) {
      excludedNames = excludedNames.Value;
    }

    if (BindingRestProperty === undefined) {
      return new NormalCompletion(undefined);
    }

    return RestBindingInitialization_BindingRestProperty(BindingRestProperty, value, environment, excludedNames);
  }

  function* BindingInitialization_CatchParameter(CatchParameter, value, environment) {
    switch (true) {
      case isBindingIdentifier(CatchParameter):
        return BindingInitialization_BindingIdentifier(CatchParameter, value, environment);

      case isBindingPattern(CatchParameter):
        return yield* BindingInitialization_BindingPattern(CatchParameter, value, environment);

      default:
        throw new OutOfRange('BindingInitialization_CatchParameter', CatchParameter);
    }
  } // 13.7.5.9 #sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization
  //   ForDeclaration : LetOrConst ForBinding

  function* BindingInitialization_ForDeclaration(ForDeclaration, value, environment) {
    return yield* BindingInitialization_ForBinding(ForDeclaration.declarations[0].id, value, environment);
  }

  /* eslint-disable no-bitwise */

  function EvaluateBinopValues_BitwiseANDExpression(lval, rval) {
    let lnum = ToInt32(lval);

    if (lnum instanceof AbruptCompletion) {
      return lnum;
    }

    if (lnum instanceof Completion) {
      lnum = lnum.Value;
    }

    let rnum = ToInt32(rval);

    if (rnum instanceof AbruptCompletion) {
      return rnum;
    }

    if (rnum instanceof Completion) {
      rnum = rnum.Value;
    }

    return new Value(lnum.numberValue() & rnum.numberValue());
  }
  function EvaluateBinopValues_BitwiseXORExpression(lval, rval) {
    let lnum = ToInt32(lval);

    if (lnum instanceof AbruptCompletion) {
      return lnum;
    }

    if (lnum instanceof Completion) {
      lnum = lnum.Value;
    }

    let rnum = ToInt32(rval);

    if (rnum instanceof AbruptCompletion) {
      return rnum;
    }

    if (rnum instanceof Completion) {
      rnum = rnum.Value;
    }

    return new Value(lnum.numberValue() ^ rnum.numberValue());
  }
  function EvaluateBinopValues_BitwiseORExpression(lval, rval) {
    let lnum = ToInt32(lval);

    if (lnum instanceof AbruptCompletion) {
      return lnum;
    }

    if (lnum instanceof Completion) {
      lnum = lnum.Value;
    }

    let rnum = ToInt32(rval);

    if (rnum instanceof AbruptCompletion) {
      return rnum;
    }

    if (rnum instanceof Completion) {
      rnum = rnum.Value;
    }

    return new Value(lnum.numberValue() | rnum.numberValue());
  } // 12.12.3 #sec-binary-bitwise-operators-runtime-semantics-evaluation

  function* Evaluate_BinaryBitwiseExpression({
    left: A,
    operator,
    right: B
  }) {
    const lref = yield* Evaluate(A);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    const rref = yield* Evaluate(B);
    let rval = GetValue(rref);

    if (rval instanceof AbruptCompletion) {
      return rval;
    }

    if (rval instanceof Completion) {
      rval = rval.Value;
    }

    // Return the result of applying the bitwise operator @ to lnum and rnum.
    switch (operator) {
      case '&':
        return EvaluateBinopValues_BitwiseANDExpression(lval, rval);

      case '^':
        return EvaluateBinopValues_BitwiseXORExpression(lval, rval);

      case '|':
        return EvaluateBinopValues_BitwiseORExpression(lval, rval);

      default:
        throw new OutOfRange('Evaluate_BinaryBiwise', operator);
    }
  }

  function BlockDeclarationInstantiation(code, env) {
    const envRec = env.EnvironmentRecord;
    Assert(envRec instanceof DeclarativeEnvironmentRecord, "envRec instanceof DeclarativeEnvironmentRecord");
    const declarations = LexicallyScopedDeclarations_StatementList(code);

    for (const d of declarations) {
      for (const dn of BoundNames_Declaration(d).map(Value)) {
        if (IsConstantDeclaration(d)) {
          Assert(!(envRec.CreateImmutableBinding(dn, Value.true) instanceof AbruptCompletion), "");
        } else {
          Assert(!(envRec.CreateMutableBinding(dn, false) instanceof AbruptCompletion), "");
        }

        if (isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)) {
          const fn = BoundNames_Declaration(d)[0];
          const fo = InstantiateFunctionObject(d, env);
          envRec.InitializeBinding(new Value(fn), fo);
        }
      }
    }
  } // 13.2.13 #sec-block-runtime-semantics-evaluation
  //   Block :
  //     `{` `}`
  //     `{` StatementList `}`

  function* Evaluate_Block(Block) {
    const StatementList = Block.body;

    if (StatementList.length === 0) {
      return new NormalCompletion(undefined);
    }

    const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const blockEnv = NewDeclarativeEnvironment(oldEnv);
    BlockDeclarationInstantiation(StatementList, blockEnv);
    surroundingAgent.runningExecutionContext.LexicalEnvironment = blockEnv;
    const blockValue = yield* Evaluate_StatementList(StatementList);
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
    return blockValue;
  }
  const Evaluate_BlockStatement = Evaluate_Block;

  // BreakStatement :
  //   `break` `;`
  //   `break` LabelIdentifier `;`

  function Evaluate_BreakStatement({
    label: LabelIdentifier
  }) {
    if (LabelIdentifier) {
      const label = new Value(LabelIdentifier.name);
      return new BreakCompletion(label);
    } else {
      return new BreakCompletion();
    }
  }

  //   BreakableStatement :
  //     IterationStatement
  //     SwitchStatement

  function* Evaluate_BreakableStatement(BreakableStatement) {
    const newLabelSet = [];
    return yield* LabelledEvaluation_BreakableStatement(BreakableStatement, newLabelSet);
  } // 13.1.7 #sec-statement-semantics-runtime-semantics-labelledevaluation
  //   BreakableStatement : IterationStatement

  function* LabelledEvaluation_BreakableStatement(BreakableStatement, labelSet) {
    switch (true) {
      case isIterationStatement(BreakableStatement):
        {
          let stmtResult = EnsureCompletion((yield* LabelledEvaluation_IterationStatement(BreakableStatement, labelSet)));

          if (stmtResult.Type === 'break') {
            if (stmtResult.Target === undefined) {
              if (stmtResult.Value === undefined) {
                stmtResult = new NormalCompletion(Value.undefined);
              } else {
                stmtResult = new NormalCompletion(stmtResult.Value);
              }
            }
          }

          return Completion(stmtResult);
        }

      case isSwitchStatement(BreakableStatement):
        {
          let stmtResult = EnsureCompletion((yield* Evaluate_SwitchStatement(BreakableStatement)));

          if (stmtResult.Type === 'break') {
            if (stmtResult.Target === undefined) {
              if (stmtResult.Value === undefined) {
                stmtResult = new NormalCompletion(Value.undefined);
              } else {
                stmtResult = new NormalCompletion(stmtResult.Value);
              }
            }
          }

          return Completion(stmtResult);
        }

      default:
        throw new OutOfRange('LabelledEvaluation_BreakableStatement', BreakableStatement);
    }
  }

  function* EvaluateCall(func, ref, args, tailPosition) {
    let thisValue;

    if (Type(ref) === 'Reference') {
      if (IsPropertyReference(ref) === Value.true) {
        thisValue = GetThisValue(ref);
      } else {
        const refEnv = GetBase(ref);
        thisValue = refEnv.WithBaseObject();
      }
    } else {
      thisValue = Value.undefined;
    }

    let argList = yield* ArgumentListEvaluation(args);

    if (argList instanceof AbruptCompletion) {
      return argList;
    }

    if (argList instanceof Completion) {
      argList = argList.Value;
    }

    if (Type(func) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', func));
    }

    if (IsCallable(func) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', func));
    }

    const result = Call(func, thisValue, argList); // Assert: If tailPosition is true, the above call will not return here
    // but instead evaluation will continue as if the following return has already occurred.

    if (!(result instanceof AbruptCompletion)) {
      Assert(result instanceof Value || result instanceof Completion, "result instanceof Value || result instanceof Completion");
    }

    return result;
  } // 12.3.4.1 #sec-function-calls-runtime-semantics-evaluation
  // CallExpression :
  //   CoverCallExpressionAndAsyncArrowHead
  //   CallExpression Arguments

  function* Evaluate_CallExpression(CallExpression) {
    const expr = CallExpression;
    const memberExpr = expr.callee;
    const args = expr.arguments;
    const ref = yield* Evaluate(memberExpr);
    let func = GetValue(ref);

    if (func instanceof AbruptCompletion) {
      return func;
    }

    if (func instanceof Completion) {
      func = func.Value;
    }

    if (Type(ref) === 'Reference' && IsPropertyReference(ref) === Value.false && Type(GetReferencedName(ref)) === 'String' && GetReferencedName(ref).stringValue() === 'eval') {
      if (SameValue(func, surroundingAgent.intrinsic('%eval%')) === Value.true) {
        let argList = yield* ArgumentListEvaluation_Arguments(args);

        if (argList instanceof AbruptCompletion) {
          return argList;
        }

        if (argList instanceof Completion) {
          argList = argList.Value;
        }

        if (argList.length === 0) {
          return Value.undefined;
        }

        const evalText = argList[0];
        const strictCaller = CallExpression.strict;
        const evalRealm = surroundingAgent.currentRealmRecord;
        return PerformEval(evalText, evalRealm, strictCaller, true);
      }
    }
    return yield* EvaluateCall(func, ref, args);
  }

  //   ClassTail : ClassHeritage `{` ClassBody `}`

  function* ClassDefinitionEvaluation_ClassTail({
    ClassHeritage,
    ClassBody
  }, classBinding, className) {
    const lex = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const classScope = NewDeclarativeEnvironment(lex);
    const classScopeEnvRec = classScope.EnvironmentRecord;

    if (classBinding !== Value.undefined) {
      classScopeEnvRec.CreateImmutableBinding(classBinding, Value.true);
    }

    let protoParent;
    let constructorParent;

    if (!ClassHeritage) {
      protoParent = surroundingAgent.intrinsic('%ObjectPrototype%');
      constructorParent = surroundingAgent.intrinsic('%FunctionPrototype%');
    } else {
      surroundingAgent.runningExecutionContext.LexicalEnvironment = classScope;
      const superclassRef = yield* Evaluate(ClassHeritage);
      surroundingAgent.runningExecutionContext.LexicalEnvironment = lex;
      let superclass = GetValue(superclassRef);

      if (superclass instanceof AbruptCompletion) {
        return superclass;
      }

      if (superclass instanceof Completion) {
        superclass = superclass.Value;
      }

      if (Type(superclass) === 'Null') {
        protoParent = Value.null;
        constructorParent = surroundingAgent.intrinsic('%FunctionPrototype%');
      } else if (IsConstructor(superclass) === Value.false) {
        return surroundingAgent.Throw('TypeError');
      } else {
        protoParent = Get(superclass, new Value('prototype'));

        if (protoParent instanceof AbruptCompletion) {
          return protoParent;
        }

        if (protoParent instanceof Completion) {
          protoParent = protoParent.Value;
        }

        if (Type(protoParent) !== 'Object' && Type(protoParent) !== 'Null') {
          return surroundingAgent.Throw('TypeError');
        }

        constructorParent = superclass;
      }
    }

    const proto = ObjectCreate(protoParent);
    let constructor;

    if (!ClassBody) {
      constructor = undefined;
    } else {
      constructor = ConstructorMethod_ClassBody(ClassBody);
    }

    if (constructor === undefined) {
      if (ClassHeritage) {
        // Set constructor to the result of parsing the source text `constructor(...args) { super(...args); }`
        constructor = forwardingConstructorNode;
      } else {
        // Set constructor to the result of parsing the source text `constructor() {}`
        constructor = emptyConstructorNode;
      }
    }

    surroundingAgent.runningExecutionContext.LexicalEnvironment = classScope;
    const constructorInfo = yield* DefineMethod(constructor, proto, constructorParent);
    Assert(!(constructorInfo instanceof AbruptCompletion), "!(constructorInfo instanceof AbruptCompletion)");
    const F = constructorInfo.Closure;

    if (ClassHeritage) {
      F.ConstructorKind = 'derived';
    }

    MakeConstructor(F, false, proto);
    MakeClassConstructor(F);

    if (className !== Value.undefined) {
      Assert(!(SetFunctionName(F, className) instanceof AbruptCompletion), "");
    }

    CreateMethodProperty(proto, new Value('constructor'), F);
    let methods;

    if (!ClassBody) {
      methods = [];
    } else {
      methods = NonConstructorMethodDefinitions_ClassBody(ClassBody);
    }

    for (const m of methods) {
      let status;

      if (IsStatic_ClassElement(m) === false) {
        status = yield* PropertyDefinitionEvaluation_ClassElement(m, proto, false);
      } else {
        status = yield* PropertyDefinitionEvaluation_ClassElement(m, F, false);
      }

      if (status instanceof AbruptCompletion) {
        surroundingAgent.runningExecutionContext.LexicalEnvironment = lex;
        return Completion(status);
      }
    }

    surroundingAgent.runningExecutionContext.LexicalEnvironment = lex;

    if (classBinding !== Value.undefined) {
      classScopeEnvRec.InitializeBinding(classBinding, F);
    }

    return F;
  } // 14.6.16 #sec-class-definitions-runtime-semantics-evaluation
  //   ClassExpression : `class` BindingIdentifier ClassTail

  function* Evaluate_ClassExpression(ClassExpression) {
    const {
      id: BindingIdentifier,
      body,
      superClass
    } = ClassExpression;
    const ClassTail = {
      ClassHeritage: superClass,
      ClassBody: body.body
    };
    let className;

    if (!BindingIdentifier) {
      className = Value.undefined;
    } else {
      className = new Value(BindingIdentifier.name);
    }

    let value = yield* ClassDefinitionEvaluation_ClassTail(ClassTail, className, className);

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    value.SourceText = sourceTextMatchedBy(ClassExpression);
    return value;
  } // 14.6.14 #sec-runtime-semantics-bindingclassdeclarationevaluation
  //   ClassDeclaration :
  //     `class` BindingIdentifier ClassTail
  //     `class` ClassTail

  function* BindingClassDeclarationEvaluation_ClassDeclaration(ClassDeclaration) {
    const {
      id: BindingIdentifier,
      body,
      superClass: ClassHeritage
    } = ClassDeclaration;
    const ClassTail = {
      ClassHeritage,
      ClassBody: body.body
    };
    let classBinding;
    let className;

    if (!BindingIdentifier) {
      classBinding = Value.undefined;
      className = new Value('default');
    } else {
      classBinding = new Value(BindingIdentifier.name);
      className = classBinding;
    }

    let value = yield* ClassDefinitionEvaluation_ClassTail(ClassTail, classBinding, className);

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    value.SourceText = sourceTextMatchedBy(ClassDeclaration);

    if (BindingIdentifier) {
      const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
      {
        const hygienicTemp = InitializeBoundName(className, value, env);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    return value;
  } // 14.6.16 #sec-class-definitions-runtime-semantics-evaluation
  //   ClassDeclaration : `class` BindingIdentifier ClassTail

  function* Evaluate_ClassDeclaration(ClassDeclaration) {
    {
      const hygienicTemp = yield* BindingClassDeclarationEvaluation_ClassDeclaration(ClassDeclaration);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return new NormalCompletion(undefined);
  }

  // CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression

  function* Evaluate_CoalesceExpression({
    left: CoalesceExpressionHead,
    right: BitwiseORExpression
  }) {
    const lref = yield* Evaluate(CoalesceExpressionHead);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    if (lval === Value.undefined || lval === Value.null) {
      const rref = yield* Evaluate(BitwiseORExpression);
      return GetValue(rref);
    }

    return lval;
  }

  // ConditionalExpression : LogicalORExpression `?` AssignmentExpression `:` AssignmentExpression

  function* Evaluate_ConditionalExpression({
    test: LogicalORExpression,
    consequent: FirstAssignmentExpression,
    alternate: SecondAssignmentExpression
  }) {
    const lref = yield* Evaluate(LogicalORExpression);

    let _hygienicTemp = GetValue(lref);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const lval = ToBoolean(_hygienicTemp);

    if (lval === Value.true) {
      const trueRef = yield* Evaluate(FirstAssignmentExpression);
      return GetValue(trueRef);
    } else {
      const falseRef = yield* Evaluate(SecondAssignmentExpression);
      return GetValue(falseRef);
    }
  }

  // ContinueStatement :
  //   `continue` `;`
  //   `continue` LabelIdentifier `;`

  function Evaluate_ContinueStatement({
    label: LabelIdentifier
  }) {
    if (LabelIdentifier) {
      const label = new Value(LabelIdentifier.name);
      return new ContinueCompletion(label);
    } else {
      return new ContinueCompletion(undefined);
    }
  }

  function hasIntersection(reference, check) {
    if (reference.length === 0 || check.length === 0) {
      return false;
    }

    const refSet = new Set(reference);

    for (const el of check) {
      if (refSet.has(el)) {
        return el;
      }
    }

    return false;
  } // #table-dynamic-function-sourcetext-prefixes


  const DynamicFunctionSourceTextPrefixes = {
    'normal': 'function',
    'generator': 'function*',
    'async': 'async function',
    'async generator': 'async function*'
  }; // 19.2.1.1.1 #sec-createdynamicfunction

  function CreateDynamicFunction(constructor, newTarget, kind, args) {
    Assert(surroundingAgent.executionContextStack.length >= 2, "surroundingAgent.executionContextStack.length >= 2");
    const callerContext = surroundingAgent.executionContextStack[surroundingAgent.executionContextStack.length - 2];
    const callerRealm = callerContext.Realm;
    const calleeRealm = surroundingAgent.currentRealmRecord;
    {
      const hygienicTemp = HostEnsureCanCompileStrings(callerRealm, calleeRealm);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (Type(newTarget) === 'Undefined') {
      newTarget = constructor;
    }

    let bodyParser;
    let enableYield;
    let enableAwait;
    let fallbackProto;

    if (kind === 'normal') {
      bodyParser = ParseAsFunctionBody;
      enableYield = false;
      enableAwait = false;
      fallbackProto = '%FunctionPrototype%';
    } else if (kind === 'generator') {
      bodyParser = ParseAsGeneratorBody;
      enableYield = true;
      enableAwait = false;
      fallbackProto = '%Generator%';
    } else if (kind === 'async') {
      bodyParser = ParseAsAsyncFunctionBody;
      enableYield = false;
      enableAwait = true;
      fallbackProto = '%AsyncFunctionPrototype%';
    } else if (kind === 'async generator') {
      bodyParser = ParseAsAsyncGeneratorBody;
      enableYield = true;
      enableAwait = true;
      fallbackProto = '%AsyncGenerator%';
    }

    const argCount = args.length;
    let P = '';
    let bodyText;

    if (argCount === 0) {
      bodyText = new Value('');
    } else if (argCount === 1) {
      bodyText = args[0];
    } else {
      const firstArg = args[0];

      let _hygienicTemp = ToString(firstArg);

      if (_hygienicTemp instanceof AbruptCompletion) {
        return _hygienicTemp;
      }

      if (_hygienicTemp instanceof Completion) {
        _hygienicTemp = _hygienicTemp.Value;
      }

      P = _hygienicTemp.stringValue();
      let k = 1;

      while (k < argCount - 1) {
        const nextArg = args[k];
        let nextArgString = ToString(nextArg);

        if (nextArgString instanceof AbruptCompletion) {
          return nextArgString;
        }

        if (nextArgString instanceof Completion) {
          nextArgString = nextArgString.Value;
        }

        P = `${P},${nextArgString.stringValue()}`;
        k += 1;
      }

      bodyText = args[k];
    }

    let _hygienicTemp2 = ToString(bodyText);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    bodyText = _hygienicTemp2.stringValue();
    let body;

    try {
      body = bodyParser(bodyText);
    } catch (err) {
      return surroundingAgent.Throw('SyntaxError', err.message);
    }

    const strict = ContainsUseStrict_FunctionBody(body);
    let parameters;

    try {
      parameters = ParseAsFormalParameters(P, strict, enableAwait, enableYield);
    } catch (err) {
      return surroundingAgent.Throw('SyntaxError', err.message);
    } // These steps are included in ParseAsFormalParameters:
    // 20. If strict is true, the Early Error rules for UniqueFormalParameters : FormalParameters are applied.
    // 21. If strict is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.
    // 24. If parameters Contains SuperCall is true, throw a SyntaxError exception.
    // 26. If parameters Contains SuperProperty is true, throw a SyntaxError exception.
    // 27. If kind is "generator" or "async generator", then
    //   a. If parameters Contains YieldExpression is true, throw a SyntaxError exception.
    // 28. If kind is "async" or "async generator", then
    //   a. If parameters Contains AwaitExpression is true, throw a SyntaxError exception.
    // 29. If strict is true, then
    //   a. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.
    // 22. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.


    const intersected = hasIntersection(BoundNames_FormalParameters(parameters), LexicallyDeclaredNames_FunctionBody(body));

    if (intersected !== false) {
      return surroundingAgent.Throw('SyntaxError', `Identifier '${intersected}' is already declared`);
    }

    const fabricatedFunctionNode = {
      type: 'FunctionExpression',
      id: null,
      generator: enableYield,
      expression: false,
      async: enableAwait,
      params: parameters,
      strict,
      body: {
        type: 'BlockStatement',
        body,
        strict
      }
    };
    let proto = GetPrototypeFromConstructor(newTarget, fallbackProto);

    if (proto instanceof AbruptCompletion) {
      return proto;
    }

    if (proto instanceof Completion) {
      proto = proto.Value;
    }

    const F = FunctionAllocate(proto, kind);
    const realmF = F.Realm;
    const scope = realmF.GlobalEnv;
    FunctionInitialize(F, 'Normal', parameters, fabricatedFunctionNode, scope);

    if (kind === 'generator') {
      const prototype = ObjectCreate(surroundingAgent.intrinsic('%GeneratorPrototype%'));
      Assert(!(DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
        Value: prototype,
        Writable: Value.true,
        Enumerable: Value.false,
        Configurable: Value.false
      })) instanceof AbruptCompletion), "");
    } else if (kind === 'async generator') {
      const prototype = ObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorPrototype%'));
      Assert(!(DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
        Value: prototype,
        Writable: Value.true,
        Enumerable: Value.false,
        Configurable: Value.false
      })) instanceof AbruptCompletion), "");
    } else if (kind === 'normal') {
      MakeConstructor(F);
    }

    SetFunctionName(F, new Value('anonymous'));
    const prefix = DynamicFunctionSourceTextPrefixes[kind];
    const sourceText = `${prefix} anonymous(${P}\u000A) {\u000A${bodyText}\u000A}`;
    F.SourceText = new Value(sourceText);
    return F;
  }

  // DebuggerStatement : `debugger` `;`

  function Evaluate_DebuggerStatement() {
    if (surroundingAgent.hostDefinedOptions.onDebugger) {
      {
        const hygienicTemp = surroundingAgent.hostDefinedOptions.onDebugger();

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }
  }

  // MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`

  function* DefineMethod(MethodDefinition, object, functionPrototype) {
    const PropertyName = MethodDefinition.key;
    const UniqueFormalParameters = MethodDefinition.value.params;
    let propKey = yield* Evaluate_PropertyName(PropertyName, MethodDefinition.computed);

    if (propKey instanceof AbruptCompletion) {
      return propKey;
    }

    if (propKey instanceof Completion) {
      propKey = propKey.Value;
    }

    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    let kind;
    let prototype;

    if (functionPrototype !== undefined) {
      kind = 'Normal';
      prototype = functionPrototype;
    } else {
      kind = 'Method';
      prototype = surroundingAgent.intrinsic('%FunctionPrototype%');
    }

    const closure = FunctionCreate(kind, UniqueFormalParameters, MethodDefinition.value, scope, prototype);
    Assert(!(MakeMethod(closure, object) instanceof AbruptCompletion), "");
    closure.SourceText = sourceTextMatchedBy(MethodDefinition);
    return {
      Key: propKey,
      Closure: closure
    };
  }

  //   AssignmentPattern :
  //     ObjectAssignmentPattern
  //     ArrayAssignmentPattern

  function* DestructuringAssignmentEvaluation_AssignmentPattern(AssignmentPattern, value) {
    switch (true) {
      case isObjectAssignmentPattern(AssignmentPattern):
        return yield* DestructuringAssignmentEvaluation_ObjectAssignmentPattern(AssignmentPattern, value);

      case isArrayAssignmentPattern(AssignmentPattern):
        return yield* DestructuringAssignmentEvaluation_ArrayAssignmentPattern(AssignmentPattern, value);

      default:
        throw new OutOfRange('DestructuringAssignmentEvaluation_AssignmentPattern', AssignmentPattern);
    }
  } // 12.15.5.2 #sec-runtime-semantics-destructuringassignmentevaluation
  //   ObjectAssignmentPattern :
  //     `{` `}`
  //     `{` AssignmentRestProperty `}`
  //     `{` AssignmentPropertyList `}`
  //     `{` AssignmentPropertyList `,` `}`
  //     `{` AssignmentPropertyList `,` AssignmentRestProperty `}`

  function* DestructuringAssignmentEvaluation_ObjectAssignmentPattern(ObjectAssignmentPattern, value) {
    let AssignmentPropertyList = ObjectAssignmentPattern.properties;
    let AssignmentRestProperty; // Members of the AssignmentPropertyList may be null, so add a truthyness check.

    if (AssignmentPropertyList.length > 0 && AssignmentPropertyList[AssignmentPropertyList.length - 1] && isAssignmentRestProperty(AssignmentPropertyList[AssignmentPropertyList.length - 1])) {
      AssignmentRestProperty = AssignmentPropertyList[AssignmentPropertyList.length - 1];
      AssignmentPropertyList = AssignmentPropertyList.slice(0, -1);
    }

    {
      const hygienicTemp = RequireObjectCoercible(value);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    let excludedNames = [];

    if (AssignmentPropertyList.length > 0) {
      excludedNames = yield* PropertyDestructuringAssignmentEvaluation_AssignmentPropertyList(AssignmentPropertyList, value);

      if (excludedNames instanceof AbruptCompletion) {
        return excludedNames;
      }

      if (excludedNames instanceof Completion) {
        excludedNames = excludedNames.Value;
      }
    }

    if (AssignmentRestProperty === undefined) {
      return new NormalCompletion(undefined);
    }

    return yield* RestDestructuringAssignmentEvaluation_AssignmentRestProperty(AssignmentRestProperty, value, excludedNames);
  } // 12.15.5.2 #sec-runtime-semantics-destructuringassignmentevaluation
  //   ArrayAssignmentPattern :
  //     `[` `]`
  //     `[` Elision `]`
  //     `[` Elision_opt AssignmentRestProperty `]`
  //     `[` AssignmentElementList `]`
  //     `[` AssignmentElementList `,` Elision_opt AssignmentRestProperty_opt `]`


  function* DestructuringAssignmentEvaluation_ArrayAssignmentPattern(ArrayAssignmentPattern, value) {
    let Elision;
    let AssignmentElementList = ArrayAssignmentPattern.elements;
    let AssignmentRestProperty; // Members of the AssignmentElementList may be null, so add a truthyness check.

    if (AssignmentElementList.length > 0 && AssignmentElementList[AssignmentElementList.length - 1] && isAssignmentRestProperty(AssignmentElementList[AssignmentElementList.length - 1])) {
      AssignmentRestProperty = AssignmentElementList[AssignmentElementList.length - 1];
      AssignmentElementList = AssignmentElementList.slice(0, -1);
    }

    if (AssignmentElementList.length > 0) {
      let begin;

      for (begin = AssignmentElementList.length; begin > 0; begin -= 1) {
        if (AssignmentElementList[begin - 1] !== null) {
          break;
        }
      }

      if (begin !== AssignmentElementList.length) {
        Elision = AssignmentElementList.slice(begin);
        AssignmentElementList = AssignmentElementList.slice(0, begin);
      }
    }

    let iteratorRecord = GetIterator(value);

    if (iteratorRecord instanceof AbruptCompletion) {
      return iteratorRecord;
    }

    if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    // ArrayAssignmentPattern : `[` `]`
    if (AssignmentElementList.length === 0 && Elision === undefined && AssignmentRestProperty === undefined) {
      return IteratorClose(iteratorRecord, new NormalCompletion(undefined));
    }

    let status;

    if (AssignmentElementList.length > 0) {
      status = yield* IteratorDestructuringAssignmentEvaluation_AssignmentElementList(AssignmentElementList, iteratorRecord);

      if (status instanceof AbruptCompletion) {
        if (iteratorRecord.Done === Value.false) {
          return IteratorClose(iteratorRecord, status);
        }

        return Completion(status);
      }
    }

    if (Elision !== undefined) {
      status = IteratorDestructuringAssignmentEvaluation_Elision(Elision, iteratorRecord);

      if (AssignmentRestProperty === undefined) ; else {
        // ArrayAssignmentPattern :
        //   `[` Elision AssignmentRestElement `]`
        //   `[` AssignmentElementList `,` Elision AssignmentRestElement_opt `]`
        if (status instanceof AbruptCompletion) {
          Assert(iteratorRecord.Done === Value.true, "iteratorRecord.Done === Value.true");
          return Completion(status);
        }
      }
    }

    if (AssignmentRestProperty !== undefined) {
      status = yield* IteratorDestructuringAssignmentEvaluation_AssignmentRestProperty(AssignmentRestProperty, iteratorRecord);
    }

    if (iteratorRecord.Done === Value.false) {
      return IteratorClose(iteratorRecord, status);
    }

    return Completion(status);
  } // 12.15.5.3 #sec-runtime-semantics-propertydestructuringassignmentevaluation
  //   AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty
  //
  // (implicit)
  //   AssignmentPropertyList : AssignmentProperty


  function* PropertyDestructuringAssignmentEvaluation_AssignmentPropertyList(AssignmentPropertyList, value) {
    const propertyNames = [];

    for (const AssignmentProperty of AssignmentPropertyList) {
      let nextNames = yield* PropertyDestructuringAssignmentEvaluation_AssignmentProperty(AssignmentProperty, value);

      if (nextNames instanceof AbruptCompletion) {
        return nextNames;
      }

      if (nextNames instanceof Completion) {
        nextNames = nextNames.Value;
      }

      propertyNames.push(...nextNames);
    }

    return propertyNames;
  } // 12.15.5.3 #sec-runtime-semantics-propertydestructuringassignmentevaluation
  //   AssignmentProperty :
  //     IdentifierReference Initializer_opt
  //     PropertyName `:` AssignmentElement


  function* PropertyDestructuringAssignmentEvaluation_AssignmentProperty(AssignmentProperty, value) {
    if (AssignmentProperty.shorthand) {
      // AssignmentProperty : IdentifierReference Initializer_opt
      const IdentifierReference = AssignmentProperty.key;
      let Initializer;

      if (AssignmentProperty.value.type === 'AssignmentPattern') {
        Initializer = AssignmentProperty.value.right;
      }

      const P = new Value(IdentifierReference.name);
      let lref = ResolveBinding(P, undefined, IdentifierReference.strict);

      if (lref instanceof AbruptCompletion) {
        return lref;
      }

      if (lref instanceof Completion) {
        lref = lref.Value;
      }

      let v = GetV(value, P);

      if (v instanceof AbruptCompletion) {
        return v;
      }

      if (v instanceof Completion) {
        v = v.Value;
      }

      if (Initializer !== undefined && Type(v) === 'Undefined') {
        if (IsAnonymousFunctionDefinition(Initializer)) {
          v = yield* NamedEvaluation_Expression(Initializer, P);
        } else {
          const defaultValue = yield* Evaluate(Initializer);
          v = GetValue(defaultValue);

          if (v instanceof AbruptCompletion) {
            return v;
          }

          if (v instanceof Completion) {
            v = v.Value;
          }
        }
      }

      {
        const hygienicTemp = PutValue(lref, v);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      return [P];
    }

    const {
      key: PropertyName,
      value: AssignmentElement
    } = AssignmentProperty;
    let name = yield* Evaluate_PropertyName(PropertyName, AssignmentProperty.computed);

    if (name instanceof AbruptCompletion) {
      return name;
    }

    if (name instanceof Completion) {
      name = name.Value;
    }

    {
      const hygienicTemp = yield* KeyedDestructuringAssignmentEvaluation_AssignmentElement(AssignmentElement, value, name);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return [name];
  } // 12.15.5.4 #sec-runtime-semantics-restdestructuringassignmentevaluation
  //   AssignmentRestProperty : `...` DestructuringAssignmentTarget


  function* RestDestructuringAssignmentEvaluation_AssignmentRestProperty(AssignmentRestProperty, value, excludedNames) {
    const DestructuringAssignmentTarget = AssignmentRestProperty.argument;
    let lref = yield* Evaluate(DestructuringAssignmentTarget);

    if (lref instanceof AbruptCompletion) {
      return lref;
    }

    if (lref instanceof Completion) {
      lref = lref.Value;
    }

    const restObj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    {
      const hygienicTemp = CopyDataProperties(restObj, value, excludedNames);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return PutValue(lref, restObj);
  } // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
  //   AssignmentElementList :
  //     AssignmentElisionElement
  //     AssignmentElementList `,` AssignmentElisionElement


  function* IteratorDestructuringAssignmentEvaluation_AssignmentElementList(AssignmentElementList, iteratorRecord) {
    Assert(AssignmentElementList.length > 0, "AssignmentElementList.length > 0");
    let result;

    for (const AssignmentElisionElement of AssignmentElementList) {
      result = yield* IteratorDestructuringAssignmentEvaluation_AssignmentElisionElement(AssignmentElisionElement, iteratorRecord);

      if (result instanceof AbruptCompletion) {
        return result;
      }

      if (result instanceof Completion) {
        result = result.Value;
      }
    }

    return result;
  } // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
  //   AssignmentElisionElement :
  //     AssignmentElement
  //     Elision AssignmentElement


  function* IteratorDestructuringAssignmentEvaluation_AssignmentElisionElement(AssignmentElisionElement, iteratorRecord) {
    if (!AssignmentElisionElement) {
      // This is an elision.
      return IteratorDestructuringAssignmentEvaluation_Elision([AssignmentElisionElement], iteratorRecord);
    }

    return yield* IteratorDestructuringAssignmentEvaluation_AssignmentElement(AssignmentElisionElement, iteratorRecord);
  } // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
  //   AssignmentElement : DestructuringAssignmentTarget Initializer_opt


  function* IteratorDestructuringAssignmentEvaluation_AssignmentElement(AssignmentElement, iteratorRecord) {
    let DestructuringAssignmentTarget = AssignmentElement;
    let Initializer;

    if (AssignmentElement.type === 'AssignmentPattern') {
      DestructuringAssignmentTarget = AssignmentElement.left;
      Initializer = AssignmentElement.right;
    }

    let lref;

    if (!isAssignmentPattern(DestructuringAssignmentTarget)) {
      lref = yield* Evaluate(DestructuringAssignmentTarget);

      if (lref instanceof AbruptCompletion) {
        return lref;
      }

      if (lref instanceof Completion) {
        lref = lref.Value;
      }
    }

    let value;

    if (iteratorRecord.Done === Value.false) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
      } else {
        value = IteratorValue(next);

        if (value instanceof AbruptCompletion) {
          iteratorRecord.Done = Value.true;
        }

        if (value instanceof AbruptCompletion) {
          return value;
        }

        if (value instanceof Completion) {
          value = value.Value;
        }
      }
    }

    if (iteratorRecord.Done === Value.true) {
      value = Value.undefined;
    }

    let v;

    if (Initializer !== undefined && value === Value.undefined) {
      if (IsAnonymousFunctionDefinition(Initializer) && IsIdentifierRef(DestructuringAssignmentTarget)) {
        v = yield* NamedEvaluation_Expression(Initializer, GetReferencedName(lref));
      } else {
        const defaultValue = yield* Evaluate(Initializer);
        v = GetValue(defaultValue);

        if (v instanceof AbruptCompletion) {
          return v;
        }

        if (v instanceof Completion) {
          v = v.Value;
        }
      }
    } else {
      v = value;
    }

    if (isAssignmentPattern(DestructuringAssignmentTarget)) {
      const nestedAssignmentPattern = DestructuringAssignmentTarget;
      return yield* DestructuringAssignmentEvaluation_AssignmentPattern(nestedAssignmentPattern, v);
    }

    return PutValue(lref, v);
  } // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
  //   Elision :
  //     `,`
  //     Elision `,`


  function IteratorDestructuringAssignmentEvaluation_Elision(Elision, iteratorRecord) {
    let remaining = Elision.length;

    while (remaining > 0 && iteratorRecord.Done === Value.false) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
      }

      remaining -= 1;
    }

    return new NormalCompletion(undefined);
  } // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
  //   AssignmentRestElement : `...` DestructuringAssignmentTarget

  function* IteratorDestructuringAssignmentEvaluation_AssignmentRestProperty(AssignmentRestProperty, iteratorRecord) {
    const DestructuringAssignmentTarget = AssignmentRestProperty.argument;
    let lref;

    if (!isAssignmentPattern(DestructuringAssignmentTarget)) {
      lref = yield* Evaluate(DestructuringAssignmentTarget);

      if (lref instanceof AbruptCompletion) {
        return lref;
      }

      if (lref instanceof Completion) {
        lref = lref.Value;
      }
    }

    let A = ArrayCreate(new Value(0));
    Assert(!(A instanceof AbruptCompletion), "");

    if (A instanceof Completion) {
      A = A.Value;
    }

    let n = 0;

    while (iteratorRecord.Done === Value.false) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
      } else {
        let nextValue = IteratorValue(next);

        if (nextValue instanceof AbruptCompletion) {
          iteratorRecord.Done = Value.true;
        }

        if (nextValue instanceof AbruptCompletion) {
          return nextValue;
        }

        if (nextValue instanceof Completion) {
          nextValue = nextValue.Value;
        }

        let status = CreateDataProperty(A, ToString(new Value(n)), nextValue);
        Assert(!(status instanceof AbruptCompletion), "");

        if (status instanceof Completion) {
          status = status.Value;
        }

        Assert(status === Value.true, "status === Value.true");
        n += 1;
      }
    }

    if (!isAssignmentPattern(DestructuringAssignmentTarget)) {
      return PutValue(lref, A);
    }

    const nestedAssignmentPattern = DestructuringAssignmentTarget;
    return yield* DestructuringAssignmentEvaluation_AssignmentPattern(nestedAssignmentPattern, A);
  } // 12.15.5.6 #sec-runtime-semantics-keyeddestructuringassignmentevaluation
  //   AssignmentElement : DestructuringAssignmentTarget Initializer_opt


  function* KeyedDestructuringAssignmentEvaluation_AssignmentElement(AssignmentElement, value, propertyName) {
    let DestructuringAssignmentTarget = AssignmentElement;
    let Initializer;

    if (AssignmentElement.type === 'AssignmentPattern') {
      DestructuringAssignmentTarget = AssignmentElement.left;
      Initializer = AssignmentElement.right;
    }

    let lref;

    if (!isAssignmentPattern(DestructuringAssignmentTarget)) {
      lref = yield* Evaluate(DestructuringAssignmentTarget);

      if (lref instanceof AbruptCompletion) {
        return lref;
      }

      if (lref instanceof Completion) {
        lref = lref.Value;
      }
    }

    let v = GetV(value, propertyName);

    if (v instanceof AbruptCompletion) {
      return v;
    }

    if (v instanceof Completion) {
      v = v.Value;
    }

    let rhsValue;

    if (Initializer !== undefined && v === Value.undefined) {
      if (IsAnonymousFunctionDefinition(Initializer) && IsIdentifierRef(DestructuringAssignmentTarget)) {
        rhsValue = yield* NamedEvaluation_Expression(Initializer, GetReferencedName(lref));
      } else {
        const defaultValue = yield* Evaluate(Initializer);
        rhsValue = GetValue(defaultValue);

        if (rhsValue instanceof AbruptCompletion) {
          return rhsValue;
        }

        if (rhsValue instanceof Completion) {
          rhsValue = rhsValue.Value;
        }
      }
    } else {
      rhsValue = v;
    }

    if (isAssignmentPattern(DestructuringAssignmentTarget)) {
      const assignmentPattern = DestructuringAssignmentTarget;
      return yield* DestructuringAssignmentEvaluation_AssignmentPattern(assignmentPattern, rhsValue);
    }

    return PutValue(lref, rhsValue);
  }

  //   EmptyStatement : `;`

  function Evaluate_EmptyStatement()
  /* EmptyStatement */
  {
    return new NormalCompletion(undefined);
  }

  // EqualityExpression :
  //   EqualityExpression `==` RelationalExpression
  //   EqualityExpression `!=` RelationalExpression
  //   EqualityExpression `===` RelationalExpression
  //   EqualityExpression `!==` RelationalExpression

  function* Evaluate_EqualityExpression({
    left: EqualityExpression,
    operator,
    right: RelationalExpression
  }) {
    const lref = yield* Evaluate(EqualityExpression);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    const rref = yield* Evaluate(RelationalExpression);
    let rval = GetValue(rref);

    if (rval instanceof AbruptCompletion) {
      return rval;
    }

    if (rval instanceof Completion) {
      rval = rval.Value;
    }

    switch (operator) {
      case '==':
        return AbstractEqualityComparison(rval, lval);

      case '!=':
        {
          let r = AbstractEqualityComparison(rval, lval);

          if (r instanceof AbruptCompletion) {
            return r;
          }

          if (r instanceof Completion) {
            r = r.Value;
          }

          if (r === Value.true) {
            return Value.false;
          } else {
            return Value.true;
          }
        }

      case '===':
        return StrictEqualityComparison(rval, lval);

      case '!==':
        {
          let r = StrictEqualityComparison(rval, lval);
          Assert(!(r instanceof AbruptCompletion), "");

          if (r instanceof Completion) {
            r = r.Value;
          }

          if (r === Value.true) {
            return Value.false;
          } else {
            return Value.true;
          }
        }

      default:
        throw new OutOfRange('Evaluate_EqualityExpression', operator);
    }
  }

  function* FunctionDeclarationInstantiation(func, argumentsList) {
    const calleeContext = surroundingAgent.runningExecutionContext;
    const env = calleeContext.LexicalEnvironment;
    const envRec = env.EnvironmentRecord;
    const code = func.ECMAScriptCode;
    const strict = func.Strict;
    const formals = func.FormalParameters;
    const parameterNames = BoundNames_FormalParameters(formals).map(Value);
    const hasDuplicates = parameterNames.some(e => parameterNames.indexOf(e) !== parameterNames.lastIndexOf(e));
    const simpleParameterList = IsSimpleParameterList_FormalParameters(formals);
    const hasParameterExpressions = ContainsExpression_FormalParameters(formals);
    let varNames;
    let varDeclarations;
    let lexicalNames;

    switch (getFunctionBodyType(code)) {
      case 'FunctionBody':
        varNames = VarDeclaredNames_FunctionBody(code.body.body).map(Value);
        varDeclarations = VarScopedDeclarations_FunctionBody(code.body.body);
        lexicalNames = LexicallyDeclaredNames_FunctionBody(code.body.body).map(Value);
        break;

      case 'ConciseBody_ExpressionBody':
      case 'ConciseBody_FunctionBody':
      case 'AsyncConciseBody_AsyncFunctionBody':
      case 'AsyncConciseBody_ExpressionBody':
      case 'AsyncGeneratorBody':
        varNames = VarDeclaredNames_ConciseBody(code.body).map(Value);
        varDeclarations = VarScopedDeclarations_ConciseBody(code.body);
        lexicalNames = LexicallyDeclaredNames_ConciseBody(code.body).map(Value);
        break;

      case 'GeneratorBody':
        varNames = VarDeclaredNames_GeneratorBody(code.body.body).map(Value);
        varDeclarations = VarScopedDeclarations_GeneratorBody(code.body.body);
        lexicalNames = LexicallyDeclaredNames_GeneratorBody(code.body.body).map(Value);
        break;

      case 'AsyncFunctionBody':
        varNames = VarDeclaredNames_AsyncFunctionBody(code.body.body).map(Value);
        varDeclarations = VarScopedDeclarations_AsyncFunctionBody(code.body.body);
        lexicalNames = LexicallyDeclaredNames_AsyncFunctionBody(code.body.body).map(Value);
        break;

      default:
        throw new OutOfRange('FunctionDeclarationInstantiation', code);
    }

    const functionNames = [];
    const functionsToInitialize = [];

    for (const d of [...varDeclarations].reverse()) {
      if (!isVariableDeclaration(d) && !isForBinding(d) && !isBindingIdentifier(d)) {
        Assert(isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d), "isFunctionDeclaration(d) || isGeneratorDeclaration(d)\n             || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)");
        const fn = BoundNames_FunctionDeclaration(d)[0];

        if (!functionNames.includes(fn)) {
          functionNames.unshift(fn);
          functionsToInitialize.unshift(d);
        }
      }
    }

    let argumentsObjectNeeded = true;

    if (func.ThisMode === 'lexical') {
      argumentsObjectNeeded = false;
    } else if (parameterNames.includes(new Value('arguments'))) {
      argumentsObjectNeeded = false;
    } else if (hasParameterExpressions === false) {
      if (functionNames.includes(new Value('arguments')) || lexicalNames.includes(new Value('arguments'))) {
        argumentsObjectNeeded = false;
      }
    }

    for (const paramName of parameterNames) {
      const alreadyDeclared = envRec.HasBinding(paramName);

      if (alreadyDeclared === Value.false) {
        Assert(!(envRec.CreateMutableBinding(paramName, false) instanceof AbruptCompletion), "");

        if (hasDuplicates === true) {
          Assert(!(envRec.InitializeBinding(paramName, Value.undefined) instanceof AbruptCompletion), "");
        }
      }
    }

    let parameterBindings;

    if (argumentsObjectNeeded === true) {
      let ao;

      if (strict || simpleParameterList === false) {
        ao = CreateUnmappedArgumentsObject(argumentsList);
      } else {
        ao = CreateMappedArgumentsObject(func, formals, argumentsList, envRec);
      }

      if (strict) {
        Assert(!(envRec.CreateImmutableBinding(new Value('arguments'), Value.false) instanceof AbruptCompletion), "");
      } else {
        Assert(!(envRec.CreateMutableBinding(new Value('arguments'), false) instanceof AbruptCompletion), "");
      }

      envRec.InitializeBinding(new Value('arguments'), ao);
      parameterBindings = [...parameterNames, new Value('arguments')];
    } else {
      parameterBindings = parameterNames;
    }

    const iteratorRecord = CreateListIteratorRecord(argumentsList);

    if (hasDuplicates) {
      {
        const hygienicTemp = yield* IteratorBindingInitialization_FormalParameters(formals, iteratorRecord, Value.undefined);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    } else {
      {
        const hygienicTemp = yield* IteratorBindingInitialization_FormalParameters(formals, iteratorRecord, env);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    let varEnv;
    let varEnvRec;

    if (hasParameterExpressions === false) {
      const instantiatedVarNames = [...parameterBindings];

      for (const n of varNames) {
        if (!instantiatedVarNames.includes(n)) {
          instantiatedVarNames.push(n);
          Assert(!(envRec.CreateMutableBinding(n, false) instanceof AbruptCompletion), "");
          envRec.InitializeBinding(n, Value.undefined);
        }
      }

      varEnv = env;
      varEnvRec = envRec;
    } else {
      varEnv = NewDeclarativeEnvironment(env);
      varEnvRec = varEnv.EnvironmentRecord;
      calleeContext.VariableEnvironment = varEnv;
      const instantiatedVarNames = [];

      for (const n of varNames) {
        if (!instantiatedVarNames.includes(n)) {
          instantiatedVarNames.push(n);
          Assert(!(varEnvRec.CreateMutableBinding(n, false) instanceof AbruptCompletion), "");
          let initialValue;

          if (!parameterBindings.includes(n) || functionNames.includes(n)) {
            initialValue = Value.undefined;
          } else {
            initialValue = envRec.GetBindingValue(n, Value.false);
            Assert(!(initialValue instanceof AbruptCompletion), "");

            if (initialValue instanceof Completion) {
              initialValue = initialValue.Value;
            }
          }

          varEnvRec.InitializeBinding(n, initialValue);
        }
      }
    } // NOTE: Annex B.3.3.1 adds additional steps at this point.


    let lexEnv;

    if (strict === false) {
      lexEnv = NewDeclarativeEnvironment(varEnv);
    } else {
      lexEnv = varEnv;
    }

    const lexEnvRec = lexEnv.EnvironmentRecord;
    lexEnv.EnvironmentRecord = lexEnvRec;
    calleeContext.LexicalEnvironment = lexEnv;
    let lexDeclarations;

    switch (getFunctionBodyType(code)) {
      case 'FunctionBody':
        lexDeclarations = LexicallyScopedDeclarations_FunctionBody(code.body.body);
        break;

      case 'ConciseBody_ExpressionBody':
      case 'ConciseBody_FunctionBody':
      case 'AsyncConciseBody_ExpressionBody':
      case 'AsyncConciseBody_AsyncFunctionBody':
        lexDeclarations = LexicallyScopedDeclarations_ConciseBody(code.body);
        break;

      case 'GeneratorBody':
        lexDeclarations = LexicallyScopedDeclarations_GeneratorBody(code.body.body);
        break;

      case 'AsyncFunctionBody':
      case 'AsyncGeneratorBody':
        lexDeclarations = LexicallyScopedDeclarations_AsyncFunctionBody(code.body.body);
        break;

      default:
        throw new OutOfRange('FunctionDeclarationInstantiation', code);
    }

    for (const d of lexDeclarations) {
      for (const dn of BoundNames_Declaration(d).map(Value)) {
        if (IsConstantDeclaration(d)) {
          Assert(!(lexEnvRec.CreateImmutableBinding(dn, Value.true) instanceof AbruptCompletion), "");
        } else {
          Assert(!(lexEnvRec.CreateMutableBinding(dn, false) instanceof AbruptCompletion), "");
        }
      }
    }

    for (const f of functionsToInitialize) {
      const fn = BoundNames_FunctionDeclaration(f)[0];
      const fo = InstantiateFunctionObject(f, lexEnv);
      Assert(!(varEnvRec.SetMutableBinding(new Value(fn), fo, Value.false) instanceof AbruptCompletion), "");
    }

    return new NormalCompletion(undefined);
  }
  function getFunctionBodyType(ECMAScriptCode) {
    switch (true) {
      // FunctionBody : FunctionStatementList
      case isFunctionDeclaration(ECMAScriptCode) || isFunctionExpression(ECMAScriptCode):
        // includes MethodDefinitions
        return 'FunctionBody';
      // ConciseBody : `{` FunctionBody `}`

      case isArrowFunction(ECMAScriptCode) && !ECMAScriptCode.expression:
        return 'ConciseBody_FunctionBody';
      // ConciseBody : ExpressionBody

      case isArrowFunction(ECMAScriptCode) && ECMAScriptCode.expression:
        return 'ConciseBody_ExpressionBody';
      // AsyncConciseBody : `{` AsyncFunctionBody `}`

      case isAsyncArrowFunction(ECMAScriptCode) && !ECMAScriptCode.expression:
        return 'AsyncConciseBody_AsyncFunctionBody';
      // AsyncConciseBody : ExpressionBody

      case isAsyncArrowFunction(ECMAScriptCode) && ECMAScriptCode.expression:
        return 'AsyncConciseBody_ExpressionBody';
      // GeneratorBody : FunctionBody

      case isGeneratorDeclaration(ECMAScriptCode) || isGeneratorExpression(ECMAScriptCode):
        return 'GeneratorBody';
      // AsyncFunctionBody : FunctionBody

      case isAsyncFunctionDeclaration(ECMAScriptCode) || isAsyncFunctionExpression(ECMAScriptCode):
        return 'AsyncFunctionBody';

      case isAsyncGeneratorDeclaration(ECMAScriptCode) || isAsyncGeneratorExpression(ECMAScriptCode):
        return 'AsyncGeneratorBody';

      default:
        throw new OutOfRange('getFunctionBodyType', ECMAScriptCode);
    }
  } // 14.2.15 #sec-arrow-function-definitions-runtime-semantics-evaluatebody
  // ConciseBody : ExpressionBody

  function* EvaluateBody_ConciseBody_ExpressionBody(ExpressionBody, functionObject, argumentsList) {
    {
      const hygienicTemp = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return yield* Evaluate_ExpressionBody(ExpressionBody);
  } // 14.1.18 #sec-function-definitions-runtime-semantics-evaluatebody
  // FunctionBody : FunctionStatementList

  function* EvaluateBody_FunctionBody(FunctionStatementList, functionObject, argumentsList) {
    {
      const hygienicTemp = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return yield* Evaluate_FunctionStatementList(FunctionStatementList);
  } // 14.4.10 #sec-generator-function-definitions-runtime-semantics-evaluatebody
  // GeneratorBody : FunctionBody

  function* EvaluateBody_GeneratorBody(GeneratorBody, functionObject, argumentsList) {
    {
      const hygienicTemp = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    let G = OrdinaryCreateFromConstructor(functionObject, '%GeneratorPrototype%', ['GeneratorState', 'GeneratorContext']);

    if (G instanceof AbruptCompletion) {
      return G;
    }

    if (G instanceof Completion) {
      G = G.Value;
    }

    GeneratorStart(G, GeneratorBody);
    return new ReturnCompletion(G);
  } // 14.7.11 #sec-async-function-definitions-EvaluateBody
  // AsyncFunctionBody : FunctionBody

  function* EvaluateBody_AsyncFunctionBody(FunctionBody, functionObject, argumentsList) {
    let promiseCapability = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    Assert(!(promiseCapability instanceof AbruptCompletion), "");

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    const declResult = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

    if (!(declResult instanceof AbruptCompletion)) {
      Assert(!(AsyncFunctionStart(promiseCapability, FunctionBody) instanceof AbruptCompletion), "");
    } else {
      Assert(!(Call(promiseCapability.Reject, Value.undefined, [declResult.Value]) instanceof AbruptCompletion), "");
    }

    return new Completion('return', promiseCapability.Promise, undefined);
  } // 14.8.14 #sec-async-arrow-function-definitions-EvaluateBody
  // AsyncConciseBody : ExpressionBody

  function* EvaluateBody_AsyncConciseBody_ExpressionBody(ExpressionBody, functionObject, argumentsList) {
    let promiseCapability = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    Assert(!(promiseCapability instanceof AbruptCompletion), "");

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    const declResult = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

    if (!(declResult instanceof AbruptCompletion)) {
      Assert(!(AsyncFunctionStart(promiseCapability, ExpressionBody) instanceof AbruptCompletion), "");
    } else {
      Assert(!(Call(promiseCapability.Reject, Value.undefined, [declResult.Value]) instanceof AbruptCompletion), "");
    }

    return new Completion('return', promiseCapability.Promise, undefined);
  }
  function* EvaluateBody_AsyncGeneratorBody(FunctionBody, functionObject, argumentsList) {
    {
      const hygienicTemp = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    let generator = OrdinaryCreateFromConstructor(functionObject, '%AsyncGeneratorPrototype%', ['AsyncGeneratorState', 'AsyncGeneratorContext', 'AsyncGeneratorQueue']);

    if (generator instanceof AbruptCompletion) {
      return generator;
    }

    if (generator instanceof Completion) {
      generator = generator.Value;
    }

    Assert(!(AsyncGeneratorStart(generator, FunctionBody) instanceof AbruptCompletion), "");
    return new Completion('return', generator, undefined);
  }

  function* EvaluateDynamicPropertyAccess(baseValue, expression, strict) {
    const propertyNameReference = yield* Evaluate(expression);
    let propertyNameValue = GetValue(propertyNameReference);

    if (propertyNameValue instanceof AbruptCompletion) {
      return propertyNameValue;
    }

    if (propertyNameValue instanceof Completion) {
      propertyNameValue = propertyNameValue.Value;
    }

    let bv = RequireObjectCoercible(baseValue);

    if (bv instanceof AbruptCompletion) {
      return bv;
    }

    if (bv instanceof Completion) {
      bv = bv.Value;
    }

    let propertyKey = ToPropertyKey(propertyNameValue);

    if (propertyKey instanceof AbruptCompletion) {
      return propertyKey;
    }

    if (propertyKey instanceof Completion) {
      propertyKey = propertyKey.Value;
    }

    return new Reference({
      BaseValue: bv,
      ReferencedName: propertyKey,
      StrictReference: strict ? Value.true : Value.false
    });
  } // https://tc39.es/proposal-optional-chaining

  function EvaluateStaticPropertyAccess(baseValue, identifierName, strict) {
    let bv = RequireObjectCoercible(baseValue);

    if (bv instanceof AbruptCompletion) {
      return bv;
    }

    if (bv instanceof Completion) {
      bv = bv.Value;
    }

    const propertyNameString = new Value(identifierName.name);
    return new Reference({
      BaseValue: bv,
      ReferencedName: propertyNameString,
      StrictReference: strict ? Value.true : Value.false
    });
  }

  function EvaluateBinopValues_ExponentiationExpression(lval, rval) {
    let base = ToNumber(lval);

    if (base instanceof AbruptCompletion) {
      return base;
    }

    if (base instanceof Completion) {
      base = base.Value;
    }

    let exponent = ToNumber(rval);

    if (exponent instanceof AbruptCompletion) {
      return exponent;
    }

    if (exponent instanceof Completion) {
      exponent = exponent.Value;
    }

    return new Value(base.numberValue() ** exponent.numberValue());
  } // 12.6.3 #sec-exp-operator-runtime-semantics-evaluation
  // ExponentiationExpression : UpdateExpression ** ExponentiationExpression

  function* Evaluate_ExponentiationExpression({
    left: UpdateExpression,
    right: ExponentiationExpression
  }) {
    const left = yield* Evaluate(UpdateExpression);
    let leftValue = GetValue(left);

    if (leftValue instanceof AbruptCompletion) {
      return leftValue;
    }

    if (leftValue instanceof Completion) {
      leftValue = leftValue.Value;
    }

    const right = yield* Evaluate(ExponentiationExpression);
    let rightValue = GetValue(right);

    if (rightValue instanceof AbruptCompletion) {
      return rightValue;
    }

    if (rightValue instanceof Completion) {
      rightValue = rightValue.Value;
    }

    return EvaluateBinopValues_ExponentiationExpression(leftValue, rightValue);
  }

  // Expression : Expression `,` AssignmentExpression

  function* Evaluate_ExpressionWithComma(ExpressionWithComma) {
    const expressions = [...ExpressionWithComma.expressions];
    const AssignmentExpression = expressions.pop();

    for (const Expression of expressions) {
      const lref = yield* Evaluate(Expression);
      {
        const hygienicTemp = GetValue(lref);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    const rref = yield* Evaluate(AssignmentExpression);
    return GetValue(rref);
  }

  function* Evaluate_ExportDeclaration(ExportDeclaration) {
    switch (true) {
      case isExportDeclarationWithStar(ExportDeclaration):
      case isExportDeclarationWithExportAndFrom(ExportDeclaration):
      case isExportDeclarationWithExport(ExportDeclaration):
        return new NormalCompletion(undefined);

      case isExportDeclarationWithVariable(ExportDeclaration):
      case isExportDeclarationWithDeclaration(ExportDeclaration):
      case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
        return yield* Evaluate(ExportDeclaration.declaration);

      case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
        {
          const ClassDeclaration = ExportDeclaration.declaration;
          let value = yield* BindingClassDeclarationEvaluation_ClassDeclaration(ClassDeclaration);

          if (value instanceof AbruptCompletion) {
            return value;
          }

          if (value instanceof Completion) {
            value = value.Value;
          }

          const className = BoundNames_ClassDeclaration(ClassDeclaration)[0];

          if (className === '*default*') {
            const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
            {
              const hygienicTemp = InitializeBoundName(new Value('*default*'), value, env);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          }

          return new NormalCompletion(undefined);
        }

      case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
        {
          const AssignmentExpression = ExportDeclaration.declaration;
          let value;

          if (IsAnonymousFunctionDefinition(AssignmentExpression)) {
            value = yield* NamedEvaluation_Expression(AssignmentExpression, new Value('default'));

            if (value instanceof AbruptCompletion) {
              return value;
            }

            if (value instanceof Completion) {
              value = value.Value;
            } // https://github.com/tc39/ecma262/issues/1605

          } else {
            const rhs = yield* Evaluate(AssignmentExpression);
            value = GetValue(rhs);

            if (value instanceof AbruptCompletion) {
              return value;
            }

            if (value instanceof Completion) {
              value = value.Value;
            }
          }

          const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
          {
            const hygienicTemp = InitializeBoundName(new Value('*default*'), value, env);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return new NormalCompletion(undefined);
        }

      default:
        throw new OutOfRange('Evaluate_ExportDeclaration', ExportDeclaration);
    }
  }

  function LoopContinues(completion, labelSet) {
    if (completion.Type === 'normal') {
      return true;
    }

    if (completion.Type !== 'continue') {
      return false;
    }

    if (completion.Target === undefined) {
      return true;
    }

    if (labelSet.includes(completion.Target)) {
      return true;
    }

    return false;
  } // 13.7.4.8 #sec-forbodyevaluation


  function* ForBodyEvaluation(test, increment, stmt, perIterationBindings, labelSet) {
    let V = Value.undefined;
    {
      const hygienicTemp = CreatePerIterationEnvironment(perIterationBindings);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    while (true) {
      if (test) {
        const testRef = yield* Evaluate(test);
        let testValue = GetValue(testRef);

        if (testValue instanceof AbruptCompletion) {
          return testValue;
        }

        if (testValue instanceof Completion) {
          testValue = testValue.Value;
        }

        if (ToBoolean(testValue) === Value.false) {
          return new NormalCompletion(V);
        }
      }

      const result = EnsureCompletion((yield* Evaluate(stmt)));

      if (LoopContinues(result, labelSet) === false) {
        return Completion(UpdateEmpty(result, V));
      }

      if (result.Value !== undefined) {
        V = result.Value;
      }

      {
        const hygienicTemp = CreatePerIterationEnvironment(perIterationBindings);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }

      if (increment) {
        const incRef = yield* Evaluate(increment);
        {
          const hygienicTemp = GetValue(incRef);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }
    }
  } // 13.7.4.9 #sec-createperiterationenvironment


  function CreatePerIterationEnvironment(perIterationBindings) {
    if (perIterationBindings.length > 0) {
      const lastIterationEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
      const lastIterationEnvRec = lastIterationEnv.EnvironmentRecord;
      const outer = lastIterationEnv.outerEnvironmentReference;
      Assert(Type(outer) !== 'Null', "Type(outer) !== 'Null'");
      const thisIterationEnv = NewDeclarativeEnvironment(outer);
      const thisIterationEnvRec = thisIterationEnv.EnvironmentRecord;

      for (const bn of perIterationBindings) {
        Assert(!(thisIterationEnvRec.CreateMutableBinding(bn, false) instanceof AbruptCompletion), "");
        let lastValue = lastIterationEnvRec.GetBindingValue(bn, Value.true);

        if (lastValue instanceof AbruptCompletion) {
          return lastValue;
        }

        if (lastValue instanceof Completion) {
          lastValue = lastValue.Value;
        }

        thisIterationEnvRec.InitializeBinding(bn, lastValue);
      }

      surroundingAgent.runningExecutionContext.LexicalEnvironment = thisIterationEnv;
    }

    return Value.undefined;
  } // 13.7.5.10 #sec-runtime-semantics-bindinginstantiation


  function BindingInstantiation_ForDeclaration(ForDeclaration, environment) {
    const envRec = environment.EnvironmentRecord;
    Assert(envRec instanceof DeclarativeEnvironmentRecord, "envRec instanceof DeclarativeEnvironmentRecord");
    const ForBinding = ForDeclaration.declarations[0].id;

    for (const name of BoundNames_ForBinding(ForBinding).map(Value)) {
      if (IsConstantDeclaration(ForDeclaration)) {
        Assert(!(envRec.CreateImmutableBinding(name, Value.true) instanceof AbruptCompletion), "");
      } else {
        Assert(!(envRec.CreateMutableBinding(name, false) instanceof AbruptCompletion), "");
      }
    }
  } // 13.7.5.12 #sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind


  function* ForInOfHeadEvaluation(TDZnames, expr, iterationKind) {
    const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;

    if (TDZnames.length > 0) {
      Assert(new Set(TDZnames).size === TDZnames.length, "new Set(TDZnames).size === TDZnames.length");
      const TDZ = NewDeclarativeEnvironment(oldEnv);
      const TDZEnvRec = TDZ.EnvironmentRecord;

      for (const name of TDZnames) {
        Assert(!(TDZEnvRec.CreateMutableBinding(name, false) instanceof AbruptCompletion), "");
      }

      surroundingAgent.runningExecutionContext.LexicalEnvironment = TDZ;
    }

    const exprRef = yield* Evaluate(expr);
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
    let exprValue = GetValue(exprRef);

    if (exprValue instanceof AbruptCompletion) {
      return exprValue;
    }

    if (exprValue instanceof Completion) {
      exprValue = exprValue.Value;
    }

    if (iterationKind === 'enumerate') {
      if (Type(exprValue) === 'Undefined' || Type(exprValue) === 'Null') {
        return new BreakCompletion(undefined);
      }

      let obj = ToObject(exprValue);
      Assert(!(obj instanceof AbruptCompletion), "");

      if (obj instanceof Completion) {
        obj = obj.Value;
      }

      return EnumerateObjectProperties(obj);
    } else {
      Assert(iterationKind === 'iterate' || iterationKind === 'async-iterate', "iterationKind === 'iterate' || iterationKind === 'async-iterate'");
      const iteratorHint = iterationKind === 'async-iterate' ? 'async' : 'sync';
      return GetIterator(exprValue, iteratorHint);
    }
  } // 13.7.5.13 #sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset


  function* ForInOfBodyEvaluation(lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet, iteratorKind = 'sync', strict) {
    const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    let V = Value.undefined;
    const destructuring = lhs.type === 'VariableDeclaration' ? IsDestructuring_ForDeclaration(lhs) : IsDestructuring_LeftHandSideExpression(lhs);
    let assignmentPattern;

    if (destructuring && lhsKind === 'assignment') {
      assignmentPattern = lhs;
      Assert(isAssignmentPattern(assignmentPattern), "isAssignmentPattern(assignmentPattern)");
    }

    while (true) {
      let nextResult = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator);

      if (nextResult instanceof AbruptCompletion) {
        return nextResult;
      }

      if (nextResult instanceof Completion) {
        nextResult = nextResult.Value;
      }

      if (iteratorKind === 'async') {
        nextResult = yield* Await(nextResult);

        if (nextResult instanceof AbruptCompletion) {
          return nextResult;
        }

        if (nextResult instanceof Completion) {
          nextResult = nextResult.Value;
        }
      }

      if (Type(nextResult) !== 'Object') {
        return surroundingAgent.Throw('TypeError');
      }

      let done = IteratorComplete(nextResult);

      if (done instanceof AbruptCompletion) {
        return done;
      }

      if (done instanceof Completion) {
        done = done.Value;
      }

      if (done === Value.true) {
        return new NormalCompletion(V);
      }

      let nextValue = IteratorValue(nextResult);

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      let iterationEnv;
      let lhsRef;

      if (lhsKind === 'assignment' || lhsKind === 'varBinding') {
        if (!destructuring) {
          lhsRef = yield* Evaluate(lhs);
        }
      } else {
        Assert(lhsKind === 'lexicalBinding', "lhsKind === 'lexicalBinding'");
        Assert(isForDeclaration(lhs), "isForDeclaration(lhs)");
        iterationEnv = NewDeclarativeEnvironment(oldEnv);
        BindingInstantiation_ForDeclaration(lhs, iterationEnv);
        surroundingAgent.runningExecutionContext.LexicalEnvironment = iterationEnv;

        if (!destructuring) {
          const lhsNames = BoundNames_ForDeclaration(lhs);
          Assert(lhsNames.length === 1, "lhsNames.length === 1");
          const lhsName = new Value(lhsNames[0]);
          lhsRef = ResolveBinding(lhsName, undefined, strict);
          Assert(!(lhsRef instanceof AbruptCompletion), "");

          if (lhsRef instanceof Completion) {
            lhsRef = lhsRef.Value;
          }
        }
      }

      let status;

      if (!destructuring) {
        if (lhsRef instanceof AbruptCompletion) {
          status = lhsRef;
        } else if (lhsKind === 'lexicalBinding') {
          status = InitializeReferencedBinding(lhsRef, nextValue);
        } else {
          status = PutValue(lhsRef, nextValue);
        }
      } else {
        if (lhsKind === 'assignment') {
          status = yield* DestructuringAssignmentEvaluation_AssignmentPattern(assignmentPattern, nextValue);
        } else if (lhsKind === 'varBinding') {
          Assert(isForBinding(lhs), "isForBinding(lhs)");
          status = yield* BindingInitialization_ForBinding(lhs, nextValue, Value.undefined);
        } else {
          Assert(lhsKind === 'lexicalBinding', "lhsKind === 'lexicalBinding'");
          Assert(isForDeclaration(lhs), "isForDeclaration(lhs)");
          status = yield* BindingInitialization_ForDeclaration(lhs, nextValue, iterationEnv);
        }
      }

      if (status instanceof AbruptCompletion) {
        surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;

        if (iteratorKind === 'async') {
          return yield* AsyncIteratorClose(iteratorRecord, status);
        }

        if (iterationKind === 'enumerate') {
          return status;
        } else {
          Assert(iterationKind === 'iterate', "iterationKind === 'iterate'");
          return IteratorClose(iteratorRecord, status);
        }
      }

      const result = EnsureCompletion((yield* Evaluate(stmt)));
      surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;

      if (LoopContinues(result, labelSet) === false) {
        if (iterationKind === 'enumerate') {
          return Completion(UpdateEmpty(result, V));
        } else {
          Assert(iterationKind === 'iterate', "iterationKind === 'iterate'");
          status = UpdateEmpty(result, V);

          if (iteratorKind === 'async') {
            return yield* AsyncIteratorClose(iteratorRecord, status);
          }

          return IteratorClose(iteratorRecord, status);
        }
      }

      if (result.Value !== undefined) {
        V = result.Value;
      }
    }
  } // 13.7.2.6 #sec-do-while-statement-runtime-semantics-labelledevaluation
  //   IterationStatement : `do` Statement `while` `(` Expression `)` `;`
  //
  // 13.7.3.6 #sec-while-statement-runtime-semantics-labelledevaluation
  //   IterationStatement : `while` `(` Expression `)` Statement
  //
  // 13.7.4.7 #sec-for-statement-runtime-semantics-labelledevaluation
  //   IterationStatement :
  //     `for` `(` Expression `;` Expression `;` Expression `)` Statement
  //     `for` `(` `var` VariableDeclarationList `;` Expression `;` Expression `)` Statement
  //     `for` `(` LexicalDeclarationExpression `;` Expression `)` Statement
  //
  // 13.7.5.11 #sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation
  //   IterationStatement :
  //     `for` `(` LeftHandSideExpression `in` Expression `)` Statement
  //     `for` `(` `var` ForBinding `in` Expression `)` Statement
  //     `for` `(` ForDeclaration `in` Expression `)` Statement
  //     `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
  //     `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  //     `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
  //     `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
  //     `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  //     `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement


  function* LabelledEvaluation_IterationStatement(IterationStatement, labelSet) {
    switch (true) {
      case isDoWhileStatement(IterationStatement):
        {
          const Statement = IterationStatement.body;
          const Expression = IterationStatement.test;
          let V = Value.undefined;

          while (true) {
            const stmtResult = EnsureCompletion((yield* Evaluate(Statement)));

            if (!LoopContinues(stmtResult, labelSet)) {
              return Completion(UpdateEmpty(stmtResult, V));
            }

            if (stmtResult.Value !== undefined) {
              V = stmtResult.Value;
            }

            const exprRef = yield* Evaluate(Expression);
            let exprValue = GetValue(exprRef);

            if (exprValue instanceof AbruptCompletion) {
              return exprValue;
            }

            if (exprValue instanceof Completion) {
              exprValue = exprValue.Value;
            }

            if (ToBoolean(exprValue) === Value.false) {
              return new NormalCompletion(V);
            }
          }
        }

      case isWhileStatement(IterationStatement):
        {
          const Expression = IterationStatement.test;
          const Statement = IterationStatement.body;
          let V = Value.undefined;

          while (true) {
            const exprRef = yield* Evaluate(Expression);
            let exprValue = GetValue(exprRef);

            if (exprValue instanceof AbruptCompletion) {
              return exprValue;
            }

            if (exprValue instanceof Completion) {
              exprValue = exprValue.Value;
            }

            if (ToBoolean(exprValue) === Value.false) {
              return new NormalCompletion(V);
            }

            const stmtResult = EnsureCompletion((yield* Evaluate(Statement)));

            if (!LoopContinues(stmtResult, labelSet)) {
              return Completion(UpdateEmpty(stmtResult, V));
            }

            if (stmtResult.Value !== undefined) {
              V = stmtResult.Value;
            }
          }
        }

      case isForStatementWithExpression(IterationStatement):
        if (IterationStatement.init) {
          const exprRef = yield* Evaluate(IterationStatement.init);
          {
            const hygienicTemp = GetValue(exprRef);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        return yield* ForBodyEvaluation(IterationStatement.test, IterationStatement.update, IterationStatement.body, [], labelSet);

      case isForStatementWithVariableStatement(IterationStatement):
        {
          let varDcl = yield* Evaluate(IterationStatement.init);

          if (varDcl instanceof AbruptCompletion) {
            return varDcl;
          }

          if (varDcl instanceof Completion) {
            varDcl = varDcl.Value;
          }

          return yield* ForBodyEvaluation(IterationStatement.test, IterationStatement.update, IterationStatement.body, [], labelSet);
        }

      case isForStatementWithLexicalDeclaration(IterationStatement):
        {
          const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
          const loopEnv = NewDeclarativeEnvironment(oldEnv);
          const loopEnvRec = loopEnv.EnvironmentRecord;
          const isConst = IsConstantDeclaration(IterationStatement.init);
          const boundNames = BoundNames_LexicalDeclaration(IterationStatement.init).map(Value);

          for (const dn of boundNames) {
            if (isConst) {
              Assert(!(loopEnvRec.CreateImmutableBinding(dn, Value.true) instanceof AbruptCompletion), "");
            } else {
              Assert(!(loopEnvRec.CreateMutableBinding(dn, true) instanceof AbruptCompletion), "");
            }
          }

          surroundingAgent.runningExecutionContext.LexicalEnvironment = loopEnv;
          const forDcl = yield* Evaluate(IterationStatement.init);

          if (forDcl instanceof AbruptCompletion) {
            surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
            return Completion(forDcl);
          }

          const perIterationLets = isConst ? [] : boundNames;
          const bodyResult = yield* ForBodyEvaluation(IterationStatement.test, IterationStatement.update, IterationStatement.body, perIterationLets, labelSet);
          surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
          return Completion(bodyResult);
        }

      case isForInStatementWithExpression(IterationStatement):
        {
          const {
            left: LeftHandSideExpression,
            right: Expression,
            body: Statement,
            strict
          } = IterationStatement;
          let keyResult = yield* ForInOfHeadEvaluation([], Expression, 'enumerate');

          if (keyResult instanceof AbruptCompletion) {
            return keyResult;
          }

          if (keyResult instanceof Completion) {
            keyResult = keyResult.Value;
          }

          return yield* ForInOfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, 'enumerate', 'assignment', labelSet, 'sync', strict);
        }

      case isForInStatementWithVarForBinding(IterationStatement):
        {
          const {
            left: {
              declarations: [{
                id: ForBinding
              }]
            },
            right: Expression,
            body: Statement,
            strict
          } = IterationStatement;
          let keyResult = yield* ForInOfHeadEvaluation([], Expression, 'enumerate');

          if (keyResult instanceof AbruptCompletion) {
            return keyResult;
          }

          if (keyResult instanceof Completion) {
            keyResult = keyResult.Value;
          }

          return yield* ForInOfBodyEvaluation(ForBinding, Statement, keyResult, 'enumerate', 'varBinding', labelSet, 'sync', strict);
        }

      case isForInStatementWithForDeclaration(IterationStatement):
        {
          const {
            left: ForDeclaration,
            right: Expression,
            body: Statement,
            strict
          } = IterationStatement;
          let keyResult = yield* ForInOfHeadEvaluation(BoundNames_ForDeclaration(ForDeclaration).map(Value), Expression, 'enumerate');

          if (keyResult instanceof AbruptCompletion) {
            return keyResult;
          }

          if (keyResult instanceof Completion) {
            keyResult = keyResult.Value;
          }

          return yield* ForInOfBodyEvaluation(ForDeclaration, Statement, keyResult, 'enumerate', 'lexicalBinding', labelSet, 'sync', strict);
        }

      case isForOfStatementWithExpression(IterationStatement):
        {
          const {
            left: LeftHandSideExpression,
            right: AssignmentExpression,
            body: Statement,
            await: isAwait,
            strict
          } = IterationStatement;
          let keyResult = yield* ForInOfHeadEvaluation([], AssignmentExpression, isAwait ? 'async-iterate' : 'iterate');

          if (keyResult instanceof AbruptCompletion) {
            return keyResult;
          }

          if (keyResult instanceof Completion) {
            keyResult = keyResult.Value;
          }

          return yield* ForInOfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, 'iterate', 'assignment', labelSet, isAwait ? 'async' : 'sync', strict);
        }

      case isForOfStatementWithVarForBinding(IterationStatement):
        {
          const {
            left: {
              declarations: [{
                id: ForBinding
              }]
            },
            right: AssignmentExpression,
            body: Statement,
            await: isAwait,
            strict
          } = IterationStatement;
          let keyResult = yield* ForInOfHeadEvaluation([], AssignmentExpression, isAwait ? 'async-iterate' : 'iterate');

          if (keyResult instanceof AbruptCompletion) {
            return keyResult;
          }

          if (keyResult instanceof Completion) {
            keyResult = keyResult.Value;
          }

          return yield* ForInOfBodyEvaluation(ForBinding, Statement, keyResult, 'iterate', 'varBinding', labelSet, isAwait ? 'async' : 'sync', strict);
        }

      case isForOfStatementWithForDeclaration(IterationStatement):
        {
          const {
            left: ForDeclaration,
            right: AssignmentExpression,
            body: Statement,
            await: isAwait,
            strict
          } = IterationStatement;
          let keyResult = yield* ForInOfHeadEvaluation(BoundNames_ForDeclaration(ForDeclaration).map(Value), AssignmentExpression, isAwait ? 'async-iterate' : 'iterate');

          if (keyResult instanceof AbruptCompletion) {
            return keyResult;
          }

          if (keyResult instanceof Completion) {
            keyResult = keyResult.Value;
          }

          return yield* ForInOfBodyEvaluation(ForDeclaration, Statement, keyResult, 'iterate', 'lexicalBinding', labelSet, isAwait ? 'async' : 'sync', strict);
        }

      default:
        throw new OutOfRange('LabelledEvaluation_IterationStatement', IterationStatement);
    }
  }

  function* InternalEnumerateObjectProperties(O) {
    const visited = new Set();
    let keys = O.OwnPropertyKeys();

    if (keys instanceof AbruptCompletion) {
      return keys;
    }

    if (keys instanceof Completion) {
      keys = keys.Value;
    }

    for (const key of keys) {
      if (Type(key) === 'Symbol') {
        continue;
      }

      let desc = O.GetOwnProperty(key);

      if (desc instanceof AbruptCompletion) {
        return desc;
      }

      if (desc instanceof Completion) {
        desc = desc.Value;
      }

      if (Type(desc) !== 'Undefined') {
        visited.add(key);

        if (desc.Enumerable === Value.true) {
          yield key;
        }
      }
    }

    let proto = O.GetPrototypeOf();

    if (proto instanceof AbruptCompletion) {
      return proto;
    }

    if (proto instanceof Completion) {
      proto = proto.Value;
    }

    if (Type(proto) === 'Null') {
      return;
    }

    for (const protoKey of InternalEnumerateObjectProperties(proto)) {
      if (!visited.has(protoKey)) {
        yield protoKey;
      }
    }
  } // 13.7.5.15 #sec-enumerate-object-properties


  function EnumerateObjectProperties(O) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    const internalIterator = InternalEnumerateObjectProperties(O);
    let iterator = ObjectCreate(Value.null);
    Assert(!(iterator instanceof AbruptCompletion), "");

    if (iterator instanceof Completion) {
      iterator = iterator.Value;
    }

    const nextMethod = CreateBuiltinFunction(() => {
      let {
        value,
        done
      } = internalIterator.next();

      if (value instanceof AbruptCompletion) {
        return value;
      }

      if (value instanceof Completion) {
        value = value.Value;
      }

      let _val = CreateIterResultObject(value === undefined ? Value.undefined : value, done ? Value.true : Value.false);

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      return _val;
    }, []);
    Assert(!(CreateDataProperty(iterator, new Value('next'), nextMethod) instanceof AbruptCompletion), "");
    Assert(!(CreateDataProperty(iterator, new Value('throw'), Value.null) instanceof AbruptCompletion), "");
    Assert(!(CreateDataProperty(iterator, new Value('return'), Value.null) instanceof AbruptCompletion), "");
    return {
      Iterator: iterator,
      NextMethod: nextMethod,
      Done: Value.false
    };
  }

  // FunctionDeclaration :
  //   function BindingIdentifier ( FormalParameters ) { FunctionBody }
  //   function ( FormalParameters ) { FunctionBody }

  function Evaluate_FunctionDeclaration() {
    return new NormalCompletion(undefined);
  }

  function Evaluate_FunctionExpression_BindingIdentifier(FunctionExpression) {
    const {
      id: BindingIdentifier,
      params: FormalParameters
    } = FunctionExpression;
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const funcEnv = NewDeclarativeEnvironment(scope);
    const envRec = funcEnv.EnvironmentRecord;
    const name = new Value(BindingIdentifier.name);
    envRec.CreateImmutableBinding(name, Value.false);
    const closure = FunctionCreate('Normal', FormalParameters, FunctionExpression, funcEnv);
    MakeConstructor(closure);
    SetFunctionName(closure, name);
    closure.SourceText = sourceTextMatchedBy(FunctionExpression);
    envRec.InitializeBinding(name, closure);
    return closure;
  }

  function Evaluate_FunctionExpression(FunctionExpression) {
    if (isFunctionExpressionWithBindingIdentifier(FunctionExpression)) {
      return Evaluate_FunctionExpression_BindingIdentifier(FunctionExpression);
    }

    const FormalParameters = FunctionExpression.params;
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const closure = FunctionCreate('Normal', FormalParameters, FunctionExpression, scope);
    MakeConstructor(closure);
    closure.SourceText = sourceTextMatchedBy(FunctionExpression);
    return closure;
  }

  //   FunctionStatementList : [empty]
  //
  // (implicit)
  //   FunctionStatementList : StatementList

  const Evaluate_FunctionStatementList = Evaluate_StatementList; // (implicit)
  //   FunctionBody : FunctionStatementList

  const Evaluate_FunctionBody = Evaluate_FunctionStatementList;

  //   GeneratorExpression :
  //     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
  //     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

  function Evaluate_GeneratorExpression(GeneratorExpression) {
    const {
      id: BindingIdentifier,
      params: FormalParameters
    } = GeneratorExpression;
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    let funcEnv = scope;
    let envRec;
    let name;

    if (BindingIdentifier) {
      funcEnv = NewDeclarativeEnvironment(scope);
      envRec = funcEnv.EnvironmentRecord;
      name = new Value(BindingIdentifier.name);
      envRec.CreateImmutableBinding(name, Value.false);
    }

    let closure = GeneratorFunctionCreate('Normal', FormalParameters, GeneratorExpression, funcEnv);
    Assert(!(closure instanceof AbruptCompletion), "");

    if (closure instanceof Completion) {
      closure = closure.Value;
    }

    const prototype = ObjectCreate(surroundingAgent.intrinsic('%GeneratorPrototype%'));
    Assert(!(DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    closure.SourceText = sourceTextMatchedBy(GeneratorExpression);

    if (BindingIdentifier) {
      Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
      envRec.InitializeBinding(name, closure);
    }

    return closure;
  }

  function GetSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    Assert(Type(matched) === 'String', "Type(matched) === 'String'");
    const matchLength = matched.stringValue().length;
    Assert(Type(str) === 'String', "Type(str) === 'String'");
    const stringLength = str.stringValue().length;
    Assert(Type(position) === 'Number' && Number.isInteger(position.numberValue()) && position.numberValue() >= 0, "Type(position) === 'Number' && Number.isInteger(position.numberValue()) && position.numberValue() >= 0");
    Assert(position.numberValue() <= stringLength, "position.numberValue() <= stringLength");
    Assert(Array.isArray(captures) && captures.every(value => Type(value) === 'String' || Type(value) === 'Undefined'), "Array.isArray(captures) && captures.every((value) => Type(value) === 'String' || Type(value) === 'Undefined')");
    Assert(Type(replacement) === 'String', "Type(replacement) === 'String'");
    const tailPos = position.numberValue() + matchLength;
    const m = captures.length;

    if (namedCaptures !== Value.undefined) {
      namedCaptures = ToObject(namedCaptures);

      if (namedCaptures instanceof AbruptCompletion) {
        return namedCaptures;
      }

      if (namedCaptures instanceof Completion) {
        namedCaptures = namedCaptures.Value;
      }
    }

    const replacementStr = replacement.stringValue();
    let result = '';
    let i = 0;

    while (i < replacementStr.length) {
      const currentChar = replacementStr[i];

      if (currentChar === '$' && i < replacementStr.length - 1) {
        const nextChar = replacementStr[i + 1];

        if (nextChar === '$') {
          result += '$';
          i += 2;
        } else if (nextChar === '&') {
          result += matched.stringValue();
          i += 2;
        } else if (nextChar === '`') {
          if (position.numberValue() === 0) ; else {
            result += str.stringValue().substring(0, position.numberValue());
          }

          i += 2;
        } else if (nextChar === '\'') {
          if (tailPos >= stringLength) ; else {
            result += str.stringValue().substring(tailPos);
          }

          i += 2;
        } else if ('123456789'.includes(nextChar) && (i === replacementStr.length - 2 || !'0123456789'.includes(replacementStr[i + 2]))) {
          const n = Number(nextChar);

          if (n <= m) {
            const capture = captures[n - 1];

            if (capture !== Value.undefined) {
              result += capture.stringValue();
            }
          } else {
            result += `$${nextChar}`;
          }

          i += 2;
        } else if (i < replacementStr.length - 2 && '0123456789'.includes(nextChar) && '0123456789'.includes(replacementStr[i + 2])) {
          const nextNextChar = replacementStr[i + 2];
          const n = Number(nextChar + nextNextChar);

          if (n !== 0 && n <= m) {
            const capture = captures[n - 1];

            if (capture !== Value.undefined) {
              result += capture.stringValue();
            }
          } else {
            result += `$${nextChar}${nextNextChar}`;
          }

          i += 3;
        } else if (nextChar === '<') {
          if (namedCaptures === Value.undefined) {
            result += '$<';
            i += 2;
          } else {
            const nextSign = replacementStr.indexOf('>', i);

            if (nextSign === -1) {
              result += '$<';
              i += 2;
            } else {
              const groupName = new Value(replacementStr.substring(i + 1, nextSign));
              let capture = Get(namedCaptures, groupName);

              if (capture instanceof AbruptCompletion) {
                return capture;
              }

              if (capture instanceof Completion) {
                capture = capture.Value;
              }

              if (capture === Value.undefined) ; else {
                let _hygienicTemp = ToString(capture);

                if (_hygienicTemp instanceof AbruptCompletion) {
                  return _hygienicTemp;
                }

                if (_hygienicTemp instanceof Completion) {
                  _hygienicTemp = _hygienicTemp.Value;
                }

                result += _hygienicTemp.stringValue();
              }

              i = nextSign + 1;
            }
          }
        } else {
          result += '$';
          i += 1;
        }
      } else {
        result += currentChar;
        i += 1;
      }
    }

    return new Value(result);
  }

  function GlobalDeclarationInstantiation(script, env) {
    const envRec = env.EnvironmentRecord;
    Assert(envRec instanceof EnvironmentRecord, "envRec instanceof EnvironmentRecord");
    const lexNames = LexicallyDeclaredNames_ScriptBody(script).map(Value);
    const varNames = VarDeclaredNames_ScriptBody(script).map(Value);

    for (const name of lexNames) {
      if (envRec.HasVarDeclaration(name) === Value.true) {
        return surroundingAgent.Throw('SyntaxError', msg('AlreadyDeclared', name));
      }

      if (envRec.HasLexicalDeclaration(name) === Value.true) {
        return surroundingAgent.Throw('SyntaxError', msg('AlreadyDeclared', name));
      }

      let hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(name);

      if (hasRestrictedGlobal instanceof AbruptCompletion) {
        return hasRestrictedGlobal;
      }

      if (hasRestrictedGlobal instanceof Completion) {
        hasRestrictedGlobal = hasRestrictedGlobal.Value;
      }

      if (hasRestrictedGlobal === Value.true) {
        return surroundingAgent.Throw('SyntaxError', msg('AlreadyDeclared', name));
      }
    }

    for (const name of varNames) {
      if (envRec.HasLexicalDeclaration(name) === Value.true) {
        return surroundingAgent.Throw('SyntaxError', msg('AlreadyDeclared', name));
      }
    }

    const varDeclarations = VarScopedDeclarations_ScriptBody(script);
    const functionsToInitialize = [];
    const declaredFunctionNames = [];

    for (const d of [...varDeclarations].reverse()) {
      if (!isVariableDeclaration(d) && !isForBinding(d) && !isBindingIdentifier(d)) {
        Assert(isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d), "isFunctionDeclaration(d) || isGeneratorDeclaration(d)\n             || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)");
        const fn = BoundNames_FunctionDeclaration(d)[0];

        if (!declaredFunctionNames.includes(fn)) {
          let fnDefinable = envRec.CanDeclareGlobalFunction(new Value(fn));

          if (fnDefinable instanceof AbruptCompletion) {
            return fnDefinable;
          }

          if (fnDefinable instanceof Completion) {
            fnDefinable = fnDefinable.Value;
          }

          if (fnDefinable === Value.false) {
            return surroundingAgent.Throw('TypeError');
          }

          declaredFunctionNames.push(fn);
          functionsToInitialize.unshift(d);
        }
      }
    }

    const declaredVarNames = [];

    for (const d of varDeclarations) {
      let boundNames;

      if (isVariableDeclaration(d)) {
        boundNames = BoundNames_VariableDeclaration(d);
      } else if (isForBinding(d)) {
        boundNames = BoundNames_ForBinding(d);
      } else if (isBindingIdentifier(d)) {
        boundNames = BoundNames_BindingIdentifier(d);
      }

      if (boundNames !== undefined) {
        for (const vn of boundNames.map(Value)) {
          if (!declaredFunctionNames.includes(vn)) {
            let vnDefinable = envRec.CanDeclareGlobalVar(vn);

            if (vnDefinable instanceof AbruptCompletion) {
              return vnDefinable;
            }

            if (vnDefinable instanceof Completion) {
              vnDefinable = vnDefinable.Value;
            }

            if (vnDefinable === Value.false) {
              return surroundingAgent.Throw('TypeError');
            }

            if (!declaredVarNames.includes(vn)) {
              declaredVarNames.push(vn);
            }
          }
        }
      }
    } // NOTE: Annex B.3.3.2 adds additional steps at this point.
    // TODO(devsnek): Annex B.3.3.2


    const lexDeclarations = LexicallyScopedDeclarations_ScriptBody(script);

    for (const d of lexDeclarations) {
      for (const dn of BoundNames_Declaration(d).map(Value)) {
        if (IsConstantDeclaration(d)) {
          {
            const hygienicTemp = envRec.CreateImmutableBinding(dn, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        } else {
          {
            const hygienicTemp = envRec.CreateMutableBinding(dn, Value.false);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }
      }
    }

    for (const f of functionsToInitialize) {
      const fn = new Value(BoundNames_FunctionDeclaration(f)[0]);
      const fo = InstantiateFunctionObject(f, env);
      {
        const hygienicTemp = envRec.CreateGlobalFunctionBinding(fn, fo, Value.false);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    for (const vn of declaredVarNames) {
      {
        const hygienicTemp = envRec.CreateGlobalVarBinding(vn, Value.false);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    return new NormalCompletion(undefined);
  }

  //   HoistableDeclaration :
  //     GeneratorDeclaration
  //     AsyncFunctionDeclaration
  //     AsyncGeneratorDeclaration
  //     FunctionDeclaration

  function Evaluate_HoistableDeclaration(HoistableDeclaration) {
    switch (true) {
      case isGeneratorDeclaration(HoistableDeclaration):
      case isAsyncFunctionDeclaration(HoistableDeclaration):
      case isAsyncGeneratorDeclaration(HoistableDeclaration):
        return new NormalCompletion(undefined);

      case isFunctionDeclaration(HoistableDeclaration):
        return Evaluate_FunctionDeclaration();

      default:
        throw new OutOfRange('Evaluate_HoistableDeclaration', HoistableDeclaration);
    }
  }

  // IdentifierReference :
  //   Identifier
  //   yield
  //   await

  function Evaluate_Identifier(Identifier) {
    return ResolveBinding(new Value(Identifier.name), undefined, Identifier.strict);
  }

  //   IfStatement :
  //     `if` `(` Expression `)` Statement `else` Statement
  //     `if` `(` Expression `)` Statement

  function* Evaluate_IfStatement({
    test: Expression,
    consequent: Statement,
    alternate: AlternateStatement
  }) {
    const exprRef = yield* Evaluate(Expression);

    let _hygienicTemp = GetValue(exprRef);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const exprValue = ToBoolean(_hygienicTemp);

    if (AlternateStatement !== null) {
      let stmtCompletion;

      if (exprValue === Value.true) {
        stmtCompletion = EnsureCompletion((yield* Evaluate(Statement)));
      } else {
        stmtCompletion = EnsureCompletion((yield* Evaluate(AlternateStatement)));
      }

      return Completion(UpdateEmpty(stmtCompletion, Value.undefined));
    } else {
      if (exprValue === Value.false) {
        return new NormalCompletion(Value.undefined);
      } else {
        const stmtCompletion = EnsureCompletion((yield* Evaluate(Statement)));
        return Completion(UpdateEmpty(stmtCompletion, Value.undefined));
      }
    }
  }

  // ImportCall : `import` `(` AssignmentExpression `)`

  function* Evaluate_ImportCall({
    arguments: [AssignmentExpression]
  }) {
    let referencingScriptOrModule = GetActiveScriptOrModule();
    Assert(!(referencingScriptOrModule instanceof AbruptCompletion), "");

    if (referencingScriptOrModule instanceof Completion) {
      referencingScriptOrModule = referencingScriptOrModule.Value;
    }

    const argRef = yield* Evaluate(AssignmentExpression);
    let specifier = GetValue(argRef);

    if (specifier instanceof AbruptCompletion) {
      return specifier;
    }

    if (specifier instanceof Completion) {
      specifier = specifier.Value;
    }

    let promiseCapability = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    Assert(!(promiseCapability instanceof AbruptCompletion), "");

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    let specifierString = ToString(specifier);

    if (specifierString instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [specifierString.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (specifierString instanceof Completion) {
      specifierString = specifierString.Value;
    }

    Assert(!(HostImportModuleDynamically(referencingScriptOrModule, specifierString, promiseCapability) instanceof AbruptCompletion), "");
    return promiseCapability.Promise;
  }

  //   FunctionDeclaration :
  //     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
  //     `function` `(` FormalParameters `)` `{` FunctionBody `}`

  function InstantiateFunctionObject_FunctionDeclaration(FunctionDeclaration, scope) {
    const {
      id: BindingIdentifier,
      params: FormalParameters
    } = FunctionDeclaration;
    const name = new Value(BindingIdentifier ? BindingIdentifier.name : 'default');
    let F = FunctionCreate('Normal', FormalParameters, FunctionDeclaration, scope);
    Assert(!(F instanceof AbruptCompletion), "");

    if (F instanceof Completion) {
      F = F.Value;
    }

    MakeConstructor(F);
    SetFunctionName(F, name);
    F.SourceText = sourceTextMatchedBy(FunctionDeclaration);
    return F;
  } // 14.4.11 #sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject
  //   GeneratorDeclaration :
  //     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
  //     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

  function InstantiateFunctionObject_GeneratorDeclaration(GeneratorDeclaration, scope) {
    const {
      id: BindingIdentifier,
      params: FormalParameters
    } = GeneratorDeclaration;
    const name = new Value(BindingIdentifier ? BindingIdentifier.name : 'default');
    let F = GeneratorFunctionCreate('Normal', FormalParameters, GeneratorDeclaration, scope);
    Assert(!(F instanceof AbruptCompletion), "");

    if (F instanceof Completion) {
      F = F.Value;
    }

    let prototype = ObjectCreate(surroundingAgent.intrinsic('%GeneratorPrototype%'));
    Assert(!(prototype instanceof AbruptCompletion), "");

    if (prototype instanceof Completion) {
      prototype = prototype.Value;
    }

    Assert(!(DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    SetFunctionName(F, name);
    F.SourceText = sourceTextMatchedBy(GeneratorDeclaration);
    return F;
  }
  function InstantiateFunctionObject_AsyncFunctionDeclaration(AsyncFunctionDeclaration, scope) {
    const {
      id: BindingIdentifier,
      params: FormalParameters
    } = AsyncFunctionDeclaration;
    const name = new Value(BindingIdentifier ? BindingIdentifier.name : 'default');
    let F = AsyncFunctionCreate('Normal', FormalParameters, AsyncFunctionDeclaration, scope);
    Assert(!(F instanceof AbruptCompletion), "");

    if (F instanceof Completion) {
      F = F.Value;
    }

    SetFunctionName(F, name);
    F.SourceText = sourceTextMatchedBy(AsyncFunctionDeclaration);
    return F;
  }
  function InstantiateFunctionObject_AsyncGeneratorDeclaration(AsyncGeneratorDeclaration, scope) {
    const {
      id: BindingIdentifier,
      params: FormalParameters
    } = AsyncGeneratorDeclaration;
    const name = new Value(BindingIdentifier ? BindingIdentifier.name : 'default');
    let F = AsyncGeneratorFunctionCreate('Normal', FormalParameters, AsyncGeneratorDeclaration, scope);
    Assert(!(F instanceof AbruptCompletion), "");

    if (F instanceof Completion) {
      F = F.Value;
    }

    let prototype = ObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorPrototype%'));
    Assert(!(prototype instanceof AbruptCompletion), "");

    if (prototype instanceof Completion) {
      prototype = prototype.Value;
    }

    Assert(!(DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    SetFunctionName(F, name);
    F.SourceText = sourceTextMatchedBy(AsyncGeneratorDeclaration);
    return F;
  }
  function InstantiateFunctionObject(AnyFunctionDeclaration, scope) {
    switch (true) {
      case isFunctionDeclaration(AnyFunctionDeclaration):
        return InstantiateFunctionObject_FunctionDeclaration(AnyFunctionDeclaration, scope);

      case isGeneratorDeclaration(AnyFunctionDeclaration):
        return InstantiateFunctionObject_GeneratorDeclaration(AnyFunctionDeclaration, scope);

      case isAsyncFunctionDeclaration(AnyFunctionDeclaration):
        return InstantiateFunctionObject_AsyncFunctionDeclaration(AnyFunctionDeclaration, scope);

      case isAsyncGeneratorDeclaration(AnyFunctionDeclaration):
        return InstantiateFunctionObject_AsyncGeneratorDeclaration(AnyFunctionDeclaration, scope);

      default:
        throw new OutOfRange('InstantiateFunctionObject', AnyFunctionDeclaration);
    }
  }

  //   ArrayBindingPattern :
  //     `[` `]`
  //     `[` Elision `]`
  //     `[` Elision BindingRestElement `]`
  //     `[` BindingElementList `]`
  //     `[` BindingElementList `,` `]`
  //     `[` BindingElementList `,` Elision `]`
  //     `[` BindingElementList `,` Elision BindingRestElement `]`

  function* IteratorBindingInitialization_ArrayBindingPattern(ArrayBindingPattern, iteratorRecord, environment) {
    let Elision;
    let BindingElementList = ArrayBindingPattern.elements;
    let BindingRestElement; // Members of the BindingElementList may be null, so add a truthyness check.

    if (BindingElementList.length > 0 && BindingElementList[BindingElementList.length - 1] && isBindingRestElement(BindingElementList[BindingElementList.length - 1])) {
      BindingRestElement = BindingElementList[BindingElementList.length - 1];
      BindingElementList = BindingElementList.slice(0, -1);
    }

    if (BindingElementList.length > 0) {
      let begin;

      for (begin = BindingElementList.length; begin > 0; begin -= 1) {
        if (BindingElementList[begin - 1] !== null) {
          break;
        }
      }

      if (begin !== BindingElementList.length) {
        Elision = BindingElementList.slice(begin);
        BindingElementList = BindingElementList.slice(0, begin);
      }
    }

    let status = new NormalCompletion(undefined);

    if (BindingElementList.length > 0) {
      status = yield* IteratorBindingInitialization_BindingElementList(BindingElementList, iteratorRecord, environment);

      if (status instanceof AbruptCompletion) {
        return status;
      }

      if (status instanceof Completion) {
        status = status.Value;
      }
    }

    if (Elision !== undefined) {
      status = IteratorDestructuringAssignmentEvaluation_Elision(Elision, iteratorRecord);

      if (status instanceof AbruptCompletion) {
        return status;
      }

      if (status instanceof Completion) {
        status = status.Value;
      }
    }

    if (BindingRestElement !== undefined) {
      status = yield* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment);

      if (status instanceof AbruptCompletion) {
        return status;
      }

      if (status instanceof Completion) {
        status = status.Value;
      }
    }

    return status;
  } // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
  //   BindingElement : BindingPattern Initializer

  function* IteratorBindingInitialization_BindingElement_BindingPattern(BindingElement, iteratorRecord, environment) {
    let BindingPattern;
    let Initializer;

    switch (true) {
      case isBindingPattern(BindingElement):
        BindingPattern = BindingElement;
        Initializer = undefined;
        break;

      case isBindingPatternAndInitializer(BindingElement):
        BindingPattern = BindingElement.left;
        Initializer = BindingElement.right;
        break;

      default:
        throw new OutOfRange('IteratorBindingInitialization_BindingElement_BindingPattern', BindingElement);
    }

    let v;

    if (iteratorRecord.Done === Value.false) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
      } else {
        v = IteratorValue(next);

        if (v instanceof AbruptCompletion) {
          iteratorRecord.Done = Value.true;
        }

        if (v instanceof AbruptCompletion) {
          return v;
        }

        if (v instanceof Completion) {
          v = v.Value;
        }
      }
    }

    if (iteratorRecord.Done === Value.true) {
      v = Value.undefined;
    }

    if (Initializer !== undefined && Type(v) === 'Undefined') {
      const defaultValue = yield* Evaluate(Initializer);
      v = GetValue(defaultValue);

      if (v instanceof AbruptCompletion) {
        return v;
      }

      if (v instanceof Completion) {
        v = v.Value;
      }
    }

    return yield* BindingInitialization_BindingPattern(BindingPattern, v, environment);
  } // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
  //   SingleNameBinding : BindingIdentifier Initializer


  function* IteratorBindingInitialization_SingleNameBinding(SingleNameBinding, iteratorRecord, environment) {
    let BindingIdentifier;
    let Initializer;

    switch (true) {
      case isBindingIdentifier(SingleNameBinding):
        BindingIdentifier = SingleNameBinding;
        Initializer = undefined;
        break;

      case isBindingIdentifierAndInitializer(SingleNameBinding):
        BindingIdentifier = SingleNameBinding.left;
        Initializer = SingleNameBinding.right;
        break;

      default:
        throw new OutOfRange('IteratorBindingInitialization_SingleNameBinding', SingleNameBinding);
    }

    const bindingId = new Value(BindingIdentifier.name);
    let lhs = ResolveBinding(bindingId, environment, BindingIdentifier.strict);

    if (lhs instanceof AbruptCompletion) {
      return lhs;
    }

    if (lhs instanceof Completion) {
      lhs = lhs.Value;
    }

    let v;

    if (iteratorRecord.Done === Value.false) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
      } else {
        v = IteratorValue(next);

        if (v instanceof AbruptCompletion) {
          iteratorRecord.Done = Value.true;
        }

        if (v instanceof AbruptCompletion) {
          return v;
        }

        if (v instanceof Completion) {
          v = v.Value;
        }
      }
    }

    if (iteratorRecord.Done === Value.true) {
      v = Value.undefined;
    }

    if (Initializer !== undefined && v === Value.undefined) {
      if (IsAnonymousFunctionDefinition(Initializer)) {
        v = yield* NamedEvaluation_Expression(Initializer, bindingId);
      } else {
        const defaultValue = yield* Evaluate(Initializer);
        v = GetValue(defaultValue);

        if (v instanceof AbruptCompletion) {
          return v;
        }

        if (v instanceof Completion) {
          v = v.Value;
        }
      }
    }

    if (Type(environment) === 'Undefined') {
      return PutValue(lhs, v);
    }

    return InitializeReferencedBinding(lhs, v);
  } // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
  //   BindingElementList : BindingElementList `,` BindingElisionElement
  //
  // (implicit)
  //   BindingElementList : BindingElisionElement


  function* IteratorBindingInitialization_BindingElementList(BindingElementList, iteratorRecord, environment) {
    Assert(BindingElementList.length > 0, "BindingElementList.length > 0");
    let result;

    for (const BindingElisionElement of BindingElementList) {
      result = yield* IteratorBindingInitialization_BindingElisionElement(BindingElisionElement, iteratorRecord, environment);

      if (result instanceof AbruptCompletion) {
        return result;
      }

      if (result instanceof Completion) {
        result = result.Value;
      }
    }

    return result;
  } // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
  //   BindingElisionElement :
  //     BindingElement
  //     Elision BindingElement


  function* IteratorBindingInitialization_BindingElisionElement(BindingElisionElement, iteratorRecord, environment) {
    if (!BindingElisionElement) {
      // This is an elision.
      return IteratorDestructuringAssignmentEvaluation_Elision([BindingElisionElement], iteratorRecord);
    }

    return yield* IteratorBindingInitialization_BindingElement(BindingElisionElement, iteratorRecord, environment);
  } // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
  //   BindingElement : SingleNameBinding


  function* IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment) {
    switch (true) {
      case isSingleNameBinding(BindingElement):
        return yield* IteratorBindingInitialization_SingleNameBinding(BindingElement, iteratorRecord, environment);

      case isBindingPattern(BindingElement) || isBindingPatternAndInitializer(BindingElement):
        return yield* IteratorBindingInitialization_BindingElement_BindingPattern(BindingElement, iteratorRecord, environment);

      default:
        throw new OutOfRange('IteratorBindingInitialization_BindingElement', BindingElement);
    }
  } // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
  //   BindingRestElement : `...` BindingIdentifier


  function IteratorBindingInitialization_BindingRestElement_Identifier(BindingRestElement, iteratorRecord, environment) {
    const BindingIdentifier = BindingRestElement.argument;
    let lhs = ResolveBinding(new Value(BindingIdentifier.name), environment, BindingIdentifier.strict);

    if (lhs instanceof AbruptCompletion) {
      return lhs;
    }

    if (lhs instanceof Completion) {
      lhs = lhs.Value;
    }

    let A = ArrayCreate(new Value(0));
    Assert(!(A instanceof AbruptCompletion), "");

    if (A instanceof Completion) {
      A = A.Value;
    }

    let n = 0;

    while (true) {
      let next;

      if (iteratorRecord.Done === Value.false) {
        next = IteratorStep(iteratorRecord);

        if (next instanceof AbruptCompletion) {
          iteratorRecord.Done = Value.true;
        }

        if (next instanceof AbruptCompletion) {
          return next;
        }

        if (next instanceof Completion) {
          next = next.Value;
        }

        if (next === Value.false) {
          iteratorRecord.Done = Value.true;
        }
      }

      if (iteratorRecord.Done === Value.true) {
        if (Type(environment) === 'Undefined') {
          return PutValue(lhs, A);
        }

        return InitializeReferencedBinding(lhs, A);
      }

      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      let nStr = ToString(new Value(n));
      Assert(!(nStr instanceof AbruptCompletion), "");

      if (nStr instanceof Completion) {
        nStr = nStr.Value;
      }

      let status = CreateDataProperty(A, nStr, nextValue);
      Assert(!(status instanceof AbruptCompletion), "");

      if (status instanceof Completion) {
        status = status.Value;
      }

      Assert(status === Value.true, "status === Value.true");
      n += 1;
    }
  } // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
  //   BindingRestElement :
  //     `...` BindingPattern


  function* IteratorBindingInitialization_BindingRestElement_Pattern(BindingRestElement, iteratorRecord, environment) {
    const BindingPattern = BindingRestElement.argument;
    let A = ArrayCreate(new Value(0));
    Assert(!(A instanceof AbruptCompletion), "");

    if (A instanceof Completion) {
      A = A.Value;
    }

    let n = 0;

    while (true) {
      let next;

      if (iteratorRecord.Done === Value.false) {
        next = IteratorStep(iteratorRecord);

        if (next instanceof AbruptCompletion) {
          iteratorRecord.Done = Value.true;
        }

        if (next instanceof AbruptCompletion) {
          return next;
        }

        if (next instanceof Completion) {
          next = next.Value;
        }

        if (next === Value.false) {
          iteratorRecord.Done = Value.true;
        }
      }

      if (iteratorRecord.Done === Value.true) {
        return yield* BindingInitialization_BindingPattern(BindingPattern, A, environment);
      }

      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      let nStr = ToString(new Value(n));
      Assert(!(nStr instanceof AbruptCompletion), "");

      if (nStr instanceof Completion) {
        nStr = nStr.Value;
      }

      let status = CreateDataProperty(A, nStr, nextValue);
      Assert(!(status instanceof AbruptCompletion), "");

      if (status instanceof Completion) {
        status = status.Value;
      }

      Assert(status === Value.true, "status === Value.true");
      n += 1;
    }
  }

  function* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment) {
    switch (true) {
      case isBindingIdentifier(BindingRestElement.argument):
        return IteratorBindingInitialization_BindingRestElement_Identifier(BindingRestElement, iteratorRecord, environment);

      case isBindingPattern(BindingRestElement.argument):
        return yield* IteratorBindingInitialization_BindingRestElement_Pattern(BindingRestElement, iteratorRecord, environment);

      default:
        throw new OutOfRange('IteratorBindingInitialization_BindingRestElement', BindingRestElement);
    }
  } // 14.1.19 #sec-function-definitions-runtime-semantics-iteratorbindinginitialization
  //   FormalParameter : BindingElement


  function* IteratorBindingInitialization_FormalParameter(FormalParameter, iteratorRecord, environment) {
    const BindingElement = FormalParameter;

    if (!ContainsExpression_BindingElement(BindingElement)) {
      return yield* IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment);
    }

    const currentContext = surroundingAgent.runningExecutionContext;
    const originalEnv = currentContext.VariableEnvironment;
    Assert(currentContext.VariableEnvironment === currentContext.LexicalEnvironment, "currentContext.VariableEnvironment === currentContext.LexicalEnvironment");

    if (environment !== Value.undefined) {
      Assert(environment === originalEnv, "environment === originalEnv");
    }

    const paramVarEnv = NewDeclarativeEnvironment(originalEnv);
    currentContext.VariableEnvironment = paramVarEnv;
    currentContext.LexicalEnvironment = paramVarEnv;
    const result = yield* IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment);
    currentContext.VariableEnvironment = originalEnv;
    currentContext.LexicalEnvironment = originalEnv;
    return result;
  } // 14.1.19 #sec-function-definitions-runtime-semantics-iteratorbindinginitialization
  //   FunctionRestParameter : BindingRestElement


  function* IteratorBindingInitialization_FunctionRestParameter(FunctionRestParameter, iteratorRecord, environment) {
    const BindingRestElement = FunctionRestParameter;

    if (!ContainsExpression_BindingRestElement(BindingRestElement)) {
      return yield* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment);
    }

    const currentContext = surroundingAgent.runningExecutionContext;
    const originalEnv = currentContext.VariableEnvironment;
    Assert(currentContext.VariableEnvironment === currentContext.LexicalEnvironment, "currentContext.VariableEnvironment === currentContext.LexicalEnvironment");

    if (environment !== Value.undefined) {
      Assert(environment === originalEnv, "environment === originalEnv");
    }

    const paramVarEnv = NewDeclarativeEnvironment(originalEnv);
    currentContext.VariableEnvironment = paramVarEnv;
    currentContext.LexicalEnvironment = paramVarEnv;
    const result = yield* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment);
    currentContext.VariableEnvironment = originalEnv;
    currentContext.LexicalEnvironment = originalEnv;
    return result;
  } // 14.1.19 #sec-function-definitions-runtime-semantics-iteratorbindinginitialization
  //   FormalParameters :
  //     [empty]
  //     FormalParameterList `,` FunctionRestParameter
  //   FormalParameterList : FormalParameterList `,` FormalParameter
  //
  // (implicit)
  //   FormalParameters :
  //     FunctionRestParameter
  //     FormalParameterList
  //     FormalParameterList `,`
  //   FormalParameterList : FormalParameter


  function* IteratorBindingInitialization_FormalParameters(FormalParameters, iteratorRecord, environment) {
    if (FormalParameters.length === 0) {
      return new NormalCompletion(undefined);
    }

    for (const FormalParameter of FormalParameters.slice(0, -1)) {
      Assert(isFormalParameter(FormalParameter), "isFormalParameter(FormalParameter)");
      {
        const hygienicTemp = yield* IteratorBindingInitialization_FormalParameter(FormalParameter, iteratorRecord, environment);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    const last = FormalParameters[FormalParameters.length - 1];

    if (isFunctionRestParameter(last)) {
      return yield* IteratorBindingInitialization_FunctionRestParameter(last, iteratorRecord, environment);
    }

    Assert(isFormalParameter(last), "isFormalParameter(last)");
    return yield* IteratorBindingInitialization_FormalParameter(last, iteratorRecord, environment);
  }

  //   BindingElement : BindingPattern Initializer
  //
  // (implicit)
  //   BindingElement : SingleNameBinding

  function* KeyedBindingInitialization_BindingElement(BindingElement, value, environment, propertyName) {
    let BindingPattern;
    let Initializer;

    switch (true) {
      case isSingleNameBinding(BindingElement):
        return yield* KeyedBindingInitialization_SingleNameBinding(BindingElement, value, environment, propertyName);

      case isBindingPattern(BindingElement):
        BindingPattern = BindingElement;
        Initializer = undefined;
        break;

      case isBindingPatternAndInitializer(BindingElement):
        BindingPattern = BindingElement.left;
        Initializer = BindingElement.right;
        break;

      default:
        throw new OutOfRange('KeyedBindingInitialization_BindingElement', BindingElement);
    }

    let v = GetV(value, propertyName);

    if (v instanceof AbruptCompletion) {
      return v;
    }

    if (v instanceof Completion) {
      v = v.Value;
    }

    if (Initializer !== undefined && Type(v) === 'Undefined') {
      const defaultValue = yield* Evaluate(Initializer);
      v = GetValue(defaultValue);

      if (v instanceof AbruptCompletion) {
        return v;
      }

      if (v instanceof Completion) {
        v = v.Value;
      }
    }

    return yield* BindingInitialization_BindingPattern(BindingPattern, v, environment);
  } // 13.3.3.9 #sec-runtime-semantics-keyedbindinginitialization
  //   SingleNameBinding : BindingIdentifier Initializer

  function* KeyedBindingInitialization_SingleNameBinding(SingleNameBinding, value, environment, propertyName) {
    let BindingIdentifier;
    let Initializer;

    switch (true) {
      case isBindingIdentifier(SingleNameBinding):
        BindingIdentifier = SingleNameBinding;
        Initializer = undefined;
        break;

      case isBindingIdentifierAndInitializer(SingleNameBinding):
        BindingIdentifier = SingleNameBinding.left;
        Initializer = SingleNameBinding.right;
        break;

      default:
        throw new OutOfRange('KeyedBindingInitialization_SingleNameBinding', SingleNameBinding);
    }

    const bindingId = new Value(BindingIdentifier.name);
    let lhs = ResolveBinding(bindingId, environment, BindingIdentifier.strict);

    if (lhs instanceof AbruptCompletion) {
      return lhs;
    }

    if (lhs instanceof Completion) {
      lhs = lhs.Value;
    }

    let v = GetV(value, propertyName);

    if (v instanceof AbruptCompletion) {
      return v;
    }

    if (v instanceof Completion) {
      v = v.Value;
    }

    if (Initializer !== undefined && Type(v) === 'Undefined') {
      if (IsAnonymousFunctionDefinition(Initializer)) {
        v = yield* NamedEvaluation_Expression(Initializer, bindingId);
      } else {
        const defaultValue = yield* Evaluate(Initializer);
        v = GetValue(defaultValue);

        if (v instanceof AbruptCompletion) {
          return v;
        }

        if (v instanceof Completion) {
          v = v.Value;
        }
      }
    }

    if (Type(environment) === 'Undefined') {
      return PutValue(lhs, v);
    }

    return InitializeReferencedBinding(lhs, v);
  }

  function* LabelledEvaluation({
    label: LabelIdentifier,
    body: LabelledItem
  }, labelSet) {
    const label = new Value(LabelIdentifier.name);
    labelSet.push(label);
    let stmtResult;

    switch (true) {
      case isBreakableStatement(LabelledItem):
        stmtResult = yield* LabelledEvaluation_BreakableStatement(LabelledItem, labelSet);
        break;

      case isLabelledStatement(LabelledItem):
        stmtResult = yield* LabelledEvaluation(LabelledItem, labelSet);
        break;

      case isStatement(LabelledItem):
        stmtResult = yield* Evaluate(LabelledItem);
        break;

      default:
        throw new OutOfRange('LabelledEvaluation', LabelledItem);
    }

    stmtResult = EnsureCompletion(stmtResult);

    if (stmtResult.Type === 'break' && SameValue(stmtResult.Target, label) === Value.true) {
      stmtResult = new NormalCompletion(stmtResult.Value);
    }

    return Completion(stmtResult);
  } // 13.13.15 #sec-labelled-statements-runtime-semantics-evaluation


  function* Evaluate_LabelledStatement(LabelledStatement) {
    const newLabelSet = [];
    return yield* LabelledEvaluation(LabelledStatement, newLabelSet);
  }

  //   LexicalBinding :
  //     BindingIdentifier
  //     BindingIdentifier Initializer

  function* Evaluate_LexicalBinding_BindingIdentifier(LexicalBinding) {
    const {
      id: BindingIdentifier,
      init: Initializer,
      strict
    } = LexicalBinding;
    const bindingId = new Value(BindingIdentifier.name);
    let lhs = ResolveBinding(bindingId, undefined, strict);
    Assert(!(lhs instanceof AbruptCompletion), "");

    if (lhs instanceof Completion) {
      lhs = lhs.Value;
    }

    if (Initializer) {
      let value;

      if (IsAnonymousFunctionDefinition(Initializer)) {
        value = yield* NamedEvaluation_Expression(Initializer, bindingId);
      } else {
        const rhs = yield* Evaluate(Initializer);
        value = GetValue(rhs);

        if (value instanceof AbruptCompletion) {
          return value;
        }

        if (value instanceof Completion) {
          value = value.Value;
        }
      }

      return InitializeReferencedBinding(lhs, value);
    } else {
      return InitializeReferencedBinding(lhs, Value.undefined);
    }
  } // 13.3.1.4 #sec-let-and-const-declarations-runtime-semantics-evaluation
  //   LexicalBinding : BindingPattern Initializer


  function* Evaluate_LexicalBinding_BindingPattern(LexicalBinding) {
    const {
      id: BindingPattern,
      init: Initializer
    } = LexicalBinding;
    const rhs = yield* Evaluate(Initializer);
    let value = GetValue(rhs);

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    return yield* BindingInitialization_BindingPattern(BindingPattern, value, env);
  }

  function* Evaluate_LexicalBinding(LexicalBinding) {
    switch (true) {
      case isBindingIdentifier(LexicalBinding.id):
        return yield* Evaluate_LexicalBinding_BindingIdentifier(LexicalBinding);

      case isBindingPattern(LexicalBinding.id):
        return yield* Evaluate_LexicalBinding_BindingPattern(LexicalBinding);

      default:
        throw new OutOfRange('Evaluate_LexicalBinding', LexicalBinding.id);
    }
  } // 13.3.1.4 #sec-let-and-const-declarations-runtime-semantics-evaluation
  //   BindingList : BindingList `,` LexicalBinding
  //
  // (implicit)
  //   BindingList : LexicalBinding

  function* Evaluate_BindingList(BindingList) {
    let last;

    for (const LexicalBinding of BindingList) {
      last = yield* Evaluate_LexicalBinding(LexicalBinding);

      if (last instanceof AbruptCompletion) {
        return last;
      }

      if (last instanceof Completion) {
        last = last.Value;
      }
    }

    return last;
  } // 13.3.1.4 #sec-let-and-const-declarations-runtime-semantics-evaluation
  //   LexicalDeclaration : LetOrConst BindingList `;`

  function* Evaluate_LexicalDeclaration({
    declarations: BindingList
  }) {
    let next = yield* Evaluate_BindingList(BindingList);

    if (next instanceof AbruptCompletion) {
      return next;
    }

    if (next instanceof Completion) {
      next = next.Value;
    }

    return new NormalCompletion(undefined);
  }

  //   Literal : StringLiteral
  //   Literal : BooleanLiteral
  //   Literal : NumericLiteral

  function Evaluate_Literal(Literal) {
    switch (true) {
      case Literal.raw === 'null':
        return Value.null;

      case Literal.raw === 'true':
        return Value.true;

      case Literal.raw === 'false':
        return Value.false;

      case typeof Literal.value === 'number':
        return new Value(MV_NumericLiteral(Literal.raw));

      case typeof Literal.value === 'string':
        return new Value(Literal.value);

      default:
        throw new OutOfRange('Evaluate_Literal', Literal);
    }
  }

  // LogicalANDExpression : LogicalANDExpression `&&` BitwiseORExpression

  function* Evaluate_LogicalANDExpression({
    left: LogicalANDExpression,
    right: BitwiseORExpression
  }) {
    const lref = yield* Evaluate(LogicalANDExpression);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    const lbool = ToBoolean(lval);

    if (lbool === Value.false) {
      return lval;
    }

    const rref = yield* Evaluate(BitwiseORExpression);
    return GetValue(rref);
  }

  // LogicalORExpression : LogicalORExpression `||` LogicalANDExpression

  function* Evaluate_LogicalORExpression({
    left: LogicalORExpression,
    right: LogicalANDExpression
  }) {
    const lref = yield* Evaluate(LogicalORExpression);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    const lbool = ToBoolean(lval);

    if (lbool === Value.true) {
      return lval;
    }

    const rref = yield* Evaluate(LogicalANDExpression);
    return GetValue(rref);
  }

  //   MemberExpression : MemberExpression `[` Expression `]`
  //   CallExpression : CallExpression `[` Expression `]`

  function* Evaluate_MemberExpression_Expression(MemberExpression, Expression) {
    const baseReference = yield* Evaluate(MemberExpression);
    let baseValue = GetValue(baseReference);

    if (baseValue instanceof AbruptCompletion) {
      return baseValue;
    }

    if (baseValue instanceof Completion) {
      baseValue = baseValue.Value;
    }

    const strict = MemberExpression.strict;
    return yield* EvaluateDynamicPropertyAccess(baseValue, Expression, strict);
  } // 12.3.2.1 #sec-property-accessors-runtime-semantics-evaluation
  //   MemberExpression : MemberExpression `.` IdentifierName
  //   CallExpression : CallExpression `.` IdentifierName


  function* Evaluate_MemberExpression_IdentifierName(MemberExpression, IdentifierName) {
    const baseReference = yield* Evaluate(MemberExpression);
    let baseValue = GetValue(baseReference);

    if (baseValue instanceof AbruptCompletion) {
      return baseValue;
    }

    if (baseValue instanceof Completion) {
      baseValue = baseValue.Value;
    }

    const strict = MemberExpression.strict;
    return EvaluateStaticPropertyAccess(baseValue, IdentifierName, strict);
  } // 12.3.2.1 #sec-property-accessors-runtime-semantics-evaluation
  //   MemberExpression :
  //     MemberExpression `[` Expression `]`
  //     MemberExpression `.` IdentifierName
  //   CallExpression :
  //     CallExpression `[` Expression `]`
  //     CallExpression `.` IdentifierName


  function* Evaluate_MemberExpression(MemberExpression) {
    switch (true) {
      case isActualMemberExpressionWithBrackets(MemberExpression):
        return yield* Evaluate_MemberExpression_Expression(MemberExpression.object, MemberExpression.property);

      case isActualMemberExpressionWithDot(MemberExpression):
        return yield* Evaluate_MemberExpression_IdentifierName(MemberExpression.object, MemberExpression.property);

      default:
        throw new OutOfRange('Evaluate_MemberExpression', MemberExpression);
    }
  }

  // NewTarget : `new` `.` `target`

  function Evaluate_NewTarget() {
    return GetNewTarget();
  } // #prod-MetaProperty
  // MetaProperty : NewTarget


  function* Evaluate_MetaProperty() {
    // eslint-disable-line require-yield
    return Evaluate_NewTarget();
  }

  const {
    isNewLine,
    nonASCIIwhitespace
  } = acorn;

  function isWhiteSpace(c) {
    return c === '\x09' // CHARACTER TABULATION
    || c === '\x0B' // LINE TABULATION
    || c === '\x0C' // FORM FEED (FF)
    || c === '\x20' // SPACE
    || c === '\xA0' // NO-BREAK SPACE
    || nonASCIIwhitespace.test(c);
  }

  const isLineTerminator = c => isNewLine(c.charCodeAt(0), false);

  const isStrWhiteSpaceChar = c => isWhiteSpace(c) || isLineTerminator(c); // Returns index of first non-StrWhiteSpaceChar character.


  function searchNotStrWhiteSpaceChar(str) {
    for (let i = 0; i < str.length; i += 1) {
      if (!isStrWhiteSpaceChar(str[i])) return i;
    }

    return str.length;
  } // Returns index of last non-StrWhiteSpaceChar character + 1.

  function reverseSearchNotStrWhiteSpaceChar(str) {
    for (let i = str.length - 1; i >= 0; i -= 1) {
      if (!isStrWhiteSpaceChar(str[i])) return i + 1;
    }

    return 0;
  }

  const {
    ParserRules: ParserRules$2
  } = grammar;
  const StrNumericLiteralGrammar = nearley.Grammar.fromCompiled({
    ParserRules: ParserRules$2,
    ParserStart: 'StrNumericLiteral'
  });
  const StrDecimalLiteralGrammar = nearley.Grammar.fromCompiled({
    ParserRules: ParserRules$2,
    ParserStart: 'StrDecimalLiteral'
  }); // 7.1.3.1.1 #sec-runtime-semantics-mv-s
  // Once the exact MV for a String numeric literal has been determined, it is
  // then rounded to a value of the Number type. If the MV is 0, then the rounded
  // value is +0 unless the first non white space code point in the String
  // numeric literal is "-", in which case the rounded value is -0. Otherwise,
  // the rounded value must be the Number value for the MV

  function convertScientificMVToNumber(scientific, strWithoutWhitespace) {
    const prelimMV = scientific.toNumber();

    if (prelimMV === 0) {
      if (strWithoutWhitespace[0] === '-') {
        return new Value(-0);
      } else {
        return new Value(+0);
      }
    }

    return new Value(prelimMV);
  } // 7.1.3.1.1 #sec-runtime-semantics-mv-s
  //   StringNumericLiteral :::
  //     [empty]
  //     StrWhiteSpace
  //     StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt


  function MV_StringNumericLiteral(StringNumericLiteral) {
    if (StringNumericLiteral === '') {
      // StringNumericLiteral ::: [empty]
      return new Value(0);
    }

    const leadingWhitespaceStripped = StringNumericLiteral.slice(searchNotStrWhiteSpaceChar(StringNumericLiteral));

    if (leadingWhitespaceStripped === '') {
      // StringNumericLiteral ::: StrWhiteSpace
      return new Value(0);
    } // StringNumericLiteral ::: StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt


    const StrNumericLiteral = leadingWhitespaceStripped.slice(0, reverseSearchNotStrWhiteSpaceChar(leadingWhitespaceStripped));
    return MV_StrNumericLiteral(StrNumericLiteral);
  } // 7.1.3.1.1 #sec-runtime-semantics-mv-s
  //   StrNumericLiteral :::
  //     StrDecimalLiteral
  //     BinaryIntegerLiteral
  //     OctalIntegerLiteral
  //     HexIntegerLiteral

  function MV_StrNumericLiteral(StrNumericLiteral) {
    const parser = new nearley.Parser(StrNumericLiteralGrammar);

    try {
      parser.feed(StrNumericLiteral);
    } catch (err) {
      return new Value(NaN);
    }

    if (parser.results.length === 0) {
      return new Value(NaN);
    }

    Assert(parser.results.length === 1, "parser.results.length === 1");
    return convertScientificMVToNumber(parser.results[0], StrNumericLiteral);
  } // 7.1.3.1.1 #sec-runtime-semantics-mv-s
  //   StrDecimalLiteral :::
  //     StrUnsignedDecimalLiteral
  //     `+` StrUnsignedDecimalLiteral
  //     `-` StrUnsignedDecimalLiteral


  function MV_StrDecimalLiteral(StrDecimalLiteral, prefixOk = false) {
    const parser = new nearley.Parser(StrDecimalLiteralGrammar, {
      keepHistory: prefixOk
    });

    try {
      parser.feed(StrDecimalLiteral);
    } catch (err) {
      if (!prefixOk) {
        return new Value(NaN);
      }
    }

    if (prefixOk) {
      // Backtrack until we find a prefix of StrDecimalLiteral that is indeed a
      // StrDecimalLiteral.
      while (parser.table[parser.current]) {
        parser.restore(parser.table[parser.current]);

        if (parser.results.length !== 0) {
          break;
        }

        parser.current -= 1;
      }

      if (parser.results.length === 0) {
        return new Value(NaN);
      }
    }

    Assert(parser.results.length === 1, "parser.results.length === 1");
    return convertScientificMVToNumber(parser.results[0], StrDecimalLiteral);
  }

  function EvaluateBinopValues_MultiplicativeExpression(MultiplicativeOperator, lval, rval) {
    let lnum = ToNumber(lval);

    if (lnum instanceof AbruptCompletion) {
      return lnum;
    }

    if (lnum instanceof Completion) {
      lnum = lnum.Value;
    }

    let rnum = ToNumber(rval);

    if (rnum instanceof AbruptCompletion) {
      return rnum;
    }

    if (rnum instanceof Completion) {
      rnum = rnum.Value;
    }

    // Return the result of applying the MultiplicativeOperator (*, /, or %)
    // to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.
    switch (MultiplicativeOperator) {
      case '*':
        return new Value(lnum.numberValue() * rnum.numberValue());

      case '/':
        return new Value(lnum.numberValue() / rnum.numberValue());

      case '%':
        return new Value(lnum.numberValue() % rnum.numberValue());

      default:
        throw new OutOfRange('EvaluateBinopValues_MultiplicativeExpression', MultiplicativeOperator);
    }
  }
  function* Evaluate_MultiplicativeExpression({
    left: MultiplicativeExpression,
    operator: MultiplicativeOperator,
    right: ExponentiationExpression
  }) {
    const left = yield* Evaluate(MultiplicativeExpression);
    let leftValue = GetValue(left);

    if (leftValue instanceof AbruptCompletion) {
      return leftValue;
    }

    if (leftValue instanceof Completion) {
      leftValue = leftValue.Value;
    }

    const right = yield* Evaluate(ExponentiationExpression);
    let rightValue = GetValue(right);

    if (rightValue instanceof AbruptCompletion) {
      return rightValue;
    }

    if (rightValue instanceof Completion) {
      rightValue = rightValue.Value;
    }

    return EvaluateBinopValues_MultiplicativeExpression(MultiplicativeOperator, leftValue, rightValue);
  }

  //   ParenthesizedExpression : `(` Expression `)`

  function* NamedEvaluation_ParenthesizedExpression(ParenthesizedExpression, name) {
    const {
      expression: Expression
    } = ParenthesizedExpression;
    Assert(IsAnonymousFunctionDefinition(Expression), "IsAnonymousFunctionDefinition(Expression)");
    return yield* NamedEvaluation_Expression(Expression, name);
  } // 14.1.21 #sec-function-definitions-runtime-semantics-namedevaluation
  //   FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`


  function NamedEvaluation_FunctionExpression(FunctionExpression, name) {
    const closure = Evaluate_FunctionExpression(FunctionExpression);
    Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
    return closure;
  } // 14.2.16 #sec-arrow-function-definitions-runtime-semantics-namedevaluation
  //   ArrowFunction : ArrowParameters `=>` ConciseBody


  function NamedEvaluation_ArrowFunction(ArrowFunction, name) {
    const closure = Evaluate_ArrowFunction(ArrowFunction);
    Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
    return closure;
  } // 14.4.13 #sec-generator-function-definitions-runtime-semantics-namedevaluation
  //   GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`


  function NamedEvaluation_GeneratorExpression(GeneratorExpression, name) {
    const closure = Evaluate_GeneratorExpression(GeneratorExpression);
    Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
    return closure;
  } // 14.5.13 #sec-asyncgenerator-definitions-namedevaluation
  //   AsyncGeneratorExpression :
  //     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`


  function NamedEvaluation_AsyncGeneratorExpression(AsyncGeneratorExpression, name) {
    const closure = Evaluate_AsyncGeneratorExpression(AsyncGeneratorExpression);
    Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
    return closure;
  } // 14.6.15 #sec-class-definitions-runtime-semantics-namedevaluation
  //   ClassExpression : `class` ClassTail


  function* NamedEvaluation_ClassExpression(ClassExpression, name) {
    const {
      body,
      superClass
    } = ClassExpression;
    const ClassTail = {
      ClassHeritage: superClass,
      ClassBody: body.body
    };
    let value = yield* ClassDefinitionEvaluation_ClassTail(ClassTail, Value.undefined, name);

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    value.SourceText = sourceTextMatchedBy(ClassExpression);
    return value;
  } // 14.7.13 #sec-async-function-definitions-runtime-semantics-namedevaluation
  //   AsyncFunctionExpression :
  //     `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`


  function NamedEvaluation_AsyncFunctionExpression(AsyncFunctionExpression, name) {
    const closure = Evaluate_AsyncFunctionExpression(AsyncFunctionExpression);
    Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
    return closure;
  } // 14.8.15 #sec-async-arrow-function-definitions-runtime-semantics-namedevaluation
  //   AsyncArrowFunction :
  //     `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
  //     CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody


  function NamedEvaluation_AsyncArrowFunction(AsyncArrowFunction, name) {
    const closure = Evaluate_AsyncArrowFunction(AsyncArrowFunction);
    Assert(!(SetFunctionName(closure, name) instanceof AbruptCompletion), "");
    return closure;
  } // (implicit)


  function* NamedEvaluation_Expression(Expression, name) {
    switch (true) {
      case isFunctionExpression(Expression):
        return NamedEvaluation_FunctionExpression(Expression, name);

      case isClassExpression(Expression):
        return yield* NamedEvaluation_ClassExpression(Expression, name);

      case isGeneratorExpression(Expression):
        return NamedEvaluation_GeneratorExpression(Expression, name);

      case isAsyncFunctionExpression(Expression):
        return NamedEvaluation_AsyncFunctionExpression(Expression, name);

      case isAsyncGeneratorExpression(Expression):
        return NamedEvaluation_AsyncGeneratorExpression(Expression, name);

      case isArrowFunction(Expression):
        return NamedEvaluation_ArrowFunction(Expression, name);

      case isAsyncArrowFunction(Expression):
        return NamedEvaluation_AsyncArrowFunction(Expression, name);

      case isParenthesizedExpression(Expression):
        return yield* NamedEvaluation_ParenthesizedExpression(Expression, name);

      default:
        throw new OutOfRange('NamedEvaluation_Expression', Expression);
    }
  }

  function* EvaluateNew(constructExpr, args = []) {
    Assert(isActualNewExpression(constructExpr), "isActualNewExpression(constructExpr)");
    Assert(Array.isArray(args), "Array.isArray(args)");
    const ref = yield* Evaluate(constructExpr.callee);
    let constructor = GetValue(ref);

    if (constructor instanceof AbruptCompletion) {
      return constructor;
    }

    if (constructor instanceof Completion) {
      constructor = constructor.Value;
    }

    let argList = yield* ArgumentListEvaluation(args);

    if (argList instanceof AbruptCompletion) {
      return argList;
    }

    if (argList instanceof Completion) {
      argList = argList.Value;
    }

    if (IsConstructor(constructor) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAConstructor', constructor));
    }

    return Construct(constructor, argList);
  } // 12.3.3.1 #sec-new-operator-runtime-semantics-evaluation
  //   NewExpression :
  //     `new` NewExpression
  //     `new` MemberExpression Arguments


  function* Evaluate_NewExpression(NewExpression) {
    return yield* EvaluateNew(NewExpression, NewExpression.arguments);
  }

  //   ObjectLiteral :
  //     `{` `}`
  //     `{` PropertyDefintionList `}`
  //     `{` PropertyDefintionList `,` `}`

  function* Evaluate_ObjectLiteral(ObjectLiteral) {
    if (ObjectLiteral.properties.length === 0) {
      return ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    }

    const PropertyDefintionList = ObjectLiteral.properties;
    const obj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    {
      const hygienicTemp = yield* PropertyDefinitionEvaluation_PropertyDefinitionList(PropertyDefintionList, obj, true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return obj;
  }

  // OptionalExpression :
  //   MemberExpression OptionalChain
  //   CallExpression OptionalChain
  //   OptionalExpression OptionalChain

  function* Evaluate_OptionalExpression(OptionalExpression) {
    const baseReference = yield* Evaluate(OptionalExpression.object);
    let baseValue = GetValue(baseReference);

    if (baseValue instanceof AbruptCompletion) {
      return baseValue;
    }

    if (baseValue instanceof Completion) {
      baseValue = baseValue.Value;
    }

    if (baseValue === Value.undefined || baseValue === Value.null) {
      return Value.undefined;
    }

    Assert(isOptionalChain(OptionalExpression.chain), "isOptionalChain(OptionalExpression.chain)");
    return yield* ChainEvaluation(OptionalExpression.chain, baseValue, baseReference);
  } // https://tc39.es/proposal-optional-chaining/#sec-optional-chaining-chain-evaluation
  // OptionalChain :
  //   `?.` `[` Expression `]`
  //   `?.` IdentifierName
  //   `?.` Arguments
  //   OptionalChain `[` Expression `]`
  //   OptionalChain `.` IdentifierName
  //   OptionalChain Arguments

  function* ChainEvaluation(OptionalChain, baseValue, baseReference) {
    const strict = OptionalChain.strict;

    if (isOptionalChainWithOptionalChain(OptionalChain)) {
      Assert(isOptionalChain(OptionalChain.base), "isOptionalChain(OptionalChain.base)");
      const newReference = yield* ChainEvaluation(OptionalChain.base, baseValue, baseReference);
      let newValue = GetValue(newReference);

      if (newValue instanceof AbruptCompletion) {
        return newValue;
      }

      if (newValue instanceof Completion) {
        newValue = newValue.Value;
      }

      switch (true) {
        // OptionalChain : OptionalChain `?.` `[` Expression `]`
        case isOptionalChainWithExpression(OptionalChain):
          return yield* EvaluateDynamicPropertyAccess(newValue, OptionalChain.property, strict);
        // OptionalChain : OptionalChain `?.` IdentifierName

        case isOptionalChainWithIdentifierName(OptionalChain):
          return EvaluateStaticPropertyAccess(newValue, OptionalChain.property, strict);
        // OptionalChain : OptionalChain `?.` Arguments

        case isOptionalChainWithArguments(OptionalChain):
          {
            return yield* EvaluateCall(newValue, newReference, OptionalChain.arguments);
          }

        default:
          throw new OutOfRange('ChainEvaluation', OptionalChain);
      }
    }

    switch (true) {
      // OptionalChain : `?.` `[` Expression `]`
      case isOptionalChainWithExpression(OptionalChain):
        return yield* EvaluateDynamicPropertyAccess(baseValue, OptionalChain.property, strict);
      // OptionalChain : `?.` IdentifierName

      case isOptionalChainWithIdentifierName(OptionalChain):
        return EvaluateStaticPropertyAccess(baseValue, OptionalChain.property, strict);
      // OptionalChain : `?.` Arguments

      case isOptionalChainWithArguments(OptionalChain):
        {
          return yield* EvaluateCall(baseValue, baseReference, OptionalChain.arguments);
        }

      default:
        throw new OutOfRange('ChainEvaluation', OptionalChain);
    }
  }

  //   BindingPropertyList : BindingPropertyList `,` BindingProperty
  //
  // (implicit)
  //   BindingPropertyList : BindingProperty

  function* PropertyBindingInitialization_BindingPropertyList(BindingPropertyList, value, environment) {
    const boundNames = [];

    for (const BindingProperty of BindingPropertyList) {
      let nextNames = yield* PropertyBindingInitialization_BindingProperty(BindingProperty, value, environment);

      if (nextNames instanceof AbruptCompletion) {
        return nextNames;
      }

      if (nextNames instanceof Completion) {
        nextNames = nextNames.Value;
      }

      boundNames.push(...nextNames);
    }

    return boundNames;
  } // 13.3.3.6 #sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization
  //   BindingProperty :
  //     SingleNameBinding
  //     PropertyName `:` BindingElement

  function* PropertyBindingInitialization_BindingProperty(BindingProperty, value, environment) {
    switch (true) {
      case isBindingPropertyWithSingleNameBinding(BindingProperty):
        {
          const name = new Value(BindingProperty.key.name);
          {
            const hygienicTemp = yield* KeyedBindingInitialization_SingleNameBinding(BindingProperty.value, value, environment, name);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return [name];
        }

      case isBindingPropertyWithColon(BindingProperty):
        {
          const {
            key: PropertyName,
            value: BindingElement
          } = BindingProperty;
          let P = yield* Evaluate_PropertyName(PropertyName, BindingProperty.computed);

          if (P instanceof AbruptCompletion) {
            return P;
          }

          if (P instanceof Completion) {
            P = P.Value;
          }

          {
            const hygienicTemp = yield* KeyedBindingInitialization_BindingElement(BindingElement, value, environment, P);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return [P];
        }

      default:
        throw new OutOfRange('PropertyBindingInitialization_BindingProperty', BindingProperty);
    }
  }

  function hasNonConfigurableProperties(obj) {
    for (const desc of obj.properties.values()) {
      if (desc.Configurable === Value.false) {
        return true;
      }
    }

    return false;
  } // 12.2.6.8 #sec-object-initializer-runtime-semantics-propertydefinitionevaluation
  //   PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition
  //
  // (implicit)
  //   PropertyDefinitionList : PropertyDefinition


  function* PropertyDefinitionEvaluation_PropertyDefinitionList(PropertyDefinitionList, object, enumerable) {
    Assert(PropertyDefinitionList.length > 0, "PropertyDefinitionList.length > 0");
    let lastReturn;

    for (const PropertyDefinition of PropertyDefinitionList) {
      lastReturn = yield* PropertyDefinitionEvaluation_PropertyDefinition(PropertyDefinition, object, enumerable);

      if (lastReturn instanceof AbruptCompletion) {
        return lastReturn;
      }

      if (lastReturn instanceof Completion) {
        lastReturn = lastReturn.Value;
      }
    }

    return lastReturn;
  } // 12.2.6.8 #sec-object-initializer-runtime-semantics-propertydefinitionevaluation
  //   PropertyDefinition : `...` AssignmentExpression

  function* PropertyDefinitionEvaluation_PropertyDefinition_Spread(PropertyDefinition, object) {
    const AssignmentExpression = PropertyDefinition.argument;
    const exprValue = yield* Evaluate(AssignmentExpression);
    let fromValue = GetValue(exprValue);

    if (fromValue instanceof AbruptCompletion) {
      return fromValue;
    }

    if (fromValue instanceof Completion) {
      fromValue = fromValue.Value;
    }

    const excludedNames = [];
    return CopyDataProperties(object, fromValue, excludedNames);
  } // 12.2.6.8 #sec-object-initializer-runtime-semantics-propertydefinitionevaluation
  //   PropertyDefinition : IdentifierReference


  function* PropertyDefinitionEvaluation_PropertyDefinition_IdentifierReference(PropertyDefinition, object, enumerable) {
    const IdentifierReference = PropertyDefinition.key;
    const propName = new Value(IdentifierReference.name);
    const exprValue = yield* Evaluate(IdentifierReference);
    let propValue = GetValue(exprValue);

    if (propValue instanceof AbruptCompletion) {
      return propValue;
    }

    if (propValue instanceof Completion) {
      propValue = propValue.Value;
    }

    Assert(enumerable, "enumerable");
    Assert(object.isOrdinary, "object.isOrdinary");
    Assert(object.Extensible === Value.true, "object.Extensible === Value.true");
    Assert(!hasNonConfigurableProperties(object), "!hasNonConfigurableProperties(object)");

    let _val = CreateDataPropertyOrThrow(object, propName, propValue);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    return _val;
  } // 12.2.6.8 #sec-object-initializer-runtime-semantics-propertydefinitionevaluation
  //   PropertyDefinition : PropertyName `:` AssignmentExpression


  function* PropertyDefinitionEvaluation_PropertyDefinition_KeyValue(PropertyDefinition, object, enumerable) {
    const {
      key: PropertyName,
      value: AssignmentExpression
    } = PropertyDefinition;
    let propKey = yield* Evaluate_PropertyName(PropertyName, PropertyDefinition.computed);

    if (propKey instanceof AbruptCompletion) {
      return propKey;
    }

    if (propKey instanceof Completion) {
      propKey = propKey.Value;
    }

    let propValue;

    if (IsAnonymousFunctionDefinition(AssignmentExpression)) {
      propValue = yield* NamedEvaluation_Expression(AssignmentExpression, propKey);

      if (propValue instanceof AbruptCompletion) {
        return propValue;
      }

      if (propValue instanceof Completion) {
        propValue = propValue.Value;
      } // https://github.com/tc39/ecma262/issues/1605

    } else {
      const exprValueRef = yield* Evaluate(AssignmentExpression);
      propValue = GetValue(exprValueRef);

      if (propValue instanceof AbruptCompletion) {
        return propValue;
      }

      if (propValue instanceof Completion) {
        propValue = propValue.Value;
      }
    }

    Assert(enumerable, "enumerable");
    Assert(object.isOrdinary, "object.isOrdinary");
    Assert(object.Extensible === Value.true, "object.Extensible === Value.true");
    Assert(!hasNonConfigurableProperties(object), "!hasNonConfigurableProperties(object)");

    let _val2 = CreateDataPropertyOrThrow(object, propKey, propValue);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    return _val2;
  } // 14.3.8 #sec-method-definitions-runtime-semantics-propertydefinitionevaluation
  //   MethodDefinition :
  //     PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
  //     `get` PropertyName `(` `)` `{` FunctionBody `}`
  //     `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`
  //
  // (implicit)
  //   MethodDefinition : GeneratorMethod


  function* PropertyDefinitionEvaluation_MethodDefinition(MethodDefinition, object, enumerable) {
    switch (true) {
      case isMethodDefinitionRegularFunction(MethodDefinition):
        {
          let methodDef = yield* DefineMethod(MethodDefinition, object);

          if (methodDef instanceof AbruptCompletion) {
            return methodDef;
          }

          if (methodDef instanceof Completion) {
            methodDef = methodDef.Value;
          }

          Assert(!(SetFunctionName(methodDef.Closure, methodDef.Key) instanceof AbruptCompletion), "");
          const desc = Descriptor({
            Value: methodDef.Closure,
            Writable: Value.true,
            Enumerable: enumerable ? Value.true : Value.false,
            Configurable: Value.true
          });
          return DefinePropertyOrThrow(object, methodDef.Key, desc);
        }

      case isGeneratorMethod(MethodDefinition):
        return yield* PropertyDefinitionEvaluation_GeneratorMethod(MethodDefinition, object, enumerable);

      case isAsyncMethod(MethodDefinition):
        return yield* PropertyDefinitionEvaluation_AsyncMethod(MethodDefinition, object, enumerable);

      case isAsyncGeneratorMethod(MethodDefinition):
        return yield* PropertyDefinitionEvaluation_AsyncGeneratorMethod(MethodDefinition, object, enumerable);

      case isMethodDefinitionGetter(MethodDefinition):
        {
          const PropertyName = MethodDefinition.key;
          let propKey = yield* Evaluate_PropertyName(PropertyName, MethodDefinition.computed);

          if (propKey instanceof AbruptCompletion) {
            return propKey;
          }

          if (propKey instanceof Completion) {
            propKey = propKey.Value;
          }

          const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
          const formalParameterList = [];
          const closure = FunctionCreate('Method', formalParameterList, MethodDefinition.value, scope);
          Assert(!(MakeMethod(closure, object) instanceof AbruptCompletion), "");
          Assert(!(SetFunctionName(closure, propKey, new Value('get')) instanceof AbruptCompletion), "");
          closure.SourceText = sourceTextMatchedBy(MethodDefinition);
          const desc = Descriptor({
            Get: closure,
            Enumerable: enumerable ? Value.true : Value.false,
            Configurable: Value.true
          });
          return DefinePropertyOrThrow(object, propKey, desc);
        }

      case isMethodDefinitionSetter(MethodDefinition):
        {
          const PropertyName = MethodDefinition.key;
          const PropertySetParameterList = MethodDefinition.value.params;
          let propKey = yield* Evaluate_PropertyName(PropertyName, MethodDefinition.computed);

          if (propKey instanceof AbruptCompletion) {
            return propKey;
          }

          if (propKey instanceof Completion) {
            propKey = propKey.Value;
          }

          const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
          const closure = FunctionCreate('Method', PropertySetParameterList, MethodDefinition.value, scope);
          Assert(!(MakeMethod(closure, object) instanceof AbruptCompletion), "");
          Assert(!(SetFunctionName(closure, propKey, new Value('set')) instanceof AbruptCompletion), "");
          closure.SourceText = sourceTextMatchedBy(MethodDefinition);
          const desc = Descriptor({
            Set: closure,
            Enumerable: enumerable ? Value.true : Value.false,
            Configurable: Value.true
          });
          return DefinePropertyOrThrow(object, propKey, desc);
        }

      default:
        throw new OutOfRange('PropertyDefinitionEvaluation_MethodDefinition', MethodDefinition);
    }
  } // (implicit)
  //   ClassElement :
  //     MethodDefinition
  //     `static` MethodDefinition

  const PropertyDefinitionEvaluation_ClassElement = PropertyDefinitionEvaluation_MethodDefinition; // 14.4.12 #sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation
  //   GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

  function* PropertyDefinitionEvaluation_GeneratorMethod(GeneratorMethod, object, enumerable) {
    const {
      key: PropertyName,
      value: GeneratorExpression
    } = GeneratorMethod;
    const UniqueFormalParameters = GeneratorExpression.params;
    let propKey = yield* Evaluate_PropertyName(PropertyName, GeneratorMethod.computed);

    if (propKey instanceof AbruptCompletion) {
      return propKey;
    }

    if (propKey instanceof Completion) {
      propKey = propKey.Value;
    }

    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    let closure = GeneratorFunctionCreate('Method', UniqueFormalParameters, GeneratorExpression, scope);
    Assert(!(closure instanceof AbruptCompletion), "");

    if (closure instanceof Completion) {
      closure = closure.Value;
    }

    MakeMethod(closure, object);
    const prototype = ObjectCreate(surroundingAgent.intrinsic('%GeneratorPrototype%'));
    Assert(!(DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    Assert(!(SetFunctionName(closure, propKey) instanceof AbruptCompletion), "");
    closure.SourceText = sourceTextMatchedBy(GeneratorExpression);
    const desc = Descriptor({
      Value: closure,
      Writable: Value.true,
      Enumerable: enumerable ? Value.true : Value.false,
      Configurable: Value.true
    });
    return DefinePropertyOrThrow(object, propKey, desc);
  } // AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`


  function* PropertyDefinitionEvaluation_AsyncMethod(AsyncMethod, object, enumerable) {
    const {
      key: PropertyName,
      value: AsyncExpression
    } = AsyncMethod;
    const UniqueFormalParameters = AsyncExpression.params;
    let propKey = yield* Evaluate_PropertyName(PropertyName, AsyncMethod.computed);

    if (propKey instanceof AbruptCompletion) {
      return propKey;
    }

    if (propKey instanceof Completion) {
      propKey = propKey.Value;
    }

    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    let closure = AsyncFunctionCreate('Method', UniqueFormalParameters, AsyncExpression, scope);
    Assert(!(closure instanceof AbruptCompletion), "");

    if (closure instanceof Completion) {
      closure = closure.Value;
    }

    Assert(!(MakeMethod(closure, object) instanceof AbruptCompletion), "");
    Assert(!(SetFunctionName(closure, propKey) instanceof AbruptCompletion), "");
    closure.SourceText = sourceTextMatchedBy(AsyncMethod);
    const desc = Descriptor({
      Value: closure,
      Writable: Value.true,
      Enumerable: enumerable ? Value.true : Value.false,
      Configurable: Value.true
    });
    return DefinePropertyOrThrow(object, propKey, desc);
  } // AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorFunctionBody `}`


  function* PropertyDefinitionEvaluation_AsyncGeneratorMethod(AsyncGeneratorMethod, object, enumerable) {
    const {
      key: PropertyName,
      value: AsyncGeneratorExpression
    } = AsyncGeneratorMethod;
    const UniqueFormalParameters = AsyncGeneratorExpression.params;
    let propKey = yield* Evaluate_PropertyName(PropertyName, AsyncGeneratorMethod.computed);

    if (propKey instanceof AbruptCompletion) {
      return propKey;
    }

    if (propKey instanceof Completion) {
      propKey = propKey.Value;
    }

    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    let closure = AsyncGeneratorFunctionCreate('Method', UniqueFormalParameters, AsyncGeneratorExpression, scope);
    Assert(!(closure instanceof AbruptCompletion), "");

    if (closure instanceof Completion) {
      closure = closure.Value;
    }

    Assert(!(MakeMethod(closure, object) instanceof AbruptCompletion), "");
    let prototype = ObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorPrototype%'));
    Assert(!(prototype instanceof AbruptCompletion), "");

    if (prototype instanceof Completion) {
      prototype = prototype.Value;
    }

    Assert(!(DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    Assert(!(SetFunctionName(closure, propKey) instanceof AbruptCompletion), "");
    closure.SourceText = sourceTextMatchedBy(AsyncGeneratorMethod);
    const desc = Descriptor({
      Value: closure,
      Writable: Value.true,
      Enumerable: enumerable ? Value.true : Value.false,
      Configurable: Value.true
    });
    return DefinePropertyOrThrow(object, propKey, desc);
  } // (implicit)
  //   PropertyDefinition : MethodDefinition
  //
  // Note: PropertyDefinition : CoverInitializedName is an early error.


  function* PropertyDefinitionEvaluation_PropertyDefinition(PropertyDefinition, object, enumerable) {
    switch (true) {
      case isPropertyDefinitionIdentifierReference(PropertyDefinition):
        return yield* PropertyDefinitionEvaluation_PropertyDefinition_IdentifierReference(PropertyDefinition, object, enumerable);

      case isPropertyDefinitionKeyValue(PropertyDefinition):
        return yield* PropertyDefinitionEvaluation_PropertyDefinition_KeyValue(PropertyDefinition, object, enumerable);

      case isMethodDefinition(PropertyDefinition):
        return yield* PropertyDefinitionEvaluation_MethodDefinition(PropertyDefinition, object, enumerable);

      case isPropertyDefinitionSpread(PropertyDefinition):
        return yield* PropertyDefinitionEvaluation_PropertyDefinition_Spread(PropertyDefinition, object);

      default:
        throw new OutOfRange('PropertyDefinitionEvaluation_PropertyDefinition', PropertyDefinition);
    }
  }

  //   LiteralPropertyName :
  //     IdentifierName
  //     StringLiteral
  //     NumericLiteral

  function Evaluate_LiteralPropertyName(LiteralPropertyName) {
    switch (true) {
      case isIdentifierName(LiteralPropertyName):
        return new Value(LiteralPropertyName.name);

      case isStringLiteral(LiteralPropertyName):
        return new Value(LiteralPropertyName.value);

      case isNumericLiteral(LiteralPropertyName):
        {
          const nbr = new Value(LiteralPropertyName.value);

          let _val = ToString(nbr);

          Assert(!(_val instanceof AbruptCompletion), "");

          if (_val instanceof Completion) {
            _val = _val.Value;
          }

          return _val;
        }

      default:
        throw new OutOfRange('Evaluate_LiteralPropertyName', LiteralPropertyName);
    }
  } // 12.2.6.7 #sec-object-initializer-runtime-semantics-evaluation
  //   ComputedPropertyName : `[` AssignmentExpression `]`


  function* Evaluate_ComputedPropertyName(ComputedPropertyName) {
    const AssignmentExpression = ComputedPropertyName;
    const exprValue = yield* Evaluate(AssignmentExpression);
    let propName = GetValue(exprValue);

    if (propName instanceof AbruptCompletion) {
      return propName;
    }

    if (propName instanceof Completion) {
      propName = propName.Value;
    }

    return ToPropertyKey(propName);
  } // 12.2.6.7 #sec-object-initializer-runtime-semantics-evaluation
  //   PropertyName :
  //     LiteralPropertyName
  //     ComputedPropertyName
  //
  // Note: We need some out-of-band information on whether the PropertyName is
  // computed.


  function* Evaluate_PropertyName(PropertyName, computed) {
    return computed ? yield* Evaluate_ComputedPropertyName(PropertyName) : Evaluate_LiteralPropertyName(PropertyName);
  }

  // (implicit)
  //   PrimaryExpression : RegularExpressionLiteral

  function Evaluate_RegularExpressionLiteral(RegularExpressionLiteral) {
    const pattern = new Value(RegularExpressionLiteral.regex.pattern);
    const flags = new Value(RegularExpressionLiteral.regex.flags);
    return RegExpCreate(pattern, flags);
  }

  function InstanceofOperator(V, target) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError');
    }

    let instOfHandler = GetMethod(target, wellKnownSymbols.hasInstance);

    if (instOfHandler instanceof AbruptCompletion) {
      return instOfHandler;
    }

    if (instOfHandler instanceof Completion) {
      instOfHandler = instOfHandler.Value;
    }

    if (Type(instOfHandler) !== 'Undefined') {
      let _hygienicTemp = Call(instOfHandler, target, [V]);

      if (_hygienicTemp instanceof AbruptCompletion) {
        return _hygienicTemp;
      }

      if (_hygienicTemp instanceof Completion) {
        _hygienicTemp = _hygienicTemp.Value;
      }

      return ToBoolean(_hygienicTemp);
    }

    if (IsCallable(target) === Value.false) {
      return surroundingAgent.Throw('TypeError');
    }

    return OrdinaryHasInstance(target, V);
  }
  function* Evaluate_RelationalExpression({
    left: RelationalExpression,
    right: ShiftExpression,
    operator
  }) {
    const lref = yield* Evaluate(RelationalExpression);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    const rref = yield* Evaluate(ShiftExpression);
    let rval = GetValue(rref);

    if (rval instanceof AbruptCompletion) {
      return rval;
    }

    if (rval instanceof Completion) {
      rval = rval.Value;
    }

    switch (operator) {
      case '<':
        {
          let r = AbstractRelationalComparison(lval, rval);

          if (r instanceof AbruptCompletion) {
            return r;
          }

          if (r instanceof Completion) {
            r = r.Value;
          }

          if (Type(r) === 'Undefined') {
            return Value.false;
          }

          return r;
        }

      case '>':
        {
          let r = AbstractRelationalComparison(rval, lval, false);

          if (r instanceof AbruptCompletion) {
            return r;
          }

          if (r instanceof Completion) {
            r = r.Value;
          }

          if (Type(r) === 'Undefined') {
            return Value.false;
          }

          return r;
        }

      case '<=':
        {
          let r = AbstractRelationalComparison(rval, lval, false);

          if (r instanceof AbruptCompletion) {
            return r;
          }

          if (r instanceof Completion) {
            r = r.Value;
          }

          if (Type(r) === 'Undefined' || r === Value.true) {
            return Value.false;
          }

          return Value.true;
        }

      case '>=':
        {
          let r = AbstractRelationalComparison(lval, rval);

          if (r instanceof AbruptCompletion) {
            return r;
          }

          if (r instanceof Completion) {
            r = r.Value;
          }

          if (Type(r) === 'Undefined' || r === Value.true) {
            return Value.false;
          }

          return Value.true;
        }

      case 'instanceof':
        return InstanceofOperator(lval, rval);

      case 'in':
        if (Type(rval) !== 'Object') {
          return surroundingAgent.Throw('TypeError', 'cannot check for property in non-object');
        }

        return HasProperty(rval, ToPropertyKey(lval));

      default:
        throw new OutOfRange('Evaluate_RelationalExpression', operator);
    }
  }

  //   BindingRestProperty : `...` BindingIdentifier

  function RestBindingInitialization_BindingRestProperty(BindingRestProperty, value, environment, excludedNames) {
    const BindingIdentifier = BindingRestProperty.argument;
    let lhs = ResolveBinding(new Value(BindingIdentifier.name), environment, BindingIdentifier.strict);

    if (lhs instanceof AbruptCompletion) {
      return lhs;
    }

    if (lhs instanceof Completion) {
      lhs = lhs.Value;
    }

    const restObj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    {
      const hygienicTemp = CopyDataProperties(restObj, value, excludedNames);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (Type(environment) === 'Undefined') {
      return PutValue(lhs, restObj);
    }

    return InitializeReferencedBinding(lhs, restObj);
  }

  function* Evaluate_ReturnStatement({
    argument: Expression
  }) {
    if (Expression === null) {
      // ReturnStatement : return `;`
      return new ReturnCompletion(Value.undefined);
    } else {
      // ReturnStatement : return Expression `;`
      const exprRef = yield* Evaluate(Expression);
      let exprValue = GetValue(exprRef);

      if (exprValue instanceof AbruptCompletion) {
        return exprValue;
      }

      if (exprValue instanceof Completion) {
        exprValue = exprValue.Value;
      }

      let _val = GetGeneratorKind();

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      if (_val === 'async') {
        exprValue = yield* Await(exprValue);

        if (exprValue instanceof AbruptCompletion) {
          return exprValue;
        }

        if (exprValue instanceof Completion) {
          exprValue = exprValue.Value;
        }
      }

      return new ReturnCompletion(exprValue);
    }
  }

  /* eslint-disable no-bitwise */

  function EvaluateBinopValues_ShiftExpression(operator, lval, rval) {
    switch (operator) {
      case '<<':
        {
          let lnum = ToInt32(lval);

          if (lnum instanceof AbruptCompletion) {
            return lnum;
          }

          if (lnum instanceof Completion) {
            lnum = lnum.Value;
          }

          let rnum = ToUint32(rval);

          if (rnum instanceof AbruptCompletion) {
            return rnum;
          }

          if (rnum instanceof Completion) {
            rnum = rnum.Value;
          }

          const shiftCount = rnum.numberValue() & 0x1F;
          return new Value(lnum.numberValue() << shiftCount);
        }

      case '>>':
        {
          let lnum = ToInt32(lval);

          if (lnum instanceof AbruptCompletion) {
            return lnum;
          }

          if (lnum instanceof Completion) {
            lnum = lnum.Value;
          }

          let rnum = ToUint32(rval);

          if (rnum instanceof AbruptCompletion) {
            return rnum;
          }

          if (rnum instanceof Completion) {
            rnum = rnum.Value;
          }

          const shiftCount = rnum.numberValue() & 0x1F;
          return new Value(lnum.numberValue() >> shiftCount);
        }

      case '>>>':
        {
          let lnum = ToUint32(lval);

          if (lnum instanceof AbruptCompletion) {
            return lnum;
          }

          if (lnum instanceof Completion) {
            lnum = lnum.Value;
          }

          let rnum = ToUint32(rval);

          if (rnum instanceof AbruptCompletion) {
            return rnum;
          }

          if (rnum instanceof Completion) {
            rnum = rnum.Value;
          }

          const shiftCount = rnum.numberValue() & 0x1F;
          return new Value(lnum.numberValue() >>> shiftCount);
        }

      default:
        throw new OutOfRange('EvaluateBinopValues_ShiftExpression', operator);
    }
  } // ShiftExpression :
  //   ShiftExpression << AdditiveExpression
  //   ShiftExpression >> AdditiveExpression
  //   ShiftExpression >>> AdditiveExpression

  function* Evaluate_ShiftExpression({
    left: ShiftExpression,
    operator,
    right: AdditiveExpression
  }) {
    const lref = yield* Evaluate(ShiftExpression);
    let lval = GetValue(lref);

    if (lval instanceof AbruptCompletion) {
      return lval;
    }

    if (lval instanceof Completion) {
      lval = lval.Value;
    }

    const rref = yield* Evaluate(AdditiveExpression);
    let rval = GetValue(rref);

    if (rval instanceof AbruptCompletion) {
      return rval;
    }

    if (rval instanceof Completion) {
      rval = rval.Value;
    }

    return EvaluateBinopValues_ShiftExpression(operator, lval, rval);
  }

  function StringPad(O, maxLength, fillString, placement) {
    Assert(placement === 'start' || placement === 'end', "placement === 'start' || placement === 'end'");
    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let _hygienicTemp = ToLength(maxLength);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const intMaxLength = _hygienicTemp.numberValue();

    const stringLength = S.stringValue().length;

    if (intMaxLength <= stringLength) {
      return S;
    }

    let filler;

    if (fillString === Value.undefined) {
      filler = ' ';
    } else {
      let _hygienicTemp2 = ToString(fillString);

      if (_hygienicTemp2 instanceof AbruptCompletion) {
        return _hygienicTemp2;
      }

      if (_hygienicTemp2 instanceof Completion) {
        _hygienicTemp2 = _hygienicTemp2.Value;
      }

      filler = _hygienicTemp2.stringValue();
    }

    if (filler === '') {
      return S;
    }

    const fillLen = intMaxLength - stringLength;
    const stringFiller = filler.repeat(Math.ceil(fillLen / filler.length));
    const truncatedStringFiller = stringFiller.slice(0, fillLen);

    if (placement === 'start') {
      return new Value(truncatedStringFiller + S.stringValue());
    } else {
      return new Value(S.stringValue() + truncatedStringFiller);
    }
  }

  function GetSuperConstructor() {
    const envRec = GetThisEnvironment();
    Assert(envRec instanceof FunctionEnvironmentRecord, "envRec instanceof FunctionEnvironmentRecord");
    const activeFunction = envRec.FunctionObject;
    Assert(activeFunction instanceof FunctionValue, "activeFunction instanceof FunctionValue");
    let superConstructor = activeFunction.GetPrototypeOf();
    Assert(!(superConstructor instanceof AbruptCompletion), "");

    if (superConstructor instanceof Completion) {
      superConstructor = superConstructor.Value;
    }

    if (IsConstructor(superConstructor) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAConstructor', superConstructor));
    }

    return superConstructor;
  } // 12.3.5.1 #sec-super-keyword-runtime-semantics-evaluation
  // SuperCall : `super` Arguments


  function* Evaluate_SuperCall({
    arguments: Arguments
  }) {
    const newTarget = GetNewTarget();
    Assert(Type(newTarget) === 'Object', "Type(newTarget) === 'Object'");
    let func = GetSuperConstructor();

    if (func instanceof AbruptCompletion) {
      return func;
    }

    if (func instanceof Completion) {
      func = func.Value;
    }

    let argList = yield* ArgumentListEvaluation(Arguments);

    if (argList instanceof AbruptCompletion) {
      return argList;
    }

    if (argList instanceof Completion) {
      argList = argList.Value;
    }

    let result = Construct(func, argList, newTarget);

    if (result instanceof AbruptCompletion) {
      return result;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }

    const thisER = GetThisEnvironment();
    return thisER.BindThisValue(result);
  }

  function MakeSuperPropertyReference(actualThis, propertyKey, strict) {
    const env = GetThisEnvironment();
    Assert(env.HasSuperBinding() === Value.true, "env.HasSuperBinding() === Value.true");
    let baseValue = env.GetSuperBase();

    if (baseValue instanceof AbruptCompletion) {
      return baseValue;
    }

    if (baseValue instanceof Completion) {
      baseValue = baseValue.Value;
    }

    let bv = RequireObjectCoercible(baseValue);

    if (bv instanceof AbruptCompletion) {
      return bv;
    }

    if (bv instanceof Completion) {
      bv = bv.Value;
    }

    return new SuperReference({
      BaseValue: bv,
      ReferencedName: propertyKey,
      thisValue: actualThis,
      StrictReference: strict ? Value.true : Value.false
    });
  } // 12.3.5.1 #sec-super-keyword-runtime-semantics-evaluation
  // SuperProperty :
  //   `super` `[` Expression `]`
  //   `super` `.` IdentifierName


  function* Evaluate_SuperProperty(SuperProperty) {
    if (SuperProperty.computed) {
      const Expression = SuperProperty.property;
      const env = GetThisEnvironment();
      let actualThis = env.GetThisBinding();

      if (actualThis instanceof AbruptCompletion) {
        return actualThis;
      }

      if (actualThis instanceof Completion) {
        actualThis = actualThis.Value;
      }

      const propertyNameReference = yield* Evaluate(Expression);
      let propertyNameValue = GetValue(propertyNameReference);

      if (propertyNameValue instanceof AbruptCompletion) {
        return propertyNameValue;
      }

      if (propertyNameValue instanceof Completion) {
        propertyNameValue = propertyNameValue.Value;
      }

      let propertyKey = ToPropertyKey(propertyNameValue);

      if (propertyKey instanceof AbruptCompletion) {
        return propertyKey;
      }

      if (propertyKey instanceof Completion) {
        propertyKey = propertyKey.Value;
      }

      const strict = SuperProperty.strict;
      return MakeSuperPropertyReference(actualThis, propertyKey, strict);
    } else {
      const IdentifierName = SuperProperty.property;
      const env = GetThisEnvironment();
      let actualThis = env.GetThisBinding();

      if (actualThis instanceof AbruptCompletion) {
        return actualThis;
      }

      if (actualThis instanceof Completion) {
        actualThis = actualThis.Value;
      }

      const propertyKey = new Value(IdentifierName.name);
      const strict = SuperProperty.strict;
      return MakeSuperPropertyReference(actualThis, propertyKey, strict);
    }
  }

  function* CaseClauseIsSelected(C, input) {
    // Assert: C is an instance of the production CaseClause : `case` Expression : StatementList.
    const exprRef = yield* Evaluate(C.test);
    let clauseSelector = GetValue(exprRef);

    if (clauseSelector instanceof AbruptCompletion) {
      return clauseSelector;
    }

    if (clauseSelector instanceof Completion) {
      clauseSelector = clauseSelector.Value;
    }

    return StrictEqualityComparison(input, clauseSelector);
  } // 13.12.9 #sec-runtime-semantics-caseblockevaluation
  // CaseBlock :
  //   `{` `}`
  //   `{` CaseClauses `}`
  //   `{` CaseClauses DefaultClause CaseClauses `}`


  function* CaseBlockEvaluation(CaseBlock, input) {
    if (CaseBlock.length === 0) {
      return new NormalCompletion(Value.undefined);
    }

    const defaultIndex = CaseBlock.findIndex(c => c.test === null);

    if (defaultIndex !== -1) {
      // CaseBlock : `{` CaseClauses DefaultClause CaseClauses `}`
      const firstCaseClauses = CaseBlock.slice(0, defaultIndex);
      const secondCaseClauses = CaseBlock.slice(defaultIndex + 1);
      const DefaultClause = CaseBlock[defaultIndex];
      let V = Value.undefined;
      let A;

      if (firstCaseClauses.length > 0) {
        A = firstCaseClauses;
      } else {
        A = [];
      }

      let found = false;

      for (const C of A) {
        if (found === false) {
          let _hygienicTemp = yield* CaseClauseIsSelected(C, input);

          if (_hygienicTemp instanceof AbruptCompletion) {
            return _hygienicTemp;
          }

          if (_hygienicTemp instanceof Completion) {
            _hygienicTemp = _hygienicTemp.Value;
          }

          found = _hygienicTemp === Value.true;
        }

        if (found === true) {
          const R = EnsureCompletion((yield* Evaluate_StatementList(C.consequent)));

          if (R.Value !== undefined) {
            V = R.Value;
          }

          if (R instanceof AbruptCompletion) {
            return Completion(UpdateEmpty(R, V));
          }
        }
      }

      let foundInB = false;
      let B;

      if (secondCaseClauses.length > 0) {
        B = secondCaseClauses;
      } else {
        B = [];
      }

      if (found === false) {
        for (const C of B) {
          if (foundInB === false) {
            let _hygienicTemp2 = yield* CaseClauseIsSelected(C, input);

            if (_hygienicTemp2 instanceof AbruptCompletion) {
              return _hygienicTemp2;
            }

            if (_hygienicTemp2 instanceof Completion) {
              _hygienicTemp2 = _hygienicTemp2.Value;
            }

            foundInB = _hygienicTemp2 === Value.true;
          }

          if (foundInB === true) {
            const R = EnsureCompletion((yield* Evaluate_StatementList(C.consequent)));

            if (R.Value !== undefined) {
              V = R.Value;
            }

            if (R instanceof AbruptCompletion) {
              return Completion(UpdateEmpty(R, V));
            }
          }
        }
      }

      if (foundInB === true) {
        return new NormalCompletion(V);
      }

      const R = EnsureCompletion((yield* Evaluate_StatementList(DefaultClause.consequent)));

      if (R.Value !== undefined) {
        V = R.Value;
      }

      if (R instanceof AbruptCompletion) {
        return Completion(UpdateEmpty(R, V));
      }

      for (const C of B) {
        const R = EnsureCompletion((yield* Evaluate_StatementList(C.consequent))); // eslint-disable-line no-shadow

        if (R.Value !== undefined) {
          V = R.Value;
        }

        if (R instanceof AbruptCompletion) {
          return Completion(UpdateEmpty(R, V));
        }
      }

      return new NormalCompletion(V);
    } else {
      // CaseBlock : `{` CaseClauses `}`
      let V = Value.undefined; // Let A be the List of CaseClause items in CaseClauses, in source text order.

      const A = CaseBlock;
      let found = false;

      for (const C of A) {
        if (found === false) {
          let _hygienicTemp3 = yield* CaseClauseIsSelected(C, input);

          if (_hygienicTemp3 instanceof AbruptCompletion) {
            return _hygienicTemp3;
          }

          if (_hygienicTemp3 instanceof Completion) {
            _hygienicTemp3 = _hygienicTemp3.Value;
          }

          found = _hygienicTemp3 === Value.true;
        }

        if (found === true) {
          const R = EnsureCompletion((yield* Evaluate_StatementList(C.consequent)));

          if (R.Value !== undefined) {
            V = R.Value;
          }

          if (R instanceof AbruptCompletion) {
            return Completion(UpdateEmpty(R, V));
          }
        }
      }

      return new NormalCompletion(V);
    }
  } // 13.12.11 #sec-switch-statement-runtime-semantics-evaluation
  // SwitchStatement : `switch` `(` Expression `)` CaseBlock


  function* Evaluate_SwitchStatement({
    discriminant: Expression,
    cases: CaseBlock
  }) {
    const exprRef = yield* Evaluate(Expression);
    let switchValue = GetValue(exprRef);

    if (switchValue instanceof AbruptCompletion) {
      return switchValue;
    }

    if (switchValue instanceof Completion) {
      switchValue = switchValue.Value;
    }

    const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const blockEnv = NewDeclarativeEnvironment(oldEnv);
    BlockDeclarationInstantiation(CaseBlock, blockEnv);
    surroundingAgent.runningExecutionContext.LexicalEnvironment = blockEnv;
    const R = yield* CaseBlockEvaluation(CaseBlock, switchValue);
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
    return R;
  }

  function GetTemplateObject(templateLiteral) {
    const rawStrings = TemplateStrings_TemplateLiteral(templateLiteral, true).map(Value);
    const realm = surroundingAgent.currentRealmRecord;
    const templateRegistry = realm.TemplateMap;

    for (const e of templateRegistry) {
      if (e.Site === templateLiteral) {
        return e.Array;
      }
    }

    const cookedStrings = TemplateStrings_TemplateLiteral(templateLiteral, false).map(v => v === undefined ? Value.undefined : new Value(v));
    const count = cookedStrings.length;
    Assert(count < 2 ** 32 - 1, "count < (2 ** 32) - 1");
    let template = ArrayCreate(new Value(count));
    Assert(!(template instanceof AbruptCompletion), "");

    if (template instanceof Completion) {
      template = template.Value;
    }

    let rawObj = ArrayCreate(new Value(count));
    Assert(!(rawObj instanceof AbruptCompletion), "");

    if (rawObj instanceof Completion) {
      rawObj = rawObj.Value;
    }

    let index = 0;

    while (index < count) {
      let prop = ToString(new Value(index));
      Assert(!(prop instanceof AbruptCompletion), "");

      if (prop instanceof Completion) {
        prop = prop.Value;
      }

      const cookedValue = cookedStrings[index];
      Assert(!(template.DefineOwnProperty(prop, Descriptor({
        Value: cookedValue,
        Writable: Value.false,
        Enumerable: Value.true,
        Configurable: Value.false
      })) instanceof AbruptCompletion), "");
      const rawValue = rawStrings[index];
      Assert(!(rawObj.DefineOwnProperty(prop, Descriptor({
        Value: rawValue,
        Writable: Value.false,
        Enumerable: Value.true,
        Configurable: Value.false
      })) instanceof AbruptCompletion), "");
      index += 1;
    }

    Assert(!(SetIntegrityLevel(rawObj, 'frozen') instanceof AbruptCompletion), "");
    Assert(!(template.DefineOwnProperty(new Value('raw'), Descriptor({
      Value: rawObj,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    Assert(!(SetIntegrityLevel(template, 'frozen') instanceof AbruptCompletion), "");
    templateRegistry.push({
      Site: templateLiteral,
      Array: template
    });
    return template;
  } // 12.3.8.1 #sec-tagged-templates-runtime-semantics-evaluation

  function* Evaluate_TaggedTemplate({
    tag: Expression,
    quasi: TemplateLiteral
  }) {
    const tagRef = yield* Evaluate(Expression);
    let tagFunc = GetValue(tagRef);

    if (tagFunc instanceof AbruptCompletion) {
      return tagFunc;
    }

    if (tagFunc instanceof Completion) {
      tagFunc = tagFunc.Value;
    }
    return yield* EvaluateCall(tagFunc, tagRef, TemplateLiteral);
  }

  //   TemplateLiteral : NoSubstitutionTemplate
  //   SubstitutionTemplate : TemplateHead Expression TemplateSpans
  //   TemplateSpans : TemplateTail
  //   TemplateSpans : TemplateMiddleList TemplateTail
  //   TemplateMiddleList : TemplateMiddle Expression
  //   TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
  //
  // (implicit)
  //   TemplateLiteral : SubstitutionTemplate

  function* Evaluate_TemplateLiteral(TemplateLiteral) {
    let str = '';

    for (let i = 0; i < TemplateLiteral.quasis.length - 1; i += 1) {
      const TemplateHead = TemplateLiteral.quasis[i];
      const Expression = TemplateLiteral.expressions[i];
      const head = TemplateHead.value.cooked;
      const subRef = yield* Evaluate(Expression);
      let sub = GetValue(subRef);

      if (sub instanceof AbruptCompletion) {
        return sub;
      }

      if (sub instanceof Completion) {
        sub = sub.Value;
      }

      let middle = ToString(sub);

      if (middle instanceof AbruptCompletion) {
        return middle;
      }

      if (middle instanceof Completion) {
        middle = middle.Value;
      }

      str += head;
      str += middle.stringValue();
    }

    const TemplateTail = TemplateLiteral.quasis[TemplateLiteral.quasis.length - 1];
    const tail = TemplateTail.value.cooked;
    return new Value(str + tail);
  }

  // PrimaryExpression : this

  function Evaluate_ThisExpression() {
    return ResolveThisBinding();
  }

  function* Evaluate_ThrowStatement(Expression) {
    const exprRef = yield* Evaluate(Expression);
    let exprValue = GetValue(exprRef);

    if (exprValue instanceof AbruptCompletion) {
      return exprValue;
    }

    if (exprValue instanceof Completion) {
      exprValue = exprValue.Value;
    }

    return new ThrowCompletion(exprValue);
  }

  function TrimString(string, where) {
    let str = RequireObjectCoercible(string);

    if (str instanceof AbruptCompletion) {
      return str;
    }

    if (str instanceof Completion) {
      str = str.Value;
    }

    let _hygienicTemp = ToString(str);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const S = _hygienicTemp.stringValue();

    let T;

    if (where === 'start') {
      T = S.trimStart();
    } else if (where === 'end') {
      T = S.trimEnd();
    } else {
      Assert(where === 'start+end', "where === 'start+end'");
      T = S.trim();
    }

    return new Value(T);
  }

  //    With parameter thrownValue.
  //    Catch :
  //      `catch` `(` CatchParameter `)` Block
  //      `catch` Block

  function* CatchClauseEvaluation({
    param: CatchParameter,
    body: Block
  }, thrownValue) {
    if (!CatchParameter) {
      //  Catch : `catch` Block
      return yield* Evaluate_Block(Block);
    }

    const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const catchEnv = NewDeclarativeEnvironment(oldEnv);
    const catchEnvRec = catchEnv.EnvironmentRecord;

    for (const argName of BoundNames_CatchParameter(CatchParameter)) {
      Assert(!(catchEnvRec.CreateMutableBinding(new Value(argName), false) instanceof AbruptCompletion), "");
    }

    surroundingAgent.runningExecutionContext.LexicalEnvironment = catchEnv;
    const status = yield* BindingInitialization_CatchParameter(CatchParameter, thrownValue, catchEnv);

    if (status instanceof AbruptCompletion) {
      surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
      return status;
    }

    const B = yield* Evaluate_Block(Block);
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
    return B;
  } // (implicit)
  //   Finally : `finally` Block


  const Evaluate_Finally = Evaluate_Block; // 13.15.8 #sec-try-statement-runtime-semantics-evaluation
  //   TryStatement : `try` Block Catch

  function* Evaluate_TryStatement_Catch(Block, Catch) {
    const B = EnsureCompletion((yield* Evaluate_Block(Block)));
    let C;

    if (B.Type === 'throw') {
      C = EnsureCompletion((yield* CatchClauseEvaluation(Catch, B.Value)));
    } else {
      C = B;
    }

    return Completion(UpdateEmpty(C, Value.undefined));
  } // 13.15.8 #sec-try-statement-runtime-semantics-evaluation
  //   TryStatement : `try` Block Finally


  function* Evaluate_TryStatement_Finally(Block, Finally) {
    const B = EnsureCompletion((yield* Evaluate_Block(Block)));
    let F = EnsureCompletion((yield* Evaluate_Finally(Finally)));

    if (F.Type === 'normal') {
      F = B;
    }

    return Completion(UpdateEmpty(F, Value.undefined));
  } // 13.15.8 #sec-try-statement-runtime-semantics-evaluation
  //   TryStatement : `try` Block Catch Finally


  function* Evaluate_TryStatement_CatchFinally(Block, Catch, Finally) {
    const B = EnsureCompletion((yield* Evaluate_Block(Block)));
    let C;

    if (B.Type === 'throw') {
      C = EnsureCompletion((yield* CatchClauseEvaluation(Catch, B.Value)));
    } else {
      C = B;
    }

    let F = EnsureCompletion((yield* Evaluate_Finally(Finally)));

    if (F.Type === 'normal') {
      F = C;
    }

    return Completion(UpdateEmpty(F, Value.undefined));
  } // 13.15.8 #sec-try-statement-runtime-semantics-evaluation


  function* Evaluate_TryStatement(Expression) {
    switch (true) {
      case isTryStatementWithCatch(Expression) && isTryStatementWithFinally(Expression):
        return yield* Evaluate_TryStatement_CatchFinally(Expression.block, Expression.handler, Expression.finalizer);

      case isTryStatementWithCatch(Expression):
        return yield* Evaluate_TryStatement_Catch(Expression.block, Expression.handler);

      case isTryStatementWithFinally(Expression):
        return yield* Evaluate_TryStatement_Finally(Expression.block, Expression.finalizer);

      default:
        throw new OutOfRange('Evaluate_TryStatement', Expression);
    }
  }

  // UnaryExpression : `delete` UnaryExpression

  function* Evaluate_UnaryExpression_Delete(UnaryExpression) {
    let ref = yield* Evaluate(UnaryExpression);

    if (ref instanceof AbruptCompletion) {
      return ref;
    }

    if (ref instanceof Completion) {
      ref = ref.Value;
    }

    if (Type(ref) !== 'Reference') {
      return Value.true;
    }

    if (IsUnresolvableReference(ref) === Value.true) {
      Assert(IsStrictReference(ref) === Value.false, "IsStrictReference(ref) === Value.false");
      return Value.true;
    }

    if (IsPropertyReference(ref) === Value.true) {
      if (IsSuperReference(ref) === Value.true) {
        return surroundingAgent.Throw('ReferenceError');
      }

      let baseObj = ToObject(GetBase(ref));
      Assert(!(baseObj instanceof AbruptCompletion), "");

      if (baseObj instanceof Completion) {
        baseObj = baseObj.Value;
      }

      let deleteStatus = baseObj.Delete(GetReferencedName(ref));

      if (deleteStatus instanceof AbruptCompletion) {
        return deleteStatus;
      }

      if (deleteStatus instanceof Completion) {
        deleteStatus = deleteStatus.Value;
      }

      if (deleteStatus === Value.false && IsStrictReference(ref) === Value.true) {
        return surroundingAgent.Throw('TypeError', msg('StrictModeDelete', GetReferencedName(ref)));
      }

      return deleteStatus;
    } else {
      const bindings = GetBase(ref);
      return bindings.DeleteBinding(GetReferencedName(ref));
    }
  } // 12.5.4.1 #sec-void-operator-runtime-semantics-evaluation
  // UnaryExpression : `void` UnaryExpression


  function* Evaluate_UnaryExpression_Void(UnaryExpression) {
    const expr = yield* Evaluate(UnaryExpression);
    {
      const hygienicTemp = GetValue(expr);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return Value.undefined;
  } // 12.5.5.1 #sec-typeof-operator-runtime-semantics-evaluation
  // UnaryExpression : `typeof` UnaryExpression


  function* Evaluate_UnaryExpression_Typeof(UnaryExpression) {
    let val = yield* Evaluate(UnaryExpression);

    if (Type(val) === 'Reference') {
      if (IsUnresolvableReference(val) === Value.true) {
        return new Value('undefined');
      }
    }

    val = GetValue(val);

    if (val instanceof AbruptCompletion) {
      return val;
    }

    if (val instanceof Completion) {
      val = val.Value;
    } // Return a String according to Table 35.


    const type = Type(val);

    switch (type) {
      case 'Undefined':
        return new Value('undefined');

      case 'Null':
        return new Value('object');

      case 'Boolean':
        return new Value('boolean');

      case 'Number':
        return new Value('number');

      case 'String':
        return new Value('string');

      case 'Symbol':
        return new Value('symbol');

      case 'Object':
        if (IsCallable(val) === Value.true) {
          return new Value('function');
        }

        return new Value('object');

      default:
        throw new OutOfRange('Evaluate_UnaryExpression_Typeof', type);
    }
  } // 12.5.6.1 #sec-unary-plus-operator-runtime-semantics-evaluation
  // UnaryExpression : `+` UnaryExpression


  function* Evaluate_UnaryExpression_Plus(UnaryExpression) {
    const expr = yield* Evaluate(UnaryExpression);
    let exprVal = GetValue(expr);

    if (exprVal instanceof AbruptCompletion) {
      return exprVal;
    }

    if (exprVal instanceof Completion) {
      exprVal = exprVal.Value;
    }

    return ToNumber(exprVal);
  } // 12.5.7.1 #sec-unary-minus-operator-runtime-semantics-evaluation
  // UnaryExpression : `-` UnaryExpression


  function* Evaluate_UnaryExpression_Minus(UnaryExpression) {
    const expr = yield* Evaluate(UnaryExpression);
    let exprVal = GetValue(expr);

    if (exprVal instanceof AbruptCompletion) {
      return exprVal;
    }

    if (exprVal instanceof Completion) {
      exprVal = exprVal.Value;
    }

    let oldValue = ToNumber(exprVal);

    if (oldValue instanceof AbruptCompletion) {
      return oldValue;
    }

    if (oldValue instanceof Completion) {
      oldValue = oldValue.Value;
    }

    if (oldValue.isNaN()) {
      return new Value(NaN);
    }

    return new Value(-oldValue.numberValue());
  } // 12.5.8.1 #sec-bitwise-not-operator-runtime-semantics-evaluation
  // UnaryExpression : `~` UnaryExpression


  function* Evaluate_UnaryExpression_Tilde(UnaryExpression) {
    const expr = yield* Evaluate(UnaryExpression);
    let exprVal = GetValue(expr);

    if (exprVal instanceof AbruptCompletion) {
      return exprVal;
    }

    if (exprVal instanceof Completion) {
      exprVal = exprVal.Value;
    }

    let oldValue = ToInt32(exprVal);

    if (oldValue instanceof AbruptCompletion) {
      return oldValue;
    }

    if (oldValue instanceof Completion) {
      oldValue = oldValue.Value;
    }

    return new Value(~oldValue.numberValue()); // eslint-disable-line no-bitwise
  } // 12.5.9.1 #sec-logical-not-operator-runtime-semantics-evaluation
  // UnaryExpression : `!` UnaryExpression


  function* Evaluate_UnaryExpression_Bang(UnaryExpression) {
    const expr = yield* Evaluate(UnaryExpression);

    let _hygienicTemp = GetValue(expr);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const oldValue = ToBoolean(_hygienicTemp);

    if (oldValue === Value.true) {
      return Value.false;
    }

    return Value.true;
  }

  function* Evaluate_UnaryExpression(UnaryExpression) {
    switch (true) {
      case isUnaryExpressionWithDelete(UnaryExpression):
        return yield* Evaluate_UnaryExpression_Delete(UnaryExpression.argument);

      case isUnaryExpressionWithVoid(UnaryExpression):
        return yield* Evaluate_UnaryExpression_Void(UnaryExpression.argument);

      case isUnaryExpressionWithTypeof(UnaryExpression):
        return yield* Evaluate_UnaryExpression_Typeof(UnaryExpression.argument);

      case isUnaryExpressionWithPlus(UnaryExpression):
        return yield* Evaluate_UnaryExpression_Plus(UnaryExpression.argument);

      case isUnaryExpressionWithMinus(UnaryExpression):
        return yield* Evaluate_UnaryExpression_Minus(UnaryExpression.argument);

      case isUnaryExpressionWithTilde(UnaryExpression):
        return yield* Evaluate_UnaryExpression_Tilde(UnaryExpression.argument);

      case isUnaryExpressionWithBang(UnaryExpression):
        return yield* Evaluate_UnaryExpression_Bang(UnaryExpression.argument);

      default:
        throw new OutOfRange('Evaluate_UnaryExpression', UnaryExpression);
    }
  }

  function* Evaluate_UpdateExpression({
    operator,
    prefix,
    argument
  }) {
    switch (true) {
      // UpdateExpression : LeftHandSideExpression `++`
      case operator === '++' && !prefix:
        {
          const LeftHandSideExpression = argument;
          const lhs = yield* Evaluate(LeftHandSideExpression);
          let lhsValue = GetValue(lhs);

          if (lhsValue instanceof AbruptCompletion) {
            return lhsValue;
          }

          if (lhsValue instanceof Completion) {
            lhsValue = lhsValue.Value;
          }

          let oldValue = ToNumber(lhsValue);

          if (oldValue instanceof AbruptCompletion) {
            return oldValue;
          }

          if (oldValue instanceof Completion) {
            oldValue = oldValue.Value;
          }

          const newValue = EvaluateBinopValues_AdditiveExpression_Plus(oldValue, new Value(1));
          {
            const hygienicTemp = PutValue(lhs, newValue);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return oldValue;
        }
      // UpdateExpression : LeftHandSideExpression `--`

      case operator === '--' && !prefix:
        {
          const LeftHandSideExpression = argument;
          const lhs = yield* Evaluate(LeftHandSideExpression);
          let lhsVal = GetValue(lhs);

          if (lhsVal instanceof AbruptCompletion) {
            return lhsVal;
          }

          if (lhsVal instanceof Completion) {
            lhsVal = lhsVal.Value;
          }

          let oldValue = ToNumber(lhsVal);

          if (oldValue instanceof AbruptCompletion) {
            return oldValue;
          }

          if (oldValue instanceof Completion) {
            oldValue = oldValue.Value;
          }

          const newValue = EvaluateBinopValues_AdditiveExpression_Minus(oldValue, new Value(1));
          {
            const hygienicTemp = PutValue(lhs, newValue);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return oldValue;
        }
      // UpdateExpression : `++` UnaryExpression

      case operator === '++' && prefix:
        {
          const UnaryExpression = argument;
          const expr = yield* Evaluate(UnaryExpression);
          let exprVal = GetValue(expr);

          if (exprVal instanceof AbruptCompletion) {
            return exprVal;
          }

          if (exprVal instanceof Completion) {
            exprVal = exprVal.Value;
          }

          let oldValue = ToNumber(exprVal);

          if (oldValue instanceof AbruptCompletion) {
            return oldValue;
          }

          if (oldValue instanceof Completion) {
            oldValue = oldValue.Value;
          }

          const newValue = EvaluateBinopValues_AdditiveExpression_Plus(oldValue, new Value(1));
          {
            const hygienicTemp = PutValue(expr, newValue);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return newValue;
        }
      // UpdateExpression : `--` UnaryExpression

      case operator === '--' && prefix:
        {
          const UnaryExpression = argument;
          const expr = yield* Evaluate(UnaryExpression);
          let exprVal = GetValue(expr);

          if (exprVal instanceof AbruptCompletion) {
            return exprVal;
          }

          if (exprVal instanceof Completion) {
            exprVal = exprVal.Value;
          }

          let oldValue = ToNumber(exprVal);

          if (oldValue instanceof AbruptCompletion) {
            return oldValue;
          }

          if (oldValue instanceof Completion) {
            oldValue = oldValue.Value;
          }

          const newValue = EvaluateBinopValues_AdditiveExpression_Minus(oldValue, new Value(1));
          {
            const hygienicTemp = PutValue(expr, newValue);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return newValue;
        }

      default:
        throw new OutOfRange('Evaluate_UpdateExpression', operator, prefix);
    }
  }

  //   VariableDeclaration :
  //     BindingIdentifier
  //     BindingIdentifier Initializer
  //     BindingPattern Initializer

  function* Evaluate_VariableDeclaration(VariableDeclaration) {
    switch (true) {
      case isBindingIdentifier(VariableDeclaration.id) && VariableDeclaration.init === null:
        return new NormalCompletion(undefined);

      case isBindingIdentifier(VariableDeclaration.id) && VariableDeclaration.init !== null:
        {
          const {
            id: BindingIdentifier,
            init: Initializer
          } = VariableDeclaration;
          const bindingId = new Value(BindingIdentifier.name);
          let lhs = ResolveBinding(bindingId, undefined, BindingIdentifier.strict);

          if (lhs instanceof AbruptCompletion) {
            return lhs;
          }

          if (lhs instanceof Completion) {
            lhs = lhs.Value;
          }

          let value;

          if (IsAnonymousFunctionDefinition(Initializer)) {
            value = yield* NamedEvaluation_Expression(Initializer, bindingId);
          } else {
            const rhs = yield* Evaluate(Initializer);
            value = GetValue(rhs);

            if (value instanceof AbruptCompletion) {
              return value;
            }

            if (value instanceof Completion) {
              value = value.Value;
            }
          }

          return PutValue(lhs, value);
        }

      case isBindingPattern(VariableDeclaration.id) && VariableDeclaration.init !== null:
        {
          const {
            id: BindingPattern,
            init: Initializer
          } = VariableDeclaration;
          const rhs = yield* Evaluate(Initializer);
          let rval = GetValue(rhs);

          if (rval instanceof AbruptCompletion) {
            return rval;
          }

          if (rval instanceof Completion) {
            rval = rval.Value;
          }

          return yield* BindingInitialization_BindingPattern(BindingPattern, rval, Value.undefined);
        }

      default:
        throw new OutOfRange('Evaluate_VariableDeclaration', VariableDeclaration);
    }
  } // 13.3.2.4 #sec-variable-statement-runtime-semantics-evaluation
  //   VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration
  //
  // (implicit)
  //   VariableDeclarationList : VariableDeclaration

  function* Evaluate_VariableDeclarationList(VariableDeclarationList) {
    let next;

    for (const VariableDeclaration of VariableDeclarationList) {
      next = yield* Evaluate_VariableDeclaration(VariableDeclaration);

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }
    }

    return next;
  } // 13.3.2.4 #sec-variable-statement-runtime-semantics-evaluation
  //   VariableStatement : `var` VariableDeclarationList `;`

  function* Evaluate_VariableStatement(VariableStatement) {
    let next = yield* Evaluate_VariableDeclarationList(VariableStatement.declarations);

    if (next instanceof AbruptCompletion) {
      return next;
    }

    if (next instanceof Completion) {
      next = next.Value;
    }

    return new NormalCompletion(undefined);
  }

  // WithStatement : `with` `(` Expression `)` Statement

  function* Evaluate_WithStatement({
    object: Expression,
    body: Statement
  }) {
    const val = yield* Evaluate(Expression);
    let actualVal = GetValue(val);

    if (actualVal instanceof AbruptCompletion) {
      return actualVal;
    }

    if (actualVal instanceof Completion) {
      actualVal = actualVal.Value;
    }

    let obj = ToObject(actualVal);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const newEnv = NewObjectEnvironment(obj, oldEnv);
    newEnv.EnvironmentRecord.withEnvironment = true;
    surroundingAgent.runningExecutionContext.LexicalEnvironment = newEnv;
    const C = EnsureCompletion((yield* Evaluate(Statement)));
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
    return Completion(UpdateEmpty(C, Value.undefined));
  }

  //   YieldExpression :
  //     `yield`
  //     `yield` AssignmentExpression

  function* Evaluate_YieldExpression_WithoutStar(YieldExpression) {
    let generatorKind = GetGeneratorKind();
    Assert(!(generatorKind instanceof AbruptCompletion), "");

    if (generatorKind instanceof Completion) {
      generatorKind = generatorKind.Value;
    }

    let value = Value.undefined;

    if (YieldExpression.argument) {
      const AssignmentExpression = YieldExpression.argument;
      const exprRef = yield* Evaluate(AssignmentExpression);
      value = GetValue(exprRef);

      if (value instanceof AbruptCompletion) {
        return value;
      }

      if (value instanceof Completion) {
        value = value.Value;
      }
    }

    if (generatorKind === 'async') {
      return yield* AsyncGeneratorYield(value);
    }

    Assert(generatorKind === 'sync', "generatorKind === 'sync'");
    return yield* GeneratorYield(CreateIterResultObject(value, Value.false));
  } // 14.4.14 #sec-generator-function-definitions-runtime-semantics-evaluation
  //   YieldExpression :
  //     `yield` `*` AssignmentExpression


  function* Evaluate_YieldExpression_Star({
    argument: AssignmentExpression
  }) {
    let generatorKind = GetGeneratorKind();
    Assert(!(generatorKind instanceof AbruptCompletion), "");

    if (generatorKind instanceof Completion) {
      generatorKind = generatorKind.Value;
    }

    const exprRef = yield* Evaluate(AssignmentExpression);
    let value = GetValue(exprRef);

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    let iteratorRecord = GetIterator(value, generatorKind);

    if (iteratorRecord instanceof AbruptCompletion) {
      return iteratorRecord;
    }

    if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    const iterator = iteratorRecord.Iterator;
    let received = new NormalCompletion(Value.undefined);

    while (true) {
      if (received.Type === 'normal') {
        let innerResult = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, [received.Value]);

        if (innerResult instanceof AbruptCompletion) {
          return innerResult;
        }

        if (innerResult instanceof Completion) {
          innerResult = innerResult.Value;
        }

        if (generatorKind === 'async') {
          innerResult = yield* Await(innerResult);

          if (innerResult instanceof AbruptCompletion) {
            return innerResult;
          }

          if (innerResult instanceof Completion) {
            innerResult = innerResult.Value;
          }
        }

        if (Type(innerResult) !== 'Object') {
          return surroundingAgent.Throw('TypeError');
        }

        let done = IteratorComplete(innerResult);

        if (done instanceof AbruptCompletion) {
          return done;
        }

        if (done instanceof Completion) {
          done = done.Value;
        }

        if (done === Value.true) {
          return IteratorValue(innerResult);
        }

        if (generatorKind === 'async') {
          let _hygienicTemp = IteratorValue(innerResult);

          if (_hygienicTemp instanceof AbruptCompletion) {
            return _hygienicTemp;
          }

          if (_hygienicTemp instanceof Completion) {
            _hygienicTemp = _hygienicTemp.Value;
          }

          received = EnsureCompletion((yield* AsyncGeneratorYield(_hygienicTemp)));
        } else {
          received = EnsureCompletion((yield* GeneratorYield(innerResult)));
        }
      } else if (received.Type === 'throw') {
        let thr = GetMethod(iterator, new Value('throw'));

        if (thr instanceof AbruptCompletion) {
          return thr;
        }

        if (thr instanceof Completion) {
          thr = thr.Value;
        }

        if (Type(thr) !== 'Undefined') {
          let innerResult = Call(thr, iterator, [received.Value]);

          if (innerResult instanceof AbruptCompletion) {
            return innerResult;
          }

          if (innerResult instanceof Completion) {
            innerResult = innerResult.Value;
          }

          if (generatorKind === 'async') {
            innerResult = yield* Await(innerResult);

            if (innerResult instanceof AbruptCompletion) {
              return innerResult;
            }

            if (innerResult instanceof Completion) {
              innerResult = innerResult.Value;
            }
          }

          if (Type(innerResult) !== 'Object') {
            return surroundingAgent.Throw('TypeError');
          }

          let done = IteratorComplete(innerResult);

          if (done instanceof AbruptCompletion) {
            return done;
          }

          if (done instanceof Completion) {
            done = done.Value;
          }

          if (done === Value.true) {
            return IteratorValue(innerResult);
          }

          if (generatorKind === 'async') {
            let _hygienicTemp2 = IteratorValue(innerResult);

            if (_hygienicTemp2 instanceof AbruptCompletion) {
              return _hygienicTemp2;
            }

            if (_hygienicTemp2 instanceof Completion) {
              _hygienicTemp2 = _hygienicTemp2.Value;
            }

            received = EnsureCompletion((yield* AsyncGeneratorYield(_hygienicTemp2)));
          } else {
            received = EnsureCompletion((yield* GeneratorYield(innerResult)));
          }
        } else {
          const closeCompletion = new NormalCompletion(undefined);

          if (generatorKind === 'async') {
            {
              const hygienicTemp = yield* AsyncIteratorClose(iteratorRecord, closeCompletion);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          } else {
            {
              const hygienicTemp = IteratorClose(iteratorRecord, closeCompletion);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          }

          return surroundingAgent.Throw('TypeError');
        }
      } else {
        Assert(received.Type === 'return', "received.Type === 'return'");
        let ret = GetMethod(iterator, new Value('return'));

        if (ret instanceof AbruptCompletion) {
          return ret;
        }

        if (ret instanceof Completion) {
          ret = ret.Value;
        }

        if (Type(ret) === 'Undefined') {
          if (generatorKind === 'async') {
            let _hygienicTemp3 = yield* Await(received.Value);

            if (_hygienicTemp3 instanceof AbruptCompletion) {
              return _hygienicTemp3;
            }

            if (_hygienicTemp3 instanceof Completion) {
              _hygienicTemp3 = _hygienicTemp3.Value;
            }

            received.Value = _hygienicTemp3;
          }

          return Completion(received);
        }

        let innerReturnResult = Call(ret, iterator, [received.Value]);

        if (innerReturnResult instanceof AbruptCompletion) {
          return innerReturnResult;
        }

        if (innerReturnResult instanceof Completion) {
          innerReturnResult = innerReturnResult.Value;
        }

        if (generatorKind === 'async') {
          innerReturnResult = yield* Await(innerReturnResult);

          if (innerReturnResult instanceof AbruptCompletion) {
            return innerReturnResult;
          }

          if (innerReturnResult instanceof Completion) {
            innerReturnResult = innerReturnResult.Value;
          }
        }

        if (Type(innerReturnResult) !== 'Object') {
          return surroundingAgent.Throw('TypeError');
        }

        let done = IteratorComplete(innerReturnResult);

        if (done instanceof AbruptCompletion) {
          return done;
        }

        if (done instanceof Completion) {
          done = done.Value;
        }

        if (done === Value.true) {
          let innerValue = IteratorValue(innerReturnResult);

          if (innerValue instanceof AbruptCompletion) {
            return innerValue;
          }

          if (innerValue instanceof Completion) {
            innerValue = innerValue.Value;
          }

          return new ReturnCompletion(innerValue);
        }

        if (generatorKind === 'async') {
          let _hygienicTemp4 = IteratorValue(innerReturnResult);

          if (_hygienicTemp4 instanceof AbruptCompletion) {
            return _hygienicTemp4;
          }

          if (_hygienicTemp4 instanceof Completion) {
            _hygienicTemp4 = _hygienicTemp4.Value;
          }

          received = EnsureCompletion((yield* AsyncGeneratorYield(_hygienicTemp4)));
        } else {
          received = EnsureCompletion((yield* GeneratorYield(innerReturnResult)));
        }
      }
    }
  }

  function* Evaluate_YieldExpression(YieldExpression) {
    if (isYieldExpressionWithStar(YieldExpression)) {
      return yield* Evaluate_YieldExpression_Star(YieldExpression);
    }

    return yield* Evaluate_YieldExpression_WithoutStar(YieldExpression);
  }

  // 25.7 #sec-async-function-objects
  // 25.7.5.1 #sec-async-functions-abstract-operations-async-function-start

  function AsyncFunctionStart(promiseCapability, asyncFunctionBody) {
    const runningContext = surroundingAgent.runningExecutionContext;
    const asyncContext = runningContext.copy();

    asyncContext.codeEvaluationState = function* resumer() {
      const evaluator = isExpressionBody(asyncFunctionBody) ? Evaluate_ExpressionBody : Evaluate_FunctionBody;
      const result = EnsureCompletion((yield* evaluator(asyncFunctionBody))); // Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.

      surroundingAgent.executionContextStack.pop(asyncContext);

      if (result.Type === 'normal') {
        Assert(!(Call(promiseCapability.Resolve, Value.undefined, [Value.undefined]) instanceof AbruptCompletion), "");
      } else if (result.Type === 'return') {
        Assert(!(Call(promiseCapability.Resolve, Value.undefined, [result.Value]) instanceof AbruptCompletion), "");
      } else {
        Assert(result.Type === 'throw', "result.Type === 'throw'");
        Assert(!(Call(promiseCapability.Reject, Value.undefined, [result.Value]) instanceof AbruptCompletion), "");
      }

      return Value.undefined;
    }();

    surroundingAgent.executionContextStack.push(asyncContext);
    const result = EnsureCompletion(resume(asyncContext, undefined));
    Assert(surroundingAgent.runningExecutionContext === runningContext, "surroundingAgent.runningExecutionContext === runningContext");
    Assert(result.Type === 'normal' && result.Value === Value.undefined, "result.Type === 'normal' && result.Value === Value.undefined");
    return Value.undefined;
  }

  // 25.5 #sec-asyncgenerator-objects
  // 25.5.3.1 #sec-asyncgeneratorrequest-records

  class AsyncGeneratorRequestRecord {
    constructor(completion, promiseCapability) {
      this.Completion = completion;
      this.Capability = promiseCapability;
    }

  } // 25.5.3.2 #sec-asyncgeneratorstart


  function AsyncGeneratorStart(generator, generatorBody) {
    // Assert: generator is an AsyncGenerator instance.
    Assert(generator.AsyncGeneratorState === Value.undefined, "generator.AsyncGeneratorState === Value.undefined");
    const genContext = surroundingAgent.runningExecutionContext;
    genContext.Generator = generator;

    genContext.codeEvaluationState = function* resumer() {
      const result = EnsureCompletion((yield* Evaluate_FunctionBody(generatorBody))); // Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.

      surroundingAgent.executionContextStack.pop(genContext);
      generator.AsyncGeneratorState = 'completed';
      let resultValue;

      if (result instanceof NormalCompletion) {
        resultValue = Value.undefined;
      } else {
        resultValue = result.Value;

        if (result.Type !== 'return') {
          let _val = AsyncGeneratorReject(generator, resultValue);

          Assert(!(_val instanceof AbruptCompletion), "");

          if (_val instanceof Completion) {
            _val = _val.Value;
          }

          return _val;
        }
      }

      let _val2 = AsyncGeneratorResolve(generator, resultValue, Value.true);

      Assert(!(_val2 instanceof AbruptCompletion), "");

      if (_val2 instanceof Completion) {
        _val2 = _val2.Value;
      }

      return _val2;
    }();

    generator.AsyncGeneratorContext = genContext;
    generator.AsyncGeneratorState = 'suspendedStart';
    generator.AsyncGeneratorQueue = [];
    return Value.undefined;
  } // 25.5.3.3 #sec-asyncgeneratorresolve

  function AsyncGeneratorResolve(generator, value, done) {
    // Assert: generator is an AsyncGenerator instance.
    const queue = generator.AsyncGeneratorQueue;
    Assert(queue.length > 0, "queue.length > 0");
    const next = queue.shift();
    const promiseCapability = next.Capability;
    let iteratorResult = CreateIterResultObject(value, done);
    Assert(!(iteratorResult instanceof AbruptCompletion), "");

    if (iteratorResult instanceof Completion) {
      iteratorResult = iteratorResult.Value;
    }

    Assert(!(Call(promiseCapability.Resolve, Value.undefined, [iteratorResult]) instanceof AbruptCompletion), "");
    Assert(!(AsyncGeneratorResumeNext(generator) instanceof AbruptCompletion), "");
    return Value.undefined;
  } // 25.5.3.4 #sec-asyncgeneratorreject


  function AsyncGeneratorReject(generator, exception) {
    // Assert: generator is an AsyncGenerator instance.
    const queue = generator.AsyncGeneratorQueue;
    Assert(queue.length > 0, "queue.length > 0");
    const next = queue.shift();
    const promiseCapability = next.Capability;
    Assert(!(Call(promiseCapability.Reject, Value.undefined, [exception]) instanceof AbruptCompletion), "");
    Assert(!(AsyncGeneratorResumeNext(generator) instanceof AbruptCompletion), "");
    return Value.undefined;
  } // 25.5.3.5.1 #async-generator-resume-next-return-processor-fulfilled


  function AsyncGeneratorResumeNextReturnProcessorFulfilledFunctions([value = Value.undefined]) {
    const F = surroundingAgent.activeFunctionObject;
    F.Generator.AsyncGeneratorState = 'completed';

    let _val3 = AsyncGeneratorResolve(F.Generator, value, Value.true);

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    return _val3;
  } // 25.5.3.5.2 #async-generator-resume-next-return-processor-rejected


  function AsyncGeneratorResumeNextReturnProcessorRejectedFunctions([reason = Value.undefined]) {
    const F = surroundingAgent.activeFunctionObject;
    F.Generator.AsyncGeneratorState = 'completed';

    let _val4 = AsyncGeneratorReject(F.Generator, reason);

    Assert(!(_val4 instanceof AbruptCompletion), "");

    if (_val4 instanceof Completion) {
      _val4 = _val4.Value;
    }

    return _val4;
  } // 25.5.3.5 #sec-asyncgeneratorresumenext


  function AsyncGeneratorResumeNext(generator) {
    // Assert: generator is an AsyncGenerator instance.
    let state = generator.AsyncGeneratorState;
    Assert(state !== 'executing', "state !== 'executing'");

    if (state === 'awaiting-return') {
      return Value.undefined;
    }

    const queue = generator.AsyncGeneratorQueue;

    if (queue.length === 0) {
      return Value.undefined;
    }

    const next = queue[0];
    Assert(next instanceof AsyncGeneratorRequestRecord, "next instanceof AsyncGeneratorRequestRecord");
    const completion = next.Completion;

    if (completion instanceof AbruptCompletion) {
      if (state === 'suspendedStart') {
        generator.AsyncGeneratorState = 'completed';
        state = 'completed';
      }

      if (state === 'completed') {
        if (completion.Type === 'return') {
          generator.AsyncGeneratorState = 'awaiting-return';
          let promise = PromiseResolve(surroundingAgent.intrinsic('%Promise%'), completion.Value);

          if (promise instanceof AbruptCompletion) {
            return promise;
          }

          if (promise instanceof Completion) {
            promise = promise.Value;
          }

          const stepsFulfilled = AsyncGeneratorResumeNextReturnProcessorFulfilledFunctions;
          let onFulfilled = CreateBuiltinFunction(stepsFulfilled, ['Generator']);
          Assert(!(onFulfilled instanceof AbruptCompletion), "");

          if (onFulfilled instanceof Completion) {
            onFulfilled = onFulfilled.Value;
          }

          onFulfilled.Generator = generator;
          const stepsRejected = AsyncGeneratorResumeNextReturnProcessorRejectedFunctions;
          let onRejected = CreateBuiltinFunction(stepsRejected, ['Generator']);
          Assert(!(onRejected instanceof AbruptCompletion), "");

          if (onRejected instanceof Completion) {
            onRejected = onRejected.Value;
          }

          onRejected.Generator = generator;
          Assert(!(PerformPromiseThen(promise, onFulfilled, onRejected) instanceof AbruptCompletion), "");
          return Value.undefined;
        } else {
          Assert(completion.Type === 'throw', "completion.Type === 'throw'");
          Assert(!(AsyncGeneratorReject(generator, completion.Value) instanceof AbruptCompletion), "");
          return Value.undefined;
        }
      }
    } else if (state === 'completed') {
      let _val5 = AsyncGeneratorResolve(generator, Value.undefined, Value.true);

      Assert(!(_val5 instanceof AbruptCompletion), "");

      if (_val5 instanceof Completion) {
        _val5 = _val5.Value;
      }

      return _val5;
    }

    Assert(state === 'suspendedStart' || state === 'suspendedYield', "state === 'suspendedStart' || state === 'suspendedYield'");
    const genContext = generator.AsyncGeneratorContext;
    const callerContext = surroundingAgent.runningExecutionContext; // Suspend callerContext

    generator.AsyncGeneratorState = 'executing';
    surroundingAgent.executionContextStack.push(genContext);
    const result = resume(genContext, completion);
    Assert(!(result instanceof AbruptCompletion), "!(result instanceof AbruptCompletion)");
    Assert(surroundingAgent.runningExecutionContext === callerContext, "surroundingAgent.runningExecutionContext === callerContext");
    return Value.undefined;
  } // 25.5.3.6 #sec-asyncgeneratorenqueue


  function AsyncGeneratorEnqueue(generator, completion) {
    Assert(completion instanceof Completion, "completion instanceof Completion");
    let promiseCapability = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    Assert(!(promiseCapability instanceof AbruptCompletion), "");

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    if (Type(generator) !== 'Object' || !('AsyncGeneratorState' in generator)) {
      const badGeneratorError = surroundingAgent.Throw('TypeError', msg('NotAnTypeObject', 'AsyncGenerator', generator)).Value;
      Assert(!(Call(promiseCapability.Reject, Value.undefined, [badGeneratorError]) instanceof AbruptCompletion), "");
      return promiseCapability.Promise;
    }

    const queue = generator.AsyncGeneratorQueue;
    const request = new AsyncGeneratorRequestRecord(completion, promiseCapability);
    queue.push(request);
    const state = generator.AsyncGeneratorState;

    if (state !== 'executing') {
      Assert(!(AsyncGeneratorResumeNext(generator) instanceof AbruptCompletion), "");
    }

    return promiseCapability.Promise;
  } // 25.5.3.7 #sec-asyncgeneratoryield

  function* AsyncGeneratorYield(value) {
    const genContext = surroundingAgent.runningExecutionContext;
    Assert(genContext.Generator !== Value.undefined, "genContext.Generator !== Value.undefined");
    const generator = genContext.Generator;
    Assert(GetGeneratorKind() === 'async', "GetGeneratorKind() === 'async'");
    value = yield* Await(value);

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    generator.AsyncGeneratorState = 'suspendedYield';
    surroundingAgent.executionContextStack.pop(genContext);
    const resumptionValue = EnsureCompletion((yield handleInResume(AsyncGeneratorResolve, generator, value, Value.false)));

    if (resumptionValue.Type !== 'return') {
      return Completion(resumptionValue);
    }

    const awaited = EnsureCompletion((yield* Await(resumptionValue.Value)));

    if (awaited.Type === 'Throw') {
      return Completion(awaited);
    }

    Assert(awaited.Type === 'normal', "awaited.Type === 'normal'");
    return new Completion('return', awaited.Value, undefined);
  }

  // 6 #sec-ecmascript-data-types-and-values
  // 6.1.4 #leading-surrogate

  function isLeadingSurrogate(cp) {
    return cp >= 0xD800 && cp <= 0xDBFF;
  } // 6.1.4 #trailing-surrogate

  function isTrailingSurrogate(cp) {
    return cp >= 0xDC00 && cp <= 0xDFFF;
  } // 6.1.7 #integer-index

  function isIntegerIndex(V) {
    if (Type(V) !== 'String') {
      return false;
    }

    let numeric = CanonicalNumericIndexString(V);
    Assert(!(numeric instanceof AbruptCompletion), "");

    if (numeric instanceof Completion) {
      numeric = numeric.Value;
    }

    if (numeric === Value.undefined) {
      return false;
    }

    if (Object.is(numeric.numberValue(), +0)) {
      return true;
    }

    return numeric.numberValue() > 0 && Number.isSafeInteger(numeric.numberValue());
  } // 6.1.7 #array-index

  function isArrayIndex(V) {
    if (Type(V) !== 'String') {
      return false;
    }

    let numeric = CanonicalNumericIndexString(V);
    Assert(!(numeric instanceof AbruptCompletion), "");

    if (numeric instanceof Completion) {
      numeric = numeric.Value;
    }

    if (numeric === Value.undefined) {
      return false;
    }

    if (Object.is(numeric.numberValue(), +0)) {
      return true;
    }

    return numeric.numberValue() > 0 && numeric.numberValue() < 2 ** 32 - 1;
  }

  // 24.3 #sec-dataview-objects
  // 24.3.1.1 #sec-getviewvalue

  function GetViewValue(view, requestIndex, isLittleEndian, type) {
    {
      const hygienicTemp = RequireInternalSlot(view, 'DataView');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in view, "'ViewedArrayBuffer' in view");

    let _hygienicTemp = ToIndex(requestIndex);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const getIndex = _hygienicTemp.numberValue();

    isLittleEndian = ToBoolean(isLittleEndian);
    Assert(!(isLittleEndian instanceof AbruptCompletion), "");

    if (isLittleEndian instanceof Completion) {
      isLittleEndian = isLittleEndian.Value;
    }

    const buffer = view.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const viewOffset = view.ByteOffset.numberValue();
    const viewSize = view.ByteLength.numberValue();
    const elementSize = numericTypeInfo.get(type).ElementSize;

    if (getIndex + elementSize > viewSize) {
      return surroundingAgent.Throw('RangeError', msg('DataViewOOB'));
    }

    const bufferIndex = new Value(getIndex + viewOffset);
    return GetValueFromBuffer(buffer, bufferIndex, type, false, 'Unordered', isLittleEndian);
  } // 24.3.1.2 #sec-setviewvalue

  function SetViewValue(view, requestIndex, isLittleEndian, type, value) {
    {
      const hygienicTemp = RequireInternalSlot(view, 'DataView');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in view, "'ViewedArrayBuffer' in view");

    let _hygienicTemp2 = ToIndex(requestIndex);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const getIndex = _hygienicTemp2.numberValue();

    let numberValue = ToNumber(value);

    if (numberValue instanceof AbruptCompletion) {
      return numberValue;
    }

    if (numberValue instanceof Completion) {
      numberValue = numberValue.Value;
    }

    isLittleEndian = ToBoolean(isLittleEndian);
    Assert(!(isLittleEndian instanceof AbruptCompletion), "");

    if (isLittleEndian instanceof Completion) {
      isLittleEndian = isLittleEndian.Value;
    }

    const buffer = view.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const viewOffset = view.ByteOffset.numberValue();
    const viewSize = view.ByteLength.numberValue();
    const elementSize = numericTypeInfo.get(type).ElementSize;

    if (getIndex + elementSize > viewSize) {
      return surroundingAgent.Throw('RangeError', msg('DataViewOOB'));
    }

    const bufferIndex = new Value(getIndex + viewOffset);
    return SetValueInBuffer(buffer, bufferIndex, type, numberValue, false, 'Unordered', isLittleEndian);
  }

  const mod = (n, m) => {
    const r = n % m;
    return Math.floor(r >= 0 ? r : r + m);
  }; // 20.3.1.2 #sec-day-number-and-time-within-day


  function Day(t) {
    return new Value(Math.floor(t.numberValue() / msPerDay));
  }
  const msPerDay = 86400000;
  function TimeWithinDay(t) {
    return new Value(mod(t.numberValue(), msPerDay));
  } // 20.3.1.3 #sec-year-number

  function DaysInYear(y) {
    y = y.numberValue();

    if (mod(y, 4) !== 0) {
      return new Value(365);
    }

    if (mod(y, 4) === 0 && mod(y, 100) !== 0) {
      return new Value(366);
    }

    if (mod(y, 100) === 0 && mod(y, 400) !== 0) {
      return new Value(365);
    }

    if (mod(y, 400) === 0) {
      return new Value(366);
    }
  }
  function DayFromYear(y) {
    y = y.numberValue();
    return new Value(365 * (y - 1970) + Math.floor((y - 1969) / 4) - Math.floor((y - 1901) / 100) + Math.floor((y - 1601) / 400));
  }
  function TimeFromYear(y) {
    return new Value(msPerDay * DayFromYear(y).numberValue());
  }
  const msPerAverageYear = 12 * 30.436875 * msPerDay;
  function YearFromTime(t) {
    t = t.numberValue();
    let year = Math.floor((t + msPerAverageYear / 2) / msPerAverageYear) + 1970;

    if (TimeFromYear(new Value(year)).numberValue() > t) {
      year -= 1;
    }

    return new Value(year);
  }
  function InLeapYear(t) {
    if (DaysInYear(YearFromTime(t)).numberValue() === 365) {
      return new Value(0);
    }

    if (DaysInYear(YearFromTime(t)).numberValue() === 366) {
      return new Value(1);
    }
  } // 20.3.1.4 #sec-month-number

  function MonthFromTime(t) {
    const dayWithinYear = DayWithinYear(t).numberValue();
    const inLeapYear = InLeapYear(t).numberValue();

    if (dayWithinYear >= 0 && dayWithinYear < 31) {
      return new Value(0);
    }

    if (dayWithinYear >= 31 && dayWithinYear < 59 + inLeapYear) {
      return new Value(1);
    }

    if (dayWithinYear >= 59 + inLeapYear && dayWithinYear < 90 + inLeapYear) {
      return new Value(2);
    }

    if (dayWithinYear >= 90 + inLeapYear && dayWithinYear < 120 + inLeapYear) {
      return new Value(3);
    }

    if (dayWithinYear >= 120 + inLeapYear && dayWithinYear < 151 + inLeapYear) {
      return new Value(4);
    }

    if (dayWithinYear >= 151 + inLeapYear && dayWithinYear < 181 + inLeapYear) {
      return new Value(5);
    }

    if (dayWithinYear >= 181 + inLeapYear && dayWithinYear < 212 + inLeapYear) {
      return new Value(6);
    }

    if (dayWithinYear >= 212 + inLeapYear && dayWithinYear < 243 + inLeapYear) {
      return new Value(7);
    }

    if (dayWithinYear >= 243 + inLeapYear && dayWithinYear < 273 + inLeapYear) {
      return new Value(8);
    }

    if (dayWithinYear >= 273 + inLeapYear && dayWithinYear < 304 + inLeapYear) {
      return new Value(9);
    }

    if (dayWithinYear >= 304 + inLeapYear && dayWithinYear < 334 + inLeapYear) {
      return new Value(10);
    }

    if (dayWithinYear >= 334 + inLeapYear && dayWithinYear < 365 + inLeapYear) {
      return new Value(11);
    }
  }
  function DayWithinYear(t) {
    return new Value(Day(t).numberValue() - DayFromYear(YearFromTime(t)).numberValue());
  } // 20.3.1.5 #sec-date-number

  function DateFromTime(t) {
    const dayWithinYear = DayWithinYear(t).numberValue();
    const monthFromTime = MonthFromTime(t).numberValue();
    const inLeapYear = InLeapYear(t).numberValue();

    switch (monthFromTime) {
      case 0:
        return new Value(dayWithinYear + 1);

      case 1:
        return new Value(dayWithinYear - 30);

      case 2:
        return new Value(dayWithinYear - 58 - inLeapYear);

      case 3:
        return new Value(dayWithinYear - 89 - inLeapYear);

      case 4:
        return new Value(dayWithinYear - 119 - inLeapYear);

      case 5:
        return new Value(dayWithinYear - 150 - inLeapYear);

      case 6:
        return new Value(dayWithinYear - 180 - inLeapYear);

      case 7:
        return new Value(dayWithinYear - 211 - inLeapYear);

      case 8:
        return new Value(dayWithinYear - 242 - inLeapYear);

      case 9:
        return new Value(dayWithinYear - 272 - inLeapYear);

      case 10:
        return new Value(dayWithinYear - 303 - inLeapYear);

      case 11:
        return new Value(dayWithinYear - 333 - inLeapYear);

      default: // Unreachable

    }
  } // 20.3.1.6 #sec-week-day

  function WeekDay(t) {
    return new Value(mod(Day(t).numberValue() + 4, 7));
  } // 20.3.1.7 #sec-local-time-zone-adjustment

  function LocalTZA()
  /* t, isUTC */
  {
    // TODO: implement this function properly.
    return 0;
  } // 20.3.1.8 #sec-localtime

  function LocalTime(t) {
    return new Value(t.numberValue() + LocalTZA());
  } // 20.3.1.9 #sec-utc-t

  function UTC(t) {
    return new Value(t.numberValue() - LocalTZA());
  } // 20.3.1.10 #sec-hours-minutes-second-and-milliseconds

  function HourFromTime(t) {
    return new Value(mod(Math.floor(t.numberValue() / msPerHour), HoursPerDay));
  }
  function MinFromTime(t) {
    return new Value(mod(Math.floor(t.numberValue() / msPerMinute), MinutesPerHour));
  }
  function SecFromTime(t) {
    return new Value(mod(Math.floor(t.numberValue() / msPerSecond), SecondsPerMinute));
  }
  function msFromTime(t) {
    return new Value(mod(t.numberValue(), msPerSecond));
  }
  const HoursPerDay = 24;
  const MinutesPerHour = 60;
  const SecondsPerMinute = 60;
  const msPerSecond = 1000;
  const msPerMinute = msPerSecond * SecondsPerMinute;
  const msPerHour = msPerMinute * MinutesPerHour; // 20.3.1.11 #sec-maketime

  function MakeTime(hour, min, sec, ms) {
    if (!Number.isFinite(hour.numberValue()) || !Number.isFinite(min.numberValue()) || !Number.isFinite(sec.numberValue()) || !Number.isFinite(ms.numberValue())) {
      return new Value(NaN);
    }

    let _val = ToInteger(hour);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    const h = _val.numberValue();

    let _val2 = ToInteger(min);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    const m = _val2.numberValue();

    let _val3 = ToInteger(sec);

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    const s = _val3.numberValue();

    let _val4 = ToInteger(ms);

    Assert(!(_val4 instanceof AbruptCompletion), "");

    if (_val4 instanceof Completion) {
      _val4 = _val4.Value;
    }

    const milli = _val4.numberValue();

    const t = h * msPerHour + m * msPerMinute + s * msPerSecond + milli;
    return new Value(t);
  }
  const daysWithinYearToEndOfMonth = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]; // 20.3.1.12 #sec-makeday

  function MakeDay(year, month, date) {
    if (!Number.isFinite(year.numberValue()) || !Number.isFinite(month.numberValue()) || !Number.isFinite(date.numberValue())) {
      return new Value(NaN);
    }

    let _val5 = ToInteger(year);

    Assert(!(_val5 instanceof AbruptCompletion), "");

    if (_val5 instanceof Completion) {
      _val5 = _val5.Value;
    }

    const y = _val5.numberValue();

    let _val6 = ToInteger(month);

    Assert(!(_val6 instanceof AbruptCompletion), "");

    if (_val6 instanceof Completion) {
      _val6 = _val6.Value;
    }

    const m = _val6.numberValue();

    let _val7 = ToInteger(date);

    Assert(!(_val7 instanceof AbruptCompletion), "");

    if (_val7 instanceof Completion) {
      _val7 = _val7.Value;
    }

    const dt = _val7.numberValue();

    const ym = y + Math.floor(m / 12);
    const mn = mod(m, 12);
    const ymday = DayFromYear(new Value(ym + (mn > 1 ? 1 : 0))).numberValue() - 365 * (mn > 1 ? 1 : 0) + daysWithinYearToEndOfMonth[mn];
    const t = new Value(ymday * msPerDay);
    return new Value(Day(t).numberValue() + dt - 1);
  } // 20.3.1.13 #sec-makedate

  function MakeDate(day, time) {
    if (!Number.isFinite(day.numberValue()) || !Number.isFinite(time.numberValue())) {
      return new Value(NaN);
    }

    return new Value(day.numberValue() * msPerDay + time.numberValue());
  } // 20.3.1.14 #sec-timeclip

  function TimeClip(time) {
    if (!Number.isFinite(time.numberValue())) {
      return new Value(NaN);
    }

    if (Math.abs(time.numberValue()) > 8.64e15) {
      return new Value(NaN);
    }

    let _val8 = ToInteger(time);

    Assert(!(_val8 instanceof AbruptCompletion), "");

    if (_val8 instanceof Completion) {
      _val8 = _val8.Value;
    }

    let clippedTime = _val8.numberValue();

    if (Object.is(clippedTime, -0)) {
      clippedTime = 0;
    }

    return new Value(clippedTime);
  }

  // 8.3 #sec-execution-contexts
  // 8.3.1 #sec-getactivescriptormodule

  function GetActiveScriptOrModule() {
    if (surroundingAgent.executionContextStack.length === 0) {
      return Value.null;
    }

    const ec = [...surroundingAgent.executionContextStack].reverse().find(e => e.ScriptOrModule !== undefined);

    if (!ec) {
      return Value.null;
    }

    return ec.ScriptOrModule;
  } // 8.3.2 #sec-resolvebinding

  function ResolveBinding(name, env, strict) {
    if (!env || Type(env) === 'Undefined') {
      env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    }

    Assert(env instanceof LexicalEnvironment, "env instanceof LexicalEnvironment");
    return GetIdentifierReference(env, name, strict ? Value.true : Value.false);
  } // 8.3.3 #sec-getthisenvironment

  function GetThisEnvironment() {
    let lex = surroundingAgent.runningExecutionContext.LexicalEnvironment;

    while (true) {
      // eslint-disable-line no-constant-condition
      const envRec = lex.EnvironmentRecord;
      const exists = envRec.HasThisBinding();

      if (exists === Value.true) {
        return envRec;
      }

      const outer = lex.outerEnvironmentReference;
      Assert(Type(outer) !== 'Null', "Type(outer) !== 'Null'");
      lex = outer;
    }
  } // 8.3.4 #sec-resolvethisbinding

  function ResolveThisBinding() {
    const envRec = GetThisEnvironment();
    return envRec.GetThisBinding();
  } // 8.3.5 #sec-getnewtarget

  function GetNewTarget() {
    const envRec = GetThisEnvironment();
    Assert('NewTarget' in envRec, "'NewTarget' in envRec");
    return envRec.NewTarget;
  } // 8.3.6 #sec-getglobalobject

  function GetGlobalObject() {
    const ctx = surroundingAgent.runningExecutionContext;
    const currentRealm = ctx.Realm;
    return currentRealm.GlobalObject;
  }

  // 9.2 #sec-ecmascript-function-objects
  // 9.3 #sec-built-in-function-objects
  // and
  // 14.9 #sec-tail-position-calls
  // 9.2.1.1 #sec-prepareforordinarycall

  function PrepareForOrdinaryCall(F, newTarget) {
    Assert(Type(newTarget) === 'Undefined' || Type(newTarget) === 'Object', "Type(newTarget) === 'Undefined' || Type(newTarget) === 'Object'"); // const callerContext = surroundingAgent.runningExecutionContext;

    const calleeContext = new ExecutionContext();
    calleeContext.Function = F;
    const calleeRealm = F.Realm;
    calleeContext.Realm = calleeRealm;
    calleeContext.ScriptOrModule = F.ScriptOrModule;
    const localEnv = NewFunctionEnvironment(F, newTarget);
    calleeContext.LexicalEnvironment = localEnv;
    calleeContext.VariableEnvironment = localEnv; // Suspend(callerContext);

    surroundingAgent.executionContextStack.push(calleeContext);
    return calleeContext;
  } // 9.2.1.2 #sec-ordinarycallbindthis


  function OrdinaryCallBindThis(F, calleeContext, thisArgument) {
    const thisMode = F.ThisMode;

    if (thisMode === 'lexical') {
      return new NormalCompletion(Value.undefined);
    }

    const calleeRealm = F.Realm;
    const localEnv = calleeContext.LexicalEnvironment;
    let thisValue;

    if (thisMode === 'strict') {
      thisValue = thisArgument;
    } else {
      if (thisArgument === Value.undefined || thisArgument === Value.null) {
        const globalEnv = calleeRealm.GlobalEnv;
        const globalEnvRec = globalEnv.EnvironmentRecord;
        Assert(globalEnvRec instanceof GlobalEnvironmentRecord, "globalEnvRec instanceof GlobalEnvironmentRecord");
        thisValue = globalEnvRec.GlobalThisValue;
      } else {
        thisValue = ToObject(thisArgument);
        Assert(!(thisValue instanceof AbruptCompletion), "");

        if (thisValue instanceof Completion) {
          thisValue = thisValue.Value;
        } // NOTE: ToObject produces wrapper objects using calleeRealm.

      }
    }

    const envRec = localEnv.EnvironmentRecord;
    Assert(envRec instanceof FunctionEnvironmentRecord, "envRec instanceof FunctionEnvironmentRecord");
    Assert(envRec.ThisBindingStatus !== 'initialized', "envRec.ThisBindingStatus !== 'initialized'");
    return envRec.BindThisValue(thisValue);
  } // 9.2.1.3 #sec-ordinarycallevaluatebody


  function* OrdinaryCallEvaluateBody(F, argumentsList) {
    switch (getFunctionBodyType(F.ECMAScriptCode)) {
      // FunctionBody : FunctionStatementList
      // ConciseBody : `{` FunctionBody `}`
      case 'FunctionBody':
      case 'ConciseBody_FunctionBody':
        return yield* EvaluateBody_FunctionBody(F.ECMAScriptCode.body.body, F, argumentsList);
      // ConciseBody : ExpressionBody

      case 'ConciseBody_ExpressionBody':
        return yield* EvaluateBody_ConciseBody_ExpressionBody(F.ECMAScriptCode.body, F, argumentsList);

      case 'GeneratorBody':
        return yield* EvaluateBody_GeneratorBody(F.ECMAScriptCode.body.body, F, argumentsList);

      case 'AsyncFunctionBody':
      case 'AsyncConciseBody_AsyncFunctionBody':
        return yield* EvaluateBody_AsyncFunctionBody(F.ECMAScriptCode.body.body, F, argumentsList);

      case 'AsyncConciseBody_ExpressionBody':
        return yield* EvaluateBody_AsyncConciseBody_ExpressionBody(F.ECMAScriptCode.body, F, argumentsList);

      case 'AsyncGeneratorBody':
        return yield* EvaluateBody_AsyncGeneratorBody(F.ECMAScriptCode.body.body, F, argumentsList);

      default:
        throw new OutOfRange('OrdinaryCallEvaluateBody', F.ECMAScriptCode);
    }
  } // 9.2.1 #sec-ecmascript-function-objects-call-thisargument-argumentslist

  function FunctionCallSlot(thisArgument, argumentsList) {
    const F = this;
    Assert(F instanceof FunctionValue, "F instanceof FunctionValue");

    if (F.FunctionKind === 'classConstructor') {
      return surroundingAgent.Throw('TypeError', 'Class constructor cannot be called without `new`');
    } // const callerContext = surroundingAgent.runningExecutionContext;


    const calleeContext = PrepareForOrdinaryCall(F, Value.undefined);
    Assert(surroundingAgent.runningExecutionContext === calleeContext, "surroundingAgent.runningExecutionContext === calleeContext");
    OrdinaryCallBindThis(F, calleeContext, thisArgument);
    let result = EnsureCompletion(unwind(OrdinaryCallEvaluateBody(F, argumentsList))); // Remove calleeContext from the execution context stack and
    // restore callerContext as the running execution context.

    surroundingAgent.executionContextStack.pop(calleeContext);

    if (result.Type === 'return') {
      return new NormalCompletion(result.Value);
    }

    if (result instanceof AbruptCompletion) {
      return result;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }

    return new NormalCompletion(Value.undefined);
  } // 9.2.2 #sec-ecmascript-function-objects-construct-argumentslist-newtarget


  function FunctionConstructSlot(argumentsList, newTarget) {
    const F = this;
    Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
    Assert(Type(newTarget) === 'Object', "Type(newTarget) === 'Object'"); // const callerContext = surroundingAgent.runningExecutionContext;

    const kind = F.ConstructorKind;
    let thisArgument;

    if (kind === 'base') {
      thisArgument = OrdinaryCreateFromConstructor(newTarget, '%ObjectPrototype%');

      if (thisArgument instanceof AbruptCompletion) {
        return thisArgument;
      }

      if (thisArgument instanceof Completion) {
        thisArgument = thisArgument.Value;
      }
    }

    const calleeContext = PrepareForOrdinaryCall(F, newTarget);
    Assert(surroundingAgent.runningExecutionContext === calleeContext, "surroundingAgent.runningExecutionContext === calleeContext");

    if (kind === 'base') {
      OrdinaryCallBindThis(F, calleeContext, thisArgument);
    }

    const constructorEnv = calleeContext.LexicalEnvironment;
    const envRec = constructorEnv.EnvironmentRecord;
    let result = EnsureCompletion(unwind(OrdinaryCallEvaluateBody(F, argumentsList))); // Remove calleeContext from the execution context stack and
    // restore callerContext as the running execution context.

    surroundingAgent.executionContextStack.pop(calleeContext);

    if (result.Type === 'return') {
      if (Type(result.Value) === 'Object') {
        return new NormalCompletion(result.Value);
      }

      if (kind === 'base') {
        return new NormalCompletion(thisArgument);
      }

      if (Type(result.Value) !== 'Undefined') {
        return surroundingAgent.Throw('TypeError', 'Derived constructors may only return object or undefined');
      }
    } else {
      if (result instanceof AbruptCompletion) {
        return result;
      }

      if (result instanceof Completion) {
        result = result.Value;
      }
    }

    return envRec.GetThisBinding();
  } // 9.2 #sec-ecmascript-function-objects


  const esFunctionInternalSlots = Object.freeze(['Environment', 'FormalParameters', 'FunctionKind', 'ECMAScriptCode', 'ConstructorKind', 'Realm', 'ScriptOrModule', 'ThisMode', 'Strict', 'HomeObject']); // 9.2.3 #sec-functionallocate

  function FunctionAllocate(functionPrototype, functionKind) {
    Assert(Type(functionPrototype) === 'Object', "Type(functionPrototype) === 'Object'");
    Assert(['normal', 'non-constructor', 'generator', 'async', 'async generator'].includes(functionKind), "['normal', 'non-constructor', 'generator', 'async', 'async generator']\n    .includes(functionKind)");
    const needsConstruct = functionKind === 'normal';

    if (functionKind === 'non-constructor') {
      functionKind = 'Normal';
    }

    const F = new FunctionValue(functionPrototype);

    for (const internalSlot of esFunctionInternalSlots) {
      F[internalSlot] = Value.undefined;
    }

    F.Call = FunctionCallSlot;

    if (needsConstruct) {
      F.Construct = FunctionConstructSlot;
      F.ConstructorKind = 'base';
    }

    F.FunctionKind = functionKind;
    F.Prototype = functionPrototype;
    F.Extensible = Value.true;
    F.Realm = surroundingAgent.currentRealmRecord;
    return F;
  } // 9.2.4 #sec-functioninitialize

  function FunctionInitialize(F, kind, ParameterList, Body, Scope) {
    let len;

    switch (kind) {
      case 'Normal':
      case 'Method':
        len = ExpectedArgumentCount_FormalParameters(ParameterList);
        break;

      case 'Arrow':
        len = ExpectedArgumentCount_ArrowParameters(ParameterList);
        break;

      default:
        throw new OutOfRange('FunctionInitialize kind', kind);
    }

    Assert(!(SetFunctionLength(F, new Value(len)) instanceof AbruptCompletion), "");
    const Strict = isStrictModeCode(Body);
    F.Strict = Strict;
    F.Environment = Scope;
    F.FormalParameters = ParameterList;
    F.ECMAScriptCode = Body;
    F.ScriptOrModule = GetActiveScriptOrModule();

    if (kind === 'Arrow') {
      F.ThisMode = 'lexical';
    } else if (Strict) {
      F.ThisMode = 'strict';
    } else {
      F.ThisMode = 'global';
    }

    return F;
  } // 9.2.5 #sec-functioncreate
  // Instead of taking in a {Async}Function/Concise/GeneratorBody for Body, we
  // instead take in the entire function node as Body and save it in
  // ECMAScriptCode as such.

  function FunctionCreate(kind, ParameterList, Body, Scope, prototype) {
    if (prototype === undefined) {
      prototype = surroundingAgent.intrinsic('%FunctionPrototype%');
    }

    const allocKind = kind === 'Normal' ? 'normal' : 'non-constructor';
    const F = FunctionAllocate(prototype, allocKind);
    return FunctionInitialize(F, kind, ParameterList, Body, Scope);
  } // 9.2.6 #sec-generatorfunctioncreate

  function GeneratorFunctionCreate(kind, ParameterList, Body, Scope) {
    const functionPrototype = surroundingAgent.intrinsic('%Generator%');
    const F = FunctionAllocate(functionPrototype, 'generator');
    return FunctionInitialize(F, kind, ParameterList, Body, Scope);
  } // 9.2.7 #sec-asyncgeneratorfunctioncreate

  function AsyncGeneratorFunctionCreate(kind, ParameterList, Body, Scope) {
    const functionPrototype = surroundingAgent.intrinsic('%AsyncGenerator%');
    let F = FunctionAllocate(functionPrototype, 'generator');
    Assert(!(F instanceof AbruptCompletion), "");

    if (F instanceof Completion) {
      F = F.Value;
    }

    let _val = FunctionInitialize(F, kind, ParameterList, Body, Scope);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    return _val;
  } // 9.2.8 #sec-async-functions-abstract-operations-async-function-create

  function AsyncFunctionCreate(kind, parameters, body, Scope) {
    const functionPrototype = surroundingAgent.intrinsic('%AsyncFunctionPrototype%');
    let F = FunctionAllocate(functionPrototype, 'async');
    Assert(!(F instanceof AbruptCompletion), "");

    if (F instanceof Completion) {
      F = F.Value;
    }

    let _val2 = FunctionInitialize(F, kind, parameters, body, Scope);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    return _val2;
  } // 9.2.10 #sec-makeconstructor

  function MakeConstructor(F, writablePrototype, prototype) {
    Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
    Assert(IsConstructor(F) === Value.true, "IsConstructor(F) === Value.true");

    let _val3 = IsExtensible(F);

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    let _val4 = HasOwnProperty(F, new Value('prototype'));

    Assert(!(_val4 instanceof AbruptCompletion), "");

    if (_val4 instanceof Completion) {
      _val4 = _val4.Value;
    }

    Assert(_val3 === Value.true && _val4 === Value.false, "X(IsExtensible(F)) === Value.true && X(HasOwnProperty(F, new Value('prototype'))) === Value.false");

    if (writablePrototype === undefined) {
      writablePrototype = true;
    }

    if (prototype === undefined) {
      prototype = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
      Assert(!(DefinePropertyOrThrow(prototype, new Value('constructor'), Descriptor({
        Value: F,
        Writable: writablePrototype ? Value.true : Value.false,
        Enumerable: Value.false,
        Configurable: Value.true
      })) instanceof AbruptCompletion), "");
    }

    Assert(!(DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: writablePrototype ? Value.true : Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    return new NormalCompletion(Value.undefined);
  } // 9.2.11 #sec-makeclassconstructor

  function MakeClassConstructor(F) {
    Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
    Assert(F.FunctionKind === 'normal', "F.FunctionKind === 'normal'");
    F.FunctionKind = 'classConstructor';
    return new NormalCompletion(Value.undefined);
  } // 9.2.12 #sec-makemethod

  function MakeMethod(F, homeObject) {
    Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
    Assert(Type(homeObject) === 'Object', "Type(homeObject) === 'Object'");
    F.HomeObject = homeObject;
    return new NormalCompletion(Value.undefined);
  } // 9.2.13 #sec-setfunctionname

  function SetFunctionName(F, name, prefix) {
    Assert(IsExtensible(F) === Value.true && HasOwnProperty(F, new Value('name')) === Value.false, "IsExtensible(F) === Value.true && HasOwnProperty(F, new Value('name')) === Value.false");
    Assert(Type(name) === 'Symbol' || Type(name) === 'String', "Type(name) === 'Symbol' || Type(name) === 'String'");
    Assert(!prefix || Type(prefix) === 'String', "!prefix || Type(prefix) === 'String'");

    if (Type(name) === 'Symbol') {
      const description = name.Description;

      if (Type(description) === 'Undefined') {
        name = new Value('');
      } else {
        name = new Value(`[${description.stringValue()}]`);
      }
    }

    if (prefix !== undefined) {
      name = new Value(`${prefix.stringValue()} ${name.stringValue()}`);
    }

    let _val5 = DefinePropertyOrThrow(F, new Value('name'), Descriptor({
      Value: name,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }));

    Assert(!(_val5 instanceof AbruptCompletion), "");

    if (_val5 instanceof Completion) {
      _val5 = _val5.Value;
    }

    return _val5;
  } // 9.2.14 #sec-setfunctionlength

  function SetFunctionLength(F, length) {
    Assert(IsExtensible(F) === Value.true && HasOwnProperty(F, new Value('length')) === Value.false, "IsExtensible(F) === Value.true && HasOwnProperty(F, new Value('length')) === Value.false");
    Assert(Type(length) === 'Number', "Type(length) === 'Number'");

    let _val6 = IsInteger(length);

    Assert(!(_val6 instanceof AbruptCompletion), "");

    if (_val6 instanceof Completion) {
      _val6 = _val6.Value;
    }

    Assert(length.numberValue() >= 0 && _val6 === Value.true, "length.numberValue() >= 0 && X(IsInteger(length)) === Value.true");

    let _val7 = DefinePropertyOrThrow(F, new Value('length'), Descriptor({
      Value: length,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }));

    Assert(!(_val7 instanceof AbruptCompletion), "");

    if (_val7 instanceof Completion) {
      _val7 = _val7.Value;
    }

    return _val7;
  } // 9.3.3 #sec-createbuiltinfunction

  function CreateBuiltinFunction(steps, internalSlotsList, realm, prototype, isConstructor = Value.false) {
    Assert(typeof steps === 'function', "typeof steps === 'function'");

    if (realm === undefined) {
      realm = surroundingAgent.currentRealmRecord;
    }

    Assert(realm instanceof Realm, "realm instanceof Realm");

    if (prototype === undefined) {
      prototype = realm.Intrinsics['%FunctionPrototype%'];
    }

    const func = new BuiltinFunctionValue(steps, isConstructor);

    for (const slot of internalSlotsList) {
      func[slot] = Value.undefined;
    }

    func.Realm = realm;
    func.Prototype = prototype;
    func.Extensible = Value.true;
    func.ScriptOrModule = Value.null;
    return func;
  } // 14.9.3 #sec-preparefortailcall

  function PrepareForTailCall() {// const leafContext = surroundingAgent.runningExecutionContext;
    // Suspend(leafContext);
    // surroundingAgent.executionContextStack.pop();
    // Assert: leafContext has no further use. It will never
    // be activated as the running execution context.
  }

  // 25.4 #sec-generator-objects
  // 25.4.3.1 #sec-generatorstart

  function GeneratorStart(generator, generatorBody) {
    Assert(Type(generator.GeneratorState) === 'Undefined', "Type(generator.GeneratorState) === 'Undefined'");
    const genContext = surroundingAgent.runningExecutionContext;
    genContext.Generator = generator;

    genContext.codeEvaluationState = function* resumer() {
      const result = EnsureCompletion((yield* Evaluate_FunctionBody(generatorBody)));
      surroundingAgent.executionContextStack.pop(genContext);
      generator.GeneratorState = 'completed';
      genContext.codeEvaluationState = null;
      let resultValue;

      if (result.Type === 'normal') {
        resultValue = Value.undefined;
      } else if (result.Type === 'return') {
        resultValue = result.Value;
      } else {
        Assert(result.Type === 'throw', "result.Type === 'throw'");
        return Completion(result);
      }

      let _val = CreateIterResultObject(resultValue, Value.true);

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      return _val;
    }();

    generator.GeneratorContext = genContext;
    generator.GeneratorState = 'suspendedStart';
    return new NormalCompletion(Value.undefined);
  } // 25.4.3.2 #sec-generatorvalidate

  function GeneratorValidate(generator) {
    {
      const hygienicTemp = RequireInternalSlot(generator, 'GeneratorState');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('GeneratorContext' in generator, "'GeneratorContext' in generator");
    const state = generator.GeneratorState;

    if (state === 'executing') {
      return surroundingAgent.Throw('TypeError', 'Cannot manipulate an executing generator');
    }

    return state;
  } // 25.4.3.3 #sec-generatorresume

  function GeneratorResume(generator, value) {
    let state = GeneratorValidate(generator);

    if (state instanceof AbruptCompletion) {
      return state;
    }

    if (state instanceof Completion) {
      state = state.Value;
    }

    if (state === 'completed') {
      let _val2 = CreateIterResultObject(Value.undefined, Value.true);

      Assert(!(_val2 instanceof AbruptCompletion), "");

      if (_val2 instanceof Completion) {
        _val2 = _val2.Value;
      }

      return _val2;
    }

    Assert(state === 'suspendedStart' || state === 'suspendedYield', "state === 'suspendedStart' || state === 'suspendedYield'");
    const genContext = generator.GeneratorContext;
    const originalStackLength = surroundingAgent.executionContextStack.length;
    const methodContext = surroundingAgent.runningExecutionContext; // Suspend methodContext.

    generator.GeneratorState = 'executing';
    surroundingAgent.executionContextStack.push(genContext);
    const result = resume(genContext, new NormalCompletion(value));
    Assert(surroundingAgent.runningExecutionContext === methodContext, "surroundingAgent.runningExecutionContext === methodContext");
    Assert(surroundingAgent.executionContextStack.length === originalStackLength, "surroundingAgent.executionContextStack.length === originalStackLength");
    return Completion(result);
  } // 25.4.3.4 #sec-generatorresumeabrupt

  function GeneratorResumeAbrupt(generator, abruptCompletion) {
    Assert(abruptCompletion instanceof AbruptCompletion, "abruptCompletion instanceof AbruptCompletion");
    let state = GeneratorValidate(generator);

    if (state instanceof AbruptCompletion) {
      return state;
    }

    if (state instanceof Completion) {
      state = state.Value;
    }

    if (state === 'suspendedStart') {
      generator.GeneratorState = 'completed';
      generator.GeneratorContext = null;
      state = 'completed';
    }

    if (state === 'completed') {
      if (abruptCompletion.Type === 'return') {
        let _val3 = CreateIterResultObject(abruptCompletion.Value, Value.true);

        Assert(!(_val3 instanceof AbruptCompletion), "");

        if (_val3 instanceof Completion) {
          _val3 = _val3.Value;
        }

        return _val3;
      }

      return Completion(abruptCompletion);
    }

    Assert(state === 'suspendedYield', "state === 'suspendedYield'");
    const genContext = generator.GeneratorContext;
    const originalStackLength = surroundingAgent.executionContextStack.length;
    const methodContext = surroundingAgent.runningExecutionContext; // Suspend methodContext.

    generator.GeneratorState = 'executing';
    surroundingAgent.executionContextStack.push(genContext);
    const result = resume(genContext, abruptCompletion);
    Assert(surroundingAgent.runningExecutionContext === methodContext, "surroundingAgent.runningExecutionContext === methodContext");
    Assert(surroundingAgent.executionContextStack.length === originalStackLength, "surroundingAgent.executionContextStack.length === originalStackLength");
    return Completion(result);
  } // 25.4.3.5 #sec-getgeneratorkind

  function GetGeneratorKind() {
    const genContext = surroundingAgent.runningExecutionContext;

    if (!genContext.Generator) {
      return 'non-generator';
    }

    const generator = genContext.Generator;

    if ('AsyncGeneratorState' in generator) {
      return 'async';
    }

    return 'sync';
  } // 25.4.3.6 #sec-generatoryield

  function* GeneratorYield(iterNextObj) {
    const genContext = surroundingAgent.runningExecutionContext;
    const generator = genContext.Generator;
    Assert(GetGeneratorKind() === 'sync', "GetGeneratorKind() === 'sync'");
    generator.GeneratorState = 'suspendedYield';
    surroundingAgent.executionContextStack.pop(genContext);
    const resumptionValue = yield new NormalCompletion(iterNextObj);
    return resumptionValue;
  }

  // 18 #sec-global-object
  // 18.2.1.1 #sec-performeval

  function PerformEval(x, callerRealm, strictCaller, direct) {
    if (direct === false) {
      Assert(strictCaller === false, "strictCaller === false");
    }

    if (Type(x) !== 'String') {
      return x;
    }

    const evalRealm = surroundingAgent.currentRealmRecord;
    {
      const hygienicTemp = HostEnsureCanCompileStrings(callerRealm, evalRealm);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    /*
    const thisEnvRec = X(GetThisEnvironment());
    let inFunction;
    let inMethod;
    let inDerivedConstructor;
    if (thisEnvRec instanceof FunctionEnvironmentRecord) {
      const F = thisEnvRec.FunctionObject;
      inFunction = true;
      inMethod = thisEnvRec.HasSuperBinding() === Value.true;
      if (F.ConstructorKind === 'derived') {
        inDerivedConstructor = true;
      } else {
        inDerivedConstructor = false;
      }
    } else {
      inFunction = false;
      inMethod = false;
      inDerivedConstructor = false;
    }
    */

    const r = ParseScript(x.stringValue(), evalRealm, undefined, strictCaller);

    if (Array.isArray(r)) {
      return surroundingAgent.Throw('SyntaxError');
    }

    const script = r.ECMAScriptCode; // If script Contains ScriptBody is false, return undefined.

    const body = script.body;
    let strictEval;

    if (strictCaller === true) {
      strictEval = true;
    } else {
      strictEval = IsStrict(script);
    }

    const ctx = surroundingAgent.runningExecutionContext;
    let lexEnv;
    let varEnv;

    if (direct === true) {
      lexEnv = NewDeclarativeEnvironment(ctx.LexicalEnvironment);
      varEnv = ctx.VariableEnvironment;
    } else {
      lexEnv = NewDeclarativeEnvironment(evalRealm.GlobalEnv);
      varEnv = evalRealm.GlobalEnv;
    }

    if (strictEval === true) {
      varEnv = lexEnv;
    } // If ctx is not already suspended, suspend ctx.


    const evalCtx = new ExecutionContext();
    evalCtx.Function = Value.null;
    evalCtx.Realm = evalRealm;
    evalCtx.ScriptOrModule = ctx.ScriptOrModule;
    evalCtx.VariableEnvironment = varEnv;
    evalCtx.LexicalEnvironment = lexEnv;
    surroundingAgent.executionContextStack.push(evalCtx);
    let result = EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval);

    if (result.Type === 'normal') {
      result = Evaluate_Script(body);
    }

    if (result.Type === 'normal' && result.Value === undefined) {
      result = new NormalCompletion(Value.undefined);
    }

    surroundingAgent.executionContextStack.pop(evalCtx); // Resume the context that is now on the top of the execution context stack as the running execution context.

    return Completion(result);
  } // 18.2.1.3 #sec-evaldeclarationinstantiation

  function EvalDeclarationInstantiation(body, varEnv, lexEnv, strict) {
    const varNames = VarDeclaredNames_ScriptBody(body).map(Value);
    const varDeclarations = VarScopedDeclarations_ScriptBody(body);
    const lexEnvRec = lexEnv.EnvironmentRecord;
    const varEnvRec = varEnv.EnvironmentRecord;

    if (strict === false) {
      if (varEnvRec instanceof GlobalEnvironmentRecord) {
        for (const name of varNames) {
          if (varEnvRec.HasLexicalDeclaration(name) === Value.true) {
            return surroundingAgent.Throw('SyntaxError');
          } // NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.

        }
      }

      let thisLex = lexEnv; // Assert: The following loop will terminate.

      while (thisLex !== varEnv) {
        const thisEnvRec = thisLex.EnvironmentRecord;

        if (!(thisEnvRec instanceof ObjectEnvironmentRecord)) {
          for (const name of varNames) {
            if (thisEnvRec.HasBinding(name) === Value.true) {
              return surroundingAgent.Throw('SyntaxError'); // NOTE: Annex B.3.5 defines alternate semantics for the above step.
            } // NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration

          }
        }

        thisLex = thisLex.outerEnvironmentReference;
      }
    }

    const functionsToInitialize = [];
    const declaredFunctionNames = [];

    for (const d of [...varDeclarations].reverse()) {
      if (!isVariableDeclaration(d) && !isForBinding(d) && !isBindingIdentifier(d)) {
        Assert(isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d), "isFunctionDeclaration(d) || isGeneratorDeclaration(d)\n             || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)");
        const fn = new Value(BoundNames_FunctionDeclaration(d)[0]);

        if (!declaredFunctionNames.includes(fn)) {
          if (varEnvRec instanceof GlobalEnvironmentRecord) {
            let fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn);

            if (fnDefinable instanceof AbruptCompletion) {
              return fnDefinable;
            }

            if (fnDefinable instanceof Completion) {
              fnDefinable = fnDefinable.Value;
            }

            if (fnDefinable === Value.false) {
              return surroundingAgent.Throw('TypeError');
            }
          }

          declaredFunctionNames.push(fn);
          functionsToInitialize.unshift(d);
        }
      }
    } // NOTE: Annex B.3.3.3 adds additional steps at this point.


    const declaredVarNames = [];

    for (const d of varDeclarations) {
      let boundNames;

      if (isVariableDeclaration(d)) {
        boundNames = BoundNames_VariableDeclaration(d);
      } else if (isForBinding(d)) {
        boundNames = BoundNames_ForBinding(d);
      } else if (isBindingIdentifier(d)) {
        boundNames = BoundNames_BindingIdentifier(d);
      }

      if (boundNames !== undefined) {
        for (const vn of boundNames.map(Value)) {
          if (!declaredFunctionNames.includes(vn)) {
            if (varEnvRec instanceof GlobalEnvironmentRecord) {
              let vnDefinable = varEnvRec.CanDeclareGlobalVar(vn);

              if (vnDefinable instanceof AbruptCompletion) {
                return vnDefinable;
              }

              if (vnDefinable instanceof Completion) {
                vnDefinable = vnDefinable.Value;
              }

              if (vnDefinable === Value.false) {
                return surroundingAgent.Throw('TypeError');
              }
            }

            if (!declaredVarNames.includes(vn)) {
              declaredVarNames.push(vn);
            }
          }
        }
      }
    } // NOTE: No abnormal terminations occur after this algorithm step unless
    // varEnvRec is a global Environment Record and the global object is a Proxy exotic object.


    const lexDeclarations = LexicallyScopedDeclarations_ScriptBody(body);

    for (const d of lexDeclarations) {
      for (const dn of BoundNames_Declaration(d).map(Value)) {
        if (IsConstantDeclaration(d)) {
          {
            const hygienicTemp = lexEnvRec.CreateImmutableBinding(dn, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        } else {
          {
            const hygienicTemp = lexEnvRec.CreateMutableBinding(dn, Value.false);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }
      }
    }

    for (const f of functionsToInitialize) {
      const fn = new Value(BoundNames_FunctionDeclaration(f)[0]);
      const fo = InstantiateFunctionObject(f, lexEnv);

      if (varEnvRec instanceof GlobalEnvironmentRecord) {
        {
          const hygienicTemp = varEnvRec.CreateGlobalFunctionBinding(fn, fo, Value.true);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      } else {
        const bindingExists = varEnvRec.HasBinding(fn);

        if (bindingExists === Value.false) {
          let status = varEnvRec.CreateMutableBinding(fn, Value.true);
          Assert(!(status instanceof AbruptCompletion), "");

          if (status instanceof Completion) {
            status = status.Value;
          }

          Assert(!(status instanceof AbruptCompletion), "!(status instanceof AbruptCompletion)");
          Assert(!(varEnvRec.InitializeBinding(fn, fo) instanceof AbruptCompletion), "");
        } else {
          Assert(!(varEnvRec.SetMutableBinding(fn, fo, Value.false) instanceof AbruptCompletion), "");
        }
      }
    }

    for (const vn of declaredVarNames) {
      if (!declaredFunctionNames.includes(vn)) {
        if (varEnvRec instanceof GlobalEnvironmentRecord) {
          {
            const hygienicTemp = varEnvRec.CreateGlobalVarBinding(vn, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        } else {
          const bindingExists = varEnvRec.HasBinding(vn);

          if (bindingExists === Value.false) {
            let status = varEnvRec.CreateMutableBinding(vn, Value.true);
            Assert(!(status instanceof AbruptCompletion), "");

            if (status instanceof Completion) {
              status = status.Value;
            }

            Assert(!(status instanceof AbruptCompletion), "!(status instanceof AbruptCompletion)");
            Assert(!(varEnvRec.InitializeBinding(vn, Value.undefined) instanceof AbruptCompletion), "");
          }
        }
      }
    }

    return new NormalCompletion(undefined);
  }

  // 7.4 #sec-operations-on-iterator-objects
  // and
  // 25.1 #sec-iteration
  // 7.4.1 #sec-getiterator

  function GetIterator(obj, hint, method) {
    if (!hint) {
      hint = 'sync';
    }

    Assert(hint === 'sync' || hint === 'async', "hint === 'sync' || hint === 'async'");

    if (!method) {
      if (hint === 'async') {
        method = GetMethod(obj, wellKnownSymbols.asyncIterator);

        if (method instanceof AbruptCompletion) {
          return method;
        }

        if (method instanceof Completion) {
          method = method.Value;
        }

        if (method === Value.undefined) {
          let syncMethod = GetMethod(obj, wellKnownSymbols.iterator);

          if (syncMethod instanceof AbruptCompletion) {
            return syncMethod;
          }

          if (syncMethod instanceof Completion) {
            syncMethod = syncMethod.Value;
          }

          let syncIteratorRecord = GetIterator(obj, 'sync', syncMethod);

          if (syncIteratorRecord instanceof AbruptCompletion) {
            return syncIteratorRecord;
          }

          if (syncIteratorRecord instanceof Completion) {
            syncIteratorRecord = syncIteratorRecord.Value;
          }

          return CreateAsyncFromSyncIterator(syncIteratorRecord);
        }
      } else {
        method = GetMethod(obj, wellKnownSymbols.iterator);

        if (method instanceof AbruptCompletion) {
          return method;
        }

        if (method instanceof Completion) {
          method = method.Value;
        }
      }
    }

    let iterator = Call(method, obj);

    if (iterator instanceof AbruptCompletion) {
      return iterator;
    }

    if (iterator instanceof Completion) {
      iterator = iterator.Value;
    }

    if (Type(iterator) !== 'Object') {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    let nextMethod = GetV(iterator, new Value('next'));

    if (nextMethod instanceof AbruptCompletion) {
      return nextMethod;
    }

    if (nextMethod instanceof Completion) {
      nextMethod = nextMethod.Value;
    }

    const iteratorRecord = {
      Iterator: iterator,
      NextMethod: nextMethod,
      Done: Value.false
    };
    return EnsureCompletion(iteratorRecord);
  } // 7.4.2 #sec-iteratornext

  function IteratorNext(iteratorRecord, value) {
    let result;

    if (!value) {
      result = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator);

      if (result instanceof AbruptCompletion) {
        return result;
      }

      if (result instanceof Completion) {
        result = result.Value;
      }
    } else {
      result = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, [value]);

      if (result instanceof AbruptCompletion) {
        return result;
      }

      if (result instanceof Completion) {
        result = result.Value;
      }
    }

    if (Type(result) !== 'Object') {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    return EnsureCompletion(result);
  } // 7.4.3 #sec-iteratorcomplete

  function IteratorComplete(iterResult) {
    Assert(Type(iterResult) === 'Object', "Type(iterResult) === 'Object'");

    let _hygienicTemp = Get(iterResult, new Value('done'));

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    return EnsureCompletion(ToBoolean(_hygienicTemp));
  } // 7.4.4 #sec-iteratorvalue

  function IteratorValue(iterResult) {
    Assert(Type(iterResult) === 'Object', "Type(iterResult) === 'Object'");

    let _hygienicTemp2 = Get(iterResult, new Value('value'));

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    return EnsureCompletion(_hygienicTemp2);
  } // 7.4.5 #sec-iteratorstep

  function IteratorStep(iteratorRecord) {
    let result = IteratorNext(iteratorRecord);

    if (result instanceof AbruptCompletion) {
      return result;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }

    let done = IteratorComplete(result);

    if (done instanceof AbruptCompletion) {
      return done;
    }

    if (done instanceof Completion) {
      done = done.Value;
    }

    if (done === Value.true) {
      return EnsureCompletion(Value.false);
    }

    return EnsureCompletion(result);
  } // 7.4.6 #sec-iteratorclose

  function IteratorClose(iteratorRecord, completion) {
    // TODO: completion should be a Completion Record so this should not be necessary
    completion = EnsureCompletion(completion);
    Assert(Type(iteratorRecord.Iterator) === 'Object', "Type(iteratorRecord.Iterator) === 'Object'");
    Assert(completion instanceof Completion, "completion instanceof Completion");
    const iterator = iteratorRecord.Iterator;
    let ret = GetMethod(iterator, new Value('return'));

    if (ret instanceof AbruptCompletion) {
      return ret;
    }

    if (ret instanceof Completion) {
      ret = ret.Value;
    }

    if (ret === Value.undefined) {
      return Completion(completion);
    }

    const innerResult = EnsureCompletion(Call(ret, iterator));

    if (completion.Type === 'throw') {
      return Completion(completion);
    }

    if (innerResult.Type === 'throw') {
      return Completion(innerResult);
    }

    if (Type(innerResult.Value) !== 'Object') {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    return Completion(completion);
  } // 7.4.7 #sec-asynciteratorclose

  function* AsyncIteratorClose(iteratorRecord, completion) {
    Assert(Type(iteratorRecord.Iterator) === 'Object', "Type(iteratorRecord.Iterator) === 'Object'");
    Assert(completion instanceof Completion, "completion instanceof Completion");
    const iterator = iteratorRecord.Iterator;
    let ret = GetMethod(iterator, new Value('return'));

    if (ret instanceof AbruptCompletion) {
      return ret;
    }

    if (ret instanceof Completion) {
      ret = ret.Value;
    }

    if (ret === Value.undefined) {
      return Completion(completion);
    }

    let innerResult = EnsureCompletion(Call(ret, iterator));

    if (innerResult.Type === 'normal') {
      innerResult = EnsureCompletion((yield* Await(innerResult.Value)));
    }

    if (completion.Type === 'throw') {
      return Completion(completion);
    }

    if (innerResult.Type === 'throw') {
      return Completion(innerResult);
    }

    if (Type(innerResult.Value) !== 'Object') {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    return Completion(completion);
  } // 7.4.8 #sec-createiterresultobject

  function CreateIterResultObject(value, done) {
    Assert(Type(done) === 'Boolean', "Type(done) === 'Boolean'");
    const obj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    Assert(!(CreateDataProperty(obj, new Value('value'), value) instanceof AbruptCompletion), "");
    Assert(!(CreateDataProperty(obj, new Value('done'), done) instanceof AbruptCompletion), "");
    return obj;
  } // 7.4.9 #sec-createlistiteratorRecord

  function CreateListIteratorRecord(list) {
    const iterator = ObjectCreate(surroundingAgent.intrinsic('%IteratorPrototype%'), ['IteratedList', 'ListIteratorNextIndex']);
    iterator.IteratedList = list;
    iterator.ListIteratorNextIndex = 0;
    const steps = ListIteratorNextSteps;
    let next = CreateBuiltinFunction(steps, []);
    Assert(!(next instanceof AbruptCompletion), "");

    if (next instanceof Completion) {
      next = next.Value;
    }

    return {
      Iterator: iterator,
      NextMethod: next,
      Done: Value.false
    };
  } // 7.4.9.1 #sec-listiterator-next

  function ListIteratorNextSteps(args, {
    thisValue
  }) {
    const O = thisValue;
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert('IteratedList' in O, "'IteratedList' in O");
    const list = O.IteratedList;
    const index = O.ListIteratorNextIndex;
    const len = list.length;

    if (index >= len) {
      return CreateIterResultObject(Value.undefined, Value.true);
    }

    O.ListIteratorNextIndex += 1;
    return CreateIterResultObject(list[index], Value.false);
  } // 25.1.4.1 #sec-createasyncfromsynciterator


  function CreateAsyncFromSyncIterator(syncIteratorRecord) {
    let asyncIterator = ObjectCreate(surroundingAgent.intrinsic('%AsyncFromSyncIteratorPrototype%'), ['SyncIteratorRecord']);
    Assert(!(asyncIterator instanceof AbruptCompletion), "");

    if (asyncIterator instanceof Completion) {
      asyncIterator = asyncIterator.Value;
    }

    asyncIterator.SyncIteratorRecord = syncIteratorRecord;
    let nextMethod = Get(asyncIterator, new Value('next'));
    Assert(!(nextMethod instanceof AbruptCompletion), "");

    if (nextMethod instanceof Completion) {
      nextMethod = nextMethod.Value;
    }

    return {
      Iterator: asyncIterator,
      NextMethod: nextMethod,
      Done: Value.false
    };
  } // 25.1.4.2.4 #sec-async-from-sync-iterator-value-unwrap-functions

  function AsyncFromSyncIteratorValueUnwrapFunctions([value = Value.undefined]) {
    const F = this;

    let _val = CreateIterResultObject(value, F.Done);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    return _val;
  } // 25.1.4.4 #sec-asyncfromsynciteratorcontinuation


  function AsyncFromSyncIteratorContinuation(result, promiseCapability) {
    let done = IteratorComplete(result);

    if (done instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [done.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (done instanceof Completion) {
      done = done.Value;
    }

    let value = IteratorValue(result);

    if (value instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [value.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (value instanceof Completion) {
      value = value.Value;
    }

    let valueWrapper = PromiseResolve(surroundingAgent.intrinsic('%Promise%'), value);

    if (valueWrapper instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [valueWrapper.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (valueWrapper instanceof Completion) {
      valueWrapper = valueWrapper.Value;
    }

    const steps = AsyncFromSyncIteratorValueUnwrapFunctions;
    let onFulfilled = CreateBuiltinFunction(steps, ['Done']);
    Assert(!(onFulfilled instanceof AbruptCompletion), "");

    if (onFulfilled instanceof Completion) {
      onFulfilled = onFulfilled.Value;
    }

    onFulfilled.Done = done;
    Assert(!(PerformPromiseThen(valueWrapper, onFulfilled, Value.undefined, promiseCapability) instanceof AbruptCompletion), "");
    return promiseCapability.Promise;
  }

  function ModuleNamespaceCreate(module, exports) {
    Assert(module instanceof AbstractModuleRecord, "module instanceof AbstractModuleRecord");
    Assert(module.Namespace === Value.undefined, "module.Namespace === Value.undefined");
    Assert(Array.isArray(exports), "Array.isArray(exports)");
    const M = new ModuleNamespaceExoticObjectValue();
    M.properties.set(wellKnownSymbols.toStringTag, Descriptor({
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false,
      Value: new Value('Module')
    }));
    M.Module = module;
    const sortedExports = [...exports].sort((x, y) => {
      let result = SortCompare(x, y, Value.undefined);
      Assert(!(result instanceof AbruptCompletion), "");

      if (result instanceof Completion) {
        result = result.Value;
      }

      return result.numberValue();
    });
    M.Exports = sortedExports;
    module.Namespace = M;
    return M;
  }

  function InnerModuleLinking(module, stack, index) {
    if (!(module instanceof CyclicModuleRecord)) {
      {
        const hygienicTemp = module.Link();

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      return index;
    }

    if (module.Status === 'linking' || module.Status === 'linked' || module.Status === 'evaluated') {
      return index;
    }

    Assert(module.Status === 'unlinked', "module.Status === 'unlinked'");
    module.Status = 'linking';
    module.DFSIndex = index;
    module.DFSAncestorIndex = index;
    index += 1;
    stack.push(module);

    for (const required of module.RequestedModules) {
      let requiredModule = HostResolveImportedModule(module, required);

      if (requiredModule instanceof AbruptCompletion) {
        return requiredModule;
      }

      if (requiredModule instanceof Completion) {
        requiredModule = requiredModule.Value;
      }

      index = InnerModuleLinking(requiredModule, stack, index);

      if (index instanceof AbruptCompletion) {
        return index;
      }

      if (index instanceof Completion) {
        index = index.Value;
      }

      if (requiredModule instanceof CyclicModuleRecord) {
        Assert(requiredModule.Status === 'linking' || requiredModule.Status === 'linked' || requiredModule.Status === 'evaluated', "requiredModule.Status === 'linking' || requiredModule.Status === 'linked' || requiredModule.Status === 'evaluated'");
        Assert(requiredModule.Status === 'linking' === stack.includes(requiredModule), "(requiredModule.Status === 'linking') === stack.includes(requiredModule)");

        if (requiredModule.Status === 'linking') {
          module.DFSAncestorIndex = Math.min(module.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
        }
      }
    }

    {
      const hygienicTemp = module.InitializeEnvironment();

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert(stack.indexOf(module) === stack.lastIndexOf(module), "stack.indexOf(module) === stack.lastIndexOf(module)");
    Assert(module.DFSAncestorIndex <= module.DFSIndex, "module.DFSAncestorIndex <= module.DFSIndex");

    if (module.DFSAncestorIndex === module.DFSIndex) {
      let done = false;

      while (done === false) {
        const requiredModule = stack.pop();
        Assert(requiredModule instanceof CyclicModuleRecord, "requiredModule instanceof CyclicModuleRecord");
        requiredModule.Status = 'linked';

        if (requiredModule === module) {
          done = true;
        }
      }
    }

    return index;
  } // 15.2.1.16.2.1 #sec-innermoduleevaluation

  function InnerModuleEvaluation(module, stack, index) {
    if (!(module instanceof CyclicModuleRecord)) {
      {
        const hygienicTemp = module.Evaluate();

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      return index;
    }

    if (module.Status === 'evaluated') {
      if (module.EvaluationError === Value.undefined) {
        return index;
      } else {
        return module.EvaluationError;
      }
    }

    if (module.Status === 'evaluating') {
      return index;
    }

    Assert(module.Status === 'linked', "module.Status === 'linked'");
    module.Status = 'evaluating';
    module.DFSIndex = index;
    module.DFSAncestorIndex = index;
    index += 1;
    stack.push(module);

    for (const required of module.RequestedModules) {
      let requiredModule = HostResolveImportedModule(module, required);
      Assert(!(requiredModule instanceof AbruptCompletion), "");

      if (requiredModule instanceof Completion) {
        requiredModule = requiredModule.Value;
      }

      index = InnerModuleEvaluation(requiredModule, stack, index);

      if (index instanceof AbruptCompletion) {
        return index;
      }

      if (index instanceof Completion) {
        index = index.Value;
      }

      if (requiredModule instanceof CyclicModuleRecord) {
        Assert(requiredModule.Status === 'evaluating' || requiredModule.Status === 'evaluated', "requiredModule.Status === 'evaluating' || requiredModule.Status === 'evaluated'");

        if (stack.includes(requiredModule)) {
          Assert(requiredModule.Status === 'evaluating', "requiredModule.Status === 'evaluating'");
        }

        if (requiredModule.Status === 'evaluating') {
          module.DFSAncestorIndex = Math.min(module.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
        }
      }
    }

    {
      const hygienicTemp = module.ExecuteModule();

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert(stack.indexOf(module) === stack.lastIndexOf(module), "stack.indexOf(module) === stack.lastIndexOf(module)");
    Assert(module.DFSAncestorIndex <= module.DFSIndex, "module.DFSAncestorIndex <= module.DFSIndex");

    if (module.DFSAncestorIndex === module.DFSIndex) {
      let done = false;

      while (done === false) {
        const requiredModule = stack.pop();
        Assert(requiredModule instanceof CyclicModuleRecord, "requiredModule instanceof CyclicModuleRecord");
        requiredModule.Status = 'evaluated';

        if (requiredModule === module) {
          done = true;
        }
      }
    }

    return index;
  } // 15.2.1.21 #sec-getmodulenamespace

  function GetModuleNamespace(module) {
    Assert(module instanceof AbstractModuleRecord, "module instanceof AbstractModuleRecord");

    if (module instanceof CyclicModuleRecord) {
      Assert(module.Status !== 'unlinked', "module.Status !== 'unlinked'");
    }

    let namespace = module.Namespace;

    if (namespace === Value.undefined) {
      let exportedNames = module.GetExportedNames();

      if (exportedNames instanceof AbruptCompletion) {
        return exportedNames;
      }

      if (exportedNames instanceof Completion) {
        exportedNames = exportedNames.Value;
      }

      const unambiguousNames = [];

      for (const name of exportedNames) {
        let resolution = module.ResolveExport(name);

        if (resolution instanceof AbruptCompletion) {
          return resolution;
        }

        if (resolution instanceof Completion) {
          resolution = resolution.Value;
        }

        if (resolution instanceof ResolvedBindingRecord) {
          unambiguousNames.push(name);
        }
      }

      namespace = ModuleNamespaceCreate(module, unambiguousNames);
    }

    return namespace;
  }

  // 7.3 #sec-operations-on-objects
  // 7.3.1 #sec-get-o-p

  function Get(O, P) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)"); // TODO: This should just return Q(O.Get(P, O))

    let _hygienicTemp = O.Get(P, O);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    return new NormalCompletion(_hygienicTemp);
  } // 7.3.2 #sec-getv

  function GetV(V, P) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let O = ToObject(V);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    return O.Get(P, V);
  } // 7.3.3 #sec-set-o-p-v-throw

  function Set$1(O, P, V, Throw) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    Assert(Type(Throw) === 'Boolean', "Type(Throw) === 'Boolean'");
    let success = O.Set(P, V, O);

    if (success instanceof AbruptCompletion) {
      return success;
    }

    if (success instanceof Completion) {
      success = success.Value;
    }

    if (success === Value.false && Throw === Value.true) {
      return surroundingAgent.Throw('TypeError', msg('CannotSetProperty', P, O));
    }

    return success;
  } // 7.3.4 #sec-createdataproperty

  function CreateDataProperty(O, P, V) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const newDesc = Descriptor({
      Value: V,
      Writable: Value.true,
      Enumerable: Value.true,
      Configurable: Value.true
    });
    return O.DefineOwnProperty(P, newDesc);
  } // 7.3.5 #sec-createmethodproperty

  function CreateMethodProperty(O, P, V) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const newDesc = Descriptor({
      Value: V,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    });
    return O.DefineOwnProperty(P, newDesc);
  } // 7.3.6 #sec-createdatapropertyorthrow

  function CreateDataPropertyOrThrow(O, P, V) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let success = CreateDataProperty(O, P, V);

    if (success instanceof AbruptCompletion) {
      return success;
    }

    if (success instanceof Completion) {
      success = success.Value;
    }

    if (success === Value.false) {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    return success;
  } // 7.3.7 #sec-definepropertyorthrow

  function DefinePropertyOrThrow(O, P, desc) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let success = O.DefineOwnProperty(P, desc);

    if (success instanceof AbruptCompletion) {
      return success;
    }

    if (success instanceof Completion) {
      success = success.Value;
    }

    if (success === Value.false) {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    return success;
  } // 7.3.8 #sec-deletepropertyorthrow

  function DeletePropertyOrThrow(O, P) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let success = O.Delete(P);

    if (success instanceof AbruptCompletion) {
      return success;
    }

    if (success instanceof Completion) {
      success = success.Value;
    }

    if (success === Value.false) {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    return success;
  } // 7.3.9 #sec-getmethod

  function GetMethod(V, P) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let func = GetV(V, P);

    if (func instanceof AbruptCompletion) {
      return func;
    }

    if (func instanceof Completion) {
      func = func.Value;
    }

    if (func === Value.null || func === Value.undefined) {
      return Value.undefined;
    }

    if (IsCallable(func) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', func));
    }

    return func;
  } // 7.3.10 #sec-hasproperty

  function HasProperty(O, P) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    return O.HasProperty(P);
  } // 7.3.11 #sec-hasownproperty

  function HasOwnProperty(O, P) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let desc = O.GetOwnProperty(P);

    if (desc instanceof AbruptCompletion) {
      return desc;
    }

    if (desc instanceof Completion) {
      desc = desc.Value;
    }

    if (desc === Value.undefined) {
      return Value.false;
    }

    return Value.true;
  } // 7.3.12 #sec-call

  function Call(F, V, argumentsList) {
    if (!argumentsList) {
      argumentsList = [];
    }

    Assert(argumentsList.every(a => a instanceof Value), "argumentsList.every((a) => a instanceof Value)");

    if (IsCallable(F) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', F));
    }

    return F.Call(V, argumentsList);
  } // 7.3.13 #sec-construct

  function Construct(F, argumentsList, newTarget) {
    if (!newTarget) {
      newTarget = F;
    }

    if (!argumentsList) {
      argumentsList = [];
    }

    Assert(IsConstructor(F) === Value.true, "IsConstructor(F) === Value.true");
    Assert(IsConstructor(newTarget) === Value.true, "IsConstructor(newTarget) === Value.true");
    return F.Construct(argumentsList, newTarget);
  } // 7.3.14 #sec-setintegritylevel

  function SetIntegrityLevel(O, level) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(level === 'sealed' || level === 'frozen', "level === 'sealed' || level === 'frozen'");
    let status = O.PreventExtensions();

    if (status instanceof AbruptCompletion) {
      return status;
    }

    if (status instanceof Completion) {
      status = status.Value;
    }

    if (status === Value.false) {
      return Value.false;
    }

    let keys = O.OwnPropertyKeys();

    if (keys instanceof AbruptCompletion) {
      return keys;
    }

    if (keys instanceof Completion) {
      keys = keys.Value;
    }

    if (level === 'sealed') {
      for (const k of keys) {
        {
          const hygienicTemp = DefinePropertyOrThrow(O, k, Descriptor({
            Configurable: Value.false
          }));

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }
    } else if (level === 'frozen') {
      for (const k of keys) {
        let currentDesc = O.GetOwnProperty(k);

        if (currentDesc instanceof AbruptCompletion) {
          return currentDesc;
        }

        if (currentDesc instanceof Completion) {
          currentDesc = currentDesc.Value;
        }

        if (currentDesc !== Value.undefined) {
          let desc;

          if (IsAccessorDescriptor(currentDesc) === true) {
            desc = Descriptor({
              Configurable: Value.false
            });
          } else {
            desc = Descriptor({
              Configurable: Value.false,
              Writable: Value.false
            });
          }

          {
            const hygienicTemp = DefinePropertyOrThrow(O, k, desc);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }
      }
    }

    return Value.true;
  } // 7.3.15 #sec-testintegritylevel

  function TestIntegrityLevel(O, level) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(level === 'sealed' || level === 'frozen', "level === 'sealed' || level === 'frozen'");
    let extensible = IsExtensible(O);

    if (extensible instanceof AbruptCompletion) {
      return extensible;
    }

    if (extensible instanceof Completion) {
      extensible = extensible.Value;
    }

    if (extensible === Value.true) {
      return Value.false;
    }

    let keys = O.OwnPropertyKeys();

    if (keys instanceof AbruptCompletion) {
      return keys;
    }

    if (keys instanceof Completion) {
      keys = keys.Value;
    }

    for (const k of keys) {
      let currentDesc = O.GetOwnProperty(k);

      if (currentDesc instanceof AbruptCompletion) {
        return currentDesc;
      }

      if (currentDesc instanceof Completion) {
        currentDesc = currentDesc.Value;
      }

      if (currentDesc !== Value.undefined) {
        if (currentDesc.Configurable === Value.true) {
          return Value.false;
        }

        if (level === 'frozen' && IsDataDescriptor(currentDesc)) {
          if (currentDesc.Writable === Value.true) {
            return Value.false;
          }
        }
      }
    }

    return Value.true;
  } // 7.3.16 #sec-createarrayfromlist

  function CreateArrayFromList(elements) {
    Assert(elements.every(e => e instanceof Value), "elements.every((e) => e instanceof Value)");
    let array = ArrayCreate(new Value(0));
    Assert(!(array instanceof AbruptCompletion), "");

    if (array instanceof Completion) {
      array = array.Value;
    }

    let n = 0;

    for (const e of elements) {
      let nStr = ToString(new Value(n));
      Assert(!(nStr instanceof AbruptCompletion), "");

      if (nStr instanceof Completion) {
        nStr = nStr.Value;
      }

      let status = CreateDataProperty(array, nStr, e);
      Assert(!(status instanceof AbruptCompletion), "");

      if (status instanceof Completion) {
        status = status.Value;
      }

      Assert(status === Value.true, "status === Value.true");
      n += 1;
    }

    return array;
  } // 7.3.17 #sec-lengthofarraylike

  function LengthOfArrayLike(obj) {
    Assert(Type(obj) === 'Object', "Type(obj) === 'Object'");

    let _hygienicTemp2 = Get(obj, new Value('length'));

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    return ToLength(_hygienicTemp2);
  } // 7.3.17 #sec-createlistfromarraylike

  function CreateListFromArrayLike(obj, elementTypes) {
    if (!elementTypes) {
      elementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'Object'];
    }

    if (Type(obj) !== 'Object') {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    let _hygienicTemp3 = LengthOfArrayLike(obj);

    if (_hygienicTemp3 instanceof AbruptCompletion) {
      return _hygienicTemp3;
    }

    if (_hygienicTemp3 instanceof Completion) {
      _hygienicTemp3 = _hygienicTemp3.Value;
    }

    const len = _hygienicTemp3.numberValue();

    const list = [];
    let index = 0;

    while (index < len) {
      let indexName = ToString(new Value(index));
      Assert(!(indexName instanceof AbruptCompletion), "");

      if (indexName instanceof Completion) {
        indexName = indexName.Value;
      }

      let next = Get(obj, indexName);

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (!elementTypes.includes(Type(next))) {
        // TODO: throw with an error message
        return surroundingAgent.Throw('TypeError');
      }

      list.push(next);
      index += 1;
    }

    return list;
  } // 7.3.18 #sec-invoke

  function Invoke(V, P, argumentsList) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (!argumentsList) {
      argumentsList = [];
    }

    let func = GetV(V, P);

    if (func instanceof AbruptCompletion) {
      return func;
    }

    if (func instanceof Completion) {
      func = func.Value;
    }

    return Call(func, V, argumentsList);
  } // 7.3.19 #sec-ordinaryhasinstance

  function OrdinaryHasInstance(C, O) {
    if (IsCallable(C) === Value.false) {
      return Value.false;
    }

    if ('BoundTargetFunction' in C) {
      const BC = C.BoundTargetFunction;
      return InstanceofOperator(O, BC);
    }

    if (Type(O) !== 'Object') {
      return Value.false;
    }

    let P = Get(C, new Value('prototype'));

    if (P instanceof AbruptCompletion) {
      return P;
    }

    if (P instanceof Completion) {
      P = P.Value;
    }

    if (Type(P) !== 'Object') {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    while (true) {
      O = O.GetPrototypeOf();

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      if (O === Value.null) {
        return Value.false;
      }

      if (SameValue(P, O) === Value.true) {
        return Value.true;
      }
    }
  } // 7.3.20 #sec-speciesconstructor

  function SpeciesConstructor(O, defaultConstructor) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    let C = Get(O, new Value('constructor'));

    if (C instanceof AbruptCompletion) {
      return C;
    }

    if (C instanceof Completion) {
      C = C.Value;
    }

    if (C === Value.undefined) {
      return defaultConstructor;
    }

    if (Type(C) !== 'Object') {
      // TODO: throw with an error message
      return surroundingAgent.Throw('TypeError');
    }

    let S = Get(C, wellKnownSymbols.species);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    if (S === Value.undefined || S === Value.null) {
      return defaultConstructor;
    }

    if (IsConstructor(S) === Value.true) {
      return S;
    } // TODO: throw with an error message


    return surroundingAgent.Throw('TypeError');
  } // 7.3.21 #sec-enumerableownpropertynames

  function EnumerableOwnPropertyNames(O, kind) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    let ownKeys = O.OwnPropertyKeys();

    if (ownKeys instanceof AbruptCompletion) {
      return ownKeys;
    }

    if (ownKeys instanceof Completion) {
      ownKeys = ownKeys.Value;
    }

    const properties = [];

    for (const key of ownKeys) {
      if (Type(key) === 'String') {
        let desc = O.GetOwnProperty(key);

        if (desc instanceof AbruptCompletion) {
          return desc;
        }

        if (desc instanceof Completion) {
          desc = desc.Value;
        }

        if (desc !== Value.undefined && desc.Enumerable === Value.true) {
          if (kind === 'key') {
            properties.push(key);
          } else {
            let value = Get(O, key);

            if (value instanceof AbruptCompletion) {
              return value;
            }

            if (value instanceof Completion) {
              value = value.Value;
            }

            if (kind === 'value') {
              properties.push(value);
            } else {
              Assert(kind === 'key+value', "kind === 'key+value'");
              let entry = CreateArrayFromList([key, value]);
              Assert(!(entry instanceof AbruptCompletion), "");

              if (entry instanceof Completion) {
                entry = entry.Value;
              }

              properties.push(entry);
            }
          }
        }
      }
    } // Order the elements of properties so they are in the same relative
    // order as would be produced by the Iterator that would be returned
    // if the EnumerateObjectProperties internal method were invoked with O.


    return properties;
  } // 7.3.22 #sec-getfunctionrealm

  function GetFunctionRealm(obj) {
    let _val = IsCallable(obj);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    Assert(_val === Value.true, "X(IsCallable(obj)) === Value.true");

    if ('Realm' in obj) {
      return obj.Realm;
    }

    if ('BoundTargetFunction' in obj) {
      const target = obj.BoundTargetFunction;
      return GetFunctionRealm(target);
    }

    if (obj instanceof ProxyExoticObjectValue) {
      if (Type(obj.ProxyHandler) === 'Null') {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'GetFunctionRealm'));
      }

      const proxyTarget = obj.ProxyTarget;
      return GetFunctionRealm(proxyTarget);
    }

    return surroundingAgent.currentRealmRecord;
  } // 7.3.23 #sec-copydataproperties

  function CopyDataProperties(target, source, excludedItems) {
    Assert(Type(target) === 'Object', "Type(target) === 'Object'");
    Assert(excludedItems.every(i => IsPropertyKey(i)), "excludedItems.every((i) => IsPropertyKey(i))");

    if (source === Value.undefined || source === Value.null) {
      return target;
    }

    let from = ToObject(source);
    Assert(!(from instanceof AbruptCompletion), "");

    if (from instanceof Completion) {
      from = from.Value;
    }

    let keys = from.OwnPropertyKeys();

    if (keys instanceof AbruptCompletion) {
      return keys;
    }

    if (keys instanceof Completion) {
      keys = keys.Value;
    }

    for (const nextKey of keys) {
      let excluded = false;

      for (const e of excludedItems) {
        if (SameValue(e, nextKey) === Value.true) {
          excluded = true;
        }
      }

      if (excluded === false) {
        let desc = from.GetOwnProperty(nextKey);

        if (desc instanceof AbruptCompletion) {
          return desc;
        }

        if (desc instanceof Completion) {
          desc = desc.Value;
        }

        if (desc !== Value.undefined && desc.Enumerable === Value.true) {
          let propValue = Get(from, nextKey);

          if (propValue instanceof AbruptCompletion) {
            return propValue;
          }

          if (propValue instanceof Completion) {
            propValue = propValue.Value;
          }

          Assert(!(CreateDataProperty(target, nextKey, propValue) instanceof AbruptCompletion), "");
        }
      }
    }

    return target;
  }

  function OrdinaryGetPrototypeOf(O) {
    return O.Prototype;
  } // 9.1.2.1 OrdinarySetPrototypeOf

  function OrdinarySetPrototypeOf(O, V) {
    Assert(Type(V) === 'Object' || Type(V) === 'Null', "Type(V) === 'Object' || Type(V) === 'Null'");
    const current = O.Prototype;

    if (SameValue(V, current) === Value.true) {
      return Value.true;
    }

    const extensible = O.Extensible;

    if (extensible === Value.false) {
      return Value.false;
    }

    let p = V;
    let done = false;

    while (done === false) {
      if (p === Value.null) {
        done = true;
      } else if (SameValue(p, O) === Value.true) {
        return Value.false;
      } else if (p.GetPrototypeOf !== ObjectValue.prototype.GetPrototypeOf) {
        done = true;
      } else {
        p = p.Prototype;
      }
    }

    O.Prototype = V;
    return Value.true;
  } // 9.1.3.1 OrdinaryIsExtensible

  function OrdinaryIsExtensible(O) {
    return O.Extensible;
  } // 9.1.4.1 OrdinaryPreventExtensions

  function OrdinaryPreventExtensions(O) {
    O.Extensible = Value.false;
    return Value.true;
  } // 9.1.5.1 OrdinaryGetOwnProperty

  function OrdinaryGetOwnProperty(O, P) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (!O.properties.has(P)) {
      return Value.undefined;
    }

    const D = Descriptor({});
    const x = O.properties.get(P);

    if (IsDataDescriptor(x)) {
      D.Value = x.Value;
      D.Writable = x.Writable;
    } else if (IsAccessorDescriptor(x)) {
      D.Get = x.Get;
      D.Set = x.Set;
    }

    D.Enumerable = x.Enumerable;
    D.Configurable = x.Configurable;
    return D;
  } // 9.1.6.1 OrdinaryDefineOwnProperty

  function OrdinaryDefineOwnProperty(O, P, Desc) {
    let current = O.GetOwnProperty(P);

    if (current instanceof AbruptCompletion) {
      return current;
    }

    if (current instanceof Completion) {
      current = current.Value;
    }

    let extensible = IsExtensible(O);

    if (extensible instanceof AbruptCompletion) {
      return extensible;
    }

    if (extensible instanceof Completion) {
      extensible = extensible.Value;
    }

    return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
  } // 9.1.6.2 #sec-iscompatiblepropertydescriptor

  function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
    return ValidateAndApplyPropertyDescriptor(Value.undefined, Value.undefined, Extensible, Desc, Current);
  } // 9.1.6.3 ValidateAndApplyPropertyDescriptor

  function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
    Assert(O === Value.undefined || IsPropertyKey(P), "O === Value.undefined || IsPropertyKey(P)");

    if (current === Value.undefined) {
      if (extensible === Value.false) {
        return Value.false;
      }

      Assert(extensible === Value.true, "extensible === Value.true");

      if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
        if (Type(O) !== 'Undefined') {
          O.properties.set(P, Descriptor({
            Value: Desc.Value === undefined ? Value.undefined : Desc.Value,
            Writable: Desc.Writable === undefined ? Value.false : Desc.Writable,
            Enumerable: Desc.Enumerable === undefined ? Value.false : Desc.Enumerable,
            Configurable: Desc.Configurable === undefined ? Value.false : Desc.Configurable
          }));
        }
      } else {
        Assert(IsAccessorDescriptor(Desc), "IsAccessorDescriptor(Desc)");

        if (Type(O) !== 'Undefined') {
          O.properties.set(P, Descriptor({
            Get: Desc.Get === undefined ? Value.undefined : Desc.Get,
            Set: Desc.Set === undefined ? Value.undefined : Desc.Set,
            Enumerable: Desc.Enumerable === undefined ? Value.false : Desc.Enumerable,
            Configurable: Desc.Configurable === undefined ? Value.false : Desc.Configurable
          }));
        }
      }

      return Value.true;
    }

    if (Desc.everyFieldIsAbsent()) {
      return Value.true;
    }

    if (current.Configurable === Value.false) {
      if (Desc.Configurable !== undefined && Desc.Configurable === Value.true) {
        return Value.false;
      }

      if (Desc.Enumerable !== undefined && Desc.Enumerable !== current.Enumerable) {
        return Value.false;
      }
    }

    if (IsGenericDescriptor(Desc)) ; else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
      if (current.Configurable === Value.false) {
        return Value.false;
      }

      if (IsDataDescriptor(current)) {
        if (Type(O) !== 'Undefined') {
          const entry = O.properties.get(P);
          entry.Value = undefined;
          entry.Writable = undefined;
          entry.Get = Value.undefined;
          entry.Set = Value.undefined;
        }
      } else {
        if (Type(O) !== 'Undefined') {
          const entry = O.properties.get(P);
          entry.Get = undefined;
          entry.Set = undefined;
          entry.Value = Value.undefined;
          entry.Writable = Value.false;
        }
      }
    } else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
      if (current.Configurable === Value.false && current.Writable === Value.false) {
        if (Desc.Writable !== undefined && Desc.Writable === Value.true) {
          return Value.false;
        }

        if (Desc.Value !== undefined && SameValue(Desc.Value, current.Value) === Value.false) {
          return Value.false;
        }

        return Value.true;
      }
    } else {
      Assert(IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc), "IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)");

      if (current.Configurable === Value.false) {
        if (Desc.Set !== undefined && SameValue(Desc.Set, current.Set) === Value.false) {
          return Value.false;
        }

        if (Desc.Get !== undefined && SameValue(Desc.Get, current.Get) === Value.false) {
          return Value.false;
        }

        return Value.true;
      }
    }

    if (Type(O) !== 'Undefined') {
      const target = O.properties.get(P);

      if (Desc.Value !== undefined) {
        target.Value = Desc.Value;
      }

      if (Desc.Writable !== undefined) {
        target.Writable = Desc.Writable;
      }

      if (Desc.Get !== undefined) {
        target.Get = Desc.Get;
      }

      if (Desc.Set !== undefined) {
        target.Set = Desc.Set;
      }

      if (Desc.Enumerable !== undefined) {
        target.Enumerable = Desc.Enumerable;
      }

      if (Desc.Configurable !== undefined) {
        target.Configurable = Desc.Configurable;
      }
    }

    return Value.true;
  } // 9.1.7.1 OrdinaryHasProperty

  function OrdinaryHasProperty(O, P) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let hasOwn = O.GetOwnProperty(P);

    if (hasOwn instanceof AbruptCompletion) {
      return hasOwn;
    }

    if (hasOwn instanceof Completion) {
      hasOwn = hasOwn.Value;
    }

    if (Type(hasOwn) !== 'Undefined') {
      return Value.true;
    }

    let parent = O.GetPrototypeOf();

    if (parent instanceof AbruptCompletion) {
      return parent;
    }

    if (parent instanceof Completion) {
      parent = parent.Value;
    }

    if (Type(parent) !== 'Null') {
      return parent.HasProperty(P);
    }

    return Value.false;
  } // 9.1.8.1

  function OrdinaryGet(O, P, Receiver) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let desc = O.GetOwnProperty(P);

    if (desc instanceof AbruptCompletion) {
      return desc;
    }

    if (desc instanceof Completion) {
      desc = desc.Value;
    }

    if (Type(desc) === 'Undefined') {
      let parent = O.GetPrototypeOf();

      if (parent instanceof AbruptCompletion) {
        return parent;
      }

      if (parent instanceof Completion) {
        parent = parent.Value;
      }

      if (Type(parent) === 'Null') {
        return Value.undefined;
      }

      return parent.Get(P, Receiver);
    }

    if (IsDataDescriptor(desc)) {
      return desc.Value;
    }

    Assert(IsAccessorDescriptor(desc), "IsAccessorDescriptor(desc)");
    const getter = desc.Get;

    if (Type(getter) === 'Undefined') {
      return Value.undefined;
    }

    return Call(getter, Receiver);
  } // 9.1.9.1 OrdinarySet

  function OrdinarySet(O, P, V, Receiver) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let ownDesc = O.GetOwnProperty(P);

    if (ownDesc instanceof AbruptCompletion) {
      return ownDesc;
    }

    if (ownDesc instanceof Completion) {
      ownDesc = ownDesc.Value;
    }

    return OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc);
  } // 9.1.9.2 OrdinarySetWithOwnDescriptor

  function OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (Type(ownDesc) === 'Undefined') {
      let parent = O.GetPrototypeOf();

      if (parent instanceof AbruptCompletion) {
        return parent;
      }

      if (parent instanceof Completion) {
        parent = parent.Value;
      }

      if (Type(parent) !== 'Null') {
        return parent.Set(P, V, Receiver);
      }

      ownDesc = Descriptor({
        Value: Value.undefined,
        Writable: Value.true,
        Enumerable: Value.true,
        Configurable: Value.true
      });
    }

    if (IsDataDescriptor(ownDesc)) {
      if (ownDesc.Writable !== undefined && ownDesc.Writable === Value.false) {
        return Value.false;
      }

      if (Type(Receiver) !== 'Object') {
        return Value.false;
      }

      let existingDescriptor = Receiver.GetOwnProperty(P);

      if (existingDescriptor instanceof AbruptCompletion) {
        return existingDescriptor;
      }

      if (existingDescriptor instanceof Completion) {
        existingDescriptor = existingDescriptor.Value;
      }

      if (Type(existingDescriptor) !== 'Undefined') {
        if (IsAccessorDescriptor(existingDescriptor)) {
          return Value.false;
        }

        if (existingDescriptor.Writable === Value.false) {
          return Value.false;
        }

        const valueDesc = Descriptor({
          Value: V
        });
        return Receiver.DefineOwnProperty(P, valueDesc);
      }

      return CreateDataProperty(Receiver, P, V);
    }

    Assert(IsAccessorDescriptor(ownDesc), "IsAccessorDescriptor(ownDesc)");
    const setter = ownDesc.Set;

    if (setter === undefined || Type(setter) === 'Undefined') {
      return Value.false;
    }

    {
      const hygienicTemp = Call(setter, Receiver, [V]);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return Value.true;
  } // 9.1.10.1 OrdinaryDelete

  function OrdinaryDelete(O, P) {
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    let desc = O.GetOwnProperty(P);

    if (desc instanceof AbruptCompletion) {
      return desc;
    }

    if (desc instanceof Completion) {
      desc = desc.Value;
    }

    if (Type(desc) === 'Undefined') {
      return Value.true;
    }

    if (desc.Configurable === Value.true) {
      O.properties.delete(P);
      return Value.true;
    }

    return Value.false;
  } // 9.1.11.1

  function OrdinaryOwnPropertyKeys(O) {
    const keys = []; // For each own property key P of O that is an array index, in ascending numeric index order, do
    //   Add P as the last element of keys.

    for (const P of O.properties.keys()) {
      if (isArrayIndex(P)) {
        keys.push(P);
      }
    }

    keys.sort((a, b) => Number.parseInt(a.stringValue(), 10) - Number.parseInt(b.stringValue(), 10)); // For each own property key P of O such that Type(P) is String and
    // P is not an array index, in ascending chronological order of property creation, do
    //   Add P as the last element of keys.

    for (const P of O.properties.keys()) {
      if (Type(P) === 'String' && isArrayIndex(P) === false) {
        keys.push(P);
      }
    } // For each own property key P of O such that Type(P) is Symbol,
    // in ascending chronological order of property creation, do
    //   Add P as the last element of keys.


    for (const P of O.properties.keys()) {
      if (Type(P) === 'Symbol') {
        keys.push(P);
      }
    }

    return keys;
  } // 9.1.12 ObjectCreate

  function ObjectCreate(proto, internalSlotsList) {
    Assert(Type(proto) === 'Null' || Type(proto) === 'Object', "Type(proto) === 'Null' || Type(proto) === 'Object'");

    if (!internalSlotsList) {
      internalSlotsList = [];
    }

    const obj = new ObjectValue();

    for (const slot of internalSlotsList) {
      obj[slot] = Value.undefined;
    } // The following steps happen in ObjectValue constructor:
    //
    // Set obj's essential internal methods to the default ordinary
    // object definitions specified in 9.1.


    obj.Prototype = proto;
    obj.Extensible = Value.true;
    return obj;
  } // 9.1.13 OrdinaryCreateFromConstructor

  function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto, internalSlotsList) {
    let proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);

    if (proto instanceof AbruptCompletion) {
      return proto;
    }

    if (proto instanceof Completion) {
      proto = proto.Value;
    }

    return ObjectCreate(proto, internalSlotsList);
  } // 9.1.14 GetPrototypeFromConstructor

  function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
    // Assert: intrinsicDefaultProto is a String value that
    // is this specification's name of an intrinsic object.
    Assert(IsCallable(constructor) === Value.true, "IsCallable(constructor) === Value.true");
    let proto = Get(constructor, new Value('prototype'));

    if (proto instanceof AbruptCompletion) {
      return proto;
    }

    if (proto instanceof Completion) {
      proto = proto.Value;
    }

    if (Type(proto) !== 'Object') {
      let realm = GetFunctionRealm(constructor);

      if (realm instanceof AbruptCompletion) {
        return realm;
      }

      if (realm instanceof Completion) {
        realm = realm.Value;
      }

      proto = realm.Intrinsics[intrinsicDefaultProto];
    }

    return proto;
  } // 9.4.5.7 #sec-integerindexedobjectcreate

  function IntegerIndexedObjectCreate(prototype, internalSlotsList) {
    Assert(internalSlotsList.includes('ViewedArrayBuffer'), "internalSlotsList.includes('ViewedArrayBuffer')");
    Assert(internalSlotsList.includes('ArrayLength'), "internalSlotsList.includes('ArrayLength')");
    Assert(internalSlotsList.includes('ByteOffset'), "internalSlotsList.includes('ByteOffset')");
    Assert(internalSlotsList.includes('TypedArrayName'), "internalSlotsList.includes('TypedArrayName')");
    const A = new IntegerIndexedExoticObjectValue();

    for (const slot of internalSlotsList) {
      A[slot] = Value.undefined;
    }

    A.Prototype = prototype;
    A.Extensible = Value.true;
    return A;
  } // 9.4.5.8 #sec-integerindexedelementget

  function IntegerIndexedElementGet(O, index) {
    Assert(Type(index) === 'Number', "Type(index) === 'Number'");
    Assert(O instanceof ObjectValue && 'ViewedArrayBuffer' in O && 'ArrayLength' in O && 'ByteOffset' in O && 'TypedArrayName' in O, "O instanceof ObjectValue\n      && 'ViewedArrayBuffer' in O\n      && 'ArrayLength' in O\n      && 'ByteOffset' in O\n      && 'TypedArrayName' in O");
    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', 'Attempt to access detached ArrayBuffer');
    }

    if (IsInteger(index) === Value.false) {
      return Value.undefined;
    }

    index = index.numberValue();

    if (Object.is(index, -0)) {
      return Value.undefined;
    }

    const length = O.ArrayLength.numberValue();

    if (index < 0 || index >= length) {
      return Value.undefined;
    }

    const offset = O.ByteOffset.numberValue();
    const arrayTypeName = O.TypedArrayName.stringValue();
    const {
      ElementSize: elementSize,
      ElementType: elementType
    } = typedArrayInfo.get(arrayTypeName);
    const indexedPosition = index * elementSize + offset;
    return GetValueFromBuffer(buffer, new Value(indexedPosition), elementType);
  } // 9.4.5.9 #sec-integerindexedelementset

  function IntegerIndexedElementSet(O, index, value) {
    Assert(Type(index) === 'Number', "Type(index) === 'Number'");
    Assert(O instanceof ObjectValue && 'ViewedArrayBuffer' in O && 'ArrayLength' in O && 'ByteOffset' in O && 'TypedArrayName' in O, "O instanceof ObjectValue\n      && 'ViewedArrayBuffer' in O\n      && 'ArrayLength' in O\n      && 'ByteOffset' in O\n      && 'TypedArrayName' in O");
    let numValue = ToNumber(value);

    if (numValue instanceof AbruptCompletion) {
      return numValue;
    }

    if (numValue instanceof Completion) {
      numValue = numValue.Value;
    }

    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', 'Attempt to access detached ArrayBuffer');
    }

    if (IsInteger(index) === Value.false) {
      return Value.false;
    }

    if (Object.is(index.numberValue(), -0)) {
      return Value.false;
    }

    const length = O.ArrayLength;

    if (index.numberValue() < 0 || index.numberValue() >= length.numberValue()) {
      return Value.false;
    }

    const offset = O.ByteOffset;
    const arrayTypeName = O.TypedArrayName.stringValue();
    const {
      ElementSize: elementSize,
      ElementType: elementType
    } = typedArrayInfo.get(arrayTypeName);
    const indexedPosition = new Value(index.numberValue() * elementSize + offset.numberValue());
    Assert(!(SetValueInBuffer(buffer, indexedPosition, elementType, numValue) instanceof AbruptCompletion), "");
    return Value.true;
  }

  // 25.6 #sec-promise-objects
  // 25.6.1.1 #sec-promisecapability-records

  class PromiseCapabilityRecord {
    constructor() {
      this.Promise = Value.undefined;
      this.Resolve = Value.undefined;
      this.Reject = Value.undefined;
    }

  } // 25.6.1.2 #sec-promisereaction-records

  class PromiseReactionRecord {
    constructor(O) {
      Assert(O.Capability instanceof PromiseCapabilityRecord || O.Capability === Value.undefined, "O.Capability instanceof PromiseCapabilityRecord\n        || O.Capability === Value.undefined");
      Assert(O.Type === 'Fulfill' || O.Type === 'Reject', "O.Type === 'Fulfill' || O.Type === 'Reject'");
      Assert(O.Handler instanceof FunctionValue || O.Handler === Value.undefined, "O.Handler instanceof FunctionValue\n        || O.Handler === Value.undefined");
      this.Capability = O.Capability;
      this.Type = O.Type;
      this.Handler = O.Handler;
    }

  } // 25.6.1.3 #sec-createresolvingfunctions

  function CreateResolvingFunctions(promise) {
    const alreadyResolved = {
      Value: false
    };
    const stepsResolve = PromiseResolveFunctions;
    let resolve = CreateBuiltinFunction(stepsResolve, ['Promise', 'AlreadyResolved']);
    Assert(!(resolve instanceof AbruptCompletion), "");

    if (resolve instanceof Completion) {
      resolve = resolve.Value;
    }

    SetFunctionLength(resolve, new Value(1));
    resolve.Promise = promise;
    resolve.AlreadyResolved = alreadyResolved;
    const stepsReject = PromiseRejectFunctions;
    let reject = CreateBuiltinFunction(stepsReject, ['Promise', 'AlreadyResolved']);
    Assert(!(reject instanceof AbruptCompletion), "");

    if (reject instanceof Completion) {
      reject = reject.Value;
    }

    SetFunctionLength(reject, new Value(1));
    reject.Promise = promise;
    reject.AlreadyResolved = alreadyResolved;
    return {
      Resolve: resolve,
      Reject: reject
    };
  } // 25.6.1.3.1 #sec-promise-reject-functions

  function PromiseRejectFunctions([reason = Value.undefined]) {
    const F = this;
    Assert('Promise' in F && Type(F.Promise) === 'Object', "'Promise' in F && Type(F.Promise) === 'Object'");
    const promise = F.Promise;
    const alreadyResolved = F.AlreadyResolved;

    if (alreadyResolved.Value === true) {
      return Value.undefined;
    }

    alreadyResolved.Value = true;
    return RejectPromise(promise, reason);
  } // 25.6.1.3.2 #sec-promise-resolve-functions


  function PromiseResolveFunctions([resolution = Value.undefined]) {
    const F = this;
    Assert('Promise' in F && Type(F.Promise) === 'Object', "'Promise' in F && Type(F.Promise) === 'Object'");
    const promise = F.Promise;
    const alreadyResolved = F.AlreadyResolved;

    if (alreadyResolved.Value === true) {
      return Value.undefined;
    }

    alreadyResolved.Value = true;

    if (SameValue(resolution, promise) === Value.true) {
      const selfResolutionError = surroundingAgent.Throw('TypeError', 'Cannot resolve a promise with itself').Value;
      return RejectPromise(promise, selfResolutionError);
    }

    if (Type(resolution) !== 'Object') {
      return FulfillPromise(promise, resolution);
    }

    const then = Get(resolution, new Value('then'));

    if (then instanceof AbruptCompletion) {
      return RejectPromise(promise, then.Value);
    }

    const thenAction = then.Value;

    if (IsCallable(thenAction) === Value.false) {
      return FulfillPromise(promise, resolution);
    }

    EnqueueJob('PromiseJobs', PromiseResolveThenableJob, [promise, resolution, thenAction]);
    return Value.undefined;
  } // 25.6.1.4 #sec-fulfillpromise


  function FulfillPromise(promise, value) {
    Assert(promise.PromiseState === 'pending', "promise.PromiseState === 'pending'");
    const reactions = promise.PromiseFulfillReactions;
    promise.PromiseResult = value;
    promise.PromiseFulfillReactions = undefined;
    promise.PromiseRejectReactions = undefined;
    promise.PromiseState = 'fulfilled';
    return TriggerPromiseReactions(reactions, value);
  } // 25.6.1.5 #sec-newpromisecapability


  function NewPromiseCapability(C) {
    if (IsConstructor(C) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAConstructor', C));
    }

    const promiseCapability = new PromiseCapabilityRecord();
    const steps = GetCapabilitiesExecutorFunctions;
    let executor = CreateBuiltinFunction(steps, ['Capability']);
    Assert(!(executor instanceof AbruptCompletion), "");

    if (executor instanceof Completion) {
      executor = executor.Value;
    }

    SetFunctionLength(executor, new Value(2));
    executor.Capability = promiseCapability;
    let promise = Construct(C, [executor]);

    if (promise instanceof AbruptCompletion) {
      return promise;
    }

    if (promise instanceof Completion) {
      promise = promise.Value;
    }

    if (IsCallable(promiseCapability.Resolve) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('PromiseResolveFunction', promiseCapability.Resolve));
    }

    if (IsCallable(promiseCapability.Reject) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('PromiseRejectFunction', promiseCapability.Reject));
    }

    promiseCapability.Promise = promise;
    return promiseCapability;
  } // 25.6.1.5.1 #sec-getcapabilitiesexecutor-functions

  function GetCapabilitiesExecutorFunctions([resolve = Value.undefined, reject = Value.undefined]) {
    const F = this;
    const promiseCapability = F.Capability;

    if (Type(promiseCapability.Resolve) !== 'Undefined') {
      return surroundingAgent.Throw('TypeError', 'Promise resolve function already set');
    }

    if (Type(promiseCapability.Reject) !== 'Undefined') {
      return surroundingAgent.Throw('TypeError', 'Promise reject function already set');
    }

    promiseCapability.Resolve = resolve;
    promiseCapability.Reject = reject;
    return Value.undefined;
  } // 25.6.1.6 #sec-ispromise


  function IsPromise(x) {
    if (Type(x) !== 'Object') {
      return Value.false;
    }

    if (!('PromiseState' in x)) {
      return Value.false;
    }

    return Value.true;
  } // 25.6.1.7 #sec-rejectpromise

  function RejectPromise(promise, reason) {
    Assert(promise.PromiseState === 'pending', "promise.PromiseState === 'pending'");
    const reactions = promise.PromiseRejectReactions;
    promise.PromiseResult = reason;
    promise.PromiseFulfillReactions = undefined;
    promise.PromiseRejectReactions = undefined;
    promise.PromiseState = 'rejected';

    if (promise.PromiseIsHandled === Value.false) {
      HostPromiseRejectionTracker(promise, 'reject');
    }

    return TriggerPromiseReactions(reactions, reason);
  } // 25.6.1.8 #sec-triggerpromisereactions


  function TriggerPromiseReactions(reactions, argument) {
    reactions.forEach(reaction => {
      EnqueueJob('PromiseJobs', PromiseReactionJob, [reaction, argument]);
    });
    return Value.undefined;
  } // 25.6.2.1 #sec-promisereactionjob


  function PromiseReactionJob(reaction, argument) {
    Assert(reaction instanceof PromiseReactionRecord, "reaction instanceof PromiseReactionRecord");
    const promiseCapability = reaction.Capability;
    const type = reaction.Type;
    const handler = reaction.Handler;
    let handlerResult;

    if (handler === Value.undefined) {
      if (type === 'Fulfill') {
        handlerResult = new NormalCompletion(argument);
      } else {
        Assert(type === 'Reject', "type === 'Reject'");
        handlerResult = new ThrowCompletion(argument);
      }
    } else {
      handlerResult = Call(handler, Value.undefined, [argument]);
    }

    if (promiseCapability === Value.undefined) {
      Assert(!(handlerResult instanceof AbruptCompletion), "!(handlerResult instanceof AbruptCompletion)");
      return new NormalCompletion(undefined);
    }

    let status;

    if (handlerResult instanceof AbruptCompletion) {
      status = Call(promiseCapability.Reject, Value.undefined, [handlerResult.Value]);
    } else {
      status = Call(promiseCapability.Resolve, Value.undefined, [EnsureCompletion(handlerResult).Value]);
    }

    return status;
  } // 25.6.2.2 #sec-promiseresolvethenablejob

  function PromiseResolveThenableJob(promiseToResolve, thenable, then) {
    const resolvingFunctions = CreateResolvingFunctions(promiseToResolve);
    const thenCallResult = Call(then, thenable, [resolvingFunctions.Resolve, resolvingFunctions.Reject]);

    if (thenCallResult instanceof AbruptCompletion) {
      const status = Call(resolvingFunctions.Reject, Value.undefined, [thenCallResult.Value]);
      return status;
    }

    return thenCallResult;
  } // 25.6.4.5.1 #sec-promise-resolve


  function PromiseResolve(C, x) {
    Assert(Type(C) === 'Object', "Type(C) === 'Object'");

    if (IsPromise(x) === Value.true) {
      let xConstructor = Get(x, new Value('constructor'));

      if (xConstructor instanceof AbruptCompletion) {
        return xConstructor;
      }

      if (xConstructor instanceof Completion) {
        xConstructor = xConstructor.Value;
      }

      if (SameValue(xConstructor, C) === Value.true) {
        return x;
      }
    }

    let promiseCapability = NewPromiseCapability(C);

    if (promiseCapability instanceof AbruptCompletion) {
      return promiseCapability;
    }

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    {
      const hygienicTemp = Call(promiseCapability.Resolve, Value.undefined, [x]);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return promiseCapability.Promise;
  } // 25.6.5.4.1 #sec-performpromisethen

  function PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability) {
    Assert(IsPromise(promise) === Value.true, "IsPromise(promise) === Value.true");

    if (resultCapability) {
      Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
    } else {
      resultCapability = Value.undefined;
    }

    if (IsCallable(onFulfilled) === Value.false) {
      onFulfilled = Value.undefined;
    }

    if (IsCallable(onRejected) === Value.false) {
      onRejected = Value.undefined;
    }

    const fulfillReaction = new PromiseReactionRecord({
      Capability: resultCapability,
      Type: 'Fulfill',
      Handler: onFulfilled
    });
    const rejectReaction = new PromiseReactionRecord({
      Capability: resultCapability,
      Type: 'Reject',
      Handler: onRejected
    });

    if (promise.PromiseState === 'pending') {
      promise.PromiseFulfillReactions.push(fulfillReaction);
      promise.PromiseRejectReactions.push(rejectReaction);
    } else if (promise.PromiseState === 'fulfilled') {
      const value = promise.PromiseResult;
      EnqueueJob('PromiseJobs', PromiseReactionJob, [fulfillReaction, value]);
    } else {
      Assert(promise.PromiseState === 'rejected', "promise.PromiseState === 'rejected'");
      const reason = promise.PromiseResult;

      if (promise.PromiseIsHandled === Value.false) {
        HostPromiseRejectionTracker(promise, 'handler');
      }

      EnqueueJob('PromiseJobs', PromiseReactionJob, [rejectReaction, reason]);
    }

    promise.PromiseIsHandled = Value.true;

    if (resultCapability === Value.undefined) {
      return Value.undefined;
    } else {
      return resultCapability.Promise;
    }
  }

  function GetBase(V) {
    Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
    return V.BaseValue;
  } // 6.2.4.2 #sec-getreferencedname

  function GetReferencedName(V) {
    Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
    return V.ReferencedName;
  } // 6.2.4.3 #sec-isstrictreference

  function IsStrictReference(V) {
    Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
    return V.StrictReference;
  } // 6.2.4.4 #sec-hasprimitivebase

  function HasPrimitiveBase(V) {
    Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");

    if (V.BaseValue instanceof PrimitiveValue) {
      return Value.true;
    }

    return Value.false;
  } // 6.2.4.5 #sec-ispropertyreference

  function IsPropertyReference(V) {
    Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");

    if (Type(V.BaseValue) === 'Object' || HasPrimitiveBase(V) === Value.true) {
      return Value.true;
    }

    return Value.false;
  } // 6.2.4.6 #sec-isunresolvablereference

  function IsUnresolvableReference(V) {
    Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");

    if (V.BaseValue === Value.undefined) {
      return Value.true;
    }

    return Value.false;
  } // 6.2.4.7 #sec-issuperreference

  function IsSuperReference(V) {
    Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
    return 'ThisValue' in V ? Value.true : Value.false;
  } // 6.2.4.8 #sec-getvalue

  function GetValue(V) {
    if (V instanceof AbruptCompletion) {
      return V;
    }

    if (V instanceof Completion) {
      V = V.Value;
    }

    if (Type(V) !== 'Reference') {
      return V;
    }

    let base = GetBase(V);

    if (IsUnresolvableReference(V) === Value.true) {
      return surroundingAgent.Throw('ReferenceError', msg('NotDefined', GetReferencedName(V)));
    }

    if (IsPropertyReference(V) === Value.true) {
      if (HasPrimitiveBase(V) === Value.true) {
        Assert(base !== Value.undefined && base !== Value.null, "base !== Value.undefined && base !== Value.null");
        base = ToObject(base);
        Assert(!(base instanceof AbruptCompletion), "");

        if (base instanceof Completion) {
          base = base.Value;
        }
      }

      return base.Get(GetReferencedName(V), GetThisValue(V));
    } else {
      return base.GetBindingValue(GetReferencedName(V), IsStrictReference(V));
    }
  } // 6.2.4.9 #sec-putvalue

  function PutValue(V, W) {
    if (V instanceof AbruptCompletion) {
      return V;
    }

    if (V instanceof Completion) {
      V = V.Value;
    }

    if (W instanceof AbruptCompletion) {
      return W;
    }

    if (W instanceof Completion) {
      W = W.Value;
    }

    if (Type(V) !== 'Reference') {
      return surroundingAgent.Throw('ReferenceError');
    }

    let base = GetBase(V);

    if (IsUnresolvableReference(V) === Value.true) {
      if (IsStrictReference(V) === Value.true) {
        return surroundingAgent.Throw('ReferenceError', msg('NotDefined', GetReferencedName(V)));
      }

      const globalObj = GetGlobalObject();
      return Set$1(globalObj, GetReferencedName(V), W, Value.false);
    } else if (IsPropertyReference(V) === Value.true) {
      if (HasPrimitiveBase(V) === Value.true) {
        Assert(Type(base) !== 'Undefined' && Type(base) !== 'Null', "Type(base) !== 'Undefined' && Type(base) !== 'Null'");
        base = ToObject(base);
        Assert(!(base instanceof AbruptCompletion), "");

        if (base instanceof Completion) {
          base = base.Value;
        }
      }

      let succeeded = base.Set(GetReferencedName(V), W, GetThisValue(V));

      if (succeeded instanceof AbruptCompletion) {
        return succeeded;
      }

      if (succeeded instanceof Completion) {
        succeeded = succeeded.Value;
      }

      if (succeeded === Value.false && IsStrictReference(V) === Value.true) {
        return surroundingAgent.Throw('TypeError', msg('CannotSetProperty', GetReferencedName(V), base));
      }

      return new NormalCompletion(Value.undefined);
    } else {
      return base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V));
    }
  } // 6.2.4.10 #sec-getthisvalue

  function GetThisValue(V) {
    Assert(IsPropertyReference(V) === Value.true, "IsPropertyReference(V) === Value.true");

    if (IsSuperReference(V) === Value.true) {
      return V.ThisValue;
    }

    return GetBase(V);
  } // 6.2.4.11 #sec-initializereferencedbinding

  function InitializeReferencedBinding(V, W) {
    if (V instanceof AbruptCompletion) {
      return V;
    }

    if (V instanceof Completion) {
      V = V.Value;
    }

    if (W instanceof AbruptCompletion) {
      return W;
    }

    if (W instanceof Completion) {
      W = W.Value;
    }

    Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
    Assert(IsUnresolvableReference(V) === Value.false, "IsUnresolvableReference(V) === Value.false");
    const base = GetBase(V);
    Assert(Type(base) === 'EnvironmentRecord', "Type(base) === 'EnvironmentRecord'");
    return base.InitializeBinding(GetReferencedName(V), W);
  }

  function RegExpAlloc(newTarget) {
    let obj = OrdinaryCreateFromConstructor(newTarget, '%RegExpPrototype%', ['RegExpMatcher', 'OriginalSource', 'OriginalFlags']);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    Assert(!(DefinePropertyOrThrow(obj, new Value('lastIndex'), Descriptor({
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    return obj;
  } // 21.2.3.2.2 #sec-regexpinitialize

  function RegExpInitialize(obj, pattern, flags) {
    let P;

    if (pattern === Value.undefined) {
      P = new Value('');
    } else {
      P = ToString(pattern);

      if (P instanceof AbruptCompletion) {
        return P;
      }

      if (P instanceof Completion) {
        P = P.Value;
      }
    }

    let F;

    if (flags === Value.undefined) {
      F = new Value('');
    } else {
      F = ToString(flags);

      if (F instanceof AbruptCompletion) {
        return F;
      }

      if (F instanceof Completion) {
        F = F.Value;
      }
    }

    const f = F.stringValue();

    if (/^[gimsuy]*$/.test(f) === false || new global.Set(f).size !== f.length) {
      return surroundingAgent.Throw('SyntaxError', msg('InvalidRegExpFlags', f));
    }

    const BMP = !f.includes('u');
      // TODO: remove this once internal parsing is implemented


    try {
      new RegExp(P.stringValue(), F.stringValue()); // eslint-disable-line no-new
    } catch (e) {
      if (e instanceof SyntaxError) {
        return surroundingAgent.Throw('SyntaxError', e.message);
      }

      throw e;
    }

    obj.OriginalSource = P;
    obj.OriginalFlags = F;
    obj.RegExpMatcher = getMatcher(P, F);
    {
      const hygienicTemp = Set$1(obj, new Value('lastIndex'), new Value(0), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return obj;
  } // TODO: implement an independant matcher

  function getMatcher(P, F) {
    const regex = new RegExp(P.stringValue(), F.stringValue());
    const unicode = F.stringValue().includes('u');
    return function RegExpMatcher(S, lastIndex) {
      regex.lastIndex = lastIndex.numberValue();
      const result = regex.exec(S.stringValue());

      if (result === null) {
        return null;
      }

      if (result.index > lastIndex.numberValue()) {
        return null;
      }

      const captures = [];

      for (const capture of result.slice(1)) {
        if (capture === undefined) {
          captures.push(Value.undefined);
        } else if (unicode) {
          captures.push(Array.from(capture).map(char => char.codePointAt(0)));
        } else {
          captures.push(capture.split('').map(char => char.charCodeAt(0)));
        }
      }

      return {
        endIndex: new Value(result.index + result[0].length),
        captures
      };
    };
  } // 21.2.3.2.3 #sec-regexpcreate


  function RegExpCreate(P, F) {
    let obj = RegExpAlloc(surroundingAgent.intrinsic('%RegExp%'));

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    return RegExpInitialize(obj, P, F);
  } // 21.2.3.2.4 #sec-escaperegexppattern

  function EscapeRegExpPattern(P, F) {
    // TODO: implement this without host
    const re = new RegExp(P.stringValue(), F.stringValue());
    return new Value(re.source);
  }

  // 10 #sec-ecmascript-language-source-code
  // 10.1.1 #sec-utf16encoding

  function UTF16Encoding(cp) {
    Assert(cp >= 0 && cp <= 0x10FFFF, "cp >= 0 && cp <= 0x10FFFF");

    if (cp <= 0xFFFF) {
      return [cp];
    }

    const cu1 = Math.floor((cp - 0x10000) / 0x400) + 0xD800;
    const cu2 = (cp - 0x10000) % 0x400 + 0xDC00;
    return [cu1, cu2];
  } // 10.1.2 #sec-utf16decode

  function UTF16Decode(lead, trail) {
    Assert(isLeadingSurrogate(lead) && isTrailingSurrogate(trail), "isLeadingSurrogate(lead) && isTrailingSurrogate(trail)");
    const cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    return cp;
  } // 10.1.3 #sec-codepointat

  function CodePointAt(string, position) {
    const size = string.stringValue().length;
    Assert(position >= 0 && position < size, "position >= 0 && position < size");
    const first = string.stringValue().charCodeAt(position);
    let cp = first;

    if (!isLeadingSurrogate(first) && !isTrailingSurrogate(first)) {
      return {
        CodePoint: new Value(cp),
        CodeUnitCount: new Value(1),
        IsUnpairedSurrogate: Value.false
      };
    }

    if (isTrailingSurrogate(first) || position + 1 === size) {
      return {
        CodePoint: new Value(cp),
        CodeUnitCount: new Value(1),
        IsUnpairedSurrogate: Value.true
      };
    }

    const second = string.stringValue().charCodeAt(position + 1);

    if (!isTrailingSurrogate(second)) {
      return {
        CodePoint: new Value(cp),
        CodeUnitCount: new Value(1),
        IsUnpairedSurrogate: Value.true
      };
    }

    cp = UTF16Decode(first, second);
    Assert(!(cp instanceof AbruptCompletion), "");

    if (cp instanceof Completion) {
      cp = cp.Value;
    }

    return {
      CodePoint: new Value(cp),
      CodeUnitCount: new Value(2),
      IsUnpairedSurrogate: Value.false
    };
  }

  function IsAccessorDescriptor(Desc) {
    if (Type(Desc) === 'Undefined') {
      return false;
    }

    if (Desc.Get === undefined && Desc.Set === undefined) {
      return false;
    }

    return true;
  } // 6.2.5.2 IsDataDescriptor

  function IsDataDescriptor(Desc) {
    if (Type(Desc) === 'Undefined') {
      return false;
    }

    if (Desc.Value === undefined && Desc.Writable === undefined) {
      return false;
    }

    return true;
  } // 6.2.5.3 IsGenericDescriptor

  function IsGenericDescriptor(Desc) {
    if (Type(Desc) === 'Undefined') {
      return false;
    }

    if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
      return true;
    }

    return false;
  } // 6.2.5.4 #sec-frompropertydescriptor

  function FromPropertyDescriptor(Desc) {
    if (Type(Desc) === 'Undefined') {
      return Value.undefined;
    }

    const obj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));

    if (Desc.Value !== undefined) {
      Assert(!(CreateDataProperty(obj, new Value('value'), Desc.Value) instanceof AbruptCompletion), "");
    }

    if (Desc.Writable !== undefined) {
      Assert(!(CreateDataProperty(obj, new Value('writable'), Desc.Writable) instanceof AbruptCompletion), "");
    }

    if (Desc.Get !== undefined) {
      Assert(!(CreateDataProperty(obj, new Value('get'), Desc.Get) instanceof AbruptCompletion), "");
    }

    if (Desc.Set !== undefined) {
      Assert(!(CreateDataProperty(obj, new Value('set'), Desc.Set) instanceof AbruptCompletion), "");
    }

    if (Desc.Enumerable !== undefined) {
      Assert(!(CreateDataProperty(obj, new Value('enumerable'), Desc.Enumerable) instanceof AbruptCompletion), "");
    }

    if (Desc.Configurable !== undefined) {
      Assert(!(CreateDataProperty(obj, new Value('configurable'), Desc.Configurable) instanceof AbruptCompletion), "");
    } // Assert: All of the above CreateDataProperty operations return true.


    return obj;
  } // 6.2.5.5 #sec-topropertydescriptor

  function ToPropertyDescriptor(Obj) {
    if (Type(Obj) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotAnObject', Obj));
    }

    const desc = Descriptor({});
    let hasEnumerable = HasProperty(Obj, new Value('enumerable'));

    if (hasEnumerable instanceof AbruptCompletion) {
      return hasEnumerable;
    }

    if (hasEnumerable instanceof Completion) {
      hasEnumerable = hasEnumerable.Value;
    }

    if (hasEnumerable === Value.true) {
      let _hygienicTemp = Get(Obj, new Value('enumerable'));

      if (_hygienicTemp instanceof AbruptCompletion) {
        return _hygienicTemp;
      }

      if (_hygienicTemp instanceof Completion) {
        _hygienicTemp = _hygienicTemp.Value;
      }

      const enumerable = ToBoolean(_hygienicTemp);
      desc.Enumerable = enumerable;
    }

    let hasConfigurable = HasProperty(Obj, new Value('configurable'));

    if (hasConfigurable instanceof AbruptCompletion) {
      return hasConfigurable;
    }

    if (hasConfigurable instanceof Completion) {
      hasConfigurable = hasConfigurable.Value;
    }

    if (hasConfigurable === Value.true) {
      let _hygienicTemp2 = Get(Obj, new Value('configurable'));

      if (_hygienicTemp2 instanceof AbruptCompletion) {
        return _hygienicTemp2;
      }

      if (_hygienicTemp2 instanceof Completion) {
        _hygienicTemp2 = _hygienicTemp2.Value;
      }

      const conf = ToBoolean(_hygienicTemp2);
      desc.Configurable = conf;
    }

    let hasValue = HasProperty(Obj, new Value('value'));

    if (hasValue instanceof AbruptCompletion) {
      return hasValue;
    }

    if (hasValue instanceof Completion) {
      hasValue = hasValue.Value;
    }

    if (hasValue === Value.true) {
      let value = Get(Obj, new Value('value'));

      if (value instanceof AbruptCompletion) {
        return value;
      }

      if (value instanceof Completion) {
        value = value.Value;
      }

      desc.Value = value;
    }

    let hasWritable = HasProperty(Obj, new Value('writable'));

    if (hasWritable instanceof AbruptCompletion) {
      return hasWritable;
    }

    if (hasWritable instanceof Completion) {
      hasWritable = hasWritable.Value;
    }

    if (hasWritable === Value.true) {
      let _hygienicTemp3 = Get(Obj, new Value('writable'));

      if (_hygienicTemp3 instanceof AbruptCompletion) {
        return _hygienicTemp3;
      }

      if (_hygienicTemp3 instanceof Completion) {
        _hygienicTemp3 = _hygienicTemp3.Value;
      }

      const writable = ToBoolean(_hygienicTemp3);
      desc.Writable = writable;
    }

    let hasGet = HasProperty(Obj, new Value('get'));

    if (hasGet instanceof AbruptCompletion) {
      return hasGet;
    }

    if (hasGet instanceof Completion) {
      hasGet = hasGet.Value;
    }

    if (hasGet === Value.true) {
      let getter = Get(Obj, new Value('get'));

      if (getter instanceof AbruptCompletion) {
        return getter;
      }

      if (getter instanceof Completion) {
        getter = getter.Value;
      }

      if (IsCallable(getter) === Value.false && Type(getter) !== 'Undefined') {
        return surroundingAgent.Throw('TypeError', msg('NotAFunction', getter));
      }

      desc.Get = getter;
    }

    let hasSet = HasProperty(Obj, new Value('set'));

    if (hasSet instanceof AbruptCompletion) {
      return hasSet;
    }

    if (hasSet instanceof Completion) {
      hasSet = hasSet.Value;
    }

    if (hasSet === Value.true) {
      let setter = Get(Obj, new Value('set'));

      if (setter instanceof AbruptCompletion) {
        return setter;
      }

      if (setter instanceof Completion) {
        setter = setter.Value;
      }

      if (IsCallable(setter) === Value.false && Type(setter) !== 'Undefined') {
        return surroundingAgent.Throw('TypeError', msg('NotAFunction', setter));
      }

      desc.Set = setter;
    }

    if (desc.Get !== undefined || desc.Set !== undefined) {
      if (desc.Value !== undefined || desc.Writable !== undefined) {
        return surroundingAgent.Throw('TypeError', 'invalid descriptor');
      }
    }

    return desc;
  } // 6.2.5.6 #sec-completepropertydescriptor

  function CompletePropertyDescriptor(Desc) {
    Assert(Type(Desc) === 'Descriptor', "Type(Desc) === 'Descriptor'");
    const like = Descriptor({
      Value: Value.undefined,
      Writable: false,
      Get: Value.undefined,
      Set: Value.undefined,
      Enumerable: false,
      Configurable: false
    });

    if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
      if (Desc.Value === undefined) {
        Desc.Value = like.Value;
      }

      if (Desc.Writable === undefined) {
        Desc.Writable = like.Writable;
      }
    } else {
      if (Desc.Get === undefined) {
        Desc.Get = like.Get;
      }

      if (Desc.Set === undefined) {
        Desc.Set = like.Set;
      }
    }

    if (Desc.Enumerable === undefined) {
      Desc.Enumerable = like.Enumerable;
    }

    if (Desc.Configurable === undefined) {
      Desc.Configurable = like.Configurable;
    }

    return Desc;
  } // 6.2.7.1 #sec-createbytedatablock

  function CreateByteDataBlock(size) {
    size = size.numberValue();
    Assert(size >= 0, "size >= 0");
    let db;

    try {
      db = new DataBlock(size);
    } catch (err) {
      return surroundingAgent.Throw('RangeError', 'Cannot allocate memory');
    }

    return db;
  } // 6.2.7.3 #sec-copydatablockbytes

  function CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) {
    Assert(Type(toIndex) === 'Number', "Type(toIndex) === 'Number'");
    Assert(Type(fromIndex) === 'Number', "Type(fromIndex) === 'Number'");
    Assert(Type(count) === 'Number', "Type(count) === 'Number'");
    toIndex = toIndex.numberValue();
    fromIndex = fromIndex.numberValue();
    count = count.numberValue();
    Assert(fromBlock !== toBlock, "fromBlock !== toBlock");
    Assert(Type(fromBlock) === 'Data Block'
    /* || Type(fromBlock) === 'Shared Data Block' */
    , "Type(fromBlock) === 'Data Block'");
    Assert(Type(toBlock) === 'Data Block'
    /* || Type(toBlock) === 'Shared Data Block' */
    , "Type(toBlock) === 'Data Block'");
    Assert(Number.isSafeInteger(fromIndex) && fromIndex >= 0, "Number.isSafeInteger(fromIndex) && fromIndex >= 0");
    Assert(Number.isSafeInteger(toIndex) && toIndex >= 0, "Number.isSafeInteger(toIndex) && toIndex >= 0");
    Assert(Number.isSafeInteger(count) && count >= 0, "Number.isSafeInteger(count) && count >= 0");
    const fromSize = fromBlock.byteLength;
    Assert(fromIndex + count <= fromSize, "fromIndex + count <= fromSize");
    const toSize = toBlock.byteLength;
    Assert(toIndex + count <= toSize, "toIndex + count <= toSize");

    while (count > 0) {
      // if (Type(fromBlock) === 'Shared Data Block') {
      //   ...
      // } else {
      Assert(Type(toBlock) !== 'Shared Data Block', "Type(toBlock) !== 'Shared Data Block'");
      toBlock[toIndex] = fromBlock[fromIndex]; // }

      toIndex += 1;
      fromIndex += 1;
      count -= 1;
    }

    return new NormalCompletion(undefined);
  }

  function StringCreate(value, prototype) {
    Assert(Type(value) === 'String', "Type(value) === 'String'");
    const S = new StringExoticObjectValue();
    S.StringData = value;
    S.Prototype = prototype;
    S.Extensible = Value.true;
    const length = new Value(value.stringValue().length);
    Assert(!(DefinePropertyOrThrow(S, new Value('length'), Descriptor({
      Value: length,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    return S;
  } // 9.4.3.5 #sec-stringgetownproperty

  function StringGetOwnProperty(S, P) {
    Assert(Type(S) === 'Object' && 'StringData' in S, "Type(S) === 'Object' && 'StringData' in S");
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (Type(P) !== 'String') {
      return Value.undefined;
    }

    let index = CanonicalNumericIndexString(P);
    Assert(!(index instanceof AbruptCompletion), "");

    if (index instanceof Completion) {
      index = index.Value;
    }

    if (Type(index) === 'Undefined') {
      return Value.undefined;
    }

    if (IsInteger(index) === Value.false) {
      return Value.undefined;
    }

    if (Object.is(index.numberValue(), -0)) {
      return Value.undefined;
    }

    const str = S.StringData;
    Assert(Type(str) === 'String', "Type(str) === 'String'");
    const len = str.stringValue().length;

    if (index.numberValue() < 0 || len <= index.numberValue()) {
      return Value.undefined;
    }

    const resultStr = str.stringValue()[index.numberValue()];
    return Descriptor({
      Value: new Value(resultStr),
      Writable: Value.false,
      Enumerable: Value.true,
      Configurable: Value.false
    });
  }

  function SymbolDescriptiveString(sym) {
    Assert(Type(sym) === 'Symbol', "Type(sym) === 'Symbol'");
    let desc = sym.Description;

    if (Type(desc) === 'Undefined') {
      desc = new Value('');
    }

    return new Value(`Symbol(${desc.stringValue()})`);
  }

  // 7.2 #sec-testing-and-comparison-operations
  // 7.2.1 #sec-requireobjectcoercible

  function RequireObjectCoercible(argument) {
    const type = Type(argument);

    switch (type) {
      case 'Undefined':
        return surroundingAgent.Throw('TypeError', msg('CannotConvertToObject', 'undefined'));

      case 'Null':
        return surroundingAgent.Throw('TypeError', msg('CannotConvertToObject', 'null'));

      case 'Boolean':
      case 'Number':
      case 'String':
      case 'Symbol':
      case 'Object':
        return argument;

      default:
        throw new OutOfRange('RequireObjectCoercible', {
          type,
          argument
        });
    }
  } // 7.2.2 #sec-isarray

  function IsArray(argument) {
    if (Type(argument) !== 'Object') {
      return Value.false;
    }

    if (argument instanceof ArrayExoticObjectValue) {
      return Value.true;
    }

    if (argument instanceof ProxyExoticObjectValue) {
      if (Type(argument.ProxyHandler) === 'Null') {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'IsArray'));
      }

      const target = argument.ProxyTarget;
      return IsArray(target);
    }

    return Value.false;
  } // 7.2.3 #sec-iscallable

  function IsCallable(argument) {
    if (Type(argument) !== 'Object') {
      return Value.false;
    }

    if ('Call' in argument) {
      return Value.true;
    }

    return Value.false;
  } // 7.2.4 #sec-isconstructor

  function IsConstructor(argument) {
    if (Type(argument) !== 'Object') {
      return Value.false;
    }

    if ('Construct' in argument) {
      return Value.true;
    }

    return Value.false;
  } // 7.2.5 #sec-isextensible-o

  function IsExtensible(O) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    return O.IsExtensible();
  } // 7.2.6 #sec-isinteger

  function IsInteger(argument) {
    if (Type(argument) !== 'Number') {
      return Value.false;
    }

    if (argument.isNaN() || argument.isInfinity()) {
      return Value.false;
    }

    if (Math.floor(Math.abs(argument.numberValue())) !== Math.abs(argument.numberValue())) {
      return Value.false;
    }

    return Value.true;
  } // 7.2.7 #sec-ispropertykey

  function IsPropertyKey(argument) {
    if (Type(argument) === 'String') {
      return true;
    }

    if (Type(argument) === 'Symbol') {
      return true;
    }

    return false;
  } // 7.2.8 #sec-isregexp

  function IsRegExp(argument) {
    if (Type(argument) !== 'Object') {
      return Value.false;
    }

    let matcher = Get(argument, wellKnownSymbols.match);

    if (matcher instanceof AbruptCompletion) {
      return matcher;
    }

    if (matcher instanceof Completion) {
      matcher = matcher.Value;
    }

    if (matcher !== Value.undefined) {
      return ToBoolean(matcher);
    }

    if ('RegExpMatcher' in argument) {
      return Value.true;
    }

    return Value.false;
  } // 7.2.9 #sec-isstringprefix

  function IsStringPrefix(p, q) {
    Assert(Type(p) === 'String', "Type(p) === 'String'");
    Assert(Type(q) === 'String', "Type(q) === 'String'");
    return q.stringValue().startsWith(p.stringValue());
  } // 7.2.10 #sec-samevalue

  function SameValue(x, y) {
    if (Type(x) !== Type(y)) {
      return Value.false;
    }

    if (Type(x) === 'Number') {
      if (x.isNaN() && y.isNaN()) {
        return Value.true;
      }

      const xVal = x.numberValue();
      const yVal = y.numberValue();

      if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
        return Value.false;
      }

      if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
        return Value.false;
      }

      if (xVal === yVal) {
        return Value.true;
      }

      return Value.false;
    }

    return SameValueNonNumber(x, y);
  } // 7.2.11 #sec-samevaluezero

  function SameValueZero(x, y) {
    if (Type(x) !== Type(y)) {
      return Value.false;
    }

    if (Type(x) === 'Number') {
      if (x.isNaN() && y.isNaN()) {
        return Value.true;
      }

      const xVal = x.numberValue();
      const yVal = y.numberValue();

      if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
        return Value.true;
      }

      if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
        return Value.true;
      }

      if (xVal === yVal) {
        return Value.true;
      }

      return Value.false;
    }

    return SameValueNonNumber(x, y);
  } // 7.2.12 #sec-samevaluenonnumber

  function SameValueNonNumber(x, y) {
    Assert(Type(x) !== 'Number', "Type(x) !== 'Number'");
    Assert(Type(x) === Type(y), "Type(x) === Type(y)");

    if (Type(x) === 'Undefined') {
      return Value.true;
    }

    if (Type(x) === 'Null') {
      return Value.true;
    }

    if (Type(x) === 'String') {
      if (x.stringValue() === y.stringValue()) {
        return Value.true;
      }

      return Value.false;
    }

    if (Type(x) === 'Boolean') {
      if (x === y) {
        return Value.true;
      }

      return Value.false;
    }

    if (Type(x) === 'Symbol') {
      return x === y ? Value.true : Value.false;
    }

    return x === y ? Value.true : Value.false;
  } // 7.2.13 #sec-abstract-relational-comparison

  function AbstractRelationalComparison(x, y, LeftFirst = true) {
    let px;
    let py;

    if (LeftFirst === true) {
      px = ToPrimitive(x, 'Number');

      if (px instanceof AbruptCompletion) {
        return px;
      }

      if (px instanceof Completion) {
        px = px.Value;
      }

      py = ToPrimitive(y, 'Number');

      if (py instanceof AbruptCompletion) {
        return py;
      }

      if (py instanceof Completion) {
        py = py.Value;
      }
    } else {
      py = ToPrimitive(y, 'Number');

      if (py instanceof AbruptCompletion) {
        return py;
      }

      if (py instanceof Completion) {
        py = py.Value;
      }

      px = ToPrimitive(x, 'Number');

      if (px instanceof AbruptCompletion) {
        return px;
      }

      if (px instanceof Completion) {
        px = px.Value;
      }
    }

    if (Type(px) === 'String' && Type(py) === 'String') {
      if (IsStringPrefix(py, px)) {
        return Value.false;
      }

      if (IsStringPrefix(px, py)) {
        return Value.true;
      }

      let k = 0;

      while (true) {
        if (px.stringValue()[k] !== py.stringValue()[k]) {
          break;
        }

        k += 1;
      }

      const m = px.stringValue().charCodeAt(k);
      const n = py.stringValue().charCodeAt(k);

      if (m < n) {
        return Value.true;
      } else {
        return Value.false;
      }
    } else {
      let nx = ToNumber(px);

      if (nx instanceof AbruptCompletion) {
        return nx;
      }

      if (nx instanceof Completion) {
        nx = nx.Value;
      }

      let ny = ToNumber(py);

      if (ny instanceof AbruptCompletion) {
        return ny;
      }

      if (ny instanceof Completion) {
        ny = ny.Value;
      }

      if (nx.isNaN()) {
        return Value.undefined;
      }

      if (ny.isNaN()) {
        return Value.undefined;
      } // If nx and ny are the same Number value, return false.
      // If nx is +0 and ny is -0, return false.
      // If nx is -0 and ny is +0, return false.


      if (nx.numberValue() === ny.numberValue()) {
        return Value.false;
      }

      if (nx.numberValue() === +Infinity) {
        return Value.false;
      }

      if (ny.numberValue() === +Infinity) {
        return Value.true;
      }

      if (ny.numberValue() === -Infinity) {
        return Value.false;
      }

      if (nx.numberValue() === -Infinity) {
        return Value.true;
      }

      return nx.numberValue() < ny.numberValue() ? Value.true : Value.false;
    }
  } // 7.2.14 #sec-abstract-equality-comparison

  function AbstractEqualityComparison(x, y) {
    if (Type(x) === Type(y)) {
      return StrictEqualityComparison(x, y);
    }

    if (x === Value.null && y === Value.undefined) {
      return Value.true;
    }

    if (x === Value.undefined && y === Value.null) {
      return Value.true;
    }

    if (Type(x) === 'Number' && Type(y) === 'String') {
      let _val = ToNumber(y);

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      return AbstractEqualityComparison(x, _val);
    }

    if (Type(x) === 'String' && Type(y) === 'Number') {
      let _val2 = ToNumber(x);

      Assert(!(_val2 instanceof AbruptCompletion), "");

      if (_val2 instanceof Completion) {
        _val2 = _val2.Value;
      }

      return AbstractEqualityComparison(_val2, y);
    }

    if (Type(x) === 'Boolean') {
      let _val3 = ToNumber(x);

      Assert(!(_val3 instanceof AbruptCompletion), "");

      if (_val3 instanceof Completion) {
        _val3 = _val3.Value;
      }

      return AbstractEqualityComparison(_val3, y);
    }

    if (Type(y) === 'Boolean') {
      let _val4 = ToNumber(y);

      Assert(!(_val4 instanceof AbruptCompletion), "");

      if (_val4 instanceof Completion) {
        _val4 = _val4.Value;
      }

      return AbstractEqualityComparison(x, _val4);
    }

    if (['String', 'Number', 'Symbol'].includes(Type(x)) && Type(y) === 'Object') {
      let _hygienicTemp = ToPrimitive(y);

      if (_hygienicTemp instanceof AbruptCompletion) {
        return _hygienicTemp;
      }

      if (_hygienicTemp instanceof Completion) {
        _hygienicTemp = _hygienicTemp.Value;
      }

      return AbstractEqualityComparison(x, _hygienicTemp);
    }

    if (Type(x) === 'Object' && ['String', 'Number', 'Symbol'].includes(Type(y))) {
      let _hygienicTemp2 = ToPrimitive(x);

      if (_hygienicTemp2 instanceof AbruptCompletion) {
        return _hygienicTemp2;
      }

      if (_hygienicTemp2 instanceof Completion) {
        _hygienicTemp2 = _hygienicTemp2.Value;
      }

      return AbstractEqualityComparison(_hygienicTemp2, y);
    }

    return Value.false;
  } // 7.2.15 #sec-strict-equality-comparison

  function StrictEqualityComparison(x, y) {
    if (Type(x) !== Type(y)) {
      return Value.false;
    }

    if (Type(x) === 'Number') {
      if (x.isNaN()) {
        return Value.false;
      }

      if (y.isNaN()) {
        return Value.false;
      }

      const xVal = x.numberValue();
      const yVal = y.numberValue();

      if (xVal === yVal) {
        return Value.true;
      }

      if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
        return Value.true;
      }

      if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
        return Value.true;
      }

      return Value.false;
    }

    return SameValueNonNumber(x, y);
  }

  function ToPrimitive(input, PreferredType) {
    Assert(input instanceof Value, "input instanceof Value");

    if (Type(input) === 'Object') {
      let hint;

      if (PreferredType === undefined) {
        hint = new Value('default');
      } else if (PreferredType === 'String') {
        hint = new Value('string');
      } else {
        Assert(PreferredType === 'Number', "PreferredType === 'Number'");
        hint = new Value('number');
      }

      let exoticToPrim = GetMethod(input, wellKnownSymbols.toPrimitive);

      if (exoticToPrim instanceof AbruptCompletion) {
        return exoticToPrim;
      }

      if (exoticToPrim instanceof Completion) {
        exoticToPrim = exoticToPrim.Value;
      }

      if (exoticToPrim !== Value.undefined) {
        let result = Call(exoticToPrim, input, [hint]);

        if (result instanceof AbruptCompletion) {
          return result;
        }

        if (result instanceof Completion) {
          result = result.Value;
        }

        if (Type(result) !== 'Object') {
          return result;
        }

        return surroundingAgent.Throw('TypeError', msg('ObjectToPrimitive'));
      }

      if (hint.stringValue() === 'default') {
        hint = new Value('number');
      }

      return OrdinaryToPrimitive(input, hint);
    }

    return input;
  } // 7.1.1.1 #sec-ordinarytoprimitive

  function OrdinaryToPrimitive(O, hint) {
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(Type(hint) === 'String' && (hint.stringValue() === 'string' || hint.stringValue() === 'number'), "Type(hint) === 'String' && (hint.stringValue() === 'string' || hint.stringValue() === 'number')");
    let methodNames;

    if (hint.stringValue() === 'string') {
      methodNames = [new Value('toString'), new Value('valueOf')];
    } else {
      methodNames = [new Value('valueOf'), new Value('toString')];
    }

    for (const name of methodNames) {
      let method = Get(O, name);

      if (method instanceof AbruptCompletion) {
        return method;
      }

      if (method instanceof Completion) {
        method = method.Value;
      }

      if (IsCallable(method) === Value.true) {
        let result = Call(method, O);

        if (result instanceof AbruptCompletion) {
          return result;
        }

        if (result instanceof Completion) {
          result = result.Value;
        }

        if (Type(result) !== 'Object') {
          return result;
        }
      }
    }

    return surroundingAgent.Throw('TypeError', msg('ObjectToPrimitive'));
  } // 7.1.2 #sec-toboolean

  function ToBoolean(argument) {
    const type = Type(argument);

    switch (type) {
      case 'Undefined':
        return Value.false;

      case 'Null':
        return Value.false;

      case 'Boolean':
        return argument;

      case 'Number':
        if (argument.numberValue() === 0 || argument.isNaN()) {
          return Value.false;
        }

        return Value.true;

      case 'String':
        if (argument.stringValue().length === 0) {
          return Value.false;
        }

        return Value.true;

      case 'Symbol':
        return Value.true;

      case 'Object':
        return Value.true;

      default:
        throw new OutOfRange('ToBoolean', {
          type,
          argument
        });
    }
  } // 7.1.3 #sec-tonumber

  function ToNumber(argument) {
    const type = Type(argument);

    switch (type) {
      case 'Undefined':
        return new Value(NaN);

      case 'Null':
        return new Value(0);

      case 'Boolean':
        if (argument === Value.true) {
          return new Value(1);
        }

        return new Value(0);

      case 'Number':
        return argument;

      case 'String':
        return MV_StringNumericLiteral(argument.stringValue());

      case 'Symbol':
        return surroundingAgent.Throw('TypeError', msg('CannotConvertSymbol', 'number'));

      case 'Object':
        {
          let primValue = ToPrimitive(argument, 'Number');

          if (primValue instanceof AbruptCompletion) {
            return primValue;
          }

          if (primValue instanceof Completion) {
            primValue = primValue.Value;
          }

          return ToNumber(primValue);
        }

      default:
        throw new OutOfRange('ToNumber', {
          type,
          argument
        });
    }
  }

  const sign = n => n >= 0 ? 1 : -1;

  const mod$1 = (n, m) => {
    const r = n % m;
    return Math.floor(r >= 0 ? r : r + m);
  }; // 7.1.4 #sec-tointeger


  function ToInteger(argument) {
    let _hygienicTemp = ToNumber(argument);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const number = _hygienicTemp.numberValue();

    if (Number.isNaN(number)) {
      return new Value(0);
    }

    if (number === 0 || !Number.isFinite(number)) {
      return new Value(number);
    }

    const int = sign(number) * Math.floor(Math.abs(number));
    return new Value(int);
  } // 7.1.5 #sec-toint32

  function ToInt32(argument) {
    let _hygienicTemp2 = ToNumber(argument);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const number = _hygienicTemp2.numberValue();

    if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
      return new Value(0);
    }

    const int = sign(number) * Math.floor(Math.abs(number));
    const int32bit = mod$1(int, 2 ** 32);

    if (int32bit >= 2 ** 31) {
      return new Value(int32bit - 2 ** 32);
    }

    return new Value(int32bit);
  } // 7.1.6 #sec-touint32

  function ToUint32(argument) {
    let _hygienicTemp3 = ToNumber(argument);

    if (_hygienicTemp3 instanceof AbruptCompletion) {
      return _hygienicTemp3;
    }

    if (_hygienicTemp3 instanceof Completion) {
      _hygienicTemp3 = _hygienicTemp3.Value;
    }

    const number = _hygienicTemp3.numberValue();

    if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
      return new Value(0);
    }

    const int = sign(number) * Math.floor(Math.abs(number));
    const int32bit = mod$1(int, 2 ** 32);
    return new Value(int32bit);
  } // 7.1.7 #sec-toint16

  function ToInt16(argument) {
    let _hygienicTemp4 = ToNumber(argument);

    if (_hygienicTemp4 instanceof AbruptCompletion) {
      return _hygienicTemp4;
    }

    if (_hygienicTemp4 instanceof Completion) {
      _hygienicTemp4 = _hygienicTemp4.Value;
    }

    const number = _hygienicTemp4.numberValue();

    if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
      return new Value(0);
    }

    const int = sign(number) * Math.floor(Math.abs(number));
    const int16bit = mod$1(int, 2 ** 16);

    if (int16bit >= 2 ** 15) {
      return new Value(int16bit - 2 ** 16);
    }

    return new Value(int16bit);
  } // 7.1.8 #sec-touint16

  function ToUint16(argument) {
    let _hygienicTemp5 = ToNumber(argument);

    if (_hygienicTemp5 instanceof AbruptCompletion) {
      return _hygienicTemp5;
    }

    if (_hygienicTemp5 instanceof Completion) {
      _hygienicTemp5 = _hygienicTemp5.Value;
    }

    const number = _hygienicTemp5.numberValue();

    if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
      return new Value(0);
    }

    const int = sign(number) * Math.floor(Math.abs(number));
    const int16bit = mod$1(int, 2 ** 16);
    return new Value(int16bit);
  } // 7.1.9 #sec-toint8

  function ToInt8(argument) {
    let _hygienicTemp6 = ToNumber(argument);

    if (_hygienicTemp6 instanceof AbruptCompletion) {
      return _hygienicTemp6;
    }

    if (_hygienicTemp6 instanceof Completion) {
      _hygienicTemp6 = _hygienicTemp6.Value;
    }

    const number = _hygienicTemp6.numberValue();

    if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
      return new Value(0);
    }

    const int = sign(number) * Math.floor(Math.abs(number));
    const int8bit = mod$1(int, 2 ** 8);

    if (int8bit >= 2 ** 7) {
      return new Value(int8bit - 2 ** 8);
    }

    return new Value(int8bit);
  } // 7.1.10 #sec-touint8

  function ToUint8(argument) {
    let _hygienicTemp7 = ToNumber(argument);

    if (_hygienicTemp7 instanceof AbruptCompletion) {
      return _hygienicTemp7;
    }

    if (_hygienicTemp7 instanceof Completion) {
      _hygienicTemp7 = _hygienicTemp7.Value;
    }

    const number = _hygienicTemp7.numberValue();

    if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
      return new Value(0);
    }

    const int = sign(number) * Math.floor(Math.abs(number));
    const int8bit = mod$1(int, 2 ** 8);
    return new Value(int8bit);
  } // 7.1.11 #sec-touint8clamp

  function ToUint8Clamp(argument) {
    let _hygienicTemp8 = ToNumber(argument);

    if (_hygienicTemp8 instanceof AbruptCompletion) {
      return _hygienicTemp8;
    }

    if (_hygienicTemp8 instanceof Completion) {
      _hygienicTemp8 = _hygienicTemp8.Value;
    }

    const number = _hygienicTemp8.numberValue();

    if (Number.isNaN(number)) {
      return new Value(0);
    }

    if (number <= 0) {
      return new Value(0);
    }

    if (number >= 255) {
      return new Value(255);
    }

    const f = Math.floor(number);

    if (f + 0.5 < number) {
      return new Value(f + 1);
    }

    if (number < f + 0.5) {
      return new Value(f);
    }

    if (f % 2 === 1) {
      return new Value(f + 1);
    }

    return new Value(f);
  } // 7.1.12 #sec-tostring

  function ToString(argument) {
    const type = Type(argument);

    switch (type) {
      case 'Undefined':
        return new Value('undefined');

      case 'Null':
        return new Value('null');

      case 'Boolean':
        return new Value(argument === Value.true ? 'true' : 'false');

      case 'Number':
        return NumberToString(argument);

      case 'String':
        return argument;

      case 'Symbol':
        return surroundingAgent.Throw('TypeError', msg('CannotConvertSymbol', 'string'));

      case 'Object':
        {
          let primValue = ToPrimitive(argument, 'String');

          if (primValue instanceof AbruptCompletion) {
            return primValue;
          }

          if (primValue instanceof Completion) {
            primValue = primValue.Value;
          }

          return ToString(primValue);
        }

      default:
        throw new OutOfRange('ToString', {
          type,
          argument
        });
    }
  } // 7.1.12.1 #sec-tostring-applied-to-the-number-type

  function NumberToString(m) {
    if (m.isNaN()) {
      return new Value('NaN');
    }

    const mVal = m.numberValue();

    if (mVal === 0) {
      return new Value('0');
    }

    if (mVal < 0) {
      let _val = NumberToString(new Value(-mVal));

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      const str = _val.stringValue();

      return new Value(`-${str}`);
    }

    if (m.isInfinity()) {
      return new Value('Infinity');
    } // TODO: implement properly


    return new Value(`${mVal}`);
  } // 7.1.13 #sec-toobject

  function ToObject(argument) {
    const type = Type(argument);

    switch (type) {
      case 'Undefined':
        return surroundingAgent.Throw('TypeError', msg('CannotConvertToObject', 'undefined'));

      case 'Null':
        return surroundingAgent.Throw('TypeError', msg('CannotConvertToObject', 'null'));

      case 'Boolean':
        {
          const obj = ObjectCreate(surroundingAgent.intrinsic('%BooleanPrototype%'));
          obj.BooleanData = argument;
          return obj;
        }

      case 'Number':
        {
          const obj = ObjectCreate(surroundingAgent.intrinsic('%NumberPrototype%'));
          obj.NumberData = argument;
          return obj;
        }

      case 'String':
        return StringCreate(argument, surroundingAgent.intrinsic('%StringPrototype%'));

      case 'Symbol':
        {
          const obj = ObjectCreate(surroundingAgent.intrinsic('%SymbolPrototype%'));
          obj.SymbolData = argument;
          return obj;
        }

      case 'Object':
        return argument;

      default:
        throw new OutOfRange('ToObject', {
          type,
          argument
        });
    }
  } // 7.1.14 #sec-topropertykey

  function ToPropertyKey(argument) {
    let key = ToPrimitive(argument, 'String');

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    if (Type(key) === 'Symbol') {
      return key;
    }

    let _val2 = ToString(key);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    return _val2;
  } // 7.1.15 #sec-tolength

  function ToLength(argument) {
    let len = ToInteger(argument);

    if (len instanceof AbruptCompletion) {
      return len;
    }

    if (len instanceof Completion) {
      len = len.Value;
    }

    if (len.numberValue() <= 0) {
      return new Value(0);
    }

    return new Value(Math.min(len.numberValue(), 2 ** 53 - 1));
  } // 7.1.16 #sec-canonicalnumericindexstring

  function CanonicalNumericIndexString(argument) {
    Assert(Type(argument) === 'String', "Type(argument) === 'String'");

    if (argument.stringValue() === '-0') {
      return new Value(-0);
    }

    let n = ToNumber(argument);
    Assert(!(n instanceof AbruptCompletion), "");

    if (n instanceof Completion) {
      n = n.Value;
    }

    let _val3 = ToString(n);

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    if (SameValue(_val3, argument) === Value.false) {
      return Value.undefined;
    }

    return n;
  } // 7.1.17 #sec-toindex

  function ToIndex(value) {
    let index;

    if (Type(value) === 'Undefined') {
      index = new Value(0);
    } else {
      let integerIndex = ToInteger(value);

      if (integerIndex instanceof AbruptCompletion) {
        return integerIndex;
      }

      if (integerIndex instanceof Completion) {
        integerIndex = integerIndex.Value;
      }

      if (integerIndex.numberValue() < 0) {
        return surroundingAgent.Throw('RangeError', msg('NegativeIndex'));
      }

      index = ToLength(integerIndex);
      Assert(!(index instanceof AbruptCompletion), "");

      if (index instanceof Completion) {
        index = index.Value;
      }

      if (SameValueZero(integerIndex, index) === Value.false) {
        return surroundingAgent.Throw('RangeError', msg('OutOfRange', 'Index'));
      }
    }

    return index;
  }

  const typedArrayInfo = new Map([['Int8Array', {
    Intrinsic: '%Int8Array%',
    ElementType: 'Int8',
    ElementSize: 1,
    ConversionOperation: ToInt8
  }], ['Uint8Array', {
    Intrinsic: '%Uint8Array%',
    ElementType: 'Uint8',
    ElementSize: 1,
    ConversionOperation: ToUint8
  }], ['Uint8ClampedArray', {
    Intrinsic: '%Uint8ClampedArray%',
    ElementType: 'Uint8C',
    ElementSize: 1,
    ConversionOperation: ToUint8Clamp
  }], ['Int16Array', {
    Intrinsic: '%Int16Array%',
    ElementType: 'Int16',
    ElementSize: 2,
    ConversionOperation: ToInt16
  }], ['Uint16Array', {
    Intrinsic: '%Uint16Array%',
    ElementType: 'Uint16',
    ElementSize: 2,
    ConversionOperation: ToUint16
  }], ['Int32Array', {
    Intrinsic: '%Int32Array%',
    ElementType: 'Int32',
    ElementSize: 4,
    ConversionOperation: ToInt32
  }], ['Uint32Array', {
    Intrinsic: '%Uint32Array%',
    ElementType: 'Uint32',
    ElementSize: 4,
    ConversionOperation: ToUint32
  }], ['Float32Array', {
    Intrinsic: '%Float32Array%',
    ElementType: 'Float32',
    ElementSize: 4
  }], ['Float64Array', {
    Intrinsic: '%Float64Array%',
    ElementType: 'Float64',
    ElementSize: 8
  }]]);
  const numericTypeInfo = new Map([...typedArrayInfo.values()].map(info => [info.ElementType, info])); // 22.2.2.1.1 #sec-iterabletolist

  function IterableToList(items, method) {
    let iteratorRecord = GetIterator(items, 'sync', method);

    if (iteratorRecord instanceof AbruptCompletion) {
      return iteratorRecord;
    }

    if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    const values = [];
    let next = Value.true;

    while (next !== Value.false) {
      next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next !== Value.false) {
        let nextValue = IteratorValue(next);

        if (nextValue instanceof AbruptCompletion) {
          return nextValue;
        }

        if (nextValue instanceof Completion) {
          nextValue = nextValue.Value;
        }

        values.push(nextValue);
      }
    }

    return values;
  } // 22.2.3.5.1 #sec-validatetypedarray

  function ValidateTypedArray(O) {
    {
      const hygienicTemp = RequireInternalSlot(O, 'TypedArrayName');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    return buffer;
  } // 22.2.4.2.1 #sec-allocatetypedarray

  function AllocateTypedArray(constructorName, newTarget, defaultProto, length) {
    let proto = GetPrototypeFromConstructor(newTarget, defaultProto);

    if (proto instanceof AbruptCompletion) {
      return proto;
    }

    if (proto instanceof Completion) {
      proto = proto.Value;
    }

    const obj = IntegerIndexedObjectCreate(proto, ['ViewedArrayBuffer', 'TypedArrayName', 'ByteLength', 'ByteOffset', 'ArrayLength']);
    Assert(obj.ViewedArrayBuffer === Value.undefined, "obj.ViewedArrayBuffer === Value.undefined");
    obj.TypedArrayName = constructorName;

    if (length === undefined) {
      obj.ByteLength = new Value(0);
      obj.ByteOffset = new Value(0);
      obj.ArrayLength = new Value(0);
    } else {
      {
        const hygienicTemp = AllocateTypedArrayBuffer(obj, length);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    return obj;
  } // 22.2.4.2.2 #sec-allocatetypedarraybuffer

  function AllocateTypedArrayBuffer(O, length) {
    Assert(Type(O) === 'Object' && 'ViewedArrayBuffer' in O, "Type(O) === 'Object' && 'ViewedArrayBuffer' in O");
    Assert(O.ViewedArrayBuffer === Value.undefined, "O.ViewedArrayBuffer === Value.undefined");
    Assert(length.numberValue() >= 0, "length.numberValue() >= 0");
    const constructorName = O.TypedArrayName.stringValue();
    const elementSize = typedArrayInfo.get(constructorName).ElementSize;
    const byteLength = new Value(elementSize * length.numberValue());
    let data = AllocateArrayBuffer(surroundingAgent.intrinsic('%ArrayBuffer%'), byteLength);

    if (data instanceof AbruptCompletion) {
      return data;
    }

    if (data instanceof Completion) {
      data = data.Value;
    }

    O.ViewedArrayBuffer = data;
    O.ByteLength = byteLength;
    O.ByteOffset = new Value(0);
    O.ArrayLength = length;
    return O;
  } // 22.2.4.6 #typedarray-create

  function TypedArrayCreate(constructor, argumentList) {
    let newTypedArray = Construct(constructor, argumentList);

    if (newTypedArray instanceof AbruptCompletion) {
      return newTypedArray;
    }

    if (newTypedArray instanceof Completion) {
      newTypedArray = newTypedArray.Value;
    }

    {
      const hygienicTemp = ValidateTypedArray(newTypedArray);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (argumentList.length === 1 && Type(argumentList[0]) === 'Number') {
      if (newTypedArray.ArrayLength.numberValue() < argumentList[0].numberValue()) {
        return surroundingAgent.Throw('TypeError', msg('TypedArrayTooSmall', newTypedArray.ArrayLength, argumentList[0]));
      }
    }

    return newTypedArray;
  } // 22.2.4.7 #typedarray-species-create

  function TypedArraySpeciesCreate(exemplar, argumentList) {
    Assert(Type(exemplar) === 'Object' && 'TypedArrayName' in exemplar, "Type(exemplar) === 'Object' && 'TypedArrayName' in exemplar");
    const intrinsicName = typedArrayInfo.get(exemplar.TypedArrayName.stringValue()).Intrinsic;
    const defaultConstructor = surroundingAgent.intrinsic(intrinsicName);
    let constructor = SpeciesConstructor(exemplar, defaultConstructor);

    if (constructor instanceof AbruptCompletion) {
      return constructor;
    }

    if (constructor instanceof Completion) {
      constructor = constructor.Value;
    }

    return TypedArrayCreate(constructor, argumentList);
  }



  var AbstractOps = /*#__PURE__*/Object.freeze({
    CreateUnmappedArgumentsObject: CreateUnmappedArgumentsObject,
    CreateMappedArgumentsObject: CreateMappedArgumentsObject,
    ArrayCreate: ArrayCreate,
    ArraySpeciesCreate: ArraySpeciesCreate,
    ArraySetLength: ArraySetLength,
    IsConcatSpreadable: IsConcatSpreadable,
    SortCompare: SortCompare,
    CreateArrayIterator: CreateArrayIterator,
    AllocateArrayBuffer: AllocateArrayBuffer,
    IsDetachedBuffer: IsDetachedBuffer,
    DetachArrayBuffer: DetachArrayBuffer,
    CloneArrayBuffer: CloneArrayBuffer,
    RawBytesToNumber: RawBytesToNumber,
    GetValueFromBuffer: GetValueFromBuffer,
    NumberToRawBytes: NumberToRawBytes,
    SetValueInBuffer: SetValueInBuffer,
    IsSharedArrayBuffer: IsSharedArrayBuffer,
    AsyncFunctionStart: AsyncFunctionStart,
    AsyncGeneratorStart: AsyncGeneratorStart,
    AsyncGeneratorEnqueue: AsyncGeneratorEnqueue,
    AsyncGeneratorYield: AsyncGeneratorYield,
    isLeadingSurrogate: isLeadingSurrogate,
    isTrailingSurrogate: isTrailingSurrogate,
    isIntegerIndex: isIntegerIndex,
    isArrayIndex: isArrayIndex,
    GetViewValue: GetViewValue,
    SetViewValue: SetViewValue,
    Day: Day,
    msPerDay: msPerDay,
    TimeWithinDay: TimeWithinDay,
    DaysInYear: DaysInYear,
    DayFromYear: DayFromYear,
    TimeFromYear: TimeFromYear,
    msPerAverageYear: msPerAverageYear,
    YearFromTime: YearFromTime,
    InLeapYear: InLeapYear,
    MonthFromTime: MonthFromTime,
    DayWithinYear: DayWithinYear,
    DateFromTime: DateFromTime,
    WeekDay: WeekDay,
    LocalTZA: LocalTZA,
    LocalTime: LocalTime,
    UTC: UTC,
    HourFromTime: HourFromTime,
    MinFromTime: MinFromTime,
    SecFromTime: SecFromTime,
    msFromTime: msFromTime,
    HoursPerDay: HoursPerDay,
    MinutesPerHour: MinutesPerHour,
    SecondsPerMinute: SecondsPerMinute,
    msPerSecond: msPerSecond,
    msPerMinute: msPerMinute,
    msPerHour: msPerHour,
    MakeTime: MakeTime,
    MakeDay: MakeDay,
    MakeDate: MakeDate,
    TimeClip: TimeClip,
    GetActiveScriptOrModule: GetActiveScriptOrModule,
    ResolveBinding: ResolveBinding,
    GetThisEnvironment: GetThisEnvironment,
    ResolveThisBinding: ResolveThisBinding,
    GetNewTarget: GetNewTarget,
    GetGlobalObject: GetGlobalObject,
    OrdinaryCallEvaluateBody: OrdinaryCallEvaluateBody,
    FunctionAllocate: FunctionAllocate,
    FunctionInitialize: FunctionInitialize,
    FunctionCreate: FunctionCreate,
    GeneratorFunctionCreate: GeneratorFunctionCreate,
    AsyncGeneratorFunctionCreate: AsyncGeneratorFunctionCreate,
    AsyncFunctionCreate: AsyncFunctionCreate,
    MakeConstructor: MakeConstructor,
    MakeClassConstructor: MakeClassConstructor,
    MakeMethod: MakeMethod,
    SetFunctionName: SetFunctionName,
    SetFunctionLength: SetFunctionLength,
    CreateBuiltinFunction: CreateBuiltinFunction,
    PrepareForTailCall: PrepareForTailCall,
    GeneratorStart: GeneratorStart,
    GeneratorValidate: GeneratorValidate,
    GeneratorResume: GeneratorResume,
    GeneratorResumeAbrupt: GeneratorResumeAbrupt,
    GetGeneratorKind: GetGeneratorKind,
    GeneratorYield: GeneratorYield,
    PerformEval: PerformEval,
    GetIterator: GetIterator,
    IteratorNext: IteratorNext,
    IteratorComplete: IteratorComplete,
    IteratorValue: IteratorValue,
    IteratorStep: IteratorStep,
    IteratorClose: IteratorClose,
    AsyncIteratorClose: AsyncIteratorClose,
    CreateIterResultObject: CreateIterResultObject,
    CreateListIteratorRecord: CreateListIteratorRecord,
    CreateAsyncFromSyncIterator: CreateAsyncFromSyncIterator,
    AsyncFromSyncIteratorContinuation: AsyncFromSyncIteratorContinuation,
    ModuleNamespaceCreate: ModuleNamespaceCreate,
    InnerModuleLinking: InnerModuleLinking,
    InnerModuleEvaluation: InnerModuleEvaluation,
    GetModuleNamespace: GetModuleNamespace,
    Assert: Assert,
    RequireInternalSlot: RequireInternalSlot,
    sourceTextMatchedBy: sourceTextMatchedBy,
    isStrictModeCode: isStrictModeCode,
    Get: Get,
    GetV: GetV,
    Set: Set$1,
    CreateDataProperty: CreateDataProperty,
    CreateMethodProperty: CreateMethodProperty,
    CreateDataPropertyOrThrow: CreateDataPropertyOrThrow,
    DefinePropertyOrThrow: DefinePropertyOrThrow,
    DeletePropertyOrThrow: DeletePropertyOrThrow,
    GetMethod: GetMethod,
    HasProperty: HasProperty,
    HasOwnProperty: HasOwnProperty,
    Call: Call,
    Construct: Construct,
    SetIntegrityLevel: SetIntegrityLevel,
    TestIntegrityLevel: TestIntegrityLevel,
    CreateArrayFromList: CreateArrayFromList,
    LengthOfArrayLike: LengthOfArrayLike,
    CreateListFromArrayLike: CreateListFromArrayLike,
    Invoke: Invoke,
    OrdinaryHasInstance: OrdinaryHasInstance,
    SpeciesConstructor: SpeciesConstructor,
    EnumerableOwnPropertyNames: EnumerableOwnPropertyNames,
    GetFunctionRealm: GetFunctionRealm,
    CopyDataProperties: CopyDataProperties,
    OrdinaryGetPrototypeOf: OrdinaryGetPrototypeOf,
    OrdinarySetPrototypeOf: OrdinarySetPrototypeOf,
    OrdinaryIsExtensible: OrdinaryIsExtensible,
    OrdinaryPreventExtensions: OrdinaryPreventExtensions,
    OrdinaryGetOwnProperty: OrdinaryGetOwnProperty,
    OrdinaryDefineOwnProperty: OrdinaryDefineOwnProperty,
    IsCompatiblePropertyDescriptor: IsCompatiblePropertyDescriptor,
    ValidateAndApplyPropertyDescriptor: ValidateAndApplyPropertyDescriptor,
    OrdinaryHasProperty: OrdinaryHasProperty,
    OrdinaryGet: OrdinaryGet,
    OrdinarySet: OrdinarySet,
    OrdinarySetWithOwnDescriptor: OrdinarySetWithOwnDescriptor,
    OrdinaryDelete: OrdinaryDelete,
    OrdinaryOwnPropertyKeys: OrdinaryOwnPropertyKeys,
    ObjectCreate: ObjectCreate,
    OrdinaryCreateFromConstructor: OrdinaryCreateFromConstructor,
    GetPrototypeFromConstructor: GetPrototypeFromConstructor,
    IntegerIndexedObjectCreate: IntegerIndexedObjectCreate,
    IntegerIndexedElementGet: IntegerIndexedElementGet,
    IntegerIndexedElementSet: IntegerIndexedElementSet,
    PromiseCapabilityRecord: PromiseCapabilityRecord,
    PromiseReactionRecord: PromiseReactionRecord,
    CreateResolvingFunctions: CreateResolvingFunctions,
    NewPromiseCapability: NewPromiseCapability,
    IsPromise: IsPromise,
    PromiseReactionJob: PromiseReactionJob,
    PromiseResolve: PromiseResolve,
    PerformPromiseThen: PerformPromiseThen,
    GetBase: GetBase,
    GetReferencedName: GetReferencedName,
    IsStrictReference: IsStrictReference,
    HasPrimitiveBase: HasPrimitiveBase,
    IsPropertyReference: IsPropertyReference,
    IsUnresolvableReference: IsUnresolvableReference,
    IsSuperReference: IsSuperReference,
    GetValue: GetValue,
    PutValue: PutValue,
    GetThisValue: GetThisValue,
    InitializeReferencedBinding: InitializeReferencedBinding,
    RegExpAlloc: RegExpAlloc,
    RegExpInitialize: RegExpInitialize,
    RegExpCreate: RegExpCreate,
    EscapeRegExpPattern: EscapeRegExpPattern,
    UTF16Encoding: UTF16Encoding,
    UTF16Decode: UTF16Decode,
    CodePointAt: CodePointAt,
    IsAccessorDescriptor: IsAccessorDescriptor,
    IsDataDescriptor: IsDataDescriptor,
    IsGenericDescriptor: IsGenericDescriptor,
    FromPropertyDescriptor: FromPropertyDescriptor,
    ToPropertyDescriptor: ToPropertyDescriptor,
    CompletePropertyDescriptor: CompletePropertyDescriptor,
    CreateByteDataBlock: CreateByteDataBlock,
    CopyDataBlockBytes: CopyDataBlockBytes,
    StringCreate: StringCreate,
    StringGetOwnProperty: StringGetOwnProperty,
    SymbolDescriptiveString: SymbolDescriptiveString,
    RequireObjectCoercible: RequireObjectCoercible,
    IsArray: IsArray,
    IsCallable: IsCallable,
    IsConstructor: IsConstructor,
    IsExtensible: IsExtensible,
    IsInteger: IsInteger,
    IsPropertyKey: IsPropertyKey,
    IsRegExp: IsRegExp,
    IsStringPrefix: IsStringPrefix,
    SameValue: SameValue,
    SameValueZero: SameValueZero,
    SameValueNonNumber: SameValueNonNumber,
    AbstractRelationalComparison: AbstractRelationalComparison,
    AbstractEqualityComparison: AbstractEqualityComparison,
    StrictEqualityComparison: StrictEqualityComparison,
    ToPrimitive: ToPrimitive,
    OrdinaryToPrimitive: OrdinaryToPrimitive,
    ToBoolean: ToBoolean,
    ToNumber: ToNumber,
    ToInteger: ToInteger,
    ToInt32: ToInt32,
    ToUint32: ToUint32,
    ToInt16: ToInt16,
    ToUint16: ToUint16,
    ToInt8: ToInt8,
    ToUint8: ToUint8,
    ToUint8Clamp: ToUint8Clamp,
    ToString: ToString,
    NumberToString: NumberToString,
    ToObject: ToObject,
    ToPropertyKey: ToPropertyKey,
    ToLength: ToLength,
    CanonicalNumericIndexString: CanonicalNumericIndexString,
    ToIndex: ToIndex,
    typedArrayInfo: typedArrayInfo,
    numericTypeInfo: numericTypeInfo,
    IterableToList: IterableToList,
    ValidateTypedArray: ValidateTypedArray,
    AllocateTypedArray: AllocateTypedArray,
    AllocateTypedArrayBuffer: AllocateTypedArrayBuffer,
    TypedArrayCreate: TypedArrayCreate,
    TypedArraySpeciesCreate: TypedArraySpeciesCreate
  });

  class LexicalEnvironment {
    constructor() {
      this.EnvironmentRecord = undefined;
      this.outerEnvironmentReference = undefined;
    }

  }
  class EnvironmentRecord {} // https://tc39.github.io/ecma262/#sec-lexical-environments

  class DeclarativeEnvironmentRecord extends EnvironmentRecord {
    constructor() {
      super();
      this.bindings = new Map();
    }

    HasBinding(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");

      if (this.bindings.has(N)) {
        return Value.true;
      }

      return Value.false;
    }

    CreateMutableBinding(N, D) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      this.bindings.set(N, {
        indirect: false,
        initialized: false,
        mutable: true,
        strict: undefined,
        deletable: D === Value.true,
        value: undefined
      });
    }

    CreateImmutableBinding(N, S) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      this.bindings.set(N, {
        indirect: false,
        initialized: false,
        mutable: false,
        strict: S === Value.true,
        deletable: false,
        value: undefined
      });
    }

    InitializeBinding(N, V) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const binding = this.bindings.get(N);
      Assert(binding !== undefined, "binding !== undefined");
      binding.value = V;
      binding.initialized = true;
    }

    SetMutableBinding(N, V, S) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;

      if (!this.bindings.has(N)) {
        if (S === Value.true) {
          return surroundingAgent.Throw('ReferenceError', msg('NotDefined', N));
        }

        envRec.CreateMutableBinding(N, true);
        envRec.InitializeBinding(N, V);
        return new NormalCompletion(undefined);
      }

      const binding = this.bindings.get(N);

      if (binding.strict === true) {
        S = Value.true;
      }

      if (binding.initialized === false) {
        return surroundingAgent.Throw('ReferenceError', msg('NotDefined', N));
      } else if (binding.mutable === true) {
        binding.value = V;
      } else if (S === Value.true) {
        return surroundingAgent.Throw('TypeError', 'assignment to a constant variable');
      }

      return new NormalCompletion(undefined);
    }

    GetBindingValue(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const binding = this.bindings.get(N);

      if (binding.initialized === false) {
        return surroundingAgent.Throw('ReferenceError', msg('NotDefined', N));
      }

      return binding.value;
    }

    DeleteBinding(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const binding = this.bindings.get(N);

      if (binding.deletable === false) {
        return Value.false;
      }

      this.bindings.delete(N);
      return Value.true;
    }

    HasThisBinding() {
      return Value.false;
    }

    HasSuperBinding() {
      return Value.false;
    }

    WithBaseObject() {
      return Value.undefined;
    }

  } // 8.1.1.2 #sec-object-environment-records

  class ObjectEnvironmentRecord extends EnvironmentRecord {
    constructor(BindingObject) {
      super();
      this.bindingObject = BindingObject;
      this.withEnvironment = false;
    } // 8.1.1.2.1 #sec-object-environment-records-hasbinding-n


    HasBinding(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const bindings = envRec.bindingObject;
      let foundBinding = HasProperty(bindings, N);

      if (foundBinding instanceof AbruptCompletion) {
        return foundBinding;
      }

      if (foundBinding instanceof Completion) {
        foundBinding = foundBinding.Value;
      }

      if (foundBinding === Value.false) {
        return Value.false;
      }

      if (envRec.withEnvironment === false) {
        return Value.true;
      }

      let unscopables = Get(bindings, wellKnownSymbols.unscopables);

      if (unscopables instanceof AbruptCompletion) {
        return unscopables;
      }

      if (unscopables instanceof Completion) {
        unscopables = unscopables.Value;
      }

      if (Type(unscopables) === 'Object') {
        let _hygienicTemp = Get(unscopables, N);

        if (_hygienicTemp instanceof AbruptCompletion) {
          return _hygienicTemp;
        }

        if (_hygienicTemp instanceof Completion) {
          _hygienicTemp = _hygienicTemp.Value;
        }

        const blocked = ToBoolean(_hygienicTemp);

        if (blocked === Value.true) {
          return Value.false;
        }
      }

      return Value.true;
    } // 8.1.1.2.2 #sec-object-environment-records-createmutablebinding-n-d


    CreateMutableBinding(N, D) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const bindings = envRec.bindingObject;
      return DefinePropertyOrThrow(bindings, N, Descriptor({
        Value: Value.undefined,
        Writable: Value.true,
        Enumerable: Value.true,
        Configurable: D
      }));
    } // 8.1.1.2.3 #sec-object-environment-records-createimmutablebinding-n-s


    CreateImmutableBinding()
    /* N, S */
    {
      throw new Error('CreateImmutableBinding got called on an object Environment Record');
    } // 8.1.1.2.4 #sec-object-environment-records-initializebinding-n-v


    InitializeBinding(N, V) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this; // Record that the binding for N in envRec has been initialized.
      // According to the spec this is an unnecessary step for object Environment Records.

      return envRec.SetMutableBinding(N, V, Value.false);
    } // 8.1.1.2.5 #sec-object-environment-records-setmutablebinding-n-v-s


    SetMutableBinding(N, V, S) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const bindings = envRec.bindingObject;
      return Set$1(bindings, N, V, S);
    } // 8.1.1.2.6 #sec-object-environment-records-getbindingvalue-n-s


    GetBindingValue(N, S) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const bindings = envRec.bindingObject;
      let value = HasProperty(bindings, N);

      if (value instanceof AbruptCompletion) {
        return value;
      }

      if (value instanceof Completion) {
        value = value.Value;
      }

      if (value === Value.false) {
        if (S === Value.false) {
          return Value.undefined;
        } else {
          return surroundingAgent.Throw('ReferenceError', msg('NotDefined', N));
        }
      }

      return Get(bindings, N);
    } // 8.1.1.2.7 #sec-object-environment-records-deletebinding-n


    DeleteBinding(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const bindings = envRec.bindingObject;
      return bindings.Delete(N);
    } // 8.1.1.2.8 #sec-object-environment-records-hasthisbinding


    HasThisBinding() {
      return Value.false;
    } // 8.1.1.2.9 #sec-object-environment-records-hassuperbinding


    HasSuperBinding() {
      return Value.false;
    } // 8.1.1.2.10 #sec-object-environment-records-withbaseobject


    WithBaseObject() {
      const envRec = this;

      if (envRec.withEnvironment) {
        return envRec.bindingObject;
      }

      return Value.undefined;
    }

  }
  class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {
    constructor() {
      super();
      this.ThisValue = undefined;
      this.ThisBindingValue = undefined;
      this.FunctionObject = undefined;
      this.HomeObject = Value.undefined;
      this.NewTarget = undefined;
    }

    BindThisValue(V) {
      const envRec = this;
      Assert(envRec.ThisBindingStatus !== 'lexical', "envRec.ThisBindingStatus !== 'lexical'");

      if (envRec.ThisBindingStatus === 'initialized') {
        return surroundingAgent.Throw('ReferenceError', 'this is not defined');
      }

      envRec.ThisValue = V;
      envRec.ThisBindingStatus = 'initialized';
      return V;
    }

    HasThisBinding() {
      const envRec = this;

      if (envRec.ThisBindingStatus === 'lexical') {
        return Value.false;
      } else {
        return Value.true;
      }
    }

    HasSuperBinding() {
      const envRec = this;

      if (envRec.ThisBindingStatus === 'lexical') {
        return Value.false;
      }

      if (Type(envRec.HomeObject) === 'Undefined') {
        return Value.false;
      }

      return Value.true;
    }

    GetThisBinding() {
      const envRec = this;
      Assert(envRec.ThisBindingStatus !== 'lexical', "envRec.ThisBindingStatus !== 'lexical'");

      if (envRec.ThisBindingStatus === 'uninitialized') {
        return surroundingAgent.Throw('ReferenceError', 'this is not defined');
      }

      return envRec.ThisValue;
    }

    GetSuperBase() {
      const envRec = this;
      const home = envRec.HomeObject;

      if (Type(home) === 'Undefined') {
        return Value.undefined;
      }

      Assert(Type(home) === 'Object', "Type(home) === 'Object'");
      return home.GetPrototypeOf();
    }

  }
  class GlobalEnvironmentRecord extends EnvironmentRecord {
    constructor() {
      super();
      this.ObjectRecord = undefined;
      this.GlobalThisValue = undefined;
      this.DeclarativeRecord = undefined;
      this.VarNames = undefined;
    }

    HasBinding(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const DclRec = envRec.DeclarativeRecord;

      if (DclRec.HasBinding(N) === Value.true) {
        return Value.true;
      }

      const ObjRec = envRec.ObjectRecord;
      return ObjRec.HasBinding(N);
    }

    CreateMutableBinding(N, D) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const DclRec = envRec.DeclarativeRecord;

      if (DclRec.HasBinding(N) === Value.true) {
        return surroundingAgent.Throw('TypeError', msg('AlreadyDeclared', N));
      }

      return DclRec.CreateMutableBinding(N, D);
    }

    CreateImmutableBinding(N, S) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const DclRec = envRec.DeclarativeRecord;

      if (DclRec.HasBinding(N) === Value.true) {
        return surroundingAgent.Throw('TypeError', msg('AlreadyDeclared', N));
      }

      return DclRec.CreateImmutableBinding(N, S);
    }

    InitializeBinding(N, V) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const DclRec = envRec.DeclarativeRecord;

      if (DclRec.HasBinding(N) === Value.true) {
        return DclRec.InitializeBinding(N, V);
      }

      const ObjRec = envRec.ObjectRecord;
      return ObjRec.InitializeBinding(N, V);
    }

    SetMutableBinding(N, V, S) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const DclRec = envRec.DeclarativeRecord;

      if (DclRec.HasBinding(N) === Value.true) {
        return DclRec.SetMutableBinding(N, V, S);
      }

      const ObjRec = envRec.ObjectRecord;
      return ObjRec.SetMutableBinding(N, V, S);
    }

    GetBindingValue(N, S) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const DclRec = envRec.DeclarativeRecord;

      if (DclRec.HasBinding(N) === Value.true) {
        return DclRec.GetBindingValue(N, S);
      }

      const ObjRec = envRec.ObjectRecord;
      return ObjRec.GetBindingValue(N, S);
    }

    DeleteBinding(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const DclRec = this.DeclarativeRecord;

      if (DclRec.HasBinding(N) === Value.true) {
        return DclRec.DeleteBinding(N);
      }

      const ObjRec = envRec.ObjectRecord;
      const globalObject = ObjRec.bindingObject;
      let existingProp = HasOwnProperty(globalObject, N);

      if (existingProp instanceof AbruptCompletion) {
        return existingProp;
      }

      if (existingProp instanceof Completion) {
        existingProp = existingProp.Value;
      }

      if (existingProp === Value.true) {
        let status = ObjRec.DeleteBinding(N);

        if (status instanceof AbruptCompletion) {
          return status;
        }

        if (status instanceof Completion) {
          status = status.Value;
        }

        if (status === Value.true) {
          const varNames = envRec.VarNames;

          if (varNames.includes(N)) {
            varNames.splice(varNames.indexOf(N), 1);
          }
        }

        return status;
      }

      return Value.true;
    }

    HasThisBinding() {
      return Value.true;
    }

    HasSuperBinding() {
      return Value.false;
    }

    WithBaseObject() {
      return Value.undefined;
    }

    GetThisBinding() {
      const envRec = this;
      return envRec.GlobalThisValue;
    }

    HasVarDeclaration(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const varDeclaredNames = envRec.VarNames;

      if (varDeclaredNames.includes(N)) {
        return Value.true;
      }

      return Value.false;
    }

    HasLexicalDeclaration(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const DclRec = envRec.DeclarativeRecord;
      return DclRec.HasBinding(N);
    }

    HasRestrictedGlobalProperty(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const ObjRec = envRec.ObjectRecord;
      const globalObject = ObjRec.bindingObject;
      let existingProp = globalObject.GetOwnProperty(N);

      if (existingProp instanceof AbruptCompletion) {
        return existingProp;
      }

      if (existingProp instanceof Completion) {
        existingProp = existingProp.Value;
      }

      if (existingProp === Value.undefined) {
        return Value.false;
      }

      if (existingProp.Configurable === Value.true) {
        return Value.false;
      }

      return Value.true;
    }

    CanDeclareGlobalVar(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const ObjRec = envRec.ObjectRecord;
      const globalObject = ObjRec.bindingObject;
      let hasProperty = HasOwnProperty(globalObject, N);

      if (hasProperty instanceof AbruptCompletion) {
        return hasProperty;
      }

      if (hasProperty instanceof Completion) {
        hasProperty = hasProperty.Value;
      }

      if (hasProperty === Value.true) {
        return Value.true;
      }

      return IsExtensible(globalObject);
    }

    CanDeclareGlobalFunction(N) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const ObjRec = envRec.ObjectRecord;
      const globalObject = ObjRec.bindingObject;
      let existingProp = globalObject.GetOwnProperty(N);

      if (existingProp instanceof AbruptCompletion) {
        return existingProp;
      }

      if (existingProp instanceof Completion) {
        existingProp = existingProp.Value;
      }

      if (Type(existingProp) === 'Undefined') {
        return IsExtensible(globalObject);
      }

      if (existingProp.Configurable === Value.true) {
        return Value.true;
      }

      if (IsDataDescriptor(existingProp) === true && existingProp.Writable === Value.true && existingProp.Enumerable === Value.true) {
        return Value.true;
      }

      return Value.false;
    }

    CreateGlobalVarBinding(N, D) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const ObjRec = envRec.ObjectRecord;
      const globalObject = ObjRec.bindingObject;
      let hasProperty = HasOwnProperty(globalObject, N);

      if (hasProperty instanceof AbruptCompletion) {
        return hasProperty;
      }

      if (hasProperty instanceof Completion) {
        hasProperty = hasProperty.Value;
      }

      let extensible = IsExtensible(globalObject);

      if (extensible instanceof AbruptCompletion) {
        return extensible;
      }

      if (extensible instanceof Completion) {
        extensible = extensible.Value;
      }

      if (hasProperty === Value.false && extensible === Value.true) {
        {
          const hygienicTemp = ObjRec.CreateMutableBinding(N, D);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        {
          const hygienicTemp = ObjRec.InitializeBinding(N, Value.undefined);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }

      const varDeclaredNames = envRec.VarNames;

      if (!varDeclaredNames.includes(N)) {
        varDeclaredNames.push(N);
      }

      return new NormalCompletion(undefined);
    }

    CreateGlobalFunctionBinding(N, V, D) {
      Assert(IsPropertyKey(N), "IsPropertyKey(N)");
      const envRec = this;
      const ObjRec = envRec.ObjectRecord;
      const globalObject = ObjRec.bindingObject;
      let existingProp = globalObject.GetOwnProperty(N);

      if (existingProp instanceof AbruptCompletion) {
        return existingProp;
      }

      if (existingProp instanceof Completion) {
        existingProp = existingProp.Value;
      }

      let desc;

      if (Type(existingProp) === 'Undefined' || existingProp.Configurable === Value.true) {
        desc = Descriptor({
          Value: V,
          Writable: Value.true,
          Enumerable: Value.true,
          Configurable: D
        });
      } else {
        desc = Descriptor({
          Value: V
        });
      }

      {
        const hygienicTemp = DefinePropertyOrThrow(globalObject, N, desc);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      } // Record that the binding for N in ObjRec has been initialized.

      {
        const hygienicTemp = Set$1(globalObject, N, V, Value.false);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      const varDeclaredNames = envRec.VarNames;

      if (!varDeclaredNames.includes(N)) {
        varDeclaredNames.push(N);
      }

      return new NormalCompletion(undefined);
    }

  }
  class ModuleEnvironmentRecord extends DeclarativeEnvironmentRecord {
    GetBindingValue(N, S) {
      Assert(S === Value.true, "S === Value.true");
      const envRec = this;
      Assert(envRec.bindings.has(N), "envRec.bindings.has(N)");
      const binding = envRec.bindings.get(N);

      if (binding.indirect === true) {
        const [M, N2] = binding.target;
        const targetEnv = M.Environment;

        if (targetEnv === Value.undefined) {
          return surroundingAgent.Throw('ReferenceError', 'targetEnv is undefined');
        }

        const targetER = targetEnv.EnvironmentRecord;
        return targetER.GetBindingValue(N2, Value.true);
      }

      if (binding.initialized === false) {
        return surroundingAgent.Throw('ReferenceError', msg('NotDefined', N));
      }

      return binding.value;
    }

    DeleteBinding() {
      Assert(false, 'This method is never invoked. See #sec-delete-operator-static-semantics-early-errors');
    }

    HasThisBinding() {
      return Value.true;
    }

    GetThisBinding() {
      return Value.undefined;
    }

    CreateImportBinding(N, M, N2) {
      const envRec = this;
      Assert(envRec.HasBinding(N) === Value.false, "envRec.HasBinding(N) === Value.false");
      Assert(M instanceof AbstractModuleRecord, "M instanceof AbstractModuleRecord"); // Assert: When M.[[Environment]] is instantiated it will have a direct binding for N2.

      envRec.bindings.set(N, {
        indirect: true,
        target: [M, N2],
        initialized: true
      });
      return new NormalCompletion(undefined);
    }

  } // 8.1.2.1 #sec-getidentifierreference

  function GetIdentifierReference(lex, name, strict) {
    if (Type(lex) === 'Null') {
      return new Reference({
        BaseValue: Value.undefined,
        ReferencedName: name,
        StrictReference: strict
      });
    }

    const envRec = lex.EnvironmentRecord;
    let exists = envRec.HasBinding(name);

    if (exists instanceof AbruptCompletion) {
      return exists;
    }

    if (exists instanceof Completion) {
      exists = exists.Value;
    }

    if (exists === Value.true) {
      return new Reference({
        BaseValue: envRec,
        ReferencedName: name,
        StrictReference: strict
      });
    } else {
      const outer = lex.outerEnvironmentReference;
      return GetIdentifierReference(outer, name, strict);
    }
  } // 8.1.2.2 #sec-newdeclarativeenvironment

  function NewDeclarativeEnvironment(E) {
    const env = new LexicalEnvironment();
    const envRec = new DeclarativeEnvironmentRecord();
    env.EnvironmentRecord = envRec;
    env.outerEnvironmentReference = E;
    return env;
  } // 8.1.2.3 #sec-newobjectenvironment

  function NewObjectEnvironment(O, E) {
    const env = new LexicalEnvironment();
    const envRec = new ObjectEnvironmentRecord(O);
    env.EnvironmentRecord = envRec;
    env.outerEnvironmentReference = E;
    return env;
  } // 8.1.2.4 #sec-newfunctionenvironment

  function NewFunctionEnvironment(F, newTarget) {
    Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
    Assert(Type(newTarget) === 'Undefined' || Type(newTarget) === 'Object', "Type(newTarget) === 'Undefined' || Type(newTarget) === 'Object'");
    const env = new LexicalEnvironment();
    const envRec = new FunctionEnvironmentRecord();
    envRec.FunctionObject = F;

    if (F.ThisMode === 'lexical') {
      envRec.ThisBindingStatus = 'lexical';
    } else {
      envRec.ThisBindingStatus = 'uninitialized';
    }

    const home = F.HomeObject;
    envRec.HomeObject = home;
    envRec.NewTarget = newTarget;
    env.EnvironmentRecord = envRec;
    env.outerEnvironmentReference = F.Environment;
    return env;
  } // 8.1.2.5 NewGlobalEnvironment

  function NewGlobalEnvironment(G, thisValue) {
    const env = new LexicalEnvironment();
    const objRec = new ObjectEnvironmentRecord(G);
    const dclRec = new DeclarativeEnvironmentRecord();
    const globalRec = new GlobalEnvironmentRecord();
    globalRec.ObjectRecord = objRec;
    globalRec.GlobalThisValue = thisValue;
    globalRec.DeclarativeRecord = dclRec;
    globalRec.VarNames = [];
    env.EnvironmentRecord = globalRec;
    env.outerEnvironmentReference = Value.null;
    return env;
  } // 8.1.2.6 #sec-newmoduleenvironment

  function NewModuleEnvironment(E) {
    const env = new LexicalEnvironment();
    const envRec = new ModuleEnvironmentRecord();
    env.EnvironmentRecord = envRec;
    env.outerEnvironmentReference = E;
    return env;
  }

  class ImportEntryRecord {
    constructor({
      ModuleRequest,
      ImportName,
      LocalName
    }) {
      Assert(Type(ModuleRequest) === 'String', "Type(ModuleRequest) === 'String'");
      Assert(Type(ImportName) === 'String', "Type(ImportName) === 'String'");
      Assert(Type(LocalName) === 'String', "Type(LocalName) === 'String'");
      this.ModuleRequest = ModuleRequest;
      this.ImportName = ImportName;
      this.LocalName = LocalName;
    }

  } // #exportentry-record

  class ExportEntryRecord {
    constructor({
      ExportName,
      ModuleRequest,
      ImportName,
      LocalName
    }) {
      Assert(Type(ExportName) === 'String' || Type(ExportName) === 'Null', "Type(ExportName) === 'String' || Type(ExportName) === 'Null'");
      Assert(Type(ModuleRequest) === 'String' || Type(ModuleRequest) === 'Null', "Type(ModuleRequest) === 'String' || Type(ModuleRequest) === 'Null'");
      Assert(Type(ImportName) === 'String' || Type(ImportName) === 'Null', "Type(ImportName) === 'String' || Type(ImportName) === 'Null'");
      Assert(Type(LocalName) === 'String' || Type(LocalName) === 'Null', "Type(LocalName) === 'String' || Type(LocalName) === 'Null'");
      this.ExportName = ExportName;
      this.ModuleRequest = ModuleRequest;
      this.ImportName = ImportName;
      this.LocalName = LocalName;
    }

  } // #resolvedbinding-record

  class ResolvedBindingRecord {
    constructor({
      Module,
      BindingName
    }) {
      Assert(Module instanceof AbstractModuleRecord, "Module instanceof AbstractModuleRecord");
      Assert(Type(BindingName) === 'String', "Type(BindingName) === 'String'");
      this.Module = Module;
      this.BindingName = BindingName;
    }

  } // 15.2.1.15 #sec-abstract-module-records

  class AbstractModuleRecord {
    constructor({
      Realm,
      Environment,
      Namespace,
      HostDefined
    }) {
      this.Realm = Realm;
      this.Environment = Environment;
      this.Namespace = Namespace;
      this.HostDefined = HostDefined;
    }

  } // 15.2.1.16 #sec-cyclic-module-records

  class CyclicModuleRecord extends AbstractModuleRecord {
    constructor(init) {
      super(init);
      this.Status = init.Status;
      this.EvaluationError = init.EvaluationError;
      this.DFSIndex = init.DFSIndex;
      this.DFSAncestorIndex = init.DFSAncestorIndex;
      this.RequestedModules = init.RequestedModules;
    } // 15.2.1.16.1 #sec-moduledeclarationlinking


    Link() {
      const module = this;
      Assert(module.Status !== 'linking' && module.Status !== 'evaluating', "module.Status !== 'linking' && module.Status !== 'evaluating'");
      const stack = [];
      const result = InnerModuleLinking(module, stack, 0);

      if (result instanceof AbruptCompletion) {
        for (const m of stack) {
          Assert(m.Status === 'linking', "m.Status === 'linking'");
          m.Status = 'unlinked';
          m.Environment = Value.undefined;
          m.DFSIndex = Value.undefined;
          m.DFSAncestorIndex = Value.undefined;
        }

        Assert(module.Status === 'unlinked', "module.Status === 'unlinked'");
        return result;
      }

      Assert(module.Status === 'linked' || module.Status === 'evaluated', "module.Status === 'linked' || module.Status === 'evaluated'");
      Assert(stack.length === 0, "stack.length === 0");
      return Value.undefined;
    } // 15.2.1.16.2 #sec-moduleevaluation


    Evaluate() {
      const module = this;
      Assert(module.Status === 'linked' || module.Status === 'evaluated', "module.Status === 'linked' || module.Status === 'evaluated'");
      const stack = [];
      const result = InnerModuleEvaluation(module, stack, 0);

      if (result instanceof AbruptCompletion) {
        for (const m of stack) {
          Assert(m.Status === 'evaluating', "m.Status === 'evaluating'");
          m.Status = 'evaluated';
          m.EvaluationError = result;
        }

        Assert(module.Status === 'evaluated' && module.EvaluationError === result, "module.Status === 'evaluated' && module.EvaluationError === result");
        return result;
      }

      Assert(module.Status === 'evaluated' && module.EvaluationError === Value.undefined, "module.Status === 'evaluated' && module.EvaluationError === Value.undefined");
      Assert(stack.length === 0, "stack.length === 0");
      return Value.undefined;
    }

  } // 15.2.1.17 #sec-source-text-module-records

  class SourceTextModuleRecord extends CyclicModuleRecord {
    constructor(init) {
      super(init);
      ({
        ECMAScriptCode: this.ECMAScriptCode,
        ImportEntries: this.ImportEntries,
        LocalExportEntries: this.LocalExportEntries,
        IndirectExportEntries: this.IndirectExportEntries,
        StarExportEntries: this.StarExportEntries
      } = init);
    } // 15.2.1.17.2 #sec-getexportednames


    GetExportedNames(exportStarSet) {
      const module = this;

      if (!exportStarSet) {
        exportStarSet = [];
      }

      Assert(Array.isArray(exportStarSet) && exportStarSet.every(e => e instanceof SourceTextModuleRecord), "Array.isArray(exportStarSet) && exportStarSet.every((e) => e instanceof SourceTextModuleRecord)");

      if (exportStarSet.includes(module)) {
        // Assert: We've reached the starting point of an import * circularity.
        return [];
      }

      exportStarSet.push(module);
      const exportedNames = [];

      for (const e of module.LocalExportEntries) {
        // Assert: module provides the direct binding for this export.
        exportedNames.push(e.ExportName);
      }

      for (const e of module.IndirectExportEntries) {
        // Assert: module imports a specific binding for this export.
        exportedNames.push(e.ExportName);
      }

      for (const e of module.StarExportEntries) {
        let requestedModule = HostResolveImportedModule(module, e.ModuleRequest);

        if (requestedModule instanceof AbruptCompletion) {
          return requestedModule;
        }

        if (requestedModule instanceof Completion) {
          requestedModule = requestedModule.Value;
        }

        let starNames = requestedModule.GetExportedNames(exportStarSet);

        if (starNames instanceof AbruptCompletion) {
          return starNames;
        }

        if (starNames instanceof Completion) {
          starNames = starNames.Value;
        }

        for (const n of starNames) {
          if (SameValue(n, new Value('default')) === Value.false) {
            if (!exportedNames.includes(n)) {
              exportedNames.push(n);
            }
          }
        }
      }

      return exportedNames;
    } // 15.2.1.17.3 #sec-resolveexport


    ResolveExport(exportName, resolveSet) {
      const module = this;

      if (!resolveSet) {
        resolveSet = [];
      }

      Assert(Array.isArray(resolveSet) && resolveSet.every(e => 'Module' in e && 'ExportName' in e), "Array.isArray(resolveSet) && resolveSet.every((e) => 'Module' in e && 'ExportName' in e)");

      for (const r of resolveSet) {
        if (module === r.Module && SameValue(exportName, r.ExportName) === Value.true) {
          // Assert: This is a circular import request.
          return null;
        }
      }

      resolveSet.push({
        Module: module,
        ExportName: exportName
      });

      for (const e of module.LocalExportEntries) {
        if (SameValue(exportName, e.ExportName) === Value.true) {
          // Assert: module provides the direct binding for this export.
          return new ResolvedBindingRecord({
            Module: module,
            BindingName: e.LocalName
          });
        }
      }

      for (const e of module.IndirectExportEntries) {
        if (SameValue(exportName, e.ExportName) === Value.true) {
          let importedModule = HostResolveImportedModule(module, e.ModuleRequest);

          if (importedModule instanceof AbruptCompletion) {
            return importedModule;
          }

          if (importedModule instanceof Completion) {
            importedModule = importedModule.Value;
          }

          return importedModule.ResolveExport(e.ImportName, resolveSet);
        }
      }

      if (SameValue(exportName, new Value('default')) === Value.true) {
        // Assert: A default export was not explicitly defined by this module.
        return null; // NOTE: A default export cannot be provided by an export *.
      }

      let starResolution = null;

      for (const e of module.StarExportEntries) {
        let importedModule = HostResolveImportedModule(module, e.ModuleRequest);

        if (importedModule instanceof AbruptCompletion) {
          return importedModule;
        }

        if (importedModule instanceof Completion) {
          importedModule = importedModule.Value;
        }

        let resolution = importedModule.ResolveExport(exportName, resolveSet);

        if (resolution instanceof AbruptCompletion) {
          return resolution;
        }

        if (resolution instanceof Completion) {
          resolution = resolution.Value;
        }

        if (resolution === 'ambiguous') {
          return 'ambiguous';
        }

        if (resolution !== null) {
          Assert(resolution instanceof ResolvedBindingRecord, "resolution instanceof ResolvedBindingRecord");

          if (starResolution === null) {
            starResolution = resolution;
          } else {
            // Assert: There is more than one * import that includes the requested name.
            if (resolution.Module !== starResolution.Module || SameValue(resolution.BindingName, starResolution.BindingName) === Value.false) {
              return 'ambiguous';
            }
          }
        }
      }

      return starResolution;
    } // 15.2.1.17.4 #sec-source-text-module-record-initialize-environment


    InitializeEnvironment() {
      const module = this;

      for (const e of module.IndirectExportEntries) {
        let resolution = module.ResolveExport(e.ExportName);

        if (resolution instanceof AbruptCompletion) {
          return resolution;
        }

        if (resolution instanceof Completion) {
          resolution = resolution.Value;
        }

        if (resolution === null || resolution === 'ambiguous') {
          return surroundingAgent.Throw('SyntaxError', msg('ResolutionNullOrAmbiguous', resolution, e.ExportName, module));
        } // Assert: resolution is a ResolvedBinding Record.

      } // Assert: All named exports from module are resolvable.


      const realm = module.Realm;
      Assert(realm !== Value.undefined, "realm !== Value.undefined");
      const env = NewModuleEnvironment(realm.GlobalEnv);
      module.Environment = env;
      const envRec = env.EnvironmentRecord;

      for (const ie of module.ImportEntries) {
        let importedModule = HostResolveImportedModule(module, ie.ModuleRequest);
        Assert(!(importedModule instanceof AbruptCompletion), "");

        if (importedModule instanceof Completion) {
          importedModule = importedModule.Value;
        }

        if (ie.ImportName === new Value('*')) {
          let namespace = GetModuleNamespace(importedModule);

          if (namespace instanceof AbruptCompletion) {
            return namespace;
          }

          if (namespace instanceof Completion) {
            namespace = namespace.Value;
          }

          Assert(!(envRec.CreateImmutableBinding(ie.LocalName, Value.true) instanceof AbruptCompletion), "");
          envRec.InitializeBinding(ie.LocalName, namespace);
        } else {
          let resolution = importedModule.ResolveExport(ie.ImportName);

          if (resolution instanceof AbruptCompletion) {
            return resolution;
          }

          if (resolution instanceof Completion) {
            resolution = resolution.Value;
          }

          if (resolution === null || resolution === 'ambiguous') {
            return surroundingAgent.Throw('SyntaxError', msg('ResolutionNullOrAmbiguous', resolution, ie.ImportName, importedModule));
          }

          envRec.CreateImportBinding(ie.LocalName, resolution.Module, resolution.BindingName);
        }
      }

      const code = module.ECMAScriptCode.body;
      const varDeclarations = VarScopedDeclarations_ModuleBody(code);
      const declaredVarNames = [];

      for (const d of varDeclarations) {
        for (const dn of BoundNames_VariableDeclaration(d).map(Value)) {
          if (!declaredVarNames.includes(dn)) {
            Assert(!(envRec.CreateMutableBinding(dn, Value.false) instanceof AbruptCompletion), "");
            envRec.InitializeBinding(dn, Value.undefined);
            declaredVarNames.push(dn);
          }
        }
      }

      const lexDeclarations = LexicallyScopedDeclarations_Module(code);

      for (const d of lexDeclarations) {
        for (const dn of BoundNames_ModuleItem(d).map(Value)) {
          if (IsConstantDeclaration(d)) {
            {
              const hygienicTemp = envRec.CreateImmutableBinding(dn, Value.true);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          } else {
            {
              const hygienicTemp = envRec.CreateMutableBinding(dn, Value.false);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          }

          if (isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)) {
            const fo = InstantiateFunctionObject(d, env);
            envRec.InitializeBinding(dn, fo);
          }
        }
      }

      return new NormalCompletion(undefined);
    } // 15.2.1.17.5 #sec-source-text-module-record-execute-module


    ExecuteModule() {
      const module = this;
      const moduleCtx = new ExecutionContext();
      moduleCtx.Function = Value.null;
      Assert(module.Realm !== Value.undefined, "module.Realm !== Value.undefined");
      moduleCtx.Realm = module.Realm;
      moduleCtx.ScriptOrModule = module; // Assert: module has been linked and declarations in its module environment have been instantiated.

      moduleCtx.VariableEnvironment = module.Environment;
      moduleCtx.LexicalEnvironment = module.Environment; // Suspend the currently running execution context.

      surroundingAgent.executionContextStack.push(moduleCtx);
      const result = Evaluate_Module(module.ECMAScriptCode.body);
      surroundingAgent.executionContextStack.pop(moduleCtx); // Resume the context that is now on the top of the execution context stack as the running execution context.

      return Completion(result);
    }

  }

  const HasOwnProperty$1 = Function.call.bind(Object.prototype.hasOwnProperty);

  function deepFreeze(o) {
    Object.freeze(o);
    Object.getOwnPropertyNames(o).forEach(prop => {
      if (HasOwnProperty$1(o, prop) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {
        deepFreeze(o[prop]);
      }
    });
    return o;
  } // Copied from acorn/src/scopeflags.js.


  const SCOPE_FUNCTION = 2;
  const SCOPE_ASYNC = 4;
  const SCOPE_GENERATOR = 8;

  function functionFlags(async, generator) {
    // eslint-disable-next-line no-bitwise
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
  }

  const optionalChainToken = {
    label: '?.'
  };
  const nullishCoalescingToken = {
    label: '??',
    binop: 0
  };
  const Parser = acorn.Parser.extend(P => class Parse262 extends P {
    constructor(options = {}, source) {
      super({ ...options,
        ecmaVersion: 2020,
        // adds needed ParenthesizedExpression production
        preserveParens: true,
        locations: true
      }, source);

      if (options.strict === true) {
        this.strict = true;
      }
    }

    parse() {
      const body = super.parse();
      deepFreeze(body);
      return body;
    }

    finishNode(node, type) {
      node.strict = this.strict;
      const ret = super.finishNode(node, type);

      node.sourceText = () => this.input.slice(node.start, node.end);

      if (ret.type === 'MethodDefinition' && ret.static) {
        ret.start += 7; // don't include `static` in the source text
      }

      return ret;
    }

    getTokenFromCode(code) {
      if (code === 63) {
        this.pos += 1;

        if (surroundingAgent.feature('OptionalChaining')) {
          const next = this.input.charCodeAt(this.pos);

          if (next === 46) {
            const nextNext = this.input.charCodeAt(this.pos + 1);

            if (nextNext < 48 || nextNext > 57) {
              this.pos += 1;
              return this.finishToken(optionalChainToken);
            }
          }
        }

        if (surroundingAgent.feature('NullishCoalescing')) {
          const next = this.input.charCodeAt(this.pos);

          if (next === 63) {
            this.pos += 1;
            return this.finishToken(nullishCoalescingToken, nullishCoalescingToken.label);
          }
        }

        return this.finishToken(acorn.tokTypes.question);
      }

      return super.getTokenFromCode(code);
    }

    parseSubscripts(base, startPos, startLoc, noCalls) {
      if (noCalls) {
        return super.parseSubscripts(base, startPos, startLoc, noCalls);
      }

      const maybeAsyncArrow = base.type === 'Identifier' && base.name === 'async' && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === 'async';
      /**
       * Optional chains are hard okay?
       *
       *  a.b?.c
       *  @=>
       *  OptionalExpression a.b?.c
       *      MemberExpression a.b
       *      OptionalChain ?.c
       *
       *  a.b?.c.d.e
       *  @=>
       *  OptionalExpressoin a.b?.c.d.e
       *      MemberExpression a.b
       *      OptionalChain ?.c.d.e
       *          OptionalChain ?.c.d
       *              OptionalChain ?.c
       *              Identifier .d
       *          Identifier .e
       *
       *  a.b?.c.d
       *  @=>
       *  OptionalExpression a.b?.c.d
       *      MemberExpression a.b
       *      OptionalChain ?.c.d
       *          OptionalChain ?.c
       *          Identifier .d
       *
       *  a.b?.c.d?.e.f
       *  @=>
       *  OptionalExpression a.b?.c.d?.e.f
       *      OptionalExpression a.b?.c.d
       *          MemberExpression a.b
       *          OptionalChain ?.c.d
       *              OptionalChain ?.c
       *              Identifier .d
       *      OptionalChain ?.e.f
       *          OptionalChain ?.e
       *          Identifier .f
       */

      while (true) {
        if (this.eat(optionalChainToken)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.chain = this.parseOptionalChain(startPos, startLoc);
          base = this.finishNode(node, 'OptionalExpression');
        } else {
          const element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);

          if (element === base) {
            break;
          }

          base = element;
        }
      }

      return base;
    }

    parseOptionalChain(startPos, startLoc) {
      let base = this.startNodeAt(startPos, startLoc);

      if (this.eat(acorn.tokTypes.bracketL)) {
        base.property = this.parseExpression();
        this.expect(acorn.tokTypes.bracketR);
        base.computed = true;
        base = this.finishNode(base, 'OptionalChain');
      } else if (this.eat(acorn.tokTypes.parenL)) {
        base.arguments = this.parseExprList(acorn.tokTypes.parenR, this.options.ecmaVersion >= 8, false, undefined);
      } else {
        base.property = this.parseIdent(true);
        base.computed = false;
      }

      base.base = null;
      base = this.finishNode(base, 'OptionalChain');

      while (true) {
        const computed = this.eat(acorn.tokTypes.bracketL);

        if (computed || this.eat(acorn.tokTypes.dot)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.base = base;
          node.property = computed ? this.parseExpression() : this.parseIdent(true);

          if (computed) {
            this.expect(acorn.tokTypes.bracketR);
          }

          node.computed = computed;
          base = this.finishNode(node, 'OptionalChain');
        } else if (this.eat(acorn.tokTypes.parenL)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.base = base;
          node.arguments = this.parseExprList(acorn.tokTypes.parenR, this.options.ecmaVersion >= 8, false, undefined);
          base = this.finishNode(node, 'OptionalChain');
        } else if (this.eat(acorn.tokTypes.backQuote)) {
          this.raise(this.start, 'Cannot tag an optional chain');
        } else {
          break;
        }
      }

      return base;
    }

    buildBinary(startPos, startLoc, left, right, op, logical) {
      if (op === '??') {
        if (left.type === 'LogicalExpression') {
          this.raise(left.start, 'Cannot mix &&, ||, and ??');
        }

        if (right.type === 'LogicalExpression') {
          this.raise(right.start, 'Cannot mix &&, ||, and ??');
        }
      } else if (logical) {
        if (left.operator === '??') {
          this.raise(left.start, 'Cannot mix &&, ||, and ??');
        }

        if (right.operator === '??') {
          this.raise(right.start, 'Cannot mix &&, ||, and ??');
        }
      }

      return super.buildBinary(startPos, startLoc, left, right, op, logical);
    } // Adapted from several different places in Acorn.


    static parseFunctionBody(sourceText, async, generator) {
      const parser = new Parser({
        sourceType: 'script'
      }, sourceText); // Parser.prototype.parse()

      const node = parser.startNode();
      parser.nextToken(); // Parser.prototype.parseFunction()

      parser.initFunction(node);
      parser.enterScope(functionFlags(async, generator)); // Parser.prototype.parseBlock()

      const body = [];

      while (!parser.eat(acorn.tokTypes.eof)) {
        const stmt = parser.parseStatement(null);
        body.push(stmt);
      } // Parser.prototype.parseFunctionBody()


      parser.adaptDirectivePrologue(body);
      deepFreeze(body);
      return body;
    }

  });
  function ParseAsFunctionBody(sourceText) {
    return Parser.parseFunctionBody(sourceText, false, false);
  }
  function ParseAsGeneratorBody(sourceText) {
    return Parser.parseFunctionBody(sourceText, false, true);
  }
  function ParseAsAsyncFunctionBody(sourceText) {
    return Parser.parseFunctionBody(sourceText, true, false);
  }
  function ParseAsAsyncGeneratorBody(sourceText) {
    return Parser.parseFunctionBody(sourceText, true, true);
  } // Adapted from several different places in Acorn.
  // `strict` refers to ContainsUseStrict of the corresponding function body.

  function ParseAsFormalParameters(sourceText, strict, enableAwait, enableYield) {
    // Adapted from different places in Acorn.
    const parser = new Parser({
      sourceType: 'script'
    }, sourceText);
    parser.strict = strict; // Parser.prototype.parse()

    const node = parser.startNode();
    parser.nextToken(); // Parser.prototype.parseFunction()

    parser.initFunction(node);
    parser.enterScope(functionFlags(enableAwait, enableYield)); // Parser.prototype.parseFunctionParams()

    const params = parser.parseBindingList(acorn.tokTypes.eof, false, true);
    parser.checkYieldAwaitInDefaultParams(); // Parser.prototype.parseFunctionBody()

    const simple = parser.isSimpleParamList(params);

    if (strict && !simple) {
      parser.raiseRecoverable(node.start, 'Illegal \'use strict\' directive in function with non-simple parameter list');
    }

    parser.checkParams({
      params
    }, !strict && simple);
    deepFreeze(params);
    return params;
  }
  const emptyConstructorNode = Parser.parse('(class { constructor() {} })').body[0].expression.expression.body.body[0];
  const forwardingConstructorNode = Parser.parse('(class extends X { constructor(...args) { super(...args); } })').body[0].expression.expression.body.body[0];

  function forwardError(fn) {
    try {
      return fn();
    } catch (e) {
      if (e.name === 'SyntaxError') {
        return [surroundingAgent.Throw('SyntaxError', e.message).Value];
      } else {
        throw e;
      }
    }
  }

  function ParseScript(sourceText, realm, hostDefined = {}, strict) {
    const body = forwardError(() => Parser.parse(sourceText, {
      sourceType: 'script',
      strict
    }));

    if (Array.isArray(body)) {
      return body;
    }

    return {
      Realm: realm,
      Environment: undefined,
      ECMAScriptCode: body,
      HostDefined: hostDefined
    };
  }
  function ParseModule(sourceText, realm, hostDefined = {}) {
    // Assert: sourceText is an ECMAScript source text (see clause 10).
    const body = forwardError(() => Parser.parse(sourceText, {
      sourceType: 'module'
    }));

    if (Array.isArray(body)) {
      return body;
    }

    const requestedModules = ModuleRequests_ModuleItemList(body.body);
    const importEntries = ImportEntries_ModuleItemList(body.body);
    const importedBoundNames = ImportedLocalNames(importEntries);
    const indirectExportEntries = [];
    const localExportEntries = [];
    const starExportEntries = [];
    const exportEntries = ExportEntries_ModuleItemList(body.body);

    for (const ee of exportEntries) {
      if (ee.ModuleRequest === Value.null) {
        if (!importedBoundNames.includes(ee.LocalName)) {
          localExportEntries.push(ee);
        } else {
          const ie = importEntries.find(e => e.LocalName === ee.LocalName);

          if (ie.ImportName === new Value('*')) {
            // Assert: This is a re-export of an imported module namespace object.
            localExportEntries.push(ee);
          } else {
            indirectExportEntries.push(new ExportEntryRecord({
              ModuleRequest: ie.ModuleRequest,
              ImportName: ie.ImportName,
              LocalName: Value.null,
              ExportName: ee.ExportName
            }));
          }
        }
      } else if (ee.ImportName === new Value('*')) {
        starExportEntries.push(ee);
      } else {
        indirectExportEntries.push(ee);
      }
    }

    return new SourceTextModuleRecord({
      Realm: realm,
      Environment: Value.undefined,
      Namespace: Value.undefined,
      Status: 'unlinked',
      EvaluationError: Value.undefined,
      HostDefined: hostDefined,
      ECMAScriptCode: body,
      RequestedModules: requestedModules,
      ImportEntries: importEntries,
      LocalExportEntries: localExportEntries,
      IndirectExportEntries: indirectExportEntries,
      StarExportEntries: starExportEntries,
      DFSIndex: Value.undefined,
      DFSAncestorIndex: Value.undefined
    });
  }

  const FEATURES = Object.freeze([{
    name: 'globalThis',
    url: 'https://github.com/tc39/proposal-global'
  }, {
    name: 'Promise.allSettled',
    url: 'https://github.com/tc39/proposal-promise-allSettled'
  }, {
    name: 'OptionalChaining',
    url: 'https://github.com/tc39/proposal-optional-chaining'
  }, {
    name: 'NullishCoalescing',
    url: 'https://github.com/tc39/proposal-nullish-coalescing'
  }].map(Object.freeze));
  class Agent {
    constructor(options = {}) {
      this.LittleEndian = Value.true;
      this.CanBlock = true;
      this.Signifier = Agent.Increment;
      Agent.Increment += 1;
      this.IsLockFree1 = true;
      this.IsLockFree2 = true;
      this.CandidateExecution = undefined;
      this.executionContextStack = [];
      const stackPop = this.executionContextStack.pop;

      this.executionContextStack.pop = function pop(...args) {
        const popped = stackPop.call(this);

        if (args.length === 1) {
          Assert(args[0] === popped, "args[0] === popped");
        }
      };

      this.jobQueue = [];
      this.hostDefinedOptions = { ...options,
        features: FEATURES.reduce((acc, {
          name
        }) => {
          if (options.features) {
            acc[name] = options.features.includes(name);
          } else {
            acc[name] = false;
          }

          return acc;
        }, {})
      };
    }

    get runningExecutionContext() {
      return this.executionContextStack[this.executionContextStack.length - 1];
    }

    get currentRealmRecord() {
      return this.runningExecutionContext.Realm;
    }

    get activeFunctionObject() {
      return this.runningExecutionContext.Function;
    }

    intrinsic(name) {
      return this.currentRealmRecord.Intrinsics[name];
    }

    Throw(type, message) {
      const cons = this.currentRealmRecord.Intrinsics[`%${type}%`];
      const error = Construct(cons, message ? [new Value(message)] : []);
      error.hostTrace = new Error().stack;
      return new ThrowCompletion(error);
    }

    feature(name) {
      return this.hostDefinedOptions.features[name];
    }

  }
  Agent.Increment = 0;
  let surroundingAgent;
  function setSurroundingAgent(a) {
    surroundingAgent = a;
  }
  class ExecutionContext {
    constructor() {
      this.codeEvaluationState = undefined;
      this.Function = undefined;
      this.Realm = undefined;
      this.ScriptOrModule = undefined;
      this.LexicalEnvironment = undefined;
    }

    copy() {
      const e = new ExecutionContext();
      e.codeEvaluationState = this.codeEvaluationState;
      e.Function = this.Function;
      e.Realm = this.Realm;
      e.ScriptOrModule = this.ScriptOrModule;
      e.LexicalEnvironment = this.LexicalEnvironment;
      return e;
    }

  } // 8.4.1 #sec-enqueuejob

  function EnqueueJob(queueName, job, args) {
    const callerContext = surroundingAgent.runningExecutionContext;
    const callerRealm = callerContext.Realm;
    const callerScriptOrModule = callerContext.ScriptOrModule;
    const pending = {
      Job: job,
      Arguments: args,
      Realm: callerRealm,
      ScriptOrModule: callerScriptOrModule,
      HostDefined: undefined
    };
    surroundingAgent.jobQueue.push(pending);
  } // 8.5 #sec-initializehostdefinedrealm

  function ScriptEvaluation(scriptRecord) {
    const globalEnv = scriptRecord.Realm.GlobalEnv;
    const scriptCtx = new ExecutionContext();
    scriptCtx.Function = Value.null;
    scriptCtx.Realm = scriptRecord.Realm;
    scriptCtx.ScriptOrModule = scriptRecord;
    scriptCtx.VariableEnvironment = globalEnv;
    scriptCtx.LexicalEnvironment = globalEnv;
    scriptCtx.HostDefined = scriptRecord.HostDefined; // Suspend runningExecutionContext

    surroundingAgent.executionContextStack.push(scriptCtx);
    const scriptBody = scriptRecord.ECMAScriptCode.body;
    let result = EnsureCompletion(GlobalDeclarationInstantiation(scriptBody, globalEnv));

    if (result.Type === 'normal') {
      result = Evaluate_Script(scriptBody);
    }

    if (result.Type === 'normal' && !result.Value) {
      result = new NormalCompletion(Value.undefined);
    } // Suspend scriptCtx


    surroundingAgent.executionContextStack.pop(scriptCtx); // Resume(surroundingAgent.runningExecutionContext);

    return result;
  } // 15.1.12 #sec-scriptevaluationjob

  function ScriptEvaluationJob(sourceText, hostDefined) {
    const realm = surroundingAgent.currentRealmRecord;
    const s = ParseScript(sourceText, realm, hostDefined);

    if (Array.isArray(s)) {
      HostReportErrors(s);
      return new NormalCompletion(undefined);
    }

    return ScriptEvaluation(s);
  } // 15.2.1.22 #sec-toplevelmoduleevaluationjob

  function HostReportErrors(errorList) {
    if (surroundingAgent.hostDefinedOptions.reportError) {
      errorList.forEach(error => {
        surroundingAgent.hostDefinedOptions.reportError(error);
      });
    }
  }
  function HostEnsureCanCompileStrings(callerRealm, calleeRealm) {
    if (surroundingAgent.hostDefinedOptions.ensureCanCompileStrings !== undefined) {
      {
        const hygienicTemp = surroundingAgent.hostDefinedOptions.ensureCanCompileStrings(callerRealm, calleeRealm);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    return new NormalCompletion(undefined);
  }
  function HostPromiseRejectionTracker(promise, operation) {
    if (surroundingAgent.hostDefinedOptions.promiseRejectionTracker) {
      Assert(!(surroundingAgent.hostDefinedOptions.promiseRejectionTracker(promise, operation) instanceof AbruptCompletion), "");
    }
  }
  function HostHasSourceTextAvailable(func) {
    if (surroundingAgent.hostDefinedOptions.hasSourceTextAvailable) {
      let _val = surroundingAgent.hostDefinedOptions.hasSourceTextAvailable(func);

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      return _val;
    }

    return Value.true;
  }
  function HostResolveImportedModule(referencingScriptOrModule, specifier) {
    const Realm = referencingScriptOrModule.Realm || surroundingAgent.currentRealmRecord;

    if (Realm.HostDefined.resolveImportedModule) {
      if (!Realm.HostDefined.moduleMap) {
        Realm.HostDefined.moduleMap = new Map();
      }

      specifier = specifier.stringValue();
      const key = `${referencingScriptOrModule.HostDefined ? referencingScriptOrModule.HostDefined.specifier : ''}\u0000${specifier}`;

      if (Realm.HostDefined.moduleMap.has(key)) {
        return Realm.HostDefined.moduleMap.get(key);
      }

      const publicModule = referencingScriptOrModule.HostDefined ? referencingScriptOrModule.HostDefined.public : null;
      let apiModule = Realm.HostDefined.resolveImportedModule(publicModule, specifier);

      if (apiModule instanceof AbruptCompletion) {
        return apiModule;
      }

      if (apiModule instanceof Completion) {
        apiModule = apiModule.Value;
      }

      Realm.HostDefined.moduleMap.set(key, apiModule.module);
      return apiModule.module;
    }

    return surroundingAgent.Throw('Error', msg('CouldNotResolveModule', specifier));
  }

  function FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion) {
    if (completion instanceof AbruptCompletion) {
      Assert(!(Call(promiseCapability.Reject, Value.undefined, [completion.Value]) instanceof AbruptCompletion), "");
    } else {
      Assert(completion instanceof NormalCompletion && completion.Value === Value.undefined, "completion instanceof NormalCompletion && completion.Value === Value.undefined");
      let moduleRecord = HostResolveImportedModule(referencingScriptOrModule, specifier);
      Assert(!(moduleRecord instanceof AbruptCompletion), "");

      if (moduleRecord instanceof Completion) {
        moduleRecord = moduleRecord.Value;
      }

      // Assert: Evaluate has already been invoked on moduleRecord and successfully completed.
      const namespace = EnsureCompletion(GetModuleNamespace(moduleRecord));

      if (namespace instanceof AbruptCompletion) {
        Assert(!(Call(promiseCapability.Reject, Value.undefined, [namespace.Value]) instanceof AbruptCompletion), "");
      } else {
        Assert(!(Call(promiseCapability.Resolve, Value.undefined, [namespace.Value]) instanceof AbruptCompletion), "");
      }
    }
  }

  function HostImportModuleDynamically(referencingScriptOrModule, specifier, promiseCapability) {
    let completion = EnsureCompletion(HostResolveImportedModule(referencingScriptOrModule, specifier));

    if (!(completion instanceof AbruptCompletion)) {
      const module = completion.Value;

      if (module instanceof CyclicModuleRecord) {
        if (module.Status !== 'linking' && module.Status !== 'evaluating') {
          completion = EnsureCompletion(module.Link());
        } // !!! WILLFUL VIOLATION !!!
        // The spec requires that we call module.Evaluate() here,
        // but if module.Status is 'evaluating', an assertion will fail.


        if (!(completion instanceof AbruptCompletion) && (module.Status === 'linked' || module.Status === 'evaluated')) {
          completion = EnsureCompletion(module.Evaluate());
        }
      } else {
        completion = EnsureCompletion(module.Link());

        if (!(completion instanceof AbruptCompletion)) {
          completion = EnsureCompletion(module.Evaluate());
        }
      }
    }

    if (!(completion instanceof AbruptCompletion)) {
      completion = new NormalCompletion(Value.undefined);
    }

    FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion);
    return new NormalCompletion(Value.undefined);
  }

  function Value(value) {
    if (new.target !== undefined && new.target !== Value) {
      return undefined;
    }

    if (typeof value === 'string') {
      if (stringMap.has(value)) {
        return stringMap.get(value);
      }

      const s = new StringValue(value);
      stringMap.set(value, s);
      return s;
    }

    if (typeof value === 'number') {
      // Redundant value === 0 added to work around a bug in some older versions
      // of V8.
      // Refs: https://github.com/nodejs/node/issues/25268
      // Refs: https://crbug.com/903043
      if (value === 0 && Object.is(value, -0)) {
        return negativeZero;
      }

      if (numberMap.has(value)) {
        return numberMap.get(value);
      }

      const s = new NumberValue(value);
      numberMap.set(value, s);
      return s;
    }

    if (typeof value === 'function') {
      return new BuiltinFunctionValue(value);
    }

    throw new OutOfRange('new Value', value);
  }
  class PrimitiveValue extends Value {}
  class UndefinedValue extends PrimitiveValue {}
  class NullValue extends PrimitiveValue {}
  class BooleanValue extends PrimitiveValue {
    constructor(v) {
      super();
      this.value = v;
    }

    [Symbol.for('nodejs.util.inspect.custom')]() {
      return `Boolean { ${this.value} }`;
    }

  }
  Object.defineProperties(Value, {
    undefined: {
      value: new UndefinedValue(),
      configurable: false,
      writable: false
    },
    null: {
      value: new NullValue(),
      configurable: false,
      writable: false
    },
    true: {
      value: new BooleanValue(true),
      configurable: false,
      writable: false
    },
    false: {
      value: new BooleanValue(false),
      configurable: false,
      writable: false
    }
  });
  class NumberValue extends PrimitiveValue {
    constructor(number) {
      super();
      this.number = number;
    }

    numberValue() {
      return this.number;
    }

    isNaN() {
      return Number.isNaN(this.number);
    }

    isInfinity() {
      return !Number.isFinite(this.number) && !this.isNaN();
    }

  }
  const negativeZero = new NumberValue(-0);
  class StringValue extends PrimitiveValue {
    constructor(string) {
      super();
      this.string = string;
    }

    stringValue() {
      return this.string;
    }

  }
  class SymbolValue extends PrimitiveValue {
    constructor(Description) {
      super();
      this.Description = Description;
    }

  }
  const wellKnownSymbols = Object.create(null);

  for (const name of ['asyncIterator', 'hasInstance', 'isConcatSpreadable', 'iterator', 'match', 'matchAll', 'replace', 'search', 'species', 'split', 'toPrimitive', 'toStringTag', 'unscopables']) {
    const sym = new SymbolValue(new StringValue(`Symbol.${name}`));
    wellKnownSymbols[name] = sym;
  }

  Object.freeze(wellKnownSymbols);
  class ObjectValue extends Value {
    constructor() {
      super();
      this.Prototype = undefined;
      this.Extensible = undefined;
      this.IsClassPrototype = false;
      this.properties = new Map();
    }

    GetPrototypeOf() {
      return OrdinaryGetPrototypeOf(this);
    }

    SetPrototypeOf(V) {
      return OrdinarySetPrototypeOf(this, V);
    }

    IsExtensible() {
      return OrdinaryIsExtensible(this);
    }

    PreventExtensions() {
      return OrdinaryPreventExtensions(this);
    }

    GetOwnProperty(P) {
      return OrdinaryGetOwnProperty(this, P);
    }

    DefineOwnProperty(P, Desc) {
      return OrdinaryDefineOwnProperty(this, P, Desc);
    }

    HasProperty(P) {
      return OrdinaryHasProperty(this, P);
    }

    Get(P, Receiver) {
      return OrdinaryGet(this, P, Receiver);
    }

    Set(P, V, Receiver) {
      return OrdinarySet(this, P, V, Receiver);
    }

    Delete(P) {
      return OrdinaryDelete(this, P);
    }

    OwnPropertyKeys() {
      return OrdinaryOwnPropertyKeys(this);
    }

  }
  ObjectValue.prototype.isOrdinary = true;
  class ArrayExoticObjectValue extends ObjectValue {
    DefineOwnProperty(P, Desc) {
      const A = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");

      if (Type(P) === 'String' && P.stringValue() === 'length') {
        return ArraySetLength(A, Desc);
      } else if (isArrayIndex(P)) {
        const oldLenDesc = OrdinaryGetOwnProperty(A, new Value('length'));
        Assert(Type(oldLenDesc) !== 'Undefined' && !IsAccessorDescriptor(oldLenDesc), "Type(oldLenDesc) !== 'Undefined' && !IsAccessorDescriptor(oldLenDesc)");
        const oldLen = oldLenDesc.Value;
        let index = ToUint32(P);
        Assert(!(index instanceof AbruptCompletion), "");

        if (index instanceof Completion) {
          index = index.Value;
        }

        if (index.numberValue() >= oldLen.numberValue() && oldLenDesc.Writable === Value.false) {
          return Value.false;
        }

        let succeeded = OrdinaryDefineOwnProperty(A, P, Desc);
        Assert(!(succeeded instanceof AbruptCompletion), "");

        if (succeeded instanceof Completion) {
          succeeded = succeeded.Value;
        }

        if (succeeded === Value.false) {
          return Value.false;
        }

        if (index.numberValue() >= oldLen.numberValue()) {
          oldLenDesc.Value = new Value(index.numberValue() + 1);
          const succeeded = OrdinaryDefineOwnProperty(A, new Value('length'), oldLenDesc); // eslint-disable-line no-shadow

          Assert(succeeded === Value.true, "succeeded === Value.true");
        }

        return Value.true;
      }

      return OrdinaryDefineOwnProperty(A, P, Desc);
    }

  }
  ArrayExoticObjectValue.prototype.isOrdinary = false;
  class FunctionValue extends ObjectValue {
    static [Symbol.hasInstance](V) {
      return V instanceof ObjectValue && typeof V.Call === 'function';
    }

  }

  function nativeCall(F, argumentsList, thisArgument, newTarget) {
    return F.nativeFunction(argumentsList, {
      thisValue: thisArgument || Value.undefined,
      NewTarget: newTarget || Value.undefined
    });
  }

  class BuiltinFunctionValue extends FunctionValue {
    constructor(nativeFunction, isConstructor = Value.false) {
      super();
      this.nativeFunction = nativeFunction;
      this.Realm = undefined;
      this.ScriptOrModule = undefined;

      if (isConstructor === Value.true) {
        this.Construct = function Construct(argumentsList, newTarget) {
          const F = this; // const callerContext = surroundingAgent.runningExecutionContext;
          // If callerContext is not already suspended, suspend callerContext.

          const calleeContext = new ExecutionContext();
          calleeContext.Function = F;
          const calleeRealm = F.Realm;
          calleeContext.Realm = calleeRealm;
          calleeContext.ScriptOrModule = F.ScriptOrModule; // 8. Perform any necessary implementation-defined initialization of calleeContext.

          surroundingAgent.executionContextStack.push(calleeContext);
          const result = nativeCall(F, argumentsList, undefined, newTarget); // Remove calleeContext from the execution context stack and
          // restore callerContext as the running execution context.

          surroundingAgent.executionContextStack.pop(calleeContext);
          return result;
        };
      }
    }

    Call(thisArgument, argumentsList) {
      const F = this; // const callerContext = surroundingAgent.runningExecutionContext;
      // If callerContext is not already suspended, suspend callerContext.

      const calleeContext = new ExecutionContext();
      calleeContext.Function = F;
      const calleeRealm = F.Realm;
      calleeContext.Realm = calleeRealm;
      calleeContext.ScriptOrModule = F.ScriptOrModule; // 8. Perform any necessary implementation-defined initialization of calleeContext.

      surroundingAgent.executionContextStack.push(calleeContext);
      const result = nativeCall(F, argumentsList, thisArgument, Value.undefined); // Remove calleeContext from the execution context stack and
      // restore callerContext as the running execution context.

      surroundingAgent.executionContextStack.pop(calleeContext);
      return result;
    }

  }
  BuiltinFunctionValue.prototype.isOrdinary = false; // 9.4.3 #sec-string-exotic-objects

  class StringExoticObjectValue extends ObjectValue {
    constructor() {
      super();
      this.StringData = undefined;
    }

    GetOwnProperty(P) {
      const S = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      const desc = OrdinaryGetOwnProperty(S, P);

      if (Type(desc) !== 'Undefined') {
        return desc;
      }

      let _val = StringGetOwnProperty(S, P);

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      return _val;
    }

    DefineOwnProperty(P, Desc) {
      const S = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      let stringDesc = StringGetOwnProperty(S, P);
      Assert(!(stringDesc instanceof AbruptCompletion), "");

      if (stringDesc instanceof Completion) {
        stringDesc = stringDesc.Value;
      }

      if (Type(stringDesc) !== 'Undefined') {
        const extensible = S.Extensible;

        let _val2 = IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc);

        Assert(!(_val2 instanceof AbruptCompletion), "");

        if (_val2 instanceof Completion) {
          _val2 = _val2.Value;
        }

        return _val2;
      }

      let _val3 = OrdinaryDefineOwnProperty(S, P, Desc);

      Assert(!(_val3 instanceof AbruptCompletion), "");

      if (_val3 instanceof Completion) {
        _val3 = _val3.Value;
      }

      return _val3;
    }

    OwnPropertyKeys() {
      const O = this;
      const keys = [];
      const str = O.StringData;
      Assert(Type(str) === 'String', "Type(str) === 'String'");
      const len = str.stringValue().length;

      for (let i = 0; i < len; i += 1) {
        keys.push(new Value(`${i}`));
      } // For each own property key P of O such that P is an array index and
      // ToInteger(P)  len, in ascending numeric index order, do
      //   Add P as the last element of keys.


      for (const P of O.properties.keys()) {
        // This is written with two nested ifs to work around https://github.com/devsnek/engine262/issues/24
        if (isArrayIndex(P)) {
          let _val4 = ToInteger(P);

          Assert(!(_val4 instanceof AbruptCompletion), "");

          if (_val4 instanceof Completion) {
            _val4 = _val4.Value;
          }

          if (_val4.numberValue() >= len) {
            keys.push(P);
          }
        }
      } // For each own property key P of O such that Type(P) is String and
      // P is not an array index, in ascending chronological order of property creation, do
      //   Add P as the last element of keys.


      for (const P of O.properties.keys()) {
        if (Type(P) === 'String' && isArrayIndex(P) === false) {
          keys.push(P);
        }
      } // For each own property key P of O such that Type(P) is Symbol,
      // in ascending chronological order of property creation, do
      //   Add P as the last element of keys.


      for (const P of O.properties.keys()) {
        if (Type(P) === 'Symbol') {
          keys.push(P);
        }
      }

      return keys;
    }

  }
  StringExoticObjectValue.prototype.isOrdinary = false; // 9.4.4 #sec-arguments-exotic-objects

  class ArgumentsExoticObjectValue extends ObjectValue {
    constructor() {
      super();
      this.ParameterMap = undefined;
    }

    GetOwnProperty(P) {
      const args = this;
      const desc = OrdinaryGetOwnProperty(args, P);

      if (desc === Value.undefined) {
        return desc;
      }

      const map = args.ParameterMap;
      let isMapped = HasOwnProperty(map, P);
      Assert(!(isMapped instanceof AbruptCompletion), "");

      if (isMapped instanceof Completion) {
        isMapped = isMapped.Value;
      }

      if (isMapped === Value.true) {
        desc.Value = Get(map, P);
      }

      return desc;
    }

    DefineOwnProperty(P, Desc) {
      const args = this;
      const map = args.ParameterMap;
      let isMapped = HasOwnProperty(map, P);
      Assert(!(isMapped instanceof AbruptCompletion), "");

      if (isMapped instanceof Completion) {
        isMapped = isMapped.Value;
      }

      let newArgDesc = Desc;

      if (isMapped === Value.true && IsDataDescriptor(Desc) === true) {
        if (Desc.Value === undefined && Desc.Writable !== undefined && Desc.Writable === Value.false) {
          newArgDesc = Descriptor({ ...Desc
          });

          let _val5 = Get(map, P);

          Assert(!(_val5 instanceof AbruptCompletion), "");

          if (_val5 instanceof Completion) {
            _val5 = _val5.Value;
          }

          newArgDesc.Value = _val5;
        }
      }

      let allowed = OrdinaryDefineOwnProperty(args, P, newArgDesc);

      if (allowed instanceof AbruptCompletion) {
        return allowed;
      }

      if (allowed instanceof Completion) {
        allowed = allowed.Value;
      }

      if (allowed === Value.false) {
        return Value.false;
      }

      if (isMapped === Value.true) {
        if (IsAccessorDescriptor(Desc) === true) {
          map.Delete(P);
        } else {
          if (Desc.Value !== undefined) {
            const setStatus = Set$1(map, P, Desc.Value, Value.false);
            Assert(setStatus === Value.true, "setStatus === Value.true");
          }

          if (Desc.Writable !== undefined && Desc.Writable === Value.false) {
            map.Delete(P);
          }
        }
      }

      return Value.true;
    }

    Get(P, Receiver) {
      const args = this;
      const map = args.ParameterMap;
      let isMapped = HasOwnProperty(map, P);
      Assert(!(isMapped instanceof AbruptCompletion), "");

      if (isMapped instanceof Completion) {
        isMapped = isMapped.Value;
      }

      if (isMapped === Value.false) {
        return OrdinaryGet(args, P, Receiver);
      } else {
        return Get(map, P);
      }
    }

    Set(P, V, Receiver) {
      const args = this;
      let isMapped;
      let map;

      if (SameValue(args, Receiver) === Value.false) {
        isMapped = false;
      } else {
        map = args.ParameterMap;

        let _val6 = HasOwnProperty(map, P);

        Assert(!(_val6 instanceof AbruptCompletion), "");

        if (_val6 instanceof Completion) {
          _val6 = _val6.Value;
        }

        isMapped = _val6 === Value.true;
      }

      if (isMapped) {
        const setStatus = Set$1(map, P, V, Value.false);
        Assert(setStatus === Value.true, "setStatus === Value.true");
      }

      return OrdinarySet(args, P, V, Receiver);
    }

    Delete(P) {
      const args = this;
      const map = args.ParameterMap;
      let isMapped = HasOwnProperty(map, P);
      Assert(!(isMapped instanceof AbruptCompletion), "");

      if (isMapped instanceof Completion) {
        isMapped = isMapped.Value;
      }

      let result = OrdinaryDelete(args, P);

      if (result instanceof AbruptCompletion) {
        return result;
      }

      if (result instanceof Completion) {
        result = result.Value;
      }

      if (result === Value.true && isMapped === Value.true) {
        map.Delete(P);
      }

      return result;
    }

  }
  ArgumentsExoticObjectValue.prototype.isOrdinary = false; // 9.4.5 #sec-integer-indexed-exotic-objects

  class IntegerIndexedExoticObjectValue extends ObjectValue {
    constructor() {
      super();
      this.ViewedArrayBuffer = Value.undefined;
      this.ArrayLength = Value.undefined;
      this.ByteOffset = Value.undefined;
      this.TypedArrayName = Value.undefined;
    } // 9.4.5.1 #sec-integer-indexed-exotic-objects-getownproperty-p


    GetOwnProperty(P) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      Assert(O instanceof ObjectValue && 'ViewedArrayBuffer' in O, "O instanceof ObjectValue && 'ViewedArrayBuffer' in O");

      if (Type(P) === 'String') {
        let numericIndex = CanonicalNumericIndexString(P);
        Assert(!(numericIndex instanceof AbruptCompletion), "");

        if (numericIndex instanceof Completion) {
          numericIndex = numericIndex.Value;
        }

        if (numericIndex !== Value.undefined) {
          let value = IntegerIndexedElementGet(O, numericIndex);

          if (value instanceof AbruptCompletion) {
            return value;
          }

          if (value instanceof Completion) {
            value = value.Value;
          }

          if (value === Value.undefined) {
            return Value.undefined;
          }

          return Descriptor({
            Value: value,
            Writable: Value.true,
            Enumerable: Value.true,
            Configurable: Value.false
          });
        }
      }

      return OrdinaryGetOwnProperty(O, P);
    } // 9.4.5.2 #sec-integer-indexed-exotic-objects-hasproperty-p


    HasProperty(P) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      Assert(O instanceof ObjectValue && 'ViewedArrayBuffer' in O, "O instanceof ObjectValue && 'ViewedArrayBuffer' in O");

      if (Type(P) === 'String') {
        let numericIndex = CanonicalNumericIndexString(P);
        Assert(!(numericIndex instanceof AbruptCompletion), "");

        if (numericIndex instanceof Completion) {
          numericIndex = numericIndex.Value;
        }

        if (numericIndex !== Value.undefined) {
          const buffer = O.ViewedArrayBuffer;

          if (IsDetachedBuffer(buffer)) {
            return surroundingAgent.Throw('TypeError', 'Attempt to access detached ArrayBuffer');
          }

          if (IsInteger(numericIndex) === Value.false) {
            return Value.false;
          }

          numericIndex = numericIndex.numberValue();

          if (Object.is(numericIndex, -0)) {
            return Value.false;
          }

          if (numericIndex < 0) {
            return Value.false;
          }

          if (numericIndex >= O.ArrayLength.numberValue()) {
            return Value.false;
          }

          return Value.true;
        }
      }

      return OrdinaryHasProperty(O, P);
    } // 9.4.5.3 #sec-integer-indexed-exotic-objects-defineownproperty-p-desc


    DefineOwnProperty(P, Desc) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      Assert(O instanceof ObjectValue && 'ViewedArrayBuffer' in O, "O instanceof ObjectValue && 'ViewedArrayBuffer' in O");

      if (Type(P) === 'String') {
        let numericIndex = CanonicalNumericIndexString(P);
        Assert(!(numericIndex instanceof AbruptCompletion), "");

        if (numericIndex instanceof Completion) {
          numericIndex = numericIndex.Value;
        }

        if (numericIndex !== Value.undefined) {
          if (IsInteger(numericIndex) === Value.false) {
            return Value.false;
          }

          if (Object.is(numericIndex.numberValue(), -0)) {
            return Value.false;
          }

          if (numericIndex.numberValue() < 0) {
            return Value.false;
          }

          const length = O.ArrayLength;

          if (numericIndex.numberValue() >= length.numberValue()) {
            return Value.false;
          }

          if (IsAccessorDescriptor(Desc)) {
            return Value.false;
          }

          if (Desc.Configurable === Value.true) {
            return Value.false;
          }

          if (Desc.Enumerable === Value.false) {
            return Value.false;
          }

          if (Desc.Writable === Value.false) {
            return Value.false;
          }

          if (Desc.Value !== undefined) {
            const value = Desc.Value;
            return IntegerIndexedElementSet(O, numericIndex, value);
          }

          return Value.true;
        }
      }

      return OrdinaryDefineOwnProperty(O, P, Desc);
    } // 9.4.5.4 #sec-integer-indexed-exotic-objects-get-p-receiver


    Get(P, Receiver) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");

      if (Type(P) === 'String') {
        let numericIndex = CanonicalNumericIndexString(P);
        Assert(!(numericIndex instanceof AbruptCompletion), "");

        if (numericIndex instanceof Completion) {
          numericIndex = numericIndex.Value;
        }

        if (numericIndex !== Value.undefined) {
          return IntegerIndexedElementGet(O, numericIndex);
        }
      }

      return OrdinaryGet(O, P, Receiver);
    } // 9.4.5.5 #sec-integer-indexed-exotic-objects-set-p-v-receiver


    Set(P, V, Receiver) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");

      if (Type(P) === 'String') {
        let numericIndex = CanonicalNumericIndexString(P);
        Assert(!(numericIndex instanceof AbruptCompletion), "");

        if (numericIndex instanceof Completion) {
          numericIndex = numericIndex.Value;
        }

        if (numericIndex !== Value.undefined) {
          return IntegerIndexedElementSet(O, numericIndex, V);
        }
      }

      return OrdinarySet(O, P, V, Receiver);
    } // 9.4.5.6 #sec-integer-indexed-exotic-objects-ownpropertykeys


    OwnPropertyKeys() {
      const O = this;
      const keys = [];
      Assert(O instanceof ObjectValue && 'ViewedArrayBuffer' in O && 'ArrayLength' in O && 'ByteOffset' in O && 'TypedArrayName' in O, "O instanceof ObjectValue\n        && 'ViewedArrayBuffer' in O\n        && 'ArrayLength' in O\n        && 'ByteOffset' in O\n        && 'TypedArrayName' in O");
      const len = O.ArrayLength.numberValue();

      for (let i = 0; i < len; i += 1) {
        let _val7 = ToString(new Value(i));

        Assert(!(_val7 instanceof AbruptCompletion), "");

        if (_val7 instanceof Completion) {
          _val7 = _val7.Value;
        }

        keys.push(_val7);
      }

      for (const P of O.properties.keys()) {
        if (Type(P) === 'String') {
          if (!isIntegerIndex(P)) {
            keys.push(P);
          }
        }
      }

      for (const P of O.properties.keys()) {
        if (Type(P) === 'Symbol') {
          keys.push(P);
        }
      }

      return keys;
    }

  }
  IntegerIndexedExoticObjectValue.prototype.isOrdinary = false; // 9.4.7.2 #sec-set-immutable-prototype

  function SetImmutablePrototype(O, V) {
    Assert(Type(V) === 'Object' || Type(V) === 'Null', "Type(V) === 'Object' || Type(V) === 'Null'");
    let current = O.GetPrototypeOf();

    if (current instanceof AbruptCompletion) {
      return current;
    }

    if (current instanceof Completion) {
      current = current.Value;
    }

    if (SameValue(V, current) === Value.true) {
      return Value.true;
    }

    return Value.false;
  } // 9.4.6 #sec-module-namespace-exotic-objects


  class ModuleNamespaceExoticObjectValue extends ObjectValue {
    constructor() {
      super();
      this.Module = null;
      this.Exports = [];
      this.Prototype = Value.null;
    }

    SetPrototypeOf(V) {
      const O = this;
      return SetImmutablePrototype(O, V);
    }

    IsExtensible() {
      return Value.false;
    }

    PreventExtensions() {
      return Value.true;
    }

    GetOwnProperty(P) {
      const O = this;

      if (Type(P) === 'Symbol') {
        return OrdinaryGetOwnProperty(O, P);
      }

      const exports = O.Exports;

      if (!exports.includes(P)) {
        return Value.undefined;
      }

      let value = O.Get(P, O);

      if (value instanceof AbruptCompletion) {
        return value;
      }

      if (value instanceof Completion) {
        value = value.Value;
      }

      return Descriptor({
        Value: value,
        Writable: Value.true,
        Enumerable: Value.true,
        Configurable: Value.false
      });
    }

    DefineOwnProperty(P, Desc) {
      const O = this;

      if (Type(P) === 'Symbol') {
        return OrdinaryDefineOwnProperty(O, P, Desc);
      }

      let current = O.GetOwnProperty(P);

      if (current instanceof AbruptCompletion) {
        return current;
      }

      if (current instanceof Completion) {
        current = current.Value;
      }

      if (current === Value.undefined) {
        return Value.false;
      }

      if (IsAccessorDescriptor(Desc)) {
        return Value.false;
      }

      if (Desc.Writable !== undefined && Desc.Writable === Value.false) {
        return Value.false;
      }

      if (Desc.Enumerable !== undefined && Desc.Enumerable === Value.false) {
        return Value.false;
      }

      if (Desc.Configurable !== undefined && Desc.Configurable === Value.true) {
        return Value.false;
      }

      if (Desc.Value !== undefined) {
        return SameValue(Desc.Value, current.Value);
      }

      return Value.true;
    }

    HasProperty(P) {
      const O = this;

      if (Type(P) === 'Symbol') {
        return OrdinaryHasProperty(O, P);
      }

      const exports = O.Exports;

      if (exports.includes(P)) {
        return Value.true;
      }

      return Value.false;
    }

    Get(P, Receiver) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");

      if (Type(P) === 'Symbol') {
        return OrdinaryGet(O, P, Receiver);
      }

      const exports = O.Exports;

      if (!exports.includes(P)) {
        return Value.undefined;
      }

      const m = O.Module;
      const binding = m.ResolveExport(P);
      Assert(binding instanceof ResolvedBindingRecord, "binding instanceof ResolvedBindingRecord");
      const targetModule = binding.Module;
      Assert(targetModule !== Value.undefined, "targetModule !== Value.undefined");
      const targetEnv = targetModule.Environment;

      if (targetEnv === Value.undefined) {
        return surroundingAgent.Throw('ReferenceError', msg('NotDefined', P));
      }

      const targetEnvRec = targetEnv.EnvironmentRecord;
      return targetEnvRec.GetBindingValue(binding.BindingName, Value.true);
    }

    Set() {
      return Value.false;
    }

    Delete(P) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");

      if (Type(P) === 'Symbol') {
        return OrdinaryDelete(O, P);
      }

      const exports = O.Exports;

      if (exports.includes(P)) {
        return Value.false;
      }

      return Value.true;
    }

    OwnPropertyKeys() {
      const O = this;
      const exports = [...O.Exports];
      let symbolKeys = OrdinaryOwnPropertyKeys(O);
      Assert(!(symbolKeys instanceof AbruptCompletion), "");

      if (symbolKeys instanceof Completion) {
        symbolKeys = symbolKeys.Value;
      }

      exports.push(...symbolKeys);
      return exports;
    }

  }
  ModuleNamespaceExoticObjectValue.prototype.isOrdinary = false; // 9.5 #sec-proxy-object-internal-methods-and-internal-slots

  class ProxyExoticObjectValue extends ObjectValue {
    constructor() {
      super();
      this.ProxyTarget = undefined;
      this.ProxyHandler = undefined;
    }

    GetPrototypeOf() {
      const O = this;
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'getPrototypeOf'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('getPrototypeOf'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.GetPrototypeOf();
      }

      let handlerProto = Call(trap, handler, [target]);

      if (handlerProto instanceof AbruptCompletion) {
        return handlerProto;
      }

      if (handlerProto instanceof Completion) {
        handlerProto = handlerProto.Value;
      }

      if (Type(handlerProto) !== 'Object' && Type(handlerProto) !== 'Null') {
        return surroundingAgent.Throw('TypeError', '\'getPrototypeOf\' on proxy: trap returned neither object nor null');
      }

      let extensibleTarget = IsExtensible(target);

      if (extensibleTarget instanceof AbruptCompletion) {
        return extensibleTarget;
      }

      if (extensibleTarget instanceof Completion) {
        extensibleTarget = extensibleTarget.Value;
      }

      if (extensibleTarget === Value.true) {
        return handlerProto;
      }

      let targetProto = target.GetPrototypeOf();

      if (targetProto instanceof AbruptCompletion) {
        return targetProto;
      }

      if (targetProto instanceof Completion) {
        targetProto = targetProto.Value;
      }

      if (SameValue(handlerProto, targetProto) === Value.false) {
        return surroundingAgent.Throw('TypeError', '\'getPrototypeOf\' on proxy: proxy target is non-extensible but the trap did not return its actual prototype');
      }

      return handlerProto;
    }

    SetPrototypeOf(V) {
      const O = this;
      Assert(Type(V) === 'Object' || Type(V) === 'Null', "Type(V) === 'Object' || Type(V) === 'Null'");
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'setPrototypeOf'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('setPrototypeOf'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.SetPrototypeOf(V);
      }

      let _hygienicTemp = Call(trap, handler, [target, V]);

      if (_hygienicTemp instanceof AbruptCompletion) {
        return _hygienicTemp;
      }

      if (_hygienicTemp instanceof Completion) {
        _hygienicTemp = _hygienicTemp.Value;
      }

      const booleanTrapResult = ToBoolean(_hygienicTemp);

      if (booleanTrapResult === Value.false) {
        return Value.false;
      }

      let extensibleTarget = IsExtensible(target);

      if (extensibleTarget instanceof AbruptCompletion) {
        return extensibleTarget;
      }

      if (extensibleTarget instanceof Completion) {
        extensibleTarget = extensibleTarget.Value;
      }

      if (extensibleTarget === Value.true) {
        return Value.true;
      }

      let targetProto = target.GetPrototypeOf();

      if (targetProto instanceof AbruptCompletion) {
        return targetProto;
      }

      if (targetProto instanceof Completion) {
        targetProto = targetProto.Value;
      }

      if (SameValue(V, targetProto) === Value.false) {
        return surroundingAgent.Throw('TypeError', '\'setPrototypeOf\' on proxy: trap returned truthy for setting a new prototype on the non-extensible proxy target');
      }

      return Value.true;
    }

    IsExtensible() {
      const O = this;
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'isExtensible'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('isExtensible'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return IsExtensible(target);
      }

      let _hygienicTemp2 = Call(trap, handler, [target]);

      if (_hygienicTemp2 instanceof AbruptCompletion) {
        return _hygienicTemp2;
      }

      if (_hygienicTemp2 instanceof Completion) {
        _hygienicTemp2 = _hygienicTemp2.Value;
      }

      const booleanTrapResult = ToBoolean(_hygienicTemp2);
      let targetResult = IsExtensible(target);

      if (targetResult instanceof AbruptCompletion) {
        return targetResult;
      }

      if (targetResult instanceof Completion) {
        targetResult = targetResult.Value;
      }

      if (SameValue(booleanTrapResult, targetResult) === Value.false) {
        return surroundingAgent.Throw('TypeError', '\'isExtensible\' on proxy: trap result does not reflect extensibility of proxy target');
      }

      return booleanTrapResult;
    }

    PreventExtensions() {
      const O = this;
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'preventExtensions'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('preventExtensions'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.PreventExtensions();
      }

      let _hygienicTemp3 = Call(trap, handler, [target]);

      if (_hygienicTemp3 instanceof AbruptCompletion) {
        return _hygienicTemp3;
      }

      if (_hygienicTemp3 instanceof Completion) {
        _hygienicTemp3 = _hygienicTemp3.Value;
      }

      const booleanTrapResult = ToBoolean(_hygienicTemp3);

      if (booleanTrapResult === Value.true) {
        let extensibleTarget = IsExtensible(target);

        if (extensibleTarget instanceof AbruptCompletion) {
          return extensibleTarget;
        }

        if (extensibleTarget instanceof Completion) {
          extensibleTarget = extensibleTarget.Value;
        }

        if (extensibleTarget === Value.true) {
          return surroundingAgent.Throw('TypeError', '\'preventExtensions\' on proxy: trap returned truthy but the proxy target is extensible');
        }
      }

      return booleanTrapResult;
    }

    GetOwnProperty(P) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'getOwnPropertyDescriptor'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('getOwnPropertyDescriptor'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.GetOwnProperty(P);
      }

      let trapResultObj = Call(trap, handler, [target, P]);

      if (trapResultObj instanceof AbruptCompletion) {
        return trapResultObj;
      }

      if (trapResultObj instanceof Completion) {
        trapResultObj = trapResultObj.Value;
      }

      if (Type(trapResultObj) !== 'Object' && Type(trapResultObj) !== 'Undefined') {
        return surroundingAgent.Throw('TypeError', '\'getOwnPropertyDescriptor\' on proxy: trap returned neither object nor undefined for property');
      }

      let targetDesc = target.GetOwnProperty(P);

      if (targetDesc instanceof AbruptCompletion) {
        return targetDesc;
      }

      if (targetDesc instanceof Completion) {
        targetDesc = targetDesc.Value;
      }

      if (trapResultObj === Value.undefined) {
        if (targetDesc === Value.undefined) {
          return Value.undefined;
        }

        if (targetDesc.Configurable === Value.false) {
          return surroundingAgent.Throw('TypeError', '\'getOwnPropertyDescriptor\' on proxy: trap returned undefined for property which is non-configurable in the proxy target');
        }

        let extensibleTarget = IsExtensible(target);

        if (extensibleTarget instanceof AbruptCompletion) {
          return extensibleTarget;
        }

        if (extensibleTarget instanceof Completion) {
          extensibleTarget = extensibleTarget.Value;
        }

        if (extensibleTarget === Value.false) {
          return surroundingAgent.Throw('TypeError', '\'getOwnPropertyDescriptor\' on proxy: trap returned undefined for property which exists in the non-extensible proxy target');
        }

        return Value.undefined;
      }

      let extensibleTarget = IsExtensible(target);

      if (extensibleTarget instanceof AbruptCompletion) {
        return extensibleTarget;
      }

      if (extensibleTarget instanceof Completion) {
        extensibleTarget = extensibleTarget.Value;
      }

      let resultDesc = ToPropertyDescriptor(trapResultObj);

      if (resultDesc instanceof AbruptCompletion) {
        return resultDesc;
      }

      if (resultDesc instanceof Completion) {
        resultDesc = resultDesc.Value;
      }

      CompletePropertyDescriptor(resultDesc);
      const valid = IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc);

      if (valid === Value.false) {
        return surroundingAgent.Throw('TypeError', '\'getOwnPropertyDescriptor\' on proxy: trap returned descriptor for property that is incompatible with the existing property in the proxy target');
      }

      if (resultDesc.Configurable === Value.false) {
        if (targetDesc === Value.undefined || targetDesc.Configurable === Value.true) {
          return surroundingAgent.Throw('TypeError', '\'getOwnPropertyDescriptor\' on proxy: trap reported non-configurability for property which is either non-existant or configurable in the proxy target');
        }
      }

      return resultDesc;
    }

    DefineOwnProperty(P, Desc) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'defineProperty'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('defineProperty'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.DefineOwnProperty(P, Desc);
      }

      const descObj = FromPropertyDescriptor(Desc);

      let _hygienicTemp4 = Call(trap, handler, [target, P, descObj]);

      if (_hygienicTemp4 instanceof AbruptCompletion) {
        return _hygienicTemp4;
      }

      if (_hygienicTemp4 instanceof Completion) {
        _hygienicTemp4 = _hygienicTemp4.Value;
      }

      const booleanTrapResult = ToBoolean(_hygienicTemp4);

      if (booleanTrapResult === Value.false) {
        return Value.false;
      }

      let targetDesc = target.GetOwnProperty(P);

      if (targetDesc instanceof AbruptCompletion) {
        return targetDesc;
      }

      if (targetDesc instanceof Completion) {
        targetDesc = targetDesc.Value;
      }

      let extensibleTarget = IsExtensible(target);

      if (extensibleTarget instanceof AbruptCompletion) {
        return extensibleTarget;
      }

      if (extensibleTarget instanceof Completion) {
        extensibleTarget = extensibleTarget.Value;
      }

      let settingConfigFalse;

      if (Desc.Configurable !== undefined && Desc.Configurable === Value.false) {
        settingConfigFalse = true;
      } else {
        settingConfigFalse = false;
      }

      if (targetDesc === Value.undefined) {
        if (extensibleTarget === Value.false) {
          return surroundingAgent.Throw('TypeError', '\'defineProperty\' on proxy: trap returned truthy for defining non-configurable property which is either non-existant or configurable in the proxy target');
        }

        if (settingConfigFalse === true) {
          return surroundingAgent.Throw('TypeError', '\'defineProperty\' on proxy: trap returned truthy for adding property to the non-extensible proxy target');
        }
      } else {
        if (IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) === Value.false) {
          return surroundingAgent.Throw('TypeError', '\'defineProperty\' on proxy: trap returned truthy for adding property that is incompatible with the existing property in the proxy target');
        }

        if (settingConfigFalse === true && targetDesc.Configurable === Value.true) {
          return surroundingAgent.Throw('TypeError', '\'defineProperty\' on proxy: trap returned truthy for defining non-configurable property which is either non-existant or configurable in the proxy target');
        }
      }

      return Value.true;
    }

    HasProperty(P) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'has'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('has'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.HasProperty(P);
      }

      let _hygienicTemp5 = Call(trap, handler, [target, P]);

      if (_hygienicTemp5 instanceof AbruptCompletion) {
        return _hygienicTemp5;
      }

      if (_hygienicTemp5 instanceof Completion) {
        _hygienicTemp5 = _hygienicTemp5.Value;
      }

      const booleanTrapResult = ToBoolean(_hygienicTemp5);

      if (booleanTrapResult === Value.false) {
        let targetDesc = target.GetOwnProperty(P);

        if (targetDesc instanceof AbruptCompletion) {
          return targetDesc;
        }

        if (targetDesc instanceof Completion) {
          targetDesc = targetDesc.Value;
        }

        if (targetDesc !== Value.undefined) {
          if (targetDesc.Configurable === Value.false) {
            return surroundingAgent.Throw('TypeError', '\'has\' on proxy: trap returned falsy for property which exists in the proxy target as non-configurable');
          }

          let extensibleTarget = IsExtensible(target);

          if (extensibleTarget instanceof AbruptCompletion) {
            return extensibleTarget;
          }

          if (extensibleTarget instanceof Completion) {
            extensibleTarget = extensibleTarget.Value;
          }

          if (extensibleTarget === Value.false) {
            return surroundingAgent.Throw('TypeError', '\'has\' on proxy: trap returned falsy for property but the proxy target is not extensible');
          }
        }
      }

      return booleanTrapResult;
    }

    Get(P, Receiver) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'get'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('get'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.Get(P, Receiver);
      }

      let trapResult = Call(trap, handler, [target, P, Receiver]);

      if (trapResult instanceof AbruptCompletion) {
        return trapResult;
      }

      if (trapResult instanceof Completion) {
        trapResult = trapResult.Value;
      }

      let targetDesc = target.GetOwnProperty(P);

      if (targetDesc instanceof AbruptCompletion) {
        return targetDesc;
      }

      if (targetDesc instanceof Completion) {
        targetDesc = targetDesc.Value;
      }

      if (targetDesc !== Value.undefined && targetDesc.Configurable === Value.false) {
        if (IsDataDescriptor(targetDesc) === true && targetDesc.Writable === Value.false) {
          if (SameValue(trapResult, targetDesc.Value) === Value.false) {
            return surroundingAgent.Throw('TypeError', '\'get\' on proxy: property is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value');
          }
        }

        if (IsAccessorDescriptor(targetDesc) === true && targetDesc.Get === Value.undefined) {
          if (trapResult !== Value.undefined) {
            return surroundingAgent.Throw('TypeError', '\'get\' on proxy: property is a non-configurable accessor property on the proxy target and does not have a getter function, but the trap did not return undefined');
          }
        }
      }

      return trapResult;
    }

    Set(P, V, Receiver) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'set'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('set'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.Set(P, V, Receiver);
      }

      let _hygienicTemp6 = Call(trap, handler, [target, P, V, Receiver]);

      if (_hygienicTemp6 instanceof AbruptCompletion) {
        return _hygienicTemp6;
      }

      if (_hygienicTemp6 instanceof Completion) {
        _hygienicTemp6 = _hygienicTemp6.Value;
      }

      const booleanTrapResult = ToBoolean(_hygienicTemp6);

      if (booleanTrapResult === Value.false) {
        return Value.false;
      }

      let targetDesc = target.GetOwnProperty(P);

      if (targetDesc instanceof AbruptCompletion) {
        return targetDesc;
      }

      if (targetDesc instanceof Completion) {
        targetDesc = targetDesc.Value;
      }

      if (targetDesc !== Value.undefined && targetDesc.Configurable === Value.false) {
        if (IsDataDescriptor(targetDesc) === true && targetDesc.Writable === Value.false) {
          if (SameValue(V, targetDesc.Value) === Value.false) {
            return surroundingAgent.Throw('TypeError', '\'set\' on proxy: trap returned truthy for property which exists in the proxy target as a non-configurable and non-writable data property with a different value');
          }
        }

        if (IsAccessorDescriptor(targetDesc) === true) {
          if (targetDesc.Set === Value.undefined) {
            return surroundingAgent.Throw('TypeError', '\'set\' on proxy: trap returned truish for property which exists in the proxy target as a non-configurable and non-writable accessor property without a setter');
          }
        }
      }

      return Value.true;
    }

    Delete(P) {
      const O = this;
      Assert(IsPropertyKey(P), "IsPropertyKey(P)");
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'deleteProperty'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('deleteProperty'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.Delete(P);
      }

      let _hygienicTemp7 = Call(trap, handler, [target, P]);

      if (_hygienicTemp7 instanceof AbruptCompletion) {
        return _hygienicTemp7;
      }

      if (_hygienicTemp7 instanceof Completion) {
        _hygienicTemp7 = _hygienicTemp7.Value;
      }

      const booleanTrapResult = ToBoolean(_hygienicTemp7);

      if (booleanTrapResult === Value.false) {
        return Value.false;
      }

      let targetDesc = target.GetOwnProperty(P);

      if (targetDesc instanceof AbruptCompletion) {
        return targetDesc;
      }

      if (targetDesc instanceof Completion) {
        targetDesc = targetDesc.Value;
      }

      if (targetDesc === Value.undefined) {
        return Value.true;
      }

      if (targetDesc.Configurable === Value.false) {
        return surroundingAgent.Throw('TypeError', '\'deleteProperty\' on proxy: trap returned truthy for property which is non-configurable in the proxy target');
      }

      return Value.true;
    }

    OwnPropertyKeys() {
      const O = this;
      const handler = O.ProxyHandler;

      if (handler === Value.null) {
        return surroundingAgent.Throw('TypeError', msg('ProxyRevoked', 'ownKeys'));
      }

      Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
      const target = O.ProxyTarget;
      let trap = GetMethod(handler, new Value('ownKeys'));

      if (trap instanceof AbruptCompletion) {
        return trap;
      }

      if (trap instanceof Completion) {
        trap = trap.Value;
      }

      if (trap === Value.undefined) {
        return target.OwnPropertyKeys();
      }

      let trapResultArray = Call(trap, handler, [target]);

      if (trapResultArray instanceof AbruptCompletion) {
        return trapResultArray;
      }

      if (trapResultArray instanceof Completion) {
        trapResultArray = trapResultArray.Value;
      }

      let trapResult = CreateListFromArrayLike(trapResultArray, ['String', 'Symbol']);

      if (trapResult instanceof AbruptCompletion) {
        return trapResult;
      }

      if (trapResult instanceof Completion) {
        trapResult = trapResult.Value;
      }

      if (trapResult.some(e => trapResult.indexOf(e) !== trapResult.lastIndexOf(e))) {
        return surroundingAgent.Throw('TypeError', '\'ownKeys\' on proxy: trap returned duplicate keys');
      }

      let extensibleTarget = IsExtensible(target);

      if (extensibleTarget instanceof AbruptCompletion) {
        return extensibleTarget;
      }

      if (extensibleTarget instanceof Completion) {
        extensibleTarget = extensibleTarget.Value;
      }

      let targetKeys = target.OwnPropertyKeys();

      if (targetKeys instanceof AbruptCompletion) {
        return targetKeys;
      }

      if (targetKeys instanceof Completion) {
        targetKeys = targetKeys.Value;
      }

      // Assert: targetKeys is a List containing only String and Symbol values.
      // Assert: targetKeys contains no duplicate entries.
      const targetConfigurableKeys = [];
      const targetNonconfigurableKeys = [];

      for (const key of targetKeys) {
        let desc = target.GetOwnProperty(key);

        if (desc instanceof AbruptCompletion) {
          return desc;
        }

        if (desc instanceof Completion) {
          desc = desc.Value;
        }

        if (desc !== Value.undefined && desc.Configurable === Value.false) {
          targetNonconfigurableKeys.push(key);
        } else {
          targetConfigurableKeys.push(key);
        }
      }

      if (extensibleTarget === Value.true && targetNonconfigurableKeys.length === 0) {
        return trapResult;
      }

      const uncheckedResultKeys = new global.Set(trapResult);

      for (const key of targetNonconfigurableKeys) {
        if (!uncheckedResultKeys.has(key)) {
          return surroundingAgent.Throw('TypeError', '\'ownKeys\' on proxy: trap result does not include non-configurable key');
        }

        uncheckedResultKeys.delete(key);
      }

      if (extensibleTarget === Value.true) {
        return trapResult;
      }

      for (const key of targetConfigurableKeys) {
        if (!uncheckedResultKeys.has(key)) {
          return surroundingAgent.Throw('TypeError', '\'ownKeys\' on proxy: trap result does not include configurable key');
        }

        uncheckedResultKeys.delete(key);
      }

      if (uncheckedResultKeys.size > 0) {
        return surroundingAgent.Throw('TypeError', '\'ownKeys\' on proxy: trap returned extra keys but proxy target is non-extensible');
      }

      return trapResult;
    }

  }
  ProxyExoticObjectValue.prototype.isOrdinary = false;
  class Reference {
    constructor({
      BaseValue,
      ReferencedName,
      StrictReference
    }) {
      this.BaseValue = BaseValue;
      this.ReferencedName = ReferencedName;
      Assert(Type(StrictReference) === 'Boolean', "Type(StrictReference) === 'Boolean'");
      this.StrictReference = StrictReference;
    }

  }
  class SuperReference extends Reference {
    constructor({
      BaseValue,
      ReferencedName,
      thisValue,
      StrictReference
    }) {
      super({
        BaseValue,
        ReferencedName,
        StrictReference
      });
      this.thisValue = thisValue;
    }

  } // TODO(devsnek): clean this up somehow

  const stringMap = new Map();
  const numberMap = new Map();
  function Descriptor(O) {
    if (new.target === Descriptor) {
      this.Value = O.Value;
      this.Get = O.Get;
      this.Set = O.Set;
      this.Writable = O.Writable;
      this.Enumerable = O.Enumerable;
      this.Configurable = O.Configurable;
    } else {
      return new Descriptor(O);
    }
  }

  Descriptor.prototype.everyFieldIsAbsent = function everyFieldIsAbsent() {
    return this.Value === undefined && this.Get === undefined && this.Set === undefined && this.Writable === undefined && this.Enumerable === undefined && this.Configurable === undefined;
  };

  class DataBlock extends Uint8Array {
    constructor(sizeOrBuffer, ...restArgs) {
      if (sizeOrBuffer instanceof ArrayBuffer) {
        // fine.
        super(sizeOrBuffer, ...restArgs);
      } else {
        Assert(typeof sizeOrBuffer === 'number', "typeof sizeOrBuffer === 'number'");
        super(sizeOrBuffer);
      }
    }

  }
  function Type(val) {
    if (val instanceof UndefinedValue) {
      return 'Undefined';
    }

    if (val instanceof NullValue) {
      return 'Null';
    }

    if (val instanceof BooleanValue) {
      return 'Boolean';
    }

    if (val instanceof StringValue) {
      return 'String';
    }

    if (val instanceof NumberValue) {
      return 'Number';
    }

    if (val instanceof SymbolValue) {
      return 'Symbol';
    }

    if (val instanceof ObjectValue) {
      return 'Object';
    }

    if (val instanceof Reference) {
      return 'Reference';
    }

    if (val instanceof Completion) {
      return 'Completion';
    }

    if (val instanceof EnvironmentRecord) {
      return 'EnvironmentRecord';
    }

    if (val instanceof LexicalEnvironment) {
      return 'LexicalEnvironment';
    }

    if (val instanceof Descriptor) {
      return 'Descriptor';
    }

    if (val instanceof DataBlock) {
      return 'Data Block';
    }

    throw new OutOfRange('Type', val);
  }

  function assignProps(realmRec, obj, props) {
    for (const item of props) {
      if (item === undefined) {
        continue;
      }

      const [n, v, len, descriptor] = item;
      const name = n instanceof Value ? n : new Value(n);

      if (Array.isArray(v)) {
        // Every accessor property described in clauses 18 through 26 and in
        // Annex B.2 has the attributes { [[Enumerable]]: false,
        // [[Configurable]]: true } unless otherwise specified. If only a get
        // accessor function is described, the set accessor function is the
        // default value, undefined. If only a set accessor is described the get
        // accessor is the default value, undefined.
        let [getter = Value.undefined, setter = Value.undefined] = v;

        if (typeof getter === 'function') {
          getter = CreateBuiltinFunction(getter, [], realmRec);
          Assert(!(SetFunctionName(getter, name, new Value('get')) instanceof AbruptCompletion), "");
          Assert(!(SetFunctionLength(getter, new Value(0)) instanceof AbruptCompletion), "");
        }

        if (typeof setter === 'function') {
          setter = CreateBuiltinFunction(setter, [], realmRec);
          Assert(!(SetFunctionName(setter, name, new Value('set')) instanceof AbruptCompletion), "");
          Assert(!(SetFunctionLength(setter, new Value(1)) instanceof AbruptCompletion), "");
        }

        Assert(!(obj.DefineOwnProperty(name, Descriptor({
          Get: getter,
          Set: setter,
          Enumerable: Value.false,
          Configurable: Value.true,
          ...descriptor
        })) instanceof AbruptCompletion), "");
      } else {
        // Every other data property described in clauses 18 through 26 and in
        // Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]:
        // false, [[Configurable]]: true } unless otherwise specified.
        let value;

        if (typeof v === 'function') {
          Assert(typeof len === 'number', "typeof len === 'number'");
          value = CreateBuiltinFunction(v, [], realmRec);
          Assert(!(SetFunctionName(value, name) instanceof AbruptCompletion), "");
          Assert(!(SetFunctionLength(value, new Value(len)) instanceof AbruptCompletion), "");
        } else {
          value = v;
        }

        Assert(!(obj.DefineOwnProperty(name, Descriptor({
          Value: value,
          Writable: Value.true,
          Enumerable: Value.false,
          Configurable: Value.true,
          ...descriptor
        })) instanceof AbruptCompletion), "");
      }
    }
  }
  function BootstrapPrototype(realmRec, props, Prototype, stringTag) {
    Assert(Prototype !== undefined, "Prototype !== undefined");
    const proto = ObjectCreate(Prototype);
    assignProps(realmRec, proto, props);

    if (stringTag !== undefined) {
      Assert(!(proto.DefineOwnProperty(wellKnownSymbols.toStringTag, Descriptor({
        Value: new Value(stringTag),
        Writable: Value.false,
        Enumerable: Value.false,
        Configurable: Value.true
      })) instanceof AbruptCompletion), "");
    }

    return proto;
  }
  function BootstrapConstructor(realmRec, Constructor, name, length, Prototype, props = []) {
    const cons = CreateBuiltinFunction(Constructor, [], realmRec, undefined, Value.true);
    SetFunctionName(cons, new Value(name));
    SetFunctionLength(cons, new Value(length));
    Assert(!(cons.DefineOwnProperty(new Value('prototype'), Descriptor({
      Value: Prototype,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    Assert(!(Prototype.DefineOwnProperty(new Value('constructor'), Descriptor({
      Value: cons,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    assignProps(realmRec, cons, props);
    return cons;
  }

  function ObjectProto_hasOwnProperty([V = Value.undefined], {
    thisValue
  }) {
    let P = ToPropertyKey(V);

    if (P instanceof AbruptCompletion) {
      return P;
    }

    if (P instanceof Completion) {
      P = P.Value;
    }

    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    return HasOwnProperty(O, P);
  }

  function ObjectProto_isPrototypeOf([V = Value.undefined], {
    thisValue
  }) {
    if (Type(V) !== 'Object') {
      return Value.false;
    }

    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    while (true) {
      V = V.GetPrototypeOf();

      if (V instanceof AbruptCompletion) {
        return V;
      }

      if (V instanceof Completion) {
        V = V.Value;
      }

      if (Type(V) === 'Null') {
        return Value.false;
      }

      if (SameValue(O, V) === Value.true) {
        return Value.true;
      }
    }
  }

  function ObjectProto_propertyIsEnumerable([V = Value.undefined], {
    thisValue
  }) {
    let P = ToPropertyKey(V);

    if (P instanceof AbruptCompletion) {
      return P;
    }

    if (P instanceof Completion) {
      P = P.Value;
    }

    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let desc = O.GetOwnProperty(P);

    if (desc instanceof AbruptCompletion) {
      return desc;
    }

    if (desc instanceof Completion) {
      desc = desc.Value;
    }

    if (Type(desc) === 'Undefined') {
      return Value.false;
    }

    return desc.Enumerable;
  }

  function ObjectProto_toLocaleString(argList, {
    thisValue
  }) {
    const O = thisValue;
    return Invoke(O, new Value('toString'));
  }

  function ObjectProto_toString(argList, {
    thisValue
  }) {
    if (Type(thisValue) === 'Undefined') {
      return new Value('[object Undefined]');
    }

    if (Type(thisValue) === 'Null') {
      return new Value('[object Null]');
    }

    let O = ToObject(thisValue);
    Assert(!(O instanceof AbruptCompletion), "");

    if (O instanceof Completion) {
      O = O.Value;
    }

    let isArray = IsArray(O);

    if (isArray instanceof AbruptCompletion) {
      return isArray;
    }

    if (isArray instanceof Completion) {
      isArray = isArray.Value;
    }

    let builtinTag;

    if (isArray === Value.true) {
      builtinTag = 'Array';
    } else if ('ParameterMap' in O) {
      builtinTag = 'Arguments';
    } else if ('Call' in O) {
      builtinTag = 'Function';
    } else if ('ErrorData' in O) {
      builtinTag = 'Error';
    } else if ('BooleanData' in O) {
      builtinTag = 'Boolean';
    } else if ('NumberData' in O) {
      builtinTag = 'Number';
    } else if ('StringData' in O) {
      builtinTag = 'String';
    } else if ('DateValue' in O) {
      builtinTag = 'Date';
    } else if ('RegExpMatcher' in O) {
      builtinTag = 'RegExp';
    } else {
      builtinTag = 'Object';
    }

    let tag = Get(O, wellKnownSymbols.toStringTag);

    if (tag instanceof AbruptCompletion) {
      return tag;
    }

    if (tag instanceof Completion) {
      tag = tag.Value;
    }

    if (Type(tag) !== 'String') {
      tag = builtinTag;
    }

    return new Value(`[object ${tag.stringValue ? tag.stringValue() : tag}]`);
  }

  function ObjectProto_valueOf(argList, {
    thisValue
  }) {
    return ToObject(thisValue);
  }

  function CreateObjectPrototype(realmRec) {
    const proto = realmRec.Intrinsics['%ObjectPrototype%'];
    Assert(proto, "proto");
    assignProps(realmRec, proto, [['hasOwnProperty', ObjectProto_hasOwnProperty, 1], ['isPrototypeOf', ObjectProto_isPrototypeOf, 1], ['propertyIsEnumerable', ObjectProto_propertyIsEnumerable, 1], ['toLocaleString', ObjectProto_toLocaleString, 0], ['toString', ObjectProto_toString, 0], ['valueOf', ObjectProto_valueOf, 0]]);

    let _val = Get(proto, new Value('toString'));

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    realmRec.Intrinsics['%ObjProto_toString%'] = _val;

    let _val2 = Get(proto, new Value('valueOf'));

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    realmRec.Intrinsics['%ObjProto_valueOf%'] = _val2;
    realmRec.Intrinsics['%ObjectPrototype%'] = proto;
  }

  function AddEntriesFromIterable(target, iterable, adder) {
    if (IsCallable(adder) === Value.false) {
      return surroundingAgent.Throw('TypeError');
    }

    Assert(iterable && Type(iterable) !== 'Undefined' && Type(iterable) !== 'Null', "iterable && Type(iterable) !== 'Undefined' && Type(iterable) !== 'Null'");
    let iteratorRecord = GetIterator(iterable);

    if (iteratorRecord instanceof AbruptCompletion) {
      return iteratorRecord;
    }

    if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    while (true) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        return target;
      }

      let nextItem = IteratorValue(next);

      if (nextItem instanceof AbruptCompletion) {
        return nextItem;
      }

      if (nextItem instanceof Completion) {
        nextItem = nextItem.Value;
      }

      if (Type(nextItem) !== 'Object') {
        const error = new ThrowCompletion(surroundingAgent.Throw('TypeError').Value);
        return IteratorClose(iteratorRecord, error);
      }

      const k = Get(nextItem, new Value('0'));

      if (k instanceof AbruptCompletion) {
        return IteratorClose(iteratorRecord, k);
      }

      const v = Get(nextItem, new Value('1'));

      if (v instanceof AbruptCompletion) {
        return IteratorClose(iteratorRecord, v);
      }

      const status = Call(adder, target, [k.Value, v.Value]);

      if (status instanceof AbruptCompletion) {
        return IteratorClose(iteratorRecord, status);
      }
    }
  }

  function MapConstructor([iterable], {
    NewTarget
  }) {
    if (Type(NewTarget) === 'Undefined') {
      return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', 'Map'));
    }

    let map = OrdinaryCreateFromConstructor(NewTarget, '%MapPrototype%', ['MapData']);

    if (map instanceof AbruptCompletion) {
      return map;
    }

    if (map instanceof Completion) {
      map = map.Value;
    }

    map.MapData = [];

    if (iterable === undefined || Type(iterable) === 'Undefined' || Type(iterable) === 'Null') {
      return map;
    }

    let adder = Get(map, new Value('set'));

    if (adder instanceof AbruptCompletion) {
      return adder;
    }

    if (adder instanceof Completion) {
      adder = adder.Value;
    }

    return AddEntriesFromIterable(map, iterable, adder);
  }

  function Map_speciesGetter(args, {
    thisValue
  }) {
    return thisValue;
  }

  function CreateMap(realmRec) {
    const mapConstructor = BootstrapConstructor(realmRec, MapConstructor, 'Map', 0, realmRec.Intrinsics['%MapPrototype%'], [[wellKnownSymbols.species, [Map_speciesGetter]]]);
    realmRec.Intrinsics['%Map%'] = mapConstructor;
  }

  function ObjectConstructor([value], {
    NewTarget
  }) {
    if (NewTarget !== Value.undefined && NewTarget !== surroundingAgent.activeFunctionObject) {
      return OrdinaryCreateFromConstructor(NewTarget, '%ObjectPrototype%');
    }

    if (value === Value.null || value === Value.undefined || value === undefined) {
      return ObjectCreate(surroundingAgent.currentRealmRecord.Intrinsics['%ObjectPrototype%']);
    }

    let _val = ToObject(value);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    return _val;
  }

  function Object_assign([target = Value.undefined, ...sources]) {
    let to = ToObject(target);

    if (to instanceof AbruptCompletion) {
      return to;
    }

    if (to instanceof Completion) {
      to = to.Value;
    }

    if (sources.length === 0) {
      return to;
    } // Let sources be the List of argument values starting with the second argument.


    for (const nextSource of sources) {
      if (Type(nextSource) !== 'Undefined' && Type(nextSource) !== 'Null') {
        let from = ToObject(nextSource);
        Assert(!(from instanceof AbruptCompletion), "");

        if (from instanceof Completion) {
          from = from.Value;
        }

        let keys = from.OwnPropertyKeys();

        if (keys instanceof AbruptCompletion) {
          return keys;
        }

        if (keys instanceof Completion) {
          keys = keys.Value;
        }

        for (const nextKey of keys) {
          let desc = from.GetOwnProperty(nextKey);

          if (desc instanceof AbruptCompletion) {
            return desc;
          }

          if (desc instanceof Completion) {
            desc = desc.Value;
          }

          if (Type(desc) !== 'Undefined' && desc.Enumerable === Value.true) {
            let propValue = Get(from, nextKey);

            if (propValue instanceof AbruptCompletion) {
              return propValue;
            }

            if (propValue instanceof Completion) {
              propValue = propValue.Value;
            }

            {
              const hygienicTemp = Set$1(to, nextKey, propValue, Value.true);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          }
        }
      }
    }

    return to;
  }

  function Object_create([O = Value.undefined, Properties = Value.undefined]) {
    if (Type(O) !== 'Object' && Type(O) !== 'Null') {
      return surroundingAgent.Throw('TypeError', 'Object prototype may only be an Object or null');
    }

    const obj = ObjectCreate(O);

    if (Properties !== Value.undefined) {
      return ObjectDefineProperties(obj, Properties);
    }

    return obj;
  }

  function Object_defineProperties([O = Value.undefined, Properties = Value.undefined]) {
    return ObjectDefineProperties(O, Properties);
  } // #sec-objectdefineproperties ObjectDefineProperties


  function ObjectDefineProperties(O, Properties) {
    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotAnObject', O));
    }

    let props = ToObject(Properties);

    if (props instanceof AbruptCompletion) {
      return props;
    }

    if (props instanceof Completion) {
      props = props.Value;
    }

    let keys = props.OwnPropertyKeys();

    if (keys instanceof AbruptCompletion) {
      return keys;
    }

    if (keys instanceof Completion) {
      keys = keys.Value;
    }

    const descriptors = [];

    for (const nextKey of keys) {
      let propDesc = props.GetOwnProperty(nextKey);

      if (propDesc instanceof AbruptCompletion) {
        return propDesc;
      }

      if (propDesc instanceof Completion) {
        propDesc = propDesc.Value;
      }

      if (propDesc !== Value.undefined && propDesc.Enumerable === Value.true) {
        let descObj = Get(props, nextKey);

        if (descObj instanceof AbruptCompletion) {
          return descObj;
        }

        if (descObj instanceof Completion) {
          descObj = descObj.Value;
        }

        let desc = ToPropertyDescriptor(descObj);

        if (desc instanceof AbruptCompletion) {
          return desc;
        }

        if (desc instanceof Completion) {
          desc = desc.Value;
        }

        descriptors.push([nextKey, desc]);
      }
    }

    for (const pair of descriptors) {
      const P = pair[0];
      const desc = pair[1];
      {
        const hygienicTemp = DefinePropertyOrThrow(O, P, desc);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    return O;
  }

  function Object_defineProperty([O = Value.undefined, P = Value.undefined, Attributes = Value.undefined]) {
    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'Value is not an object');
    }

    let key = ToPropertyKey(P);

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    let desc = ToPropertyDescriptor(Attributes);

    if (desc instanceof AbruptCompletion) {
      return desc;
    }

    if (desc instanceof Completion) {
      desc = desc.Value;
    }

    {
      const hygienicTemp = DefinePropertyOrThrow(O, key, desc);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return O;
  }

  function Object_entries([O = Value.undefined]) {
    let obj = ToObject(O);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    let nameList = EnumerableOwnPropertyNames(obj, 'key+value');

    if (nameList instanceof AbruptCompletion) {
      return nameList;
    }

    if (nameList instanceof Completion) {
      nameList = nameList.Value;
    }

    return CreateArrayFromList(nameList);
  }

  function Object_freeze([O = Value.undefined]) {
    if (Type(O) !== 'Object') {
      return O;
    }

    let status = SetIntegrityLevel(O, 'frozen');

    if (status instanceof AbruptCompletion) {
      return status;
    }

    if (status instanceof Completion) {
      status = status.Value;
    }

    if (status === Value.false) {
      return surroundingAgent.Throw('TypeError', 'Could not freeze object');
    }

    return O;
  }

  function CreateDataPropertyOnObjectFunctions([key, value], {
    thisValue
  }) {
    const O = thisValue;
    Assert(Type(O) === 'Object', "Type(O) === 'Object'");
    Assert(O.Extensible === Value.true, "O.Extensible === Value.true");
    let propertyKey = ToPropertyKey(key);

    if (propertyKey instanceof AbruptCompletion) {
      return propertyKey;
    }

    if (propertyKey instanceof Completion) {
      propertyKey = propertyKey.Value;
    }

    Assert(!(CreateDataPropertyOrThrow(O, propertyKey, value) instanceof AbruptCompletion), "");
  }

  function Object_fromEntries([iterable = Value.undefined]) {
    {
      const hygienicTemp = RequireObjectCoercible(iterable);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const obj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    Assert(obj.Extensible === Value.true && obj.properties.size === 0, "obj.Extensible === Value.true && obj.properties.size === 0");
    const stepsDefine = CreateDataPropertyOnObjectFunctions;
    let adder = CreateBuiltinFunction(stepsDefine, []);
    Assert(!(adder instanceof AbruptCompletion), "");

    if (adder instanceof Completion) {
      adder = adder.Value;
    }

    return AddEntriesFromIterable(obj, iterable, adder);
  }

  function Object_getOwnPropertyDescriptor([O = Value.undefined, P = Value.undefined]) {
    let obj = ToObject(O);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    let key = ToPropertyKey(P);

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    let desc = obj.GetOwnProperty(key);

    if (desc instanceof AbruptCompletion) {
      return desc;
    }

    if (desc instanceof Completion) {
      desc = desc.Value;
    }

    return FromPropertyDescriptor(desc);
  }

  function Object_getOwnPropertyDescriptors([O = Value.undefined]) {
    let obj = ToObject(O);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    let ownKeys = obj.OwnPropertyKeys();

    if (ownKeys instanceof AbruptCompletion) {
      return ownKeys;
    }

    if (ownKeys instanceof Completion) {
      ownKeys = ownKeys.Value;
    }

    let descriptors = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    Assert(!(descriptors instanceof AbruptCompletion), "");

    if (descriptors instanceof Completion) {
      descriptors = descriptors.Value;
    }

    for (const key of ownKeys) {
      let desc = obj.GetOwnProperty(key);

      if (desc instanceof AbruptCompletion) {
        return desc;
      }

      if (desc instanceof Completion) {
        desc = desc.Value;
      }

      let descriptor = FromPropertyDescriptor(desc);
      Assert(!(descriptor instanceof AbruptCompletion), "");

      if (descriptor instanceof Completion) {
        descriptor = descriptor.Value;
      }

      if (descriptor !== Value.undefined) {
        Assert(!(CreateDataProperty(descriptors, key, descriptor) instanceof AbruptCompletion), "");
      }
    }

    return descriptors;
  }

  function GetOwnPropertyKeys(O, type) {
    let obj = ToObject(O);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    let keys = obj.OwnPropertyKeys();

    if (keys instanceof AbruptCompletion) {
      return keys;
    }

    if (keys instanceof Completion) {
      keys = keys.Value;
    }

    const nameList = [];
    keys.forEach(nextKey => {
      if (Type(nextKey) === type) {
        nameList.push(nextKey);
      }
    });
    return CreateArrayFromList(nameList);
  }

  function Object_getOwnPropertyNames([O = Value.undefined]) {
    return GetOwnPropertyKeys(O, 'String');
  }

  function Object_getOwnPropertySymbols([O = Value.undefined]) {
    return GetOwnPropertyKeys(O, 'Symbol');
  }

  function Object_getPrototypeOf([O = Value.undefined]) {
    let obj = ToObject(O);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    return obj.GetPrototypeOf();
  }

  function Object_is([value1 = Value.undefined, value2 = Value.undefined]) {
    return SameValue(value1, value2);
  }

  function Object_isExtensible([O = Value.undefined]) {
    if (Type(O) !== 'Object') {
      return Value.false;
    }

    return IsExtensible(O);
  }

  function Object_isFrozen([O = Value.undefined]) {
    if (Type(O) !== 'Object') {
      return Value.true;
    }

    return TestIntegrityLevel(O, 'frozen');
  }

  function Object_isSealed([O = Value.undefined]) {
    if (Type(O) !== 'Object') {
      return Value.true;
    }

    return TestIntegrityLevel(O, 'sealed');
  }

  function Object_keys([O = Value.undefined]) {
    let obj = ToObject(O);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    let nameList = EnumerableOwnPropertyNames(obj, 'key');

    if (nameList instanceof AbruptCompletion) {
      return nameList;
    }

    if (nameList instanceof Completion) {
      nameList = nameList.Value;
    }

    return CreateArrayFromList(nameList);
  }

  function Object_preventExtensions([O = Value.undefined]) {
    if (Type(O) !== 'Object') {
      return O;
    }

    let status = O.PreventExtensions();

    if (status instanceof AbruptCompletion) {
      return status;
    }

    if (status instanceof Completion) {
      status = status.Value;
    }

    if (status === Value.false) {
      return surroundingAgent.Throw('TypeError', 'Could not prevent extensions on object');
    }

    return O;
  }

  function Object_seal([O = Value.undefined]) {
    if (Type(O) !== 'Object') {
      return O;
    }

    let status = SetIntegrityLevel(O, 'sealed');

    if (status instanceof AbruptCompletion) {
      return status;
    }

    if (status instanceof Completion) {
      status = status.Value;
    }

    if (status === Value.false) {
      return surroundingAgent.Throw('TypeError', 'Could not seal object');
    }

    return O;
  }

  function Object_setPrototypeOf([O = Value.undefined, proto = Value.undefined]) {
    O = RequireObjectCoercible(O);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    if (Type(proto) !== 'Object' && Type(proto) !== 'Null') {
      return surroundingAgent.Throw('TypeError', 'Prototype must be an Object or null');
    }

    if (Type(O) !== 'Object') {
      return O;
    }

    let status = O.SetPrototypeOf(proto);

    if (status instanceof AbruptCompletion) {
      return status;
    }

    if (status instanceof Completion) {
      status = status.Value;
    }

    if (status === Value.false) {
      return surroundingAgent.Throw('TypeError', 'Could not set prototype of object');
    }

    return O;
  }

  function Object_values([O = Value.undefined]) {
    let obj = ToObject(O);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    let nameList = EnumerableOwnPropertyNames(obj, 'value');

    if (nameList instanceof AbruptCompletion) {
      return nameList;
    }

    if (nameList instanceof Completion) {
      nameList = nameList.Value;
    }

    return CreateArrayFromList(nameList);
  }

  function CreateObject(realmRec) {
    const objectConstructor = BootstrapConstructor(realmRec, ObjectConstructor, 'Object', 1, realmRec.Intrinsics['%ObjectPrototype%'], [['assign', Object_assign, 2], ['create', Object_create, 2], ['defineProperties', Object_defineProperties, 2], ['defineProperty', Object_defineProperty, 3], ['entries', Object_entries, 1], ['freeze', Object_freeze, 1], ['fromEntries', Object_fromEntries, 1], ['getOwnPropertyDescriptor', Object_getOwnPropertyDescriptor, 2], ['getOwnPropertyDescriptors', Object_getOwnPropertyDescriptors, 1], ['getOwnPropertyNames', Object_getOwnPropertyNames, 1], ['getOwnPropertySymbols', Object_getOwnPropertySymbols, 1], ['getPrototypeOf', Object_getPrototypeOf, 1], ['is', Object_is, 2], ['isExtensible', Object_isExtensible, 1], ['isFrozen', Object_isFrozen, 1], ['isSealed', Object_isSealed, 1], ['keys', Object_keys, 1], ['preventExtensions', Object_preventExtensions, 1], ['seal', Object_seal, 1], ['setPrototypeOf', Object_setPrototypeOf, 2], ['values', Object_values, 1]]);
    realmRec.Intrinsics['%Object%'] = objectConstructor;
  }

  // %TypedArrayPrototype%.
  // 22.1.3.27 #sec-array.prototype.sort
  // 22.2.3.26 #sec-%typedarray%.prototype.sort
  //
  // If internalMethodsRestricted is true, then Asserts are used to ensure that
  // "The only internal methods of the this object that the algorithm may call
  // are [[Get]] and [[Set]]," a requirement of %TypedArray%.prototype.sort.

  function ArrayProto_sortBody(obj, len, SortCompare, internalMethodsRestricted = false) {
    len = len.numberValue(); // Collect all elements. Count how many holes we have for error checking.

    const collected = [];
    let holes = 0;

    for (let k = 0; k < len; k += 1) {
      let curProp = ToString(new Value(k));
      Assert(!(curProp instanceof AbruptCompletion), "");

      if (curProp instanceof Completion) {
        curProp = curProp.Value;
      }

      let prop = obj.Get(curProp, obj);

      if (prop instanceof AbruptCompletion) {
        return prop;
      }

      if (prop instanceof Completion) {
        prop = prop.Value;
      }

      if (prop === Value.undefined) {
        Assert(!internalMethodsRestricted, "!internalMethodsRestricted");
        let hasOwn = HasOwnProperty(obj, curProp);

        if (hasOwn instanceof AbruptCompletion) {
          return hasOwn;
        }

        if (hasOwn instanceof Completion) {
          hasOwn = hasOwn.Value;
        }

        if (hasOwn === Value.false) {
          holes += 1;
        } else {
          collected.push(prop);
        }
      } else {
        collected.push(prop);
      }
    }

    if (internalMethodsRestricted) {
      Assert(holes === 0, "holes === 0");
    }

    Assert(collected.length + holes === len, "collected.length + holes === len"); // Get rid of holes by deleting properties at the end.
    // See Note 1: Because non-existent property values always compare greater
    // than undefined property values, and undefined always compares greater
    // than any other value, undefined property values always sort to the end
    // of the result, followed by non-existent property values.

    for (let k = collected.length; k < len; k += 1) {
      let curProp = ToString(new Value(k));
      Assert(!(curProp instanceof AbruptCompletion), "");

      if (curProp instanceof Completion) {
        curProp = curProp.Value;
      }

      {
        const hygienicTemp = DeletePropertyOrThrow(obj, curProp);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    } // Mergesort.


    const lBuffer = [];
    const rBuffer = [];

    for (let step = 1; step < collected.length; step *= 2) {
      for (let start = 0; start < collected.length - 1; start += 2 * step) {
        const sizeLeft = step;
        const mid = start + sizeLeft;
        const sizeRight = Math.min(step, collected.length - mid);

        if (sizeRight < 0) {
          continue;
        } // Merge.


        for (let l = 0; l < sizeLeft; l += 1) {
          lBuffer[l] = collected[start + l];
        }

        for (let r = 0; r < sizeRight; r += 1) {
          rBuffer[r] = collected[mid + r];
        }

        {
          let l = 0;
          let r = 0;
          let o = start;

          while (l < sizeLeft && r < sizeRight) {
            let _hygienicTemp = SortCompare(lBuffer[l], rBuffer[r]);

            if (_hygienicTemp instanceof AbruptCompletion) {
              return _hygienicTemp;
            }

            if (_hygienicTemp instanceof Completion) {
              _hygienicTemp = _hygienicTemp.Value;
            }

            const cmp = _hygienicTemp.numberValue();

            if (cmp <= 0) {
              collected[o] = lBuffer[l];
              o += 1;
              l += 1;
            } else {
              collected[o] = rBuffer[r];
              o += 1;
              r += 1;
            }
          }

          while (l < sizeLeft) {
            collected[o] = lBuffer[l];
            o += 1;
            l += 1;
          }

          while (r < sizeRight) {
            collected[o] = rBuffer[r];
            o += 1;
            r += 1;
          }
        }
      }
    } // Copy the sorted results back to the array.


    for (let k = 0; k < collected.length; k += 1) {
      let curProp = ToString(new Value(k));
      Assert(!(curProp instanceof AbruptCompletion), "");

      if (curProp instanceof Completion) {
        curProp = curProp.Value;
      }

      let _hygienicTemp2 = obj.Set(curProp, collected[k], obj);

      if (_hygienicTemp2 instanceof AbruptCompletion) {
        return _hygienicTemp2;
      }

      if (_hygienicTemp2 instanceof Completion) {
        _hygienicTemp2 = _hygienicTemp2.Value;
      }

      if (_hygienicTemp2 !== Value.true) {
        return surroundingAgent.Throw('CannotSetProperty', curProp, obj);
      }
    }

    return obj;
  }
  function CreateArrayPrototypeShared(realmRec, proto, priorToEvaluatingAlgorithm, objectToLength) {
    // 22.1.3.5 #sec-array.prototype.every
    // 22.2.3.7 #sec-%typedarray%.prototype.every
    function ArrayProto_every([callbackFn = Value.undefined, thisArg], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let len = ToLength(lenProp);

      if (len instanceof AbruptCompletion) {
        return len;
      }

      if (len instanceof Completion) {
        len = len.Value;
      }

      if (IsCallable(callbackFn) === Value.false) {
        return surroundingAgent.Throw('TypeError');
      }

      let T;

      if (thisArg !== undefined) {
        T = thisArg;
      } else {
        T = Value.undefined;
      }

      let k = 0;

      while (k < len.numberValue()) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kPresent = HasProperty(O, Pk);

        if (kPresent instanceof AbruptCompletion) {
          return kPresent;
        }

        if (kPresent instanceof Completion) {
          kPresent = kPresent.Value;
        }

        if (kPresent === Value.true) {
          let kValue = Get(O, Pk);

          if (kValue instanceof AbruptCompletion) {
            return kValue;
          }

          if (kValue instanceof Completion) {
            kValue = kValue.Value;
          }

          let _hygienicTemp3 = Call(callbackFn, T, [kValue, new Value(k), O]);

          if (_hygienicTemp3 instanceof AbruptCompletion) {
            return _hygienicTemp3;
          }

          if (_hygienicTemp3 instanceof Completion) {
            _hygienicTemp3 = _hygienicTemp3.Value;
          }

          const testResult = ToBoolean(_hygienicTemp3);

          if (testResult === Value.false) {
            return Value.false;
          }
        }

        k += 1;
      }

      return Value.true;
    } // 22.1.3.8 #sec-array.prototype.find
    // 22.2.3.10 #sec-%typedarray%.prototype.find


    function ArrayProto_find([predicate = Value.undefined, thisArg], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp4 = ToLength(lenProp);

      if (_hygienicTemp4 instanceof AbruptCompletion) {
        return _hygienicTemp4;
      }

      if (_hygienicTemp4 instanceof Completion) {
        _hygienicTemp4 = _hygienicTemp4.Value;
      }

      const len = _hygienicTemp4.numberValue();

      if (IsCallable(predicate) === Value.false) {
        return surroundingAgent.Throw('TypeError', 'predicate is not callable');
      }

      const T = thisArg || Value.undefined;
      let k = 0;

      while (k < len) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kValue = Get(O, Pk);

        if (kValue instanceof AbruptCompletion) {
          return kValue;
        }

        if (kValue instanceof Completion) {
          kValue = kValue.Value;
        }

        let _hygienicTemp5 = Call(predicate, T, [kValue, new Value(k), O]);

        if (_hygienicTemp5 instanceof AbruptCompletion) {
          return _hygienicTemp5;
        }

        if (_hygienicTemp5 instanceof Completion) {
          _hygienicTemp5 = _hygienicTemp5.Value;
        }

        const testResult = ToBoolean(_hygienicTemp5);

        if (testResult === Value.true) {
          return kValue;
        }

        k += 1;
      }

      return Value.undefined;
    } // 22.1.3.9 #sec-array.prototype.findindex
    // 22.2.3.11 #sec-%typedarray%.prototype.findindex


    function ArrayProto_findIndex([predicate = Value.undefined, thisArg], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp6 = ToLength(lenProp);

      if (_hygienicTemp6 instanceof AbruptCompletion) {
        return _hygienicTemp6;
      }

      if (_hygienicTemp6 instanceof Completion) {
        _hygienicTemp6 = _hygienicTemp6.Value;
      }

      const len = _hygienicTemp6.numberValue();

      if (IsCallable(predicate) === Value.false) {
        return surroundingAgent.Throw('TypeError', 'predicate is not callable');
      }

      const T = thisArg || Value.undefined;
      let k = 0;

      while (k < len) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kValue = Get(O, Pk);

        if (kValue instanceof AbruptCompletion) {
          return kValue;
        }

        if (kValue instanceof Completion) {
          kValue = kValue.Value;
        }

        let _hygienicTemp7 = Call(predicate, T, [kValue, new Value(k), O]);

        if (_hygienicTemp7 instanceof AbruptCompletion) {
          return _hygienicTemp7;
        }

        if (_hygienicTemp7 instanceof Completion) {
          _hygienicTemp7 = _hygienicTemp7.Value;
        }

        const testResult = ToBoolean(_hygienicTemp7);

        if (testResult === Value.true) {
          return new Value(k);
        }

        k += 1;
      }

      return new Value(-1);
    } // 22.1.3.12 #sec-array.prototype.foreach
    // 22.2.3.12 #sec-%typedarray%.prototype.foreach


    function ArrayProto_forEach([callbackfn = Value.undefined, thisArg], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp8 = ToLength(lenProp);

      if (_hygienicTemp8 instanceof AbruptCompletion) {
        return _hygienicTemp8;
      }

      if (_hygienicTemp8 instanceof Completion) {
        _hygienicTemp8 = _hygienicTemp8.Value;
      }

      const len = _hygienicTemp8.numberValue();

      if (IsCallable(callbackfn) === Value.false) {
        return surroundingAgent.Throw('TypeError', 'callbackfn is not callable');
      }

      const T = thisArg || Value.undefined;
      let k = 0;

      while (k < len) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kPresent = HasProperty(O, Pk);

        if (kPresent instanceof AbruptCompletion) {
          return kPresent;
        }

        if (kPresent instanceof Completion) {
          kPresent = kPresent.Value;
        }

        if (kPresent === Value.true) {
          let kValue = Get(O, Pk);

          if (kValue instanceof AbruptCompletion) {
            return kValue;
          }

          if (kValue instanceof Completion) {
            kValue = kValue.Value;
          }

          {
            const hygienicTemp = Call(callbackfn, T, [kValue, new Value(k), O]);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        k += 1;
      }

      return Value.undefined;
    } // 22.1.3.13 #sec-array.prototype.includes
    // 22.2.3.13 #sec-%typedarray%.prototype.includes


    function ArrayProto_includes([searchElement = Value.undefined, fromIndex = Value.undefined], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp9 = ToLength(lenProp);

      if (_hygienicTemp9 instanceof AbruptCompletion) {
        return _hygienicTemp9;
      }

      if (_hygienicTemp9 instanceof Completion) {
        _hygienicTemp9 = _hygienicTemp9.Value;
      }

      const len = _hygienicTemp9.numberValue();

      if (len === 0) {
        return Value.false;
      }

      let _hygienicTemp10 = ToInteger(fromIndex);

      if (_hygienicTemp10 instanceof AbruptCompletion) {
        return _hygienicTemp10;
      }

      if (_hygienicTemp10 instanceof Completion) {
        _hygienicTemp10 = _hygienicTemp10.Value;
      }

      const n = _hygienicTemp10.numberValue();

      if (fromIndex === Value.undefined) {
        Assert(n === 0, "n === 0");
      }

      let k;

      if (n >= 0) {
        k = n;
      } else {
        k = len + n;

        if (k < 0) {
          k = 0;
        }
      }

      while (k < len) {
        let kStr = ToString(new Value(k));
        Assert(!(kStr instanceof AbruptCompletion), "");

        if (kStr instanceof Completion) {
          kStr = kStr.Value;
        }

        let elementK = Get(O, kStr);

        if (elementK instanceof AbruptCompletion) {
          return elementK;
        }

        if (elementK instanceof Completion) {
          elementK = elementK.Value;
        }

        if (SameValueZero(searchElement, elementK) === Value.true) {
          return Value.true;
        }

        k += 1;
      }

      return Value.false;
    } // 22.1.3.14 #sec-array.prototype.indexof
    // 22.2.3.14 #sec-%typedarray%.prototype.indexof


    function ArrayProto_indexOf([searchElement = Value.undefined, fromIndex = Value.undefined], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp11 = ToLength(lenProp);

      if (_hygienicTemp11 instanceof AbruptCompletion) {
        return _hygienicTemp11;
      }

      if (_hygienicTemp11 instanceof Completion) {
        _hygienicTemp11 = _hygienicTemp11.Value;
      }

      const len = _hygienicTemp11.numberValue();

      if (len === 0) {
        return new Value(-1);
      }

      let _hygienicTemp12 = ToInteger(fromIndex);

      if (_hygienicTemp12 instanceof AbruptCompletion) {
        return _hygienicTemp12;
      }

      if (_hygienicTemp12 instanceof Completion) {
        _hygienicTemp12 = _hygienicTemp12.Value;
      }

      const n = _hygienicTemp12.numberValue();

      if (fromIndex === Value.undefined) {
        Assert(n === 0, "n === 0");
      }

      if (n >= len) {
        return new Value(-1);
      }

      let k;

      if (n >= 0) {
        if (Object.is(-0, n)) {
          k = 0;
        } else {
          k = n;
        }
      } else {
        k = len + n;

        if (k < 0) {
          k = 0;
        }
      }

      while (k < len) {
        let kStr = ToString(new Value(k));
        Assert(!(kStr instanceof AbruptCompletion), "");

        if (kStr instanceof Completion) {
          kStr = kStr.Value;
        }

        let kPresent = HasProperty(O, kStr);

        if (kPresent instanceof AbruptCompletion) {
          return kPresent;
        }

        if (kPresent instanceof Completion) {
          kPresent = kPresent.Value;
        }

        if (kPresent === Value.true) {
          let elementK = Get(O, kStr);

          if (elementK instanceof AbruptCompletion) {
            return elementK;
          }

          if (elementK instanceof Completion) {
            elementK = elementK.Value;
          }

          const same = StrictEqualityComparison(searchElement, elementK);

          if (same === Value.true) {
            return new Value(k);
          }
        }

        k += 1;
      }

      return new Value(-1);
    } // 22.1.3.15 #sec-array.prototype.join
    // 22.2.3.15 #sec-%typedarray%.prototype.join


    function ArrayProto_join([separator = Value.undefined], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp13 = ToLength(lenProp);

      if (_hygienicTemp13 instanceof AbruptCompletion) {
        return _hygienicTemp13;
      }

      if (_hygienicTemp13 instanceof Completion) {
        _hygienicTemp13 = _hygienicTemp13.Value;
      }

      const len = _hygienicTemp13.numberValue();

      let sep;

      if (Type(separator) === 'Undefined') {
        sep = ',';
      } else {
        let _hygienicTemp14 = ToString(separator);

        if (_hygienicTemp14 instanceof AbruptCompletion) {
          return _hygienicTemp14;
        }

        if (_hygienicTemp14 instanceof Completion) {
          _hygienicTemp14 = _hygienicTemp14.Value;
        }

        sep = _hygienicTemp14.stringValue();
      }

      let R = '';
      let k = 0;

      while (k < len) {
        if (k > 0) {
          R = `${R}${sep}`;
        }

        let kStr = ToString(new Value(k));
        Assert(!(kStr instanceof AbruptCompletion), "");

        if (kStr instanceof Completion) {
          kStr = kStr.Value;
        }

        let element = Get(O, kStr);

        if (element instanceof AbruptCompletion) {
          return element;
        }

        if (element instanceof Completion) {
          element = element.Value;
        }

        let next;

        if (Type(element) === 'Undefined' || Type(element) === 'Null') {
          next = '';
        } else {
          let _hygienicTemp15 = ToString(element);

          if (_hygienicTemp15 instanceof AbruptCompletion) {
            return _hygienicTemp15;
          }

          if (_hygienicTemp15 instanceof Completion) {
            _hygienicTemp15 = _hygienicTemp15.Value;
          }

          next = _hygienicTemp15.stringValue();
        }

        R = `${R}${next}`;
        k += 1;
      }

      return new Value(R);
    } // 22.1.3.17 #sec-array.prototype.lastindexof
    // 22.2.3.17 #sec-%typedarray%.prototype.lastindexof


    function ArrayProto_lastIndexOf([searchElement = Value.undefined, fromIndex], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp16 = ToLength(lenProp);

      if (_hygienicTemp16 instanceof AbruptCompletion) {
        return _hygienicTemp16;
      }

      if (_hygienicTemp16 instanceof Completion) {
        _hygienicTemp16 = _hygienicTemp16.Value;
      }

      const len = _hygienicTemp16.numberValue();

      if (len === 0) {
        return new Value(-1);
      }

      let n;

      if (fromIndex !== undefined) {
        let _hygienicTemp17 = ToInteger(fromIndex);

        if (_hygienicTemp17 instanceof AbruptCompletion) {
          return _hygienicTemp17;
        }

        if (_hygienicTemp17 instanceof Completion) {
          _hygienicTemp17 = _hygienicTemp17.Value;
        }

        n = _hygienicTemp17.numberValue();
      } else {
        n = len - 1;
      }

      let k;

      if (n >= 0) {
        if (Object.is(n, -0)) {
          k = 0;
        } else {
          k = Math.min(n, len - 1);
        }
      } else {
        k = len + n;
      }

      while (k >= 0) {
        let kStr = ToString(new Value(k));
        Assert(!(kStr instanceof AbruptCompletion), "");

        if (kStr instanceof Completion) {
          kStr = kStr.Value;
        }

        let kPresent = HasProperty(O, kStr);

        if (kPresent instanceof AbruptCompletion) {
          return kPresent;
        }

        if (kPresent instanceof Completion) {
          kPresent = kPresent.Value;
        }

        if (kPresent === Value.true) {
          let elementK = Get(O, kStr);

          if (elementK instanceof AbruptCompletion) {
            return elementK;
          }

          if (elementK instanceof Completion) {
            elementK = elementK.Value;
          }

          const same = StrictEqualityComparison(searchElement, elementK);

          if (same === Value.true) {
            return new Value(k);
          }
        }

        k -= 1;
      }

      return new Value(-1);
    } // 22.1.3.21 #sec-array.prototype.reduce
    // 22.2.3.20 #sec-%typedarray%.prototype.reduce


    function ArrayProto_reduce([callbackfn = Value.undefined, initialValue], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp18 = ToLength(lenProp);

      if (_hygienicTemp18 instanceof AbruptCompletion) {
        return _hygienicTemp18;
      }

      if (_hygienicTemp18 instanceof Completion) {
        _hygienicTemp18 = _hygienicTemp18.Value;
      }

      const len = _hygienicTemp18.numberValue();

      if (IsCallable(callbackfn) === Value.false) {
        return surroundingAgent.Throw('TypeError');
      }

      if (len === 0 && initialValue === undefined) {
        return surroundingAgent.Throw('TypeError', 'Reduce of empty array with no initial value');
      }

      let k = 0;
      let accumulator = Value.undefined;

      if (initialValue !== undefined) {
        accumulator = initialValue;
      } else {
        let kPresent = false;

        while (kPresent === false && k < len) {
          let Pk = ToString(new Value(k));
          Assert(!(Pk instanceof AbruptCompletion), "");

          if (Pk instanceof Completion) {
            Pk = Pk.Value;
          }

          let _hygienicTemp19 = HasProperty(O, Pk);

          if (_hygienicTemp19 instanceof AbruptCompletion) {
            return _hygienicTemp19;
          }

          if (_hygienicTemp19 instanceof Completion) {
            _hygienicTemp19 = _hygienicTemp19.Value;
          }

          kPresent = _hygienicTemp19 === Value.true;

          if (kPresent === true) {
            accumulator = Get(O, Pk);

            if (accumulator instanceof AbruptCompletion) {
              return accumulator;
            }

            if (accumulator instanceof Completion) {
              accumulator = accumulator.Value;
            }
          }

          k += 1;
        }

        if (kPresent === false) {
          return surroundingAgent.Throw('TypeError');
        }
      }

      while (k < len) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kPresent = HasProperty(O, Pk);

        if (kPresent instanceof AbruptCompletion) {
          return kPresent;
        }

        if (kPresent instanceof Completion) {
          kPresent = kPresent.Value;
        }

        if (kPresent === Value.true) {
          let kValue = Get(O, Pk);

          if (kValue instanceof AbruptCompletion) {
            return kValue;
          }

          if (kValue instanceof Completion) {
            kValue = kValue.Value;
          }

          accumulator = Call(callbackfn, Value.undefined, [accumulator, kValue, new Value(k), O]);

          if (accumulator instanceof AbruptCompletion) {
            return accumulator;
          }

          if (accumulator instanceof Completion) {
            accumulator = accumulator.Value;
          }
        }

        k += 1;
      }

      return accumulator;
    } // 22.1.3.22 #sec-array.prototype.reduceright
    // 22.2.3.21 #sec-%typedarray%.prototype.reduceright


    function ArrayProto_reduceRight([callbackfn = Value.undefined, initialValue], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp20 = ToLength(lenProp);

      if (_hygienicTemp20 instanceof AbruptCompletion) {
        return _hygienicTemp20;
      }

      if (_hygienicTemp20 instanceof Completion) {
        _hygienicTemp20 = _hygienicTemp20.Value;
      }

      const len = _hygienicTemp20.numberValue();

      if (IsCallable(callbackfn) === Value.false) {
        return surroundingAgent.Throw('TypeError');
      }

      if (len === 0 && initialValue === undefined) {
        return surroundingAgent.Throw('TypeError', 'Reduce of empty array with no initial value');
      }

      let k = len - 1;
      let accumulator = Value.undefined;

      if (initialValue !== undefined) {
        accumulator = initialValue;
      } else {
        let kPresent = false;

        while (kPresent === false && k >= 0) {
          let Pk = ToString(new Value(k));
          Assert(!(Pk instanceof AbruptCompletion), "");

          if (Pk instanceof Completion) {
            Pk = Pk.Value;
          }

          let _hygienicTemp21 = HasProperty(O, Pk);

          if (_hygienicTemp21 instanceof AbruptCompletion) {
            return _hygienicTemp21;
          }

          if (_hygienicTemp21 instanceof Completion) {
            _hygienicTemp21 = _hygienicTemp21.Value;
          }

          kPresent = _hygienicTemp21 === Value.true;

          if (kPresent === true) {
            accumulator = Get(O, Pk);

            if (accumulator instanceof AbruptCompletion) {
              return accumulator;
            }

            if (accumulator instanceof Completion) {
              accumulator = accumulator.Value;
            }
          }

          k -= 1;
        }

        if (kPresent === false) {
          return surroundingAgent.Throw('TypeError');
        }
      }

      while (k >= 0) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kPresent = HasProperty(O, Pk);

        if (kPresent instanceof AbruptCompletion) {
          return kPresent;
        }

        if (kPresent instanceof Completion) {
          kPresent = kPresent.Value;
        }

        if (kPresent === Value.true) {
          let kValue = Get(O, Pk);

          if (kValue instanceof AbruptCompletion) {
            return kValue;
          }

          if (kValue instanceof Completion) {
            kValue = kValue.Value;
          }

          accumulator = Call(callbackfn, Value.undefined, [accumulator, kValue, new Value(k), O]);

          if (accumulator instanceof AbruptCompletion) {
            return accumulator;
          }

          if (accumulator instanceof Completion) {
            accumulator = accumulator.Value;
          }
        }

        k -= 1;
      }

      return accumulator;
    } // 22.1.3.23 #sec-array.prototype.reverse
    // 22.2.3.22 #sec-%typedarray%.prototype.reverse


    function ArrayProto_reverse(args, {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp22 = ToLength(lenProp);

      if (_hygienicTemp22 instanceof AbruptCompletion) {
        return _hygienicTemp22;
      }

      if (_hygienicTemp22 instanceof Completion) {
        _hygienicTemp22 = _hygienicTemp22.Value;
      }

      const len = _hygienicTemp22.numberValue();

      const middle = Math.floor(len / 2);
      let lower = 0;

      while (lower !== middle) {
        const upper = len - lower - 1;
        let upperP = ToString(new Value(upper));
        Assert(!(upperP instanceof AbruptCompletion), "");

        if (upperP instanceof Completion) {
          upperP = upperP.Value;
        }

        let lowerP = ToString(new Value(lower));
        Assert(!(lowerP instanceof AbruptCompletion), "");

        if (lowerP instanceof Completion) {
          lowerP = lowerP.Value;
        }

        let lowerExists = HasProperty(O, lowerP);

        if (lowerExists instanceof AbruptCompletion) {
          return lowerExists;
        }

        if (lowerExists instanceof Completion) {
          lowerExists = lowerExists.Value;
        }

        let lowerValue;
        let upperValue;

        if (lowerExists === Value.true) {
          lowerValue = Get(O, lowerP);

          if (lowerValue instanceof AbruptCompletion) {
            return lowerValue;
          }

          if (lowerValue instanceof Completion) {
            lowerValue = lowerValue.Value;
          }
        }

        let upperExists = HasProperty(O, upperP);

        if (upperExists instanceof AbruptCompletion) {
          return upperExists;
        }

        if (upperExists instanceof Completion) {
          upperExists = upperExists.Value;
        }

        if (upperExists === Value.true) {
          upperValue = Get(O, upperP);

          if (upperValue instanceof AbruptCompletion) {
            return upperValue;
          }

          if (upperValue instanceof Completion) {
            upperValue = upperValue.Value;
          }
        }

        if (lowerExists === Value.true && upperExists === Value.true) {
          {
            const hygienicTemp = Set$1(O, lowerP, upperValue, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          {
            const hygienicTemp = Set$1(O, upperP, lowerValue, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        } else if (lowerExists === Value.false && upperExists === Value.true) {
          {
            const hygienicTemp = Set$1(O, lowerP, upperValue, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          {
            const hygienicTemp = DeletePropertyOrThrow(O, upperP);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        } else if (lowerExists === Value.true && upperExists === Value.false) {
          {
            const hygienicTemp = DeletePropertyOrThrow(O, lowerP);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          {
            const hygienicTemp = Set$1(O, upperP, lowerValue, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        lower += 1;
      }

      return O;
    } // 22.1.3.26 #sec-array.prototype.some
    // 22.2.3.25 #sec-%typedarray%.prototype.some


    function ArrayProto_some([callbackfn = Value.undefined, thisArg], {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let O = ToObject(thisValue);

      if (O instanceof AbruptCompletion) {
        return O;
      }

      if (O instanceof Completion) {
        O = O.Value;
      }

      let lenProp = objectToLength(O);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp23 = ToLength(lenProp);

      if (_hygienicTemp23 instanceof AbruptCompletion) {
        return _hygienicTemp23;
      }

      if (_hygienicTemp23 instanceof Completion) {
        _hygienicTemp23 = _hygienicTemp23.Value;
      }

      const len = _hygienicTemp23.numberValue();

      if (IsCallable(callbackfn) === Value.false) {
        return surroundingAgent.Throw('TypeError');
      }

      let T;

      if (thisArg !== undefined) {
        T = thisArg;
      } else {
        T = Value.undefined;
      }

      let k = 0;

      while (k < len) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kPresent = HasProperty(O, Pk);

        if (kPresent instanceof AbruptCompletion) {
          return kPresent;
        }

        if (kPresent instanceof Completion) {
          kPresent = kPresent.Value;
        }

        if (kPresent === Value.true) {
          let kValue = Get(O, Pk);

          if (kValue instanceof AbruptCompletion) {
            return kValue;
          }

          if (kValue instanceof Completion) {
            kValue = kValue.Value;
          }

          let _hygienicTemp24 = Call(callbackfn, T, [kValue, new Value(k), O]);

          if (_hygienicTemp24 instanceof AbruptCompletion) {
            return _hygienicTemp24;
          }

          if (_hygienicTemp24 instanceof Completion) {
            _hygienicTemp24 = _hygienicTemp24.Value;
          }

          const testResult = ToBoolean(_hygienicTemp24);

          if (testResult === Value.true) {
            return Value.true;
          }
        }

        k += 1;
      }

      return Value.false;
    } // 22.1.3.29 #sec-array.prototype.tolocalestring
    // 22.2.3.28 #sec-%typedarray%.prototype.tolocalestring


    function ArrayProto_toLocaleString(args, {
      thisValue
    }) {
      {
        const hygienicTemp = priorToEvaluatingAlgorithm(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let array = ToObject(thisValue);

      if (array instanceof AbruptCompletion) {
        return array;
      }

      if (array instanceof Completion) {
        array = array.Value;
      }

      let lenProp = objectToLength(array);

      if (lenProp instanceof AbruptCompletion) {
        return lenProp;
      }

      if (lenProp instanceof Completion) {
        lenProp = lenProp.Value;
      }

      let _hygienicTemp25 = ToLength(lenProp);

      if (_hygienicTemp25 instanceof AbruptCompletion) {
        return _hygienicTemp25;
      }

      if (_hygienicTemp25 instanceof Completion) {
        _hygienicTemp25 = _hygienicTemp25.Value;
      }

      const len = _hygienicTemp25.numberValue();

      const separator = ', ';
      let R = '';
      let k = 0;

      while (k < len) {
        if (k > 0) {
          R = `${R}${separator}`;
        }

        let kStr = ToString(new Value(k));
        Assert(!(kStr instanceof AbruptCompletion), "");

        if (kStr instanceof Completion) {
          kStr = kStr.Value;
        }

        let nextElement = Get(array, kStr);

        if (nextElement instanceof AbruptCompletion) {
          return nextElement;
        }

        if (nextElement instanceof Completion) {
          nextElement = nextElement.Value;
        }

        if (nextElement !== Value.undefined && nextElement !== Value.null) {
          let res = Invoke(nextElement, new Value('toLocaleString'));

          if (res instanceof AbruptCompletion) {
            return res;
          }

          if (res instanceof Completion) {
            res = res.Value;
          }

          let _hygienicTemp26 = ToString(res);

          if (_hygienicTemp26 instanceof AbruptCompletion) {
            return _hygienicTemp26;
          }

          if (_hygienicTemp26 instanceof Completion) {
            _hygienicTemp26 = _hygienicTemp26.Value;
          }

          const S = _hygienicTemp26.stringValue();

          R = `${R}${S}`;
        }

        k += 1;
      }

      return new Value(R);
    }

    assignProps(realmRec, proto, [['every', ArrayProto_every, 1], ['find', ArrayProto_find, 1], ['findIndex', ArrayProto_findIndex, 1], ['forEach', ArrayProto_forEach, 1], ['includes', ArrayProto_includes, 1], ['indexOf', ArrayProto_indexOf, 1], ['join', ArrayProto_join, 1], ['lastIndexOf', ArrayProto_lastIndexOf, 1], ['reduce', ArrayProto_reduce, 1], ['reduceRight', ArrayProto_reduceRight, 1], ['reverse', ArrayProto_reverse, 0], ['some', ArrayProto_some, 1], ['toLocaleString', ArrayProto_toLocaleString, 0]]);
  }

  function ArrayProto_concat(args, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let A = ArraySpeciesCreate(O, new Value(0));

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    let n = 0;
    const items = [O, ...args];

    while (items.length > 0) {
      const E = items.shift();
      let spreadable = IsConcatSpreadable(E);

      if (spreadable instanceof AbruptCompletion) {
        return spreadable;
      }

      if (spreadable instanceof Completion) {
        spreadable = spreadable.Value;
      }

      if (spreadable === Value.true) {
        let k = 0;

        let _hygienicTemp = LengthOfArrayLike(E);

        if (_hygienicTemp instanceof AbruptCompletion) {
          return _hygienicTemp;
        }

        if (_hygienicTemp instanceof Completion) {
          _hygienicTemp = _hygienicTemp.Value;
        }

        const len = _hygienicTemp.numberValue();

        if (n + len > 2 ** 53 - 1) {
          return surroundingAgent.Throw('TypeError', msg('ArrayPastSafeLength'));
        }

        while (k < len) {
          let P = ToString(new Value(k));
          Assert(!(P instanceof AbruptCompletion), "");

          if (P instanceof Completion) {
            P = P.Value;
          }

          let exists = HasProperty(E, P);

          if (exists instanceof AbruptCompletion) {
            return exists;
          }

          if (exists instanceof Completion) {
            exists = exists.Value;
          }

          if (exists === Value.true) {
            let subElement = Get(E, P);

            if (subElement instanceof AbruptCompletion) {
              return subElement;
            }

            if (subElement instanceof Completion) {
              subElement = subElement.Value;
            }

            let nStr = ToString(new Value(n));
            Assert(!(nStr instanceof AbruptCompletion), "");

            if (nStr instanceof Completion) {
              nStr = nStr.Value;
            }

            {
              const hygienicTemp = CreateDataPropertyOrThrow(A, nStr, subElement);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          }

          n += 1;
          k += 1;
        }
      } else {
        if (n >= 2 ** 53 - 1) {
          return surroundingAgent.Throw('TypeError', msg('ArrayPastSafeLength'));
        }

        let nStr = ToString(new Value(n));
        Assert(!(nStr instanceof AbruptCompletion), "");

        if (nStr instanceof Completion) {
          nStr = nStr.Value;
        }

        {
          const hygienicTemp = CreateDataPropertyOrThrow(A, nStr, E);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        n += 1;
      }
    }

    {
      const hygienicTemp = Set$1(A, new Value('length'), new Value(n), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return A;
  } // 22.1.3.3 #sec-array.prototype.copywithin


  function ArrayProto_copyWithin([target = Value.undefined, start = Value.undefined, end = Value.undefined], {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let len = LengthOfArrayLike(O);

    if (len instanceof AbruptCompletion) {
      return len;
    }

    if (len instanceof Completion) {
      len = len.Value;
    }

    let relativeTarget = ToInteger(target);

    if (relativeTarget instanceof AbruptCompletion) {
      return relativeTarget;
    }

    if (relativeTarget instanceof Completion) {
      relativeTarget = relativeTarget.Value;
    }

    let to;

    if (relativeTarget.numberValue() < 0) {
      to = Math.max(len.numberValue() + relativeTarget.numberValue(), 0);
    } else {
      to = Math.min(relativeTarget.numberValue(), len.numberValue());
    }

    let relativeStart = ToInteger(start);

    if (relativeStart instanceof AbruptCompletion) {
      return relativeStart;
    }

    if (relativeStart instanceof Completion) {
      relativeStart = relativeStart.Value;
    }

    let from;

    if (relativeStart.numberValue() < 0) {
      from = Math.max(len.numberValue() + relativeStart.numberValue(), 0);
    } else {
      from = Math.min(relativeStart.numberValue(), len.numberValue());
    }

    let relativeEnd;

    if (end === Value.undefined) {
      relativeEnd = len;
    } else {
      relativeEnd = ToInteger(end);

      if (relativeEnd instanceof AbruptCompletion) {
        return relativeEnd;
      }

      if (relativeEnd instanceof Completion) {
        relativeEnd = relativeEnd.Value;
      }
    }

    let final;

    if (relativeEnd.numberValue() < 0) {
      final = Math.max(len.numberValue() + relativeEnd.numberValue(), 0);
    } else {
      final = Math.min(relativeEnd.numberValue(), len.numberValue());
    }

    let count = Math.min(final - from, len.numberValue() - to);
    let direction;

    if (from < to && to < from + count) {
      direction = -1;
      from += count - 1;
      to += count - 1;
    } else {
      direction = 1;
    }

    while (count > 0) {
      let fromKey = ToString(new Value(from));
      Assert(!(fromKey instanceof AbruptCompletion), "");

      if (fromKey instanceof Completion) {
        fromKey = fromKey.Value;
      }

      let toKey = ToString(new Value(to));
      Assert(!(toKey instanceof AbruptCompletion), "");

      if (toKey instanceof Completion) {
        toKey = toKey.Value;
      }

      let fromPresent = HasProperty(O, fromKey);

      if (fromPresent instanceof AbruptCompletion) {
        return fromPresent;
      }

      if (fromPresent instanceof Completion) {
        fromPresent = fromPresent.Value;
      }

      if (fromPresent === Value.true) {
        let fromVal = Get(O, fromKey);

        if (fromVal instanceof AbruptCompletion) {
          return fromVal;
        }

        if (fromVal instanceof Completion) {
          fromVal = fromVal.Value;
        }

        {
          const hygienicTemp = Set$1(O, toKey, fromVal, Value.true);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      } else {
        {
          const hygienicTemp = DeletePropertyOrThrow(O, toKey);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }

      from += direction;
      to += direction;
      count -= 1;
    }

    return O;
  } // 22.1.3.4 #sec-array.prototype.entries


  function ArrayProto_entries(args, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    return CreateArrayIterator(O, 'key+value');
  } // 22.1.3.6 #sec-array.prototype.fill


  function ArrayProto_fill([value = Value.undefined, start = Value.undefined, end = Value.undefined], {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp2 = LengthOfArrayLike(O);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const len = _hygienicTemp2.numberValue();

    let _hygienicTemp3 = ToInteger(start);

    if (_hygienicTemp3 instanceof AbruptCompletion) {
      return _hygienicTemp3;
    }

    if (_hygienicTemp3 instanceof Completion) {
      _hygienicTemp3 = _hygienicTemp3.Value;
    }

    const relativeStart = _hygienicTemp3.numberValue();

    let k;

    if (relativeStart < 0) {
      k = Math.max(len + relativeStart, 0);
    } else {
      k = Math.min(relativeStart, len);
    }

    let relativeEnd;

    if (Type(end) === 'Undefined') {
      relativeEnd = len;
    } else {
      let _hygienicTemp4 = ToInteger(end);

      if (_hygienicTemp4 instanceof AbruptCompletion) {
        return _hygienicTemp4;
      }

      if (_hygienicTemp4 instanceof Completion) {
        _hygienicTemp4 = _hygienicTemp4.Value;
      }

      relativeEnd = _hygienicTemp4.numberValue();
    }

    let final;

    if (relativeEnd < 0) {
      final = Math.max(len + relativeEnd, 0);
    } else {
      final = Math.min(relativeEnd, len);
    }

    while (k < final) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      {
        const hygienicTemp = Set$1(O, Pk, value, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      k += 1;
    }

    return O;
  } // 22.1.3.7 #sec-array.prototype.filter


  function ArrayProto_filter([callbackfn = Value.undefined, thisArg], {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp5 = LengthOfArrayLike(O);

    if (_hygienicTemp5 instanceof AbruptCompletion) {
      return _hygienicTemp5;
    }

    if (_hygienicTemp5 instanceof Completion) {
      _hygienicTemp5 = _hygienicTemp5.Value;
    }

    const len = _hygienicTemp5.numberValue();

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', callbackfn));
    }

    const T = thisArg || Value.undefined;
    let A = ArraySpeciesCreate(O, new Value(0));

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    let k = 0;
    let to = 0;

    while (k < len) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      let kPresent = HasProperty(O, Pk);

      if (kPresent instanceof AbruptCompletion) {
        return kPresent;
      }

      if (kPresent instanceof Completion) {
        kPresent = kPresent.Value;
      }

      if (kPresent === Value.true) {
        let kValue = Get(O, Pk);

        if (kValue instanceof AbruptCompletion) {
          return kValue;
        }

        if (kValue instanceof Completion) {
          kValue = kValue.Value;
        }

        let _hygienicTemp6 = Call(callbackfn, T, [kValue, new Value(k), O]);

        if (_hygienicTemp6 instanceof AbruptCompletion) {
          return _hygienicTemp6;
        }

        if (_hygienicTemp6 instanceof Completion) {
          _hygienicTemp6 = _hygienicTemp6.Value;
        }

        const selected = ToBoolean(_hygienicTemp6);

        if (selected === Value.true) {
          {
            const hygienicTemp = CreateDataPropertyOrThrow(A, ToString(new Value(to)), kValue);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          to += 1;
        }
      }

      k += 1;
    }

    return A;
  } // 22.1.3.10.1 #sec-flattenintoarray


  function FlattenIntoArray(target, source, sourceLen, start, depth, mapperFunction, thisArg) {
    Assert(Type(target) === 'Object', "Type(target) === 'Object'");
    Assert(Type(source) === 'Object', "Type(source) === 'Object'");
    Assert(sourceLen >= 0, "sourceLen >= 0");
    Assert(start >= 0, "start >= 0"); // Assert: _depth_ is an integer Number, *+&infin;*, or *-&infin;*.
    // Assert(mapperFunction === undefined || (X(IsCallable(mapperFunction)) === Value.true && thisArg !== undefined && depth === 1));

    let targetIndex = start;
    let sourceIndex = 0;

    while (sourceIndex < sourceLen) {
      let P = ToString(new Value(sourceIndex));
      Assert(!(P instanceof AbruptCompletion), "");

      if (P instanceof Completion) {
        P = P.Value;
      }

      let exists = HasProperty(source, P);

      if (exists instanceof AbruptCompletion) {
        return exists;
      }

      if (exists instanceof Completion) {
        exists = exists.Value;
      }

      if (exists === Value.true) {
        let element = Get(source, P);

        if (element instanceof AbruptCompletion) {
          return element;
        }

        if (element instanceof Completion) {
          element = element.Value;
        }

        if (mapperFunction) {
          Assert(thisArg, "thisArg");
          element = Call(mapperFunction, thisArg, [element, new Value(sourceIndex), source]);

          if (element instanceof AbruptCompletion) {
            return element;
          }

          if (element instanceof Completion) {
            element = element.Value;
          }
        }

        let shouldFlatten = Value.false;

        if (depth > 0) {
          shouldFlatten = IsArray(element);

          if (shouldFlatten instanceof AbruptCompletion) {
            return shouldFlatten;
          }

          if (shouldFlatten instanceof Completion) {
            shouldFlatten = shouldFlatten.Value;
          }
        }

        if (shouldFlatten === Value.true) {
          let _hygienicTemp7 = LengthOfArrayLike(element);

          if (_hygienicTemp7 instanceof AbruptCompletion) {
            return _hygienicTemp7;
          }

          if (_hygienicTemp7 instanceof Completion) {
            _hygienicTemp7 = _hygienicTemp7.Value;
          }

          const elementLen = _hygienicTemp7.numberValue();

          targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);

          if (targetIndex instanceof AbruptCompletion) {
            return targetIndex;
          }

          if (targetIndex instanceof Completion) {
            targetIndex = targetIndex.Value;
          }
        } else {
          if (targetIndex >= 2 ** 53 - 1) {
            return surroundingAgent.Throw('TypeError');
          }

          let _val = ToString(new Value(targetIndex));

          Assert(!(_val instanceof AbruptCompletion), "");

          if (_val instanceof Completion) {
            _val = _val.Value;
          }

          {
            const hygienicTemp = CreateDataPropertyOrThrow(target, _val, element);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          targetIndex += 1;
        }
      }

      sourceIndex += 1;
    }

    return targetIndex;
  } // 22.1.3.10 #sec-array.prototype.flat


  function ArrayProto_flat([depth = Value.undefined], {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp8 = LengthOfArrayLike(O);

    if (_hygienicTemp8 instanceof AbruptCompletion) {
      return _hygienicTemp8;
    }

    if (_hygienicTemp8 instanceof Completion) {
      _hygienicTemp8 = _hygienicTemp8.Value;
    }

    const sourceLen = _hygienicTemp8.numberValue();

    let depthNum = 1;

    if (depth !== Value.undefined) {
      let _hygienicTemp9 = ToInteger(depth);

      if (_hygienicTemp9 instanceof AbruptCompletion) {
        return _hygienicTemp9;
      }

      if (_hygienicTemp9 instanceof Completion) {
        _hygienicTemp9 = _hygienicTemp9.Value;
      }

      depthNum = _hygienicTemp9.numberValue();
    }

    let A = ArraySpeciesCreate(O, new Value(0));

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    {
      const hygienicTemp = FlattenIntoArray(A, O, sourceLen, 0, depthNum);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return A;
  } // 22.1.3.11 #sec-array.prototype.flatmap


  function ArrayProto_flatMap([mapperFunction = Value.undefined, thisArg], {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp10 = LengthOfArrayLike(O);

    if (_hygienicTemp10 instanceof AbruptCompletion) {
      return _hygienicTemp10;
    }

    if (_hygienicTemp10 instanceof Completion) {
      _hygienicTemp10 = _hygienicTemp10.Value;
    }

    const sourceLen = _hygienicTemp10.numberValue();

    let _val2 = IsCallable(mapperFunction);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    if (_val2 === Value.false) {
      return surroundingAgent.Throw('TypeError');
    }

    let T;

    if (thisArg) {
      T = thisArg;
    } else {
      T = Value.undefined;
    }

    let A = ArraySpeciesCreate(O, new Value(0));

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    {
      const hygienicTemp = FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, T);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return A;
  } // 22.1.3.16 #sec-array.prototype.keys


  function ArrayProto_keys(args, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    return CreateArrayIterator(O, 'key');
  } // 22.1.3.18 #sec-array.prototype.map


  function ArrayProto_map([callbackfn = Value.undefined, thisArg], {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let len = LengthOfArrayLike(O);

    if (len instanceof AbruptCompletion) {
      return len;
    }

    if (len instanceof Completion) {
      len = len.Value;
    }

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'callbackfn is not callable');
    }

    const T = thisArg || Value.undefined;
    let A = ArraySpeciesCreate(O, len);

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    let k = 0;

    while (k < len.numberValue()) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      let kPresent = HasProperty(O, Pk);

      if (kPresent instanceof AbruptCompletion) {
        return kPresent;
      }

      if (kPresent instanceof Completion) {
        kPresent = kPresent.Value;
      }

      if (kPresent === Value.true) {
        let kValue = Get(O, Pk);

        if (kValue instanceof AbruptCompletion) {
          return kValue;
        }

        if (kValue instanceof Completion) {
          kValue = kValue.Value;
        }

        let mappedValue = Call(callbackfn, T, [kValue, new Value(k), O]);

        if (mappedValue instanceof AbruptCompletion) {
          return mappedValue;
        }

        if (mappedValue instanceof Completion) {
          mappedValue = mappedValue.Value;
        }

        {
          const hygienicTemp = CreateDataPropertyOrThrow(A, Pk, mappedValue);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }

      k += 1;
    }

    return A;
  } // 22.1.3.19 #sec-array.prototype.pop


  function ArrayProto_pop(args, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp11 = LengthOfArrayLike(O);

    if (_hygienicTemp11 instanceof AbruptCompletion) {
      return _hygienicTemp11;
    }

    if (_hygienicTemp11 instanceof Completion) {
      _hygienicTemp11 = _hygienicTemp11.Value;
    }

    const len = _hygienicTemp11.numberValue();

    if (len === 0) {
      {
        const hygienicTemp = Set$1(O, new Value('length'), new Value(0), Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      return Value.undefined;
    } else {
      const newLen = len - 1;
      let index = ToString(new Value(newLen));

      if (index instanceof AbruptCompletion) {
        return index;
      }

      if (index instanceof Completion) {
        index = index.Value;
      }

      let element = Get(O, index);

      if (element instanceof AbruptCompletion) {
        return element;
      }

      if (element instanceof Completion) {
        element = element.Value;
      }

      {
        const hygienicTemp = DeletePropertyOrThrow(O, index);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      {
        const hygienicTemp = Set$1(O, new Value('length'), new Value(newLen), Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      return element;
    }
  } // 22.1.3.20 #sec-array.prototype.push


  function ArrayProto_push(items, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp12 = LengthOfArrayLike(O);

    if (_hygienicTemp12 instanceof AbruptCompletion) {
      return _hygienicTemp12;
    }

    if (_hygienicTemp12 instanceof Completion) {
      _hygienicTemp12 = _hygienicTemp12.Value;
    }

    let len = _hygienicTemp12.numberValue();

    const argCount = items.length;

    if (len + argCount > 2 ** 53 - 1) {
      return surroundingAgent.Throw('TypeError', msg('ArrayPastSafeLength'));
    }

    while (items.length > 0) {
      const E = items.shift();

      let _val3 = ToString(new Value(len));

      Assert(!(_val3 instanceof AbruptCompletion), "");

      if (_val3 instanceof Completion) {
        _val3 = _val3.Value;
      }

      {
        const hygienicTemp = Set$1(O, _val3, E, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      len += 1;
    }

    {
      const hygienicTemp = Set$1(O, new Value('length'), new Value(len), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return new Value(len);
  } // 22.1.3.24 #sec-array.prototype.shift


  function ArrayProto_shift(args, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp13 = LengthOfArrayLike(O);

    if (_hygienicTemp13 instanceof AbruptCompletion) {
      return _hygienicTemp13;
    }

    if (_hygienicTemp13 instanceof Completion) {
      _hygienicTemp13 = _hygienicTemp13.Value;
    }

    const len = _hygienicTemp13.numberValue();

    if (len === 0) {
      {
        const hygienicTemp = Set$1(O, new Value('length'), new Value(0), Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      return Value.undefined;
    }

    let first = Get(O, new Value('0'));

    if (first instanceof AbruptCompletion) {
      return first;
    }

    if (first instanceof Completion) {
      first = first.Value;
    }

    let k = 1;

    while (k < len) {
      let from = ToString(new Value(k));
      Assert(!(from instanceof AbruptCompletion), "");

      if (from instanceof Completion) {
        from = from.Value;
      }

      let to = ToString(new Value(k - 1));
      Assert(!(to instanceof AbruptCompletion), "");

      if (to instanceof Completion) {
        to = to.Value;
      }

      let fromPresent = HasProperty(O, from);

      if (fromPresent instanceof AbruptCompletion) {
        return fromPresent;
      }

      if (fromPresent instanceof Completion) {
        fromPresent = fromPresent.Value;
      }

      if (fromPresent === Value.true) {
        let fromVal = Get(O, from);

        if (fromVal instanceof AbruptCompletion) {
          return fromVal;
        }

        if (fromVal instanceof Completion) {
          fromVal = fromVal.Value;
        }

        {
          const hygienicTemp = Set$1(O, to, fromVal, Value.true);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      } else {
        {
          const hygienicTemp = DeletePropertyOrThrow(O, to);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }

      k += 1;
    }

    let _val4 = ToString(new Value(len - 1));

    Assert(!(_val4 instanceof AbruptCompletion), "");

    if (_val4 instanceof Completion) {
      _val4 = _val4.Value;
    }

    {
      const hygienicTemp = DeletePropertyOrThrow(O, _val4);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    {
      const hygienicTemp = Set$1(O, new Value('length'), new Value(len - 1), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return first;
  } // 22.1.3.25 #sec-array.prototype.slice


  function ArrayProto_slice([start = Value.undefined, end = Value.undefined], {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp14 = LengthOfArrayLike(O);

    if (_hygienicTemp14 instanceof AbruptCompletion) {
      return _hygienicTemp14;
    }

    if (_hygienicTemp14 instanceof Completion) {
      _hygienicTemp14 = _hygienicTemp14.Value;
    }

    const len = _hygienicTemp14.numberValue();

    let _hygienicTemp15 = ToInteger(start);

    if (_hygienicTemp15 instanceof AbruptCompletion) {
      return _hygienicTemp15;
    }

    if (_hygienicTemp15 instanceof Completion) {
      _hygienicTemp15 = _hygienicTemp15.Value;
    }

    const relativeStart = _hygienicTemp15.numberValue();

    let k;

    if (relativeStart < 0) {
      k = Math.max(len + relativeStart, 0);
    } else {
      k = Math.min(relativeStart, len);
    }

    let relativeEnd;

    if (Type(end) === 'Undefined') {
      relativeEnd = len;
    } else {
      let _hygienicTemp16 = ToInteger(end);

      if (_hygienicTemp16 instanceof AbruptCompletion) {
        return _hygienicTemp16;
      }

      if (_hygienicTemp16 instanceof Completion) {
        _hygienicTemp16 = _hygienicTemp16.Value;
      }

      relativeEnd = _hygienicTemp16.numberValue();
    }

    let final;

    if (relativeEnd < 0) {
      final = Math.max(len + relativeEnd, 0);
    } else {
      final = Math.min(relativeEnd, len);
    }

    const count = Math.max(final - k, 0);
    let A = ArraySpeciesCreate(O, new Value(count));

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    let n = 0;

    while (k < final) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      let kPresent = HasProperty(O, Pk);

      if (kPresent instanceof AbruptCompletion) {
        return kPresent;
      }

      if (kPresent instanceof Completion) {
        kPresent = kPresent.Value;
      }

      if (kPresent === Value.true) {
        let kValue = Get(O, Pk);

        if (kValue instanceof AbruptCompletion) {
          return kValue;
        }

        if (kValue instanceof Completion) {
          kValue = kValue.Value;
        }

        let nStr = ToString(new Value(n));
        Assert(!(nStr instanceof AbruptCompletion), "");

        if (nStr instanceof Completion) {
          nStr = nStr.Value;
        }

        {
          const hygienicTemp = CreateDataPropertyOrThrow(A, nStr, kValue);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }

      k += 1;
      n += 1;
    }

    {
      const hygienicTemp = Set$1(A, new Value('length'), new Value(n), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return A;
  } // 22.1.3.27 #sec-array.prototype.sort


  function ArrayProto_sort([comparefn = Value.undefined], {
    thisValue
  }) {
    if (comparefn !== Value.undefined && IsCallable(comparefn) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', comparefn));
    }

    let obj = ToObject(thisValue);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    let len = LengthOfArrayLike(obj);

    if (len instanceof AbruptCompletion) {
      return len;
    }

    if (len instanceof Completion) {
      len = len.Value;
    }

    return ArrayProto_sortBody(obj, len, (x, y) => SortCompare(x, y, comparefn));
  } // 22.1.3.28 #sec-array.prototype.splice


  function ArrayProto_splice(args, {
    thisValue
  }) {
    const [start = Value.undefined, deleteCount = Value.undefined, ...items] = args;
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp17 = LengthOfArrayLike(O);

    if (_hygienicTemp17 instanceof AbruptCompletion) {
      return _hygienicTemp17;
    }

    if (_hygienicTemp17 instanceof Completion) {
      _hygienicTemp17 = _hygienicTemp17.Value;
    }

    const len = _hygienicTemp17.numberValue();

    let _hygienicTemp18 = ToInteger(start);

    if (_hygienicTemp18 instanceof AbruptCompletion) {
      return _hygienicTemp18;
    }

    if (_hygienicTemp18 instanceof Completion) {
      _hygienicTemp18 = _hygienicTemp18.Value;
    }

    const relativeStart = _hygienicTemp18.numberValue();

    let actualStart;

    if (relativeStart < 0) {
      actualStart = Math.max(len + relativeStart, 0);
    } else {
      actualStart = Math.min(relativeStart, len);
    }

    let insertCount;
    let actualDeleteCount;

    if (args.length === 0) {
      insertCount = 0;
      actualDeleteCount = 0;
    } else if (args.length === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = args.length - 2;

      let _hygienicTemp19 = ToInteger(deleteCount);

      if (_hygienicTemp19 instanceof AbruptCompletion) {
        return _hygienicTemp19;
      }

      if (_hygienicTemp19 instanceof Completion) {
        _hygienicTemp19 = _hygienicTemp19.Value;
      }

      const dc = _hygienicTemp19.numberValue();

      actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > 2 ** 53 - 1) {
      return surroundingAgent.Throw('TypeError', msg('ArrayPastSafeLength'));
    }

    let A = ArraySpeciesCreate(O, new Value(actualDeleteCount));

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    let k = 0;

    while (k < actualDeleteCount) {
      let from = ToString(new Value(actualStart + k));
      Assert(!(from instanceof AbruptCompletion), "");

      if (from instanceof Completion) {
        from = from.Value;
      }

      let fromPresent = HasProperty(O, from);

      if (fromPresent instanceof AbruptCompletion) {
        return fromPresent;
      }

      if (fromPresent instanceof Completion) {
        fromPresent = fromPresent.Value;
      }

      if (fromPresent === Value.true) {
        let fromValue = Get(O, from);

        if (fromValue instanceof AbruptCompletion) {
          return fromValue;
        }

        if (fromValue instanceof Completion) {
          fromValue = fromValue.Value;
        }

        let _val5 = ToString(new Value(k));

        Assert(!(_val5 instanceof AbruptCompletion), "");

        if (_val5 instanceof Completion) {
          _val5 = _val5.Value;
        }

        {
          const hygienicTemp = CreateDataPropertyOrThrow(A, _val5, fromValue);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }

      k += 1;
    }

    {
      const hygienicTemp = Set$1(A, new Value('length'), new Value(actualDeleteCount), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const itemCount = items.length;

    if (itemCount < actualDeleteCount) {
      k = actualStart;

      while (k < len - actualDeleteCount) {
        let from = ToString(new Value(k + actualDeleteCount));
        Assert(!(from instanceof AbruptCompletion), "");

        if (from instanceof Completion) {
          from = from.Value;
        }

        let to = ToString(new Value(k + itemCount));
        Assert(!(to instanceof AbruptCompletion), "");

        if (to instanceof Completion) {
          to = to.Value;
        }

        let fromPresent = HasProperty(O, from);

        if (fromPresent instanceof AbruptCompletion) {
          return fromPresent;
        }

        if (fromPresent instanceof Completion) {
          fromPresent = fromPresent.Value;
        }

        if (fromPresent === Value.true) {
          let fromValue = Get(O, from);

          if (fromValue instanceof AbruptCompletion) {
            return fromValue;
          }

          if (fromValue instanceof Completion) {
            fromValue = fromValue.Value;
          }

          {
            const hygienicTemp = Set$1(O, to, fromValue, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        } else {
          {
            const hygienicTemp = DeletePropertyOrThrow(O, to);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        k += 1;
      }

      k = len;

      while (k > len - actualDeleteCount + itemCount) {
        let _val6 = ToString(new Value(k - 1));

        Assert(!(_val6 instanceof AbruptCompletion), "");

        if (_val6 instanceof Completion) {
          _val6 = _val6.Value;
        }

        {
          const hygienicTemp = DeletePropertyOrThrow(O, _val6);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        k -= 1;
      }
    } else if (itemCount > actualDeleteCount) {
      k = len - actualDeleteCount;

      while (k > actualStart) {
        let from = ToString(new Value(k + actualDeleteCount - 1));
        Assert(!(from instanceof AbruptCompletion), "");

        if (from instanceof Completion) {
          from = from.Value;
        }

        let to = ToString(new Value(k + itemCount - 1));
        Assert(!(to instanceof AbruptCompletion), "");

        if (to instanceof Completion) {
          to = to.Value;
        }

        let fromPresent = HasProperty(O, from);

        if (fromPresent instanceof AbruptCompletion) {
          return fromPresent;
        }

        if (fromPresent instanceof Completion) {
          fromPresent = fromPresent.Value;
        }

        if (fromPresent === Value.true) {
          let fromValue = Get(O, from);

          if (fromValue instanceof AbruptCompletion) {
            return fromValue;
          }

          if (fromValue instanceof Completion) {
            fromValue = fromValue.Value;
          }

          {
            const hygienicTemp = Set$1(O, to, fromValue, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        } else {
          {
            const hygienicTemp = DeletePropertyOrThrow(O, to);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        k -= 1;
      }
    }

    k = actualStart;

    while (items.length > 0) {
      const E = items.shift();

      let _val7 = ToString(new Value(k));

      Assert(!(_val7 instanceof AbruptCompletion), "");

      if (_val7 instanceof Completion) {
        _val7 = _val7.Value;
      }

      {
        const hygienicTemp = Set$1(O, _val7, E, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      k += 1;
    }

    {
      const hygienicTemp = Set$1(O, new Value('length'), new Value(len - actualDeleteCount + itemCount), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return A;
  } // 22.1.3.30 #sec-array.prototype.tostring


  function ArrayProto_toString(a, {
    thisValue
  }) {
    let array = ToObject(thisValue);

    if (array instanceof AbruptCompletion) {
      return array;
    }

    if (array instanceof Completion) {
      array = array.Value;
    }

    let func = Get(array, new Value('join'));

    if (func instanceof AbruptCompletion) {
      return func;
    }

    if (func instanceof Completion) {
      func = func.Value;
    }

    if (IsCallable(func) === Value.false) {
      func = surroundingAgent.intrinsic('%ObjProto_toString%');
    }

    return Call(func, array);
  } // 22.1.3.31 #sec-array.prototype.unshift


  function ArrayProto_unshift(args, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp20 = LengthOfArrayLike(O);

    if (_hygienicTemp20 instanceof AbruptCompletion) {
      return _hygienicTemp20;
    }

    if (_hygienicTemp20 instanceof Completion) {
      _hygienicTemp20 = _hygienicTemp20.Value;
    }

    const len = _hygienicTemp20.numberValue();

    const argCount = args.length;

    if (argCount > 0) {
      if (len + argCount > 2 ** 53 - 1) {
        return surroundingAgent.Throw('TypeError', msg('ArrayPastSafeLength'));
      }

      let k = len;

      while (k > 0) {
        let from = ToString(new Value(k - 1));
        Assert(!(from instanceof AbruptCompletion), "");

        if (from instanceof Completion) {
          from = from.Value;
        }

        let to = ToString(new Value(k + argCount - 1));
        Assert(!(to instanceof AbruptCompletion), "");

        if (to instanceof Completion) {
          to = to.Value;
        }

        let fromPresent = HasProperty(O, from);

        if (fromPresent instanceof AbruptCompletion) {
          return fromPresent;
        }

        if (fromPresent instanceof Completion) {
          fromPresent = fromPresent.Value;
        }

        if (fromPresent === Value.true) {
          let fromValue = Get(O, from);

          if (fromValue instanceof AbruptCompletion) {
            return fromValue;
          }

          if (fromValue instanceof Completion) {
            fromValue = fromValue.Value;
          }

          {
            const hygienicTemp = Set$1(O, to, fromValue, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        } else {
          {
            const hygienicTemp = DeletePropertyOrThrow(O, to);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        k -= 1;
      }

      let j = 0;
      const items = args;

      while (items.length !== 0) {
        const E = items.shift();
        let jStr = ToString(new Value(j));
        Assert(!(jStr instanceof AbruptCompletion), "");

        if (jStr instanceof Completion) {
          jStr = jStr.Value;
        }

        {
          const hygienicTemp = Set$1(O, jStr, E, Value.true);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        j += 1;
      }
    }

    {
      const hygienicTemp = Set$1(O, new Value('length'), new Value(len + argCount), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return new Value(len + argCount);
  } // 22.1.3.32 #sec-array.prototype.values


  function ArrayProto_values(args, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    return CreateArrayIterator(O, 'value');
  }

  function CreateArrayPrototype(realmRec) {
    const proto = new ArrayExoticObjectValue();
    proto.Prototype = realmRec.Intrinsics['%ObjectPrototype%'];
    proto.Extensible = Value.true;
    proto.properties.set(new Value('length'), Descriptor({
      Value: new Value(0),
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    assignProps(realmRec, proto, [['concat', ArrayProto_concat, 1], ['copyWithin', ArrayProto_copyWithin, 2], ['entries', ArrayProto_entries, 0], ['fill', ArrayProto_fill, 1], ['filter', ArrayProto_filter, 1], ['flat', ArrayProto_flat, 0], ['flatMap', ArrayProto_flatMap, 1], ['keys', ArrayProto_keys, 0], ['map', ArrayProto_map, 1], ['pop', ArrayProto_pop, 0], ['push', ArrayProto_push, 1], ['shift', ArrayProto_shift, 0], ['slice', ArrayProto_slice, 2], ['sort', ArrayProto_sort, 1], ['splice', ArrayProto_splice, 2], ['toString', ArrayProto_toString, 0], ['unshift', ArrayProto_unshift, 1], ['values', ArrayProto_values, 0]]);
    CreateArrayPrototypeShared(realmRec, proto, () => {}, O => Get(O, new Value('length')));
    proto.DefineOwnProperty(wellKnownSymbols.iterator, proto.GetOwnProperty(new Value('values')));
    {
      const unscopableList = ObjectCreate(Value.null);

      let _val8 = CreateDataProperty(unscopableList, new Value('copyWithin'), Value.true);

      Assert(!(_val8 instanceof AbruptCompletion), "");

      if (_val8 instanceof Completion) {
        _val8 = _val8.Value;
      }

      Assert(_val8 === Value.true, "X(CreateDataProperty(unscopableList, new Value('copyWithin'), Value.true)) === Value.true");

      let _val9 = CreateDataProperty(unscopableList, new Value('entries'), Value.true);

      Assert(!(_val9 instanceof AbruptCompletion), "");

      if (_val9 instanceof Completion) {
        _val9 = _val9.Value;
      }

      Assert(_val9 === Value.true, "X(CreateDataProperty(unscopableList, new Value('entries'), Value.true)) === Value.true");

      let _val10 = CreateDataProperty(unscopableList, new Value('fill'), Value.true);

      Assert(!(_val10 instanceof AbruptCompletion), "");

      if (_val10 instanceof Completion) {
        _val10 = _val10.Value;
      }

      Assert(_val10 === Value.true, "X(CreateDataProperty(unscopableList, new Value('fill'), Value.true)) === Value.true");

      let _val11 = CreateDataProperty(unscopableList, new Value('find'), Value.true);

      Assert(!(_val11 instanceof AbruptCompletion), "");

      if (_val11 instanceof Completion) {
        _val11 = _val11.Value;
      }

      Assert(_val11 === Value.true, "X(CreateDataProperty(unscopableList, new Value('find'), Value.true)) === Value.true");

      let _val12 = CreateDataProperty(unscopableList, new Value('findIndex'), Value.true);

      Assert(!(_val12 instanceof AbruptCompletion), "");

      if (_val12 instanceof Completion) {
        _val12 = _val12.Value;
      }

      Assert(_val12 === Value.true, "X(CreateDataProperty(unscopableList, new Value('findIndex'), Value.true)) === Value.true");

      let _val13 = CreateDataProperty(unscopableList, new Value('flat'), Value.true);

      Assert(!(_val13 instanceof AbruptCompletion), "");

      if (_val13 instanceof Completion) {
        _val13 = _val13.Value;
      }

      Assert(_val13 === Value.true, "X(CreateDataProperty(unscopableList, new Value('flat'), Value.true)) === Value.true");

      let _val14 = CreateDataProperty(unscopableList, new Value('flatMap'), Value.true);

      Assert(!(_val14 instanceof AbruptCompletion), "");

      if (_val14 instanceof Completion) {
        _val14 = _val14.Value;
      }

      Assert(_val14 === Value.true, "X(CreateDataProperty(unscopableList, new Value('flatMap'), Value.true)) === Value.true");

      let _val15 = CreateDataProperty(unscopableList, new Value('includes'), Value.true);

      Assert(!(_val15 instanceof AbruptCompletion), "");

      if (_val15 instanceof Completion) {
        _val15 = _val15.Value;
      }

      Assert(_val15 === Value.true, "X(CreateDataProperty(unscopableList, new Value('includes'), Value.true)) === Value.true");

      let _val16 = CreateDataProperty(unscopableList, new Value('keys'), Value.true);

      Assert(!(_val16 instanceof AbruptCompletion), "");

      if (_val16 instanceof Completion) {
        _val16 = _val16.Value;
      }

      Assert(_val16 === Value.true, "X(CreateDataProperty(unscopableList, new Value('keys'), Value.true)) === Value.true");

      let _val17 = CreateDataProperty(unscopableList, new Value('values'), Value.true);

      Assert(!(_val17 instanceof AbruptCompletion), "");

      if (_val17 instanceof Completion) {
        _val17 = _val17.Value;
      }

      Assert(_val17 === Value.true, "X(CreateDataProperty(unscopableList, new Value('values'), Value.true)) === Value.true");
      Assert(!(proto.DefineOwnProperty(wellKnownSymbols.unscopables, Descriptor({
        Value: unscopableList,
        Writable: Value.false,
        Enumerable: Value.false,
        Configurable: Value.true
      })) instanceof AbruptCompletion), "");
    }
    realmRec.Intrinsics['%ArrayPrototype%'] = proto;
    realmRec.Intrinsics['%ArrayProto_keys%'] = proto.Get(new Value('keys'), proto);
    realmRec.Intrinsics['%ArrayProto_entries%'] = proto.Get(new Value('entries'), proto);
    realmRec.Intrinsics['%ArrayProto_values%'] = proto.Get(new Value('values'), proto);
  }

  function ArrayConstructor(argumentsList, {
    NewTarget
  }) {
    const numberOfArgs = argumentsList.length;

    if (numberOfArgs === 0) {
      // 22.1.1.1 #sec-array-constructor-array
      Assert(numberOfArgs === 0, "numberOfArgs === 0");

      if (Type(NewTarget) === 'Undefined') {
        NewTarget = surroundingAgent.activeFunctionObject;
      }

      const proto = GetPrototypeFromConstructor(NewTarget, '%ArrayPrototype%');
      return ArrayCreate(new Value(0), proto);
    } else if (numberOfArgs === 1) {
      // 22.1.1.2 #sec-array-len
      const [len] = argumentsList;
      Assert(numberOfArgs === 1, "numberOfArgs === 1");

      if (Type(NewTarget) === 'Undefined') {
        NewTarget = surroundingAgent.activeFunctionObject;
      }

      const proto = GetPrototypeFromConstructor(NewTarget, '%ArrayPrototype%');
      const array = ArrayCreate(new Value(0), proto);
      let intLen;

      if (Type(len) !== 'Number') {
        let defineStatus = CreateDataProperty(array, new Value('0'), len);
        Assert(!(defineStatus instanceof AbruptCompletion), "");

        if (defineStatus instanceof Completion) {
          defineStatus = defineStatus.Value;
        }

        Assert(defineStatus === Value.true, "defineStatus === Value.true");
        intLen = new Value(1);
      } else {
        intLen = ToUint32(len);

        if (intLen.numberValue() !== len.numberValue()) {
          return surroundingAgent.Throw('RangeError');
        }
      }

      Set$1(array, new Value('length'), intLen, Value.true);
      return array;
    } else if (numberOfArgs >= 2) {
      // 22.1.1.3 #sec-array-items
      const items = argumentsList;
      Assert(numberOfArgs >= 2, "numberOfArgs >= 2");

      if (Type(NewTarget) === 'Undefined') {
        NewTarget = surroundingAgent.activeFunctionObject;
      }

      const proto = GetPrototypeFromConstructor(NewTarget, '%ArrayPrototype%');
      const array = ArrayCreate(new Value(0), proto);
      let k = 0;

      while (k < numberOfArgs) {
        const Pk = ToString(new Value(k));
        const itemK = items[k];
        let defineStatus = CreateDataProperty(array, Pk, itemK);
        Assert(!(defineStatus instanceof AbruptCompletion), "");

        if (defineStatus instanceof Completion) {
          defineStatus = defineStatus.Value;
        }

        Assert(defineStatus === Value.true, "defineStatus === Value.true");
        k += 1;
      }

      let _val = Get(array, new Value('length'));

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      Assert(_val.numberValue() === numberOfArgs, "X(Get(array, new Value('length'))).numberValue() === numberOfArgs");
      return array;
    }

    throw new OutOfRange('ArrayConstructor', numberOfArgs);
  } // 22.1.2.1 #sec-array.from


  function Array_from([items = Value.undefined, mapfn = Value.undefined, thisArg], {
    thisValue
  }) {
    const C = thisValue;
    let mapping;
    let T;
    let A;

    if (mapfn === Value.undefined) {
      mapping = false;
    } else {
      if (IsCallable(mapfn) === Value.false) {
        return surroundingAgent.Throw('TypeError', msg('NotAFunction', mapfn));
      }

      if (thisArg !== undefined) {
        T = thisArg;
      } else {
        T = Value.undefined;
      }

      mapping = true;
    }

    let usingIterator = GetMethod(items, wellKnownSymbols.iterator);

    if (usingIterator instanceof AbruptCompletion) {
      return usingIterator;
    }

    if (usingIterator instanceof Completion) {
      usingIterator = usingIterator.Value;
    }

    if (usingIterator !== Value.undefined) {
      if (IsConstructor(C) === Value.true) {
        A = Construct(C);

        if (A instanceof AbruptCompletion) {
          return A;
        }

        if (A instanceof Completion) {
          A = A.Value;
        }
      } else {
        A = ArrayCreate(new Value(0));
        Assert(!(A instanceof AbruptCompletion), "");

        if (A instanceof Completion) {
          A = A.Value;
        }
      }

      let iteratorRecord = GetIterator(items, 'sync', usingIterator);

      if (iteratorRecord instanceof AbruptCompletion) {
        return iteratorRecord;
      }

      if (iteratorRecord instanceof Completion) {
        iteratorRecord = iteratorRecord.Value;
      }

      let k = 0;

      while (true) {
        // eslint-disable-line no-constant-condition
        if (k >= 2 ** 53 - 1) {
          const error = new ThrowCompletion(surroundingAgent.Throw('TypeError', msg('ArrayPastSafeLength')).Value);
          return IteratorClose(iteratorRecord, error);
        }

        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let next = IteratorStep(iteratorRecord);

        if (next instanceof AbruptCompletion) {
          return next;
        }

        if (next instanceof Completion) {
          next = next.Value;
        }

        if (next === Value.false) {
          {
            const hygienicTemp = Set$1(A, new Value('length'), new Value(k), Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return A;
        }

        let nextValue = IteratorValue(next);

        if (nextValue instanceof AbruptCompletion) {
          return nextValue;
        }

        if (nextValue instanceof Completion) {
          nextValue = nextValue.Value;
        }

        let mappedValue;

        if (mapping) {
          mappedValue = Call(mapfn, T, [nextValue, new Value(k)]);

          if (mappedValue instanceof AbruptCompletion) {
            return IteratorClose(iteratorRecord, mappedValue);
          }

          mappedValue = mappedValue.Value;
        } else {
          mappedValue = nextValue;
        }

        const defineStatus = CreateDataPropertyOrThrow(A, Pk, mappedValue);

        if (defineStatus instanceof AbruptCompletion) {
          return IteratorClose(iteratorRecord, defineStatus);
        }

        k += 1;
      }
    }

    let arrayLike = ToObject(items);
    Assert(!(arrayLike instanceof AbruptCompletion), "");

    if (arrayLike instanceof Completion) {
      arrayLike = arrayLike.Value;
    }

    let len = LengthOfArrayLike(arrayLike);

    if (len instanceof AbruptCompletion) {
      return len;
    }

    if (len instanceof Completion) {
      len = len.Value;
    }

    if (IsConstructor(C) === Value.true) {
      A = Construct(C, [len]);

      if (A instanceof AbruptCompletion) {
        return A;
      }

      if (A instanceof Completion) {
        A = A.Value;
      }
    } else {
      A = ArrayCreate(len);

      if (A instanceof AbruptCompletion) {
        return A;
      }

      if (A instanceof Completion) {
        A = A.Value;
      }
    }

    let k = 0;

    while (k < len.numberValue()) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      let kValue = Get(arrayLike, Pk);

      if (kValue instanceof AbruptCompletion) {
        return kValue;
      }

      if (kValue instanceof Completion) {
        kValue = kValue.Value;
      }

      let mappedValue;

      if (mapping === true) {
        mappedValue = Call(mapfn, T, [kValue, new Value(k)]);

        if (mappedValue instanceof AbruptCompletion) {
          return mappedValue;
        }

        if (mappedValue instanceof Completion) {
          mappedValue = mappedValue.Value;
        }
      } else {
        mappedValue = kValue;
      }

      {
        const hygienicTemp = CreateDataPropertyOrThrow(A, Pk, mappedValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      k += 1;
    }

    {
      const hygienicTemp = Set$1(A, new Value('length'), len, Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return A;
  } // 22.1.2.2 #sec-array.isarray


  function Array_isArray([arg = Value.undefined]) {
    return IsArray(arg);
  } // 22.1.2.3 #sec-array.of


  function Array_of(items, {
    thisValue
  }) {
    const len = items.length; // Let items be the List of arguments passed to this function.

    const C = thisValue;
    let A;

    if (IsConstructor(C) === Value.true) {
      A = Construct(C, [new Value(len)]);

      if (A instanceof AbruptCompletion) {
        return A;
      }

      if (A instanceof Completion) {
        A = A.Value;
      }
    } else {
      A = ArrayCreate(new Value(len));

      if (A instanceof AbruptCompletion) {
        return A;
      }

      if (A instanceof Completion) {
        A = A.Value;
      }
    }

    let k = 0;

    while (k < len) {
      const kValue = items[k];
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      {
        const hygienicTemp = CreateDataPropertyOrThrow(A, Pk, kValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      k += 1;
    }

    {
      const hygienicTemp = Set$1(A, new Value('length'), new Value(len), Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return A;
  } // 22.1.2.5 #sec-get-array-@@species


  function Array_speciesGetter(args, {
    thisValue
  }) {
    return thisValue;
  }

  function CreateArray(realmRec) {
    const proto = realmRec.Intrinsics['%ArrayPrototype%'];
    const cons = BootstrapConstructor(realmRec, ArrayConstructor, 'Array', 1, proto, [['from', Array_from, 1], ['isArray', Array_isArray, 1], ['of', Array_of, 0], [wellKnownSymbols.species, [Array_speciesGetter]]]);
    realmRec.Intrinsics['%Array%'] = cons;
  }

  function thisBooleanValue(value) {
    if (Type(value) === 'Boolean') {
      return value;
    }

    if (Type(value) === 'Object' && 'BooleanData' in value) {
      const b = value.BooleanData;
      Assert(Type(b) === 'Boolean', "Type(b) === 'Boolean'");
      return b;
    }

    return surroundingAgent.Throw('TypeError');
  }

  function BooleanProto_toString(argList, {
    thisValue
  }) {
    let b = thisBooleanValue(thisValue);

    if (b instanceof AbruptCompletion) {
      return b;
    }

    if (b instanceof Completion) {
      b = b.Value;
    }

    if (b === Value.true) {
      return new Value('true');
    }

    return new Value('false');
  }

  function BooleanProto_valueOf(argList, {
    thisValue
  }) {
    return thisBooleanValue(thisValue);
  }

  function CreateBooleanPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['toString', BooleanProto_toString, 0], ['valueOf', BooleanProto_valueOf, 0]], realmRec.Intrinsics['%ObjectPrototype%']);
    proto.BooleanData = Value.false;
    realmRec.Intrinsics['%BooleanPrototype%'] = proto;
  }

  function BooleanConstructor([value = Value.undefined], {
    NewTarget
  }) {
    const b = ToBoolean(value);

    if (Type(NewTarget) === 'Undefined') {
      return b;
    }

    let O = OrdinaryCreateFromConstructor(NewTarget, '%BooleanPrototype%', ['BooleanData']);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    O.BooleanData = b;
    return O;
  }

  function CreateBoolean(realmRec) {
    const cons = BootstrapConstructor(realmRec, BooleanConstructor, 'Boolean', 1, realmRec.Intrinsics['%BooleanPrototype%'], []);
    realmRec.Intrinsics['%Boolean%'] = cons;
  }

  function thisNumberValue(value) {
    if (Type(value) === 'Number') {
      return value;
    }

    if (Type(value) === 'Object' && 'NumberData' in value) {
      const n = value.NumberData;
      Assert(Type(n) === 'Number', "Type(n) === 'Number'");
      return n;
    }

    return surroundingAgent.Throw('TypeError');
  } // 20.1.3.2 #sec-number.prototype.toexponential


  function NumberProto_toExponential([fractionDigits = Value.undefined], {
    thisValue
  }) {
    let _hygienicTemp = thisNumberValue(thisValue);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    let x = _hygienicTemp.numberValue();

    let _hygienicTemp2 = ToInteger(fractionDigits);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const f = _hygienicTemp2.numberValue();

    Assert(fractionDigits !== Value.undefined || f === 0, "fractionDigits !== Value.undefined || f === 0");

    if (Number.isNaN(x)) {
      return new Value('NaN');
    }

    let s = '';

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x === Infinity) {
      return new Value(`${s}Infinity`);
    }

    if (f < 0 || f > 100) {
      return surroundingAgent.Throw('RangeError', 'Number.prototype.toExponential argument must be between 0 and 100');
    }

    let m;
    let e;

    if (x === 0) {
      m = '0'.repeat(f + 1);
      e = 0;
    } else {
      let n;

      m = String(n);
      return surroundingAgent.Throw('Error', 'Number.prototype.toExponential is not fully implemented');
    }

    if (f !== 0) {
      const a = m[0];
      const b = m.slice(1);
      m = `${a}.${b}`;
    }

    let c;
    let d;

    if (e === 0) {
      c = '+';
      d = '0';
    } else {
      if (e > 0) {
        c = '+';
      } else {
        c = '-';
        e = -e;
      }

      d = String(e);
    }

    m = `${m}e${c}${d}`;
    return new Value(`${s}${m}`);
  } // 20.1.3.3 #sec-number.prototype.tofixed


  function NumberProto_toFixed([fractionDigits = Value.undefined], {
    thisValue
  }) {
    let _hygienicTemp3 = thisNumberValue(thisValue);

    if (_hygienicTemp3 instanceof AbruptCompletion) {
      return _hygienicTemp3;
    }

    if (_hygienicTemp3 instanceof Completion) {
      _hygienicTemp3 = _hygienicTemp3.Value;
    }

    let x = _hygienicTemp3.numberValue();

    let _hygienicTemp4 = ToInteger(fractionDigits);

    if (_hygienicTemp4 instanceof AbruptCompletion) {
      return _hygienicTemp4;
    }

    if (_hygienicTemp4 instanceof Completion) {
      _hygienicTemp4 = _hygienicTemp4.Value;
    }

    const f = _hygienicTemp4.numberValue();

    Assert(fractionDigits !== Value.undefined || f === 0, "fractionDigits !== Value.undefined || f === 0");

    if (f < 0 || f > 100) {
      return surroundingAgent.Throw('RangeError', 'Number.prototype.toFixed argument must be between 0 and 100');
    }

    if (Number.isNaN(x)) {
      return new Value('NaN');
    }

    let s = '';

    if (x < 0) {
      s = '-';
      x = -x;
    }

    let m;

    if (x >= 10 ** 21) {
      let _val = ToString(new Value(x));

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      m = _val.stringValue();
    } else {
      // TODO: compute n.
      // if (n === 0) {
      //   m = '0';
      // } else {
      //   m = String(n);
      // }
      // if (f !== 0) {
      //   let k = m.length;
      //   if (k <= f) {
      //     const z = '0'.repeat(f + 1 - k);
      //     m = `${z}${m}`;
      //     k = f + 1;
      //   }
      //   const a = m.slice(0, k - f);
      //   const b = m.slice(k - f);
      //   m = `${a}.${b}`;
      // }
      return surroundingAgent.Throw('Error', 'Number.prototype.toFixed is not fully implemented');
    }

    return new Value(`${s}${m}`);
  } // 20.1.3.4 #sec-number.prototype.tolocalestring


  function NumberProto_toLocaleString() {
    return surroundingAgent.Throw('Error', 'Number.prototype.toLocaleString is not implemented');
  } // 20.1.3.5 #sec-number.prototype.toprecision


  function NumberProto_toPrecision([precision = Value.undefined], {
    thisValue
  }) {
    let _hygienicTemp5 = thisNumberValue(thisValue);

    if (_hygienicTemp5 instanceof AbruptCompletion) {
      return _hygienicTemp5;
    }

    if (_hygienicTemp5 instanceof Completion) {
      _hygienicTemp5 = _hygienicTemp5.Value;
    }

    let x = _hygienicTemp5.numberValue();

    if (precision === Value.undefined) {
      let _val2 = ToString(new Value(x));

      Assert(!(_val2 instanceof AbruptCompletion), "");

      if (_val2 instanceof Completion) {
        _val2 = _val2.Value;
      }

      return _val2;
    }

    let _hygienicTemp6 = ToInteger(precision);

    if (_hygienicTemp6 instanceof AbruptCompletion) {
      return _hygienicTemp6;
    }

    if (_hygienicTemp6 instanceof Completion) {
      _hygienicTemp6 = _hygienicTemp6.Value;
    }

    const p = _hygienicTemp6.numberValue();

    if (Number.isNaN(x)) {
      return new Value('NaN');
    }

    let s = '';

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x === Infinity) {
      return new Value(`${s}Infinity`);
    }

    if (p < 1 || p > 100) {
      return surroundingAgent.Throw('RangeError', 'Number.prototype.toPrecision argument must be between 1 and 100');
    }

    let m;
    let e;

    if (x === 0) {
      m = '0'.repeat(p);
      e = 0;
    } else {
      // TODO: compute e and n.
      // m = String(n);
      // if (e < -6 || e >= p) {
      //   Assert(e !== 0);
      //   if (p !== 1) {
      //     const a = m[0];
      //     const b = m.slice(1);
      //     m = `${a}.${b}`;
      //   }
      //   let c;
      //   if (e > 0) {
      //     c = '+';
      //   } else {
      //     c = '-';
      //     e = -e;
      //   }
      //   const d = String(e);
      //   return new Value(`${s}${m}e${c}${d}`);
      // }
      return surroundingAgent.Throw('Error', 'Number.prototype.toPrecision is not fully implemented');
    }

    if (e === p - 1) {
      return new Value(`${s}${m}`);
    }

    if (e >= 0) {
      m = `${m.slice(0, e + 1)}.${m.slice(e + 1)}`;
    } else {
      m = `0.${'0'.repeat(-(e + 1))}${m}`;
    }

    return new Value(`${s}${m}`);
  } // 20.1.3.6 #sec-number.prototype.tostring


  function NumberProto_toString(args, {
    thisValue
  }) {
    const [radix] = args;
    let x = thisNumberValue(thisValue);

    if (x instanceof AbruptCompletion) {
      return x;
    }

    if (x instanceof Completion) {
      x = x.Value;
    }

    let radixNumber;

    if (args.length === 0 || Type(radix) === 'Undefined') {
      radixNumber = 10;
    } else {
      let _hygienicTemp7 = ToInteger(radix);

      if (_hygienicTemp7 instanceof AbruptCompletion) {
        return _hygienicTemp7;
      }

      if (_hygienicTemp7 instanceof Completion) {
        _hygienicTemp7 = _hygienicTemp7.Value;
      }

      radixNumber = _hygienicTemp7.numberValue();
    }

    if (radixNumber < 2 || radixNumber > 36) {
      return surroundingAgent.Throw('TypeError');
    }

    if (radixNumber === 10) {
      let _val3 = ToString(x);

      Assert(!(_val3 instanceof AbruptCompletion), "");

      if (_val3 instanceof Completion) {
        _val3 = _val3.Value;
      }

      return _val3;
    } // FIXME(devsnek): Return the String representation of this Number
    // value using the radix specified by radixNumber. Letters a-z are
    // used for digits with values 10 through 35. The precise algorithm
    // is implementation-dependent, however the algorithm should be a
    // generalization of that specified in 7.1.12.1.


    return surroundingAgent.Throw('TypeError', 'NumberToString');
  } // 20.1.3.7 #sec-number.prototype.valueof


  function NumberProto_valueOf(args, {
    thisValue
  }) {
    return thisNumberValue(thisValue);
  }

  function CreateNumberPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['toExponential', NumberProto_toExponential, 1], ['toFixed', NumberProto_toFixed, 1], ['toLocaleString', NumberProto_toLocaleString, 0], ['toPrecision', NumberProto_toPrecision, 1], ['toString', NumberProto_toString, 0], ['valueOf', NumberProto_valueOf, 0]], realmRec.Intrinsics['%ObjectPrototype%']);
    proto.NumberData = new Value(0);
    realmRec.Intrinsics['%NumberPrototype%'] = proto;
  }

  function NumberConstructor(args, {
    NewTarget
  }) {
    const [value] = args;
    let n;

    if (args.length === 0) {
      n = new Value(0);
    } else {
      n = ToNumber(value);

      if (n instanceof AbruptCompletion) {
        return n;
      }

      if (n instanceof Completion) {
        n = n.Value;
      }
    }

    if (NewTarget === Value.undefined) {
      return n;
    }

    const O = OrdinaryCreateFromConstructor(NewTarget, '%NumberPrototype%', ['NumberData']);
    O.NumberData = n;
    return O;
  } // 20.1.2.2 #sec-number.isfinite


  function Number_isFinite([number = Value.undefined]) {
    if (Type(number) !== 'Number') {
      return Value.false;
    }

    if (number.isNaN() || number.isInfinity()) {
      return Value.false;
    }

    return Value.true;
  } // 20.1.2.3 #sec-number.isinteger


  function Number_isInteger([number = Value.undefined]) {
    let _val = IsInteger(number);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    return _val;
  } // 20.1.2.4 #sec-number.isnan


  function Number_isNaN([number = Value.undefined]) {
    if (Type(number) !== 'Number') {
      return Value.false;
    }

    if (number.isNaN()) {
      return Value.true;
    }

    return Value.false;
  } // 20.1.2.5 #sec-number.issafeinteger


  function Number_isSafeInteger([number = Value.undefined]) {
    if (Type(number) !== 'Number') {
      return Value.false;
    }

    let _val2 = IsInteger(number);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    if (_val2 === Value.true) {
      if (Math.abs(number.numberValue()) <= 2 ** 53 - 1) {
        return Value.true;
      }
    }

    return Value.false;
  }

  function CreateNumber(realmRec) {
    const override = {
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    };
    const numberConstructor = BootstrapConstructor(realmRec, NumberConstructor, 'Number', 1, realmRec.Intrinsics['%NumberPrototype%'], [['EPSILON', new Value(Number.EPSILON), undefined, override], ['MAX_SAFE_INTEGER', new Value(Number.MAX_SAFE_INTEGER), undefined, override], ['MAX_VALUE', new Value(Number.MAX_VALUE), undefined, override], ['MIN_SAFE_INTEGER', new Value(Number.MIN_SAFE_INTEGER), undefined, override], ['MIN_VALUE', new Value(Number.MIN_VALUE), undefined, override], ['NaN', new Value(NaN), undefined, override], ['NEGATIVE_INFINITY', new Value(-Infinity), undefined, override], ['POSITIVE_INFINITY', new Value(Infinity), undefined, override], ['isFinite', Number_isFinite, 1], ['isInteger', Number_isInteger, 1], ['isNaN', Number_isNaN, 1], ['isSafeInteger', Number_isSafeInteger, 1]]); // 20.1.2.12 #sec-number.parsefloat
    // The value of the Number.parseFloat data property is the same built-in function object that is the value of the parseFloat property of the global object defined in 18.2.4.

    Assert(!(numberConstructor.DefineOwnProperty(new Value('parseFloat'), Descriptor({
      Value: realmRec.Intrinsics['%parseFloat%'],
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), ""); // 20.1.2.13 #sec-number.parseint
    // The value of the Number.parseInt data property is the same built-in function object that is the value of the parseInt property of the global object defined in 18.2.5.

    Assert(!(numberConstructor.DefineOwnProperty(new Value('parseInt'), Descriptor({
      Value: realmRec.Intrinsics['%parseInt%'],
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%Number%'] = numberConstructor;
  }

  function FunctionProto_apply([thisArg = Value.undefined, argArray = Value.undefined], {
    thisValue: func
  }) {
    if (IsCallable(func) === Value.false) {
      return surroundingAgent.Throw('TypeError');
    }

    if (Type(argArray) === 'Undefined' || Type(argArray) === 'Null') {
      return Call(func, thisArg);
    }

    let argList = CreateListFromArrayLike(argArray);

    if (argList instanceof AbruptCompletion) {
      return argList;
    }

    if (argList instanceof Completion) {
      argList = argList.Value;
    }
    return Call(func, thisArg, argList);
  }

  function BoundFunctionExoticObjectCall(thisArgument, argumentsList) {
    const F = this;
    const target = F.BoundTargetFunction;
    const boundThis = F.BoundThis;
    const boundArgs = F.BoundArguments;
    const args = [...boundArgs, ...argumentsList];
    return Call(target, boundThis, args);
  }

  function BoundFunctionExoticObjectConstruct(argumentsList, newTarget) {
    const F = this;
    const target = F.BoundTargetFunction;
    Assert(IsConstructor(target) === Value.true, "IsConstructor(target) === Value.true");
    const boundArgs = F.BoundArguments;
    const args = [...boundArgs, ...argumentsList];

    if (SameValue(F, newTarget) === Value.true) {
      newTarget = target;
    }

    return Construct(target, args, newTarget);
  } // 9.4.1.3 #sec-boundfunctioncreate


  function BoundFunctionCreate(targetFunction, boundThis, boundArgs) {
    Assert(Type(targetFunction) === 'Object', "Type(targetFunction) === 'Object'");
    let proto = targetFunction.GetPrototypeOf();

    if (proto instanceof AbruptCompletion) {
      return proto;
    }

    if (proto instanceof Completion) {
      proto = proto.Value;
    }

    const obj = new ObjectValue();
    obj.Call = BoundFunctionExoticObjectCall;

    if (IsConstructor(targetFunction) === Value.true) {
      obj.Construct = BoundFunctionExoticObjectConstruct;
    }

    obj.Prototype = proto;
    obj.Extensible = Value.true;
    obj.BoundTargetFunction = targetFunction;
    obj.BoundThis = boundThis;
    obj.BoundArguments = boundArgs;
    return obj;
  }

  function FunctionProto_bind([thisArg = Value.undefined, ...args], {
    thisValue
  }) {
    const Target = thisValue;

    if (IsCallable(Target) === Value.false) {
      return surroundingAgent.Throw('TypeError');
    } // Let args be a new (possibly empty) List consisting of all
    // of the argument values provided after thisArg in order.


    let F = BoundFunctionCreate(Target, thisArg, args);

    if (F instanceof AbruptCompletion) {
      return F;
    }

    if (F instanceof Completion) {
      F = F.Value;
    }

    let targetHasLength = HasOwnProperty(Target, new Value('length'));

    if (targetHasLength instanceof AbruptCompletion) {
      return targetHasLength;
    }

    if (targetHasLength instanceof Completion) {
      targetHasLength = targetHasLength.Value;
    }

    let L;

    if (targetHasLength === Value.true) {
      let targetLen = Get(Target, new Value('length'));

      if (targetLen instanceof AbruptCompletion) {
        return targetLen;
      }

      if (targetLen instanceof Completion) {
        targetLen = targetLen.Value;
      }

      if (Type(targetLen) !== 'Number') {
        L = 0;
      } else {
        let _hygienicTemp = ToInteger(targetLen);

        if (_hygienicTemp instanceof AbruptCompletion) {
          return _hygienicTemp;
        }

        if (_hygienicTemp instanceof Completion) {
          _hygienicTemp = _hygienicTemp.Value;
        }

        targetLen = _hygienicTemp.numberValue();
        L = Math.max(0, targetLen - args.length);
      }
    } else {
      L = 0;
    }

    Assert(!(SetFunctionLength(F, new Value(L)) instanceof AbruptCompletion), "");
    let targetName = Get(Target, new Value('name'));

    if (targetName instanceof AbruptCompletion) {
      return targetName;
    }

    if (targetName instanceof Completion) {
      targetName = targetName.Value;
    }

    if (Type(targetName) !== 'String') {
      targetName = new Value('');
    }

    SetFunctionName(F, targetName, new Value('bound'));
    return F;
  }

  function FunctionProto_call([thisArg = Value.undefined, ...args], {
    thisValue: func
  }) {
    if (IsCallable(func) === Value.false) {
      return surroundingAgent.Throw('TypeError');
    }

    const argList = [];

    for (const arg of args) {
      argList.push(arg);
    }
    return Call(func, thisArg, argList);
  }

  function FunctionProto_toString(args, {
    thisValue: func
  }) {
    if ('BoundTargetFunction' in func || 'nativeFunction' in func) {
      const name = func.properties.get(new Value('name'));

      if (name !== undefined) {
        return new Value(`function ${name.Value.stringValue()}() { [native code] }`);
      }

      return new Value('function() { [native code] }');
    }

    let _val = HostHasSourceTextAvailable(func);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    if (Type(func) === 'Object' && 'SourceText' in func && Type(func.SourceText) === 'String' && _val === Value.true) {
      return func.SourceText;
    }

    if (Type(func) === 'Object' && IsCallable(func) === Value.true) {
      return new Value('function() { [native code] }');
    }

    return surroundingAgent.Throw('TypeError', msg('NotAFunction', func));
  }

  function FunctionProto_hasInstance([V = Value.undefined], {
    thisValue
  }) {
    const F = thisValue;
    return OrdinaryHasInstance(F, V);
  }

  function CreateFunctionPrototype(realmRec) {
    Assert(realmRec.Intrinsics['%FunctionPrototype%'], "realmRec.Intrinsics['%FunctionPrototype%']");
    const proto = realmRec.Intrinsics['%FunctionPrototype%'];
    proto.Prototype = realmRec.Intrinsics['%ObjectPrototype%'];
    const readonly = {
      Writable: Value.false,
      Configurable: Value.false
    };
    assignProps(realmRec, proto, [['apply', FunctionProto_apply, 2], ['bind', FunctionProto_bind, 1], ['call', FunctionProto_call, 1], ['toString', FunctionProto_toString, 0], [wellKnownSymbols.hasInstance, FunctionProto_hasInstance, 1, readonly]]);
  }

  function FunctionConstructor(args, {
    NewTarget
  }) {
    const C = surroundingAgent.activeFunctionObject;
    return CreateDynamicFunction(C, NewTarget, 'normal', args);
  }

  function CreateFunction(realmRec) {
    const cons = BootstrapConstructor(realmRec, FunctionConstructor, 'Function', 1, realmRec.Intrinsics['%FunctionPrototype%'], []);
    realmRec.Intrinsics['%Function%'] = cons;
  }

  function thisSymbolValue(value) {
    if (Type(value) === 'Symbol') {
      return value;
    }

    if (Type(value) === 'Object' && 'SymbolData' in value) {
      const s = value.SymbolData;
      Assert(Type(s) === 'Symbol', "Type(s) === 'Symbol'");
      return s;
    }

    return surroundingAgent.Throw('TypeError');
  }

  function SymbolProto_toString(argList, {
    thisValue
  }) {
    let sym = thisSymbolValue(thisValue);

    if (sym instanceof AbruptCompletion) {
      return sym;
    }

    if (sym instanceof Completion) {
      sym = sym.Value;
    }

    return SymbolDescriptiveString(sym);
  }

  function SymbolProto_descriptionGetter(argList, {
    thisValue
  }) {
    const s = thisValue;
    let sym = thisSymbolValue(s);

    if (sym instanceof AbruptCompletion) {
      return sym;
    }

    if (sym instanceof Completion) {
      sym = sym.Value;
    }

    return sym.Description;
  }

  function SymbolProto_valueOf(argList, {
    thisValue
  }) {
    return thisSymbolValue(thisValue);
  }

  function SymbolProto_toPrimitive(argList, {
    thisValue
  }) {
    return thisSymbolValue(thisValue);
  }

  function CreateSymbolPrototype(realmRec) {
    const override = {
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    };
    const proto = BootstrapPrototype(realmRec, [['toString', SymbolProto_toString, 0], ['description', [SymbolProto_descriptionGetter]], ['valueOf', SymbolProto_valueOf, 0], [wellKnownSymbols.toPrimitive, SymbolProto_toPrimitive, 1, override], [wellKnownSymbols.toStringTag, new Value('Symbol'), undefined, override]], realmRec.Intrinsics['%ObjectPrototype%']);
    realmRec.Intrinsics['%SymbolPrototype%'] = proto;
  }

  const GlobalSymbolRegistry = [];

  function SymbolConstructor([description = Value.undefined], {
    NewTarget
  }) {
    if (Type(NewTarget) !== 'Undefined') {
      return surroundingAgent.Throw('TypeError');
    }

    let descString;

    if (description === Value.undefined) {
      descString = Value.undefined;
    } else {
      descString = ToString(description);

      if (descString instanceof AbruptCompletion) {
        return descString;
      }

      if (descString instanceof Completion) {
        descString = descString.Value;
      }
    }

    return new SymbolValue(descString);
  }

  function Symbol_for([key = Value.undefined]) {
    let stringKey = ToString(key);

    if (stringKey instanceof AbruptCompletion) {
      return stringKey;
    }

    if (stringKey instanceof Completion) {
      stringKey = stringKey.Value;
    }

    for (const e of GlobalSymbolRegistry) {
      if (SameValue(e.Key, stringKey) === Value.true) {
        return e.Symbol;
      }
    } // Assert: GlobalSymbolRegistry does not currently contain an entry for stringKey.


    const newSymbol = new SymbolValue(stringKey);
    GlobalSymbolRegistry.push({
      Key: stringKey,
      Symbol: newSymbol
    });
    return newSymbol;
  }

  function Symbol_keyFor([sym = Value.undefined]) {
    if (Type(sym) !== 'Symbol') {
      return surroundingAgent.Throw('TypeError');
    }

    for (const e of GlobalSymbolRegistry) {
      if (SameValue(e.Symbol, sym) === Value.true) {
        return e.Key;
      }
    }

    return Value.undefined;
  }

  function CreateSymbol(realmRec) {
    const symbolConstructor = BootstrapConstructor(realmRec, SymbolConstructor, 'Symbol', 0, realmRec.Intrinsics['%SymbolPrototype%'], [['for', Symbol_for, 1], ['keyFor', Symbol_keyFor, 1]]);

    for (const [name, sym] of Object.entries(wellKnownSymbols)) {
      symbolConstructor.DefineOwnProperty(new Value(name), Descriptor({
        Value: sym,
        Writable: Value.false,
        Enumerable: Value.false,
        Configurable: Value.false
      }));
    }

    symbolConstructor.DefineOwnProperty(new Value('prototype'), Descriptor({
      Value: realmRec.Intrinsics['%SymbolPrototype%'],
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    realmRec.Intrinsics['%Symbol%'] = symbolConstructor;
  }

  function Math_abs([x = Value.undefined]) {
    x = ToNumber(x);

    if (x instanceof AbruptCompletion) {
      return x;
    }

    if (x instanceof Completion) {
      x = x.Value;
    }

    if (x.isNaN()) {
      return x;
    } else if (Object.is(x.numberValue(), -0)) {
      return new Value(0);
    } else if (x.isInfinity()) {
      return new Value(Infinity);
    }

    if (x.numberValue() < 0) {
      return new Value(-x.numberValue());
    }

    return x;
  } // 20.2.2.2 #sec-math.acos


  function Math_acos([x = Value.undefined]) {
    x = ToNumber(x);

    if (x instanceof AbruptCompletion) {
      return x;
    }

    if (x instanceof Completion) {
      x = x.Value;
    }

    if (x.isNaN()) {
      return x;
    } else if (x.numberValue() > 1) {
      return new Value(NaN);
    } else if (x.numberValue() < -1) {
      return new Value(NaN);
    } else if (x.numberValue() === 1) {
      return new Value(+0);
    }

    return new Value(Math.acos(x.numberValue()));
  } // 20.2 #sec-math-object


  function CreateMath(realmRec) {
    // 20.2.1 #sec-value-properties-of-the-math-object
    const readonly = {
      Writable: Value.false,
      Configurable: Value.false
    };
    const valueProps = [['E', 2.7182818284590452354], ['LN10', 2.302585092994046], ['LN2', 0.6931471805599453], ['LOG10E', 0.4342944819032518], ['LOG2E', 1.4426950408889634], ['PI', 3.1415926535897932], ['SQRT1_2', 0.7071067811865476], ['SQRT2', 1.4142135623730951]].map(([name, value]) => [name, new Value(value), undefined, readonly]); // @@toStringTag is handled in the BootstrapPrototype() call.

    const mathObj = BootstrapPrototype(realmRec, [...valueProps, ['abs', Math_abs, 1], ['acos', Math_acos, 1]], realmRec.Intrinsics['%ObjectPrototype%'], 'Math'); // 20.2.2 #sec-function-properties-of-the-math-object

    [['acosh', 1], ['asin', 1], ['asinh', 1], ['atan', 1], ['atanh', 1], ['atan2', 2], ['cbrt', 1], ['ceil', 1], ['clz32', 1], ['cos', 1], ['cosh', 1], ['exp', 1], ['expm1', 1], ['floor', 1], ['fround', 1], ['hypot', 2], ['imul', 2], ['log', 1], ['log1p', 1], ['log10', 1], ['log2', 1], ['max', 2], ['min', 2], ['pow', 2], ['random', 0], ['round', 1], ['sign', 1], ['sin', 1], ['sinh', 1], ['sqrt', 1], ['tan', 1], ['tanh', 1], ['trunc', 1]].forEach(([name, length]) => {
      // TODO(18): Math
      const func = CreateBuiltinFunction(args => {
        for (let i = 0; i < args.length; i += 1) {
          let _hygienicTemp = ToNumber(args[i]);

          if (_hygienicTemp instanceof AbruptCompletion) {
            return _hygienicTemp;
          }

          if (_hygienicTemp instanceof Completion) {
            _hygienicTemp = _hygienicTemp.Value;
          }

          args[i] = _hygienicTemp.numberValue();
        }

        return new Value(Math[name](...args));
      }, [], realmRec);
      Assert(!(SetFunctionName(func, new Value(name)) instanceof AbruptCompletion), "");
      Assert(!(SetFunctionLength(func, new Value(length)) instanceof AbruptCompletion), "");
      mathObj.DefineOwnProperty(new Value(name), Descriptor({
        Value: func,
        Writable: Value.true,
        Enumerable: Value.false,
        Configurable: Value.true
      }));
    });
    realmRec.Intrinsics['%Math%'] = mathObj;
  }

  function thisTimeValue(value) {
    if (Type(value) === 'Object' && 'DateValue' in value) {
      return value.DateValue;
    }

    return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Date', value));
  } // 20.3.4.2 #sec-date.prototype.getdate

  function DateProto_getDate(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return DateFromTime(LocalTime(t));
  } // 20.3.4.3 #sec-date.prototype.getday


  function DateProto_getDay(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return WeekDay(LocalTime(t));
  } // 20.3.4.4 #sec-date.prototype.getfullyear


  function DateProto_getFullYear(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return YearFromTime(LocalTime(t));
  } // 20.3.4.5 #sec-date.prototype.gethours


  function DateProto_getHours(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return HourFromTime(LocalTime(t));
  } // 20.3.4.6 #sec-date.prototype.getmilliseconds


  function DateProto_getMilliseconds(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return msFromTime(LocalTime(t));
  } // 20.3.4.7 #sec-date.prototype.getminutes


  function DateProto_getMinutes(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return MinFromTime(LocalTime(t));
  } // 20.3.4.8 #sec-date.prototype.getmonth


  function DateProto_getMonth(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return MonthFromTime(LocalTime(t));
  } // 20.3.4.9 #sec-date.prototype.getseconds


  function DateProto_getSeconds(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return SecFromTime(LocalTime(t));
  } // 20.3.4.10 #sec-date.prototype.gettime


  function DateProto_getTime(args, {
    thisValue
  }) {
    return thisTimeValue(thisValue);
  } // 20.3.4.11 #sec-date.prototype.gettimezoneoffset


  function DateProto_getTimezoneOffset(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return new Value(t.numberValue() - LocalTime(t).numberValue() / msPerMinute);
  } // 20.3.4.12 #sec-date.prototype.getutcdate


  function DateProto_getUTCDate(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return DateFromTime(t);
  } // 20.3.4.13 #sec-date.prototype.getutcday


  function DateProto_getUTCDay(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return WeekDay(t);
  } // 20.3.4.14 #sec-date.prototype.getutcfullyear


  function DateProto_getUTCFullYear(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return YearFromTime(t);
  } // 20.3.4.15 #sec-date.prototype.getutchours


  function DateProto_getUTCHours(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return HourFromTime(t);
  } // 20.3.4.16 #sec-date.prototype.getutcmilliseconds


  function DateProto_getUTCMilliseconds(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return msFromTime(t);
  } // 20.3.4.17 #sec-date.prototype.getutcminutes


  function DateProto_getUTCMinutes(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return MinFromTime(t);
  } // 20.3.4.18 #sec-date.prototype.getutcmonth


  function DateProto_getUTCMonth(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return MonthFromTime(t);
  } // 20.3.4.19 #sec-date.prototype.getutcseconds


  function DateProto_getUTCSeconds(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      return new Value(NaN);
    }

    return SecFromTime(t);
  } // 20.3.4.20 #sec-date.prototype.setdate


  function DateProto_setDate([date = Value.undefined], {
    thisValue
  }) {
    let _hygienicTemp = thisTimeValue(thisValue);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const t = LocalTime(_hygienicTemp);
    let dt = ToNumber(date);

    if (dt instanceof AbruptCompletion) {
      return dt;
    }

    if (dt instanceof Completion) {
      dt = dt.Value;
    }

    const newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t));
    const u = TimeClip(UTC(newDate));
    thisValue.DateValue = u;
    return u;
  } // 20.3.4.21 #sec-date.prototype.setfullyear


  function DateProto_setFullYear([year = Value.undefined, month, date], {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    t = t.isNaN() ? new Value(0) : LocalTime(t);
    let y = ToNumber(year);

    if (y instanceof AbruptCompletion) {
      return y;
    }

    if (y instanceof Completion) {
      y = y.Value;
    }

    let m;

    if (month !== undefined) {
      m = ToNumber(month);

      if (m instanceof AbruptCompletion) {
        return m;
      }

      if (m instanceof Completion) {
        m = m.Value;
      }
    } else {
      m = MonthFromTime(t);
    }

    let dt;

    if (date !== undefined) {
      dt = ToNumber(date);

      if (dt instanceof AbruptCompletion) {
        return dt;
      }

      if (dt instanceof Completion) {
        dt = dt.Value;
      }
    } else {
      dt = DateFromTime(t);
    }

    const newDate = MakeDate(MakeDay(y, m, dt), TimeWithinDay(t));
    const u = TimeClip(UTC(newDate));
    thisValue.DateValue = u;
    return u;
  } // 20.3.4.22 #sec-date.prototype.sethours


  function DateProto_setHours([hour = Value.undefined, min, sec, ms], {
    thisValue
  }) {
    let _hygienicTemp2 = thisTimeValue(thisValue);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const t = LocalTime(_hygienicTemp2);
    let h = ToNumber(hour);

    if (h instanceof AbruptCompletion) {
      return h;
    }

    if (h instanceof Completion) {
      h = h.Value;
    }

    let m;

    if (min !== undefined) {
      m = ToNumber(min);

      if (m instanceof AbruptCompletion) {
        return m;
      }

      if (m instanceof Completion) {
        m = m.Value;
      }
    } else {
      m = MinFromTime(t);
    }

    let s;

    if (sec !== undefined) {
      s = ToNumber(sec);

      if (s instanceof AbruptCompletion) {
        return s;
      }

      if (s instanceof Completion) {
        s = s.Value;
      }
    } else {
      s = SecFromTime(t);
    }

    let milli;

    if (ms !== undefined) {
      milli = ToNumber(ms);

      if (milli instanceof AbruptCompletion) {
        return milli;
      }

      if (milli instanceof Completion) {
        milli = milli.Value;
      }
    } else {
      milli = msFromTime(t);
    }

    const date = MakeDate(Day(t), MakeTime(h, m, s, milli));
    const u = TimeClip(UTC(date));
    thisValue.DateValue = u;
    return u;
  } // 20.3.4.23 #sec-date.prototype.setmilliseconds


  function DateProto_setMilliseconds([ms = Value.undefined], {
    thisValue
  }) {
    let _hygienicTemp3 = thisTimeValue(thisValue);

    if (_hygienicTemp3 instanceof AbruptCompletion) {
      return _hygienicTemp3;
    }

    if (_hygienicTemp3 instanceof Completion) {
      _hygienicTemp3 = _hygienicTemp3.Value;
    }

    const t = LocalTime(_hygienicTemp3);
    ms = ToNumber(ms);

    if (ms instanceof AbruptCompletion) {
      return ms;
    }

    if (ms instanceof Completion) {
      ms = ms.Value;
    }

    const time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms);
    const u = TimeClip(UTC(MakeDate(Day(t), time)));
    thisValue.DateValue = u;
    return u;
  } // 20.3.4.24 #sec-date.prototype.setminutes


  function DateProto_setMinutes([min = Value.undefined, sec, ms], {
    thisValue
  }) {
    let _hygienicTemp4 = thisTimeValue(thisValue);

    if (_hygienicTemp4 instanceof AbruptCompletion) {
      return _hygienicTemp4;
    }

    if (_hygienicTemp4 instanceof Completion) {
      _hygienicTemp4 = _hygienicTemp4.Value;
    }

    const t = LocalTime(_hygienicTemp4);
    let m = ToNumber(min);

    if (m instanceof AbruptCompletion) {
      return m;
    }

    if (m instanceof Completion) {
      m = m.Value;
    }

    let s;

    if (sec !== undefined) {
      s = ToNumber(sec);

      if (s instanceof AbruptCompletion) {
        return s;
      }

      if (s instanceof Completion) {
        s = s.Value;
      }
    } else {
      s = SecFromTime(t);
    }

    let milli;

    if (ms !== undefined) {
      milli = ToNumber(ms);

      if (milli instanceof AbruptCompletion) {
        return milli;
      }

      if (milli instanceof Completion) {
        milli = milli.Value;
      }
    } else {
      milli = msFromTime(t);
    }

    const date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli));
    const u = TimeClip(UTC(date));
    thisValue.DateValue = u;
    return u;
  } // 20.3.4.25 #sec-date.prototype.setmonth


  function DateProto_setMonth([month = Value.undefined, date], {
    thisValue
  }) {
    let _hygienicTemp5 = thisTimeValue(thisValue);

    if (_hygienicTemp5 instanceof AbruptCompletion) {
      return _hygienicTemp5;
    }

    if (_hygienicTemp5 instanceof Completion) {
      _hygienicTemp5 = _hygienicTemp5.Value;
    }

    const t = LocalTime(_hygienicTemp5);
    let m = ToNumber(month);

    if (m instanceof AbruptCompletion) {
      return m;
    }

    if (m instanceof Completion) {
      m = m.Value;
    }

    let dt;

    if (date !== undefined) {
      dt = ToNumber(date);

      if (dt instanceof AbruptCompletion) {
        return dt;
      }

      if (dt instanceof Completion) {
        dt = dt.Value;
      }
    } else {
      dt = DateFromTime(t);
    }

    const newDate = MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t));
    const u = TimeClip(UTC(newDate));
    thisValue.DateValue = u;
    return u;
  } // 20.3.4.26 #sec-date.prototype.setseconds


  function DateProto_setSeconds([sec = Value.undefined, ms], {
    thisValue
  }) {
    let _hygienicTemp6 = thisTimeValue(thisValue);

    if (_hygienicTemp6 instanceof AbruptCompletion) {
      return _hygienicTemp6;
    }

    if (_hygienicTemp6 instanceof Completion) {
      _hygienicTemp6 = _hygienicTemp6.Value;
    }

    const t = LocalTime(_hygienicTemp6);
    let s = ToNumber(sec);

    if (s instanceof AbruptCompletion) {
      return s;
    }

    if (s instanceof Completion) {
      s = s.Value;
    }

    let milli;

    if (ms !== undefined) {
      milli = ToNumber(ms);

      if (milli instanceof AbruptCompletion) {
        return milli;
      }

      if (milli instanceof Completion) {
        milli = milli.Value;
      }
    } else {
      milli = msFromTime(t);
    }

    const date = MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli));
    const u = TimeClip(UTC(date));
    thisValue.DateValue = u;
    return u;
  } // 20.3.4.27 #sec-date.prototype.settime


  function DateProto_setTime([time = Value.undefined], {
    thisValue
  }) {
    {
      const hygienicTemp = thisTimeValue(thisValue);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    let t = ToNumber(time);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    const v = TimeClip(t);
    thisValue.DateValue = v;
    return v;
  } // 20.3.4.28 #sec-date.prototype.setutcdate


  function DateProto_setUTCDate([date = Value.undefined], {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    let dt = ToNumber(date);

    if (dt instanceof AbruptCompletion) {
      return dt;
    }

    if (dt instanceof Completion) {
      dt = dt.Value;
    }

    const newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t));
    const v = TimeClip(newDate);
    thisValue.DateValue = v;
    return v;
  } // 20.3.4.29 #sec-date.prototype.setutcfullyear


  function DateProto_setUTCFullYear([year = Value.undefined, month, date], {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (t.isNaN()) {
      t = new Value(0);
    }

    let y = ToNumber(year);

    if (y instanceof AbruptCompletion) {
      return y;
    }

    if (y instanceof Completion) {
      y = y.Value;
    }

    let m;

    if (month !== undefined) {
      m = ToNumber(month);

      if (m instanceof AbruptCompletion) {
        return m;
      }

      if (m instanceof Completion) {
        m = m.Value;
      }
    } else {
      m = MonthFromTime(t);
    }

    let dt;

    if (date !== undefined) {
      dt = ToNumber(date);

      if (dt instanceof AbruptCompletion) {
        return dt;
      }

      if (dt instanceof Completion) {
        dt = dt.Value;
      }
    } else {
      dt = DateFromTime(t);
    }

    const newDate = MakeDate(MakeDay(y, m, dt), TimeWithinDay(t));
    const v = TimeClip(newDate);
    thisValue.DateValue = v;
    return v;
  } // 20.3.4.30 #sec-date.prototype.setutchours


  function DateProto_setUTCHours([hour = Value.undefined, min, sec, ms], {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    let h = ToNumber(hour);

    if (h instanceof AbruptCompletion) {
      return h;
    }

    if (h instanceof Completion) {
      h = h.Value;
    }

    let m;

    if (min !== undefined) {
      m = ToNumber(min);

      if (m instanceof AbruptCompletion) {
        return m;
      }

      if (m instanceof Completion) {
        m = m.Value;
      }
    } else {
      m = MinFromTime(t);
    }

    let s;

    if (sec !== undefined) {
      s = ToNumber(sec);

      if (s instanceof AbruptCompletion) {
        return s;
      }

      if (s instanceof Completion) {
        s = s.Value;
      }
    } else {
      s = SecFromTime(t);
    }

    let milli;

    if (ms !== undefined) {
      milli = ToNumber(ms);

      if (milli instanceof AbruptCompletion) {
        return milli;
      }

      if (milli instanceof Completion) {
        milli = milli.Value;
      }
    } else {
      milli = msFromTime(t);
    }

    const newDate = MakeDate(Day(t), MakeTime(h, m, s, milli));
    const v = TimeClip(newDate);
    thisValue.DateValue = v;
    return v;
  } // 20.3.4.31 #sec-date.prototype.setutcmilliseconds


  function DateProto_setUTCMilliseconds([ms = Value.undefined], {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    let milli = ToNumber(ms);

    if (milli instanceof AbruptCompletion) {
      return milli;
    }

    if (milli instanceof Completion) {
      milli = milli.Value;
    }

    const time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli);
    const v = TimeClip(MakeDate(Day(t), time));
    thisValue.DateValue = v;
    return v;
  } // 20.3.4.32 #sec-date.prototype.setutcminutes


  function DateProto_setUTCMinutes([min = Value.undefined, sec, ms], {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    let m = ToNumber(min);

    if (m instanceof AbruptCompletion) {
      return m;
    }

    if (m instanceof Completion) {
      m = m.Value;
    }

    let s;

    if (sec !== undefined) {
      s = ToNumber(sec);

      if (s instanceof AbruptCompletion) {
        return s;
      }

      if (s instanceof Completion) {
        s = s.Value;
      }
    } else {
      s = SecFromTime(t);
    }

    let milli;

    if (ms !== undefined) {
      milli = ToNumber(ms);

      if (milli instanceof AbruptCompletion) {
        return milli;
      }

      if (milli instanceof Completion) {
        milli = milli.Value;
      }
    } else {
      milli = msFromTime(t);
    }

    const date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli));
    const v = TimeClip(date);
    thisValue.DateValue = v;
    return v;
  } // 20.3.4.33 #sec-date.prototype.setutcmonth


  function DateProto_setUTCMonth([month = Value.undefined, date], {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    let m = ToNumber(month);

    if (m instanceof AbruptCompletion) {
      return m;
    }

    if (m instanceof Completion) {
      m = m.Value;
    }

    let dt;

    if (date !== undefined) {
      dt = ToNumber(date);

      if (dt instanceof AbruptCompletion) {
        return dt;
      }

      if (dt instanceof Completion) {
        dt = dt.Value;
      }
    } else {
      dt = DateFromTime(t);
    }

    const newDate = MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t));
    const v = TimeClip(newDate);
    thisValue.DateValue = v;
    return v;
  } // 20.3.4.34 #sec-date.prototype.setutcseconds


  function DateProto_setUTCSeconds([sec = Value.undefined, ms], {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    let s = ToNumber(sec);

    if (s instanceof AbruptCompletion) {
      return s;
    }

    if (s instanceof Completion) {
      s = s.Value;
    }

    let milli;

    if (ms !== undefined) {
      milli = ToNumber(ms);

      if (milli instanceof AbruptCompletion) {
        return milli;
      }

      if (milli instanceof Completion) {
        milli = milli.Value;
      }
    } else {
      milli = msFromTime(t);
    }

    const date = MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli));
    const v = TimeClip(date);
    thisValue.DateValue = v;
    return v;
  } // 20.3.4.35 #sec-date.prototype.todatestring


  function DateProto_toDateString(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Date', O));
    }

    let tv = thisTimeValue(O);

    if (tv instanceof AbruptCompletion) {
      return tv;
    }

    if (tv instanceof Completion) {
      tv = tv.Value;
    }

    if (tv.isNaN()) {
      return new Value('Invalid Date');
    }

    const t = LocalTime(tv);
    return DateString(t);
  } // 20.3.4.36 #sec-date.prototype.toisostring


  function DateProto_toISOString(args, {
    thisValue
  }) {
    let t = thisTimeValue(thisValue);

    if (t instanceof AbruptCompletion) {
      return t;
    }

    if (t instanceof Completion) {
      t = t.Value;
    }

    if (!Number.isFinite(t.numberValue())) {
      return surroundingAgent.Throw('RangeError', 'Invalid time value');
    }

    const year = YearFromTime(t).numberValue();
    const month = MonthFromTime(t).numberValue() + 1;
    const date = DateFromTime(t).numberValue();
    const hour = HourFromTime(t).numberValue();
    const min = MinFromTime(t).numberValue();
    const sec = SecFromTime(t).numberValue();
    const ms = msFromTime(t).numberValue(); // TODO: figure out if there can be invalid years.

    let YYYY = String(year);

    if (year < 0 || year > 9999) {
      YYYY = year < 0 ? `-${String(year).padStart(6, '0')}` : `+${String(year).padStart(6, '0')}`;
    }

    const MM = String(month).padStart(2, '0');
    const DD = String(date).padStart(2, '0');
    const HH = String(hour).padStart(2, '0');
    const mm = String(min).padStart(2, '0');
    const ss = String(sec).padStart(2, '0');
    const sss = String(ms).padStart(3, '0');
    const format = `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}.${sss}Z`;
    return new Value(format);
  } // 20.3.4.37 #sec-date.prototype.tojson


  function DateProto_toJSON(args, {
    thisValue
  }) {
    let O = ToObject(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let tv = ToPrimitive(O, 'Number');

    if (tv instanceof AbruptCompletion) {
      return tv;
    }

    if (tv instanceof Completion) {
      tv = tv.Value;
    }

    if (Type(tv) === 'Number' && !Number.isFinite(tv.numberValue())) {
      return Value.null;
    }

    return Invoke(O, new Value('toISOString'));
  } // 20.3.4.38 #sec-date.prototype.tolocaledatestring


  function DateProto_toLocaleDateString() {
    // TODO: implement this function.
    return surroundingAgent.Throw('Error', 'Date.prototype.toLocaleDateString is not implemented');
  } // 20.3.4.39 #sec-date.prototype.tolocalestring


  function DateProto_toLocaleString() {
    // TODO: implement this function.
    return surroundingAgent.Throw('Error', 'Date.prototype.toLocaleString is not implemented');
  } // 20.3.4.40 #sec-date.prototype.tolocaletimestring


  function DateProto_toLocaleTimeString() {
    // TODO: implement this function.
    return surroundingAgent.Throw('Error', 'Date.prototype.toLocaleTimeString is not implemented');
  } // 20.3.4.41 #sec-date.prototype.tostring


  function DateProto_toString(args, {
    thisValue
  }) {
    let tv = thisTimeValue(thisValue);

    if (tv instanceof AbruptCompletion) {
      return tv;
    }

    if (tv instanceof Completion) {
      tv = tv.Value;
    }

    return ToDateString(tv);
  } // 20.3.4.41.1 #sec-timestring


  function TimeString(tv) {
    Assert(Type(tv) === 'Number', "Type(tv) === 'Number'");
    Assert(!tv.isNaN(), "!tv.isNaN()");
    const hour = String(HourFromTime(tv).numberValue()).padStart(2, '0');
    const minute = String(MinFromTime(tv).numberValue()).padStart(2, '0');
    const second = String(SecFromTime(tv).numberValue()).padStart(2, '0');
    return new Value(`${hour}:${minute}:${second} GMT`);
  } // 20.3.4.41.2 #sec-datestring


  function DateString(tv) {
    Assert(Type(tv) === 'Number', "Type(tv) === 'Number'");
    Assert(!tv.isNaN(), "!tv.isNaN()");
    const weekday = daysOfTheWeek[WeekDay(tv).numberValue()];
    const month = monthsOfTheYear[MonthFromTime(tv).numberValue()];
    const day = String(DateFromTime(tv).numberValue()).padStart(2, '0');
    const yv = YearFromTime(tv).numberValue();
    const yearSign = yv >= 0 ? '' : '-';
    const year = new Value(String(Math.abs(yv)));

    let _val = StringPad(year, new Value(4), new Value('0'), 'start');

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    const paddedYear = _val.stringValue();

    return new Value(`${weekday} ${month} ${day} ${yearSign}${paddedYear}`);
  } // Table 46 #sec-todatestring-day-names


  const daysOfTheWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']; // Table 47 #sec-todatestring-month-names

  const monthsOfTheYear = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 20.3.4.41.3 #sec-timezoneestring

  function TimeZoneString(tv) {
    Assert(Type(tv) === 'Number', "Type(tv) === 'Number'");
    Assert(!tv.isNaN(), "!tv.isNaN()");
    const offset = LocalTZA();
    const offsetSign =  '+' ;
    const offsetMin = String(MinFromTime(new Value(Math.abs(offset))).numberValue()).padStart(2, '0');
    const offsetHour = String(HourFromTime(new Value(Math.abs(offset))).numberValue()).padStart(2, '0');
    const tzName = '';
    return new Value(`${offsetSign}${offsetHour}${offsetMin}${tzName}`);
  } // 20.3.4.41.4 #sec-todatestring

  function ToDateString(tv) {
    Assert(Type(tv) === 'Number', "Type(tv) === 'Number'");

    if (tv.isNaN()) {
      return new Value('Invalid Date');
    }

    const t = LocalTime(tv);
    return new Value(`${DateString(t).stringValue()} ${TimeString(t).stringValue()}${TimeZoneString(t).stringValue()}`);
  } // 20.3.4.42 #sec-date.prototype.totimestring

  function DateProto_toTimeString(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Date', O));
    }

    let tv = thisTimeValue(O);

    if (tv instanceof AbruptCompletion) {
      return tv;
    }

    if (tv instanceof Completion) {
      tv = tv.Value;
    }

    if (tv.isNaN()) {
      return new Value('Invalid Date');
    }

    const t = LocalTime(tv);
    return new Value(`${TimeString(t).stringValue()}${TimeZoneString(tv).stringValue()}`);
  } // 20.3.4.43 #sec-date.prototype.toutcstring


  function DateProto_toUTCString(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Date', O));
    }

    let tv = thisTimeValue(O);

    if (tv instanceof AbruptCompletion) {
      return tv;
    }

    if (tv instanceof Completion) {
      tv = tv.Value;
    }

    if (tv.isNaN()) {
      return new Value('Invalid Date');
    }

    const weekday = daysOfTheWeek[WeekDay(tv).numberValue()];
    const month = monthsOfTheYear[MonthFromTime(tv).numberValue()];
    const day = String(DateFromTime(tv).numberValue()).padStart(2, '0');
    const yv = YearFromTime(tv).numberValue();
    const yearSign = yv >= 0 ? '' : '-';
    const year = new Value(String(Math.abs(yv)));

    let _val2 = StringPad(year, new Value(4), new Value('0'), 'start');

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    const paddedYear = _val2.stringValue();

    return new Value(`${weekday}, ${day} ${month} ${yearSign}${paddedYear} ${TimeString(tv).stringValue()}`);
  } // 20.3.4.44 #sec-date.prototype.valueof


  function DateProto_valueOf(args, {
    thisValue
  }) {
    return thisTimeValue(thisValue);
  } // 20.3.4.45 #sec-date.prototype-@@toprimitive


  function DateProto_toPrimitive([hint = Value.undefined], {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Date', O));
    }

    let tryFirst;

    if (Type(hint) === 'String' && (hint.stringValue() === 'string' || hint.stringValue() === 'default')) {
      tryFirst = new Value('string');
    } else if (Type(hint) === 'String' && hint.stringValue() === 'number') {
      tryFirst = new Value('number');
    } else {
      return surroundingAgent.Throw('TypeError', msg('InvalidHint', hint));
    }

    return OrdinaryToPrimitive(O, tryFirst);
  }

  function CreateDatePrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['getDate', DateProto_getDate, 0], ['getDay', DateProto_getDay, 0], ['getFullYear', DateProto_getFullYear, 0], ['getHours', DateProto_getHours, 0], ['getMilliseconds', DateProto_getMilliseconds, 0], ['getMinutes', DateProto_getMinutes, 0], ['getMonth', DateProto_getMonth, 0], ['getSeconds', DateProto_getSeconds, 0], ['getTime', DateProto_getTime, 0], ['getTimezoneOffset', DateProto_getTimezoneOffset, 0], ['getUTCDate', DateProto_getUTCDate, 0], ['getUTCDay', DateProto_getUTCDay, 0], ['getUTCFullYear', DateProto_getUTCFullYear, 0], ['getUTCHours', DateProto_getUTCHours, 0], ['getUTCMilliseconds', DateProto_getUTCMilliseconds, 0], ['getUTCMinutes', DateProto_getUTCMinutes, 0], ['getUTCMonth', DateProto_getUTCMonth, 0], ['getUTCSeconds', DateProto_getUTCSeconds, 0], ['setDate', DateProto_setDate, 1], ['setFullYear', DateProto_setFullYear, 3], ['setHours', DateProto_setHours, 4], ['setMilliseconds', DateProto_setMilliseconds, 1], ['setMinutes', DateProto_setMinutes, 3], ['setMonth', DateProto_setMonth, 2], ['setSeconds', DateProto_setSeconds, 2], ['setTime', DateProto_setTime, 1], ['setUTCDate', DateProto_setUTCDate, 1], ['setUTCFullYear', DateProto_setUTCFullYear, 3], ['setUTCHours', DateProto_setUTCHours, 4], ['setUTCMilliseconds', DateProto_setUTCMilliseconds, 1], ['setUTCMinutes', DateProto_setUTCMinutes, 3], ['setUTCMonth', DateProto_setUTCMonth, 2], ['setUTCSeconds', DateProto_setUTCSeconds, 2], ['toDateString', DateProto_toDateString, 0], ['toISOString', DateProto_toISOString, 0], ['toJSON', DateProto_toJSON, 1], ['toLocaleDateString', DateProto_toLocaleDateString, 0], ['toLocaleString', DateProto_toLocaleString, 0], ['toLocaleTimeString', DateProto_toLocaleTimeString, 0], ['toString', DateProto_toString, 0], ['toTimeString', DateProto_toTimeString, 0], ['toUTCString', DateProto_toUTCString, 0], ['valueOf', DateProto_valueOf, 0], [wellKnownSymbols.toPrimitive, DateProto_toPrimitive, 1, {
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }]], realmRec.Intrinsics['%ObjectPrototype%']);
    realmRec.Intrinsics['%DatePrototype%'] = proto;
  }

  function DateConstructor(args, {
    NewTarget
  }) {
    const numberOfArgs = args.length;

    if (numberOfArgs >= 2) {
      // 20.3.2.1 #sec-date-year-month-date-hours-minutes-seconds-ms
      const [year, month, date, hours, minutes, seconds, ms] = args;
      Assert(numberOfArgs >= 2, "numberOfArgs >= 2");

      if (NewTarget === Value.undefined) {
        const now = Date.now();
        return ToDateString(new Value(now));
      } else {
        let y = ToNumber(year);

        if (y instanceof AbruptCompletion) {
          return y;
        }

        if (y instanceof Completion) {
          y = y.Value;
        }

        let m = ToNumber(month);

        if (m instanceof AbruptCompletion) {
          return m;
        }

        if (m instanceof Completion) {
          m = m.Value;
        }

        let dt;

        if (date !== undefined) {
          dt = ToNumber(date);

          if (dt instanceof AbruptCompletion) {
            return dt;
          }

          if (dt instanceof Completion) {
            dt = dt.Value;
          }
        } else {
          dt = new Value(1);
        }

        let h;

        if (hours !== undefined) {
          h = ToNumber(hours);

          if (h instanceof AbruptCompletion) {
            return h;
          }

          if (h instanceof Completion) {
            h = h.Value;
          }
        } else {
          h = new Value(0);
        }

        let min;

        if (minutes !== undefined) {
          min = ToNumber(minutes);

          if (min instanceof AbruptCompletion) {
            return min;
          }

          if (min instanceof Completion) {
            min = min.Value;
          }
        } else {
          min = new Value(0);
        }

        let s;

        if (seconds !== undefined) {
          s = ToNumber(seconds);

          if (s instanceof AbruptCompletion) {
            return s;
          }

          if (s instanceof Completion) {
            s = s.Value;
          }
        } else {
          s = new Value(0);
        }

        let milli;

        if (ms !== undefined) {
          milli = ToNumber(ms);

          if (milli instanceof AbruptCompletion) {
            return milli;
          }

          if (milli instanceof Completion) {
            milli = milli.Value;
          }
        } else {
          milli = new Value(0);
        }

        let yr;

        if (y.isNaN()) {
          yr = new Value(NaN);
        } else {
          let _val = ToInteger(y);

          Assert(!(_val instanceof AbruptCompletion), "");

          if (_val instanceof Completion) {
            _val = _val.Value;
          }

          const yi = _val.numberValue();

          if (yi >= 0 && yi <= 99) {
            yr = new Value(1900 + yi);
          } else {
            yr = y;
          }
        }

        const finalDate = MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli));
        let O = OrdinaryCreateFromConstructor(NewTarget, '%DatePrototype%', ['DateValue']);

        if (O instanceof AbruptCompletion) {
          return O;
        }

        if (O instanceof Completion) {
          O = O.Value;
        }

        O.DateValue = TimeClip(UTC(finalDate));
        return O;
      }
    } else if (numberOfArgs === 1) {
      const [value] = args; // 20.3.2.2 #sec-date-value

      Assert(numberOfArgs === 1, "numberOfArgs === 1");

      if (NewTarget === Value.undefined) {
        const now = Date.now();
        return ToDateString(new Value(now));
      } else {
        let tv;

        if (Type(value) === 'Object' && 'DateValue' in value) {
          tv = thisTimeValue(value);
        } else {
          let v = ToPrimitive(value);

          if (v instanceof AbruptCompletion) {
            return v;
          }

          if (v instanceof Completion) {
            v = v.Value;
          }

          if (Type(v) === 'String') {
            // Assert: The next step never returns an abrupt completion because Type(v) is String.
            tv = parseDate(v);
          } else {
            tv = ToNumber(v);

            if (tv instanceof AbruptCompletion) {
              return tv;
            }

            if (tv instanceof Completion) {
              tv = tv.Value;
            }
          }
        }

        let O = OrdinaryCreateFromConstructor(NewTarget, '%DatePrototype%', ['DateValue']);

        if (O instanceof AbruptCompletion) {
          return O;
        }

        if (O instanceof Completion) {
          O = O.Value;
        }

        O.DateValue = TimeClip(tv);
        return O;
      }
    } else {
      // 20.3.2.3 #sec-date-constructor-date
      Assert(numberOfArgs === 0, "numberOfArgs === 0");

      if (NewTarget === Value.undefined) {
        const now = Date.now();
        return ToDateString(new Value(now));
      } else {
        let O = OrdinaryCreateFromConstructor(NewTarget, '%DatePrototype%', ['DateValue']);

        if (O instanceof AbruptCompletion) {
          return O;
        }

        if (O instanceof Completion) {
          O = O.Value;
        }

        O.DateValue = new Value(Date.now());
        return O;
      }
    }
  } // 20.3.3.1 #sec-date.now


  function Date_now() {
    const now = Date.now();
    return new Value(now);
  } // 20.3.3.2 #sec-date.parse


  function Date_parse([string = Value.undefined]) {
    const str = ToString(string);

    if (str instanceof AbruptCompletion) {
      return str;
    }

    return parseDate(str);
  } // 20.3.3.4 #sec-date.utc


  function Date_UTC([year = Value.undefined, month, date, hours, minutes, seconds, ms]) {
    let y = ToNumber(year);

    if (y instanceof AbruptCompletion) {
      return y;
    }

    if (y instanceof Completion) {
      y = y.Value;
    }

    let m;

    if (month !== undefined) {
      m = ToNumber(month);

      if (m instanceof AbruptCompletion) {
        return m;
      }

      if (m instanceof Completion) {
        m = m.Value;
      }
    } else {
      m = new Value(0);
    }

    let dt;

    if (date !== undefined) {
      dt = ToNumber(date);

      if (dt instanceof AbruptCompletion) {
        return dt;
      }

      if (dt instanceof Completion) {
        dt = dt.Value;
      }
    } else {
      dt = new Value(1);
    }

    let h;

    if (hours !== undefined) {
      h = ToNumber(hours);

      if (h instanceof AbruptCompletion) {
        return h;
      }

      if (h instanceof Completion) {
        h = h.Value;
      }
    } else {
      h = new Value(0);
    }

    let min;

    if (minutes !== undefined) {
      min = ToNumber(minutes);

      if (min instanceof AbruptCompletion) {
        return min;
      }

      if (min instanceof Completion) {
        min = min.Value;
      }
    } else {
      min = new Value(0);
    }

    let s;

    if (seconds !== undefined) {
      s = ToNumber(seconds);

      if (s instanceof AbruptCompletion) {
        return s;
      }

      if (s instanceof Completion) {
        s = s.Value;
      }
    } else {
      s = new Value(0);
    }

    let milli;

    if (ms !== undefined) {
      milli = ToNumber(ms);

      if (milli instanceof AbruptCompletion) {
        return milli;
      }

      if (milli instanceof Completion) {
        milli = milli.Value;
      }
    } else {
      milli = new Value(0);
    }

    let yr;

    if (y.isNaN()) {
      yr = new Value(NaN);
    } else {
      let _val2 = ToInteger(y);

      Assert(!(_val2 instanceof AbruptCompletion), "");

      if (_val2 instanceof Completion) {
        _val2 = _val2.Value;
      }

      const yi = _val2.numberValue();

      if (yi >= 0 && yi <= 99) {
        yr = new Value(1900 + yi);
      } else {
        yr = y;
      }
    }

    return TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)));
  }

  function parseDate(dateTimeString) {
    // 20.3.1.15 #sec-date-time-string-format
    // TODO: implement parsing without the host.
    const parsed = Date.parse(dateTimeString.stringValue());
    return new Value(parsed);
  }

  function CreateDate(realmRec) {
    const cons = BootstrapConstructor(realmRec, DateConstructor, 'Date', 7, realmRec.Intrinsics['%DatePrototype%'], [['now', Date_now, 0], ['parse', Date_parse, 1], ['UTC', Date_UTC, 7]]);
    realmRec.Intrinsics['%Date%'] = cons;
  }

  function CreateRegExpStringIterator(R, S, global, fullUnicode) {
    Assert(Type(S) === 'String', "Type(S) === 'String'");
    Assert(Type(global) === 'Boolean', "Type(global) === 'Boolean'");
    Assert(Type(fullUnicode) === 'Boolean', "Type(fullUnicode) === 'Boolean'");
    const iterator = ObjectCreate(surroundingAgent.intrinsic('%RegExpStringIteratorPrototype%'), ['IteratingRegExp', 'IteratedString', 'Global', 'Unicode', 'Done']);
    iterator.IteratingRegExp = R;
    iterator.IteratedString = S;
    iterator.Global = global;
    iterator.Unicode = fullUnicode;
    iterator.Done = Value.false;
    return iterator;
  } // 21.2.7.1.1 #sec-%regexpstringiteratorprototype%.next

  function RegExpStringIteratorPrototype_next(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp String Iterator', O));
    }

    if (!('IteratingRegExp' in O && 'IteratedString' in O && 'Global' in O && 'Unicode' in O && 'Done' in O)) {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp String Iterator', O));
    }

    if (O.Done === Value.true) {
      let _val = CreateIterResultObject(Value.undefined, Value.true);

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      return _val;
    }

    const R = O.IteratingRegExp;
    const S = O.IteratedString;
    const global = O.Global;
    const fullUnicode = O.Unicode;
    let match = RegExpExec(R, S);

    if (match instanceof AbruptCompletion) {
      return match;
    }

    if (match instanceof Completion) {
      match = match.Value;
    }

    if (match === Value.null) {
      O.Done = Value.true;

      let _val2 = CreateIterResultObject(Value.undefined, Value.true);

      Assert(!(_val2 instanceof AbruptCompletion), "");

      if (_val2 instanceof Completion) {
        _val2 = _val2.Value;
      }

      return _val2;
    } else {
      if (global === Value.true) {
        let matchStrValue = Get(match, new Value('0'));

        if (matchStrValue instanceof AbruptCompletion) {
          return matchStrValue;
        }

        if (matchStrValue instanceof Completion) {
          matchStrValue = matchStrValue.Value;
        }

        let matchStr = ToString(matchStrValue);

        if (matchStr instanceof AbruptCompletion) {
          return matchStr;
        }

        if (matchStr instanceof Completion) {
          matchStr = matchStr.Value;
        }

        if (matchStr.stringValue() === '') {
          let thisIndexValue = Get(R, new Value('lastIndex'));

          if (thisIndexValue instanceof AbruptCompletion) {
            return thisIndexValue;
          }

          if (thisIndexValue instanceof Completion) {
            thisIndexValue = thisIndexValue.Value;
          }

          let thisIndex = ToLength(thisIndexValue);

          if (thisIndex instanceof AbruptCompletion) {
            return thisIndex;
          }

          if (thisIndex instanceof Completion) {
            thisIndex = thisIndex.Value;
          }

          let nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
          Assert(!(nextIndex instanceof AbruptCompletion), "");

          if (nextIndex instanceof Completion) {
            nextIndex = nextIndex.Value;
          }

          {
            const hygienicTemp = Set$1(R, new Value('lastIndex'), nextIndex, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        return CreateIterResultObject(match, Value.false);
      } else {
        O.Done = Value.true;
        return CreateIterResultObject(match, Value.false);
      }
    }
  }

  function CreateRegExpStringIteratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['next', RegExpStringIteratorPrototype_next, 0], [wellKnownSymbols.toStringTag, new Value('RegExp String Iterator'), undefined, {
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }]], realmRec.Intrinsics['%IteratorPrototype%']);
    realmRec.Intrinsics['%RegExpStringIteratorPrototype%'] = proto;
  }

  function RegExpProto_exec([string = Value.undefined], {
    thisValue
  }) {
    const R = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(R, 'RegExpMatcher');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    let S = ToString(string);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    return RegExpBuiltinExec(R, S);
  } // 21.2.5.2.1 #sec-regexpexec


  function RegExpExec(R, S) {
    Assert(Type(R) === 'Object', "Type(R) === 'Object'");
    Assert(Type(S) === 'String', "Type(S) === 'String'");
    let exec = Get(R, new Value('exec'));

    if (exec instanceof AbruptCompletion) {
      return exec;
    }

    if (exec instanceof Completion) {
      exec = exec.Value;
    }

    if (IsCallable(exec) === Value.true) {
      let result = Call(exec, R, [S]);

      if (result instanceof AbruptCompletion) {
        return result;
      }

      if (result instanceof Completion) {
        result = result.Value;
      }

      if (Type(result) !== 'Object' && Type(result) !== 'Null') {
        // TODO: throw with an error message
        return surroundingAgent.Throw('TypeError');
      }

      return result;
    }

    {
      const hygienicTemp = RequireInternalSlot(R, 'RegExpMatcher');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return RegExpBuiltinExec(R, S);
  } // 21.2.5.2.2 #sec-regexpbuiltinexec

  function RegExpBuiltinExec(R, S) {
    Assert('RegExpMatcher' in R, "'RegExpMatcher' in R");
    Assert(Type(S) === 'String', "Type(S) === 'String'");
    const length = S.stringValue().length;
    const lastIndexStr = new Value('lastIndex');
    let lastIndexValue = Get(R, lastIndexStr);

    if (lastIndexValue instanceof AbruptCompletion) {
      return lastIndexValue;
    }

    if (lastIndexValue instanceof Completion) {
      lastIndexValue = lastIndexValue.Value;
    }

    let lastIndex = ToLength(lastIndexValue);

    if (lastIndex instanceof AbruptCompletion) {
      return lastIndex;
    }

    if (lastIndex instanceof Completion) {
      lastIndex = lastIndex.Value;
    }

    const flags = R.OriginalFlags.stringValue();
    const global = flags.includes('g');
    const sticky = flags.includes('y');

    if (!global && !sticky) {
      lastIndex = new Value(0);
    }

    const matcher = R.RegExpMatcher;
    const fullUnicode = flags.includes('u');
    let matchSucceeded = false;
    let r;

    while (matchSucceeded === false) {
      if (lastIndex.numberValue() > length) {
        if (global || sticky) {
          {
            const hygienicTemp = Set$1(R, lastIndexStr, new Value(0), Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        return Value.null;
      }

      r = matcher(S, lastIndex);

      if (r === null) {
        if (sticky) {
          {
            const hygienicTemp = Set$1(R, lastIndexStr, new Value(0), Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          return Value.null;
        }

        lastIndex = AdvanceStringIndex(S, lastIndex, fullUnicode ? Value.true : Value.false);
      } else {
        // Assert: r is a state
        matchSucceeded = true;
      }
    }

    const e = r.endIndex;

    if (global || sticky) {
      {
        const hygienicTemp = Set$1(R, lastIndexStr, e, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    const n = r.captures.length;
    Assert(n < 2 ** 32 - 1, "n < (2 ** 32) - 1");
    let A = ArrayCreate(new Value(n + 1));
    Assert(!(A instanceof AbruptCompletion), "");

    if (A instanceof Completion) {
      A = A.Value;
    }

    // Assert: The value of A's "length" property is n + 1.
    Assert(!(CreateDataProperty(A, new Value('index'), lastIndex) instanceof AbruptCompletion), "");
    Assert(!(CreateDataProperty(A, new Value('input'), S) instanceof AbruptCompletion), "");
    const matchedSubstr = S.stringValue().substring(lastIndex.numberValue(), e.numberValue());
    Assert(!(CreateDataProperty(A, new Value('0'), new Value(matchedSubstr)) instanceof AbruptCompletion), "");
    let groups;

    if (R.GroupName) ; else {
      groups = Value.undefined;
    }

    Assert(!(CreateDataProperty(A, new Value('groups'), groups) instanceof AbruptCompletion), "");

    for (let i = 1; i <= n; i += 1) {
      const captureI = r.captures[i - 1];
      let captureValue;

      if (captureI === Value.undefined) {
        captureValue = Value.undefined;
      } else if (fullUnicode) {
        // Assert: captureI is a List of code points.
        captureValue = new Value(captureI.reduce((acc, codePoint) => acc + String.fromCodePoint(codePoint), ''));
      } else {
        // Assert: captureI is a List of code units.
        captureValue = new Value(captureI.reduce((acc, charCode) => acc + String.fromCharCode(charCode), ''));
      }

      let _val = ToString(new Value(i));

      Assert(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      Assert(!(CreateDataProperty(A, _val, captureValue) instanceof AbruptCompletion), ""); // TODO
    }

    return A;
  } // 21.2.5.2.3 #sec-advancestringindex


  function AdvanceStringIndex(S, index, unicode) {
    Assert(Type(S) === 'String', "Type(S) === 'String'");
    index = index.numberValue();
    Assert(Number.isInteger(index) && index >= 0 && index <= 2 ** 53 - 1, "Number.isInteger(index) && index >= 0 && index <= (2 ** 53) - 1");
    Assert(Type(unicode) === 'Boolean', "Type(unicode) === 'Boolean'");

    if (unicode === Value.false) {
      return new Value(index + 1);
    }

    const length = S.stringValue().length;

    if (index + 1 >= length) {
      return new Value(index + 1);
    }

    let cp = CodePointAt(S, index);
    Assert(!(cp instanceof AbruptCompletion), "");

    if (cp instanceof Completion) {
      cp = cp.Value;
    }

    return new Value(index + cp.CodeUnitCount.numberValue());
  } // 21.2.5.3 #sec-get-regexp.prototype.dotAll

  function RegExpProto_dotAllGetter(args, {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    if (!('OriginalFlags' in R)) {
      if (SameValue(R, surroundingAgent.intrinsic('%RegExpPrototype%')) === Value.true) {
        return Value.undefined;
      }

      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    const flags = R.OriginalFlags;

    if (flags.stringValue().includes('s')) {
      return Value.true;
    }

    return Value.false;
  } // 21.2.5.4 #sec-get-regexp.prototype.flags


  function RegExpProto_flagsGetter(args, {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    let result = '';

    let _hygienicTemp = Get(R, new Value('global'));

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const global = ToBoolean(_hygienicTemp);

    if (global === Value.true) {
      result += 'g';
    }

    let _hygienicTemp2 = Get(R, new Value('ignoreCase'));

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const ignoreCase = ToBoolean(_hygienicTemp2);

    if (ignoreCase === Value.true) {
      result += 'i';
    }

    let _hygienicTemp3 = Get(R, new Value('multiline'));

    if (_hygienicTemp3 instanceof AbruptCompletion) {
      return _hygienicTemp3;
    }

    if (_hygienicTemp3 instanceof Completion) {
      _hygienicTemp3 = _hygienicTemp3.Value;
    }

    const multiline = ToBoolean(_hygienicTemp3);

    if (multiline === Value.true) {
      result += 'm';
    }

    let _hygienicTemp4 = Get(R, new Value('dotAll'));

    if (_hygienicTemp4 instanceof AbruptCompletion) {
      return _hygienicTemp4;
    }

    if (_hygienicTemp4 instanceof Completion) {
      _hygienicTemp4 = _hygienicTemp4.Value;
    }

    const dotAll = ToBoolean(_hygienicTemp4);

    if (dotAll === Value.true) {
      result += 's';
    }

    let _hygienicTemp5 = Get(R, new Value('unicode'));

    if (_hygienicTemp5 instanceof AbruptCompletion) {
      return _hygienicTemp5;
    }

    if (_hygienicTemp5 instanceof Completion) {
      _hygienicTemp5 = _hygienicTemp5.Value;
    }

    const unicode = ToBoolean(_hygienicTemp5);

    if (unicode === Value.true) {
      result += 'u';
    }

    let _hygienicTemp6 = Get(R, new Value('sticky'));

    if (_hygienicTemp6 instanceof AbruptCompletion) {
      return _hygienicTemp6;
    }

    if (_hygienicTemp6 instanceof Completion) {
      _hygienicTemp6 = _hygienicTemp6.Value;
    }

    const sticky = ToBoolean(_hygienicTemp6);

    if (sticky === Value.true) {
      result += 'y';
    }

    return new Value(result);
  } // 21.2.5.5 #sec-get-regexp.prototype.global


  function RegExpProto_globalGetter(args, {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    if (!('OriginalFlags' in R)) {
      if (SameValue(R, surroundingAgent.intrinsic('%RegExpPrototype%')) === Value.true) {
        return Value.undefined;
      }

      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    const flags = R.OriginalFlags;

    if (flags.stringValue().includes('g')) {
      return Value.true;
    }

    return Value.false;
  } // 21.2.5.6 #sec-get-regexp.prototype.ignorecase


  function RegExpProto_ignoreCaseGetter(args, {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    if (!('OriginalFlags' in R)) {
      if (SameValue(R, surroundingAgent.intrinsic('%RegExpPrototype%')) === Value.true) {
        return Value.undefined;
      }

      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    const flags = R.OriginalFlags;

    if (flags.stringValue().includes('i')) {
      return Value.true;
    }

    return Value.false;
  } // 21.2.5.7 #sec-regexp.prototype-@@match


  function RegExpProto_match([string = Value.undefined], {
    thisValue
  }) {
    const rx = thisValue;

    if (Type(rx) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', rx));
    }

    let S = ToString(string);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let _hygienicTemp7 = Get(rx, new Value('global'));

    if (_hygienicTemp7 instanceof AbruptCompletion) {
      return _hygienicTemp7;
    }

    if (_hygienicTemp7 instanceof Completion) {
      _hygienicTemp7 = _hygienicTemp7.Value;
    }

    const global = ToBoolean(_hygienicTemp7);

    if (global === Value.false) {
      return RegExpExec(rx, S);
    } else {
      let _hygienicTemp8 = Get(rx, new Value('unicode'));

      if (_hygienicTemp8 instanceof AbruptCompletion) {
        return _hygienicTemp8;
      }

      if (_hygienicTemp8 instanceof Completion) {
        _hygienicTemp8 = _hygienicTemp8.Value;
      }

      const fullUnicode = ToBoolean(_hygienicTemp8);
      {
        const hygienicTemp = Set$1(rx, new Value('lastIndex'), new Value(0), Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let A = ArrayCreate(new Value(0));
      Assert(!(A instanceof AbruptCompletion), "");

      if (A instanceof Completion) {
        A = A.Value;
      }

      let n = 0;

      while (true) {
        let result = RegExpExec(rx, S);

        if (result instanceof AbruptCompletion) {
          return result;
        }

        if (result instanceof Completion) {
          result = result.Value;
        }

        if (result === Value.null) {
          if (n === 0) {
            return Value.null;
          }

          return A;
        } else {
          let firstResult = Get(result, new Value('0'));

          if (firstResult instanceof AbruptCompletion) {
            return firstResult;
          }

          if (firstResult instanceof Completion) {
            firstResult = firstResult.Value;
          }

          let matchStr = ToString(firstResult);

          if (matchStr instanceof AbruptCompletion) {
            return matchStr;
          }

          if (matchStr instanceof Completion) {
            matchStr = matchStr.Value;
          }

          let _val2 = ToString(new Value(n));

          Assert(!(_val2 instanceof AbruptCompletion), "");

          if (_val2 instanceof Completion) {
            _val2 = _val2.Value;
          }

          const status = CreateDataProperty(A, _val2, matchStr);
          Assert(status === Value.true, "status === Value.true");

          if (matchStr.stringValue() === '') {
            let lastIndex = Get(rx, new Value('lastIndex'));

            if (lastIndex instanceof AbruptCompletion) {
              return lastIndex;
            }

            if (lastIndex instanceof Completion) {
              lastIndex = lastIndex.Value;
            }

            let thisIndex = ToLength(lastIndex);

            if (thisIndex instanceof AbruptCompletion) {
              return thisIndex;
            }

            if (thisIndex instanceof Completion) {
              thisIndex = thisIndex.Value;
            }

            const nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
            {
              const hygienicTemp = Set$1(rx, new Value('lastIndex'), nextIndex, Value.true);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          }

          n += 1;
        }
      }
    }
  } // 21.2.5.8 #sec-regexp-prototype-matchall


  function RegExpProto_matchAll([string = Value.undefined], {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    let S = ToString(string);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let C = SpeciesConstructor(R, surroundingAgent.intrinsic('%RegExp%'));

    if (C instanceof AbruptCompletion) {
      return C;
    }

    if (C instanceof Completion) {
      C = C.Value;
    }

    let flagsValue = Get(R, new Value('flags'));

    if (flagsValue instanceof AbruptCompletion) {
      return flagsValue;
    }

    if (flagsValue instanceof Completion) {
      flagsValue = flagsValue.Value;
    }

    let flags = ToString(flagsValue);

    if (flags instanceof AbruptCompletion) {
      return flags;
    }

    if (flags instanceof Completion) {
      flags = flags.Value;
    }

    let matcher = Construct(C, [R, flags]);

    if (matcher instanceof AbruptCompletion) {
      return matcher;
    }

    if (matcher instanceof Completion) {
      matcher = matcher.Value;
    }

    let lastIndexValue = Get(R, new Value('lastIndex'));

    if (lastIndexValue instanceof AbruptCompletion) {
      return lastIndexValue;
    }

    if (lastIndexValue instanceof Completion) {
      lastIndexValue = lastIndexValue.Value;
    }

    let lastIndex = ToLength(lastIndexValue);

    if (lastIndex instanceof AbruptCompletion) {
      return lastIndex;
    }

    if (lastIndex instanceof Completion) {
      lastIndex = lastIndex.Value;
    }

    {
      const hygienicTemp = Set$1(matcher, new Value('lastIndex'), lastIndex, Value.true);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    let global;

    if (flags.stringValue().includes('g')) {
      global = Value.true;
    } else {
      global = Value.false;
    }

    let fullUnicode;

    if (flags.stringValue().includes('u')) {
      fullUnicode = Value.true;
    } else {
      fullUnicode = Value.false;
    }

    let _val3 = CreateRegExpStringIterator(matcher, S, global, fullUnicode);

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    return _val3;
  } // 21.2.5.9 #sec-get-regexp.prototype.multiline


  function RegExpProto_multilineGetter(args, {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    if (!('OriginalFlags' in R)) {
      if (SameValue(R, surroundingAgent.intrinsic('%RegExpPrototype%')) === Value.true) {
        return Value.undefined;
      }

      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    const flags = R.OriginalFlags;

    if (flags.stringValue().includes('m')) {
      return Value.true;
    }

    return Value.false;
  } // 21.2.5.10 #sec-regexp.prototype-@@replace


  function RegExpProto_replace([string = Value.undefined, replaceValue = Value.undefined], {
    thisValue
  }) {
    const rx = thisValue;

    if (Type(rx) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', rx));
    }

    let S = ToString(string);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    const lengthS = S.stringValue().length;
    const functionalReplace = IsCallable(replaceValue);

    if (functionalReplace === Value.false) {
      replaceValue = ToString(replaceValue);

      if (replaceValue instanceof AbruptCompletion) {
        return replaceValue;
      }

      if (replaceValue instanceof Completion) {
        replaceValue = replaceValue.Value;
      }
    }

    let _hygienicTemp9 = Get(rx, new Value('global'));

    if (_hygienicTemp9 instanceof AbruptCompletion) {
      return _hygienicTemp9;
    }

    if (_hygienicTemp9 instanceof Completion) {
      _hygienicTemp9 = _hygienicTemp9.Value;
    }

    const global = ToBoolean(_hygienicTemp9);
    let fullUnicode;

    if (global === Value.true) {
      let _hygienicTemp10 = Get(rx, new Value('unicode'));

      if (_hygienicTemp10 instanceof AbruptCompletion) {
        return _hygienicTemp10;
      }

      if (_hygienicTemp10 instanceof Completion) {
        _hygienicTemp10 = _hygienicTemp10.Value;
      }

      fullUnicode = ToBoolean(_hygienicTemp10);
      {
        const hygienicTemp = Set$1(rx, new Value('lastIndex'), new Value(0), Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    const results = [];
    let done = false;

    while (!done) {
      let result = RegExpExec(rx, S);

      if (result instanceof AbruptCompletion) {
        return result;
      }

      if (result instanceof Completion) {
        result = result.Value;
      }

      if (result === Value.null) {
        done = true;
      } else {
        results.push(result);

        if (global === Value.false) {
          done = true;
        } else {
          let firstResult = Get(result, new Value('0'));

          if (firstResult instanceof AbruptCompletion) {
            return firstResult;
          }

          if (firstResult instanceof Completion) {
            firstResult = firstResult.Value;
          }

          let matchStr = ToString(firstResult);

          if (matchStr instanceof AbruptCompletion) {
            return matchStr;
          }

          if (matchStr instanceof Completion) {
            matchStr = matchStr.Value;
          }

          if (matchStr.stringValue() === '') {
            let lastIndex = Get(rx, new Value('lastIndex'));

            if (lastIndex instanceof AbruptCompletion) {
              return lastIndex;
            }

            if (lastIndex instanceof Completion) {
              lastIndex = lastIndex.Value;
            }

            let thisIndex = ToLength(lastIndex);

            if (thisIndex instanceof AbruptCompletion) {
              return thisIndex;
            }

            if (thisIndex instanceof Completion) {
              thisIndex = thisIndex.Value;
            }

            const nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
            {
              const hygienicTemp = Set$1(rx, new Value('lastIndex'), nextIndex, Value.true);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          }
        }
      }
    }

    let accumulatedResult = '';
    let nextSourcePosition = 0;

    for (const result of results) {
      let _hygienicTemp11 = LengthOfArrayLike(result);

      if (_hygienicTemp11 instanceof AbruptCompletion) {
        return _hygienicTemp11;
      }

      if (_hygienicTemp11 instanceof Completion) {
        _hygienicTemp11 = _hygienicTemp11.Value;
      }

      let nCaptures = _hygienicTemp11.numberValue();

      nCaptures = Math.max(nCaptures - 1, 0);
      let firstResult = Get(result, new Value('0'));

      if (firstResult instanceof AbruptCompletion) {
        return firstResult;
      }

      if (firstResult instanceof Completion) {
        firstResult = firstResult.Value;
      }

      let matched = ToString(firstResult);

      if (matched instanceof AbruptCompletion) {
        return matched;
      }

      if (matched instanceof Completion) {
        matched = matched.Value;
      }

      const matchLength = matched.stringValue().length;
      let resultIndex = Get(result, new Value('index'));

      if (resultIndex instanceof AbruptCompletion) {
        return resultIndex;
      }

      if (resultIndex instanceof Completion) {
        resultIndex = resultIndex.Value;
      }

      let position = ToInteger(resultIndex);

      if (position instanceof AbruptCompletion) {
        return position;
      }

      if (position instanceof Completion) {
        position = position.Value;
      }

      position = new Value(Math.max(Math.min(position.numberValue(), lengthS), 0));
      let n = 1;
      const captures = [];

      while (n <= nCaptures) {
        let _val4 = ToString(new Value(n));

        Assert(!(_val4 instanceof AbruptCompletion), "");

        if (_val4 instanceof Completion) {
          _val4 = _val4.Value;
        }

        {
          let capN = Get(result, _val4);

          if (capN instanceof AbruptCompletion) {
            return capN;
          }

          if (capN instanceof Completion) {
            capN = capN.Value;
          }

          if (capN !== Value.undefined) {
            capN = ToString(capN);

            if (capN instanceof AbruptCompletion) {
              return capN;
            }

            if (capN instanceof Completion) {
              capN = capN.Value;
            }
          }

          captures.push(capN);
          n += 1;
        }
      }

      let namedCaptures = Get(result, new Value('groups'));

      if (namedCaptures instanceof AbruptCompletion) {
        return namedCaptures;
      }

      if (namedCaptures instanceof Completion) {
        namedCaptures = namedCaptures.Value;
      }

      let replacement;

      if (functionalReplace === Value.true) {
        const replacerArgs = [matched];
        replacerArgs.push(...captures);
        replacerArgs.push(position, S);

        if (namedCaptures !== Value.undefined) {
          replacerArgs.push(namedCaptures);
        }

        let replValue = Call(replaceValue, Value.undefined, replacerArgs);

        if (replValue instanceof AbruptCompletion) {
          return replValue;
        }

        if (replValue instanceof Completion) {
          replValue = replValue.Value;
        }

        replacement = ToString(replValue);

        if (replacement instanceof AbruptCompletion) {
          return replacement;
        }

        if (replacement instanceof Completion) {
          replacement = replacement.Value;
        }
      } else {
        replacement = GetSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position.numberValue() >= nextSourcePosition) {
        accumulatedResult = accumulatedResult + S.stringValue().substring(nextSourcePosition, position.numberValue()) + replacement.stringValue();
        nextSourcePosition = position.numberValue() + matchLength;
      }
    }

    if (nextSourcePosition >= lengthS) {
      return new Value(accumulatedResult);
    }

    return new Value(accumulatedResult + S.stringValue().substring(nextSourcePosition));
  } // 21.2.5.11 #sec-regexp.prototype-@@search


  function RegExpProto_search([string = Value.undefined], {
    thisValue
  }) {
    const rx = thisValue;

    if (Type(rx) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', rx));
    }

    let S = ToString(string);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let previousLastIndex = Get(rx, new Value('lastIndex'));

    if (previousLastIndex instanceof AbruptCompletion) {
      return previousLastIndex;
    }

    if (previousLastIndex instanceof Completion) {
      previousLastIndex = previousLastIndex.Value;
    }

    if (SameValue(previousLastIndex, new Value(0)) === Value.false) {
      {
        const hygienicTemp = Set$1(rx, new Value('lastIndex'), new Value(0), Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    let result = RegExpExec(rx, S);

    if (result instanceof AbruptCompletion) {
      return result;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }

    let currentLastIndex = Get(rx, new Value('lastIndex'));

    if (currentLastIndex instanceof AbruptCompletion) {
      return currentLastIndex;
    }

    if (currentLastIndex instanceof Completion) {
      currentLastIndex = currentLastIndex.Value;
    }

    if (SameValue(currentLastIndex, previousLastIndex) === Value.false) {
      {
        const hygienicTemp = Set$1(rx, new Value('lastIndex'), previousLastIndex, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    if (result === Value.null) {
      return new Value(-1);
    }

    return Get(result, new Value('index'));
  } // 21.2.5.12 #sec-get-regexp.prototype.source


  function RegExpProto_sourceGetter(args, {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    if (!('OriginalSource' in R)) {
      if (SameValue(R, surroundingAgent.intrinsic('%RegExpPrototype%')) === Value.true) {
        return new Value('(?:)');
      }

      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    Assert('OriginalFlags' in R, "'OriginalFlags' in R");
    const src = R.OriginalSource;
    const flags = R.OriginalFlags;
    return EscapeRegExpPattern(src, flags);
  } // 21.2.5.13 #sec-regexp.prototype-@@split


  function RegExpProto_split([string = Value.undefined, limit = Value.undefined], {
    thisValue
  }) {
    const rx = thisValue;

    if (Type(rx) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', rx));
    }

    let S = ToString(string);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let C = SpeciesConstructor(rx, surroundingAgent.intrinsic('%RegExp%'));

    if (C instanceof AbruptCompletion) {
      return C;
    }

    if (C instanceof Completion) {
      C = C.Value;
    }

    let flagsValue = Get(rx, new Value('flags'));

    if (flagsValue instanceof AbruptCompletion) {
      return flagsValue;
    }

    if (flagsValue instanceof Completion) {
      flagsValue = flagsValue.Value;
    }

    let _hygienicTemp12 = ToString(flagsValue);

    if (_hygienicTemp12 instanceof AbruptCompletion) {
      return _hygienicTemp12;
    }

    if (_hygienicTemp12 instanceof Completion) {
      _hygienicTemp12 = _hygienicTemp12.Value;
    }

    const flags = _hygienicTemp12.stringValue();

    const unicodeMatching = flags.includes('u') ? Value.true : Value.false;
    const newFlags = flags.includes('y') ? new Value(flags) : new Value(`${flags}y`);
    let splitter = Construct(C, [rx, newFlags]);

    if (splitter instanceof AbruptCompletion) {
      return splitter;
    }

    if (splitter instanceof Completion) {
      splitter = splitter.Value;
    }

    let A = ArrayCreate(new Value(0));
    Assert(!(A instanceof AbruptCompletion), "");

    if (A instanceof Completion) {
      A = A.Value;
    }

    let lengthA = 0;
    let lim;

    if (limit === Value.undefined) {
      lim = 2 ** 32 - 1;
    } else {
      let _hygienicTemp13 = ToUint32(limit);

      if (_hygienicTemp13 instanceof AbruptCompletion) {
        return _hygienicTemp13;
      }

      if (_hygienicTemp13 instanceof Completion) {
        _hygienicTemp13 = _hygienicTemp13.Value;
      }

      lim = _hygienicTemp13.numberValue();
    }

    const size = S.stringValue().length;
    let p = 0;

    if (lim === 0) {
      return A;
    }

    if (size === 0) {
      let z = RegExpExec(splitter, S);

      if (z instanceof AbruptCompletion) {
        return z;
      }

      if (z instanceof Completion) {
        z = z.Value;
      }

      if (z !== Value.null) {
        return A;
      }

      Assert(!(CreateDataProperty(A, new Value('0'), S) instanceof AbruptCompletion), "");
      return A;
    }

    let q = new Value(p);

    while (q.numberValue() < size) {
      {
        const hygienicTemp = Set$1(splitter, new Value('lastIndex'), q, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      let z = RegExpExec(splitter, S);

      if (z instanceof AbruptCompletion) {
        return z;
      }

      if (z instanceof Completion) {
        z = z.Value;
      }

      if (z === Value.null) {
        q = AdvanceStringIndex(S, q, unicodeMatching);
      } else {
        let lastIndex = Get(splitter, new Value('lastIndex'));

        if (lastIndex instanceof AbruptCompletion) {
          return lastIndex;
        }

        if (lastIndex instanceof Completion) {
          lastIndex = lastIndex.Value;
        }

        let e = ToLength(lastIndex);

        if (e instanceof AbruptCompletion) {
          return e;
        }

        if (e instanceof Completion) {
          e = e.Value;
        }

        e = new Value(Math.min(e.numberValue(), size));

        if (e.numberValue() === p) {
          q = AdvanceStringIndex(S, q, unicodeMatching);
        } else {
          const T = new Value(S.stringValue().substring(p, q.numberValue()));

          let _val5 = ToString(new Value(lengthA));

          Assert(!(_val5 instanceof AbruptCompletion), "");

          if (_val5 instanceof Completion) {
            _val5 = _val5.Value;
          }

          Assert(!(CreateDataProperty(A, _val5, T) instanceof AbruptCompletion), "");
          lengthA += 1;

          if (lengthA === lim) {
            return A;
          }

          p = e.numberValue();

          let _hygienicTemp14 = LengthOfArrayLike(z);

          if (_hygienicTemp14 instanceof AbruptCompletion) {
            return _hygienicTemp14;
          }

          if (_hygienicTemp14 instanceof Completion) {
            _hygienicTemp14 = _hygienicTemp14.Value;
          }

          let numberOfCaptures = _hygienicTemp14.numberValue();

          numberOfCaptures = Math.max(numberOfCaptures - 1, 0);
          let i = 1;

          while (i <= numberOfCaptures) {
            let _val6 = ToString(new Value(i));

            Assert(!(_val6 instanceof AbruptCompletion), "");

            if (_val6 instanceof Completion) {
              _val6 = _val6.Value;
            }

            {
              let nextCapture = Get(z, _val6);

              if (nextCapture instanceof AbruptCompletion) {
                return nextCapture;
              }

              if (nextCapture instanceof Completion) {
                nextCapture = nextCapture.Value;
              }

              let _val7 = ToString(new Value(lengthA));

              Assert(!(_val7 instanceof AbruptCompletion), "");

              if (_val7 instanceof Completion) {
                _val7 = _val7.Value;
              }

              Assert(!(CreateDataProperty(A, _val7, nextCapture) instanceof AbruptCompletion), "");
              i += 1;
              lengthA += 1;

              if (lengthA === lim) {
                return A;
              }
            }
          }

          q = new Value(p);
        }
      }
    }

    const T = new Value(S.stringValue().substring(p, size));

    let _val8 = ToString(new Value(lengthA));

    Assert(!(_val8 instanceof AbruptCompletion), "");

    if (_val8 instanceof Completion) {
      _val8 = _val8.Value;
    }

    Assert(!(CreateDataProperty(A, _val8, T) instanceof AbruptCompletion), "");
    return A;
  } // 21.2.5.14 #sec-get-regexp.prototype.sticky


  function RegExpProto_stickyGetter(args, {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    if (!('OriginalFlags' in R)) {
      if (SameValue(R, surroundingAgent.intrinsic('%RegExpPrototype%')) === Value.true) {
        return Value.undefined;
      }

      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    const flags = R.OriginalFlags;

    if (flags.stringValue().includes('y')) {
      return Value.true;
    }

    return Value.false;
  } // 21.2.5.15 #sec-regexp.prototype.test


  function RegExpProto_test([S = Value.undefined], {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    let string = ToString(S);

    if (string instanceof AbruptCompletion) {
      return string;
    }

    if (string instanceof Completion) {
      string = string.Value;
    }

    let match = RegExpExec(R, string);

    if (match instanceof AbruptCompletion) {
      return match;
    }

    if (match instanceof Completion) {
      match = match.Value;
    }

    if (match !== Value.null) {
      return Value.true;
    }

    return Value.false;
  } // 21.2.5.16 #sec-regexp.prototype.tostring


  function RegExpProto_toString(args, {
    thisValue
  }) {
    let _hygienicTemp15 = Get(R, new Value('source'));

    if (_hygienicTemp15 instanceof AbruptCompletion) {
      return _hygienicTemp15;
    }

    if (_hygienicTemp15 instanceof Completion) {
      _hygienicTemp15 = _hygienicTemp15.Value;
    }

    let _hygienicTemp16 = Get(R, new Value('flags'));

    if (_hygienicTemp16 instanceof AbruptCompletion) {
      return _hygienicTemp16;
    }

    if (_hygienicTemp16 instanceof Completion) {
      _hygienicTemp16 = _hygienicTemp16.Value;
    }

    {
      const R = thisValue;

      if (Type(R) !== 'Object') {
        return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
      }

      let pattern = ToString(_hygienicTemp15);

      if (pattern instanceof AbruptCompletion) {
        return pattern;
      }

      if (pattern instanceof Completion) {
        pattern = pattern.Value;
      }

      let flags = ToString(_hygienicTemp16);

      if (flags instanceof AbruptCompletion) {
        return flags;
      }

      if (flags instanceof Completion) {
        flags = flags.Value;
      }

      const result = `/${pattern.stringValue()}/${flags.stringValue()}`;
      return new Value(result);
    }
  } // 21.2.5.17 #sec-get-regexp.prototype.unicode


  function RegExpProto_unicodeGetter(args, {
    thisValue
  }) {
    const R = thisValue;

    if (Type(R) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    if (!('OriginalFlags' in R)) {
      if (SameValue(R, surroundingAgent.intrinsic('%RegExpPrototype%')) === Value.true) {
        return Value.undefined;
      }

      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'RegExp', R));
    }

    const flags = R.OriginalFlags;

    if (flags.stringValue().includes('u')) {
      return Value.true;
    }

    return Value.false;
  }

  function CreateRegExpPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['exec', RegExpProto_exec, 1], ['dotAll', [RegExpProto_dotAllGetter]], ['flags', [RegExpProto_flagsGetter]], ['global', [RegExpProto_globalGetter]], ['ignoreCase', [RegExpProto_ignoreCaseGetter]], [wellKnownSymbols.match, RegExpProto_match, 1], [wellKnownSymbols.matchAll, RegExpProto_matchAll, 1], ['multiline', [RegExpProto_multilineGetter]], [wellKnownSymbols.replace, RegExpProto_replace, 2], [wellKnownSymbols.search, RegExpProto_search, 1], ['source', [RegExpProto_sourceGetter]], [wellKnownSymbols.split, RegExpProto_split, 2], ['sticky', [RegExpProto_stickyGetter]], ['test', RegExpProto_test, 1], ['toString', RegExpProto_toString, 0], ['unicode', [RegExpProto_unicodeGetter]]], realmRec.Intrinsics['%ObjectPrototype%']);
    realmRec.Intrinsics['%RegExpPrototype%'] = proto;
  }

  function RegExpConstructor([pattern = Value.undefined, flags = Value.undefined], {
    NewTarget
  }) {
    let patternIsRegExp = IsRegExp(pattern);

    if (patternIsRegExp instanceof AbruptCompletion) {
      return patternIsRegExp;
    }

    if (patternIsRegExp instanceof Completion) {
      patternIsRegExp = patternIsRegExp.Value;
    }

    let newTarget;

    if (NewTarget === Value.undefined) {
      newTarget = surroundingAgent.activeFunctionObject;

      if (patternIsRegExp === Value.true && flags === Value.undefined) {
        let patternConstructor = Get(pattern, new Value('constructor'));

        if (patternConstructor instanceof AbruptCompletion) {
          return patternConstructor;
        }

        if (patternConstructor instanceof Completion) {
          patternConstructor = patternConstructor.Value;
        }

        if (SameValue(newTarget, patternConstructor) === Value.true) {
          return pattern;
        }
      }
    } else {
      newTarget = NewTarget;
    }

    let P;
    let F;

    if (Type(pattern) === 'Object' && 'RegExpMatcher' in pattern) {
      P = pattern.OriginalSource;

      if (flags === Value.undefined) {
        F = pattern.OriginalFlags;
      } else {
        F = flags;
      }
    } else if (patternIsRegExp === Value.true) {
      P = Get(pattern, new Value('source'));

      if (P instanceof AbruptCompletion) {
        return P;
      }

      if (P instanceof Completion) {
        P = P.Value;
      }

      if (flags === Value.undefined) {
        F = Get(pattern, new Value('flags'));

        if (F instanceof AbruptCompletion) {
          return F;
        }

        if (F instanceof Completion) {
          F = F.Value;
        }
      } else {
        F = flags;
      }
    } else {
      P = pattern;
      F = flags;
    }

    let O = RegExpAlloc(newTarget);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    return RegExpInitialize(O, P, F);
  } // 21.2.4.2 #sec-get-regexp-@@species


  function RegExp_speciesGetter(args, {
    thisValue
  }) {
    return thisValue;
  }

  function CreateRegExp(realmRec) {
    const proto = realmRec.Intrinsics['%RegExpPrototype%'];
    const cons = BootstrapConstructor(realmRec, RegExpConstructor, 'RegExp', 2, proto, [[wellKnownSymbols.species, [RegExp_speciesGetter]]]);
    realmRec.Intrinsics['%RegExp%'] = cons;
  }

  function PromiseProto_catch([onRejected = Value.undefined], {
    thisValue
  }) {
    const promise = thisValue;
    return Invoke(promise, new Value('then'), [Value.undefined, onRejected]);
  }

  function ThenFinallyFunctions([value = Value.undefined]) {
    const F = surroundingAgent.activeFunctionObject;
    const onFinally = F.OnFinally;
    Assert(IsCallable(onFinally) === Value.true, "IsCallable(onFinally) === Value.true");
    let result = Call(onFinally, Value.undefined);

    if (result instanceof AbruptCompletion) {
      return result;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }

    const C = F.Constructor;
    Assert(IsConstructor(C) === Value.true, "IsConstructor(C) === Value.true");
    let promise = PromiseResolve(C, result);

    if (promise instanceof AbruptCompletion) {
      return promise;
    }

    if (promise instanceof Completion) {
      promise = promise.Value;
    }

    const valueThunk = CreateBuiltinFunction(() => value, []);
    SetFunctionLength(valueThunk, new Value(0));
    return Invoke(promise, new Value('then'), [valueThunk]);
  }

  function CatchFinallyFunctions([reason = Value.undefined]) {
    const F = surroundingAgent.activeFunctionObject;
    const onFinally = F.OnFinally;
    Assert(IsCallable(onFinally) === Value.true, "IsCallable(onFinally) === Value.true");
    let result = Call(onFinally, Value.undefined);

    if (result instanceof AbruptCompletion) {
      return result;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }

    const C = F.Constructor;
    Assert(IsConstructor(C) === Value.true, "IsConstructor(C) === Value.true");
    let promise = PromiseResolve(C, result);

    if (promise instanceof AbruptCompletion) {
      return promise;
    }

    if (promise instanceof Completion) {
      promise = promise.Value;
    }

    const thrower = CreateBuiltinFunction(() => new ThrowCompletion(reason), []);
    SetFunctionLength(thrower, new Value(0));
    return Invoke(promise, new Value('then'), [thrower]);
  }

  function PromiseProto_finally([onFinally = Value.undefined], {
    thisValue
  }) {
    const promise = thisValue;

    if (Type(promise) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Promise', promise));
    }

    const C = SpeciesConstructor(promise, surroundingAgent.intrinsic('%Promise%'));
    Assert(IsConstructor(C) === Value.true, "IsConstructor(C) === Value.true");
    let thenFinally;
    let catchFinally;

    if (IsCallable(onFinally) === Value.false) {
      thenFinally = onFinally;
      catchFinally = onFinally;
    } else {
      const stepsThenFinally = ThenFinallyFunctions;
      thenFinally = CreateBuiltinFunction(stepsThenFinally, ['Constructor', 'OnFinally']);
      Assert(!(thenFinally instanceof AbruptCompletion), "");

      if (thenFinally instanceof Completion) {
        thenFinally = thenFinally.Value;
      }

      SetFunctionLength(thenFinally, new Value(1));
      thenFinally.Constructor = C;
      thenFinally.OnFinally = onFinally;
      const stepsCatchFinally = CatchFinallyFunctions;
      catchFinally = CreateBuiltinFunction(stepsCatchFinally, ['Constructor', 'OnFinally']);
      Assert(!(catchFinally instanceof AbruptCompletion), "");

      if (catchFinally instanceof Completion) {
        catchFinally = catchFinally.Value;
      }

      SetFunctionLength(catchFinally, new Value(1));
      catchFinally.Constructor = C;
      catchFinally.OnFinally = onFinally;
    }

    return Invoke(promise, new Value('then'), [thenFinally, catchFinally]);
  }

  function PromiseProto_then([onFulfilled = Value.undefined, onRejected = Value.undefined], {
    thisValue
  }) {
    const promise = thisValue;

    if (IsPromise(promise) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Promise', promise));
    }

    let C = SpeciesConstructor(promise, surroundingAgent.intrinsic('%Promise%'));

    if (C instanceof AbruptCompletion) {
      return C;
    }

    if (C instanceof Completion) {
      C = C.Value;
    }

    let resultCapability = NewPromiseCapability(C);

    if (resultCapability instanceof AbruptCompletion) {
      return resultCapability;
    }

    if (resultCapability instanceof Completion) {
      resultCapability = resultCapability.Value;
    }

    return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability);
  }

  function CreatePromisePrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['catch', PromiseProto_catch, 1], ['finally', PromiseProto_finally, 1], ['then', PromiseProto_then, 2]], realmRec.Intrinsics['%ObjectPrototype%'], 'Promise');

    let _val = Get(proto, new Value('then'));

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    realmRec.Intrinsics['%PromiseProto_then%'] = _val;
    realmRec.Intrinsics['%PromisePrototype%'] = proto;
  }

  function PromiseConstructor([executor = Value.undefined], {
    NewTarget
  }) {
    if (NewTarget === Value.undefined) {
      return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', 'Promise'));
    }

    if (IsCallable(executor) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', executor));
    }

    let promise = OrdinaryCreateFromConstructor(NewTarget, '%PromisePrototype%', ['PromiseState', 'PromiseResult', 'PromiseFulfillReactions', 'PromiseRejectReactions', 'PromiseIsHandled']);

    if (promise instanceof AbruptCompletion) {
      return promise;
    }

    if (promise instanceof Completion) {
      promise = promise.Value;
    }

    promise.PromiseState = 'pending';
    promise.PromiseFulfillReactions = [];
    promise.PromiseRejectReactions = [];
    promise.PromiseIsHandled = Value.false;
    const resolvingFunctions = CreateResolvingFunctions(promise);
    const completion = Call(executor, Value.undefined, [resolvingFunctions.Resolve, resolvingFunctions.Reject]);

    if (completion instanceof AbruptCompletion) {
      {
        const hygienicTemp = Call(resolvingFunctions.Reject, Value.undefined, [completion.Value]);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    return promise;
  } // 25.6.4.1.2 #sec-promise.all-resolve-element-functions


  function PromiseAllResolveElementFunctions([x = Value.undefined]) {
    const F = surroundingAgent.activeFunctionObject;
    const alreadyCalled = F.AlreadyCalled;

    if (alreadyCalled.Value === true) {
      return Value.undefined;
    }

    alreadyCalled.Value = true;
    const index = F.Index;
    const values = F.Values;
    const promiseCapability = F.Capability;
    const remainingElementsCount = F.RemainingElements;
    values[index] = x;
    remainingElementsCount.Value -= 1;

    if (remainingElementsCount.Value === 0) {
      const valuesArray = CreateArrayFromList(values);
      return Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
    }

    return Value.undefined;
  } // 25.6.4.1.1 #sec-performpromiseall


  function PerformPromiseAll(iteratorRecord, constructor, resultCapability) {
    Assert(IsConstructor(constructor) === Value.true, "IsConstructor(constructor) === Value.true");
    Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
    const values = [];
    const remainingElementsCount = {
      Value: 1
    };
    let promiseResolve = Get(constructor, new Value('resolve'));

    if (promiseResolve instanceof AbruptCompletion) {
      return promiseResolve;
    }

    if (promiseResolve instanceof Completion) {
      promiseResolve = promiseResolve.Value;
    }

    if (IsCallable(promiseResolve) === Value.alse) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', promiseResolve));
    }

    let index = 0;

    while (true) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
        remainingElementsCount.Value -= 1;

        if (remainingElementsCount.Value === 0) {
          const valuesArray = CreateArrayFromList(values);
          {
            const hygienicTemp = Call(resultCapability.Resolve, Value.undefined, [valuesArray]);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        return resultCapability.Promise;
      }

      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      values.push(Value.undefined);
      let nextPromise = Call(promiseResolve, constructor, [nextValue]);

      if (nextPromise instanceof AbruptCompletion) {
        return nextPromise;
      }

      if (nextPromise instanceof Completion) {
        nextPromise = nextPromise.Value;
      }

      const steps = PromiseAllResolveElementFunctions;
      let resolveElement = CreateBuiltinFunction(steps, ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);
      Assert(!(resolveElement instanceof AbruptCompletion), "");

      if (resolveElement instanceof Completion) {
        resolveElement = resolveElement.Value;
      }

      Assert(!(SetFunctionLength(resolveElement, new Value(1)) instanceof AbruptCompletion), "");
      resolveElement.AlreadyCalled = {
        Value: false
      };
      resolveElement.Index = index;
      resolveElement.Values = values;
      resolveElement.Capability = resultCapability;
      resolveElement.RemainingElements = remainingElementsCount;
      remainingElementsCount.Value += 1;
      {
        const hygienicTemp = Invoke(nextPromise, new Value('then'), [resolveElement, resultCapability.Reject]);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      index += 1;
    }
  }

  function Promise_all([iterable = Value.undefined], {
    thisValue
  }) {
    const C = thisValue;
    let promiseCapability = NewPromiseCapability(C);

    if (promiseCapability instanceof AbruptCompletion) {
      return promiseCapability;
    }

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    let iteratorRecord = GetIterator(iterable);

    if (iteratorRecord instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    let result = PerformPromiseAll(iteratorRecord, C, promiseCapability);

    if (result instanceof AbruptCompletion) {
      if (iteratorRecord.Done === Value.false) {
        result = IteratorClose(iteratorRecord, result);
      }

      if (result instanceof AbruptCompletion) {
        const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

        if (hygenicTemp2 instanceof AbruptCompletion) {
          return hygenicTemp2;
        }

        return promiseCapability.Promise;
      } else if (result instanceof Completion) {
        result = result.Value;
      }
    }

    return Completion(result);
  }

  function PromiseAllSettledResolveElementFunctions([x = Value.undefined]) {
    const F = surroundingAgent.activeFunctionObject;
    const alreadyCalled = F.AlreadyCalled;

    if (alreadyCalled.Value === true) {
      return Value.undefined;
    }

    alreadyCalled.Value = true;
    const index = F.Index;
    const values = F.Values;
    const promiseCapability = F.Capability;
    const remainingElementsCount = F.RemainingElements;
    let obj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    Assert(!(obj instanceof AbruptCompletion), "");

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    Assert(!(CreateDataProperty(obj, new Value('status'), new Value('fulfilled')) instanceof AbruptCompletion), "");
    Assert(!(CreateDataProperty(obj, new Value('value'), x) instanceof AbruptCompletion), "");
    values[index] = obj;
    remainingElementsCount.Value -= 1;

    if (remainingElementsCount.Value === 0) {
      let valuesArray = CreateArrayFromList(values);
      Assert(!(valuesArray instanceof AbruptCompletion), "");

      if (valuesArray instanceof Completion) {
        valuesArray = valuesArray.Value;
      }

      return Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
    }

    return Value.undefined;
  }

  function PromiseAllSettledRejectElementFunctions([x = Value.undefined]) {
    const F = surroundingAgent.activeFunctionObject;
    const alreadyCalled = F.AlreadyCalled;

    if (alreadyCalled.Value === true) {
      return Value.undefined;
    }

    alreadyCalled.Value = true;
    const index = F.Index;
    const values = F.Values;
    const promiseCapability = F.Capability;
    const remainingElementsCount = F.RemainingElements;
    let obj = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    Assert(!(obj instanceof AbruptCompletion), "");

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    Assert(!(CreateDataProperty(obj, new Value('status'), new Value('rejected')) instanceof AbruptCompletion), "");
    Assert(!(CreateDataProperty(obj, new Value('reason'), x) instanceof AbruptCompletion), "");
    values[index] = obj;
    remainingElementsCount.Value -= 1;

    if (remainingElementsCount.Value === 0) {
      let valuesArray = CreateArrayFromList(values);
      Assert(!(valuesArray instanceof AbruptCompletion), "");

      if (valuesArray instanceof Completion) {
        valuesArray = valuesArray.Value;
      }

      return Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
    }

    return Value.undefined;
  }

  function PerformPromiseAllSettled(iteratorRecord, constructor, resultCapability) {
    let _val = IsConstructor(constructor) === Value.true;

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    Assert(_val, "X(IsConstructor(constructor) === Value.true)");
    Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
    let promiseResolve = Get(constructor, new Value('resolve'));

    if (promiseResolve instanceof AbruptCompletion) {
      return promiseResolve;
    }

    if (promiseResolve instanceof Completion) {
      promiseResolve = promiseResolve.Value;
    }

    const values = [];
    const remainingElementsCount = {
      Value: 1
    };
    let index = 0;

    while (true) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
        remainingElementsCount.Value -= 1;

        if (remainingElementsCount.Value === 0) {
          let valuesArray = CreateArrayFromList(values);
          Assert(!(valuesArray instanceof AbruptCompletion), "");

          if (valuesArray instanceof Completion) {
            valuesArray = valuesArray.Value;
          }

          {
            const hygienicTemp = Call(resultCapability.Resolve, Value.undefined, [valuesArray]);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }

        return resultCapability.Promise;
      }

      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      values.push(Value.undefined);
      let nextPromise = Call(promiseResolve, constructor, [nextValue]);

      if (nextPromise instanceof AbruptCompletion) {
        return nextPromise;
      }

      if (nextPromise instanceof Completion) {
        nextPromise = nextPromise.Value;
      }

      const steps = PromiseAllSettledResolveElementFunctions;
      let resolveElement = CreateBuiltinFunction(steps, ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);
      Assert(!(resolveElement instanceof AbruptCompletion), "");

      if (resolveElement instanceof Completion) {
        resolveElement = resolveElement.Value;
      }

      Assert(!(SetFunctionLength(resolveElement, new Value(1)) instanceof AbruptCompletion), "");
      const alreadyCalled = {
        Value: false
      };
      resolveElement.AlreadyCalled = alreadyCalled;
      resolveElement.Index = index;
      resolveElement.Values = values;
      resolveElement.Capability = resultCapability;
      resolveElement.RemainingElements = remainingElementsCount;
      const rejectSteps = PromiseAllSettledRejectElementFunctions;
      let rejectElement = CreateBuiltinFunction(rejectSteps, ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);
      Assert(!(rejectElement instanceof AbruptCompletion), "");

      if (rejectElement instanceof Completion) {
        rejectElement = rejectElement.Value;
      }

      Assert(!(SetFunctionLength(rejectElement, new Value(1)) instanceof AbruptCompletion), "");
      rejectElement.AlreadyCalled = alreadyCalled;
      rejectElement.Index = index;
      rejectElement.Values = values;
      rejectElement.Capability = resultCapability;
      rejectElement.RemainingElements = remainingElementsCount;
      remainingElementsCount.Value += 1;
      {
        const hygienicTemp = Invoke(nextPromise, new Value('then'), [resolveElement, rejectElement]);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      index += 1;
    }
  }

  function Promise_allSettled([iterable = Value.undefined], {
    thisValue
  }) {
    const C = thisValue;
    let promiseCapability = NewPromiseCapability(C);

    if (promiseCapability instanceof AbruptCompletion) {
      return promiseCapability;
    }

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    let iteratorRecord = GetIterator(iterable);

    if (iteratorRecord instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    let result = PerformPromiseAllSettled(iteratorRecord, C, promiseCapability);

    if (result instanceof AbruptCompletion) {
      if (iteratorRecord.Done === Value.false) {
        result = IteratorClose(iteratorRecord, result);
      }

      if (result instanceof AbruptCompletion) {
        const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

        if (hygenicTemp2 instanceof AbruptCompletion) {
          return hygenicTemp2;
        }

        return promiseCapability.Promise;
      } else if (result instanceof Completion) {
        result = result.Value;
      }
    }

    return Completion(result);
  }

  function PerformPromiseRace(iteratorRecord, constructor, resultCapability) {
    Assert(IsConstructor(constructor) === Value.true, "IsConstructor(constructor) === Value.true");
    Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
    let promiseResolve = Get(constructor, new Value('resolve'));

    if (promiseResolve instanceof AbruptCompletion) {
      return promiseResolve;
    }

    if (promiseResolve instanceof Completion) {
      promiseResolve = promiseResolve.Value;
    }

    if (IsCallable(promiseResolve) === Value.alse) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', promiseResolve));
    }

    while (true) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
        return resultCapability.Promise;
      }

      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      let nextPromise = Call(promiseResolve, constructor, [nextValue]);

      if (nextPromise instanceof AbruptCompletion) {
        return nextPromise;
      }

      if (nextPromise instanceof Completion) {
        nextPromise = nextPromise.Value;
      }

      {
        const hygienicTemp = Invoke(nextPromise, new Value('then'), [resultCapability.Resolve, resultCapability.Reject]);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }
  }

  function Promise_race([iterable = Value.undefined], {
    thisValue
  }) {
    const C = thisValue;
    let promiseCapability = NewPromiseCapability(C);

    if (promiseCapability instanceof AbruptCompletion) {
      return promiseCapability;
    }

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    let iteratorRecord = GetIterator(iterable);

    if (iteratorRecord instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    let result = PerformPromiseRace(iteratorRecord, C, promiseCapability);

    if (result instanceof AbruptCompletion) {
      if (iteratorRecord.Done === Value.false) {
        result = IteratorClose(iteratorRecord, result);
      }

      if (result instanceof AbruptCompletion) {
        const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

        if (hygenicTemp2 instanceof AbruptCompletion) {
          return hygenicTemp2;
        }

        return promiseCapability.Promise;
      } else if (result instanceof Completion) {
        result = result.Value;
      }
    }

    return Completion(result);
  }

  function Promise_reject([r = Value.undefined], {
    thisValue
  }) {
    const C = thisValue;
    let promiseCapability = NewPromiseCapability(C);

    if (promiseCapability instanceof AbruptCompletion) {
      return promiseCapability;
    }

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    {
      const hygienicTemp = Call(promiseCapability.Reject, Value.undefined, [r]);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return promiseCapability.Promise;
  }

  function Promise_resolve([x = Value.undefined], {
    thisValue
  }) {
    const C = thisValue;

    if (Type(C) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'Promise.resolve called on non-object');
    }

    return PromiseResolve(C, x);
  }

  function Promise_symbolSpecies(args, {
    thisValue
  }) {
    return thisValue;
  }

  function CreatePromise(realmRec) {
    const promiseConstructor = BootstrapConstructor(realmRec, PromiseConstructor, 'Promise', 1, realmRec.Intrinsics['%PromisePrototype%'], [['all', Promise_all, 1], surroundingAgent.feature('Promise.allSettled') ? ['allSettled', Promise_allSettled, 1] : undefined, ['race', Promise_race, 1], ['reject', Promise_reject, 1], ['resolve', Promise_resolve, 1], [wellKnownSymbols.species, [Promise_symbolSpecies]]]);
    promiseConstructor.DefineOwnProperty(new Value('prototype'), Descriptor({
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    }));

    let _val2 = Get(promiseConstructor, new Value('all'));

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    realmRec.Intrinsics['%Promise_all%'] = _val2;

    let _val3 = Get(promiseConstructor, new Value('reject'));

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    realmRec.Intrinsics['%Promise_reject%'] = _val3;

    let _val4 = Get(promiseConstructor, new Value('resolve'));

    Assert(!(_val4 instanceof AbruptCompletion), "");

    if (_val4 instanceof Completion) {
      _val4 = _val4.Value;
    }

    realmRec.Intrinsics['%Promise_resolve%'] = _val4;
    realmRec.Intrinsics['%Promise%'] = promiseConstructor;
  }

  function ProxyCallSlot(thisArgument, argumentsList) {
    const O = this;
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'Cannot call a proxy that has been revoked');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;
    let trap = GetMethod(handler, new Value('apply'));

    if (trap instanceof AbruptCompletion) {
      return trap;
    }

    if (trap instanceof Completion) {
      trap = trap.Value;
    }

    if (trap === Value.undefined) {
      return Call(target, thisArgument, argumentsList);
    }

    let argArray = CreateArrayFromList(argumentsList);
    Assert(!(argArray instanceof AbruptCompletion), "");

    if (argArray instanceof Completion) {
      argArray = argArray.Value;
    }

    return Call(trap, handler, [target, thisArgument, argArray]);
  }

  function ProxyConstructSlot(argumentsList, newTarget) {
    const O = this;
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'Cannot construct a proxy that has been revoked');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;
    Assert(IsConstructor(target) === Value.true, "IsConstructor(target) === Value.true");
    let trap = GetMethod(handler, new Value('construct'));

    if (trap instanceof AbruptCompletion) {
      return trap;
    }

    if (trap instanceof Completion) {
      trap = trap.Value;
    }

    if (trap === Value.undefined) {
      return Construct(target, argumentsList, newTarget);
    }

    let argArray = CreateArrayFromList(argumentsList);
    Assert(!(argArray instanceof AbruptCompletion), "");

    if (argArray instanceof Completion) {
      argArray = argArray.Value;
    }

    let newObj = Call(trap, handler, [target, argArray, newTarget]);

    if (newObj instanceof AbruptCompletion) {
      return newObj;
    }

    if (newObj instanceof Completion) {
      newObj = newObj.Value;
    }

    if (Type(newObj) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'Proxy trap returned non-object');
    }

    return newObj;
  }

  function ProxyCreate(target, handler) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'Cannot create proxy with a non-object as target');
    }

    if (target instanceof ProxyExoticObjectValue && Type(target.ProxyHandler) === 'Null') {
      return surroundingAgent.Throw('TypeError', 'Cannot create proxy with a revoked proxy as target');
    }

    if (Type(handler) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'Cannot create proxy with a non-object as handler');
    }

    if (handler instanceof ProxyExoticObjectValue && Type(handler.ProxyHandler) === 'Null') {
      return surroundingAgent.Throw('TypeError', 'Cannot create proxy with a revoked proxy as handler');
    }

    const P = new ProxyExoticObjectValue();

    if (IsCallable(target) === Value.true) {
      P.Call = ProxyCallSlot;

      if (IsConstructor(target) === Value.true) {
        P.Construct = ProxyConstructSlot;
      }
    }

    P.ProxyTarget = target;
    P.ProxyHandler = handler;
    return P;
  }

  function ProxyConstructor([target = Value.undefined, handler = Value.undefined], {
    NewTarget
  }) {
    if (Type(NewTarget) === 'Undefined') {
      return surroundingAgent.Throw('TypeError', 'Constructor Proxy requires \'new\'');
    }

    return ProxyCreate(target, handler);
  }

  function ProxyRevocationFunctions() {
    const F = this;
    const p = F.RevocableProxy;

    if (Type(p) === 'Null') {
      return Value.undefined;
    }

    F.RevocableProxy = Value.null;
    Assert(p instanceof ProxyExoticObjectValue, "p instanceof ProxyExoticObjectValue");
    p.ProxyTarget = Value.null;
    p.ProxyHandler = Value.null;
    return Value.undefined;
  }

  function Proxy_revocable([target = Value.undefined, handler = Value.undefined]) {
    let p = ProxyCreate(target, handler);

    if (p instanceof AbruptCompletion) {
      return p;
    }

    if (p instanceof Completion) {
      p = p.Value;
    }

    const steps = ProxyRevocationFunctions;
    let revoker = CreateBuiltinFunction(steps, ['RevocableProxy']);
    Assert(!(revoker instanceof AbruptCompletion), "");

    if (revoker instanceof Completion) {
      revoker = revoker.Value;
    }

    SetFunctionLength(revoker, new Value(0));
    revoker.RevocableProxy = p;
    const result = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    Assert(!(CreateDataProperty(result, new Value('proxy'), p) instanceof AbruptCompletion), "");
    Assert(!(CreateDataProperty(result, new Value('revoke'), revoker) instanceof AbruptCompletion), "");
    return result;
  }

  function CreateProxy(realmRec) {
    const proxyConstructor = CreateBuiltinFunction(ProxyConstructor, [], realmRec, undefined, Value.true);
    SetFunctionName(proxyConstructor, new Value('Proxy'));
    SetFunctionLength(proxyConstructor, new Value(2));
    assignProps(realmRec, proxyConstructor, [['revocable', Proxy_revocable, 2]]);
    realmRec.Intrinsics['%Proxy%'] = proxyConstructor;
  }

  function Reflect_apply([target = Value.undefined, thisArgument = Value.undefined, argumentsList = Value.undefined]) {
    if (IsCallable(target) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'target is not callable');
    }

    let args = CreateListFromArrayLike(argumentsList);

    if (args instanceof AbruptCompletion) {
      return args;
    }

    if (args instanceof Completion) {
      args = args.Value;
    }
    return Call(target, thisArgument, args);
  }

  function Reflect_construct([target = Value.undefined, argumentsList = Value.undefined, newTarget]) {
    if (IsConstructor(target) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAConstructor', target));
    }

    if (newTarget === undefined) {
      newTarget = target;
    } else if (IsConstructor(newTarget) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAConstructor', newTarget));
    }

    let args = CreateListFromArrayLike(argumentsList);

    if (args instanceof AbruptCompletion) {
      return args;
    }

    if (args instanceof Completion) {
      args = args.Value;
    }

    return Construct(target, args, newTarget);
  }

  function Reflect_defineProperty([target = Value.undefined, propertyKey = Value.undefined, attributes = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    let key = ToPropertyKey(propertyKey);

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    let desc = ToPropertyDescriptor(attributes);

    if (desc instanceof AbruptCompletion) {
      return desc;
    }

    if (desc instanceof Completion) {
      desc = desc.Value;
    }

    return target.DefineOwnProperty(key, desc);
  }

  function Reflect_deleteProperty([target = Value.undefined, propertyKey = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    let key = ToPropertyKey(propertyKey);

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    return target.Delete(key);
  }

  function Reflect_get([target = Value.undefined, propertyKey = Value.undefined, receiver]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    let key = ToPropertyKey(propertyKey);

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    if (receiver === undefined) {
      receiver = target;
    }

    return target.Get(key, receiver);
  }

  function Reflect_getOwnPropertyDescriptor([target = Value.undefined, propertyKey = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    let key = ToPropertyKey(propertyKey);

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    let desc = target.GetOwnProperty(key);

    if (desc instanceof AbruptCompletion) {
      return desc;
    }

    if (desc instanceof Completion) {
      desc = desc.Value;
    }

    return FromPropertyDescriptor(desc);
  }

  function Reflect_getPrototypeOf([target = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    return target.GetPrototypeOf();
  }

  function Reflect_has([target = Value.undefined, propertyKey = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    let key = ToPropertyKey(propertyKey);

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    return target.HasProperty(key);
  }

  function Reflect_isExtensible([target = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    return target.IsExtensible();
  }

  function Reflect_ownKeys([target = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    let keys = target.OwnPropertyKeys();

    if (keys instanceof AbruptCompletion) {
      return keys;
    }

    if (keys instanceof Completion) {
      keys = keys.Value;
    }

    return CreateArrayFromList(keys);
  }

  function Reflect_preventExtensions([target = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    return target.PreventExtensions();
  }

  function Reflect_set([target = Value.undefined, propertyKey = Value.undefined, V = Value.undefined, receiver]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    let key = ToPropertyKey(propertyKey);

    if (key instanceof AbruptCompletion) {
      return key;
    }

    if (key instanceof Completion) {
      key = key.Value;
    }

    if (receiver === undefined) {
      receiver = target;
    }

    return target.Set(key, V, receiver);
  }

  function Reflect_setPrototypeOf([target = Value.undefined, proto = Value.undefined]) {
    if (Type(target) !== 'Object') {
      return surroundingAgent.Throw('TypeError', 'target is not an object');
    }

    if (Type(proto) !== 'Object' && Type(proto) !== 'Null') {
      return surroundingAgent.Throw('TypeError', 'proto is not an object or null');
    }

    return target.SetPrototypeOf(proto);
  }

  function CreateReflect(realmRec) {
    const reflect = BootstrapPrototype(realmRec, [['apply', Reflect_apply, 3], ['construct', Reflect_construct, 2], ['defineProperty', Reflect_defineProperty, 3], ['deleteProperty', Reflect_deleteProperty, 2], ['get', Reflect_get, 2], ['getOwnPropertyDescriptor', Reflect_getOwnPropertyDescriptor, 2], ['getPrototypeOf', Reflect_getPrototypeOf, 1], ['has', Reflect_has, 2], ['isExtensible', Reflect_isExtensible, 1], ['ownKeys', Reflect_ownKeys, 1], ['preventExtensions', Reflect_preventExtensions, 1], ['set', Reflect_set, 3], ['setPrototypeOf', Reflect_setPrototypeOf, 2]], realmRec.Intrinsics['%ObjectPrototype%']);
    realmRec.Intrinsics['%Reflect%'] = reflect;
  }

  function CreateStringIterator(string) {
    Assert(Type(string) === 'String', "Type(string) === 'String'");
    const iterator = ObjectCreate(surroundingAgent.intrinsic('%StringIteratorPrototype%'), ['IteratedString', 'StringIteratorNextIndex']);
    iterator.IteratedString = string;
    iterator.StringIteratorNextIndex = 0;
    return iterator;
  }

  function StringIteratorPrototype_next(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'String Iterator', O));
    }

    if (!('IteratedString' in O && 'StringIteratorNextIndex' in O)) {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'String Iterator', O));
    }

    const s = O.IteratedString;

    if (s === Value.undefined) {
      return CreateIterResultObject(Value.undefined, Value.true);
    }

    const position = O.StringIteratorNextIndex;
    const len = s.stringValue().length;

    if (position >= len) {
      O.IteratedString = Value.undefined;
      return CreateIterResultObject(Value.undefined, Value.true);
    }

    let cp = CodePointAt(s, position);
    Assert(!(cp instanceof AbruptCompletion), "");

    if (cp instanceof Completion) {
      cp = cp.Value;
    }

    const resultString = new Value(s.stringValue().substr(position, cp.CodeUnitCount.numberValue()));
    O.StringIteratorNextIndex = position + cp.CodeUnitCount.numberValue();
    return CreateIterResultObject(resultString, Value.false);
  }

  function CreateStringIteratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['next', StringIteratorPrototype_next, 0]], realmRec.Intrinsics['%IteratorPrototype%'], 'String Iterator');
    realmRec.Intrinsics['%StringIteratorPrototype%'] = proto;
  }

  function thisStringValue(value) {
    if (Type(value) === 'String') {
      return value;
    }

    if (Type(value) === 'Object' && 'StringData' in value) {
      const s = value.StringData;
      Assert(Type(s) === 'String', "Type(s) === 'String'");
      return s;
    }

    return surroundingAgent.Throw('TypeError');
  } // 21.1.3.1 #sec-string.prototype.charat


  function StringProto_charAt([pos = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let _hygienicTemp = ToInteger(pos);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const position = _hygienicTemp.numberValue();

    const size = S.stringValue().length;

    if (position < 0 || position >= size) {
      return new Value('');
    }

    return new Value(S.stringValue()[position]);
  } // 21.1.3.2 #sec-string.prototype.charcodeat


  function StringProto_charCodeAt([pos = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let _hygienicTemp2 = ToInteger(pos);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const position = _hygienicTemp2.numberValue();

    const size = S.stringValue().length;

    if (position < 0 || position >= size) {
      return new Value(NaN);
    }

    return new Value(S.stringValue().charCodeAt(position));
  } // 21.1.3.3 #sec-string.prototype.codepointat


  function StringProto_codePointAt([pos = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let _hygienicTemp3 = ToInteger(pos);

    if (_hygienicTemp3 instanceof AbruptCompletion) {
      return _hygienicTemp3;
    }

    if (_hygienicTemp3 instanceof Completion) {
      _hygienicTemp3 = _hygienicTemp3.Value;
    }

    const position = _hygienicTemp3.numberValue();

    const size = S.stringValue().length;

    if (position < 0 || position >= size) {
      return Value.undefined;
    }

    let cp = CodePointAt(S, position);
    Assert(!(cp instanceof AbruptCompletion), "");

    if (cp instanceof Completion) {
      cp = cp.Value;
    }

    return cp.CodePoint;
  } // 21.1.3.4 #sec-string.prototype.concat


  function StringProto_concat(args, {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let R = S.stringValue();

    while (args.length > 0) {
      const next = args.shift();
      let nextString = ToString(next);

      if (nextString instanceof AbruptCompletion) {
        return nextString;
      }

      if (nextString instanceof Completion) {
        nextString = nextString.Value;
      }

      R = `${R}${nextString.stringValue()}`;
    }

    return new Value(R);
  } // 21.1.3.6 #sec-string.prototype.endswith


  function StringProto_endsWith([searchString = Value.undefined, endPosition = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp4 = ToString(O);

    if (_hygienicTemp4 instanceof AbruptCompletion) {
      return _hygienicTemp4;
    }

    if (_hygienicTemp4 instanceof Completion) {
      _hygienicTemp4 = _hygienicTemp4.Value;
    }

    const S = _hygienicTemp4.stringValue();

    let isRegExp = IsRegExp(searchString);

    if (isRegExp instanceof AbruptCompletion) {
      return isRegExp;
    }

    if (isRegExp instanceof Completion) {
      isRegExp = isRegExp.Value;
    }

    if (isRegExp === Value.true) {
      return surroundingAgent.Throw('TypeError', msg('RegExpArgumentNotAllowed', 'String.prototype.endsWith'));
    }

    let _hygienicTemp5 = ToString(searchString);

    if (_hygienicTemp5 instanceof AbruptCompletion) {
      return _hygienicTemp5;
    }

    if (_hygienicTemp5 instanceof Completion) {
      _hygienicTemp5 = _hygienicTemp5.Value;
    }

    const searchStr = _hygienicTemp5.stringValue();

    const len = S.length;

    let _hygienicTemp6 = ToInteger(endPosition);

    if (_hygienicTemp6 instanceof AbruptCompletion) {
      return _hygienicTemp6;
    }

    if (_hygienicTemp6 instanceof Completion) {
      _hygienicTemp6 = _hygienicTemp6.Value;
    }

    const pos = endPosition === Value.undefined ? len : _hygienicTemp6.numberValue();
    const end = Math.min(Math.max(pos, 0), len);
    const searchLength = searchStr.length;
    const start = end - searchLength;

    if (start < 0) {
      return Value.false;
    }

    for (let i = 0; i < searchLength; i += 1) {
      if (S.charCodeAt(start + i) !== searchStr.charCodeAt(i)) {
        return Value.false;
      }
    }

    return Value.true;
  } // 21.1.3.7 #sec-string.prototype.includes


  function StringProto_includes([searchString = Value.undefined, position = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp7 = ToString(O);

    if (_hygienicTemp7 instanceof AbruptCompletion) {
      return _hygienicTemp7;
    }

    if (_hygienicTemp7 instanceof Completion) {
      _hygienicTemp7 = _hygienicTemp7.Value;
    }

    const S = _hygienicTemp7.stringValue();

    let isRegExp = IsRegExp(searchString);

    if (isRegExp instanceof AbruptCompletion) {
      return isRegExp;
    }

    if (isRegExp instanceof Completion) {
      isRegExp = isRegExp.Value;
    }

    if (isRegExp === Value.true) {
      return surroundingAgent.Throw('TypeError', msg('RegExpArgumentNotAllowed', 'String.prototype.includes'));
    }

    let _hygienicTemp8 = ToString(searchString);

    if (_hygienicTemp8 instanceof AbruptCompletion) {
      return _hygienicTemp8;
    }

    if (_hygienicTemp8 instanceof Completion) {
      _hygienicTemp8 = _hygienicTemp8.Value;
    }

    const searchStr = _hygienicTemp8.stringValue();

    let pos = ToInteger(position);

    if (pos instanceof AbruptCompletion) {
      return pos;
    }

    if (pos instanceof Completion) {
      pos = pos.Value;
    }

    Assert(!(position === Value.undefined) || pos.numberValue() === 0, "!(position === Value.undefined) || pos.numberValue() === 0");
    const len = S.length;
    const start = Math.min(Math.max(pos.numberValue(), 0), len);
    const searchLen = searchStr.length;
    let k = start;

    while (k + searchLen <= len) {
      let match = true;

      for (let j = 0; j < searchLen; j += 1) {
        if (searchStr[j] !== S[k + j]) {
          match = false;
          break;
        }
      }

      if (match) {
        return Value.true;
      }

      k += 1;
    }

    return Value.false;
  } // 21.1.3.8 #sec-string.prototype.indexof


  function StringProto_indexOf([searchString = Value.undefined, position = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp9 = ToString(O);

    if (_hygienicTemp9 instanceof AbruptCompletion) {
      return _hygienicTemp9;
    }

    if (_hygienicTemp9 instanceof Completion) {
      _hygienicTemp9 = _hygienicTemp9.Value;
    }

    const S = _hygienicTemp9.stringValue();

    let _hygienicTemp10 = ToString(searchString);

    if (_hygienicTemp10 instanceof AbruptCompletion) {
      return _hygienicTemp10;
    }

    if (_hygienicTemp10 instanceof Completion) {
      _hygienicTemp10 = _hygienicTemp10.Value;
    }

    const searchStr = _hygienicTemp10.stringValue();

    let pos = ToInteger(position);

    if (pos instanceof AbruptCompletion) {
      return pos;
    }

    if (pos instanceof Completion) {
      pos = pos.Value;
    }

    Assert(!(position === Value.undefined) || pos.numberValue() === 0, "!(position === Value.undefined) || pos.numberValue() === 0");
    const len = S.length;
    const start = Math.min(Math.max(pos.numberValue(), 0), len);
    const searchLen = searchStr.length;
    let k = start;

    while (k + searchLen <= len) {
      let match = true;

      for (let j = 0; j < searchLen; j += 1) {
        if (searchStr[j] !== S[k + j]) {
          match = false;
          break;
        }
      }

      if (match) {
        return new Value(k);
      }

      k += 1;
    }

    return new Value(-1);
  } // 21.1.3.9 #sec-string.prototype.lastindexof


  function StringProto_lastIndexOf([searchString = Value.undefined, position = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp11 = ToString(O);

    if (_hygienicTemp11 instanceof AbruptCompletion) {
      return _hygienicTemp11;
    }

    if (_hygienicTemp11 instanceof Completion) {
      _hygienicTemp11 = _hygienicTemp11.Value;
    }

    const S = _hygienicTemp11.stringValue();

    let _hygienicTemp12 = ToString(searchString);

    if (_hygienicTemp12 instanceof AbruptCompletion) {
      return _hygienicTemp12;
    }

    if (_hygienicTemp12 instanceof Completion) {
      _hygienicTemp12 = _hygienicTemp12.Value;
    }

    const searchStr = _hygienicTemp12.stringValue();

    let numPos = ToNumber(position);

    if (numPos instanceof AbruptCompletion) {
      return numPos;
    }

    if (numPos instanceof Completion) {
      numPos = numPos.Value;
    }

    Assert(!(position === Value.undefined) || numPos.isNaN(), "!(position === Value.undefined) || numPos.isNaN()");
    let pos;

    if (numPos.isNaN()) {
      pos = new Value(Infinity);
    } else {
      pos = ToInteger(numPos);
      Assert(!(pos instanceof AbruptCompletion), "");

      if (pos instanceof Completion) {
        pos = pos.Value;
      }
    }

    const len = S.length;
    const start = Math.min(Math.max(pos.numberValue(), 0), len);
    const searchLen = searchStr.length;
    let k = start;

    while (k >= 0) {
      if (k + searchLen <= len) {
        let match = true;

        for (let j = 0; j < searchLen; j += 1) {
          if (searchStr[j] !== S[k + j]) {
            match = false;
            break;
          }
        }

        if (match) {
          return new Value(k);
        }
      }

      k -= 1;
    }

    return new Value(-1);
  } // 21.1.3.10 #sec-string.prototype.localecompare


  function StringProto_localeCompare([that = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp13 = ToString(O);

    if (_hygienicTemp13 instanceof AbruptCompletion) {
      return _hygienicTemp13;
    }

    if (_hygienicTemp13 instanceof Completion) {
      _hygienicTemp13 = _hygienicTemp13.Value;
    }

    const S = _hygienicTemp13.stringValue();

    let _hygienicTemp14 = ToString(that);

    if (_hygienicTemp14 instanceof AbruptCompletion) {
      return _hygienicTemp14;
    }

    if (_hygienicTemp14 instanceof Completion) {
      _hygienicTemp14 = _hygienicTemp14.Value;
    }

    const That = _hygienicTemp14.stringValue();

    if (S === That) {
      return new Value(0);
    } else if (S < That) {
      return new Value(-1);
    } else {
      return new Value(1);
    }
  } // 21.1.3.11 #sec-string.prototype.match


  function StringProto_match([regexp = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    if (regexp !== Value.undefined && regexp !== Value.null) {
      let matcher = GetMethod(regexp, wellKnownSymbols.match);

      if (matcher instanceof AbruptCompletion) {
        return matcher;
      }

      if (matcher instanceof Completion) {
        matcher = matcher.Value;
      }

      if (matcher !== Value.undefined) {
        return Call(matcher, regexp, [O]);
      }
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let rx = RegExpCreate(regexp, Value.undefined);

    if (rx instanceof AbruptCompletion) {
      return rx;
    }

    if (rx instanceof Completion) {
      rx = rx.Value;
    }

    return Invoke(rx, wellKnownSymbols.match, [S]);
  } // 21.1.3.12 #sec-string.prototype.matchall


  function StringProto_matchAll([regexp = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    if (regexp !== Value.undefined && regexp !== Value.null) {
      let matcher = GetMethod(regexp, wellKnownSymbols.matchAll);

      if (matcher instanceof AbruptCompletion) {
        return matcher;
      }

      if (matcher instanceof Completion) {
        matcher = matcher.Value;
      }

      if (matcher !== Value.undefined) {
        return Call(matcher, regexp, [O]);
      }
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let rx = RegExpCreate(regexp, new Value('g'));

    if (rx instanceof AbruptCompletion) {
      return rx;
    }

    if (rx instanceof Completion) {
      rx = rx.Value;
    }

    return Invoke(rx, wellKnownSymbols.matchAll, [S]);
  } // 21.1.3.13 #sec-string.prototype.normalize


  function StringProto_normalize([form], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    if (form === undefined || form === Value.undefined) {
      form = new Value('NFC');
    }

    let _hygienicTemp15 = ToString(form);

    if (_hygienicTemp15 instanceof AbruptCompletion) {
      return _hygienicTemp15;
    }

    if (_hygienicTemp15 instanceof Completion) {
      _hygienicTemp15 = _hygienicTemp15.Value;
    }

    const f = _hygienicTemp15.stringValue();

    if (!['NFC', 'NFD', 'NFKC', 'NFKD'].includes(f)) {
      return surroundingAgent.Throw('RangeError');
    }

    const ns = S.stringValue().normalize(f);
    return new Value(ns);
  } // 21.1.3.14 #sec-string.prototype.padend


  function StringProto_padEnd([maxLength = Value.undefined, fillString = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    return StringPad(O, maxLength, fillString, 'end');
  } // 21.1.3.15 #sec-string.prototype.padstart


  function StringProto_padStart([maxLength = Value.undefined, fillString = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    return StringPad(O, maxLength, fillString, 'start');
  } // 21.1.3.16 #sec-string.prototype.repeat


  function StringProto_repeat([count = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let n = ToInteger(count);

    if (n instanceof AbruptCompletion) {
      return n;
    }

    if (n instanceof Completion) {
      n = n.Value;
    }

    if (n.numberValue() < 0) {
      return surroundingAgent.Throw('RangeError', msg('StringRepeatCount', n));
    }

    if (n.isInfinity()) {
      return surroundingAgent.Throw('RangeError', msg('StringRepeatCount', n));
    }

    if (n.numberValue() === 0) {
      return new Value('');
    }

    let T = '';

    for (let i = 0; i < n.numberValue(); i += 1) {
      T += S.stringValue();
    }

    return new Value(T);
  } // 21.1.3.17 #sec-string.prototype.replace


  function StringProto_replace([searchValue = Value.undefined, replaceValue = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    if (searchValue !== Value.undefined && searchValue !== Value.null) {
      let replacer = GetMethod(searchValue, wellKnownSymbols.replace);

      if (replacer instanceof AbruptCompletion) {
        return replacer;
      }

      if (replacer instanceof Completion) {
        replacer = replacer.Value;
      }

      if (replacer !== Value.undefined) {
        return Call(replacer, searchValue, [O, replaceValue]);
      }
    }

    let string = ToString(O);

    if (string instanceof AbruptCompletion) {
      return string;
    }

    if (string instanceof Completion) {
      string = string.Value;
    }

    let searchString = ToString(searchValue);

    if (searchString instanceof AbruptCompletion) {
      return searchString;
    }

    if (searchString instanceof Completion) {
      searchString = searchString.Value;
    }

    const functionalReplace = IsCallable(replaceValue);

    if (functionalReplace === Value.false) {
      replaceValue = ToString(replaceValue);

      if (replaceValue instanceof AbruptCompletion) {
        return replaceValue;
      }

      if (replaceValue instanceof Completion) {
        replaceValue = replaceValue.Value;
      }
    }

    const pos = new Value(string.stringValue().indexOf(searchString.stringValue()));
    const matched = searchString;

    if (pos.numberValue() === -1) {
      return string;
    }

    let replStr;

    if (functionalReplace === Value.true) {
      let replValue = Call(replaceValue, Value.undefined, [matched, pos, string]);

      if (replValue instanceof AbruptCompletion) {
        return replValue;
      }

      if (replValue instanceof Completion) {
        replValue = replValue.Value;
      }

      replStr = ToString(replValue);

      if (replStr instanceof AbruptCompletion) {
        return replStr;
      }

      if (replStr instanceof Completion) {
        replStr = replStr.Value;
      }
    } else {
      const captures = [];
      replStr = GetSubstitution(matched, string, pos, captures, Value.undefined, replaceValue);
    }

    const tailPos = pos.numberValue() + matched.stringValue().length;
    const newString = string.stringValue().slice(0, pos.numberValue()) + replStr.stringValue() + string.stringValue().slice(tailPos);
    return new Value(newString);
  } // 21.1.3.19 #sec-string.prototype.slice


  function StringProto_search([regexp = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    if (regexp !== Value.undefined && regexp !== Value.null) {
      let searcher = GetMethod(regexp, wellKnownSymbols.search);

      if (searcher instanceof AbruptCompletion) {
        return searcher;
      }

      if (searcher instanceof Completion) {
        searcher = searcher.Value;
      }

      if (searcher !== Value.undefined) {
        return Call(searcher, regexp, [O]);
      }
    }

    let string = ToString(O);

    if (string instanceof AbruptCompletion) {
      return string;
    }

    if (string instanceof Completion) {
      string = string.Value;
    }

    let rx = RegExpCreate(regexp, Value.undefined);

    if (rx instanceof AbruptCompletion) {
      return rx;
    }

    if (rx instanceof Completion) {
      rx = rx.Value;
    }

    return Invoke(rx, wellKnownSymbols.search, [string]);
  } // 21.1.3.19 #sec-string.prototype.slice


  function StringProto_slice([start = Value.undefined, end = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp16 = ToString(O);

    if (_hygienicTemp16 instanceof AbruptCompletion) {
      return _hygienicTemp16;
    }

    if (_hygienicTemp16 instanceof Completion) {
      _hygienicTemp16 = _hygienicTemp16.Value;
    }

    const S = _hygienicTemp16.stringValue();

    const len = S.length;

    let _hygienicTemp17 = ToInteger(start);

    if (_hygienicTemp17 instanceof AbruptCompletion) {
      return _hygienicTemp17;
    }

    if (_hygienicTemp17 instanceof Completion) {
      _hygienicTemp17 = _hygienicTemp17.Value;
    }

    const intStart = _hygienicTemp17.numberValue();

    let intEnd;

    if (end === Value.undefined) {
      intEnd = len;
    } else {
      let _hygienicTemp18 = ToInteger(end);

      if (_hygienicTemp18 instanceof AbruptCompletion) {
        return _hygienicTemp18;
      }

      if (_hygienicTemp18 instanceof Completion) {
        _hygienicTemp18 = _hygienicTemp18.Value;
      }

      intEnd = _hygienicTemp18.numberValue();
    }

    let from;

    if (intStart < 0) {
      from = Math.max(len + intStart, 0);
    } else {
      from = Math.min(intStart, len);
    }

    let to;

    if (intEnd < 0) {
      to = Math.max(len + intEnd, 0);
    } else {
      to = Math.min(intEnd, len);
    }

    const span = Math.max(to - from, 0);
    return new Value(S.slice(from, from + span));
  } // 21.1.3.20 #sec-string.prototype.split


  function StringProto_split([separator = Value.undefined, limit = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    if (separator !== Value.undefined && separator !== Value.null) {
      let splitter = GetMethod(separator, wellKnownSymbols.split);

      if (splitter instanceof AbruptCompletion) {
        return splitter;
      }

      if (splitter instanceof Completion) {
        splitter = splitter.Value;
      }

      if (splitter !== Value.undefined) {
        return Call(splitter, separator, [O, limit]);
      }
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    let A = ArrayCreate(new Value(0));
    Assert(!(A instanceof AbruptCompletion), "");

    if (A instanceof Completion) {
      A = A.Value;
    }

    let lengthA = 0;

    let _hygienicTemp19 = ToUint32(limit);

    if (_hygienicTemp19 instanceof AbruptCompletion) {
      return _hygienicTemp19;
    }

    if (_hygienicTemp19 instanceof Completion) {
      _hygienicTemp19 = _hygienicTemp19.Value;
    }

    const lim = limit === Value.undefined ? new Value(2 ** 32 - 1) : _hygienicTemp19;
    const s = S.stringValue().length;
    let p = 0;
    let R = ToString(separator);

    if (R instanceof AbruptCompletion) {
      return R;
    }

    if (R instanceof Completion) {
      R = R.Value;
    }

    if (lim.numberValue() === 0) {
      return A;
    }

    if (separator === Value.undefined) {
      Assert(!(CreateDataProperty(A, new Value('0'), S) instanceof AbruptCompletion), "");
      return A;
    }

    if (s === 0) {
      const z = SplitMatch(S, 0, R);

      if (z !== false) {
        return A;
      }

      Assert(!(CreateDataProperty(A, new Value('0'), S) instanceof AbruptCompletion), "");
      return A;
    }

    let q = p;

    while (q !== s) {
      const e = SplitMatch(S, q, R);

      if (e === false) {
        q += 1;
      } else {
        if (e === p) {
          q += 1;
        } else {
          const T = new Value(S.stringValue().substring(p, q));

          let _val = ToString(new Value(lengthA));

          Assert(!(_val instanceof AbruptCompletion), "");

          if (_val instanceof Completion) {
            _val = _val.Value;
          }

          Assert(!(CreateDataProperty(A, _val, T) instanceof AbruptCompletion), "");
          lengthA += 1;

          if (lengthA === lim.numberValue()) {
            return A;
          }

          p = e;
          q = p;
        }
      }
    }

    const T = new Value(S.stringValue().substring(p, s));

    let _val2 = ToString(new Value(lengthA));

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    Assert(!(CreateDataProperty(A, _val2, T) instanceof AbruptCompletion), "");
    return A;
  } // 21.1.3.20.1 #sec-splitmatch


  function SplitMatch(S, q, R) {
    Assert(Type(R) === 'String', "Type(R) === 'String'");
    const r = R.stringValue().length;
    const s = S.stringValue().length;

    if (q + r > s) {
      return false;
    }

    for (let i = 0; i < r; i += 1) {
      if (S.stringValue().charCodeAt(q + i) !== R.stringValue().charCodeAt(i)) {
        return false;
      }
    }

    return q + r;
  } // 21.1.3.21 #sec-string.prototype.startswith


  function StringProto_startsWith([searchString = Value.undefined, position = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp20 = ToString(O);

    if (_hygienicTemp20 instanceof AbruptCompletion) {
      return _hygienicTemp20;
    }

    if (_hygienicTemp20 instanceof Completion) {
      _hygienicTemp20 = _hygienicTemp20.Value;
    }

    const S = _hygienicTemp20.stringValue();

    let isRegExp = IsRegExp(searchString);

    if (isRegExp instanceof AbruptCompletion) {
      return isRegExp;
    }

    if (isRegExp instanceof Completion) {
      isRegExp = isRegExp.Value;
    }

    if (isRegExp === Value.true) {
      return surroundingAgent.Throw('TypeError', msg('RegExpArgumentNotAllowed', 'String.prototype.startsWith'));
    }

    let _hygienicTemp21 = ToString(searchString);

    if (_hygienicTemp21 instanceof AbruptCompletion) {
      return _hygienicTemp21;
    }

    if (_hygienicTemp21 instanceof Completion) {
      _hygienicTemp21 = _hygienicTemp21.Value;
    }

    const searchStr = _hygienicTemp21.stringValue();

    let _hygienicTemp22 = ToInteger(position);

    if (_hygienicTemp22 instanceof AbruptCompletion) {
      return _hygienicTemp22;
    }

    if (_hygienicTemp22 instanceof Completion) {
      _hygienicTemp22 = _hygienicTemp22.Value;
    }

    const pos = _hygienicTemp22.numberValue();

    Assert(!(position === Value.undefined) || pos === 0, "!(position === Value.undefined) || pos === 0");
    const len = S.length;
    const start = Math.min(Math.max(pos, 0), len);
    const searchLength = searchStr.length;

    if (searchLength + start > len) {
      return Value.false;
    }

    for (let i = 0; i < searchLength; i += 1) {
      if (S.charCodeAt(start + i) !== searchStr.charCodeAt(i)) {
        return Value.false;
      }
    }

    return Value.true;
  } // 21.1.3.22 #sec-string.prototype.substring


  function StringProto_substring([start = Value.undefined, end = Value.undefined], {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let _hygienicTemp23 = ToString(O);

    if (_hygienicTemp23 instanceof AbruptCompletion) {
      return _hygienicTemp23;
    }

    if (_hygienicTemp23 instanceof Completion) {
      _hygienicTemp23 = _hygienicTemp23.Value;
    }

    const S = _hygienicTemp23.stringValue();

    const len = S.length;

    let _hygienicTemp24 = ToInteger(start);

    if (_hygienicTemp24 instanceof AbruptCompletion) {
      return _hygienicTemp24;
    }

    if (_hygienicTemp24 instanceof Completion) {
      _hygienicTemp24 = _hygienicTemp24.Value;
    }

    const intStart = _hygienicTemp24.numberValue();

    let intEnd;

    if (end === Value.undefined) {
      intEnd = len;
    } else {
      let _hygienicTemp25 = ToInteger(end);

      if (_hygienicTemp25 instanceof AbruptCompletion) {
        return _hygienicTemp25;
      }

      if (_hygienicTemp25 instanceof Completion) {
        _hygienicTemp25 = _hygienicTemp25.Value;
      }

      intEnd = _hygienicTemp25.numberValue();
    }

    const finalStart = Math.min(Math.max(intStart, 0), len);
    const finalEnd = Math.min(Math.max(intEnd, 0), len);
    const from = Math.min(finalStart, finalEnd);
    const to = Math.max(finalStart, finalEnd);
    return new Value(S.slice(from, to));
  } // 21.1.3.23 #sec-string.prototype.tolocalelowercase


  function StringProto_toLocaleLowerCase(args, {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    const L = S.stringValue().toLocaleLowerCase();
    return new Value(L);
  } // 21.1.3.24 #sec-string.prototype.tolocaleuppercase


  function StringProto_toLocaleUpperCase(args, {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    const L = S.stringValue().toLocaleUpperCase();
    return new Value(L);
  } // 21.1.3.25 #sec-string.prototype.tolowercase


  function StringProto_toLowerCase(args, {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    const L = S.stringValue().toLowerCase();
    return new Value(L);
  } // 21.1.3.26 #sec-string.prototype.tostring


  function StringProto_toString(args, {
    thisValue
  }) {
    return thisStringValue(thisValue);
  } // 21.1.3.27 #sec-string.prototype.touppercase


  function StringProto_toUpperCase(args, {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    const L = S.stringValue().toUpperCase();
    return new Value(L);
  } // 21.1.3.28 #sec-string.prototype.trim


  function StringProto_trim(args, {
    thisValue
  }) {
    const S = thisValue;
    return TrimString(S, 'start+end');
  } // 21.1.3.29 #sec-string.prototype.trimend


  function StringProto_trimEnd(args, {
    thisValue
  }) {
    const S = thisValue;
    return TrimString(S, 'end');
  } // 21.1.3.30 #sec-string.prototype.trimstart


  function StringProto_trimStart(args, {
    thisValue
  }) {
    const S = thisValue;
    return TrimString(S, 'start');
  } // 21.1.3.31 #sec-string.prototype.valueof


  function StringProto_valueOf(args, {
    thisValue
  }) {
    return thisStringValue(thisValue);
  } // 21.1.3.32 #sec-string.prototype-@@iterator


  function StringProto_iterator(args, {
    thisValue
  }) {
    let O = RequireObjectCoercible(thisValue);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    let S = ToString(O);

    if (S instanceof AbruptCompletion) {
      return S;
    }

    if (S instanceof Completion) {
      S = S.Value;
    }

    return CreateStringIterator(S);
  }

  function CreateStringPrototype(realmRec) {
    const proto = new StringExoticObjectValue();
    proto.Prototype = realmRec.Intrinsics['%ObjectPrototype%'];
    proto.Extensible = Value.true;
    proto.StringData = new Value('');
    proto.properties.set(new Value('length'), Descriptor({
      Value: new Value(0),
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    assignProps(realmRec, proto, [['charAt', StringProto_charAt, 1], ['charCodeAt', StringProto_charCodeAt, 1], ['codePointAt', StringProto_codePointAt, 1], ['concat', StringProto_concat, 1], ['endsWith', StringProto_endsWith, 1], ['includes', StringProto_includes, 1], ['indexOf', StringProto_indexOf, 1], ['lastIndexOf', StringProto_lastIndexOf, 1], ['localeCompare', StringProto_localeCompare, 1], ['match', StringProto_match, 1], ['matchAll', StringProto_matchAll, 1], ['normalize', StringProto_normalize, 0], ['padEnd', StringProto_padEnd, 1], ['padStart', StringProto_padStart, 1], ['repeat', StringProto_repeat, 1], ['replace', StringProto_replace, 2], ['search', StringProto_search, 1], ['slice', StringProto_slice, 2], ['split', StringProto_split, 2], ['startsWith', StringProto_startsWith, 1], ['substring', StringProto_substring, 2], ['toLocaleLowerCase', StringProto_toLocaleLowerCase, 0], ['toLocaleUpperCase', StringProto_toLocaleUpperCase, 0], ['toLowerCase', StringProto_toLowerCase, 0], ['toString', StringProto_toString, 0], ['toUpperCase', StringProto_toUpperCase, 0], ['trim', StringProto_trim, 0], ['trimEnd', StringProto_trimEnd, 0], ['trimStart', StringProto_trimStart, 0], ['valueOf', StringProto_valueOf, 0], [wellKnownSymbols.iterator, StringProto_iterator, 0]]);
    realmRec.Intrinsics['%StringPrototype%'] = proto;
  }

  function StringConstructor(args, {
    NewTarget
  }) {
    let s;

    if (args.length === 0) {
      // String ( )
      s = new Value('');
    } else {
      // String ( value )
      const [value] = args;

      if (NewTarget === Value.undefined && Type(value) === 'Symbol') {
        let _val = SymbolDescriptiveString(value);

        Assert(!(_val instanceof AbruptCompletion), "");

        if (_val instanceof Completion) {
          _val = _val.Value;
        }

        return _val;
      }

      s = ToString(value);

      if (s instanceof AbruptCompletion) {
        return s;
      }

      if (s instanceof Completion) {
        s = s.Value;
      }
    }

    if (NewTarget === Value.undefined) {
      return s;
    }

    let _hygienicTemp = GetPrototypeFromConstructor(NewTarget, '%StringPrototype%');

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    let _val2 = StringCreate(s, _hygienicTemp);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    return _val2;
  } // 21.1.2.1 #sec-string.fromcharcode


  function String_fromCharCode(codeUnits) {
    const length = codeUnits.length;
    const elements = [];
    let nextIndex = 0;

    while (nextIndex < length) {
      const next = codeUnits[nextIndex];
      let nextCU = ToUint16(next);

      if (nextCU instanceof AbruptCompletion) {
        return nextCU;
      }

      if (nextCU instanceof Completion) {
        nextCU = nextCU.Value;
      }

      elements.push(nextCU);
      nextIndex += 1;
    }

    const result = elements.reduce((previous, current) => previous + String.fromCharCode(current.numberValue()), '');
    return new Value(result);
  } // 21.1.2.2 #sec-string.fromcodepoint


  function String_fromCodePoint(codePoints) {
    const length = codePoints.length;
    const elements = [];
    let nextIndex = 0;

    while (nextIndex < length) {
      const next = codePoints[nextIndex];
      let nextCP = ToNumber(next);

      if (nextCP instanceof AbruptCompletion) {
        return nextCP;
      }

      if (nextCP instanceof Completion) {
        nextCP = nextCP.Value;
      }

      let _val3 = IsInteger(nextCP);

      Assert(!(_val3 instanceof AbruptCompletion), "");

      if (_val3 instanceof Completion) {
        _val3 = _val3.Value;
      }

      if (_val3 === Value.false) {
        return surroundingAgent.Throw('RangeError');
      }

      if (nextCP.numberValue() < 0 || nextCP.numberValue() > 0x10FFFF) {
        return surroundingAgent.Throw('RangeError');
      }

      elements.push(...UTF16Encoding(nextCP.numberValue()));
      nextIndex += 1;
    }

    const result = elements.reduce((previous, current) => previous + String.fromCharCode(current), '');
    return new Value(result);
  } // 21.1.2.4 #sec-string.raw


  function String_raw([template = Value.undefined, ...substitutions]) {
    const numberOfSubstitutions = substitutions.length;
    let cooked = ToObject(template);

    if (cooked instanceof AbruptCompletion) {
      return cooked;
    }

    if (cooked instanceof Completion) {
      cooked = cooked.Value;
    }

    let rawProp = Get(cooked, new Value('raw'));

    if (rawProp instanceof AbruptCompletion) {
      return rawProp;
    }

    if (rawProp instanceof Completion) {
      rawProp = rawProp.Value;
    }

    let raw = ToObject(rawProp);

    if (raw instanceof AbruptCompletion) {
      return raw;
    }

    if (raw instanceof Completion) {
      raw = raw.Value;
    }

    let _hygienicTemp2 = LengthOfArrayLike(raw);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const literalSegments = _hygienicTemp2.numberValue();

    if (literalSegments <= 0) {
      return new Value('');
    } // Not sure why the spec uses a List, but this is really just a String.


    const stringElements = [];
    let nextIndex = 0;

    while (true) {
      let nextKey = ToString(new Value(nextIndex));
      Assert(!(nextKey instanceof AbruptCompletion), "");

      if (nextKey instanceof Completion) {
        nextKey = nextKey.Value;
      }

      let nextSegProp = Get(raw, nextKey);

      if (nextSegProp instanceof AbruptCompletion) {
        return nextSegProp;
      }

      if (nextSegProp instanceof Completion) {
        nextSegProp = nextSegProp.Value;
      }

      let nextSeg = ToString(nextSegProp);

      if (nextSeg instanceof AbruptCompletion) {
        return nextSeg;
      }

      if (nextSeg instanceof Completion) {
        nextSeg = nextSeg.Value;
      }

      stringElements.push(nextSeg.stringValue());

      if (nextIndex + 1 === literalSegments) {
        return new Value(stringElements.join(''));
      }

      let next;

      if (nextIndex < numberOfSubstitutions) {
        next = substitutions[nextIndex];
      } else {
        next = new Value('');
      }

      let nextSub = ToString(next);

      if (nextSub instanceof AbruptCompletion) {
        return nextSub;
      }

      if (nextSub instanceof Completion) {
        nextSub = nextSub.Value;
      }

      stringElements.push(nextSub.stringValue());
      nextIndex += 1;
    }
  }

  function CreateString(realmRec) {
    const stringConstructor = BootstrapConstructor(realmRec, StringConstructor, 'String', 1, realmRec.Intrinsics['%StringPrototype%'], [['fromCharCode', String_fromCharCode, 1], ['fromCodePoint', String_fromCodePoint, 1], ['raw', String_raw, 1]]);
    realmRec.Intrinsics['%String%'] = stringConstructor;
  }

  function ErrorProto_toString(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError');
    }

    let name = Get(O, new Value('name'));

    if (name instanceof AbruptCompletion) {
      return name;
    }

    if (name instanceof Completion) {
      name = name.Value;
    }

    if (Type(name) === 'Undefined') {
      name = new Value('Error');
    } else {
      name = ToString(name);

      if (name instanceof AbruptCompletion) {
        return name;
      }

      if (name instanceof Completion) {
        name = name.Value;
      }
    }

    let msg = Get(O, new Value('message'));

    if (msg instanceof AbruptCompletion) {
      return msg;
    }

    if (msg instanceof Completion) {
      msg = msg.Value;
    }

    if (Type(msg) === 'Undefined') {
      msg = new Value('');
    } else {
      msg = ToString(msg);

      if (msg instanceof AbruptCompletion) {
        return msg;
      }

      if (msg instanceof Completion) {
        msg = msg.Value;
      }
    }

    if (name.stringValue() === '') {
      return msg;
    }

    if (msg.stringValue() === '') {
      return name;
    }

    return new Value(`${name.stringValue()}: ${msg.stringValue()}`);
  }

  function CreateErrorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['toString', ErrorProto_toString, 0], ['message', new Value('')], ['name', new Value('Error')]], realmRec.Intrinsics['%ObjectPrototype%']);
    realmRec.Intrinsics['%ErrorPrototype%'] = proto;
  }

  function ErrorConstructor([message = Value.undefined], {
    NewTarget
  }) {
    let newTarget;

    if (Type(NewTarget) === 'Undefined') {
      newTarget = surroundingAgent.activeFunctionObject;
    } else {
      newTarget = NewTarget;
    }

    let O = OrdinaryCreateFromConstructor(newTarget, '%ErrorPrototype%', ['ErrorData']);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    if (Type(message) !== 'Undefined') {
      let msg = ToString(message);

      if (msg instanceof AbruptCompletion) {
        return msg;
      }

      if (msg instanceof Completion) {
        msg = msg.Value;
      }

      const msgDesc = Descriptor({
        Value: msg,
        Writable: Value.true,
        Enumerable: Value.false,
        Configurable: Value.true
      });
      Assert(!(DefinePropertyOrThrow(O, new Value('message'), msgDesc) instanceof AbruptCompletion), "");
    }

    Assert(!(captureStack(O) instanceof AbruptCompletion), ""); // non-spec

    return O;
  }

  function CreateError(realmRec) {
    const error = BootstrapConstructor(realmRec, ErrorConstructor, 'Error', 1, realmRec.Intrinsics['%ErrorPrototype%'], []);
    realmRec.Intrinsics['%Error%'] = error;
  }

  function CreateNativeError(realmRec) {
    for (const name of ['EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError']) {
      const proto = BootstrapPrototype(realmRec, [['name', new Value(name)], ['message', new Value('')]], realmRec.Intrinsics['%ErrorPrototype%']);

      const Constructor = ([message = Value.undefined], {
        NewTarget
      }) => {
        let newTarget;

        if (Type(NewTarget) === 'Undefined') {
          newTarget = surroundingAgent.activeFunctionObject;
        } else {
          newTarget = NewTarget;
        }

        let O = OrdinaryCreateFromConstructor(newTarget, `%${name}Prototype%`, ['ErrorData']);

        if (O instanceof AbruptCompletion) {
          return O;
        }

        if (O instanceof Completion) {
          O = O.Value;
        }

        if (Type(message) !== 'Undefined') {
          let msg = ToString(message);

          if (msg instanceof AbruptCompletion) {
            return msg;
          }

          if (msg instanceof Completion) {
            msg = msg.Value;
          }

          const msgDesc = Descriptor({
            Value: msg,
            Writable: Value.true,
            Enumerable: Value.false,
            Configurable: Value.true
          });
          Assert(!(DefinePropertyOrThrow(O, new Value('message'), msgDesc) instanceof AbruptCompletion), "");
        }

        Assert(!(captureStack(O) instanceof AbruptCompletion), ""); // non-spec

        return O;
      };

      Object.defineProperty(Constructor, 'name', {
        value: `${name}Constructor`,
        configurable: true
      });
      const cons = BootstrapConstructor(realmRec, Constructor, name, 1, proto, []);
      cons.Prototype = realmRec.Intrinsics['%Error%'];
      realmRec.Intrinsics[`%${name}Prototype%`] = proto;
      realmRec.Intrinsics[`%${name}%`] = cons;
    }
  }

  function IteratorPrototype_iterator(args, {
    thisValue
  }) {
    return thisValue;
  }

  function CreateIteratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [[wellKnownSymbols.iterator, IteratorPrototype_iterator, 0]], realmRec.Intrinsics['%ObjectPrototype%']);
    realmRec.Intrinsics['%IteratorPrototype%'] = proto;
  }

  function AsyncIteratorPrototype_asyncIterator(args, {
    thisValue
  }) {
    return thisValue;
  }

  function CreateAsyncIteratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [[wellKnownSymbols.asyncIterator, AsyncIteratorPrototype_asyncIterator, 0]], realmRec.Intrinsics['%ObjectPrototype%']);
    realmRec.Intrinsics['%AsyncIteratorPrototype%'] = proto;
  }

  function ArrayIteratorPrototype_next(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotAnTypeObject', 'Array Iterator', O));
    }

    if (!('IteratedObject' in O) || !('ArrayIteratorNextIndex' in O) || !('ArrayIterationKind' in O)) {
      return surroundingAgent.Throw('TypeError', msg('NotAnTypeObject', 'Array Iterator', O));
    }

    const a = O.IteratedObject;

    if (Type(a) === 'Undefined') {
      return CreateIterResultObject(Value.undefined, Value.true);
    }

    const index = O.ArrayIteratorNextIndex;
    const itemKind = O.ArrayIterationKind;
    let len;

    if ('TypedArrayName' in a) {
      if (IsDetachedBuffer(a.ViewedArrayBuffer)) {
        return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
      }

      len = a.ArrayLength;
    } else {
      len = LengthOfArrayLike(a);

      if (len instanceof AbruptCompletion) {
        return len;
      }

      if (len instanceof Completion) {
        len = len.Value;
      }
    }

    if (index >= len.numberValue()) {
      O.IteratedObject = Value.undefined;
      return CreateIterResultObject(Value.undefined, Value.true);
    }

    O.ArrayIteratorNextIndex = index + 1;

    if (itemKind === 'key') {
      return CreateIterResultObject(new Value(index), Value.false);
    }

    let elementKey = ToString(new Value(index));
    Assert(!(elementKey instanceof AbruptCompletion), "");

    if (elementKey instanceof Completion) {
      elementKey = elementKey.Value;
    }

    let elementValue = Get(a, elementKey);

    if (elementValue instanceof AbruptCompletion) {
      return elementValue;
    }

    if (elementValue instanceof Completion) {
      elementValue = elementValue.Value;
    }

    let result;

    if (itemKind === 'value') {
      result = elementValue;
    } else {
      Assert(itemKind === 'key+value', "itemKind === 'key+value'");
      result = CreateArrayFromList([new Value(index), elementValue]);
      Assert(!(result instanceof AbruptCompletion), "");

      if (result instanceof Completion) {
        result = result.Value;
      }
    }

    return CreateIterResultObject(result, Value.false);
  }

  function CreateArrayIteratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['next', ArrayIteratorPrototype_next, 0]], realmRec.Intrinsics['%IteratorPrototype%'], 'Array Iterator');
    realmRec.Intrinsics['%ArrayIteratorPrototype%'] = proto;
  }

  function MapIteratorPrototype_next(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Map Iterator', O));
    }

    if (!('Map' in O && 'MapNextIndex' in O && 'MapIterationKind' in O)) {
      return surroundingAgent.Throw('TypeError', msg('NotATypeObject', 'Map Iterator', O));
    }

    const m = O.Map;
    let index = O.MapNextIndex;
    const itemKind = O.MapIterationKind;

    if (m === Value.undefined) {
      return CreateIterResultObject(Value.undefined, Value.true);
    }

    Assert('MapData' in m, "'MapData' in m");
    const entries = m.MapData;
    const numEntries = entries.length;

    while (index < numEntries) {
      const e = entries[index];
      index += 1;
      O.MapNextIndex = index;

      if (e.Key !== undefined) {
        let result;

        if (itemKind === 'key') {
          result = e.Key;
        } else if (itemKind === 'value') {
          result = e.Value;
        } else {
          Assert(itemKind === 'key+value', "itemKind === 'key+value'");
          result = CreateArrayFromList([e.Key, e.Value]);
          Assert(!(result instanceof AbruptCompletion), "");

          if (result instanceof Completion) {
            result = result.Value;
          }
        }

        return CreateIterResultObject(result, Value.false);
      }
    }

    O.Map = Value.undefined;
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  function CreateMapIteratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['next', MapIteratorPrototype_next, 0]], realmRec.Intrinsics['%IteratorPrototype%'], 'Map Iterator');
    realmRec.Intrinsics['%MapIteratorPrototype%'] = proto;
  }

  function SetIteratorPrototype_next(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object') {
      return surroundingAgent.Throw('TypeError');
    }

    if (!('IteratedSet' in O && 'SetNextIndex' in O && 'SetIterationKind' in O)) {
      return surroundingAgent.Throw('TypeError');
    }

    const s = O.IteratedSet;
    let index = O.SetNextIndex;
    const itemKind = O.SetIterationKind;

    if (Type(s) === 'Undefined') {
      return CreateIterResultObject(Value.undefined, Value.true);
    }

    Assert('SetData' in s, "'SetData' in s");
    const entries = s.SetData;
    const numEntries = entries.length;

    while (index < numEntries) {
      const e = entries[index];
      index += 1;
      O.SetNextIndex = index;

      if (e !== undefined) {
        if (itemKind === 'key+value') {
          return CreateIterResultObject(CreateArrayFromList([e, e]), Value.false);
        }

        return CreateIterResultObject(e, Value.false);
      }
    }

    O.IteratedSet = Value.undefined;
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  function CreateSetIteratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['next', SetIteratorPrototype_next, 0]], realmRec.Intrinsics['%IteratorPrototype%'], 'Set Iterator');
    realmRec.Intrinsics['%SetIteratorPrototype%'] = proto;
  }

  function CreateMapIterator(map, kind) {
    {
      const hygienicTemp = RequireInternalSlot(map, 'MapData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const iterator = ObjectCreate(surroundingAgent.intrinsic('%MapIteratorPrototype%'), ['Map', 'MapNextIndex', 'MapIterationKind']);
    iterator.Map = map;
    iterator.MapNextIndex = 0;
    iterator.MapIterationKind = kind;
    return iterator;
  }

  function MapProto_clear(args, {
    thisValue
  }) {
    const M = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(M, 'MapData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = M.MapData;

    for (const p of entries) {
      p.Key = undefined;
      p.Value = undefined;
    }

    return Value.undefined;
  }

  function MapProto_delete([key = Value.undefined], {
    thisValue
  }) {
    const M = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(M, 'MapData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = M.MapData;

    for (let i = 0; i < entries.length; i += 1) {
      const p = entries[i];

      if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
        p.Key = undefined;
        p.Value = undefined; // The value empty is used as a specification device to indicate that an
        // entry has been deleted. Actual implementations may take other actions
        // such as physically removing the entry from internal data structures.
        // entries.splice(i, 1);

        return Value.true;
      }
    }

    return Value.false;
  }

  function MapProto_entries(args, {
    thisValue
  }) {
    const M = thisValue;
    return CreateMapIterator(M, 'key+value');
  }

  function MapProto_forEach([callbackfn, thisArg], {
    thisValue
  }) {
    const M = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(M, 'MapData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', callbackfn));
    }

    let T;

    if (thisArg !== undefined) {
      T = thisArg;
    } else {
      T = Value.undefined;
    }

    const entries = M.MapData;

    for (const e of entries) {
      if (e.Key !== undefined) {
        {
          const hygienicTemp = Call(callbackfn, T, [e.Value, e.Key, M]);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }
    }

    return Value.undefined;
  }

  function MapProto_get([key = Value.undefined], {
    thisValue
  }) {
    const M = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(M, 'MapData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = M.MapData;

    for (const p of entries) {
      if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
        return p.Value;
      }
    }

    return Value.undefined;
  }

  function MapProto_has([key = Value.undefined], {
    thisValue
  }) {
    const M = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(M, 'MapData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = M.MapData;

    for (const p of entries) {
      if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
        return Value.true;
      }
    }

    return Value.false;
  }

  function MapProto_keys(args, {
    thisValue
  }) {
    const M = thisValue;
    return CreateMapIterator(M, 'key');
  }

  function MapProto_set([key = Value.undefined, value = Value.undefined], {
    thisValue
  }) {
    const M = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(M, 'MapData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = M.MapData;

    for (const p of entries) {
      if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
        p.Value = value;
        return M;
      }
    }

    if (Type(key) === 'Number' && Object.is(key.numberValue(), -0)) {
      key = new Value(0);
    }

    const p = {
      Key: key,
      Value: value
    };
    entries.push(p);
    return M;
  }

  function MapProto_sizeGetter(args, {
    thisValue
  }) {
    const M = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(M, 'MapData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = M.MapData;
    let count = 0;

    for (const p of entries) {
      if (p.Key !== undefined) {
        count += 1;
      }
    }

    return new Value(count);
  }

  function MapProto_values(args, {
    thisValue
  }) {
    const M = thisValue;
    return CreateMapIterator(M, 'value');
  }

  function CreateMapPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['clear', MapProto_clear, 0], ['delete', MapProto_delete, 1], ['entries', MapProto_entries, 0], ['forEach', MapProto_forEach, 1], ['get', MapProto_get, 1], ['has', MapProto_has, 1], ['keys', MapProto_keys, 0], ['set', MapProto_set, 2], ['size', [MapProto_sizeGetter]], ['values', MapProto_values, 0]], realmRec.Intrinsics['%ObjectPrototype%'], 'Map');
    let entriesFunc = proto.GetOwnProperty(new Value('entries'));
    Assert(!(entriesFunc instanceof AbruptCompletion), "");

    if (entriesFunc instanceof Completion) {
      entriesFunc = entriesFunc.Value;
    }

    Assert(!(proto.DefineOwnProperty(wellKnownSymbols.iterator, entriesFunc) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%MapPrototype%'] = proto;
  }

  function CreateSetIterator(set, kind) {
    {
      const hygienicTemp = RequireInternalSlot(set, 'SetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const iterator = ObjectCreate(surroundingAgent.intrinsic('%SetIteratorPrototype%'), ['IteratedSet', 'SetNextIndex', 'SetIterationKind']);
    iterator.IteratedSet = set;
    iterator.SetNextIndex = 0;
    iterator.SetIterationKind = kind;
    return iterator;
  }

  function SetProto_add([value = Value.undefined], {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'SetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = S.SetData;

    for (const e of entries) {
      if (e !== undefined && SameValueZero(e, value) === Value.true) {
        return S;
      }
    }

    if (Type(value) === 'Number' && Object.is(value.numberValue(), -0)) {
      value = new Value(0);
    }

    entries.push(value);
    return S;
  }

  function SetProto_clear(args, {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'SetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = S.SetData;

    for (let i = 0; i < entries.length; i += 1) {
      entries[i] = undefined;
    }

    return Value.undefined;
  }

  function SetProto_delete([value = Value.undefined], {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'SetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = S.SetData;

    for (let i = 0; i < entries.length; i += 1) {
      const e = entries[i];

      if (e !== undefined && SameValueZero(e, value) === Value.true) {
        entries[i] = undefined;
        return Value.true;
      }
    }

    return Value.false;
  }

  function SetProto_entries(args, {
    thisValue
  }) {
    const S = thisValue;
    return CreateSetIterator(S, 'key+value');
  }

  function SetProto_forEach([callbackfn = Value.undefined, thisArg], {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'SetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError');
    }

    let T;

    if (thisArg !== undefined) {
      T = thisArg;
    } else {
      T = Value.undefined;
    }

    const entries = S.SetData;

    for (const e of entries) {
      if (e !== undefined) {
        {
          const hygienicTemp = Call(callbackfn, T, [e, e, S]);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
      }
    }

    return Value.undefined;
  }

  function SetProto_has([value = Value.undefined], {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'SetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = S.SetData;

    for (const e of entries) {
      if (e !== undefined && SameValueZero(e, value) === Value.true) {
        return Value.true;
      }
    }

    return Value.false;
  }

  function SetProto_values(args, {
    thisValue
  }) {
    const S = thisValue;
    return CreateSetIterator(S, 'value');
  }

  function SetProto_sizeGetter(args, {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'SetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = S.SetData;
    let count = 0;

    for (const e of entries) {
      if (e !== undefined) {
        count += 1;
      }
    }

    return new Value(count);
  }

  function CreateSetPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['add', SetProto_add, 1], ['clear', SetProto_clear, 0], ['delete', SetProto_delete, 1], ['entries', SetProto_entries, 0], ['forEach', SetProto_forEach, 1], ['has', SetProto_has, 1], ['size', [SetProto_sizeGetter]], ['values', SetProto_values, 0]], realmRec.Intrinsics['%ObjectPrototype%'], 'Set');
    let valuesFunc = proto.GetOwnProperty(new Value('values'));
    Assert(!(valuesFunc instanceof AbruptCompletion), "");

    if (valuesFunc instanceof Completion) {
      valuesFunc = valuesFunc.Value;
    }

    Assert(!(proto.DefineOwnProperty(new Value('keys'), valuesFunc) instanceof AbruptCompletion), "");
    Assert(!(proto.DefineOwnProperty(wellKnownSymbols.iterator, valuesFunc) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%SetPrototype%'] = proto;
  }

  function SetConstructor([iterable], {
    NewTarget
  }) {
    if (NewTarget === Value.undefined) {
      return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', 'Set'));
    }

    let set = OrdinaryCreateFromConstructor(NewTarget, '%SetPrototype%', ['SetData']);

    if (set instanceof AbruptCompletion) {
      return set;
    }

    if (set instanceof Completion) {
      set = set.Value;
    }

    set.SetData = [];

    if (iterable === undefined || Type(iterable) === 'Undefined' || Type(iterable) === 'Null') {
      return set;
    }

    let adder = Get(set, new Value('add'));

    if (adder instanceof AbruptCompletion) {
      return adder;
    }

    if (adder instanceof Completion) {
      adder = adder.Value;
    }

    if (IsCallable(adder) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', adder));
    }

    let iteratorRecord = GetIterator(iterable);

    if (iteratorRecord instanceof AbruptCompletion) {
      return iteratorRecord;
    }

    if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    while (true) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        return set;
      }

      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      const status = Call(adder, set, [nextValue]);

      if (status instanceof AbruptCompletion) {
        return IteratorClose(iteratorRecord, status);
      }
    }
  }

  function Set_speciesGetter(args, {
    thisValue
  }) {
    return thisValue;
  }

  function CreateSet(realmRec) {
    const setConstructor = BootstrapConstructor(realmRec, SetConstructor, 'Set', 0, realmRec.Intrinsics['%SetPrototype%'], [[wellKnownSymbols.species, [Set_speciesGetter]]]);
    realmRec.Intrinsics['%Set%'] = setConstructor;
  }

  function CreateGenerator(realmRec) {
    const generatorPrototype = realmRec.Intrinsics['%GeneratorPrototype%'];
    const generator = BootstrapPrototype(realmRec, [['prototype', generatorPrototype, undefined, {
      Writable: Value.false
    }]], realmRec.Intrinsics['%FunctionPrototype%'], 'GeneratorFunction');
    Assert(!(DefinePropertyOrThrow(generatorPrototype, new Value('constructor'), Descriptor({
      Value: generator,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%Generator%'] = generator;
  }

  function GeneratorFunctionConstructor(args, {
    NewTarget
  }) {
    const C = surroundingAgent.activeFunctionObject;
    return CreateDynamicFunction(C, NewTarget, 'generator', args);
  }

  function CreateGeneratorFunction(realmRec) {
    const generator = realmRec.Intrinsics['%Generator%'];
    const cons = BootstrapConstructor(realmRec, GeneratorFunctionConstructor, 'GeneratorFunction', 1, generator, []);
    Assert(!(DefinePropertyOrThrow(cons, new Value('prototype'), Descriptor({
      Writable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    Assert(!(DefinePropertyOrThrow(generator, new Value('constructor'), Descriptor({
      Writable: Value.false
    })) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%GeneratorFunction%'] = cons;
  }

  function GeneratorProto_next([value = Value.undefined], {
    thisValue
  }) {
    const g = thisValue;
    return GeneratorResume(g, value);
  } // 25.4.1.3 #sec-generator.prototype.return


  function GeneratorProto_return([value = Value.undefined], {
    thisValue
  }) {
    const g = thisValue;
    const C = new ReturnCompletion(value);
    return GeneratorResumeAbrupt(g, C);
  } // 25.4.1.4 #sec-generator.prototype.throw


  function GeneratorProto_throw([exception = Value.undefined], {
    thisValue
  }) {
    const g = thisValue;
    const C = new ThrowCompletion(exception);
    return GeneratorResumeAbrupt(g, C);
  }

  function CreateGeneratorPrototype(realmRec) {
    const generatorPrototype = BootstrapPrototype(realmRec, [['next', GeneratorProto_next, 1], ['return', GeneratorProto_return, 1], ['throw', GeneratorProto_throw, 1]], realmRec.Intrinsics['%IteratorPrototype%'], 'Generator');
    realmRec.Intrinsics['%GeneratorPrototype%'] = generatorPrototype;
  }

  function CreateAsyncFunctionPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [], realmRec.Intrinsics['%FunctionPrototype%'], 'AsyncFunction');
    realmRec.Intrinsics['%AsyncFunctionPrototype%'] = proto;
  }

  function AsyncFunctionConstructor(args, {
    NewTarget
  }) {
    const C = surroundingAgent.activeFunctionObject;
    return CreateDynamicFunction(C, NewTarget, 'async', args);
  }

  function CreateAsyncFunction(realmRec) {
    const cons = BootstrapConstructor(realmRec, AsyncFunctionConstructor, 'AsyncFunction', 1, realmRec.Intrinsics['%AsyncFunctionPrototype%'], []);
    cons.DefineOwnProperty(new Value('prototype'), Descriptor({
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    cons.Prototype = realmRec.Intrinsics['%Function%'];
    realmRec.Intrinsics['%AsyncFunction%'] = cons;
  }

  function CreateAsyncGenerator(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['prototype', realmRec.Intrinsics['%AsyncGeneratorPrototype%'], undefined, {
      Writable: Value.false
    }]], realmRec.Intrinsics['%FunctionPrototype%'], 'AsyncGeneratorFunction');
    Assert(!(realmRec.Intrinsics['%AsyncGeneratorPrototype%'].DefineOwnProperty(new Value('constructor'), Descriptor({
      Value: proto,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%AsyncGenerator%'] = proto;
  }

  function AsyncGeneratorFunctionConstructor(args, {
    NewTarget
  }) {
    const C = surroundingAgent.activeFunctionObject;
    return CreateDynamicFunction(C, NewTarget, 'async generator', args);
  }

  function CreateAsyncGeneratorFunction(realmRec) {
    const cons = BootstrapConstructor(realmRec, AsyncGeneratorFunctionConstructor, 'AsyncGeneratorFunction', 1, realmRec.Intrinsics['%AsyncGenerator%'], []);
    Assert(!(cons.DefineOwnProperty(new Value('prototype'), Descriptor({
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    })) instanceof AbruptCompletion), "");
    Assert(!(realmRec.Intrinsics['%AsyncGenerator%'].DefineOwnProperty(new Value('constructor'), Descriptor({
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    cons.Prototype = realmRec.Intrinsics['%Function%'];
    realmRec.Intrinsics['%AsyncGeneratorFunction%'] = cons;
  }

  function AsyncGeneratorPrototype_next([value = Value.undefined], {
    thisValue
  }) {
    const generator = thisValue;
    const completion = new NormalCompletion(value);

    let _val = AsyncGeneratorEnqueue(generator, completion);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    return _val;
  }

  function AsyncGeneratorPrototype_return([value = Value.undefined], {
    thisValue
  }) {
    const generator = thisValue;
    const completion = new Completion('return', value, undefined);

    let _val2 = AsyncGeneratorEnqueue(generator, completion);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    return _val2;
  }

  function AsyncGeneratorPrototype_throw([exception = Value.undefined], {
    thisValue
  }) {
    const generator = thisValue;
    const completion = new ThrowCompletion(exception);

    let _val3 = AsyncGeneratorEnqueue(generator, completion);

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    return _val3;
  }

  function CreateAsyncGeneratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['next', AsyncGeneratorPrototype_next, 1], ['return', AsyncGeneratorPrototype_return, 1], ['throw', AsyncGeneratorPrototype_throw, 1]], realmRec.Intrinsics['%AsyncIteratorPrototype%'], 'AsyncGenerator');
    realmRec.Intrinsics['%AsyncGeneratorPrototype%'] = proto;
  }

  function AsyncFromSyncIteratorPrototype_next([value = Value.undefined], {
    thisValue
  }) {
    const O = thisValue;
    Assert(Type(O) === 'Object' && 'SyncIteratorRecord' in O, "Type(O) === 'Object' && 'SyncIteratorRecord' in O");
    let promiseCapability = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    Assert(!(promiseCapability instanceof AbruptCompletion), "");

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    const syncIteratorRecord = O.SyncIteratorRecord;
    let result = IteratorNext(syncIteratorRecord, value);

    if (result instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (result instanceof Completion) {
      result = result.Value;
    }

    let _val = AsyncFromSyncIteratorContinuation(result, promiseCapability);

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    return _val;
  } // 25.1.4.2.2 #sec-%asyncfromsynciteratorprototype%.return


  function AsyncFromSyncIteratorPrototype_return([value = Value.undefined], {
    thisValue
  }) {
    const O = thisValue;
    Assert(Type(O) === 'Object' && 'SyncIteratorRecord' in O, "Type(O) === 'Object' && 'SyncIteratorRecord' in O");
    let promiseCapability = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    Assert(!(promiseCapability instanceof AbruptCompletion), "");

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    const syncIterator = O.SyncIteratorRecord.Iterator;
    let ret = GetMethod(syncIterator, new Value('return'));

    if (ret instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [ret.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (ret instanceof Completion) {
      ret = ret.Value;
    }

    if (ret === Value.undefined) {
      let iterResult = CreateIterResultObject(value, Value.true);
      Assert(!(iterResult instanceof AbruptCompletion), "");

      if (iterResult instanceof Completion) {
        iterResult = iterResult.Value;
      }

      Assert(!(Call(promiseCapability.Resolve, Value.undefined, [iterResult]) instanceof AbruptCompletion), "");
      return promiseCapability.Promise;
    }

    let result = Call(ret, syncIterator, [value]);

    if (result instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (result instanceof Completion) {
      result = result.Value;
    }

    if (Type(result) !== 'Object') {
      Assert(!(Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'iterator result was not an object').Value]) instanceof AbruptCompletion), "");
      return promiseCapability.Promise;
    }

    let _val2 = AsyncFromSyncIteratorContinuation(result, promiseCapability);

    Assert(!(_val2 instanceof AbruptCompletion), "");

    if (_val2 instanceof Completion) {
      _val2 = _val2.Value;
    }

    return _val2;
  } // 25.1.4.2.3 #sec-%asyncfromsynciteratorprototype%.throw


  function AsyncFromSyncIteratorPrototype_throw([value = Value.undefined], {
    thisValue
  }) {
    const O = thisValue;
    Assert(Type(O) === 'Object' && 'SyncIteratorRecord' in O, "Type(O) === 'Object' && 'SyncIteratorRecord' in O");
    let promiseCapability = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    Assert(!(promiseCapability instanceof AbruptCompletion), "");

    if (promiseCapability instanceof Completion) {
      promiseCapability = promiseCapability.Value;
    }

    const syncIterator = O.SyncIteratorRecord.Iterator;
    let thr = GetMethod(syncIterator, new Value('throw'));

    if (thr instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [thr.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (thr instanceof Completion) {
      thr = thr.Value;
    }

    if (thr === Value.undefined) {
      Assert(!(Call(promiseCapability.Reject, Value.undefined, [value]) instanceof AbruptCompletion), "");
      return promiseCapability.Promise;
    }

    let result = Call(thr, syncIterator, [value]);

    if (result instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    } else if (result instanceof Completion) {
      result = result.Value;
    }

    if (Type(result) !== 'Object') {
      Assert(!(Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'iterator result was not an object').Value]) instanceof AbruptCompletion), "");
      return promiseCapability.Promise;
    }

    let _val3 = AsyncFromSyncIteratorContinuation(result, promiseCapability);

    Assert(!(_val3 instanceof AbruptCompletion), "");

    if (_val3 instanceof Completion) {
      _val3 = _val3.Value;
    }

    return _val3;
  }

  function CreateAsyncFromSyncIteratorPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['next', AsyncFromSyncIteratorPrototype_next, 1], ['return', AsyncFromSyncIteratorPrototype_return, 1], ['throw', AsyncFromSyncIteratorPrototype_throw, 1]], realmRec.Intrinsics['%AsyncIteratorPrototype%']);
    realmRec.Intrinsics['%AsyncFromSyncIteratorPrototype%'] = proto;
  }

  function ArrayBufferConstructor([length = Value.undefined], {
    NewTarget
  }) {
    if (Type(NewTarget) === 'Undefined') {
      return surroundingAgent.Throw('TypeError', 'ArrayBuffer constructor requires new');
    }

    let byteLength = ToIndex(length);

    if (byteLength instanceof AbruptCompletion) {
      return byteLength;
    }

    if (byteLength instanceof Completion) {
      byteLength = byteLength.Value;
    }

    return AllocateArrayBuffer(NewTarget, byteLength);
  } // 24.1.3.1 #sec-arraybuffer.isview


  function ArrayBuffer_isView([arg = Value.undefined]) {
    if (Type(arg) !== 'Object') {
      return Value.false;
    }

    if ('ViewedArrayBuffer' in arg) {
      return Value.true;
    }

    return Value.false;
  } // 24.1.3.3 #sec-get-arraybuffer-@@species


  function ArrayBuffer_speciesGetter(a, {
    thisValue
  }) {
    return thisValue;
  }

  function CreateArrayBuffer(realmRec) {
    const abConstructor = BootstrapConstructor(realmRec, ArrayBufferConstructor, 'ArrayBuffer', 1, realmRec.Intrinsics['%ArrayBufferPrototype%'], [['isView', ArrayBuffer_isView, 1], [wellKnownSymbols.species, [ArrayBuffer_speciesGetter]]]);
    realmRec.Intrinsics['%ArrayBuffer%'] = abConstructor;
  }

  function ArrayBufferProto_byteLengthGetter(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'ArrayBufferData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (IsSharedArrayBuffer(O) === Value.true) {
      return surroundingAgent.Throw('TypeError', msg('NotAnTypeObject', 'ArrayBuffer', O));
    }

    if (IsDetachedBuffer(O)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const length = O.ArrayBufferByteLength;
    return length;
  } // 24.1.4.3 #sec-arraybuffer.prototype.slice


  function ArrayBufferProto_slice([start = Value.undefined, end = Value.undefined], {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'ArrayBufferData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (IsSharedArrayBuffer(O) === Value.true) {
      return surroundingAgent.Throw('TypeError', msg('NotAnTypeObject', 'ArrayBuffer', O));
    }

    if (IsDetachedBuffer(O)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const len = O.ArrayBufferByteLength.numberValue();

    let _hygienicTemp = ToInteger(start);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const relativeStart = _hygienicTemp.numberValue();

    let first;

    if (relativeStart < 0) {
      first = Math.max(len + relativeStart, 0);
    } else {
      first = Math.min(relativeStart, len);
    }

    let relativeEnd;

    if (Type(end) === 'Undefined') {
      relativeEnd = len;
    } else {
      let _hygienicTemp2 = ToInteger(end);

      if (_hygienicTemp2 instanceof AbruptCompletion) {
        return _hygienicTemp2;
      }

      if (_hygienicTemp2 instanceof Completion) {
        _hygienicTemp2 = _hygienicTemp2.Value;
      }

      relativeEnd = _hygienicTemp2.numberValue();
    }

    let final;

    if (relativeEnd < 0) {
      final = Math.max(len + relativeEnd, 0);
    } else {
      final = Math.min(relativeEnd, len);
    }

    const newLen = Math.max(final - first, 0);
    let ctor = SpeciesConstructor(O, surroundingAgent.intrinsic('%ArrayBuffer%'));

    if (ctor instanceof AbruptCompletion) {
      return ctor;
    }

    if (ctor instanceof Completion) {
      ctor = ctor.Value;
    }

    let neww = Construct(ctor, [new Value(newLen)]);

    if (neww instanceof AbruptCompletion) {
      return neww;
    }

    if (neww instanceof Completion) {
      neww = neww.Value;
    }

    if (!('ArrayBufferData' in neww) || IsSharedArrayBuffer(neww) === Value.true) {
      return surroundingAgent.Throw('TypeError', msg('NotAnTypeObject', 'ArrayBuffer', neww));
    }

    if (IsDetachedBuffer(neww)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    if (SameValue(neww, O) === Value.true) {
      return surroundingAgent.Throw('TypeError', msg('SubclassSameValue', neww));
    }

    if (neww.ArrayBufferByteLength.numberValue() < newLen) {
      return surroundingAgent.Throw('TypeError', msg('SubclassLengthTooSmall', neww));
    }

    if (IsDetachedBuffer(O)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const fromBuf = O.ArrayBufferData;
    const toBuf = neww.ArrayBufferData;
    CopyDataBlockBytes(toBuf, new Value(0), fromBuf, new Value(first), new Value(newLen));
    return neww;
  }

  function CreateArrayBufferPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['byteLength', [ArrayBufferProto_byteLengthGetter]], ['slice', ArrayBufferProto_slice, 2]], realmRec.Intrinsics['%ObjectPrototype%'], 'ArrayBuffer');
    realmRec.Intrinsics['%ArrayBufferPrototype%'] = proto;
  }

  const WHITESPACE = [' ', '\t', '\r', '\n'];
  const NUMERIC = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
  const NUMERIC_EXTENDED = [...NUMERIC, '-', 'e', '.'];
  const VALID_HEX = [...NUMERIC, 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'];
  const ESCAPABLE = ['"', '\\', '/', 'b', 'f', 'n', 'r', 't'];

  class JSONValidator {
    constructor(input) {
      this.input = input;
      this.pos = 0;
      this.char = input.charAt(0);
    }

    validate() {
      Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
      {
        const hygienicTemp = this.parseValue();

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }

      if (this.pos < this.input.length) {
        return surroundingAgent.Throw('SyntaxError', 'JSON input doesn\'t end!');
      }

      return new NormalCompletion(undefined);
    }

    advance() {
      this.pos += 1;

      if (this.pos === this.input.length) {
        this.char = null;
      } else if (this.pos > this.input.length) {
        return surroundingAgent.Throw('SyntaxError', 'JSON got unexpected EOF');
      } else {
        this.char = this.input.charAt(this.pos);
      }

      return this.char;
    }

    eatWhitespace() {
      while (this.eat(WHITESPACE));
    }

    eat(c) {
      if (Array.isArray(c) && c.includes(this.char)) {
        Assert(!(this.advance() instanceof AbruptCompletion), "");
        return true;
      } else if (this.char === c) {
        Assert(!(this.advance() instanceof AbruptCompletion), "");
        return true;
      }

      return false;
    }

    expect(c) {
      const {
        char
      } = this;

      if (!this.eat(c)) {
        return surroundingAgent.Throw('SyntaxError', `Expected ${c} but got ${this.char}`);
      }

      return char;
    }

    parseValue() {
      switch (this.char) {
        case '"':
          return this.parseString();

        case '{':
          return this.parseObject();

        case '[':
          return this.parseArray();

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '-':
          return this.parseNumber();

        case 'f':
          if (this.eat('f') && this.eat('a') && this.eat('l') && this.eat('s') && this.eat('e')) {
            let _val = this.eatWhitespace();

            Assert(!(_val instanceof AbruptCompletion), "");

            if (_val instanceof Completion) {
              _val = _val.Value;
            }

            return _val;
          } else {
            return surroundingAgent.Throw('SyntaxError', `Unexpected ${this.char} when parsing false`);
          }

        case 't':
          if (this.eat('t') && this.eat('r') && this.eat('u') && this.eat('e')) {
            let _val2 = this.eatWhitespace();

            Assert(!(_val2 instanceof AbruptCompletion), "");

            if (_val2 instanceof Completion) {
              _val2 = _val2.Value;
            }

            return _val2;
          } else {
            return surroundingAgent.Throw('SyntaxError', `Unexpected ${this.char} when parsing true`);
          }

        case 'n':
          if (this.eat('n') && this.eat('u') && this.eat('l') && this.eat('l')) {
            let _val3 = this.eatWhitespace();

            Assert(!(_val3 instanceof AbruptCompletion), "");

            if (_val3 instanceof Completion) {
              _val3 = _val3.Value;
            }

            return _val3;
          } else {
            return surroundingAgent.Throw('SyntaxError', `Unexpected ${this.char} when parsing null`);
          }

        default:
          return surroundingAgent.Throw('SyntaxError', `Unexpected character ${this.char}`);
      }
    }

    parseString() {
      {
        const hygienicTemp = this.expect('"');

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }

      while (!this.eat('"')) {
        if (this.eat('\\')) {
          if (!this.eat(ESCAPABLE)) {
            {
              const hygienicTemp = this.expect('u');

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
            {
              const hygienicTemp = this.expect(VALID_HEX);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
            {
              const hygienicTemp = this.expect(VALID_HEX);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
            {
              const hygienicTemp = this.expect(VALID_HEX);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
            {
              const hygienicTemp = this.expect(VALID_HEX);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
          }
        } else {
          if (this.char < ' ') {
            return surroundingAgent.Throw('SyntaxError', `Unexpected character ${this.char} in JSON`);
          }

          {
            const hygienicTemp = this.advance();

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
        }
      }

      let _val4 = this.eatWhitespace();

      Assert(!(_val4 instanceof AbruptCompletion), "");

      if (_val4 instanceof Completion) {
        _val4 = _val4.Value;
      }

      return _val4;
    }

    parseNumber() {
      {
        const hygienicTemp = this.expect(NUMERIC_EXTENDED);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }

      while (this.eat(NUMERIC_EXTENDED));

      Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
    }

    parseObject() {
      {
        const hygienicTemp = this.expect('{');

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
      let first = true;

      while (!this.eat('}')) {
        if (first) {
          first = false;
        } else {
          {
            const hygienicTemp = this.expect(',');

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
        }

        {
          const hygienicTemp = this.parseString();

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
        {
          const hygienicTemp = this.expect(':');

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
        {
          const hygienicTemp = this.parseValue();

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
      }

      Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
    }

    parseArray() {
      {
        const hygienicTemp = this.expect('[');

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
      let first = true;

      while (!this.eat(']')) {
        if (first) {
          first = false;
        } else {
          {
            const hygienicTemp = this.expect(',');

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
        }

        {
          const hygienicTemp = this.parseValue();

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
      }

      Assert(!(this.eatWhitespace() instanceof AbruptCompletion), "");
    }

    static validate(input) {
      const v = new JSONValidator(input);
      return v.validate();
    }

  }

  function JSON_parse([text = Value.undefined, reviver = Value.undefined]) {
    function InternalizeJSONProperty(holder, name) {
      let val = Get(holder, name);

      if (val instanceof AbruptCompletion) {
        return val;
      }

      if (val instanceof Completion) {
        val = val.Value;
      }

      if (Type(val) === 'Object') {
        let isArray = IsArray(val);

        if (isArray instanceof AbruptCompletion) {
          return isArray;
        }

        if (isArray instanceof Completion) {
          isArray = isArray.Value;
        }

        if (isArray === Value.true) {
          let I = 0;

          let _hygienicTemp = LengthOfArrayLike(val);

          if (_hygienicTemp instanceof AbruptCompletion) {
            return _hygienicTemp;
          }

          if (_hygienicTemp instanceof Completion) {
            _hygienicTemp = _hygienicTemp.Value;
          }

          const len = _hygienicTemp.numberValue();

          while (I < len) {
            let Istr = ToString(new Value(I));
            Assert(!(Istr instanceof AbruptCompletion), "");

            if (Istr instanceof Completion) {
              Istr = Istr.Value;
            }

            let newElement = InternalizeJSONProperty(val, Istr);

            if (newElement instanceof AbruptCompletion) {
              return newElement;
            }

            if (newElement instanceof Completion) {
              newElement = newElement.Value;
            }

            if (Type(newElement) === 'Undefined') {
              {
                const hygienicTemp = val.Delete(Istr);

                if (hygienicTemp instanceof AbruptCompletion) {
                  return hygienicTemp;
                }
              }
            } else {
              {
                const hygienicTemp = CreateDataProperty(val, Istr, newElement);

                if (hygienicTemp instanceof AbruptCompletion) {
                  return hygienicTemp;
                }
              }
            }

            I += 1;
          }
        } else {
          let keys = EnumerableOwnPropertyNames(val, 'key');

          if (keys instanceof AbruptCompletion) {
            return keys;
          }

          if (keys instanceof Completion) {
            keys = keys.Value;
          }

          for (const P of keys) {
            let newElement = InternalizeJSONProperty(val, P);

            if (newElement instanceof AbruptCompletion) {
              return newElement;
            }

            if (newElement instanceof Completion) {
              newElement = newElement.Value;
            }

            if (Type(newElement) === 'Undefined') {
              {
                const hygienicTemp = val.Delete(P);

                if (hygienicTemp instanceof AbruptCompletion) {
                  return hygienicTemp;
                }
              }
            } else {
              {
                const hygienicTemp = CreateDataProperty(val, P, newElement);

                if (hygienicTemp instanceof AbruptCompletion) {
                  return hygienicTemp;
                }
              }
            }
          }
        }
      }

      return Call(reviver, holder, [name, val]);
    }

    let jText = ToString(text);

    if (jText instanceof AbruptCompletion) {
      return jText;
    }

    if (jText instanceof Completion) {
      jText = jText.Value;
    }

    // Parse JText interpreted as UTF-16 encoded Unicode points (6.1.4) as a JSON text as specified in ECMA-404.
    // Throw a SyntaxError exception if JText is not a valid JSON text as defined in that specification.
    {
      const hygienicTemp = JSONValidator.validate(jText.stringValue());

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const scriptText = `(${jText.stringValue()});`;
    const completion = EnsureCompletion(ScriptEvaluationJob(scriptText));
    const unfiltered = completion.Value;
    Assert(unfiltered instanceof StringValue || unfiltered instanceof NumberValue || unfiltered instanceof BooleanValue || unfiltered instanceof NullValue || unfiltered instanceof ObjectValue, "unfiltered instanceof StringValue\n         || unfiltered instanceof NumberValue\n         || unfiltered instanceof BooleanValue\n         || unfiltered instanceof NullValue\n         || unfiltered instanceof ObjectValue");

    if (IsCallable(reviver) === Value.true) {
      const root = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
      const rootName = new Value('');
      let status = CreateDataProperty(root, rootName, unfiltered);
      Assert(!(status instanceof AbruptCompletion), "");

      if (status instanceof Completion) {
        status = status.Value;
      }

      Assert(status === Value.true, "status === Value.true");
      return InternalizeJSONProperty(root, rootName);
    } else {
      return unfiltered;
    }
  }

  const codeUnitTable = new Map([[0x0008, '\\b'], [0x0009, '\\t'], [0x000A, '\\n'], [0x000C, '\\f'], [0x000D, '\\r'], [0x0022, '\\"'], [0x005C, '\\\\']]);

  function JSON_stringify([value = Value.undefined, replacer = Value.undefined, space = Value.undefined]) {
    // 24.5.2.1 #sec-serializejsonproperty
    function SerializeJSONProperty(key, holder) {
      let value = Get(holder, key);

      if (value instanceof AbruptCompletion) {
        return value;
      }

      if (value instanceof Completion) {
        value = value.Value;
      }

      // eslint-disable-line no-shadow
      if (Type(value) === 'Object') {
        let toJSON = Get(value, new Value('toJSON'));

        if (toJSON instanceof AbruptCompletion) {
          return toJSON;
        }

        if (toJSON instanceof Completion) {
          toJSON = toJSON.Value;
        }

        if (IsCallable(toJSON) === Value.true) {
          value = Call(toJSON, value, [key]);

          if (value instanceof AbruptCompletion) {
            return value;
          }

          if (value instanceof Completion) {
            value = value.Value;
          }
        }
      }

      if (ReplacerFunction !== Value.undefined) {
        value = Call(ReplacerFunction, holder, [key, value]);

        if (value instanceof AbruptCompletion) {
          return value;
        }

        if (value instanceof Completion) {
          value = value.Value;
        }
      }

      if (Type(value) === 'Object') {
        if ('NumberData' in value) {
          value = ToNumber(value);

          if (value instanceof AbruptCompletion) {
            return value;
          }

          if (value instanceof Completion) {
            value = value.Value;
          }
        } else if ('StringData' in value) {
          value = ToString(value);

          if (value instanceof AbruptCompletion) {
            return value;
          }

          if (value instanceof Completion) {
            value = value.Value;
          }
        } else if ('BooleanData' in value) {
          value = value.BooleanData;
        }
      }

      if (value === Value.null) {
        return new Value('null');
      }

      if (value === Value.true) {
        return new Value('true');
      }

      if (value === Value.false) {
        return new Value('false');
      }

      if (Type(value) === 'String') {
        return QuoteJSONString(value);
      }

      if (Type(value) === 'Number') {
        if (!value.isInfinity()) {
          let _val5 = ToString(value);

          Assert(!(_val5 instanceof AbruptCompletion), "");

          if (_val5 instanceof Completion) {
            _val5 = _val5.Value;
          }

          return _val5;
        }

        return new Value('null');
      }

      if (Type(value) === 'Object' && IsCallable(value) === Value.false) {
        let isArray = IsArray(value);

        if (isArray instanceof AbruptCompletion) {
          return isArray;
        }

        if (isArray instanceof Completion) {
          isArray = isArray.Value;
        }

        if (isArray === Value.true) {
          return SerializeJSONArray(value);
        }

        return SerializeJSONObject(value);
      }

      return Value.undefined;
    }

    function QuoteJSONString(value) {
      // eslint-disable-line no-shadow
      let product = '\u0022';
      const cpList = [...value.stringValue()].map(c => c.codePointAt(0));

      for (const C of cpList) {
        if (codeUnitTable.has(C)) {
          product = `${product}${codeUnitTable.get(C)}`;
        } else if (C < 0x0020 || C >= 0xD800 && C <= 0xDBFF || C >= 0xDC00 && C <= 0xDFFF) {
          const unit = String.fromCodePoint(C);
          product = `${product}${UnicodeEscape(unit)}`;
        } else {
          product = `${product}${String.fromCodePoint(...UTF16Encoding(C))}`;
        }
      }

      product = `${product}\u0022`;
      return new Value(product);
    }

    function UnicodeEscape(C) {
      const n = C.charCodeAt(0);
      Assert(n < 0xFFFF, "n < 0xFFFF");
      return `\u005Cu${n.toString(16).padStart(4, '0')}`;
    } // 24.5.2.4 #sec-serializejsonobject


    function SerializeJSONObject(value) {
      // eslint-disable-line no-shadow
      if (stack.includes(value)) {
        return surroundingAgent.Throw('TypeError', 'Cannot stringify a circular structure');
      }

      stack.push(value);
      const stepback = indent;
      indent = `${indent}${gap}`;
      let K;

      if (PropertyList !== Value.undefined) {
        K = PropertyList;
      } else {
        K = EnumerableOwnPropertyNames(value, 'key');

        if (K instanceof AbruptCompletion) {
          return K;
        }

        if (K instanceof Completion) {
          K = K.Value;
        }
      }

      const partial = [];

      for (const P of K) {
        let strP = SerializeJSONProperty(P, value);

        if (strP instanceof AbruptCompletion) {
          return strP;
        }

        if (strP instanceof Completion) {
          strP = strP.Value;
        }

        if (strP !== Value.undefined) {
          let member = QuoteJSONString(P).stringValue();
          member = `${member}:`;

          if (gap !== '') {
            member = `${member} `;
          }

          member = `${member}${strP.stringValue()}`;
          partial.push(member);
        }
      }

      let final;

      if (partial.length === 0) {
        final = new Value('{}');
      } else {
        if (gap === '') {
          const properties = partial.join(',');
          final = new Value(`{${properties}}`);
        } else {
          const separator = `,\u000A${indent}`;
          const properties = partial.join(separator);
          final = new Value(`{\u000A${indent}${properties}\u000A${stepback}}`);
        }
      }

      stack.pop();
      indent = stepback;
      return final;
    } // 24.5.2.5 #sec-serializejsonarray


    function SerializeJSONArray(value) {
      // eslint-disable-line no-shadow
      if (stack.includes(value)) {
        return surroundingAgent.Throw('TypeError', 'Cannot stringify a circular structure');
      }

      stack.push(value);
      const stepback = indent;
      indent = `${indent}${gap}`;
      const partial = [];

      let _hygienicTemp2 = Get(value, new Value('length'));

      if (_hygienicTemp2 instanceof AbruptCompletion) {
        return _hygienicTemp2;
      }

      if (_hygienicTemp2 instanceof Completion) {
        _hygienicTemp2 = _hygienicTemp2.Value;
      }

      const len = _hygienicTemp2.numberValue();

      let index = 0;

      while (index < len) {
        let indexStr = ToString(new Value(index));
        Assert(!(indexStr instanceof AbruptCompletion), "");

        if (indexStr instanceof Completion) {
          indexStr = indexStr.Value;
        }

        let strP = SerializeJSONProperty(indexStr, value);

        if (strP instanceof AbruptCompletion) {
          return strP;
        }

        if (strP instanceof Completion) {
          strP = strP.Value;
        }

        if (strP === Value.undefined) {
          partial.push('null');
        } else {
          partial.push(strP.stringValue());
        }

        index += 1;
      }

      let final;

      if (partial.length === 0) {
        final = new Value('[]');
      } else {
        if (gap === '') {
          const properties = partial.join(',');
          final = new Value(`[${properties}]`);
        } else {
          const separator = `,\u000A${indent}`;
          const properties = partial.join(separator);
          final = new Value(`[\u000A${indent}${properties}\u000A${stepback}]`);
        }
      }

      stack.pop();
      indent = stepback;
      return final;
    }

    const stack = [];
    let indent = '';
    let PropertyList = Value.undefined;
    let ReplacerFunction = Value.undefined;

    if (Type(replacer) === 'Object') {
      if (IsCallable(replacer) === Value.true) {
        ReplacerFunction = replacer;
      } else {
        let isArray = IsArray(replacer);

        if (isArray instanceof AbruptCompletion) {
          return isArray;
        }

        if (isArray instanceof Completion) {
          isArray = isArray.Value;
        }

        if (isArray === Value.true) {
          PropertyList = [];

          let _hygienicTemp3 = LengthOfArrayLike(replacer);

          if (_hygienicTemp3 instanceof AbruptCompletion) {
            return _hygienicTemp3;
          }

          if (_hygienicTemp3 instanceof Completion) {
            _hygienicTemp3 = _hygienicTemp3.Value;
          }

          const len = _hygienicTemp3.numberValue();

          let k = 0;

          while (k < len) {
            let _val6 = ToString(new Value(k));

            Assert(!(_val6 instanceof AbruptCompletion), "");

            if (_val6 instanceof Completion) {
              _val6 = _val6.Value;
            }

            {
              let v = Get(replacer, _val6);

              if (v instanceof AbruptCompletion) {
                return v;
              }

              if (v instanceof Completion) {
                v = v.Value;
              }

              let item = Value.undefined;

              if (Type(v) === 'String') {
                item = v;
              } else if (Type(v) === 'Number') {
                item = ToString(v);
                Assert(!(item instanceof AbruptCompletion), "");

                if (item instanceof Completion) {
                  item = item.Value;
                }
              } else if (Type(v) === 'Object') {
                if ('StringData' in v || 'NumberData' in v) {
                  item = ToString(v);

                  if (item instanceof AbruptCompletion) {
                    return item;
                  }

                  if (item instanceof Completion) {
                    item = item.Value;
                  }
                }
              }

              if (Type(item) !== 'undefined' && !PropertyList.includes(item)) {
                PropertyList.push(item);
              }

              k += 1;
            }
          }
        }
      }
    }

    if (Type(space) === 'Object') {
      if ('NumberData' in space) {
        space = ToNumber(space);

        if (space instanceof AbruptCompletion) {
          return space;
        }

        if (space instanceof Completion) {
          space = space.Value;
        }
      } else if ('StringData' in space) {
        space = ToString(space);

        if (space instanceof AbruptCompletion) {
          return space;
        }

        if (space instanceof Completion) {
          space = space.Value;
        }
      }
    }

    let gap;

    if (Type(space) === 'Number') {
      let _val7 = ToInteger(space);

      Assert(!(_val7 instanceof AbruptCompletion), "");

      if (_val7 instanceof Completion) {
        _val7 = _val7.Value;
      }

      space = Math.min(10, _val7.numberValue());

      if (space < 1) {
        gap = '';
      } else {
        gap = ' '.repeat(space);
      }
    } else if (Type(space) === 'String') {
      if (space.stringValue().length <= 10) {
        gap = space.stringValue();
      } else {
        gap = space.stringValue().slice(0, 10);
      }
    } else {
      gap = '';
    }

    const wrapper = ObjectCreate(surroundingAgent.intrinsic('%ObjectPrototype%'));
    let status = CreateDataProperty(wrapper, new Value(''), value);
    Assert(!(status instanceof AbruptCompletion), "");

    if (status instanceof Completion) {
      status = status.Value;
    }

    Assert(status === Value.true, "status === Value.true");
    return SerializeJSONProperty(new Value(''), wrapper);
  }

  function CreateJSON(realmRec) {
    const json = BootstrapPrototype(realmRec, [['parse', JSON_parse, 2], ['stringify', JSON_stringify, 3]], realmRec.Intrinsics['%ObjectPrototype%'], 'JSON');
    realmRec.Intrinsics['%JSON%'] = json;

    let _val8 = json.Get(new Value('parse'));

    Assert(!(_val8 instanceof AbruptCompletion), "");

    if (_val8 instanceof Completion) {
      _val8 = _val8.Value;
    }

    realmRec.Intrinsics['%JSONParse%'] = _val8;
  }

  function TheEval([x = Value.undefined]) {
    Assert(surroundingAgent.executionContextStack.length >= 2, "surroundingAgent.executionContextStack.length >= 2");
    const callerContext = surroundingAgent.executionContextStack[surroundingAgent.executionContextStack.length - 2];
    const callerRealm = callerContext.Realm;
    return PerformEval(x, callerRealm, false, false);
  }

  function CreateEval(realmRec) {
    const it = CreateBuiltinFunction(TheEval, [], realmRec);
    SetFunctionName(it, new Value('eval'));
    SetFunctionLength(it, new Value(1));
    realmRec.Intrinsics['%eval%'] = it;
  }

  function IsFinite([number = Value.undefined]) {
    let num = ToNumber(number);

    if (num instanceof AbruptCompletion) {
      return num;
    }

    if (num instanceof Completion) {
      num = num.Value;
    }

    if (num.isNaN() || num.isInfinity()) {
      return Value.false;
    }

    return Value.true;
  }

  function CreateIsFinite(realmRec) {
    const fn = CreateBuiltinFunction(IsFinite, [], realmRec);
    Assert(!(SetFunctionName(fn, new Value('isFinite')) instanceof AbruptCompletion), "");
    Assert(!(SetFunctionLength(fn, new Value(1)) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%isFinite%'] = fn;
  }

  function IsNaN([number = Value.undefined]) {
    let num = ToNumber(number);

    if (num instanceof AbruptCompletion) {
      return num;
    }

    if (num instanceof Completion) {
      num = num.Value;
    }

    if (num.isNaN()) {
      return Value.true;
    }

    return Value.false;
  }

  function CreateIsNaN(realmRec) {
    const fn = CreateBuiltinFunction(IsNaN, [], realmRec);
    Assert(!(SetFunctionName(fn, new Value('isNaN')) instanceof AbruptCompletion), "");
    Assert(!(SetFunctionLength(fn, new Value(1)) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%isNaN%'] = fn;
  }

  function ParseFloat([string = Value.undefined]) {
    let inputString = ToString(string);

    if (inputString instanceof AbruptCompletion) {
      return inputString;
    }

    if (inputString instanceof Completion) {
      inputString = inputString.Value;
    }

    let _val = TrimString(inputString, 'start');

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    const trimmedString = _val.stringValue();

    const mathFloat = MV_StrDecimalLiteral(trimmedString, true); // MV_StrDecimalLiteral handles -0 automatically.

    return mathFloat;
  }

  function CreateParseFloat(realmRec) {
    const fn = CreateBuiltinFunction(ParseFloat, [], realmRec);
    Assert(!(SetFunctionName(fn, new Value('parseFloat')) instanceof AbruptCompletion), "");
    Assert(!(SetFunctionLength(fn, new Value(1)) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%parseFloat%'] = fn;
  }

  function digitToNumber(digit) {
    digit = digit.charCodeAt(0);

    if (digit < 0x30
    /* 0 */
    ) {
        return NaN;
      }

    if (digit <= 0x39
    /* 9 */
    ) {
        return digit - 0x30;
      } // Convert to lower case.


    digit &= ~0x20; // eslint-disable-line no-bitwise

    if (digit < 0x41
    /* A */
    ) {
        return NaN;
      }

    if (digit <= 0x5a
    /* Z */
    ) {
        return digit - 0x41
        /* A */
        + 10;
      }

    return NaN;
  }

  function stringToRadixNumber(str, R) {
    let num = 0;

    for (let i = 0; i < str.length; i += 1) {
      const power = str.length - i - 1;
      const multiplier = R ** power;
      const dig = digitToNumber(str[i]);
      Assert(!Number.isNaN(dig) && dig < R, "!Number.isNaN(dig) && dig < R");
      num += dig * multiplier;
    }

    return num;
  }

  function searchNotRadixDigit(str, R) {
    for (let i = 0; i < str.length; i += 1) {
      const num = digitToNumber(str[i]);

      if (Number.isNaN(num) || num >= R) {
        return i;
      }
    }

    return str.length;
  }

  function ParseInt([string = Value.undefined, radix = Value.undefined]) {
    let inputString = ToString(string);

    if (inputString instanceof AbruptCompletion) {
      return inputString;
    }

    if (inputString instanceof Completion) {
      inputString = inputString.Value;
    }

    let _val = TrimString(inputString, 'start');

    Assert(!(_val instanceof AbruptCompletion), "");

    if (_val instanceof Completion) {
      _val = _val.Value;
    }

    let S = _val.stringValue();

    let sign = 1;

    if (S !== '' && S[0] === '\x2D') {
      sign = -1;
    }

    if (S !== '' && (S[0] === '\x2B' || S[0] === '\x2D')) {
      S = S.slice(1);
    }

    let _hygienicTemp = ToInt32(radix);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    let R = _hygienicTemp.numberValue();

    let stripPrefix = true;

    if (R !== 0) {
      if (R < 2 || R > 36) {
        return new Value(NaN);
      }

      if (R !== 16) {
        stripPrefix = false;
      }
    } else {
      R = 10;
    }

    if (stripPrefix === true) {
      if (S.length >= 2 && (S.startsWith('0x') || S.startsWith('0X'))) {
        S = S.slice(2);
        R = 16;
      }
    }

    const Z = S.slice(0, searchNotRadixDigit(S, R));

    if (Z === '') {
      return new Value(NaN);
    }

    const mathInt = stringToRadixNumber(Z, R);

    if (mathInt === 0) {
      if (sign === -1) {
        return new Value(-0);
      }

      return new Value(+0);
    }

    const number = mathInt;
    return new Value(sign * number);
  }

  function CreateParseInt(realmRec) {
    const fn = CreateBuiltinFunction(ParseInt, [], realmRec);
    Assert(!(SetFunctionName(fn, new Value('parseInt')) instanceof AbruptCompletion), "");
    Assert(!(SetFunctionLength(fn, new Value(2)) instanceof AbruptCompletion), "");
    realmRec.Intrinsics['%parseInt%'] = fn;
  }

  function TypedArrayConstructor() {
    return surroundingAgent.Throw('TypeError', '%TypedArray% is not directly constructable');
  } // 22.2.2.1 #sec-%typedarray%.from


  function TypedArray_from([source = Value.undefined, mapfn, thisArg], {
    thisValue
  }) {
    const C = thisValue;

    if (IsConstructor(C) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAConstructor', C));
    }

    let mapping;

    if (mapfn !== undefined && mapfn !== Value.undefined) {
      if (IsCallable(mapfn) === Value.false) {
        return surroundingAgent.Throw('TypeError', msg('NotAFunction', mapfn));
      }

      mapping = true;
    } else {
      mapping = false;
    }

    const T = thisArg !== undefined ? thisArg : Value.undefined;
    let usingIterator = GetMethod(source, wellKnownSymbols.iterator);

    if (usingIterator instanceof AbruptCompletion) {
      return usingIterator;
    }

    if (usingIterator instanceof Completion) {
      usingIterator = usingIterator.Value;
    }

    if (usingIterator !== Value.undefined) {
      let values = IterableToList(source, usingIterator);

      if (values instanceof AbruptCompletion) {
        return values;
      }

      if (values instanceof Completion) {
        values = values.Value;
      }

      const len = values.length;
      let targetObj = TypedArrayCreate(C, [new Value(len)]);

      if (targetObj instanceof AbruptCompletion) {
        return targetObj;
      }

      if (targetObj instanceof Completion) {
        targetObj = targetObj.Value;
      }

      let k = 0;

      while (k < len) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        const kValue = values.shift();
        let mappedValue;

        if (mapping) {
          mappedValue = Call(mapfn, T, [kValue, new Value(k)]);

          if (mappedValue instanceof AbruptCompletion) {
            return mappedValue;
          }

          if (mappedValue instanceof Completion) {
            mappedValue = mappedValue.Value;
          }
        } else {
          mappedValue = kValue;
        }

        {
          const hygienicTemp = Set$1(targetObj, Pk, mappedValue, Value.true);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        k += 1;
      }

      Assert(values.length === 0, "values.length === 0");
      return targetObj;
    } // NOTE: source is not an Iterable so assume it is already an array-like
    // object.


    let arrayLike = ToObject(source);
    Assert(!(arrayLike instanceof AbruptCompletion), "");

    if (arrayLike instanceof Completion) {
      arrayLike = arrayLike.Value;
    }

    let _hygienicTemp = LengthOfArrayLike(arrayLike);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const len = _hygienicTemp.numberValue();

    let targetObj = TypedArrayCreate(C, [new Value(len)]);

    if (targetObj instanceof AbruptCompletion) {
      return targetObj;
    }

    if (targetObj instanceof Completion) {
      targetObj = targetObj.Value;
    }

    let k = 0;

    while (k < len) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      let kValue = Get(arrayLike, Pk);

      if (kValue instanceof AbruptCompletion) {
        return kValue;
      }

      if (kValue instanceof Completion) {
        kValue = kValue.Value;
      }

      let mappedValue;

      if (mapping) {
        mappedValue = Call(mapfn, T, [kValue, new Value(k)]);

        if (mappedValue instanceof AbruptCompletion) {
          return mappedValue;
        }

        if (mappedValue instanceof Completion) {
          mappedValue = mappedValue.Value;
        }
      } else {
        mappedValue = kValue;
      }

      {
        const hygienicTemp = Set$1(targetObj, Pk, mappedValue, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      k += 1;
    }

    return targetObj;
  } // 22.2.2.2 #sec-%typedarray%.of


  function TypedArray_of(items, {
    thisValue
  }) {
    const len = items.length;
    const C = thisValue;

    if (IsConstructor(C) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAConstructor', C));
    }

    let newObj = TypedArrayCreate(C, [new Value(len)]);

    if (newObj instanceof AbruptCompletion) {
      return newObj;
    }

    if (newObj instanceof Completion) {
      newObj = newObj.Value;
    }

    let k = 0;

    while (k < len) {
      const kValue = items[k];
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      {
        const hygienicTemp = Set$1(newObj, Pk, kValue, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      k += 1;
    }

    return newObj;
  } // 22.2.2.4 #sec-get-%typedarray%-@@species


  function TypedArray_speciesGetter(args, {
    thisValue
  }) {
    return thisValue;
  }

  function CreateTypedArray(realmRec) {
    const typedArrayConstructor = BootstrapConstructor(realmRec, TypedArrayConstructor, 'TypedArray', 0, realmRec.Intrinsics['%TypedArrayPrototype%'], [['from', TypedArray_from, 1], ['of', TypedArray_of, 0], [wellKnownSymbols.species, [TypedArray_speciesGetter]]]);
    realmRec.Intrinsics['%TypedArray%'] = typedArrayConstructor;
  }

  function TypedArrayProto_bufferGetter(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'TypedArrayName');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
    const buffer = O.ViewedArrayBuffer;
    return buffer;
  } // 22.2.3.2 #sec-get-%typedarray%.prototype.bytelength


  function TypedArrayProto_byteLengthGetter(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'TypedArrayName');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return new Value(0);
    }

    const size = O.ByteLength;
    return size;
  } // 22.2.3.3 #sec-get-%typedarray%.prototype.byteoffset


  function TypedArrayProto_byteOffsetGetter(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'TypedArrayName');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return new Value(0);
    }

    const offset = O.ByteOffset;
    return offset;
  } // 22.2.3.5 #sec-%typedarray%.prototype.copywithin


  function TypedArrayProto_copyWithin([target = Value.undefined, start = Value.undefined, end], {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = ValidateTypedArray(O);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const len = O.ArrayLength.numberValue();

    let _hygienicTemp = ToInteger(target);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const relativeTarget = _hygienicTemp.numberValue();

    let to;

    if (relativeTarget < 0) {
      to = Math.max(len + relativeTarget, 0);
    } else {
      to = Math.min(relativeTarget, len);
    }

    let _hygienicTemp2 = ToInteger(start);

    if (_hygienicTemp2 instanceof AbruptCompletion) {
      return _hygienicTemp2;
    }

    if (_hygienicTemp2 instanceof Completion) {
      _hygienicTemp2 = _hygienicTemp2.Value;
    }

    const relativeStart = _hygienicTemp2.numberValue();

    let from;

    if (relativeStart < 0) {
      from = Math.max(len + relativeStart, 0);
    } else {
      from = Math.min(relativeStart, len);
    }

    let relativeEnd;

    if (end === undefined || end === Value.undefined) {
      relativeEnd = len;
    } else {
      let _hygienicTemp3 = ToInteger(end);

      if (_hygienicTemp3 instanceof AbruptCompletion) {
        return _hygienicTemp3;
      }

      if (_hygienicTemp3 instanceof Completion) {
        _hygienicTemp3 = _hygienicTemp3.Value;
      }

      relativeEnd = _hygienicTemp3.numberValue();
    }

    let final;

    if (relativeEnd < 0) {
      final = Math.max(len + relativeEnd, 0);
    } else {
      final = Math.min(relativeEnd, len);
    }

    const count = Math.min(final - from, len - to);

    if (count > 0) {
      // NOTE: The copying must be performed in a manner that preserves the
      // bit-level encoding of the source data.
      const buffer = O.ViewedArrayBuffer;

      if (IsDetachedBuffer(buffer)) {
        return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
      }

      const typedArrayName = O.TypedArrayName.stringValue();
      const elementSize = typedArrayInfo.get(typedArrayName).ElementSize;
      const byteOffset = O.ByteOffset.numberValue();
      let toByteIndex = to * elementSize + byteOffset;
      let fromByteIndex = from * elementSize + byteOffset;
      let countBytes = count * elementSize;
      let direction;

      if (fromByteIndex < toByteIndex && toByteIndex < fromByteIndex + countBytes) {
        direction = -1;
        fromByteIndex = fromByteIndex + countBytes - 1;
        toByteIndex = toByteIndex + countBytes - 1;
      } else {
        direction = 1;
      }

      while (countBytes > 0) {
        const value = GetValueFromBuffer(buffer, new Value(fromByteIndex), 'Uint8');
        SetValueInBuffer(buffer, new Value(toByteIndex), 'Uint8', value);
        fromByteIndex += direction;
        toByteIndex += direction;
        countBytes -= 1;
      }
    }

    return O;
  } // 22.2.3.6 #sec-%typedarray%.prototype.entries


  function TypedArrayProto_entries(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = ValidateTypedArray(O);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return CreateArrayIterator(O, 'key+value');
  } // 22.2.3.8 #sec-%typedarray%.prototype.fill


  function TypedArrayProto_fill([value = Value.undefined, start = Value.undefined, end = Value.undefined], {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = ValidateTypedArray(O);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const len = O.ArrayLength.numberValue();
    value = ToNumber(value);

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    let _hygienicTemp4 = ToInteger(start);

    if (_hygienicTemp4 instanceof AbruptCompletion) {
      return _hygienicTemp4;
    }

    if (_hygienicTemp4 instanceof Completion) {
      _hygienicTemp4 = _hygienicTemp4.Value;
    }

    const relativeStart = _hygienicTemp4.numberValue();

    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
    let relativeEnd;

    if (end === Value.undefined) {
      relativeEnd = len;
    } else {
      let _hygienicTemp5 = ToInteger(end);

      if (_hygienicTemp5 instanceof AbruptCompletion) {
        return _hygienicTemp5;
      }

      if (_hygienicTemp5 instanceof Completion) {
        _hygienicTemp5 = _hygienicTemp5.Value;
      }

      relativeEnd = _hygienicTemp5.numberValue();
    }

    const final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

    if (IsDetachedBuffer(O.ViewedArrayBuffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    while (k < final) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      Assert(!(Set$1(O, Pk, value, Value.true) instanceof AbruptCompletion), "");
      k += 1;
    }

    return O;
  } // 22.2.3.9 #sec-%typedarray%.prototype.filter


  function TypedArrayProto_filter([callbackfn = Value.undefined, thisArg], {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = ValidateTypedArray(O);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const len = O.ArrayLength.numberValue();

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', callbackfn));
    }

    let T;

    if (thisArg !== undefined) {
      T = thisArg;
    } else {
      T = Value.undefined;
    }

    const kept = [];
    let k = 0;
    let captured = 0;

    while (k < len) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      let kValue = Get(O, Pk);

      if (kValue instanceof AbruptCompletion) {
        return kValue;
      }

      if (kValue instanceof Completion) {
        kValue = kValue.Value;
      }

      let _hygienicTemp6 = Call(callbackfn, T, [kValue, new Value(k), O]);

      if (_hygienicTemp6 instanceof AbruptCompletion) {
        return _hygienicTemp6;
      }

      if (_hygienicTemp6 instanceof Completion) {
        _hygienicTemp6 = _hygienicTemp6.Value;
      }

      const selected = ToBoolean(_hygienicTemp6);

      if (selected === Value.true) {
        kept.push(kValue);
        captured += 1;
      }

      k += 1;
    }

    let A = TypedArraySpeciesCreate(O, [new Value(captured)]);

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    let n = 0;

    for (const e of kept) {
      let nStr = ToString(new Value(n));
      Assert(!(nStr instanceof AbruptCompletion), "");

      if (nStr instanceof Completion) {
        nStr = nStr.Value;
      }

      Assert(!(Set$1(A, nStr, e, Value.true) instanceof AbruptCompletion), "");
      n += 1;
    }

    return A;
  } // 22.2.3.16 #sec-%typedarray%.prototype.keys


  function TypedArrayProto_keys(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = ValidateTypedArray(O);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return CreateArrayIterator(O, 'key');
  } // 22.2.3.18 #sec-get-%typedarray%.prototype.length


  function TypedArrayProto_lengthGetter(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'TypedArrayName');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O && 'ArrayLength' in O, "'ViewedArrayBuffer' in O && 'ArrayLength' in O");
    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return new Value(0);
    }

    const length = O.ArrayLength;
    return length;
  } // 22.2.3.19 #sec-%typedarray%.prototype.map


  function TypedArrayProto_map([callbackfn = Value.undefined, thisArg], {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = ValidateTypedArray(O);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const len = O.ArrayLength;

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', callbackfn));
    }

    let T;

    if (thisArg !== undefined) {
      T = thisArg;
    } else {
      T = Value.undefined;
    }

    let A = TypedArraySpeciesCreate(O, [len]);

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    let k = 0;

    while (k < len.numberValue()) {
      let Pk = ToString(new Value(k));
      Assert(!(Pk instanceof AbruptCompletion), "");

      if (Pk instanceof Completion) {
        Pk = Pk.Value;
      }

      let kValue = Get(O, Pk);

      if (kValue instanceof AbruptCompletion) {
        return kValue;
      }

      if (kValue instanceof Completion) {
        kValue = kValue.Value;
      }

      let mappedValue = Call(callbackfn, T, [kValue, new Value(k), O]);

      if (mappedValue instanceof AbruptCompletion) {
        return mappedValue;
      }

      if (mappedValue instanceof Completion) {
        mappedValue = mappedValue.Value;
      }

      {
        const hygienicTemp = Set$1(A, Pk, mappedValue, Value.true);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      k += 1;
    }

    return A;
  } // 22.2.3.23 #sec-%typedarray%.prototype.set-overloaded-offset


  function TypedArrayProto_set([overloaded = Value.undefined, offset = Value.undefined], {
    thisValue
  }) {
    if (Type(overloaded) !== 'Object' || !('TypedArrayName' in overloaded)) {
      // 22.2.3.23.1 #sec-%typedarray%.prototype.set-array-offset
      const array = overloaded;
      const target = thisValue;
      {
        const hygienicTemp = RequireInternalSlot(target, 'TypedArrayName');

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      Assert('ViewedArrayBuffer' in target, "'ViewedArrayBuffer' in target");

      let _hygienicTemp7 = ToInteger(offset);

      if (_hygienicTemp7 instanceof AbruptCompletion) {
        return _hygienicTemp7;
      }

      if (_hygienicTemp7 instanceof Completion) {
        _hygienicTemp7 = _hygienicTemp7.Value;
      }

      const targetOffset = _hygienicTemp7.numberValue();

      if (targetOffset < 0) {
        return surroundingAgent.Throw('RangeError', msg('NegativeIndex', 'Offset'));
      }

      const targetBuffer = target.ViewedArrayBuffer;

      if (IsDetachedBuffer(targetBuffer)) {
        return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
      }

      const targetLength = target.ArrayLength.numberValue();
      const targetName = target.TypedArrayName.stringValue();
      const targetInfo = typedArrayInfo.get(targetName);
      const targetElementSize = targetInfo.ElementSize;
      const targetType = targetInfo.ElementType;
      const targetByteOffset = target.ByteOffset.numberValue();
      let src = ToObject(array);

      if (src instanceof AbruptCompletion) {
        return src;
      }

      if (src instanceof Completion) {
        src = src.Value;
      }

      let _hygienicTemp8 = LengthOfArrayLike(src);

      if (_hygienicTemp8 instanceof AbruptCompletion) {
        return _hygienicTemp8;
      }

      if (_hygienicTemp8 instanceof Completion) {
        _hygienicTemp8 = _hygienicTemp8.Value;
      }

      const srcLength = _hygienicTemp8.numberValue();

      if (srcLength + targetOffset > targetLength) {
        return surroundingAgent.Throw('RangeError', msg('TypedArrayOOB'));
      }

      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;
      let k = 0;
      const limit = targetByteIndex + targetElementSize * srcLength;

      while (targetByteIndex < limit) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kProp = Get(src, Pk);

        if (kProp instanceof AbruptCompletion) {
          return kProp;
        }

        if (kProp instanceof Completion) {
          kProp = kProp.Value;
        }

        let kNumber = ToNumber(kProp);

        if (kNumber instanceof AbruptCompletion) {
          return kNumber;
        }

        if (kNumber instanceof Completion) {
          kNumber = kNumber.Value;
        }

        if (IsDetachedBuffer(targetBuffer)) {
          return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
        }

        SetValueInBuffer(targetBuffer, new Value(targetByteIndex), targetType, kNumber);
        k += 1;
        targetByteIndex += targetElementSize;
      }

      return Value.undefined;
    } else {
      // 22.2.3.23.2 #sec-%typedarray%.prototype.set-typedarray-offset
      const typedArray = overloaded;
      Assert(Type(typedArray) === 'Object' && 'TypedArrayName' in typedArray, "Type(typedArray) === 'Object' && 'TypedArrayName' in typedArray");
      const target = thisValue;
      {
        const hygienicTemp = RequireInternalSlot(target, 'TypedArrayName');

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
      Assert('ViewedArrayBuffer' in target, "'ViewedArrayBuffer' in target");

      let _hygienicTemp9 = ToInteger(offset);

      if (_hygienicTemp9 instanceof AbruptCompletion) {
        return _hygienicTemp9;
      }

      if (_hygienicTemp9 instanceof Completion) {
        _hygienicTemp9 = _hygienicTemp9.Value;
      }

      const targetOffset = _hygienicTemp9.numberValue();

      if (targetOffset < 0) {
        return surroundingAgent.Throw('RangeError', msg('NegativeIndex', 'Offset'));
      }

      const targetBuffer = target.ViewedArrayBuffer;

      if (IsDetachedBuffer(targetBuffer)) {
        return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
      }

      const targetLength = target.ArrayLength.numberValue();
      let srcBuffer = typedArray.ViewedArrayBuffer;

      if (IsDetachedBuffer(srcBuffer)) {
        return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
      }

      const targetName = target.TypedArrayName.stringValue();
      const targetInfo = typedArrayInfo.get(targetName);
      const targetType = targetInfo.ElementType;
      const targetElementSize = targetInfo.ElementSize;
      const targetByteOffset = target.ByteOffset.numberValue();
      const srcName = typedArray.TypedArrayName.stringValue();
      const srcInfo = typedArrayInfo.get(srcName);
      const srcType = srcInfo.ElementType;
      const srcElementSize = srcInfo.ElementSize;
      const srcLength = typedArray.ArrayLength.numberValue();
      const srcByteOffset = typedArray.ByteOffset;

      if (srcLength + targetOffset > targetLength) {
        return surroundingAgent.Throw('RangeError', msg('TypedArrayOOB'));
      } // let same;
      // if (IsSharedArrayBuffer(srcBuffer) && IsSharedArrayBuffer(targetBuffer)) {
      //   same = ...
      // } else {


      const same = SameValue(srcBuffer, targetBuffer); // }

      let srcByteIndex;

      if (same === Value.true) {
        const srcByteLength = typedArray.ByteLength;
        srcBuffer = CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, surroundingAgent.intrinsic('%ArrayBuffer%'));

        if (srcBuffer instanceof AbruptCompletion) {
          return srcBuffer;
        }

        if (srcBuffer instanceof Completion) {
          srcBuffer = srcBuffer.Value;
        }

        srcByteIndex = new Value(0);
      } else {
        srcByteIndex = srcByteOffset;
      }

      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;
      const limit = targetByteIndex + targetElementSize * srcLength;

      if (SameValue(new Value(srcType), new Value(targetType)) === Value.true) {
        while (targetByteIndex < limit) {
          const value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'Uint8');
          SetValueInBuffer(targetBuffer, new Value(targetByteIndex), 'Uint8', value);
          srcByteIndex = new Value(srcByteIndex.numberValue() + 1);
          targetByteIndex += 1;
        }
      } else {
        while (targetByteIndex < limit) {
          const value = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType);
          SetValueInBuffer(targetBuffer, new Value(targetByteIndex), targetType, value);
          srcByteIndex = new Value(srcByteIndex.numberValue() + srcElementSize);
          targetByteIndex += targetElementSize;
        }
      }

      return Value.undefined;
    }
  } // 22.2.3.24 #sec-%typedarray%.prototype.slice


  function TypedArrayProto_slice([start = Value.undefined, end = Value.undefined], {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = ValidateTypedArray(O);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const len = O.ArrayLength.numberValue();

    let _hygienicTemp10 = ToInteger(start);

    if (_hygienicTemp10 instanceof AbruptCompletion) {
      return _hygienicTemp10;
    }

    if (_hygienicTemp10 instanceof Completion) {
      _hygienicTemp10 = _hygienicTemp10.Value;
    }

    const relativeStart = _hygienicTemp10.numberValue();

    let k;

    if (relativeStart < 0) {
      k = Math.max(len + relativeStart, 0);
    } else {
      k = Math.min(relativeStart, len);
    }

    let relativeEnd;

    if (end === Value.undefined) {
      relativeEnd = len;
    } else {
      let _hygienicTemp11 = ToInteger(end);

      if (_hygienicTemp11 instanceof AbruptCompletion) {
        return _hygienicTemp11;
      }

      if (_hygienicTemp11 instanceof Completion) {
        _hygienicTemp11 = _hygienicTemp11.Value;
      }

      relativeEnd = _hygienicTemp11.numberValue();
    }

    let final;

    if (relativeEnd < 0) {
      final = Math.max(len + relativeEnd, 0);
    } else {
      final = Math.min(relativeEnd, len);
    }

    const count = Math.max(final - k, 0);
    let A = TypedArraySpeciesCreate(O, [new Value(count)]);

    if (A instanceof AbruptCompletion) {
      return A;
    }

    if (A instanceof Completion) {
      A = A.Value;
    }

    const srcName = O.TypedArrayName.stringValue();
    const srcInfo = typedArrayInfo.get(srcName);
    const srcType = srcInfo.ElementType;
    const targetName = A.TypedArrayName.stringValue();
    const targetType = typedArrayInfo.get(targetName).ElementType;

    if (srcType !== targetType) {
      let n = 0;

      while (k < final) {
        let Pk = ToString(new Value(k));
        Assert(!(Pk instanceof AbruptCompletion), "");

        if (Pk instanceof Completion) {
          Pk = Pk.Value;
        }

        let kValue = Get(O, Pk);

        if (kValue instanceof AbruptCompletion) {
          return kValue;
        }

        if (kValue instanceof Completion) {
          kValue = kValue.Value;
        }

        let nStr = ToString(new Value(n));
        Assert(!(nStr instanceof AbruptCompletion), "");

        if (nStr instanceof Completion) {
          nStr = nStr.Value;
        }

        Assert(!(Set$1(A, nStr, kValue, Value.true) instanceof AbruptCompletion), "");
        k += 1;
        n += 1;
      }
    } else if (count > 0) {
      const srcBuffer = O.ViewedArrayBuffer;

      if (IsDetachedBuffer(srcBuffer)) {
        return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
      }

      const targetBuffer = A.ViewedArrayBuffer;
      const elementSize = srcInfo.ElementSize;
      const srcByteOffset = O.ByteOffset.numberValue();
      let targetByteIndex = A.ByteOffset.numberValue();
      let srcByteIndex = k * elementSize + srcByteOffset;
      const limit = targetByteIndex + count * elementSize;

      while (targetByteIndex < limit) {
        const value = GetValueFromBuffer(srcBuffer, new Value(srcByteIndex), 'Uint8');
        SetValueInBuffer(targetBuffer, new Value(targetByteIndex), 'Uint8', value);
        srcByteIndex += 1;
        targetByteIndex += 1;
      }
    }

    return A;
  } // 22.2.3.26 #sec-%typedarray%.prototype.sort


  function TypedArrayProto_sort([comparefn = Value.undefined], {
    thisValue
  }) {
    if (comparefn !== Value.undefined && IsCallable(comparefn) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', comparefn));
    }

    let obj = ToObject(thisValue);

    if (obj instanceof AbruptCompletion) {
      return obj;
    }

    if (obj instanceof Completion) {
      obj = obj.Value;
    }

    let buffer = ValidateTypedArray(obj);

    if (buffer instanceof AbruptCompletion) {
      return buffer;
    }

    if (buffer instanceof Completion) {
      buffer = buffer.Value;
    }

    const len = obj.ArrayLength;
    return ArrayProto_sortBody(obj, len, (x, y) => TypedArraySortCompare(x, y, comparefn, buffer), true);
  }

  function TypedArraySortCompare(x, y, comparefn, buffer) {
    Assert(Type(x) === 'Number', "Type(x) === 'Number'");
    Assert(Type(y) === 'Number', "Type(y) === 'Number'");

    if (comparefn !== Value.undefined) {
      let callRes = Call(comparefn, Value.undefined, [x, y]);

      if (callRes instanceof AbruptCompletion) {
        return callRes;
      }

      if (callRes instanceof Completion) {
        callRes = callRes.Value;
      }

      let v = ToNumber(callRes);

      if (v instanceof AbruptCompletion) {
        return v;
      }

      if (v instanceof Completion) {
        v = v.Value;
      }

      if (IsDetachedBuffer(buffer)) {
        return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
      }

      if (v.isNaN()) {
        return new Value(+0);
      }

      return v;
    }

    if (x.isNaN() && y.isNaN()) {
      return new Value(+0);
    }

    if (x.isNaN()) {
      return new Value(1);
    }

    if (y.isNaN()) {
      return new Value(-1);
    }

    x = x.numberValue();
    y = y.numberValue();

    if (x < y) {
      return new Value(-1);
    }

    if (x > y) {
      return new Value(1);
    }

    if (Object.is(x, -0) && Object.is(y, +0)) {
      return new Value(-1);
    }

    if (Object.is(x, +0) && Object.is(y, -0)) {
      return new Value(1);
    }

    return new Value(+0);
  } // 22.2.3.27 #sec-%typedarray%.prototype.subarray


  function TypedArrayProto_subarray([begin = Value.undefined, end], {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'TypedArrayName');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
    const buffer = O.ViewedArrayBuffer;
    const srcLength = O.ArrayLength.numberValue();

    let _hygienicTemp12 = ToInteger(begin);

    if (_hygienicTemp12 instanceof AbruptCompletion) {
      return _hygienicTemp12;
    }

    if (_hygienicTemp12 instanceof Completion) {
      _hygienicTemp12 = _hygienicTemp12.Value;
    }

    const relativeBegin = _hygienicTemp12.numberValue();

    let beginIndex;

    if (relativeBegin < 0) {
      beginIndex = Math.max(srcLength + relativeBegin, 0);
    } else {
      beginIndex = Math.min(relativeBegin, srcLength);
    }

    let relativeEnd;

    if (end === undefined || end === Value.undefined) {
      relativeEnd = srcLength;
    } else {
      let _hygienicTemp13 = ToInteger(end);

      if (_hygienicTemp13 instanceof AbruptCompletion) {
        return _hygienicTemp13;
      }

      if (_hygienicTemp13 instanceof Completion) {
        _hygienicTemp13 = _hygienicTemp13.Value;
      }

      relativeEnd = _hygienicTemp13.numberValue();
    }

    let endIndex;

    if (relativeEnd < 0) {
      endIndex = Math.max(srcLength + relativeEnd, 0);
    } else {
      endIndex = Math.min(relativeEnd, srcLength);
    }

    const newLength = Math.max(endIndex - beginIndex, 0);
    const constructorName = O.TypedArrayName.stringValue();
    const elementSize = typedArrayInfo.get(constructorName).ElementSize;
    const srcByteOffset = O.ByteOffset.numberValue();
    const beginByteOffset = srcByteOffset + beginIndex * elementSize;
    const argumentsList = [buffer, new Value(beginByteOffset), new Value(newLength)];
    return TypedArraySpeciesCreate(O, argumentsList);
  } // 22.2.3.30 #sec-%typedarray%.prototype.values


  function TypedArrayProto_values(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = ValidateTypedArray(O);

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    return CreateArrayIterator(O, 'value');
  } // 22.2.3.32 #sec-get-%typedarray%.prototype-@@tostringtag


  function TypedArrayProto_toStringTagGetter(args, {
    thisValue
  }) {
    const O = thisValue;

    if (Type(O) !== 'Object' || !('TypedArrayName' in O)) {
      return Value.undefined;
    }

    const name = O.TypedArrayName;
    Assert(Type(name) === 'String', "Type(name) === 'String'");
    return name;
  }

  function CreateTypedArrayPrototype(realmRec) {
    let ArrayProto_toString = Get(realmRec.Intrinsics['%ArrayPrototype%'], new Value('toString'));
    Assert(!(ArrayProto_toString instanceof AbruptCompletion), "");

    if (ArrayProto_toString instanceof Completion) {
      ArrayProto_toString = ArrayProto_toString.Value;
    }

    Assert(Type(ArrayProto_toString) === 'Object', "Type(ArrayProto_toString) === 'Object'");
    const proto = BootstrapPrototype(realmRec, [['buffer', [TypedArrayProto_bufferGetter]], ['byteLength', [TypedArrayProto_byteLengthGetter]], ['byteOffset', [TypedArrayProto_byteOffsetGetter]], ['copyWithin', TypedArrayProto_copyWithin, 2], ['entries', TypedArrayProto_entries, 0], ['fill', TypedArrayProto_fill, 1], ['filter', TypedArrayProto_filter, 1], ['keys', TypedArrayProto_keys, 0], ['length', [TypedArrayProto_lengthGetter]], ['map', TypedArrayProto_map, 1], ['set', TypedArrayProto_set, 1], ['slice', TypedArrayProto_slice, 2], ['sort', TypedArrayProto_sort, 1], ['subarray', TypedArrayProto_subarray, 2], ['values', TypedArrayProto_values, 0], ['toString', ArrayProto_toString], [wellKnownSymbols.toStringTag, [TypedArrayProto_toStringTagGetter]]], realmRec.Intrinsics['%ObjectPrototype%']);
    CreateArrayPrototypeShared(realmRec, proto, thisValue => {
      {
        const hygienicTemp = ValidateTypedArray(thisValue);

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }, O => O.ArrayLength); // 22.2.3.31 #sec-%typedarray%.prototype-@@iterator

    {
      let fn = Get(proto, new Value('values'));
      Assert(!(fn instanceof AbruptCompletion), "");

      if (fn instanceof Completion) {
        fn = fn.Value;
      }

      Assert(!(proto.DefineOwnProperty(wellKnownSymbols.iterator, Descriptor({
        Value: fn,
        Writable: Value.true,
        Enumerable: Value.false,
        Configurable: Value.true
      })) instanceof AbruptCompletion), "");
    }
    realmRec.Intrinsics['%TypedArrayPrototype%'] = proto;
  }

  function CreateTypedArrayConstructor(realmRec, TypedArray) {
    const info = typedArrayInfo.get(TypedArray);
    Assert(info !== undefined, "info !== undefined");

    function TypedArrayConstructor(args, {
      NewTarget
    }) {
      if (args.length === 0) {
        // 22.2.4.1 #sec-typedarray
        if (NewTarget === Value.undefined) {
          return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', TypedArray));
        }

        const constructorName = new Value(TypedArray);
        return AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}Prototype%`, new Value(0));
      } else if (Type(args[0]) !== 'Object') {
        // 22.2.4.2 #sec-typedarray-length
        const [length] = args;
        Assert(Type(length) !== 'Object', "Type(length) !== 'Object'");

        if (NewTarget === Value.undefined) {
          return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', TypedArray));
        }

        let elementLength = ToIndex(length);

        if (elementLength instanceof AbruptCompletion) {
          return elementLength;
        }

        if (elementLength instanceof Completion) {
          elementLength = elementLength.Value;
        }

        const constructorName = new Value(TypedArray);
        return AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}Prototype%`, elementLength);
      } else if ('TypedArrayName' in args[0]) {
        // 22.2.4.3 #sec-typedarray-typedarray
        const [typedArray] = args;
        Assert(Type(typedArray) === 'Object' && 'TypedArrayName' in typedArray, "Type(typedArray) === 'Object' && 'TypedArrayName' in typedArray");

        if (NewTarget === Value.undefined) {
          return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', TypedArray));
        }

        const constructorName = new Value(TypedArray);
        let O = AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}Prototype%`);

        if (O instanceof AbruptCompletion) {
          return O;
        }

        if (O instanceof Completion) {
          O = O.Value;
        }

        const srcArray = typedArray;
        const srcData = srcArray.ViewedArrayBuffer;

        if (IsDetachedBuffer(srcData)) {
          return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
        }

        const elementType = new Value(info.ElementType);
        const elementLength = srcArray.ArrayLength;
        const srcName = srcArray.TypedArrayName.stringValue();
        const srcInfo = typedArrayInfo.get(srcName);
        const srcType = new Value(srcInfo.ElementType);
        const srcElementSize = srcInfo.ElementSize;
        const srcByteOffset = srcArray.ByteOffset;
        const elementSize = info.ElementSize;
        const byteLength = new Value(elementSize * elementLength.numberValue()); // if (!IsSharedArrayBuffer(srcData)) {

        let bufferConstructor = SpeciesConstructor(srcData, surroundingAgent.intrinsic('%ArrayBuffer%'));

        if (bufferConstructor instanceof AbruptCompletion) {
          return bufferConstructor;
        }

        if (bufferConstructor instanceof Completion) {
          bufferConstructor = bufferConstructor.Value;
        }

        // } else {
        //   bufferConstructor = surroundingAgent.intrinsic('%ArrayBuffer%');
        // }
        let data;

        if (SameValue(elementType, srcType) === Value.true) {
          data = CloneArrayBuffer(srcData, srcByteOffset, byteLength, bufferConstructor);

          if (data instanceof AbruptCompletion) {
            return data;
          }

          if (data instanceof Completion) {
            data = data.Value;
          }
        } else {
          data = AllocateArrayBuffer(bufferConstructor, byteLength);

          if (data instanceof AbruptCompletion) {
            return data;
          }

          if (data instanceof Completion) {
            data = data.Value;
          }

          if (IsDetachedBuffer(srcData)) {
            return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
          }

          let srcByteIndex = srcByteOffset.numberValue();
          let targetByteIndex = 0;
          let count = elementLength.numberValue();

          while (count > 0) {
            const value = GetValueFromBuffer(srcData, new Value(srcByteIndex), srcType.stringValue());
            SetValueInBuffer(data, new Value(targetByteIndex), elementType.stringValue(), value);
            srcByteIndex += srcElementSize;
            targetByteIndex += elementSize;
            count -= 1;
          }
        }

        O.ViewedArrayBuffer = data;
        O.ByteLength = byteLength;
        O.ByteOffset = new Value(0);
        O.ArrayLength = elementLength;
        return O;
      } else if (!('TypedArrayName' in args[0]) && !('ArrayBufferData' in args[0])) {
        // 22.2.4.4 #sec-typedarray-object
        const [object] = args;
        Assert(Type(object) === 'Object' && !('TypedArrayName' in object) && !('ArrayBufferData' in object), "Type(object) === 'Object' && !('TypedArrayName' in object) && !('ArrayBufferData' in object)");

        if (NewTarget === Value.undefined) {
          return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', TypedArray));
        }

        const constructorName = new Value(TypedArray);
        let O = AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}Prototype%`);

        if (O instanceof AbruptCompletion) {
          return O;
        }

        if (O instanceof Completion) {
          O = O.Value;
        }

        let usingIterator = GetMethod(object, wellKnownSymbols.iterator);

        if (usingIterator instanceof AbruptCompletion) {
          return usingIterator;
        }

        if (usingIterator instanceof Completion) {
          usingIterator = usingIterator.Value;
        }

        if (usingIterator !== Value.undefined) {
          let values = IterableToList(object, usingIterator);

          if (values instanceof AbruptCompletion) {
            return values;
          }

          if (values instanceof Completion) {
            values = values.Value;
          }

          const len = values.length;
          {
            const hygienicTemp = AllocateTypedArrayBuffer(O, new Value(len));

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          let k = 0;

          while (k < len) {
            let Pk = ToString(new Value(k));
            Assert(!(Pk instanceof AbruptCompletion), "");

            if (Pk instanceof Completion) {
              Pk = Pk.Value;
            }

            const kValue = values.shift();
            {
              const hygienicTemp = Set$1(O, Pk, kValue, Value.true);

              if (hygienicTemp instanceof AbruptCompletion) {
                return hygienicTemp;
              }
            }
            k += 1;
          }

          Assert(values.length === 0, "values.length === 0");
          return O;
        }

        const arrayLike = object;
        let len = LengthOfArrayLike(arrayLike);

        if (len instanceof AbruptCompletion) {
          return len;
        }

        if (len instanceof Completion) {
          len = len.Value;
        }

        {
          const hygienicTemp = AllocateTypedArrayBuffer(O, len);

          if (hygienicTemp instanceof AbruptCompletion) {
            return hygienicTemp;
          }
        }
        let k = 0;

        while (k < len.numberValue()) {
          let Pk = ToString(new Value(k));
          Assert(!(Pk instanceof AbruptCompletion), "");

          if (Pk instanceof Completion) {
            Pk = Pk.Value;
          }

          let kValue = Get(arrayLike, Pk);

          if (kValue instanceof AbruptCompletion) {
            return kValue;
          }

          if (kValue instanceof Completion) {
            kValue = kValue.Value;
          }

          {
            const hygienicTemp = Set$1(O, Pk, kValue, Value.true);

            if (hygienicTemp instanceof AbruptCompletion) {
              return hygienicTemp;
            }
          }
          k += 1;
        }

        return O;
      } else {
        // 22.2.4.5 #sec-typedarray-buffer-byteoffset-length
        const [buffer, byteOffset = Value.undefined, length = Value.undefined] = args;
        Assert(Type(buffer) === 'Object' && 'ArrayBufferData' in buffer, "Type(buffer) === 'Object' && 'ArrayBufferData' in buffer");

        if (NewTarget === Value.undefined) {
          return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', TypedArray));
        }

        const constructorName = new Value(TypedArray);
        let O = AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}Prototype%`);

        if (O instanceof AbruptCompletion) {
          return O;
        }

        if (O instanceof Completion) {
          O = O.Value;
        }

        const elementSize = info.ElementSize;
        let offset = ToIndex(byteOffset);

        if (offset instanceof AbruptCompletion) {
          return offset;
        }

        if (offset instanceof Completion) {
          offset = offset.Value;
        }

        if (offset.numberValue() % elementSize !== 0) {
          return surroundingAgent.Throw('RangeError', msg('TypedArrayOffsetAlignment', TypedArray, elementSize));
        }

        let newLength;

        if (length !== undefined && length !== Value.undefined) {
          let _hygienicTemp = ToIndex(length);

          if (_hygienicTemp instanceof AbruptCompletion) {
            return _hygienicTemp;
          }

          if (_hygienicTemp instanceof Completion) {
            _hygienicTemp = _hygienicTemp.Value;
          }

          newLength = _hygienicTemp.numberValue();
        }

        if (IsDetachedBuffer(buffer)) {
          return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
        }

        const bufferByteLength = buffer.ArrayBufferByteLength.numberValue();
        let newByteLength;

        if (length === undefined || length === Value.undefined) {
          if (bufferByteLength % elementSize !== 0) {
            return surroundingAgent.Throw('RangeError', msg('TypedArrayLengthAlignment', TypedArray, elementSize));
          }

          newByteLength = bufferByteLength - offset.numberValue();

          if (newByteLength < 0) {
            return surroundingAgent.Throw('RangeError', msg('TypedArrayCreationOOB'));
          }
        } else {
          newByteLength = newLength * elementSize;

          if (offset.numberValue() + newByteLength > bufferByteLength) {
            return surroundingAgent.Throw('RangeError', msg('TypedArrayCreationOOB'));
          }
        }

        O.ViewedArrayBuffer = buffer;
        O.ByteLength = new Value(newByteLength);
        O.ByteOffset = offset;
        Assert(Number.isSafeInteger(newByteLength / elementSize), "Number.isSafeInteger(newByteLength / elementSize)");
        O.ArrayLength = new Value(newByteLength / elementSize);
        return O;
      }
    }

    const readonly = {
      Writable: Value.false,
      Configurable: Value.false
    };
    const taConstructor = BootstrapConstructor(realmRec, TypedArrayConstructor, TypedArray, 3, realmRec.Intrinsics[`%${TypedArray}Prototype%`], [['BYTES_PER_ELEMENT', new Value(info.ElementSize), undefined, readonly]]);
    Assert(!(taConstructor.SetPrototypeOf(realmRec.Intrinsics['%TypedArray%']) instanceof AbruptCompletion), "");
    realmRec.Intrinsics[`%${TypedArray}%`] = taConstructor;
  }

  function CreateTypedArrayConstructors(realmRec) {
    for (const TypedArray of typedArrayInfo.keys()) {
      CreateTypedArrayConstructor(realmRec, TypedArray);
    }
  }

  function CreateTypedArrayPrototype$1(realmRec, TypedArray) {
    const info = typedArrayInfo.get(TypedArray);
    Assert(info !== undefined, "info !== undefined");
    const readonly = {
      Writable: Value.false,
      Configurable: Value.false
    };
    const proto = BootstrapPrototype(realmRec, [['BYTES_PER_ELEMENT', new Value(info.ElementSize), undefined, readonly]], realmRec.Intrinsics['%TypedArrayPrototype%']);
    realmRec.Intrinsics[`%${TypedArray}Prototype%`] = proto;
  }

  function CreateTypedArrayPrototypes(realmRec) {
    for (const TypedArray of typedArrayInfo.keys()) {
      CreateTypedArrayPrototype$1(realmRec, TypedArray);
    }
  }

  function DataViewConstructor([buffer = Value.undefined, byteOffset = Value.undefined, byteLength = Value.undefined], {
    NewTarget
  }) {
    if (Type(NewTarget) === 'Undefined') {
      return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', 'DataView'));
    }

    {
      const hygienicTemp = RequireInternalSlot(buffer, 'ArrayBufferData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    let _hygienicTemp = ToIndex(byteOffset);

    if (_hygienicTemp instanceof AbruptCompletion) {
      return _hygienicTemp;
    }

    if (_hygienicTemp instanceof Completion) {
      _hygienicTemp = _hygienicTemp.Value;
    }

    const offset = _hygienicTemp.numberValue();

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const bufferByteLength = buffer.ArrayBufferByteLength.numberValue();

    if (offset > bufferByteLength) {
      return surroundingAgent.Throw('RangeError', msg('DataViewOOB'));
    }

    let viewByteLength;

    if (byteLength === Value.undefined) {
      viewByteLength = bufferByteLength - offset;
    } else {
      let _hygienicTemp2 = ToIndex(byteLength);

      if (_hygienicTemp2 instanceof AbruptCompletion) {
        return _hygienicTemp2;
      }

      if (_hygienicTemp2 instanceof Completion) {
        _hygienicTemp2 = _hygienicTemp2.Value;
      }

      viewByteLength = _hygienicTemp2.numberValue();

      if (offset + viewByteLength > bufferByteLength) {
        return surroundingAgent.Throw('RangeError', msg('DataViewOOB'));
      }
    }

    let O = OrdinaryCreateFromConstructor(NewTarget, '%DataViewPrototype%', ['DataView', 'ViewedArrayBuffer', 'ByteLength', 'ByteOffset']);

    if (O instanceof AbruptCompletion) {
      return O;
    }

    if (O instanceof Completion) {
      O = O.Value;
    }

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    O.ViewedArrayBuffer = buffer;
    O.ByteLength = new Value(viewByteLength);
    O.ByteOffset = new Value(offset);
    return O;
  }

  function CreateDataView(realmRec) {
    const dvConstructor = BootstrapConstructor(realmRec, DataViewConstructor, 'DataView', 1, realmRec.Intrinsics['%DataViewPrototype%'], []);
    realmRec.Intrinsics['%DataView%'] = dvConstructor;
  }

  function DataViewProto_bufferGetter(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'DataView');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
    const buffer = O.ViewedArrayBuffer;
    return buffer;
  } // 24.3.4.2 #sec-get-dataview.prototype.bytelength


  function DataViewProto_byteLengthGetter(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'DataView');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const size = O.ByteLength;
    return size;
  } // 24.3.4.3 #sec-get-dataview.prototype.byteoffset


  function DataViewProto_byteOffsetGetter(args, {
    thisValue
  }) {
    const O = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(O, 'DataView');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', msg('BufferDetached'));
    }

    const offset = O.ByteOffset;
    return offset;
  } // 24.3.4.5 #sec-dataview.prototype.getfloat32


  function DataViewProto_getFloat32([byteOffset = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return GetViewValue(v, byteOffset, littleEndian, 'Float32');
  } // 24.3.4.6 #sec-dataview.prototype.getfloat64


  function DataViewProto_getFloat64([byteOffset = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return GetViewValue(v, byteOffset, littleEndian, 'Float64');
  } // 24.3.4.7 #sec-dataview.prototype.getint8


  function DataViewProto_getInt8([byteOffset = Value.undefined], {
    thisValue
  }) {
    const v = thisValue;
    return GetViewValue(v, byteOffset, Value.true, 'Int8');
  } // 24.3.4.8 #sec-dataview.prototype.getint16


  function DataViewProto_getInt16([byteOffset = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return GetViewValue(v, byteOffset, littleEndian, 'Int16');
  } // 24.3.4.9 #sec-dataview.prototype.getint32


  function DataViewProto_getInt32([byteOffset = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return GetViewValue(v, byteOffset, littleEndian, 'Int32');
  } // 24.3.4.10 #sec-dataview.prototype.getuint8


  function DataViewProto_getUint8([byteOffset = Value.undefined], {
    thisValue
  }) {
    const v = thisValue;
    return GetViewValue(v, byteOffset, Value.true, 'Uint8');
  } // 24.3.4.11 #sec-dataview.prototype.getuint16


  function DataViewProto_getUint16([byteOffset = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return GetViewValue(v, byteOffset, littleEndian, 'Uint16');
  } // 24.3.4.12 #sec-dataview.prototype.getuint32


  function DataViewProto_getUint32([byteOffset = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return GetViewValue(v, byteOffset, littleEndian, 'Uint32');
  } // 24.3.4.13 #sec-dataview.prototype.setfloat32


  function DataViewProto_setFloat32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return SetViewValue(v, byteOffset, littleEndian, 'Float32', value);
  } // 24.3.4.14 #sec-dataview.prototype.setfloat64


  function DataViewProto_setFloat64([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return SetViewValue(v, byteOffset, littleEndian, 'Float64', value);
  } // 24.3.4.15 #sec-dataview.prototype.setint8


  function DataViewProto_setInt8([byteOffset = Value.undefined, value = Value.undefined], {
    thisValue
  }) {
    const v = thisValue;
    return SetViewValue(v, byteOffset, Value.true, 'Int8', value);
  } // 24.3.4.16 #sec-dataview.prototype.setint16


  function DataViewProto_setInt16([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return SetViewValue(v, byteOffset, littleEndian, 'Int16', value);
  } // 24.3.4.17 #sec-dataview.prototype.setint32


  function DataViewProto_setInt32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return SetViewValue(v, byteOffset, littleEndian, 'Int32', value);
  } // 24.3.4.18 #sec-dataview.prototype.setuint8


  function DataViewProto_setUint8([byteOffset = Value.undefined, value = Value.undefined], {
    thisValue
  }) {
    const v = thisValue;
    return SetViewValue(v, byteOffset, Value.true, 'Uint8', value);
  } // 24.3.4.19 #sec-dataview.prototype.setuint16


  function DataViewProto_setUint16([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return SetViewValue(v, byteOffset, littleEndian, 'Uint16', value);
  } // 24.3.4.20 #sec-dataview.prototype.setuint32


  function DataViewProto_setUint32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
    thisValue
  }) {
    const v = thisValue;

    if (littleEndian === undefined) {
      littleEndian = Value.false;
    }

    return SetViewValue(v, byteOffset, littleEndian, 'Uint32', value);
  }

  function CreateDataViewPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['buffer', [DataViewProto_bufferGetter]], ['byteLength', [DataViewProto_byteLengthGetter]], ['byteOffset', [DataViewProto_byteOffsetGetter]], ['getFloat32', DataViewProto_getFloat32, 1], ['getFloat64', DataViewProto_getFloat64, 1], ['getInt8', DataViewProto_getInt8, 1], ['getInt16', DataViewProto_getInt16, 1], ['getInt32', DataViewProto_getInt32, 1], ['getUint8', DataViewProto_getUint8, 1], ['getUint16', DataViewProto_getUint16, 1], ['getUint32', DataViewProto_getUint32, 1], ['setFloat32', DataViewProto_setFloat32, 2], ['setFloat64', DataViewProto_setFloat64, 2], ['setInt8', DataViewProto_setInt8, 2], ['setInt16', DataViewProto_setInt16, 2], ['setInt32', DataViewProto_setInt32, 2], ['setUint8', DataViewProto_setUint8, 2], ['setUint16', DataViewProto_setUint16, 2], ['setUint32', DataViewProto_setUint32, 2]], realmRec.Intrinsics['%ObjectPrototype%'], 'DataView');
    realmRec.Intrinsics['%DataViewPrototype%'] = proto;
  }

  class FakeWeakRef {
    constructor(target) {
      if (new.target === undefined) {
        throw new TypeError(msg('ConstructorRequiresNew', 'WeakRef'));
      }

      if (target === null || typeof target !== 'object' && typeof target !== 'function') {
        throw new TypeError(msg('NotAnObject'));
      }

      this.target = target;
    }

    deref() {
      return this.target;
    }

  }

  const ActualWeakRef = typeof WeakRef === 'function' ? WeakRef : FakeWeakRef;

  class WeakSetData {
    constructor() {
      this.data = [];
    }

    push(value) {
      Assert(Type(value) === 'Object', "Type(value) === 'Object'");
      this.data.push(new ActualWeakRef(value));
    }

    remove(i) {
      this.data[i] = undefined;
    }

    *entries() {
      for (let i = 0; i < this.data.length; i += 1) {
        let e = this.data[i];

        if (e !== undefined) {
          e = e.deref();
        }

        if (e === undefined) {
          this.data[i] = undefined;
        }

        yield [i, e];
      }
    }

    *[Symbol.iterator]() {
      for (const [, e] of this.entries()) {
        yield e;
      }
    }

  } // 23.4.1.1 #sec-weakset-iterable


  function WeakSetConstructor([iterable], {
    NewTarget
  }) {
    if (NewTarget === Value.undefined) {
      return surroundingAgent.Throw('TypeError', msg('ConstructorRequiresNew', 'WeakSet'));
    }

    let set = OrdinaryCreateFromConstructor(NewTarget, '%WeakSetPrototype%', ['WeakSetData']);

    if (set instanceof AbruptCompletion) {
      return set;
    }

    if (set instanceof Completion) {
      set = set.Value;
    }

    set.WeakSetData = new WeakSetData();

    if (iterable === undefined || iterable === Value.undefined || iterable === Value.null) {
      return set;
    }

    let adder = Get(set, new Value('add'));

    if (adder instanceof AbruptCompletion) {
      return adder;
    }

    if (adder instanceof Completion) {
      adder = adder.Value;
    }

    if (IsCallable(adder) === Value.false) {
      return surroundingAgent.Throw('TypeError', msg('NotAFunction', adder));
    }

    let iteratorRecord = GetIterator(iterable);

    if (iteratorRecord instanceof AbruptCompletion) {
      return iteratorRecord;
    }

    if (iteratorRecord instanceof Completion) {
      iteratorRecord = iteratorRecord.Value;
    }

    while (true) {
      let next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        return set;
      }

      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      const status = Call(adder, set, [nextValue]);

      if (status instanceof AbruptCompletion) {
        return IteratorClose(iteratorRecord, status);
      }
    }
  }

  function CreateWeakSet(realmRec) {
    const weakSetConstructor = BootstrapConstructor(realmRec, WeakSetConstructor, 'WeakSet', 0, realmRec.Intrinsics['%WeakSetPrototype%']);
    realmRec.Intrinsics['%WeakSet%'] = weakSetConstructor;
  }

  function WeakSetProto_add([value = Value.undefined], {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'WeakSetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (Type(value) !== 'Object') {
      return surroundingAgent.Throw('TypeError', msg('NotAnObject', value));
    }

    const entries = S.WeakSetData;

    for (const e of entries) {
      if (e !== undefined && SameValue(e, value) === Value.true) {
        return S;
      }
    }

    entries.push(value);
    return S;
  } // 23.4.3.3 #sec-weakset.prototype.delete


  function WeakSetProto_delete([value = Value.undefined], {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'WeakSetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }

    if (Type(value) !== 'Object') {
      return Value.false;
    }

    const entries = S.WeakSetData;

    for (const [i, e] of entries.entries()) {
      if (e !== undefined && SameValue(e, value) === Value.true) {
        entries.remove(i);
        return Value.true;
      }
    }

    return Value.false;
  } // 23.4.3.4 #sec-weakset.prototype.has


  function WeakSetProto_has([value = Value.undefined], {
    thisValue
  }) {
    const S = thisValue;
    {
      const hygienicTemp = RequireInternalSlot(S, 'WeakSetData');

      if (hygienicTemp instanceof AbruptCompletion) {
        return hygienicTemp;
      }
    }
    const entries = S.WeakSetData;

    for (const e of entries) {
      if (e !== undefined && SameValue(e, value) === Value.true) {
        return Value.true;
      }
    }

    return Value.false;
  }

  function CreateWeakSetPrototype(realmRec) {
    const proto = BootstrapPrototype(realmRec, [['add', WeakSetProto_add, 1], ['delete', WeakSetProto_delete, 1], ['has', WeakSetProto_has, 1]], realmRec.Intrinsics['%ObjectPrototype%'], 'WeakSet');
    realmRec.Intrinsics['%WeakSetPrototype%'] = proto;
  }

  class Realm {
    constructor() {
      this.Intrinsics = undefined;
      this.GlobalObject = undefined;
      this.GlobalEnv = undefined;
      this.TemplateMap = undefined;
      this.HostDefined = undefined;
    }

  } // 8.2.1 #sec-createrealm

  function CreateRealm() {
    const realmRec = new Realm();
    CreateIntrinsics(realmRec);
    realmRec.GlobalObject = Value.undefined;
    realmRec.GlobalEnv = Value.undefined;
    realmRec.TemplateMap = [];
    return realmRec;
  }

  function AddRestrictedFunctionProperties(F, realm) {
    Assert(realm.Intrinsics['%ThrowTypeError%'], "realm.Intrinsics['%ThrowTypeError%']");
    const thrower = realm.Intrinsics['%ThrowTypeError%'];
    Assert(!(DefinePropertyOrThrow(F, new Value('caller'), Descriptor({
      Get: thrower,
      Set: thrower,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
    Assert(!(DefinePropertyOrThrow(F, new Value('arguments'), Descriptor({
      Get: thrower,
      Set: thrower,
      Enumerable: Value.false,
      Configurable: Value.true
    })) instanceof AbruptCompletion), "");
  } // 8.2.2 #sec-createintrinsics


  function CreateIntrinsics(realmRec) {
    const intrinsics = Object.create(null);
    realmRec.Intrinsics = intrinsics;
    const objProto = ObjectCreate(Value.null);
    intrinsics['%ObjectPrototype%'] = objProto;
    let thrower = CreateBuiltinFunction(() => surroundingAgent.Throw('TypeError', 'The caller, callee, and arguments properties may' + ' not be accessed on strict mode functions or the arguments objects for calls to them'), [], realmRec, Value.null);
    Assert(!(thrower instanceof AbruptCompletion), "");

    if (thrower instanceof Completion) {
      thrower = thrower.Value;
    }

    thrower.DefineOwnProperty(new Value('length'), Descriptor({
      Value: new Value(0),
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    intrinsics['%ThrowTypeError%'] = thrower;
    const funcProto = CreateBuiltinFunction(() => Value.undefined, [], realmRec, objProto);
    SetFunctionLength(funcProto, new Value(0));
    SetFunctionName(funcProto, new Value(''));
    intrinsics['%FunctionPrototype%'] = funcProto;
    thrower.SetPrototypeOf(funcProto);
    AddRestrictedFunctionProperties(funcProto, realmRec);
    CreateEval(realmRec);
    CreateIsFinite(realmRec);
    CreateIsNaN(realmRec);
    CreateParseFloat(realmRec);
    CreateParseInt(realmRec);
    CreateObjectPrototype(realmRec);
    CreateObject(realmRec);
    CreateErrorPrototype(realmRec);
    CreateError(realmRec);
    CreateNativeError(realmRec);
    CreateFunction(realmRec);
    CreateFunctionPrototype(realmRec);
    CreateIteratorPrototype(realmRec);
    CreateAsyncIteratorPrototype(realmRec);
    CreateArrayIteratorPrototype(realmRec);
    CreateMapIteratorPrototype(realmRec);
    CreateSetIteratorPrototype(realmRec);
    CreateStringIteratorPrototype(realmRec);
    CreateRegExpStringIteratorPrototype(realmRec);
    CreateStringPrototype(realmRec);
    CreateString(realmRec);
    CreateArrayPrototype(realmRec);
    CreateArray(realmRec);
    CreateBooleanPrototype(realmRec);
    CreateBoolean(realmRec);
    CreateNumberPrototype(realmRec);
    CreateNumber(realmRec);
    CreateSymbolPrototype(realmRec);
    CreateSymbol(realmRec);
    CreatePromisePrototype(realmRec);
    CreatePromise(realmRec);
    CreateProxy(realmRec);
    CreateReflect(realmRec);
    CreateMath(realmRec);
    CreateDatePrototype(realmRec);
    CreateDate(realmRec);
    CreateRegExpPrototype(realmRec);
    CreateRegExp(realmRec);
    CreateSetPrototype(realmRec);
    CreateSet(realmRec);
    CreateMapPrototype(realmRec);
    CreateMap(realmRec);
    CreateGeneratorPrototype(realmRec);
    CreateGenerator(realmRec);
    CreateGeneratorFunction(realmRec);
    CreateAsyncFunctionPrototype(realmRec);
    CreateAsyncFunction(realmRec);
    CreateAsyncGeneratorPrototype(realmRec);
    CreateAsyncGenerator(realmRec);
    CreateAsyncGeneratorFunction(realmRec);
    CreateAsyncFromSyncIteratorPrototype(realmRec);
    CreateArrayBufferPrototype(realmRec);
    CreateArrayBuffer(realmRec);
    CreateTypedArrayPrototype(realmRec);
    CreateTypedArray(realmRec);
    CreateTypedArrayPrototypes(realmRec);
    CreateTypedArrayConstructors(realmRec);
    CreateDataViewPrototype(realmRec);
    CreateDataView(realmRec);
    CreateWeakSetPrototype(realmRec);
    CreateWeakSet(realmRec);
    CreateJSON(realmRec);
    return intrinsics;
  } // 8.2.3 #sec-setrealmglobalobject

  function SetRealmGlobalObject(realmRec, globalObj, thisValue) {
    const intrinsics = realmRec.Intrinsics;

    if (globalObj === Value.undefined) {
      globalObj = ObjectCreate(intrinsics['%ObjectPrototype%']);
    }

    if (thisValue === Value.undefined) {
      thisValue = globalObj;
    }

    if (surroundingAgent.feature('globalThis')) {
      intrinsics['%GlobalThisValue%'] = thisValue;
    }

    realmRec.GlobalObject = globalObj;
    const newGlobalEnv = NewGlobalEnvironment(globalObj, thisValue);
    realmRec.GlobalEnv = newGlobalEnv;
    return realmRec;
  } // 8.2.4 #sec-setdefaultglobalbindings

  function SetDefaultGlobalBindings(realmRec) {
    const global = realmRec.GlobalObject; // Value Properties of the Global Object

    [['Infinity', new Value(Infinity)], ['NaN', new Value(NaN)], ['undefined', Value.undefined]].forEach(([name, value]) => {
      {
        const hygienicTemp = DefinePropertyOrThrow(global, new Value(name), Descriptor({
          Value: value,
          Writable: Value.false,
          Enumerable: Value.false,
          Configurable: Value.false
        }));

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    });
    [// Function Properties of the Global Object
    'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', // 'decodeURI',
    // 'decodeURIComponent',
    // 'encodeURI',
    // 'encodeURIComponent',
    // Constructor Properties of the Global Object
    'Array', 'ArrayBuffer', 'Boolean', 'DataView', 'Date', 'Error', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Number', 'Object', 'Promise', 'Proxy', 'RangeError', 'ReferenceError', 'RegExp', 'Set', // 'SharedArrayBuffer',
    'String', 'Symbol', 'SyntaxError', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'URIError', // 'WeakMap',
    'WeakSet', // Other Properties of the Global Object
    // 'Atomics',
    'JSON', 'Math', 'Reflect'].forEach(name => {
      {
        const hygienicTemp = DefinePropertyOrThrow(global, new Value(name), Descriptor({
          Value: realmRec.Intrinsics[`%${name}%`],
          Writable: Value.true,
          Enumerable: Value.false,
          Configurable: Value.true
        }));

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    });

    if (surroundingAgent.feature('globalThis')) {
      {
        const hygienicTemp = DefinePropertyOrThrow(global, new Value('globalThis'), Descriptor({
          Value: realmRec.Intrinsics['%GlobalThisValue%'],
          Writable: Value.true,
          Enumerable: Value.false,
          Configurable: Value.true
        }));

        if (hygienicTemp instanceof AbruptCompletion) {
          return hygienicTemp;
        }
      }
    }

    return global;
  }

  const Abstract = { ...AbstractOps,
    Type
  };
  const {
    ObjectCreate: ObjectCreate$1,
    CreateBuiltinFunction: CreateBuiltinFunction$1,
    Assert: Assert$1,
    InnerModuleEvaluation: InnerModuleEvaluation$1,
    GetModuleNamespace: GetModuleNamespace$1
  } = Abstract;
  function initializeAgent(options = {}) {
    if (surroundingAgent) {
      throw new Error('Surrounding Agent is already initialized');
    }

    const agent = new Agent(options);
    setSurroundingAgent(agent);
  }

  function runJobQueue() {
    while (true) {
      // eslint-disable-line no-constant-condition
      const nextQueue = surroundingAgent.jobQueue;

      if (nextQueue.length === 0) {
        break;
      }

      const nextPending = nextQueue.shift();
      const newContext = new ExecutionContext();
      newContext.Function = Value.null;
      newContext.Realm = nextPending.Realm;
      newContext.ScriptOrModule = nextPending.ScriptOrModule;
      surroundingAgent.executionContextStack.push(newContext);
      const result = nextPending.Job(...nextPending.Arguments);
      surroundingAgent.executionContextStack.pop(newContext);

      if (result instanceof AbruptCompletion) {
        HostReportErrors(result.Value);
      }
    }
  }

  class APIRealm {
    constructor(options = {}) {
      const realm = CreateRealm();
      realm.HostDefined = options;
      const newContext = new ExecutionContext();
      newContext.Function = Value.null;
      newContext.Realm = realm;
      newContext.ScriptOrModule = Value.null;
      surroundingAgent.executionContextStack.push(newContext);
      const global = Value.undefined;
      const thisValue = Value.undefined;
      SetRealmGlobalObject(realm, global, thisValue);
      const globalObj = SetDefaultGlobalBindings(realm); // Create any implementation-defined global object properties on globalObj.

      surroundingAgent.executionContextStack.pop(newContext);
      this.global = globalObj;
      this.realm = realm;
      this.context = newContext;
      this.agent = surroundingAgent;
      this.active = false;
    }

    evaluateScript(sourceText, {
      specifier
    } = {}) {
      if (typeof sourceText !== 'string') {
        throw new TypeError('sourceText must be a string');
      }

      return this.scope(() => {
        // BEGIN ScriptEvaluationJob
        const realm = surroundingAgent.currentRealmRecord;
        const s = ParseScript(sourceText, realm, {
          specifier,
          public: {
            specifier
          }
        });

        if (Array.isArray(s)) {
          return new ThrowCompletion(s[0]);
        } // END ScriptEvaluationJob


        let res = ScriptEvaluation(s);

        if (res instanceof AbruptCompletion) {
          return res;
        }

        if (res instanceof Completion) {
          res = res.Value;
        }

        runJobQueue();
        return EnsureCompletion(res);
      });
    }

    createSourceTextModule(specifier, sourceText) {
      if (typeof sourceText !== 'string') {
        throw new TypeError('sourceText must be a string');
      }

      if (typeof specifier !== 'string') {
        throw new TypeError('specifier must be a string');
      }

      const module = this.scope(() => ParseModule(sourceText, this.realm, {
        specifier,
        public: {
          specifier,
          Link: () => this.scope(() => module.Link()),
          GetNamespace: () => this.scope(() => GetModuleNamespace$1(module)),
          Evaluate: () => this.scope(() => {
            Assert$1(module.Status === 'linked', "module.Status === 'linked'");
            const stack = [];
            let index = 0; // InnerModuleEvaluation

            module.Status = 'evaluating';
            module.DFSIndex = index;
            module.DFSAncestorIndex = index;
            stack.push(module);

            for (const required of module.RequestedModules) {
              let requiredModule = HostResolveImportedModule(module, required);
              Assert$1(!(requiredModule instanceof AbruptCompletion), "");

              if (requiredModule instanceof Completion) {
                requiredModule = requiredModule.Value;
              }

              index = InnerModuleEvaluation$1(requiredModule, stack, index);

              if (index instanceof AbruptCompletion) {
                return index;
              }

              if (index instanceof Completion) {
                index = index.Value;
              }

              if (requiredModule instanceof CyclicModuleRecord) {
                Assert$1(requiredModule.Status === 'evaluating' || requiredModule.Status === 'evaluated', "requiredModule.Status === 'evaluating' || requiredModule.Status === 'evaluated'");

                if (stack.includes(requiredModule)) {
                  Assert$1(requiredModule.Status === 'evaluating', "requiredModule.Status === 'evaluating'");
                }

                if (requiredModule.Status === 'evaluating') {
                  module.DFSAncestorIndex = Math.min(module.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
                }
              }
            }

            let result = module.ExecuteModule();

            if (result instanceof AbruptCompletion) {
              return result;
            }

            if (result instanceof Completion) {
              result = result.Value;
            }

            Assert$1(stack.indexOf(module) === stack.lastIndexOf(module), "stack.indexOf(module) === stack.lastIndexOf(module)");
            Assert$1(module.DFSAncestorIndex <= module.DFSIndex, "module.DFSAncestorIndex <= module.DFSIndex");

            if (module.DFSAncestorIndex === module.DFSIndex) {
              let done = false;

              while (done === false) {
                const requiredModule = stack.pop();
                Assert$1(requiredModule instanceof CyclicModuleRecord, "requiredModule instanceof CyclicModuleRecord");
                requiredModule.Status = 'evaluated';

                if (requiredModule === module) {
                  done = true;
                }
              }
            } // END InnerModuleEvaluation
            // Source Text Module Record Evaluate()


            if (result instanceof AbruptCompletion) {
              for (const m of stack) {
                Assert$1(m.Status === 'evaluating', "m.Status === 'evaluating'");
                m.Status = 'evaluated';
                m.EvaluationError = result;
              }

              Assert$1(module.Status === 'evaluated' && module.EvaluationError === result, "module.Status === 'evaluated' && module.EvaluationError === result");
              return result;
            }

            Assert$1(module.Status === 'evaluated' && module.EvaluationError === Value.undefined, "module.Status === 'evaluated' && module.EvaluationError === Value.undefined");
            Assert$1(stack.length === 0, "stack.length === 0");
            runJobQueue();
            return result;
          })
        }
      }));

      if (Array.isArray(module)) {
        return new ThrowCompletion(module[0]);
      }

      module.HostDefined.public.module = module;
      return module.HostDefined.public;
    }

    scope(cb) {
      if (this.active) {
        return cb();
      }

      this.active = true;
      surroundingAgent.executionContextStack.push(this.context);
      const res = cb();
      surroundingAgent.executionContextStack.pop(this.context);
      this.active = false;
      return res;
    }

  }

  function APIObject(realm, intrinsic = '%ObjectPrototype%') {
    return ObjectCreate$1(realm.realm.Intrinsics[intrinsic]);
  }

  class APIValue extends Value {
    constructor(realm, value) {
      if (typeof value === 'function') {
        return CreateBuiltinFunction$1(value, [], realm.realm);
      }

      if (value === undefined) {
        return Value.undefined;
      }

      if (value === null) {
        return Value.null;
      }

      if (value === true) {
        return Value.true;
      }

      if (value === false) {
        return Value.false;
      }

      return new Value(value);
    }

  }

  function Throw(realm, V, ...args) {
    return realm.scope(() => {
      if (typeof V === 'string') {
        return surroundingAgent.Throw(V, args[0]);
      }

      return new ThrowCompletion(V);
    });
  }

  const getObjectTag = (value, wrap) => {
    try {
      let _val = Get(value, wellKnownSymbols.toStringTag);

      Assert$1(!(_val instanceof AbruptCompletion), "");

      if (_val instanceof Completion) {
        _val = _val.Value;
      }

      const s = _val.stringValue();

      if (wrap) {
        return `[${s}] `;
      }

      return s;
    } catch {
      return '';
    }
  };

  function inspect(v, realm = surroundingAgent.currentRealmRecord, compact = false) {
    if (realm instanceof APIRealm) {
      realm = realm.realm;
    }

    let indent = 0;
    const inspected = new WeakSet();

    const innerInspect = (value, quote = true) => {
      const compactObject = toString => {
        try {
          const objectToString = realm.Intrinsics['%ObjProto_toString%'];

          if (toString.nativeFunction === objectToString.nativeFunction) {
            let _val2 = Call(toString, value);

            Assert$1(!(_val2 instanceof AbruptCompletion), "");

            if (_val2 instanceof Completion) {
              _val2 = _val2.Value;
            }

            return _val2.stringValue();
          } else {
            const tag = getObjectTag(value, false) || 'Unknown';
            let ctor = Get(value, new Value('constructor'));
            Assert$1(!(ctor instanceof AbruptCompletion), "");

            if (ctor instanceof Completion) {
              ctor = ctor.Value;
            }

            if (Type(ctor) === 'Object') {
              let _val3 = Get(ctor, new Value('name'));

              Assert$1(!(_val3 instanceof AbruptCompletion), "");

              if (_val3 instanceof Completion) {
                _val3 = _val3.Value;
              }

              const ctorName = _val3.stringValue();

              if (ctorName !== '') {
                return `#<${ctorName}>`;
              }

              return `[object ${tag}]`;
            }

            return `[object ${tag}]`;
          }
        } catch (e) {
          return '[object Unknown]';
        }
      };

      const type = Type(value);

      if (type === 'Completion') {
        return innerInspect(value.Value, quote);
      } else if (type === 'Undefined') {
        return 'undefined';
      } else if (type === 'Null') {
        return 'null';
      } else if (type === 'String') {
        return quote ? `'${value.stringValue().replace(/\n/g, '\\n')}'` : value.stringValue();
      } else if (type === 'Number') {
        const n = value.numberValue();

        if (Object.is(n, -0)) {
          return '-0';
        }

        return n.toString();
      } else if (type === 'Boolean') {
        return value.value.toString();
      } else if (type === 'Symbol') {
        return `Symbol(${value.Description.stringValue ? value.Description.stringValue() : ''})`;
      } else if (type === 'Object') {
        if (inspected.has(value)) {
          return '[Circular]';
        }

        inspected.add(value);

        if ('Call' in value) {
          const name = value.properties.get(new Value('name'));

          if (name !== undefined) {
            return `[Function: ${name.Value.stringValue()}]`;
          }

          return '[Function]';
        }

        if ('PromiseState' in value) {
          indent += 1;
          const result = innerInspect(value.PromiseResult);
          indent -= 1;
          return `Promise {
  [[PromiseState]]: '${value.PromiseState}',
  [[PromiseResult]]: ${result},
}`;
        }

        const errorToString = realm.Intrinsics['%ErrorPrototype%'].properties.get(new Value('toString')).Value;
        let toString = Get(value, new Value('toString'));

        if (toString instanceof AbruptCompletion) {
          return toString;
        }

        if (toString instanceof Completion) {
          toString = toString.Value;
        }

        if (toString.nativeFunction === errorToString.nativeFunction) {
          let e = Get(value, new Value('stack'));

          if (e instanceof AbruptCompletion) {
            return e;
          }

          if (e instanceof Completion) {
            e = e.Value;
          }

          if (!e.stringValue) {
            e = Call(toString, value);
            Assert$1(!(e instanceof AbruptCompletion), "");

            if (e instanceof Completion) {
              e = e.Value;
            }
          }

          return e.stringValue();
        }

        if ('BooleanData' in value) {
          return `[Boolean: ${innerInspect(value.BooleanData)}]`;
        }

        if ('NumberData' in value) {
          return `[Number: ${innerInspect(value.NumberData)}]`;
        }

        if ('StringData' in value) {
          return `[String: ${innerInspect(value.StringData)}]`;
        }

        if ('SymbolData' in value) {
          return `[Symbol: ${innerInspect(value.SymbolData)}]`;
        }

        if (compact === true || indent > 2) {
          return compactObject(toString);
        }

        try {
          const tag = getObjectTag(value, true);
          let keys = value.OwnPropertyKeys();
          Assert$1(!(keys instanceof AbruptCompletion), "");

          if (keys instanceof Completion) {
            keys = keys.Value;
          }

          if (keys.length === 0) {
            return `${tag}{}`;
          }

          const isArray = IsArray(value) === Value.true;
          let out = isArray ? '[' : `${tag}{`;

          if (keys.length > 5) {
            indent += 1;

            for (const key of keys) {
              let C = value.GetOwnProperty(key);
              Assert$1(!(C instanceof AbruptCompletion), "");

              if (C instanceof Completion) {
                C = C.Value;
              }

              out = `${out}\n${'  '.repeat(indent)}${innerInspect(key, false)}: ${innerInspect(C.Value)},`;
            }

            indent -= 1;
            return `${out}\n${'  '.repeat(indent)}${isArray ? ']' : '}'}`;
          } else {
            const oc = compact;
            compact = true;

            for (const key of keys) {
              let C = value.GetOwnProperty(key);
              Assert$1(!(C instanceof AbruptCompletion), "");

              if (C instanceof Completion) {
                C = C.Value;
              }

              out = `${out} ${innerInspect(key, false)}: ${innerInspect(C.Value)},`;
            }

            compact = oc;
            return `${out.slice(0, -1)} ${isArray ? ']' : '}'}`;
          }
        } catch (e) {
          return compactObject(toString);
        }
      }

      throw new OutOfRange('inspect', type);
    };

    return innerInspect(v, false);
  }

  exports.AbruptCompletion = AbruptCompletion;
  exports.Abstract = Abstract;
  exports.Completion = Completion;
  exports.Descriptor = Descriptor;
  exports.FEATURES = FEATURES;
  exports.NormalCompletion = NormalCompletion;
  exports.Object = APIObject;
  exports.Realm = APIRealm;
  exports.Throw = Throw;
  exports.Value = APIValue;
  exports.initializeAgent = initializeAgent;
  exports.inspect = inspect;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=engine262.js.map
