/*
 * engine262 0.0.1 08236c1a7f2dc4e61cee9ca9fcd9c5d8e8d50f51
 *
 * Copyright (c) 2018 engine262 Contributors
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

function Assert(invariant, source) {
  if (!invariant) {
    throw new TypeError(`Assert failed${source ? `: ${source}` : ''}`.trim());
  }
} // 9.1.15 #sec-requireinternalslot

function RequireInternalSlot(O, internalSlot) {
  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }

  if (!(internalSlot in O)) {
    return surroundingAgent.Throw('TypeError', 'InternalSlotMissing', O, internalSlot);
  }
}
function sourceTextMatchedBy(node) {
  return new Value(node.sourceText());
} // An ECMAScript Script syntactic unit may be processed using either unrestricted or strict mode syntax and semantics.
// Code is interpreted as strict mode code in the following situations:
//
//  - Global code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive.
//
//  - Module code is always strict mode code.
//
//  - All parts of a ClassDeclaration or a ClassExpression are strict mode code.
//
//  - Eval code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive or
//    if the call to eval is a direct eval that is contained in strict mode code.
//
//  - Function code is strict mode code if the associated FunctionDeclaration, FunctionExpression, GeneratorDeclaration,
//    GeneratorExpression, AsyncFunctionDeclaration, AsyncFunctionExpression, AsyncGeneratorDeclaration,
//    AsyncGeneratorExpression, MethodDefinition, ArrowFunction, or AsyncArrowFunction is contained in strict mode code
//    or if the code that produces the value of the function's [[ECMAScriptCode]] internal slot begins with a Directive
//    Prologue that contains a Use Strict Directive.
//
//  - Function code that is supplied as the arguments to the built-in Function, Generator, AsyncFunction, and
//    AsyncGenerator constructors is strict mode code if the last argument is a String that when processed is a
//    FunctionBody that begins with a Directive Prologue that contains a Use Strict Directive.

function isStrictModeCode(node) {
  if (node.strict === true) {
    return true;
  }

  if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') {
    return isStrictModeCode(node.body);
  }

  return false;
}

function isNullLiteral(node) {
  return node.type === 'Literal' && node.value === null;
} // #prod-BooleanLiteral

function isBooleanLiteral(node) {
  return node.type === 'Literal' && typeof node.value === 'boolean';
} // #prod-NumericLiteral

function isNumericLiteral(node) {
  return node.type === 'Literal' && (typeof node.value === 'number' || typeof node.value === 'bigint');
} // #prod-StringLiteral

function isStringLiteral(node) {
  return node.type === 'Literal' && typeof node.value === 'string';
}
function isSpreadElement(node) {
  return node.type === 'SpreadElement';
} // #prod-RegularExpressionLiteral

function isRegularExpressionLiteral(node) {
  return node.type === 'Literal' && typeof node.regex === 'object';
} // #prod-Identifier
// Not exact, as we allow reserved words when appropriate. (This is more like
// IdentifierReference.)

function isIdentifier(node) {
  return node.type === 'Identifier';
} // #prod-IdentifierReference

const isIdentifierReference = isIdentifier; // #prod-IdentifierName

const isIdentifierName = isIdentifier; // #prod-BindingIdentifier

const isBindingIdentifier = isIdentifier; // #prod-LabelIdentifier

function isThis(node) {
  return node.type === 'ThisExpression';
} // #prod-Literal

function isLiteral(node) {
  // Just checking node.type is not enough as RegularExpressionLiteral also
  // uses 'Literal' as node.type.
  return isNullLiteral(node) || isBooleanLiteral(node) || isNumericLiteral(node) || isStringLiteral(node);
} // #prod-ArrayLiteral

function isArrayLiteral(node) {
  return node.type === 'ArrayExpression';
} // #prod-ObjectLiteral

function isObjectLiteral(node) {
  return node.type === 'ObjectExpression';
} // #prod-GeneratorMethod

function isGeneratorMethod(node) {
  return (node.type === 'Property' && !node.shorthand && node.method && node.kind === 'init' || node.type === 'MethodDefinition' && node.kind === 'method') && isGeneratorExpression(node.value);
} // #prod-AsyncMethod

function isAsyncMethod(node) {
  return (node.type === 'Property' && !node.shorthand && node.method && node.kind === 'init' || node.type === 'MethodDefinition' && node.kind === 'method') && isAsyncFunctionExpression(node.value);
} // #prod-AsyncGeneratorMethod

function isAsyncGeneratorMethod(node) {
  return (node.type === 'Property' && !node.shorthand && node.method && node.kind === 'init' || node.type === 'MethodDefinition' && node.kind === 'method') && isAsyncGeneratorExpression(node.value);
} // Used in #prod-MethodDefinition

function isMethodDefinitionRegularFunction(node) {
  return (node.type === 'Property' && !node.shorthand && node.method && node.kind === 'init' || node.type === 'MethodDefinition' && node.kind === 'method') && isFunctionExpression(node.value);
} // Used in #prod-MethodDefinition

function isMethodDefinitionGetter(node) {
  return (node.type === 'Property' && !node.shorthand && !node.method || node.type === 'MethodDefinition') && node.kind === 'get';
} // Used in #prod-MethodDefinition

function isMethodDefinitionSetter(node) {
  return (node.type === 'Property' && !node.shorthand && !node.method || node.type === 'MethodDefinition') && node.kind === 'set';
} // #prod-MethodDefinition

function isMethodDefinition(node) {
  return isMethodDefinitionRegularFunction(node) || isGeneratorMethod(node) || isAsyncMethod(node) || isAsyncGeneratorMethod(node) || isMethodDefinitionGetter(node) || isMethodDefinitionSetter(node);
} // Used in #prod-PropertyDefinition

function isPropertyDefinitionIdentifierReference(node) {
  return node.type === 'Property' && node.shorthand && !node.method && !node.computed && node.kind === 'init';
} // Used in #prod-PropertyDefinition

function isPropertyDefinitionKeyValue(node) {
  return node.type === 'Property' && !node.shorthand && !node.method && node.kind === 'init';
} // Used in #prod-PropertyDefinition

function isPropertyDefinitionSpread(node) {
  return node.type === 'SpreadElement';
} // #prod-FunctionExpression

function isFunctionExpression(node) {
  return node.type === 'FunctionExpression' && !node.generator && !node.async;
}
function isFunctionExpressionWithBindingIdentifier(node) {
  return isFunctionExpression(node) && node.id !== null;
}
function isAsyncFunctionExpressionWithBindingIdentifier(node) {
  return isAsyncFunctionExpression(node) && node.id !== null;
} // #prod-ClassExpression

function isClassExpression(node) {
  return node.type === 'ClassExpression';
} // #prod-GeneratorExpression

function isGeneratorExpression(node) {
  return node.type === 'FunctionExpression' && node.generator && !node.async;
} // #prod-AsyncFunctionExpression

function isAsyncFunctionExpression(node) {
  return node.type === 'FunctionExpression' && !node.generator && node.async;
} // #prod-AsyncGeneratorExpression

function isAsyncGeneratorExpression(node) {
  return node.type === 'FunctionExpression' && node.generator && node.async;
} // #prod-TemplateLiteral

function isTemplateLiteral(node) {
  return node.type === 'TemplateLiteral';
} // #prod-NoSubstitutionTemplate

function isNoSubstitutionTemplate(node) {
  return isTemplateLiteral(node) && node.expressions.length === 0;
} // #prod-SubstitutionTemplate

function isSubstitutionTemplate(node) {
  return isTemplateLiteral(node) && node.expressions.length !== 0;
}
function unrollTemplateLiteral(TemplateLiteral) {
  const all = [TemplateLiteral.quasis[0]];

  for (let i = 1; i < TemplateLiteral.quasis.length; i += 1) {
    all.push(TemplateLiteral.expressions[i - 1]);
    all.push(TemplateLiteral.quasis[i]);
  }

  return all;
}
function isTaggedTemplate(node) {
  return node.type === 'TaggedTemplateExpression';
} // Used in #prod-MemberExpression and #prod-CallExpression

function isActualMemberExpression(node) {
  return node.type === 'MemberExpression' && node.object.type !== 'Super';
} // Used in #prod-MemberExpression and #prod-CallExpression

function isActualMemberExpressionWithBrackets(node) {
  return isActualMemberExpression(node) && node.computed;
} // Used in #prod-MemberExpression and #prod-CallExpression

function isActualMemberExpressionWithDot(node) {
  return isActualMemberExpression(node) && !node.computed;
} // #prod-SuperProperty

function isSuperProperty(node) {
  return node.type === 'MemberExpression' && node.object.type === 'Super';
} // #prod-MetaProperty

function isMetaProperty(node) {
  return node.type === 'MetaProperty';
} // #prod-NewTarget

function isNewTarget(node) {
  return isMetaProperty(node) && node.meta.name === 'new' && node.property.name === 'target';
} // https://tc39.es/proposal-import-meta/#prod-ImportMeta

function isImportMeta(node) {
  return isMetaProperty(node) && node.meta.name === 'import' && node.property.name === 'meta';
} // Used in #prod-MemberExpression and #prod-NewExpression

function isActualNewExpression(node) {
  return node.type === 'NewExpression';
} // Used in #prod-CallExpression and #prod-CallMemberExpression

function isActualCallExpression(node) {
  return node.type === 'CallExpression' && node.callee.type !== 'Super';
} // #prod-SuperCall

function isSuperCall(node) {
  return node.type === 'CallExpression' && node.callee.type === 'Super';
} // #prod-ImportCall

function isImportCall(node) {
  return node.type === 'ImportExpression';
} // Used in #prod-UpdateExpression

function isActualUpdateExpression(node) {
  return node.type === 'UpdateExpression';
} // Used in #prod-UnaryExpression

function isActualUnaryExpression(node) {
  return node.type === 'UnaryExpression';
} // Used in #prod-UnaryExpression

function isUnaryExpressionWithDelete(node) {
  return node.type === 'UnaryExpression' && node.operator === 'delete';
} // Used in #prod-UnaryExpression

function isUnaryExpressionWithVoid(node) {
  return node.type === 'UnaryExpression' && node.operator === 'void';
} // Used in #prod-UnaryExpression

function isUnaryExpressionWithTypeof(node) {
  return node.type === 'UnaryExpression' && node.operator === 'typeof';
} // Used in #prod-UnaryExpression

function isUnaryExpressionWithPlus(node) {
  return node.type === 'UnaryExpression' && node.operator === '+';
} // Used in #prod-UnaryExpression

function isUnaryExpressionWithMinus(node) {
  return node.type === 'UnaryExpression' && node.operator === '-';
} // Used in #prod-UnaryExpression

function isUnaryExpressionWithTilde(node) {
  return node.type === 'UnaryExpression' && node.operator === '~';
} // Used in #prod-UnaryExpression

function isUnaryExpressionWithBang(node) {
  return node.type === 'UnaryExpression' && node.operator === '!';
} // #prod-AwaitExpression

function isAwaitExpression(node) {
  return node.type === 'AwaitExpression';
} // Used in #prod-ExponentiationExpression

function isActualExponentiationExpression(node) {
  return node.type === 'BinaryExpression' && node.operator === '**';
} // Used in #prod-MultiplicativeExpression

function isActualMultiplicativeExpression(node) {
  return node.type === 'BinaryExpression' && (node.operator === '*' || node.operator === '/' || node.operator === '%');
} // Used in #prod-AdditiveExpression

function isActualAdditiveExpression(node) {
  return node.type === 'BinaryExpression' && (node.operator === '+' || node.operator === '-');
} // Used in #prod-AdditiveExpression

function isAdditiveExpressionWithPlus(node) {
  return isActualAdditiveExpression(node) && node.operator === '+';
} // Used in #prod-AdditiveExpression

function isAdditiveExpressionWithMinus(node) {
  return isActualAdditiveExpression(node) && node.operator === '-';
} // Used in #prod-ShiftExpression

function isActualShiftExpression(node) {
  return node.type === 'BinaryExpression' && (node.operator === '<<' || node.operator === '>>' || node.operator === '>>>');
} // Used in #prod-RelationalExpression

function isActualRelationalExpression(node) {
  return node.type === 'BinaryExpression' && (node.operator === '<' || node.operator === '>' || node.operator === '<=' || node.operator === '>=' || node.operator === 'instanceof' || node.operator === 'in');
} // Used in #prod-EqualityExpression

function isActualEqualityExpression(node) {
  return node.type === 'BinaryExpression' && (node.operator === '==' || node.operator === '!=' || node.operator === '===' || node.operator === '!==');
} // Used in #prod-BitwiseANDExpression

function isActualBitwiseANDExpression(node) {
  return node.type === 'BinaryExpression' && node.operator === '&';
} // Used in #prod-BitwiseXORExpression

function isActualBitwiseXORExpression(node) {
  return node.type === 'BinaryExpression' && node.operator === '^';
} // Used in #prod-BitwiseORExpression

function isActualBitwiseORExpression(node) {
  return node.type === 'BinaryExpression' && node.operator === '|';
} // Used in #prod-LogicalANDExpression

function isActualLogicalANDExpression(node) {
  return node.type === 'LogicalExpression' && node.operator === '&&';
} // Used in #prod-LogicalORExpression

function isActualLogicalORExpression(node) {
  return node.type === 'LogicalExpression' && node.operator === '||';
} // Used in #prod-ConditionalExpression

function isActualConditionalExpression(node) {
  return node.type === 'ConditionalExpression';
} // #prod-YieldExpression

function isYieldExpression(node) {
  return node.type === 'YieldExpression';
} // Used in #prod-YieldExpression.

function isYieldExpressionWithStar(node) {
  return isYieldExpression(node) && node.delegate;
} // #prod-ArrowFunction

function isArrowFunction(node) {
  return node.type === 'ArrowFunctionExpression' && !node.async && !node.generator;
} // #prod-AsyncArrowFunction

function isAsyncArrowFunction(node) {
  return node.type === 'ArrowFunctionExpression' && node.async && !node.generator;
} // Used in #prod-AssignmentExpression

function isActualAssignmentExpression(node) {
  return node.type === 'AssignmentExpression';
} // Used in #prod-AssignmentExpression

function isExpressionWithComma(node) {
  return node.type === 'SequenceExpression';
}
function isParenthesizedExpression(node) {
  return node.type === 'ParenthesizedExpression';
} // #prod-CoalesceExpression

function isActualCoalesceExpression(node) {
  return node.type === 'BinaryExpression' && node.operator === '??';
} // #prod-OptionalExpression

function isOptionalExpression(node) {
  return node.type === 'OptionalExpression';
} // #prod-OptionalChain

function isOptionalChain(node) {
  return node.type === 'OptionalChain';
}
function isOptionalChainWithOptionalChain(node) {
  return isOptionalChain(node) && node.base !== null;
}
function isOptionalChainWithExpression(node) {
  return isOptionalChain(node) && node.property && isExpression(node.property) && !isIdentifierReference(node.property);
}
function isOptionalChainWithIdentifierName(node) {
  return isOptionalChain(node) && node.property && isIdentifier(node.property);
}
function isOptionalChainWithArguments(node) {
  return isOptionalChain(node) && Array.isArray(node.arguments);
} // #prod-Expression

function isExpression(node) {
  return (// PrimaryExpression
    isThis(node) || isIdentifierReference(node) || isLiteral(node) || isArrayLiteral(node) || isObjectLiteral(node) || isFunctionExpression(node) || isClassExpression(node) || isGeneratorExpression(node) || isAsyncFunctionExpression(node) || isAsyncGeneratorExpression(node) || isRegularExpressionLiteral(node) || isTemplateLiteral(node) || isParenthesizedExpression(node) // LeftHandSideExpression (including MemberExpression, NewExpression, and
    // CallExpression)
    || isActualMemberExpression(node) || isOptionalExpression(node) || isSuperProperty(node) || isSuperCall(node) || isImportCall(node) || isMetaProperty(node) || isActualNewExpression(node) || isActualCallExpression(node) || isTaggedTemplate(node) // UpdateExpression
    || isActualUpdateExpression(node) // UnaryExpression
    || isActualUnaryExpression(node) || isAwaitExpression(node) // ExponentiationExpression
    || isActualExponentiationExpression(node) // MultiplicativeExpression
    || isActualMultiplicativeExpression(node) // AdditiveExpression
    || isActualAdditiveExpression(node) // ShiftExpression
    || isActualShiftExpression(node) // RelationalExpression
    || isActualRelationalExpression(node) // EqualityExpression
    || isActualEqualityExpression(node) // BitwiseANDExpression
    || isActualBitwiseANDExpression(node) // BitwiseXORExpression
    || isActualBitwiseXORExpression(node) // BitwiseORExpression
    || isActualBitwiseORExpression(node) // LogicalANDExpression
    || isActualLogicalANDExpression(node) // LogicalORExpression
    || isActualLogicalORExpression(node) // CoalesceExpression
    || isActualCoalesceExpression(node) // ConditionalExpression
    || isActualConditionalExpression(node) // AssignmentExpression
    || isYieldExpression(node) || isArrowFunction(node) || isAsyncArrowFunction(node) || isActualAssignmentExpression(node) // Expression
    || isExpressionWithComma(node)
  );
} // #prod-ExpressionBody

const isExpressionBody = isExpression; // Used in #prod-SingleNameBinding

function isBindingIdentifierAndInitializer(node) {
  return node.type === 'AssignmentPattern' && isBindingIdentifier(node.left);
} // #prod-SingleNameBinding
//
// Use isBindingPropertyWithSingleNameBinding() instead if SingleNameBinding is
// used as a child of BindingProperty.

function isSingleNameBinding(node) {
  return isBindingIdentifier(node) || isBindingIdentifierAndInitializer(node);
} // Used in #prod-BindingElement

function isBindingPatternAndInitializer(node) {
  return node.type === 'AssignmentPattern' && isBindingPattern(node.left);
} // #prod-BindingElement

function isBindingElement(node) {
  return isSingleNameBinding(node) || isBindingPattern(node) || isBindingPatternAndInitializer(node);
} // #prod-FormalParameter

const isFormalParameter = isBindingElement; // #prod-BindingRestElement

function isBindingRestElement(node) {
  return node.type === 'RestElement';
} // #prod-FunctionRestParameter

const isFunctionRestParameter = isBindingRestElement; // #prod-BindingProperty

function isBindingProperty(node) {
  // ESTree puts the SingleNameBinding in node.value.
  return node.type === 'Property' && isBindingElement(node.value);
} // Used in #prod-BindingProperty.

function isBindingPropertyWithSingleNameBinding(node) {
  return isBindingProperty(node) && node.shorthand;
} // Used in #prod-BindingProperty.

function isBindingPropertyWithColon(node) {
  return isBindingProperty(node) && !node.shorthand;
} // #prod-BindingRestProperty

function isBindingRestProperty(node) {
  return node.type === 'RestElement';
} // #prod-BlockStatement

function isBlockStatement(node) {
  return node.type === 'BlockStatement';
} // #prod-BindingPattern

function isBindingPattern(node) {
  return isObjectBindingPattern(node) || isArrayBindingPattern(node);
} // #prod-ObjectBindingPattern

function isObjectBindingPattern(node) {
  return node.type === 'ObjectPattern';
}

function isArrayBindingPattern(node) {
  return node.type === 'ArrayPattern';
} // #prod-AssignmentPattern

const isAssignmentPattern = isBindingPattern; // #prod-ObjectAssignmentPattern

const isObjectAssignmentPattern = isObjectBindingPattern; // #prod-ArrayAssignmentPattern

const isArrayAssignmentPattern = isArrayBindingPattern; // #prod-AssignmentRestProperty

const isAssignmentRestProperty = isBindingRestElement; // #prod-Block

function isVariableStatement(node) {
  return node.type === 'VariableDeclaration' && node.kind === 'var';
} // #prod-VariableDeclaration

function isVariableDeclaration(node) {
  return node.type === 'VariableDeclarator';
} // #prod-EmptyStatement

function isEmptyStatement(node) {
  return node.type === 'EmptyStatement';
} // #prod-ExpressionStatement

function isExpressionStatement(node) {
  return node.type === 'ExpressionStatement';
} // #prod-IfStatement

function isIfStatement(node) {
  return node.type === 'IfStatement';
} // #prod-BreakableStatement

function isBreakableStatement(node) {
  return isIterationStatement(node) || isSwitchStatement(node);
} // #prod-IterationStatement

function isIterationStatement(node) {
  // for-await-of is ForOfStatement with await = true
  return node.type === 'DoWhileStatement' || node.type === 'WhileStatement' || node.type === 'ForStatement' || node.type === 'ForInStatement' || node.type === 'ForOfStatement';
} // Used in #prod-IterationStatement

function isDoWhileStatement(node) {
  return node.type === 'DoWhileStatement';
} // Used in #prod-IterationStatement

function isWhileStatement(node) {
  return node.type === 'WhileStatement';
} // Used in #prod-IterationStatement

function isForStatement(node) {
  return node.type === 'ForStatement';
} // Used in #prod-IterationStatement

function isForStatementWithExpression(node) {
  return isForStatement(node) && (node.init === null || isExpression(node.init));
} // Used in #prod-IterationStatement

function isForStatementWithVariableStatement(node) {
  return isForStatement(node) && isVariableStatement(node.init);
} // Used in #prod-IterationStatement

function isForStatementWithLexicalDeclaration(node) {
  return isForStatement(node) && isLexicalDeclaration(node.init);
} // Used in #prod-IterationStatement

function isForInStatement(node) {
  return node.type === 'ForInStatement';
} // Used in #prod-IterationStatement
// This covers cases like for ({ a } in b), in which case the { a } is in fact
// parsed as an ObjectLiteral per spec.

function isForInStatementWithExpression(node) {
  return isForInStatement(node) && node.left.type !== 'VariableDeclaration';
} // Used in #prod-IterationStatement

function isForInStatementWithVarForBinding(node) {
  return isForInStatement(node) && isVariableStatement(node.left) && !node.left.declarations[0].init;
} // Used in #prod-IterationStatement

function isForInStatementWithForDeclaration(node) {
  return isForInStatement(node) && isForDeclaration(node.left);
} // Used in #prod-IterationStatement

function isForOfStatement(node) {
  return node.type === 'ForOfStatement';
} // Used in #prod-IterationStatement
// This covers cases like for ({ a } of b), in which case the { a } is in fact
// parsed as an ObjectLiteral per spec.

function isForOfStatementWithExpression(node) {
  return isForOfStatement(node) && node.left.type !== 'VariableDeclaration';
} // Used in #prod-IterationStatement

function isForOfStatementWithVarForBinding(node) {
  return isForOfStatement(node) && isVariableStatement(node.left) && !node.left.declarations[0].init;
} // Used in #prod-IterationStatement

function isForOfStatementWithForDeclaration(node) {
  return isForOfStatement(node) && isForDeclaration(node.left);
} // #prod-ForBinding

function isForBinding(node) {
  return isBindingIdentifier(node) || isBindingPattern(node);
} // #prod-SwitchStatement

function isSwitchStatement(node) {
  return node.type === 'SwitchStatement';
}
function isSwitchCase(node) {
  return node.type === 'SwitchCase';
} // #prod-ContinueStatement

function isContinueStatement(node) {
  return node.type === 'ContinueStatement';
} // #prod-BreakStatement

function isBreakStatement(node) {
  return node.type === 'BreakStatement';
} // #prod-ReturnStatement

function isReturnStatement(node) {
  return node.type === 'ReturnStatement';
} // #prod-WithStatement

function isWithStatement(node) {
  return node.type === 'WithStatement';
} // #prod-LabelledStatement

function isLabelledStatement(node) {
  return node.type === 'LabeledStatement'; // sic
} // #prod-ThrowStatement

function isThrowStatement(node) {
  return node.type === 'ThrowStatement';
} // #prod-TryStatement

function isTryStatement(node) {
  return node.type === 'TryStatement';
} // Used in #prod-TryStatement

function isTryStatementWithCatch(node) {
  return isTryStatement(node) && node.handler !== null;
} // Used in #prod-TryStatement

function isTryStatementWithFinally(node) {
  return isTryStatement(node) && node.finalizer !== null;
} // #prod-DebuggerStatement

function isDebuggerStatement(node) {
  return node.type === 'DebuggerStatement';
} // #prod-Statement

function isStatement(node) {
  return isBlockStatement(node) || isVariableStatement(node) || isEmptyStatement(node) || isExpressionStatement(node) || isIfStatement(node) || isBreakableStatement(node) || isContinueStatement(node) || isBreakStatement(node) || isReturnStatement(node) || isWithStatement(node) || isLabelledStatement(node) || isThrowStatement(node) || isTryStatement(node) || isDebuggerStatement(node);
} // #prod-Declaration

function isDeclaration(node) {
  return isHoistableDeclaration(node) || isClassDeclaration(node) || isLexicalDeclaration(node);
} // #prod-HoistableDeclaration
// The other kinds of HoistableDeclarations are grouped under
// FunctionDeclaration in ESTree.

function isHoistableDeclaration(node) {
  return node.type === 'FunctionDeclaration';
} // #prod-FunctionDeclaration

function isFunctionDeclaration(node) {
  return node.type === 'FunctionDeclaration' && !node.generator && !node.async;
} // #prod-GeneratorDeclaration

function isGeneratorDeclaration(node) {
  return node.type === 'FunctionDeclaration' && node.generator && !node.async;
} // #prod-AsyncFunctionDeclaration

function isAsyncFunctionDeclaration(node) {
  return node.type === 'FunctionDeclaration' && !node.generator && node.async;
} // #prod-AsyncGeneratorDeclaration

function isAsyncGeneratorDeclaration(node) {
  return node.type === 'FunctionDeclaration' && node.generator && node.async;
} // #prod-ClassDeclaration

function isClassDeclaration(node) {
  return node.type === 'ClassDeclaration';
} // #prod-LexicalDeclaration

function isLexicalDeclaration(node) {
  return node.type === 'VariableDeclaration' && (node.kind === 'let' || node.kind === 'const');
} // #prod-StatementListItem

function isStatementListItem(node) {
  return isStatement(node) || isDeclaration(node);
} // #prod-ForDeclaration

const isForDeclaration = isLexicalDeclaration; // #prod-LexicalBinding
//
// Note:
//     import {} from 'abc';
// is treated the same as
//     import 'abc';
// and this method returns false with such constructs.

function isImportDeclarationWithClause(node) {
  return isImportDeclaration(node) && node.specifiers.length !== 0;
} // Used in #prod-ImportDeclaration
//
// Note:
//     import {} from 'abc';
// is treated the same as
//     import 'abc';
// and this method returns true with such constructs.

function isImportDeclarationWithSpecifierOnly(node) {
  return isImportDeclaration(node) && node.specifiers.length === 0;
} // #prod-ImportDeclaration

function isImportDeclaration(node) {
  return node.type === 'ImportDeclaration';
} // #prod-ImportedDefaultBinding

function isImportedDefaultBinding(node) {
  return node.type === 'ImportDefaultSpecifier';
} // #prod-NameSpaceImport

function isNameSpaceImport(node) {
  return node.type === 'ImportNamespaceSpecifier';
} // #prod-ImportSpecifier

function isImportSpecifier(node) {
  return node.type === 'ImportSpecifier';
} // Used in #prod-ExportDeclaration

function isExportDeclarationWithStar(node) {
  return node.type === 'ExportAllDeclaration';
} // Used in #prod-ExportDeclaration

function isExportDeclarationWithExportAndFrom(node) {
  return node.type === 'ExportNamedDeclaration' && node.declaration === null && node.source !== null;
} // Used in #prod-ExportDeclaration

function isExportDeclarationWithExport(node) {
  return node.type === 'ExportNamedDeclaration' && node.declaration === null && node.source === null;
} // Used in #prod-ExportDeclaration

function isExportDeclarationWithVariable(node) {
  return node.type === 'ExportNamedDeclaration' && node.declaration !== null && isVariableStatement(node.declaration);
} // Used in #prod-ExportDeclaration

function isExportDeclarationWithDeclaration(node) {
  return node.type === 'ExportNamedDeclaration' && node.declaration !== null && isDeclaration(node.declaration);
} // Used in #prod-ExportDeclaration

function isExportDeclarationWithDefaultAndHoistable(node) {
  return node.type === 'ExportDefaultDeclaration' && isHoistableDeclaration(node.declaration);
} // Used in #prod-ExportDeclaration

function isExportDeclarationWithDefaultAndClass(node) {
  return node.type === 'ExportDefaultDeclaration' && isClassDeclaration(node.declaration);
} // Used in #prod-ExportDeclaration

function isExportDeclarationWithDefaultAndExpression(node) {
  return node.type === 'ExportDefaultDeclaration' && isExpression(node.declaration);
} // #prod-ExportDeclaration

function isExportDeclaration(node) {
  return isExportDeclarationWithStar(node) || isExportDeclarationWithExportAndFrom(node) || isExportDeclarationWithExport(node) || isExportDeclarationWithVariable(node) || isExportDeclarationWithDeclaration(node) || isExportDeclarationWithDefaultAndHoistable(node) || isExportDeclarationWithDefaultAndClass(node) || isExportDeclarationWithDefaultAndExpression(node);
} // 14.1.1 #sec-directive-prologues-and-the-use-strict-directive

function directivePrologueContainsUseStrictDirective(nodes) {
  for (const node of nodes) {
    if (isExpressionStatement(node) && isStringLiteral(node.expression)) {
      Assert(typeof node.directive === 'string', "typeof node.directive === 'string'");

      if (node.directive === 'use strict') {
        return true;
      }
    } else {
      Assert(typeof node.directive !== 'string', "typeof node.directive !== 'string'");
      return false;
    }
  }

  return false;
}

function convertValueForKey(key) {
  switch (Type(key)) {
    case 'String':
      return key.stringValue();

    case 'Number':
      if (key.numberValue() === 0 && Object.is(key.numberValue(), -0)) {
        return key;
      }

      return key.numberValue();

    default:
      return key;
  }
}

class ValueMap extends Map {
  constructor(init) {
    super();

    if (init !== null && init !== undefined) {
      for (const [k, v] of init) {
        this.set(convertValueForKey(k), v);
      }
    }
  }

  get(key) {
    return super.get(convertValueForKey(key));
  }

  set(key, value) {
    return super.set(convertValueForKey(key), value);
  }

  has(key) {
    return super.has(convertValueForKey(key));
  }

  delete(key) {
    return super.delete(convertValueForKey(key));
  }

  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }

  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }

  entries() {
    return this[Symbol.iterator]();
  }

  forEach(cb) {
    for (const [key, value] of this) {
      cb(value, key, this);
    }
  }

  *[Symbol.iterator]() {
    for (const [key, value] of super.entries()) {
      if (typeof key === 'string' || typeof key === 'number') {
        yield [new Value(key), value];
      } else {
        yield [key, value];
      }
    }
  }

}
class ValueSet extends Set {
  constructor(init) {
    super();

    if (init !== undefined && init !== null) {
      for (const item of init) {
        this.add(item);
      }
    }
  }

  add(item) {
    return super.add(convertValueForKey(item));
  }

  has(item) {
    return super.has(convertValueForKey(item));
  }

  delete(item) {
    return super.delete(convertValueForKey(item));
  }

  keys() {
    return this[Symbol.iterator]();
  }

  values() {
    return this[Symbol.iterator]();
  }

  *[Symbol.iterator]() {
    for (const key of super.values()) {
      if (typeof key === 'string' || typeof key === 'number') {
        yield new Value(key);
      } else {
        yield key;
      }
    }
  }

}
class OutOfRange extends RangeError {
  constructor(fn, detail) {
    super(`${fn}() argument out of range`);
    this.detail = detail;
  }

}
function unwind(iterator, maxSteps = 1) {
  let steps = 0;

  while (true) {
    const {
      done,
      value
    } = iterator.next('Unwind');

    if (done) {
      return value;
    }

    steps += 1;

    if (steps > maxSteps) {
      throw new RangeError('Max steps exceeded');
    }
  }
}
const kSafeToResume = Symbol('kSameToResume');
function handleInResume(fn, ...args) {
  const bound = () => fn(...args);

  bound[kSafeToResume] = true;
  return bound;
}
function resume(context, completion) {
  const {
    value
  } = context.codeEvaluationState.next(completion);

  if (typeof value === 'function' && value[kSafeToResume] === true) {
    let _temp = value();

    Assert(!(_temp instanceof AbruptCompletion), "value()" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    return _temp;
  }

  return value;
}
class CallSite {
  constructor(context) {
    this.context = context;
    this.lastNode = null;
    this.constructCall = false;
  }

  clone(context = this.context) {
    const c = new CallSite(context);
    c.lastNode = this.lastNode;
    c.constructCall = this.constructCall;
    return c;
  }

  isTopLevel() {
    return this.context.Function === Value.null;
  }

  isConstructCall() {
    return this.constructCall;
  }

  isAsync() {
    if (this.context.Function !== Value.null) {
      return this.context.Function.ECMAScriptCode && this.context.Function.ECMAScriptCode.async;
    }

    return false;
  }

  isNative() {
    return !!this.context.Function.nativeFunction;
  }

  getFunctionName() {
    if (this.context.Function !== Value.null) {
      const name = this.context.Function.properties.get(new Value('name'));

      if (name) {
        let _temp2 = ToString(name.Value);

        Assert(!(_temp2 instanceof AbruptCompletion), "ToString(name.Value)" + ' returned an abrupt completion');

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }

        return _temp2.stringValue();
      }
    }

    return null;
  }

  getSpecifier() {
    if (this.context.ScriptOrModule !== Value.null) {
      return this.context.ScriptOrModule.HostDefined.specifier;
    }

    return null;
  }

  setLocation(node) {
    this.lastNode = node;
  }

  get lineNumber() {
    if (this.lastNode) {
      return this.lastNode.loc.start.line;
    }

    return null;
  }

  get columnNumber() {
    if (this.lastNode) {
      return this.lastNode.loc.start.column;
    }

    return null;
  }

  loc() {
    if (this.isNative()) {
      return 'native';
    }

    let out = '';
    const specifier = this.getSpecifier();

    if (specifier) {
      out += specifier;
    } else {
      out += '<anonymous>';
    }

    if (this.lineNumber !== null) {
      out += `:${this.lineNumber}`;

      if (this.columnNumber !== null) {
        out += `:${this.columnNumber}`;
      }
    }

    return out.trim();
  }

  toString() {
    const isAsync = this.isAsync();
    const functionName = this.getFunctionName();
    const isMethodCall = !(this.isTopLevel() || this.isConstructCall());
    let string = isAsync ? 'async ' : '';

    if (isMethodCall) {
      if (functionName) {
        string += functionName;
      } else {
        string += '<anonymous>';
      }
    } else if (this.isConstructCall()) {
      string += 'new ';

      if (functionName) {
        string += functionName;
      } else {
        string += '<anonymous>';
      }
    } else if (functionName) {
      string += functionName;
    } else {
      return `${string}${this.loc()}`;
    }

    return `${string} (${this.loc()})`;
  }

}

function captureAsyncStack(stack) {
  let promise = stack[0].context.promiseCapability.Promise;

  for (let i = 0; i < 10; i += 1) {
    if (promise.PromiseFulfillReactions.length !== 1) {
      return;
    }

    const [reaction] = promise.PromiseFulfillReactions;

    if (reaction.Handler.nativeFunction === AwaitFulfilledFunctions) {
      const asyncContext = reaction.Handler.AsyncContext;
      stack.push(asyncContext.callSite.clone());

      if ('PromiseState' in asyncContext.promiseCapability.Promise) {
        promise = asyncContext.promiseCapability.Promise;
      } else {
        return;
      }
    } else if (reaction.Capability !== Value.undefined) {
      if ('PromiseState' in reaction.Capability.Promise) {
        promise = reaction.Capability.Promise;
      } else {
        return;
      }
    }
  }
}

function captureStack(O) {
  const stack = [];

  for (let i = surroundingAgent.executionContextStack.length - 2; i >= 0; i -= 1) {
    const e = surroundingAgent.executionContextStack[i];

    if (e.VariableEnvironment === undefined) {
      break;
    }

    stack.push(e.callSite.clone());

    if (e.callSite.isAsync()) {
      i -= 1; // skip original execution context which has no useful information.
    }
  }

  if (stack.length > 0 && stack[0].context.promiseCapability) {
    captureAsyncStack(stack);
  }

  let cache = null;

  let _temp3 = DefinePropertyOrThrow(O, new Value('stack'), Descriptor({
    Get: CreateBuiltinFunction(() => {
      if (cache === null) {
        let _temp4 = ToString(O);

        Assert(!(_temp4 instanceof AbruptCompletion), "ToString(O)" + ' returned an abrupt completion');

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }

        let errorString = _temp4.stringValue();

        stack.forEach(s => {
          errorString = `${errorString}\n    at ${s.toString()}`;
        });
        cache = new Value(errorString);
      }

      return cache;
    }, []),
    Set: CreateBuiltinFunction(([value = Value.undefined]) => {
      cache = value;
      return Value.undefined;
    }, []),
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp3 instanceof AbruptCompletion), "DefinePropertyOrThrow(O, new Value('stack'), Descriptor({\n    Get: CreateBuiltinFunction(() => {\n      if (cache === null) {\n        let errorString = X(ToString(O)).stringValue();\n        stack.forEach((s) => {\n          errorString = `${errorString}\\n    at ${s.toString()}`;\n        });\n        cache = new Value(errorString);\n      }\n      return cache;\n    }, []),\n    Set: CreateBuiltinFunction(([value = Value.undefined]) => {\n      cache = value;\n      return Value.undefined;\n    }, []),\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
}

//   BindingIdentifier :
//     Identifier
//     `yield`
//     `await`

function BoundNames_BindingIdentifier(BindingIdentifier) {
  return [BindingIdentifier.name];
} // 13.3.1.2 #sec-let-and-const-declarations-static-semantics-boundnames
//   LexicalDeclaration : LetOrConst BindingList `;`
//   BindingList : BindingList `,` LexicalBinding
//   LexicalBinding :
//     BindingIdentifier Initializer
//     BindingPattern Initializer
//
// (implicit)
//   BindingList : LexicalBinding

function BoundNames_LexicalDeclaration(LexicalDeclaration) {
  const names = [];

  for (const declarator of LexicalDeclaration.declarations) {
    switch (true) {
      case isBindingIdentifier(declarator.id):
        names.push(...BoundNames_BindingIdentifier(declarator.id));
        break;

      case isBindingPattern(declarator.id):
        names.push(...BoundNames_BindingPattern(declarator.id));
        break;

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('BoundNames_LexicalDeclaration', LexicalDeclaration);
    }
  }

  return names;
} // 13.3.2.1 #sec-variable-statement-static-semantics-boundnames
//   VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration
//
// (implicit)
//   VariableDeclarationList : VariableDeclaration

function BoundNames_VariableDeclarationList(VariableDeclarationList) {
  const names = [];

  for (const VariableDeclaration of VariableDeclarationList) {
    names.push(...BoundNames_VariableDeclaration(VariableDeclaration));
  }

  return names;
} // 13.3.2.1 #sec-variable-statement-static-semantics-boundnames
//   VariableDeclaration :
//     BindingIdentifier Initializer
//     BindingPattern Initializer

function BoundNames_VariableDeclaration(VariableDeclaration) {
  switch (true) {
    // FIXME: This condition is a hack, formalize it
    case VariableDeclaration.id === undefined:
      return [VariableDeclaration.name];

    case isBindingIdentifier(VariableDeclaration.id):
      return BoundNames_BindingIdentifier(VariableDeclaration.id);

    case isBindingPattern(VariableDeclaration.id):
      return BoundNames_BindingPattern(VariableDeclaration.id);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_VariableDeclaration', VariableDeclaration);
  }
} // (implicit)
//   VariableStatement : `var` VariableDeclarationList `;`

function BoundNames_VariableStatement(VariableStatement) {
  return BoundNames_VariableDeclarationList(VariableStatement.declarations);
} // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
//   SingleNameBinding : BindingIdentifier Initializer
//
// (implicit)
//   SingleNameBinding : BindingIdentifier

function BoundNames_SingleNameBinding(SingleNameBinding) {
  switch (true) {
    case isBindingIdentifier(SingleNameBinding):
      return BoundNames_BindingIdentifier(SingleNameBinding);

    case isBindingIdentifierAndInitializer(SingleNameBinding):
      return BoundNames_BindingIdentifier(SingleNameBinding.left);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_SingleNameBinding', SingleNameBinding);
  }
} // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
//   BindingElement : BindingPattern Initializer
//
// (implicit)
//   BindingElement :
//     SingleNameBinding
//     BindingPattern

function BoundNames_BindingElement(BindingElement) {
  switch (true) {
    case isSingleNameBinding(BindingElement):
      return BoundNames_SingleNameBinding(BindingElement);

    case isBindingPattern(BindingElement):
      return BoundNames_BindingPattern(BindingElement);

    case isBindingPatternAndInitializer(BindingElement):
      return BoundNames_BindingPattern(BindingElement.left);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_BindingElement', BindingElement);
  }
} // (implicit)
//   BindingRestElement :
//     `...` BindingIdentifier
//     `...` BindingPattern

function BoundNames_BindingRestElement(BindingRestElement) {
  switch (true) {
    case isBindingIdentifier(BindingRestElement.argument):
      return BoundNames_BindingIdentifier(BindingRestElement.argument);

    case isBindingPattern(BindingRestElement.argument):
      return BoundNames_BindingPattern(BindingRestElement.argument);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_BindingRestElement argument', BindingRestElement.argument);
  }
} // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
//   ArrayBindingPattern :
//     `[` Elision `]`
//     `[` Elision BindingRestElement `]`
//     `[` BindingElementList `,` Elision `]`
//     `[` BindingElementList `,` Elision BindingRestElement `]`
//   BindingElementList : BindingElementList `,` BindingElisionElement
//   BindingElisionElement : Elision BindingElement

function BoundNames_ArrayBindingPattern(ArrayBindingPattern) {
  const names = [];

  for (const BindingElisionElementOrBindingRestElement of ArrayBindingPattern.elements) {
    switch (true) {
      case BindingElisionElementOrBindingRestElement === null:
        // This is an elision.
        break;

      case isBindingElement(BindingElisionElementOrBindingRestElement):
        {
          const BindingElement = BindingElisionElementOrBindingRestElement;
          names.push(...BoundNames_BindingElement(BindingElement));
          break;
        }

      case isBindingRestElement(BindingElisionElementOrBindingRestElement):
        {
          const BindingRestElement = BindingElisionElementOrBindingRestElement;
          names.push(...BoundNames_BindingRestElement(BindingRestElement));
          break;
        }

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('BoundNames_ArrayBindingPattern element', BindingElisionElementOrBindingRestElement);
    }
  }

  return names;
} // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
//   BindingProperty : PropertyName `:` BindingElement
//
// (implicit)
//   BindingProperty : SingleNameBinding

function BoundNames_BindingProperty(BindingProperty) {
  switch (true) {
    case isBindingPropertyWithSingleNameBinding(BindingProperty):
      return BoundNames_SingleNameBinding(BindingProperty.value);

    case isBindingPropertyWithColon(BindingProperty):
      return BoundNames_BindingElement(BindingProperty.value);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_BindingProperty', BindingProperty);
  }
} // (implicit)
//   BindingRestProperty : `...` BindingIdentifier

function BoundNames_BindingRestProperty(BindingRestProperty) {
  if (!isBindingIdentifier(BindingRestProperty.argument)) {
    throw new OutOfRange('BoundNames_BindingRestProperty argument', BindingRestProperty.argument);
  }

  return BoundNames_BindingIdentifier(BindingRestProperty.argument);
} // 13.3.3.1 #sec-destructuring-binding-patterns-static-semantics-boundnames
//   ObjectBindingPattern :
//     `{` `}`
//     `{` BindingRestProperty `}`
//   BindingPropertyList : BindingPropertyList `,` BindingProperty
//
// (implicit)
//   ObjectBindingPattern :
//     `{` BindingPropertyList `}`
//     `{` BindingPropertyList `,` `}`
//     `{` BindingPropertyList `,` BindingRestProperty `}`

function BoundNames_ObjectBindingPattern(ObjectBindingPattern) {
  const names = [];

  for (const BindingPropertyOrBindingRestProperty of ObjectBindingPattern.properties) {
    switch (true) {
      case isBindingProperty(BindingPropertyOrBindingRestProperty):
        {
          const BindingProperty = BindingPropertyOrBindingRestProperty;
          names.push(...BoundNames_BindingProperty(BindingProperty));
          break;
        }

      case isBindingRestProperty(BindingPropertyOrBindingRestProperty):
        {
          const BindingRestProperty = BindingPropertyOrBindingRestProperty;
          names.push(...BoundNames_BindingRestProperty(BindingRestProperty));
          break;
        }

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('BoundNames_ObjectBindingPattern property', BindingPropertyOrBindingRestProperty);
    }
  }

  return names;
} // (implicit)
//   BindingPattern :
//     ObjectBindingPattern
//     ArrayBindingPattern


function BoundNames_BindingPattern(BindingPattern) {
  switch (true) {
    case isObjectBindingPattern(BindingPattern):
      return BoundNames_ObjectBindingPattern(BindingPattern);

    case isArrayBindingPattern(BindingPattern):
      return BoundNames_ArrayBindingPattern(BindingPattern);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_BindingPattern', BindingPattern);
  }
} // 13.7.5.2 #sec-for-in-and-for-of-statements-static-semantics-boundnames
//   ForDeclaration : LetOrConst ForBinding


function BoundNames_ForDeclaration(ForDeclaration) {
  const ForBinding = ForDeclaration.declarations[0].id;
  return BoundNames_ForBinding(ForBinding);
}

function BoundNames_BindingIdentifierOrBindingPattern(targetTypeForErrorMessage, BindingIdentifierOrBindingPattern) {
  switch (true) {
    case isBindingIdentifier(BindingIdentifierOrBindingPattern):
      return BoundNames_BindingIdentifier(BindingIdentifierOrBindingPattern);

    case isBindingPattern(BindingIdentifierOrBindingPattern):
      return BoundNames_BindingPattern(BindingIdentifierOrBindingPattern);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange(`BoundNames_BindingIdentifierOrBindingPattern ${targetTypeForErrorMessage}`, BindingIdentifierOrBindingPattern);
  }
} // (implicit)
//   ForBinding :
//     BindingIdentifier
//     BindingPattern


function BoundNames_ForBinding(node) {
  return BoundNames_BindingIdentifierOrBindingPattern('ForBinding', node);
} // (implicit)
//   CatchParameter :
//     BindingIdentifier
//     BindingPattern

function BoundNames_CatchParameter(node) {
  return BoundNames_BindingIdentifierOrBindingPattern('CatchParameter', node);
} // (implicit)
//   FormalParameter : BindingElement

const BoundNames_FormalParameter = BoundNames_BindingElement; // (implicit)
//   FunctionRestParameter : BindingRestElement

const BoundNames_FunctionRestParameter = BoundNames_BindingRestElement; // 14.1.3 #sec-function-definitions-static-semantics-boundnames
//   FormalParameters :
//     [empty]
//     FormalParameterList `,` FunctionRestParameter
//
//   FormalParameterList :
//     FormalParameterList `,` FormalParameter
//
// (implicit)
//   FormalParameters :
//     FunctionRestParameter
//     FormalParameterList
//     FormalParameterList `,`
//
//   FormalParameterList : FormalParameter

function BoundNames_FormalParameters(FormalParameters) {
  const names = [];

  for (const FormalParameterOrFunctionRestParameter of FormalParameters) {
    switch (true) {
      case isFormalParameter(FormalParameterOrFunctionRestParameter):
        names.push(...BoundNames_FormalParameter(FormalParameterOrFunctionRestParameter));
        break;

      case isFunctionRestParameter(FormalParameterOrFunctionRestParameter):
        names.push(...BoundNames_FunctionRestParameter(FormalParameterOrFunctionRestParameter));
        break;

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('BoundNames_FormalParameters element', FormalParameterOrFunctionRestParameter);
    }
  }

  return names;
} // 14.1.3 #sec-function-definitions-static-semantics-boundnames
//   FunctionDeclaration :
//     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
//     `function` `(` FormalParameters `)` `{` FunctionBody `}`
//
// 14.4.2 #sec-generator-function-definitions-static-semantics-boundnames
//   GeneratorDeclaration :
//     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
//     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
//
// 14.5.2 #sec-async-generator-function-definitions-static-semantics-boundnames
//   AsyncGeneratorDeclaration :
//     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
//     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
//
// 14.7.2 #sec-async-function-definitions-static-semantics-BoundNames
//   AsyncFunctionDeclaration :
//     `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)`
//       `{` AsyncFunctionBody `}`
//     `async` [no LineTerminator here] `function` `(` FormalParameters `)`
//       `{` AsyncFunctionBody `}`
//
// (implicit)
//   HoistableDeclaration :
//     FunctionDeclaration
//     GeneratorDeclaration
//     AsyncFunctionDeclaration
//     AsyncGeneratorDeclaration

function BoundNames_HoistableDeclaration(HoistableDeclaration) {
  if (HoistableDeclaration.id === null) {
    return ['*default*'];
  }

  return BoundNames_BindingIdentifier(HoistableDeclaration.id);
}
const BoundNames_FunctionDeclaration = BoundNames_HoistableDeclaration;
//   ClassDeclaration :
//     `class` BindingIdentifier ClassTail
//     `class` ClassTail

function BoundNames_ClassDeclaration(ClassDeclaration) {
  if (ClassDeclaration.id === null) {
    return ['*default*'];
  }

  return BoundNames_BindingIdentifier(ClassDeclaration.id);
} // (implicit)
//   Declaration :
//     HoistableDeclaration
//     ClassDeclaration
//     LexicalDeclaration

function BoundNames_Declaration(Declaration) {
  switch (true) {
    case isHoistableDeclaration(Declaration):
      return BoundNames_HoistableDeclaration(Declaration);

    case isClassDeclaration(Declaration):
      return BoundNames_ClassDeclaration(Declaration);

    case isLexicalDeclaration(Declaration):
      return BoundNames_LexicalDeclaration(Declaration);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_Declaration', Declaration);
  }
} // (implict)
//   ImportedBinding : BindingIdentifier

const BoundNames_ImportedBinding = BoundNames_BindingIdentifier; // 15.2.2.2 #sec-imports-static-semantics-boundnames
//   ImportDeclaration :
//     `import` ImportClause FromClause `;`
//     `import` ModuleSpecifier `;`

function BoundNames_ImportDeclaration(ImportDeclaration) {
  switch (true) {
    case isImportDeclarationWithClause(ImportDeclaration):
      // return BoundNames_ImportClause(ImportDeclaration.specifiers);
      return ImportDeclaration.specfiers.map(s => s.local);

    case isImportDeclarationWithSpecifierOnly(ImportDeclaration):
      return [];

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_ImportDeclaration', ImportDeclaration);
  }
} // 15.2.3.2 #sec-exports-static-semantics-boundnames
//   ExportDeclaration :
//     `export` `*` FromClause `;`
//     `export` ExportClause FromClause `;`
//     `export` ExportClause `;`
//     `export` VariableStatement
//     `export` Declaration
//     `export` `default` HoistableDeclaration
//     `export` `default` ClassDeclaration
//     `export` `default` AssignmentExpression `;`

function BoundNames_ExportDeclaration(ExportDeclaration) {
  switch (true) {
    case isExportDeclarationWithStar(ExportDeclaration):
    case isExportDeclarationWithExportAndFrom(ExportDeclaration):
    case isExportDeclarationWithExport(ExportDeclaration):
      return [];

    case isExportDeclarationWithVariable(ExportDeclaration):
      return BoundNames_VariableStatement(ExportDeclaration.declaration);

    case isExportDeclarationWithDeclaration(ExportDeclaration):
      return BoundNames_Declaration(ExportDeclaration.declaration);

    case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
      {
        const declarationNames = BoundNames_HoistableDeclaration(ExportDeclaration.declaration);

        if (!declarationNames.includes('*default*')) {
          declarationNames.push('*default*');
        }

        return declarationNames;
      }

    case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
      {
        const declarationNames = BoundNames_ClassDeclaration(ExportDeclaration.declaration);

        if (!declarationNames.includes('*default*')) {
          declarationNames.push('*default*');
        }

        return declarationNames;
      }

    case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
      return ['*default*'];

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_ExportDeclaration', ExportDeclaration);
  }
} // (implicit)
//   ModuleItem :
//     ImportDeclaration
//     ExportDeclaration
//     StatementListItem
//
//   StatementListItem : Declaration

function BoundNames_ModuleItem(ModuleItem) {
  switch (true) {
    case isImportDeclaration(ModuleItem):
      return BoundNames_ImportDeclaration(ModuleItem);

    case isExportDeclaration(ModuleItem):
      return BoundNames_ExportDeclaration(ModuleItem);

    case isDeclaration(ModuleItem):
      return BoundNames_Declaration(ModuleItem);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BoundNames_ModuleItem', ModuleItem);
  }
}

// 14.6.3 #sec-static-semantics-constructormethod
//   ClassElementList :
//     ClassElement
//     ClassElementList ClassElement
function ConstructorMethod_ClassElementList(ClassElementList) {
  return ClassElementList.find(ClassElement => ClassElement.kind === 'constructor');
} // (implicit)
//   ClassBody : ClassElementList


const ConstructorMethod_ClassBody = ConstructorMethod_ClassElementList;

//   SingleNameBinding :
//     BindingIdentifier
//     BindingIdentifier Initializer

function ContainsExpression_SingleNameBinding(SingleNameBinding) {
  switch (true) {
    case isBindingIdentifier(SingleNameBinding):
      return false;

    case isBindingIdentifierAndInitializer(SingleNameBinding):
      return true;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ContainsExpression_SingleNameBinding', SingleNameBinding);
  }
} // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
//   BindingElement : BindingPattern Initializer
//
// (implicit)
//   BindingElement :
//     SingleNameBinding
//     BindingPattern

function ContainsExpression_BindingElement(BindingElement) {
  switch (true) {
    case isSingleNameBinding(BindingElement):
      return ContainsExpression_SingleNameBinding(BindingElement);

    case isBindingPattern(BindingElement):
      return ContainsExpression_BindingPattern(BindingElement);

    case isBindingPatternAndInitializer(BindingElement):
      return true;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ContainsExpression_BindingElement', BindingElement);
  }
} // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
//   BindingRestElement :
//     `...` BindingIdentifier
//     `...` BindingPattern

function ContainsExpression_BindingRestElement(BindingRestElement) {
  switch (true) {
    case isBindingIdentifier(BindingRestElement.argument):
      return false;

    case isBindingPattern(BindingRestElement.argument):
      return ContainsExpression_BindingPattern(BindingRestElement.argument);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ContainsExpression_BindingRestElement', BindingRestElement);
  }
} // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
//   ArrayBindingPattern :
//     `[` Elision `]`
//     `[` Elision BindingRestElement `]`
//     `[` BindingElementList `,` Elision `]`
//     `[` BindingElementList `,` Elision BindingRestElement `]`
//   BindingElementList : BindingElementList `,` BindingElisionElement
//   BindingElisionElement : Elision BindingElement
//
// (implicit)
//   BindingElementList : BindingElisionElement
//   BindingElisionElement : BindingElement

function ContainsExpression_ArrayBindingPattern(ArrayBindingPattern) {
  for (const BindingElisionElementOrBindingRestElement of ArrayBindingPattern.elements) {
    switch (true) {
      case BindingElisionElementOrBindingRestElement === null:
        // This is an elision.
        break;

      case isBindingElement(BindingElisionElementOrBindingRestElement):
        {
          const BindingElement = BindingElisionElementOrBindingRestElement;
          const has = ContainsExpression_BindingElement(BindingElement);
          if (has === true) return true;
          break;
        }

      case isBindingRestElement(BindingElisionElementOrBindingRestElement):
        {
          const BindingRestElement = BindingElisionElementOrBindingRestElement;
          const has = ContainsExpression_BindingRestElement(BindingRestElement);
          if (has === true) return true;
          break;
        }

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('ContainsExpression_ArrayBindingPattern element', BindingElisionElementOrBindingRestElement);
    }
  }

  return false;
} // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
//   BindingProperty : PropertyName `:` BindingElement
//
// (implicit)
//   BindingProperty : SingleNameBinding

function ContainsExpression_BindingProperty(BindingProperty) {
  switch (true) {
    case isBindingPropertyWithColon(BindingProperty):
      {
        const has = BindingProperty.computed;
        if (has === true) return true;
        return ContainsExpression_BindingElement(BindingProperty.value);
      }

    case isBindingPropertyWithSingleNameBinding(BindingProperty):
      return ContainsExpression_SingleNameBinding(BindingProperty.value);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ContainsExpression_BindingProperty', BindingProperty);
  }
} // https://github.com/tc39/ecma262/pull/1301
//   BindingRestProperty : `...` BindingIdentifier

function ContainsExpression_BindingRestProperty(BindingRestProperty) {
  if (!isBindingIdentifier(BindingRestProperty.argument)) {
    throw new OutOfRange('ContainsExpression_BindingRestProperty argument', BindingRestProperty.argument);
  }

  return false;
} // 13.3.3.2 #sec-destructuring-binding-patterns-static-semantics-containsexpression
//   ObjectBindingPattern : `{` `}`
//
//   BindingPropertyList : BindingPropertyList `,` BindingProperty
//
// (implicit)
//   ObjectBindingPattern :
//     `{` BindingRestProperty `}`
//     `{` BindingPropertyList `}`
//     `{` BindingPropertyList `,` `}`
//
//   BindingPropertyList : BindingProperty
//
// https://github.com/tc39/ecma262/pull/1301
//   ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`

function ContainsExpression_ObjectBindingPattern(ObjectBindingPattern) {
  for (const prop of ObjectBindingPattern.properties) {
    switch (true) {
      case isBindingProperty(prop):
        {
          const BindingProperty = prop;
          const has = ContainsExpression_BindingProperty(BindingProperty);
          if (has === true) return true;
          break;
        }

      case isBindingRestProperty(prop):
        {
          const BindingRestProperty = prop;
          const has = ContainsExpression_BindingRestProperty(BindingRestProperty);
          break;
        }

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('ContainsExpression_ObjectBindingPattern property', prop);
    }
  }

  return false;
} // (implicit)
//   BindingPattern :
//     ObjectBindingPattern
//     ArrayBindingPattern

function ContainsExpression_BindingPattern(BindingPattern) {
  switch (true) {
    case isObjectBindingPattern(BindingPattern):
      return ContainsExpression_ObjectBindingPattern(BindingPattern);

    case isArrayBindingPattern(BindingPattern):
      return ContainsExpression_ArrayBindingPattern(BindingPattern);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ContainsExpression_BindingPattern', BindingPattern);
  }
} // (implicit)
//   FormalParameter : BindingElement


const ContainsExpression_FormalParameter = ContainsExpression_BindingElement; // (implicit)
//   FunctionRestParameter : BindingRestElement

const ContainsExpression_FunctionRestParameter = ContainsExpression_BindingRestElement; // 14.1.5 #sec-function-definitions-static-semantics-containsexpression
//   FormalParameters :
//     [empty]
//     FormalParameterList `,` FunctionRestParameter
//
//   FormalParameterList :
//     FormalParameterList `,` FormalParameter
//
// (implicit)
//   FormalParameters :
//     FunctionRestParameter
//     FormalParameterList
//     FormalParameterList `,`
//
//   FormalParameterList : FormalParameter

function ContainsExpression_FormalParameters(FormalParameters) {
  for (const FormalParameterOrFunctionRestParameter of FormalParameters) {
    switch (true) {
      case isFormalParameter(FormalParameterOrFunctionRestParameter):
        if (ContainsExpression_FormalParameter(FormalParameterOrFunctionRestParameter) === true) {
          return true;
        }

        break;

      case isFunctionRestParameter(FormalParameterOrFunctionRestParameter):
        if (ContainsExpression_FunctionRestParameter(FormalParameterOrFunctionRestParameter) === true) {
          return true;
        }

        break;

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('ContainsExpression_FormalParameters element', FormalParameterOrFunctionRestParameter);
    }
  }

  return false;
}

//   FunctionBody : FunctionStatementList

function ContainsUseStrict_FunctionBody(FunctionBody) {
  return directivePrologueContainsUseStrictDirective(FunctionBody);
} // 14.2.5 #sec-arrow-function-definitions-static-semantics-containsusestrict

// 13.1.4 #sec-static-semantics-declarationpart
//   HoistableDeclaration :
//     FunctionDeclaration
//     GeneratorDeclaration
//     AsyncFunctionDeclaration
//     AsyncGeneratorDeclaration
//   Declaration :
//     ClassDeclaration
//     LexicalDeclaration
//
// (implicit)
//   Declaration : HoistableDeclaration
//
// What a weird set of static semantics
function DeclarationPart_Declaration(Declaration) {
  return Declaration;
}
const DeclarationPart_HoistableDeclaration = DeclarationPart_Declaration;

//   FormalParameters :
//     [empty]
//     FormalParameterList `,` FunctionRestParameter
//
//   FormalParameterList : FormalParameterList `,` FormalParameter
//
// (implicit)
//   FormalParameters :
//     FunctionRestParameter
//     FormalParameterList
//     FormalParameterList `,`
//
//   FormalParameterList : FormalParameter

function ExpectedArgumentCount_FormalParameters(FormalParameters) {
  if (FormalParameters.length === 0) {
    return 0;
  }

  let count = 0;

  for (const FormalParameter of FormalParameters.slice(0, -1)) {
    Assert(isBindingElement(FormalParameter), "isBindingElement(FormalParameter)");
    const BindingElement = FormalParameter;

    if (HasInitializer_BindingElement(BindingElement)) {
      return count;
    }

    count += 1;
  }

  const last = FormalParameters[FormalParameters.length - 1];

  if (isFunctionRestParameter(last)) {
    return count;
  }

  Assert(isBindingElement(last), "isBindingElement(last)");

  if (HasInitializer_BindingElement(last)) {
    return count;
  }

  return count + 1;
} // 14.2.6 #sec-arrow-function-definitions-static-semantics-expectedargumentcount
//   PropertySetParameterList : FormalParameter
//
// Not implemented. Use ExpectedArgumentCount_FormalParameters instead.
// 14.8.6 #sec-async-arrow-function-definitions-static-semantics-ExpectedArgumentCount
//   AsyncArrowBindingIdentifier : BindingIdentifier
//
// Not implemented. Use ExpectedArgumentCount_ArrowParameters instead.

const ExpectedArgumentCount = ExpectedArgumentCount_FormalParameters;

class LexicalEnvironment {
  constructor() {
    this.EnvironmentRecord = undefined;
    this.outerEnvironmentReference = undefined;
  }

} // #sec-environment-records

class EnvironmentRecord {} // #sec-declarative-environment-records

class DeclarativeEnvironmentRecord extends EnvironmentRecord {
  constructor() {
    super();
    this.bindings = new ValueMap();
  } // #sec-declarative-environment-records-hasbinding-n


  HasBinding(N) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this; // 2. If envRec has a binding for the name that is the value of N, return true.

    if (envRec.bindings.has(N)) {
      return Value.true;
    } // 3. Return false.


    return Value.false;
  } // #sec-declarative-environment-records-createmutablebinding-n-d


  CreateMutableBinding(N, D) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec does not already have a binding for N.

    Assert(!envRec.bindings.has(N), "!envRec.bindings.has(N)"); // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D
    //    is true, record that the newly created binding may be delted by a subsequent
    //    DeleteBinding call.

    this.bindings.set(N, {
      indirect: false,
      initialized: false,
      mutable: true,
      strict: undefined,
      deletable: D === Value.true,
      value: undefined
    }); //  4. Return NormalCompletion(empty).

    return NormalCompletion(undefined);
  } // #sec-declarative-environment-records-createimmutablebinding-n-s


  CreateImmutableBinding(N, S) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec does not already have a binding for N.

    Assert(!envRec.bindings.has(N), "!envRec.bindings.has(N)"); // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If
    //    S is true, record that the newly created binding is a strict binding.

    this.bindings.set(N, {
      indirect: false,
      initialized: false,
      mutable: false,
      strict: S === Value.true,
      deletable: false,
      value: undefined
    }); // 4. Return NormalCompletion(empty).

    return NormalCompletion(undefined);
  } // #sec-declarative-environment-records-initializebinding-n-v


  InitializeBinding(N, V) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec must have an uninitialized binding for N.

    const binding = envRec.bindings.get(N);
    Assert(binding !== undefined && binding.initialized === false, "binding !== undefined && binding.initialized === false"); // 3. Set the bound value for N in envRec to V.

    binding.value = V; // 4. Record that the binding for N in envRec has been initialized.

    binding.initialized = true; // 5. Return NormalCompletion(empty).

    return NormalCompletion(undefined);
  } // #sec-declarative-environment-records-setmutablebinding-n-v-s


  SetMutableBinding(N, V, S) {
    Assert(IsPropertyKey(N), "IsPropertyKey(N)"); // 1. Let envRec be the declarative Environment Record for which the method was invoked.

    const envRec = this; // 2. If envRec does not have a binding for N, then

    if (!envRec.bindings.has(N)) {
      // a. If S is true, throw a ReferenceError exception.
      if (S === Value.true) {
        return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
      } // b. Perform envRec.CreateMutableBinding(N, true).


      envRec.CreateMutableBinding(N, true); // c. Perform envRec.InitializeBinding(N, V).

      envRec.InitializeBinding(N, V); // d. Return NormalCompletion(empty).

      return NormalCompletion(undefined);
    }

    const binding = this.bindings.get(N); // 3. If the binding for N in envRec is a strict binding, set S to true.

    if (binding.strict === true) {
      S = Value.true;
    } // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.


    if (binding.initialized === false) {
      return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
    } // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.


    if (binding.mutable === true) {
      binding.value = V;
    } else {
      // a. Assert: This is an attempt to change the value of an immutable binding.
      // b. If S is true, throw a TypeError exception.
      if (S === Value.true) {
        return surroundingAgent.Throw('TypeError', 'AssignmentToConstant', N);
      }
    } // 7. Return NormalCompletion(empty).


    return NormalCompletion(undefined);
  } // #sec-declarative-environment-records-getbindingvalue-n-s


  GetBindingValue(N) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec has a binding for N.

    const binding = envRec.bindings.get(N);
    Assert(binding !== undefined, "binding !== undefined"); // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.

    if (binding.initialized === false) {
      return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
    } // 4. Return the value currently bound to N in envRec.


    return binding.value;
  } // #sec-declarative-environment-records-deletebinding-n


  DeleteBinding(N) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec has a binding for the name that is the value of N.

    const binding = envRec.bindings.get(N);
    Assert(binding !== undefined, "binding !== undefined"); // 3. If the binding for N in envRec cannot be deleted, return false.

    if (binding.deletable === false) {
      return Value.false;
    } // 4. Remove the binding for N from envRec.


    envRec.bindings.delete(N); // 5. Return true.

    return Value.true;
  } // #sec-declarative-environment-records-hasthisbinding


  HasThisBinding() {
    // 1. Return false.
    return Value.false;
  } // #sec-declarative-environment-records-hassuperbinding


  HasSuperBinding() {
    // 1. Return false.
    return Value.false;
  } // #sec-declarative-environment-records-withbaseobject


  WithBaseObject() {
    // 1. Return undefined.
    return Value.undefined;
  }

} // #sec-object-environment-records

class ObjectEnvironmentRecord extends EnvironmentRecord {
  constructor(BindingObject) {
    super();
    this.bindingObject = BindingObject;
    this.withEnvironment = false;
  } // #sec-object-environment-records-hasbinding-n


  HasBinding(N) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this; // 2. Let bindings be the binding object for envRec.

    const bindings = envRec.bindingObject; // 3. Let foundBinding be ? HasProperty(bindings, N).

    let _temp = HasProperty(bindings, N);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const foundBinding = _temp; // 4. If foundBinding is false, return false.

    if (foundBinding === Value.false) {
      return Value.false;
    } // 5. If the withEnvironment flag of envRec i s false, return true.


    if (envRec.withEnvironment === false) {
      return Value.true;
    } // 6. Let unscopables be ? Get(bindings, @@unscopables).


    let _temp2 = Get(bindings, wellKnownSymbols.unscopables);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const unscopables = _temp2; // 7. If Type(unscopables) is Object, then

    if (Type(unscopables) === 'Object') {
      let _temp4 = Get(unscopables, N);

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      let _temp3 = ToBoolean(_temp4);

      Assert(!(_temp3 instanceof AbruptCompletion), "ToBoolean(Q(Get(unscopables, N)))" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      // a. Let blocked be ! ToBoolean(? Get(unscopables, N)).
      const blocked = _temp3; // b. If blocked is true, return false.

      if (blocked === Value.true) {
        return Value.false;
      }
    } // 8. Return true.


    return Value.true;
  } // #sec-object-environment-records-createmutablebinding-n-d


  CreateMutableBinding(N, D) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this; // 2. Let envRec be the object Environment Record for which the method was invoked.

    const bindings = envRec.bindingObject; // 3. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }).

    return DefinePropertyOrThrow(bindings, N, Descriptor({
      Value: Value.undefined,
      Writable: Value.true,
      Enumerable: Value.true,
      Configurable: D
    }));
  } // #sec-object-environment-records-createimmutablebinding-n-s


  CreateImmutableBinding(_N, _S) {
    Assert(false, 'CreateImmutableBinding called on an Object Environment Record');
  } // #sec-object-environment-records-initializebinding-n-v


  InitializeBinding(N, V) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec must have an uninitialized binding for N.
    // 3. Record that the binding for N in envRec has been initialized.
    // 4. Return ? envRec.SetMutableBinding(N, V, false).

    return envRec.SetMutableBinding(N, V, Value.false);
  } // #sec-object-environment-records-setmutablebinding-n-v-s


  SetMutableBinding(N, V, S) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this; // 2. Let bindings be the binding object for envRec.

    const bindings = envRec.bindingObject; // 3. Return ? Set(bindings, N, V, S).

    return Set$1(bindings, N, V, S);
  } // #sec-object-environment-records-getbindingvalue-n-s


  GetBindingValue(N, S) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this; // 2. Let bindings be the binding object for envRec.

    const bindings = envRec.bindingObject; // 3. Let value be ? HasProperty(bindings, N).

    let _temp5 = HasProperty(bindings, N);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const value = _temp5; // 4. If value is false, then

    if (value === Value.false) {
      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.
      if (S === Value.false) {
        return Value.undefined;
      } else {
        return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
      }
    } // 5. Return ? Get(bindings, N).


    return Get(bindings, N);
  } // #sec-object-environment-records-deletebinding-n


  DeleteBinding(N) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this; // 2. Let bindings be the binding object for envRec.

    const bindings = envRec.bindingObject; // 3. Return ? bindings.[[Delete]](N).

    return bindings.Delete(N);
  } // #sec-object-environment-records-hasthisbinding


  HasThisBinding() {
    // 1. Return false.
    return Value.false;
  } // #sec-object-environment-records-hassuperbinding


  HasSuperBinding() {
    // 1. Return falase.
    return Value.false;
  } // #sec-object-environment-records-withbaseobject


  WithBaseObject() {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this; // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.

    if (envRec.withEnvironment === true) {
      return envRec.bindingObject;
    } // 3. Otherwise, return undefined.


    return Value.undefined;
  }

} // #sec-function-environment-records

class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {
  constructor() {
    super();
    this.ThisValue = undefined;
    this.ThisBindingValue = undefined;
    this.FunctionObject = undefined;
    this.HomeObject = Value.undefined;
    this.NewTarget = undefined;
  } // #sec-bindthisvalue


  BindThisValue(V) {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec.[[ThisBindingStatus]] is not lexical.

    Assert(envRec.ThisBindingStatus !== 'lexical', "envRec.ThisBindingStatus !== 'lexical'"); // 3. If envRec.[[ThisBindingStatus]] is initialized, throw a ReferenceError exception.

    if (envRec.ThisBindingStatus === 'initialized') {
      return surroundingAgent.Throw('ReferenceError', 'InvalidThis');
    } // 4. Set envRec.[[ThisValue]] to V.


    envRec.ThisValue = V; // 5. Set envRec.[[ThisBindingStatus]] to initialized.

    envRec.ThisBindingStatus = 'initialized'; // 6. Return V.

    return V;
  } // #sec-function-environment-records-hasthisbinding


  HasThisBinding() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    const envRec = this; // 2. If envRec.[[ThisBindingStatus]] is lexical, return false; otherwise, return true.

    if (envRec.ThisBindingStatus === 'lexical') {
      return Value.false;
    } else {
      return Value.true;
    }
  } // #sec-function-environment-records-hassuperbinding


  HasSuperBinding() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    const envRec = this; // 2. If envRec.[[ThisBindingStatus]] is lexical, return false.

    if (envRec.ThisBindingStatus === 'lexical') {
      return Value.false;
    } // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.


    if (Type(envRec.HomeObject) === 'Undefined') {
      return Value.false;
    } else {
      return Value.true;
    }
  } // #sec-function-environment-records-getthisbinding


  GetThisBinding() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec.[[ThisBindingStatus]] is not lexical.

    Assert(envRec.ThisBindingStatus !== 'lexical', "envRec.ThisBindingStatus !== 'lexical'"); // 3. If envRec.[[ThisBindingStatus]] is uninitialized, throw a ReferenceError exception.

    if (envRec.ThisBindingStatus === 'uninitialized') {
      return surroundingAgent.Throw('ReferenceError', 'InvalidThis');
    } // 4. Return envRec.[[ThisValue]].


    return envRec.ThisValue;
  } // #sec-getsuperbase


  GetSuperBase() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    const envRec = this; // 2. Let home be envRec.[[HomeObject]].

    const home = envRec.HomeObject; // 3. If home has the value undefined, return undefined.

    if (Type(home) === 'Undefined') {
      return Value.undefined;
    } // 4. Assert: Type(home) is Object.


    Assert(Type(home) === 'Object', "Type(home) === 'Object'"); // 5. Return ? home.[[GetPrototypeOf]]().

    return home.GetPrototypeOf();
  }

} // #sec-global-environment-records

class GlobalEnvironmentRecord extends EnvironmentRecord {
  constructor() {
    super();
    this.ObjectRecord = undefined;
    this.GlobalThisValue = undefined;
    this.DeclarativeRecord = undefined;
    this.VarNames = undefined;
  } // #sec-global-environment-records-hasbinding-n


  HasBinding(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    const DclRec = envRec.DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, return true.

    if (DclRec.HasBinding(N) === Value.true) {
      return Value.true;
    } // 4. If DclRec.HasBinding(N) is true, return true.


    const ObjRec = envRec.ObjectRecord; // 5. Let ObjRec be envRec.[[ObjectRecord]].

    return ObjRec.HasBinding(N);
  } // #sec-global-environment-records-createmutablebinding-n-d


  CreateMutableBinding(N, D) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    const DclRec = envRec.DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.

    if (DclRec.HasBinding(N) === Value.true) {
      return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', N);
    } // 4. Return DclRec.CreateMutableBinding(N, D).


    return DclRec.CreateMutableBinding(N, D);
  } // #sec-global-environment-records-createimmutablebinding-n-s


  CreateImmutableBinding(N, S) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    const DclRec = envRec.DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.

    if (DclRec.HasBinding(N) === Value.true) {
      return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', N);
    } // Return DclRec.CreateImmutableBinding(N, S).


    return DclRec.CreateImmutableBinding(N, S);
  } // #sec-global-environment-records-initializebinding-n-v


  InitializeBinding(N, V) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    const DclRec = envRec.DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, then

    if (DclRec.HasBinding(N) === Value.true) {
      // a. Return DclRec.InitializeBinding(N, V).
      return DclRec.InitializeBinding(N, V);
    } // 4. Assert: If the binding exists, it must be in the object Environment Record.
    // 5. Let ObjRec be envRec.[[ObjectRecord]].


    const ObjRec = envRec.ObjectRecord; // 6. Return ? ObjRec.InitializeBinding(N, V).

    return ObjRec.InitializeBinding(N, V);
  } // #sec-global-environment-records-setmutablebinding-n-v-s


  SetMutableBinding(N, V, S) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    const DclRec = envRec.DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, then

    if (DclRec.HasBinding(N) === Value.true) {
      // a. Return DclRec.SetMutableBinding(N, V, S).
      return DclRec.SetMutableBinding(N, V, S);
    } // 4. Let ObjRec be envRec.[[ObjectRecord]].


    const ObjRec = envRec.ObjectRecord; // 5. Return ? ObjRec.SetMutableBinding(N, V, S).

    return ObjRec.SetMutableBinding(N, V, S);
  } // #sec-global-environment-records-getbindingvalue-n-s


  GetBindingValue(N, S) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    const DclRec = envRec.DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, then

    if (DclRec.HasBinding(N) === Value.true) {
      // a. Return DclRec.GetBindingValue(N, S).
      return DclRec.GetBindingValue(N, S);
    } // 4. Let ObjRec be envRec.[[ObjectRecord]].


    const ObjRec = envRec.ObjectRecord; // 5. Return ? ObjRec.GetBindingValue(N, S).

    return ObjRec.GetBindingValue(N, S);
  } // #sec-global-environment-records-deletebinding-n


  DeleteBinding(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    const DclRec = this.DeclarativeRecord; // 3. Let DclRec be envRec.[[DeclarativeRecord]].

    if (DclRec.HasBinding(N) === Value.true) {
      // a. Return DclRec.DeleteBinding(N).
      return DclRec.DeleteBinding(N);
    } // 4. Let ObjRec be envRec.[[ObjectRecord]].


    const ObjRec = envRec.ObjectRecord; // 5. Let globalObject be the binding object for ObjRec.

    const globalObject = ObjRec.bindingObject; // 6. Let existingProp be ? HasOwnProperty(globalObject, N).

    let _temp6 = HasOwnProperty$1(globalObject, N);

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    const existingProp = _temp6; // 7. If existingProp is true, then

    if (existingProp === Value.true) {
      let _temp7 = ObjRec.DeleteBinding(N);

      if (_temp7 instanceof AbruptCompletion) {
        return _temp7;
      }

      if (_temp7 instanceof Completion) {
        _temp7 = _temp7.Value;
      }

      // a. Let status be ? ObjRec.DeleteBinding(N).
      const status = _temp7; // b. If status is true, then

      if (status === Value.true) {
        // i. Let varNames be envRec.[[VarNames]].
        const varNames = envRec.VarNames; // ii. If N is an element of varNames, remove that element from the varNames.

        if (varNames.includes(N)) {
          varNames.splice(varNames.indexOf(N), 1);
        }
      } // c. Return status.


      return status;
    } // 8. Return true.


    return Value.true;
  } // #sec-global-environment-records-hasthisbinding


  HasThisBinding() {
    // Return true.
    return Value.true;
  } // #sec-global-environment-records-hassuperbinding


  HasSuperBinding() {
    // 1. Return false.
    return Value.false;
  } // #sec-global-environment-records-withbaseobject


  WithBaseObject() {
    // 1. Return undefined.
    return Value.undefined;
  } // #sec-global-environment-records-getthisbinding


  GetThisBinding() {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Return envRec.[[GlobalThisValue]].

    return envRec.GlobalThisValue;
  } // #sec-hasvardeclaration


  HasVarDeclaration(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let varDeclaredNames be envRec.[[VarNames]].

    const varDeclaredNames = envRec.VarNames; // 3. If varDeclaredNames contains N, return true.

    if (varDeclaredNames.includes(N)) {
      return Value.true;
    } // 4. Return false.


    return Value.false;
  } // #sec-haslexicaldeclaration


  HasLexicalDeclaration(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let envRec be the global Environment Record for which the method was invoked.

    const DclRec = envRec.DeclarativeRecord; // 3. Let DclRec be envRec.[[DeclarativeRecord]].

    return DclRec.HasBinding(N);
  } // #sec-hasrestrictedglobalproperty


  HasRestrictedGlobalProperty(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    const ObjRec = envRec.ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    const globalObject = ObjRec.bindingObject; // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).

    let _temp8 = globalObject.GetOwnProperty(N);

    if (_temp8 instanceof AbruptCompletion) {
      return _temp8;
    }

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }

    const existingProp = _temp8; // 5. If existingProp is undefined, return false.

    if (existingProp === Value.undefined) {
      return Value.false;
    } // 6. If existingProp.[[Configurable]] is true, return false.


    if (existingProp.Configurable === Value.true) {
      return Value.false;
    } // Return true.


    return Value.true;
  } // #sec-candeclareglobalvar


  CanDeclareGlobalVar(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    const ObjRec = envRec.ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    const globalObject = ObjRec.bindingObject; // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).

    let _temp9 = HasOwnProperty$1(globalObject, N);

    if (_temp9 instanceof AbruptCompletion) {
      return _temp9;
    }

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }

    const hasProperty = _temp9; // 5. If hasProperty is true, return true.

    if (hasProperty === Value.true) {
      return Value.true;
    } // 6. Return ? IsExtensible(globalObject).


    return IsExtensible(globalObject);
  } // #sec-candeclareglobalfunction


  CanDeclareGlobalFunction(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    const ObjRec = envRec.ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    const globalObject = ObjRec.bindingObject; // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).

    let _temp10 = globalObject.GetOwnProperty(N);

    if (_temp10 instanceof AbruptCompletion) {
      return _temp10;
    }

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }

    const existingProp = _temp10; // 5. If existingProp is undefined, return ? IsExtensible(globalObject).

    if (existingProp === Value.undefined) {
      return IsExtensible(globalObject);
    } // 6. If existingProp.[[Configurable]] is true, return true.


    if (existingProp.Configurable === Value.true) {
      return Value.true;
    } // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values
    //    { [[Writable]]: true, [[Enumerable]]: true }, return true.


    if (IsDataDescriptor(existingProp) === true && existingProp.Writable === Value.true && existingProp.Enumerable === Value.true) {
      return Value.true;
    } // 8. Return false.


    return Value.false;
  } // #sec-createglobalvarbinding


  CreateGlobalVarBinding(N, D) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    const ObjRec = envRec.ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    const globalObject = ObjRec.bindingObject; // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).

    let _temp11 = HasOwnProperty$1(globalObject, N);

    if (_temp11 instanceof AbruptCompletion) {
      return _temp11;
    }

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    const hasProperty = _temp11; // 5. Let extensible be ? IsExtensible(globalObject).

    let _temp12 = IsExtensible(globalObject);

    if (_temp12 instanceof AbruptCompletion) {
      return _temp12;
    }

    if (_temp12 instanceof Completion) {
      _temp12 = _temp12.Value;
    }

    const extensible = _temp12; // 6. If hasProperty is false and extensible is true, then

    if (hasProperty === Value.false && extensible === Value.true) {
      let _temp13 = ObjRec.CreateMutableBinding(N, D);

      if (_temp13 instanceof AbruptCompletion) {
        return _temp13;
      }

      if (_temp13 instanceof Completion) {
        _temp13 = _temp13.Value;
      }

      let _temp14 = ObjRec.InitializeBinding(N, Value.undefined);

      if (_temp14 instanceof AbruptCompletion) {
        return _temp14;
      }

      if (_temp14 instanceof Completion) {
        _temp14 = _temp14.Value;
      }
    } // 7. Let varDeclaredNames be envRec.[[VarNames]].


    const varDeclaredNames = envRec.VarNames; // 8. If varDeclaredNames does not contain N, then

    if (!varDeclaredNames.includes(N)) {
      // a. Append N to varDeclaredNames.
      varDeclaredNames.push(N);
    } // return NormalCompletion(empty).


    return NormalCompletion(undefined);
  } // #sec-createglobalfunctionbinding


  CreateGlobalFunctionBinding(N, V, D) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    const ObjRec = envRec.ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    const globalObject = ObjRec.bindingObject; // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).

    let _temp15 = globalObject.GetOwnProperty(N);

    if (_temp15 instanceof AbruptCompletion) {
      return _temp15;
    }

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    const existingProp = _temp15; // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then

    let desc;

    if (existingProp === Value.undefined || existingProp.Configurable === Value.true) {
      // a. Let desc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }.
      desc = Descriptor({
        Value: V,
        Writable: Value.true,
        Enumerable: Value.true,
        Configurable: D
      });
    } else {
      // a. Let desc be the PropertyDescriptor { [[Value]]: V }.
      desc = Descriptor({
        Value: V
      });
    } // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).


    let _temp16 = DefinePropertyOrThrow(globalObject, N, desc);

    if (_temp16 instanceof AbruptCompletion) {
      return _temp16;
    }

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }
    // 9. Perform ? Set(globalObject, N, V, false).

    let _temp17 = Set$1(globalObject, N, V, Value.false);

    if (_temp17 instanceof AbruptCompletion) {
      return _temp17;
    }

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    const varDeclaredNames = envRec.VarNames; // 11. If varDeclaredNames does not contain N, then

    if (!varDeclaredNames.includes(N)) {
      // a. Append N to varDeclaredNames.
      varDeclaredNames.push(N);
    } // 1. Return NormalCompletion(empty).


    return NormalCompletion(undefined);
  }

} // #sec-module-environment-records

class ModuleEnvironmentRecord extends DeclarativeEnvironmentRecord {
  // #sec-module-environment-records-getbindingvalue-n-s
  GetBindingValue(N, S) {
    // 1. Assert: S is true.
    Assert(S === Value.true, "S === Value.true"); // 2. Let envRec be the module Environment Record for which the method was invoked.

    const envRec = this; // 3. Assert: envRec has a binding for N.

    const binding = envRec.bindings.get(N);
    Assert(binding !== undefined, "binding !== undefined"); // 4. If the binding for N is an indirect binding, then

    if (binding.indirect === true) {
      // a. Let M and N2 be the indirection values provided when this binding for N was created.
      const [M, N2] = binding.target; // b.Let targetEnv be M.[[Environment]].

      const targetEnv = M.Environment; // c. If targetEnv is undefined, throw a ReferenceError exception.

      if (targetEnv === Value.undefined) {
        return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
      } // d. Let targetER be targetEnv's EnvironmentRecord.


      const targetER = targetEnv.EnvironmentRecord; // e. Return ? targetER.GetBindingValue(N2, true).

      return targetER.GetBindingValue(N2, Value.true);
    } // 5. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.


    if (binding.initialized === false) {
      return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
    } // 6. Return the value currently bound to N in envRec.


    return binding.value;
  } // #sec-module-environment-records-deletebinding-n


  DeleteBinding() {
    Assert(false, 'This method is never invoked. See #sec-delete-operator-static-semantics-early-errors');
  } // #sec-module-environment-records-hasthisbinding


  HasThisBinding() {
    // Return true.
    return Value.true;
  } // #sec-module-environment-records-getthisbinding


  GetThisBinding() {
    // Return undefined.
    return Value.undefined;
  } // #sec-createimportbinding


  CreateImportBinding(N, M, N2) {
    // 1. Let envRec be the module Environment Record for which the method was invoked.
    const envRec = this; // 2. Assert: envRec does not already have a binding for N.

    Assert(envRec.HasBinding(N) === Value.false, "envRec.HasBinding(N) === Value.false"); // 3. Assert: M is a Module Record.

    Assert(M instanceof AbstractModuleRecord, "M instanceof AbstractModuleRecord"); // 4. Assert: When M.[[Environment]] is instantiated it will have a direct binding for N2.
    // 5. Create an immutable indirect binding in envRec for N that references M and N2 as its target binding and record that the binding is initialized.

    envRec.bindings.set(N, {
      indirect: true,
      target: [M, N2],
      initialized: true
    }); // 6. Return NormalCompletion(empty).

    return NormalCompletion(undefined);
  }

} // 8.1.2.1 #sec-getidentifierreference

function GetIdentifierReference(lex, name, strict) {
  // 1. If lex is the value null, then
  if (lex === Value.null) {
    // a. Return a value of type Reference whose base value component is undefined, whose
    //    referenced name component is name, and whose strict reference flag is strict.
    return new Reference({
      BaseValue: Value.undefined,
      ReferencedName: name,
      StrictReference: strict
    });
  } // 2. Let envRec be lex's EnvironmentRecord.


  const envRec = lex.EnvironmentRecord; // 3. Let exists be ? envRec.HasBinding(name).

  let _temp18 = envRec.HasBinding(name);

  if (_temp18 instanceof AbruptCompletion) {
    return _temp18;
  }

  if (_temp18 instanceof Completion) {
    _temp18 = _temp18.Value;
  }

  const exists = _temp18; // 4. If exists is true, then

  if (exists === Value.true) {
    // a. Return a value of type Reference whose base value component is envRec, whose
    //    referenced name component is name, and whose strict reference flag is strict.
    return new Reference({
      BaseValue: envRec,
      ReferencedName: name,
      StrictReference: strict
    });
  } else {
    // a. Let outer be the value of lex's outer environment reference.
    const outer = lex.outerEnvironmentReference; // b. Return ? GetIdentifierReference(outer, name, strict).

    return GetIdentifierReference(outer, name, strict);
  }
} // 8.1.2.2 #sec-newdeclarativeenvironment

function NewDeclarativeEnvironment(E) {
  // 1. Let env be a new Lexical Environment.
  const env = new LexicalEnvironment(); // 2. Let envRec be a new declarative Environment Record containing no bindings.

  const envRec = new DeclarativeEnvironmentRecord(); // 3. Set env's EnvironmentRecord to envRec.

  env.EnvironmentRecord = envRec; // 4. Set env's EnvironmentRecord to envRec.

  env.outerEnvironmentReference = E; // 5. Return env.

  return env;
} // 8.1.2.3 #sec-newobjectenvironment

function NewObjectEnvironment(O, E) {
  // 1. Let env be a new Lexical Environment.
  const env = new LexicalEnvironment(); // 2. Let envRec be a new object Environment Record containing O as the binding object.

  const envRec = new ObjectEnvironmentRecord(O); // 3. Set env's EnvironmentRecord to envRec.

  env.EnvironmentRecord = envRec; // 4. Set env's EnvironmentRecord to envRec.

  env.outerEnvironmentReference = E; // 5. Return env.

  return env;
} // 8.1.2.4 #sec-newfunctionenvironment

function NewFunctionEnvironment(F, newTarget) {
  // 1. Assert: F is an ECMAScript function.
  Assert(F instanceof FunctionValue, "F instanceof FunctionValue"); // 2. Assert: Type(newTarget) is Undefined or Object.

  Assert(Type(newTarget) === 'Undefined' || Type(newTarget) === 'Object', "Type(newTarget) === 'Undefined' || Type(newTarget) === 'Object'"); // 3. Let env be a new Lexical Environment.

  const env = new LexicalEnvironment(); // 4. Let envRec be a new function Environment Record containing no bindings.

  const envRec = new FunctionEnvironmentRecord(); // 5. Set envRec.[[FunctionObject]] to F.

  envRec.FunctionObject = F; // 6. If F.[[ThisMode]] is lexical, set envRec.[[ThisBindingStatus]] to lexical.
  // 7. Else, set envRec.[[ThisBindingStatus]] to uninitialized.

  if (F.ThisMode === 'lexical') {
    envRec.ThisBindingStatus = 'lexical';
  } else {
    envRec.ThisBindingStatus = 'uninitialized';
  } // 8. Let home be F.[[HomeObject]].


  const home = F.HomeObject; // 9. Set envRec.[[HomeObject]] to home.

  envRec.HomeObject = home; // 10. Set envRec.[[NewTarget]] to newTarget.

  envRec.NewTarget = newTarget; // 11. Set env's EnvironmentRecord to envRec.

  env.EnvironmentRecord = envRec; // 12. Set the outer lexical environment reference of env to F.[[Environment]].

  env.outerEnvironmentReference = F.Environment; // 13. Return env.

  return env;
} // #sec-newglobalenvironment

function NewGlobalEnvironment(G, thisValue) {
  // 1. Let env be a new Lexical Environment.
  const env = new LexicalEnvironment(); // 2. Let objRec be a new object Environment Record containing G as the binding object.

  const objRec = new ObjectEnvironmentRecord(G); // 3. Let dclRec be a new declarative Environment Record containing no bindings.

  const dclRec = new DeclarativeEnvironmentRecord(); // 4. Let dclRec be a new declarative Environment Record containing no bindings.

  const globalRec = new GlobalEnvironmentRecord(); // 5. Set globalRec.[[ObjectRecord]] to objRec.

  globalRec.ObjectRecord = objRec; // 6. Set globalRec.[[GlobalThisValue]] to thisValue.

  globalRec.GlobalThisValue = thisValue; // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.

  globalRec.DeclarativeRecord = dclRec; // 8. Set globalRec.[[VarNames]] to a new empty List.

  globalRec.VarNames = []; // 9. Set env's EnvironmentRecord to globalRec.

  env.EnvironmentRecord = globalRec; // 10. Set the outer lexical environment reference of env to null.

  env.outerEnvironmentReference = Value.null; // 11. Return env.

  return env;
} // #sec-newmoduleenvironment

function NewModuleEnvironment(E) {
  // 1. Let env be a new Lexical Environment.
  const env = new LexicalEnvironment(); // 2. Let envRec be a new module Environment Record containing no bindings.

  const envRec = new ModuleEnvironmentRecord(); // 3. Set env's EnvironmentRecord to envRec.

  env.EnvironmentRecord = envRec; // 4. Set the outer lexical environment reference of env to E.

  env.outerEnvironmentReference = E; // 5. Return env.

  return env;
}

function EvaluateBinopValues_AdditiveExpression_Plus(lval, rval) {
  let _temp = ToPrimitive(lval);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lprim = _temp;

  let _temp2 = ToPrimitive(rval);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const rprim = _temp2;

  if (Type(lprim) === 'String' || Type(rprim) === 'String') {
    let _temp3 = ToString(lprim);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const lstr = _temp3;

    let _temp4 = ToString(rprim);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const rstr = _temp4;
    return new Value(lstr.stringValue() + rstr.stringValue());
  }

  let _temp5 = ToNumeric(lprim);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const lnum = _temp5;

  let _temp6 = ToNumeric(rprim);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const rnum = _temp6;

  if (Type(lnum) !== Type(rnum)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }

  const T = TypeNumeric(lnum);
  return T.add(lnum, rnum);
} // 12.8.3.1 #sec-addition-operator-plus-runtime-semantics-evaluation
//  AdditiveExpression : AdditiveExpression + MultiplicativeExpression

function* Evaluate_AdditiveExpression_Plus(AdditiveExpression, MultiplicativeExpression) {
  const lref = yield* Evaluate(AdditiveExpression);

  let _temp7 = GetValue(lref);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const lval = _temp7;
  const rref = yield* Evaluate(MultiplicativeExpression);

  let _temp8 = GetValue(rref);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const rval = _temp8;
  return EvaluateBinopValues_AdditiveExpression_Plus(lval, rval);
}

function EvaluateBinopValues_AdditiveExpression_Minus(lval, rval) {
  let _temp9 = ToNumeric(lval);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const lnum = _temp9;

  let _temp10 = ToNumeric(rval);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const rnum = _temp10;

  if (Type(lnum) !== Type(rnum)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }

  const T = TypeNumeric(lnum);
  return T.subtract(lnum, rnum);
} // 12.8.4.1 #sec-subtraction-operator-minus-runtime-semantics-evaluation

function* Evaluate_AdditiveExpression_Minus(AdditiveExpression, MultiplicativeExpression) {
  const lref = yield* Evaluate(AdditiveExpression);

  let _temp11 = GetValue(lref);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const lval = _temp11;
  const rref = yield* Evaluate(MultiplicativeExpression);

  let _temp12 = GetValue(rref);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const rval = _temp12;
  return EvaluateBinopValues_AdditiveExpression_Minus(lval, rval);
}

function* Evaluate_AdditiveExpression(AdditiveExpression) {
  switch (true) {
    case isAdditiveExpressionWithPlus(AdditiveExpression):
      return yield* Evaluate_AdditiveExpression_Plus(AdditiveExpression.left, AdditiveExpression.right);

    case isAdditiveExpressionWithMinus(AdditiveExpression):
      return yield* Evaluate_AdditiveExpression_Minus(AdditiveExpression.left, AdditiveExpression.right);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_AdditiveExpression', AdditiveExpression);
  }
}

//   TemplateSpans :
//     TemplateTail
//     TemplateMiddleList TemplateTail
//
//   TemplateMiddleList :
//     TemplateMiddle Expression
//     TemplateMiddleList TemplateMiddle Expression

function* SubstitutionEvaluation_TemplateSpans(TemplateSpans) {
  const preceding = [];

  for (let i = 1; i < TemplateSpans.length; i += 2) {
    const Expression = TemplateSpans[i];
    const nextRef = yield* Evaluate(Expression);

    let _temp = GetValue(nextRef);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const next = _temp;
    preceding.push(next);
  }

  return preceding;
} // 12.2.9.3 #sec-template-literals-runtime-semantics-argumentlistevaluation
//   TemplateLiteral : NoSubstitutionTemplate
//
// https://github.com/tc39/ecma262/pull/1402
//   TemplateLiteral : SubstitutionTemplate


function* ArgumentListEvaluation_TemplateLiteral(TemplateLiteral) {
  switch (true) {
    case isNoSubstitutionTemplate(TemplateLiteral):
      {
        const templateLiteral = TemplateLiteral;
        const siteObj = GetTemplateObject(templateLiteral);
        return [siteObj];
      }

    case isSubstitutionTemplate(TemplateLiteral):
      {
        const templateLiteral = TemplateLiteral;
        const siteObj = GetTemplateObject(templateLiteral);
        const [,
        /* TemplateHead */
        first
        /* Expression */
        , ...rest
        /* TemplateSpans */
        ] = unrollTemplateLiteral(templateLiteral);
        const firstSubRef = yield* Evaluate(first);

        let _temp2 = GetValue(firstSubRef);

        if (_temp2 instanceof AbruptCompletion) {
          return _temp2;
        }

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }

        const firstSub = _temp2;

        let _temp3 = yield* SubstitutionEvaluation_TemplateSpans(rest);

        if (_temp3 instanceof AbruptCompletion) {
          return _temp3;
        }

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }

        const restSub = _temp3;
        Assert(Array.isArray(restSub), "Array.isArray(restSub)");
        return [siteObj, firstSub, ...restSub];
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ArgumentListEvaluation_TemplateLiteral', TemplateLiteral);
  }
} // 12.3.6.1 #sec-argument-lists-runtime-semantics-argumentlistevaluation
//   Arguments : `(` `)`
//   ArgumentList :
//     AssignmentExpression
//     `...` AssignmentExpression
//     ArgumentList `,` AssignmentExpression
//     ArgumentList `,` `...` AssignmentExpression
//
// (implicit)
//   Arguments :
//     `(` ArgumentList `)`
//     `(` ArgumentList `,` `)`

function* ArgumentListEvaluation_Arguments(Arguments) {
  const precedingArgs = [];

  for (const AssignmentExpressionOrSpreadElement of Arguments) {
    if (AssignmentExpressionOrSpreadElement.type === 'SpreadElement') {
      const AssignmentExpression = AssignmentExpressionOrSpreadElement.argument;
      const spreadRef = yield* Evaluate(AssignmentExpression);

      let _temp4 = GetValue(spreadRef);

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      const spreadObj = _temp4;

      let _temp5 = GetIterator(spreadObj);

      if (_temp5 instanceof AbruptCompletion) {
        return _temp5;
      }

      if (_temp5 instanceof Completion) {
        _temp5 = _temp5.Value;
      }

      const iteratorRecord = _temp5;

      while (true) {
        let _temp6 = IteratorStep(iteratorRecord);

        if (_temp6 instanceof AbruptCompletion) {
          return _temp6;
        }

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        const next = _temp6;

        if (next === Value.false) {
          break;
        }

        let _temp7 = IteratorValue(next);

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        const nextArg = _temp7;
        precedingArgs.push(nextArg);
      }
    } else {
      const AssignmentExpression = AssignmentExpressionOrSpreadElement;
      Assert(isExpression(AssignmentExpression), "isExpression(AssignmentExpression)");
      const ref = yield* Evaluate(AssignmentExpression);

      let _temp8 = GetValue(ref);

      if (_temp8 instanceof AbruptCompletion) {
        return _temp8;
      }

      if (_temp8 instanceof Completion) {
        _temp8 = _temp8.Value;
      }

      const arg = _temp8;
      precedingArgs.push(arg);
    }
  }

  return precedingArgs;
}
function ArgumentListEvaluation(ArgumentsOrTemplateLiteral) {
  switch (true) {
    case isTemplateLiteral(ArgumentsOrTemplateLiteral):
      return ArgumentListEvaluation_TemplateLiteral(ArgumentsOrTemplateLiteral);

    case Array.isArray(ArgumentsOrTemplateLiteral):
      return ArgumentListEvaluation_Arguments(ArgumentsOrTemplateLiteral);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ArgumentListEvaluation', ArgumentsOrTemplateLiteral);
  }
}

function* ArrayAccumulation_SpreadElement(SpreadElement, array, nextIndex) {
  const spreadRef = yield* Evaluate(SpreadElement.argument);

  let _temp = GetValue(spreadRef);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const spreadObj = _temp;

  let _temp2 = GetIterator(spreadObj);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const iteratorRecord = _temp2;

  while (true) {
    let _temp3 = IteratorStep(iteratorRecord);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const next = _temp3;

    if (next === Value.false) {
      return nextIndex;
    }

    let _temp4 = IteratorValue(next);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const nextValue = _temp4;

    let _temp5 = ToString(new Value(nextIndex));

    Assert(!(_temp5 instanceof AbruptCompletion), "ToString(new Value(nextIndex))" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const nextIndexStr = _temp5;

    let _temp6 = CreateDataPropertyOrThrow(array, nextIndexStr, nextValue);

    Assert(!(_temp6 instanceof AbruptCompletion), "CreateDataPropertyOrThrow(array, nextIndexStr, nextValue)" + ' returned an abrupt completion');

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
    nextIndex += 1;
  }
}

function* ArrayAccumulation_AssignmentExpression(AssignmentExpression, array, nextIndex) {
  const initResult = yield* Evaluate(AssignmentExpression);

  let _temp7 = GetValue(initResult);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const initValue = _temp7;

  let _temp8 = ToString(new Value(nextIndex));

  Assert(!(_temp8 instanceof AbruptCompletion), "ToString(new Value(nextIndex))" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const initIndex = _temp8;

  let _temp9 = CreateDataPropertyOrThrow(array, initIndex, initValue);

  Assert(!(_temp9 instanceof AbruptCompletion), "CreateDataPropertyOrThrow(array, initIndex, initValue)" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }
  return nextIndex + 1;
}

function* ArrayAccumulation(ElementList, array, nextIndex) {
  let postIndex = nextIndex;

  for (const element of ElementList) {
    switch (true) {
      case !element:
        // Elision
        postIndex += 1;
        break;

      case isExpression(element):
        let _temp10 = yield* ArrayAccumulation_AssignmentExpression(element, array, postIndex);

        if (_temp10 instanceof AbruptCompletion) {
          return _temp10;
        }

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }

        postIndex = _temp10;
        break;

      case isSpreadElement(element):
        let _temp11 = yield* ArrayAccumulation_SpreadElement(element, array, postIndex);

        if (_temp11 instanceof AbruptCompletion) {
          return _temp11;
        }

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }

        postIndex = _temp11;
        break;

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('ArrayAccumulation', element);
    }
  }

  return postIndex;
} // 12.2.5.3 #sec-array-initializer-runtime-semantics-evaluation
// ArrayLiteral :
//   `[` Elision `]`
//   `[` ElementList `]`
//   `[` ElementList `,` Elision `]`


function* Evaluate_ArrayLiteral(ArrayLiteral) {
  let _temp12 = ArrayCreate(new Value(0));

  Assert(!(_temp12 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const array = _temp12;

  let _temp13 = yield* ArrayAccumulation(ArrayLiteral.elements, array, 0);

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  const len = _temp13;

  let _temp14 = Set$1(array, new Value('length'), ToUint32(new Value(len)), Value.false);

  Assert(!(_temp14 instanceof AbruptCompletion), "Set(array, new Value('length'), ToUint32(new Value(len)), Value.false)" + ' returned an abrupt completion');

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  return array;
}

//   ArrowFunction : ArrowParameters `=>` ConciseBody

function Evaluate_ArrowFunction(ArrowFunction) {
  const {
    params: ArrowParameters
  } = ArrowFunction;
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const parameters = ArrowParameters;

  let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), parameters, ArrowFunction, 'lexical-this', scope);

  Assert(!(_temp instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), parameters, ArrowFunction, 'lexical-this', scope)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const closure = _temp;
  closure.SourceText = sourceTextMatchedBy(ArrowFunction);
  return closure;
} // https://github.com/tc39/ecma262/pull/1406
//   ExpressionBody : AssignmentExpression

function* Evaluate_ExpressionBody(ExpressionBody) {
  const AssignmentExpression = ExpressionBody;
  const exprRef = yield* Evaluate(AssignmentExpression);

  let _temp2 = GetValue(exprRef);
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const exprValue = _temp2;
  return new ReturnCompletion(exprValue);
}

//   AssignmentExpression :
//     LeftHandSideExpression `=` AssignmentExpression
//     LeftHandSideExpression AssignmentOperator AssignmentExpression

function* Evaluate_AssignmentExpression(node) {
  const LeftHandSideExpression = node.left;
  const AssignmentExpression = node.right;

  if (node.operator === '=') {
    if (!isAssignmentPattern(LeftHandSideExpression)) {
      let lref = yield* Evaluate(LeftHandSideExpression);

      /* istanbul ignore if */
      if (lref instanceof AbruptCompletion) {
        return lref;
      }
      /* istanbul ignore if */


      if (lref instanceof Completion) {
        lref = lref.Value;
      }
      let rval;

      if (IsAnonymousFunctionDefinition(AssignmentExpression) && IsIdentifierRef(LeftHandSideExpression)) {
        rval = yield* NamedEvaluation_Expression(AssignmentExpression, GetReferencedName(lref));
      } else {
        const rref = yield* Evaluate(AssignmentExpression);

        let _temp = GetValue(rref);
        /* istanbul ignore if */


        if (_temp instanceof AbruptCompletion) {
          return _temp;
        }
        /* istanbul ignore if */


        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }

        rval = _temp;
      }

      let _temp2 = PutValue(lref, rval);

      if (_temp2 instanceof AbruptCompletion) {
        return _temp2;
      }

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }
      return rval;
    }

    const assignmentPattern = LeftHandSideExpression;
    const rref = yield* Evaluate(AssignmentExpression);

    let _temp3 = GetValue(rref);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const rval = _temp3;

    let _temp4 = yield* DestructuringAssignmentEvaluation_AssignmentPattern(assignmentPattern, rval);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }
    return rval;
  } else {
    const AssignmentOperator = node.operator;
    const lref = yield* Evaluate(LeftHandSideExpression);

    let _temp5 = GetValue(lref);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const lval = _temp5;
    const rref = yield* Evaluate(AssignmentExpression);

    let _temp6 = GetValue(rref);

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    const rval = _temp6; // Let op be the @ where AssignmentOperator is @=.

    const op = AssignmentOperator.slice(0, -1); // Let r be the result of applying op to lval and rval
    // as if evaluating the expression lval op rval.

    const r = EvaluateBinopValues(op, lval, rval);

    let _temp7 = PutValue(lref, r);

    if (_temp7 instanceof AbruptCompletion) {
      return _temp7;
    }

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }
    return r;
  }
}

//   AsyncArrowFunction :
//     `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
//     CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody

function Evaluate_AsyncArrowFunction(AsyncArrowFunction) {
  const {
    params: ArrowFormalParameters
  } = AsyncArrowFunction;
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const parameters = ArrowFormalParameters;

  let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), parameters, AsyncArrowFunction, 'lexical-this', scope);

  Assert(!(_temp instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), parameters, AsyncArrowFunction, 'lexical-this', scope)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const closure = _temp;
  closure.SourceText = sourceTextMatchedBy(AsyncArrowFunction);
  return closure;
}

function Evaluate_AsyncFunctionExpression_BindingIdentifier(AsyncFunctionExpression) {
  const {
    id: BindingIdentifier,
    params: FormalParameters
  } = AsyncFunctionExpression;
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const funcEnv = NewDeclarativeEnvironment(scope);
  const envRec = funcEnv.EnvironmentRecord;
  const name = new Value(BindingIdentifier.name);

  let _temp = envRec.CreateImmutableBinding(name, Value.false);

  Assert(!(_temp instanceof AbruptCompletion), "envRec.CreateImmutableBinding(name, Value.false)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let _temp2 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), FormalParameters, AsyncFunctionExpression, 'non-lexical-this', funcEnv);

  Assert(!(_temp2 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), FormalParameters, AsyncFunctionExpression, 'non-lexical-this', funcEnv)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const closure = _temp2;

  let _temp3 = SetFunctionName(closure, name);

  Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  let _temp4 = envRec.InitializeBinding(name, closure);

  Assert(!(_temp4 instanceof AbruptCompletion), "envRec.InitializeBinding(name, closure)" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  closure.SourceText = sourceTextMatchedBy(AsyncFunctionExpression);
  return closure;
}

function Evaluate_AsyncFunctionExpression(AsyncFunctionExpression) {
  if (isAsyncFunctionExpressionWithBindingIdentifier(AsyncFunctionExpression)) {
    return Evaluate_AsyncFunctionExpression_BindingIdentifier(AsyncFunctionExpression);
  }

  const {
    params: FormalParameters
  } = AsyncFunctionExpression;
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;

  let _temp5 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), FormalParameters, AsyncFunctionExpression, 'non-lexical-this', scope);

  Assert(!(_temp5 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), FormalParameters, AsyncFunctionExpression, 'non-lexical-this', scope)" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const closure = _temp5;
  closure.SourceText = sourceTextMatchedBy(AsyncFunctionExpression);
  return closure;
}

//   AsyncGeneratorExpression :
//     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
//     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

function Evaluate_AsyncGeneratorExpression(AsyncGeneratorExpression) {
  const {
    id: BindingIdentifier,
    params: FormalParameters
  } = AsyncGeneratorExpression;
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  let funcEnv = scope;
  let envRec;
  let name;

  if (BindingIdentifier) {
    funcEnv = NewDeclarativeEnvironment(scope);
    envRec = funcEnv.EnvironmentRecord;
    name = new Value(BindingIdentifier.name);
    envRec.CreateImmutableBinding(name, Value.false);
  }

  let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), FormalParameters, AsyncGeneratorExpression, 'non-lexical-this', funcEnv);

  Assert(!(_temp instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), FormalParameters, AsyncGeneratorExpression, 'non-lexical-this', funcEnv)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const closure = _temp;
  const prototype = ObjectCreate(surroundingAgent.intrinsic('%AsyncGenerator.prototype%'));

  let _temp2 = DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp2 instanceof AbruptCompletion), "DefinePropertyOrThrow(\n    closure,\n    new Value('prototype'),\n    Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    }),\n  )" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  closure.SourceText = sourceTextMatchedBy(AsyncGeneratorExpression);

  if (BindingIdentifier) {
    let _temp3 = SetFunctionName(closure, name);

    Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }
    envRec.InitializeBinding(name, closure);
  }

  return closure;
}

// AwaitExpression : `await` UnaryExpression

function* Evaluate_AwaitExpression({
  argument: UnaryExpression
}) {
  const exprRef = yield* Evaluate(UnaryExpression);

  let _temp = GetValue(exprRef);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const value = _temp;
  return yield* Await(value);
}

function InitializeBoundName(name, value, environment) {
  Assert(Type(name) === 'String', "Type(name) === 'String'");

  if (Type(environment) !== 'Undefined') {
    const env = environment.EnvironmentRecord;
    env.InitializeBinding(name, value);
    return new NormalCompletion(Value.undefined);
  } else {
    const lhs = ResolveBinding(name, undefined, false);
    return PutValue(lhs, value);
  }
} // 12.1.5 #sec-identifiers-runtime-semantics-bindinginitialization
//   BindingIdentifier :
//     Identifier
//     `yield`
//     `await`

function BindingInitialization_BindingIdentifier(BindingIdentifier, value, environment) {
  const name = new Value(BindingIdentifier.name);
  return InitializeBoundName(name, value, environment);
} // 13.3.3.5 #sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization
//   BindingPattern :
//     ObjectBindingPattern
//     ArrayBindingPattern

function* BindingInitialization_BindingPattern(BindingPattern, value, environment) {
  switch (true) {
    case isObjectBindingPattern(BindingPattern):
      let _temp = RequireObjectCoercible(value);
      /* istanbul ignore if */


      if (_temp instanceof AbruptCompletion) {
        return _temp;
      }
      /* istanbul ignore if */


      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }
      return yield* BindingInitialization_ObjectBindingPattern(BindingPattern, value, environment);

    case isArrayBindingPattern(BindingPattern):
      {
        let _temp2 = GetIterator(value);

        if (_temp2 instanceof AbruptCompletion) {
          return _temp2;
        }

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }

        const iteratorRecord = _temp2;
        const result = yield* IteratorBindingInitialization_ArrayBindingPattern(BindingPattern, iteratorRecord, environment);

        if (iteratorRecord.Done === Value.false) {
          return IteratorClose(iteratorRecord, result);
        }

        return result;
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BindingInitialization_BindingPattern', BindingPattern);
  }
} // (implicit)
//   ForBinding :
//     BindingIdentifier
//     BindingPattern

function* BindingInitialization_ForBinding(ForBinding, value, environment) {
  switch (true) {
    case isBindingIdentifier(ForBinding):
      return BindingInitialization_BindingIdentifier(ForBinding, value, environment);

    case isBindingPattern(ForBinding):
      return yield* BindingInitialization_BindingPattern(ForBinding, value, environment);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BindingInitialization_ForBinding', ForBinding);
  }
} // 13.3.3.5 #sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization
//   ObjectBindingPattern :
//     `{` `}`
//     `{` BindingPropertyList `}`
//     `{` BindingPropertyList `,` `}`
//     `{` BindingRestProperty `}`
//     `{` BindingPropertyList `,` BindingRestProperty `}`

function* BindingInitialization_ObjectBindingPattern(ObjectBindingPattern, value, environment) {
  if (ObjectBindingPattern.properties.length === 0) {
    return new NormalCompletion(undefined);
  }

  let BindingRestProperty;
  let BindingPropertyList = ObjectBindingPattern.properties;
  const last = ObjectBindingPattern.properties[ObjectBindingPattern.properties.length - 1];

  if (isBindingRestProperty(last)) {
    BindingRestProperty = last;
    BindingPropertyList = BindingPropertyList.slice(0, -1);
  }

  let _temp3 = yield* PropertyBindingInitialization_BindingPropertyList(BindingPropertyList, value, environment);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const excludedNames = _temp3;

  if (BindingRestProperty === undefined) {
    return new NormalCompletion(undefined);
  }

  return RestBindingInitialization_BindingRestProperty(BindingRestProperty, value, environment, excludedNames);
}

function* BindingInitialization_CatchParameter(CatchParameter, value, environment) {
  switch (true) {
    case isBindingIdentifier(CatchParameter):
      return BindingInitialization_BindingIdentifier(CatchParameter, value, environment);

    case isBindingPattern(CatchParameter):
      return yield* BindingInitialization_BindingPattern(CatchParameter, value, environment);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BindingInitialization_CatchParameter', CatchParameter);
  }
} // 13.7.5.9 #sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization
//   ForDeclaration : LetOrConst ForBinding

function* BindingInitialization_ForDeclaration(ForDeclaration, value, environment) {
  return yield* BindingInitialization_ForBinding(ForDeclaration.declarations[0].id, value, environment);
}

/* eslint-disable no-bitwise */

function EvaluateBinopValues_BitwiseANDExpression(lval, rval) {
  let _temp = ToNumeric(lval);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lnum = _temp;

  let _temp2 = ToNumeric(rval);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const rnum = _temp2;

  if (Type(lnum) !== Type(rnum)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }

  const T = TypeNumeric(lnum);
  return T.bitwiseAND(lnum, rnum);
}
function EvaluateBinopValues_BitwiseXORExpression(lval, rval) {
  let _temp3 = ToNumeric(lval);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const lnum = _temp3;

  let _temp4 = ToNumeric(rval);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const rnum = _temp4;

  if (Type(lnum) !== Type(rnum)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }

  const T = TypeNumeric(lnum);
  return T.bitwiseXOR(lnum, rnum);
}
function EvaluateBinopValues_BitwiseORExpression(lval, rval) {
  let _temp5 = ToNumeric(lval);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const lnum = _temp5;

  let _temp6 = ToNumeric(rval);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const rnum = _temp6;

  if (Type(lnum) !== Type(rnum)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }

  const T = TypeNumeric(lnum);
  return T.bitwiseOR(lnum, rnum);
} // 12.12.3 #sec-binary-bitwise-operators-runtime-semantics-evaluation

function* Evaluate_BinaryBitwiseExpression({
  left: A,
  operator,
  right: B
}) {
  const lref = yield* Evaluate(A);

  let _temp7 = GetValue(lref);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const lval = _temp7;
  const rref = yield* Evaluate(B);

  let _temp8 = GetValue(rref);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const rval = _temp8; // Return the result of applying the bitwise operator @ to lnum and rnum.

  switch (operator) {
    case '&':
      return EvaluateBinopValues_BitwiseANDExpression(lval, rval);

    case '^':
      return EvaluateBinopValues_BitwiseXORExpression(lval, rval);

    case '|':
      return EvaluateBinopValues_BitwiseORExpression(lval, rval);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_BinaryBiwise', operator);
  }
}

function BlockDeclarationInstantiation(code, env) {
  const envRec = env.EnvironmentRecord;
  Assert(envRec instanceof DeclarativeEnvironmentRecord, "envRec instanceof DeclarativeEnvironmentRecord");
  const declarations = LexicallyScopedDeclarations_StatementList(code);

  for (const d of declarations) {
    for (const dn of BoundNames_Declaration(d).map(Value)) {
      if (IsConstantDeclaration(d)) {
        let _temp = envRec.CreateImmutableBinding(dn, Value.true);

        Assert(!(_temp instanceof AbruptCompletion), "envRec.CreateImmutableBinding(dn, Value.true)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }
      } else {
        let _temp2 = envRec.CreateMutableBinding(dn, false);

        Assert(!(_temp2 instanceof AbruptCompletion), "envRec.CreateMutableBinding(dn, false)" + ' returned an abrupt completion');

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }
      }

      if (isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)) {
        const fn = BoundNames_Declaration(d)[0];
        const fo = InstantiateFunctionObject(d, env);
        envRec.InitializeBinding(new Value(fn), fo);
      }
    }
  }
} // 13.2.13 #sec-block-runtime-semantics-evaluation
//   Block :
//     `{` `}`
//     `{` StatementList `}`

function* Evaluate_Block(Block) {
  const StatementList = Block.body;

  if (StatementList.length === 0) {
    return new NormalCompletion(undefined);
  }

  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const blockEnv = NewDeclarativeEnvironment(oldEnv);
  BlockDeclarationInstantiation(StatementList, blockEnv);
  surroundingAgent.runningExecutionContext.LexicalEnvironment = blockEnv;
  const blockValue = yield* Evaluate_StatementList(StatementList);
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  return blockValue;
}
const Evaluate_BlockStatement = Evaluate_Block;

// BreakStatement :
//   `break` `;`
//   `break` LabelIdentifier `;`

function Evaluate_BreakStatement({
  label: LabelIdentifier
}) {
  if (LabelIdentifier) {
    const label = new Value(LabelIdentifier.name);
    return new BreakCompletion(label);
  } else {
    return new BreakCompletion();
  }
}

//   BreakableStatement :
//     IterationStatement
//     SwitchStatement

function* Evaluate_BreakableStatement(BreakableStatement) {
  const newLabelSet = new ValueSet();
  return yield* LabelledEvaluation_BreakableStatement(BreakableStatement, newLabelSet);
} // 13.1.7 #sec-statement-semantics-runtime-semantics-labelledevaluation
//   BreakableStatement : IterationStatement

function* LabelledEvaluation_BreakableStatement(BreakableStatement, labelSet) {
  switch (true) {
    case isIterationStatement(BreakableStatement):
      {
        let stmtResult = EnsureCompletion((yield* LabelledEvaluation_IterationStatement(BreakableStatement, labelSet)));

        if (stmtResult.Type === 'break') {
          if (stmtResult.Target === undefined) {
            if (stmtResult.Value === undefined) {
              stmtResult = new NormalCompletion(Value.undefined);
            } else {
              stmtResult = new NormalCompletion(stmtResult.Value);
            }
          }
        }

        return Completion(stmtResult);
      }

    case isSwitchStatement(BreakableStatement):
      {
        let stmtResult = EnsureCompletion((yield* Evaluate_SwitchStatement(BreakableStatement)));

        if (stmtResult.Type === 'break') {
          if (stmtResult.Target === undefined) {
            if (stmtResult.Value === undefined) {
              stmtResult = new NormalCompletion(Value.undefined);
            } else {
              stmtResult = new NormalCompletion(stmtResult.Value);
            }
          }
        }

        return Completion(stmtResult);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('LabelledEvaluation_BreakableStatement', BreakableStatement);
  }
}

function* EvaluateCall(func, ref, args, tailPosition) {
  let thisValue;

  if (Type(ref) === 'Reference') {
    if (IsPropertyReference(ref) === Value.true) {
      thisValue = GetThisValue(ref);
    } else {
      const refEnv = GetBase(ref);
      thisValue = refEnv.WithBaseObject();
    }
  } else {
    thisValue = Value.undefined;
  }

  let _temp = yield* ArgumentListEvaluation(args);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const argList = _temp;

  if (Type(func) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
  }

  if (IsCallable(func) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
  }

  const result = Call(func, thisValue, argList); // Assert: If tailPosition is true, the above call will not return here
  // but instead evaluation will continue as if the following return has already occurred.

  if (!(result instanceof AbruptCompletion)) {
    Assert(result instanceof Value || result instanceof Completion, "result instanceof Value || result instanceof Completion");
  }

  return result;
} // 12.3.4.1 #sec-function-calls-runtime-semantics-evaluation
// CallExpression :
//   CoverCallExpressionAndAsyncArrowHead
//   CallExpression Arguments

function* Evaluate_CallExpression(CallExpression) {
  const expr = CallExpression;
  const memberExpr = expr.callee;
  const args = expr.arguments;
  const ref = yield* Evaluate(memberExpr);

  let _temp2 = GetValue(ref);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const func = _temp2;

  if (Type(ref) === 'Reference' && IsPropertyReference(ref) === Value.false && Type(GetReferencedName(ref)) === 'String' && GetReferencedName(ref).stringValue() === 'eval') {
    if (SameValue(func, surroundingAgent.intrinsic('%eval%')) === Value.true) {
      let _temp3 = yield* ArgumentListEvaluation_Arguments(args);

      if (_temp3 instanceof AbruptCompletion) {
        return _temp3;
      }

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      const argList = _temp3;

      if (argList.length === 0) {
        return Value.undefined;
      }

      const evalText = argList[0];
      const strictCaller = CallExpression.strict;
      const evalRealm = surroundingAgent.currentRealmRecord;
      return PerformEval(evalText, evalRealm, strictCaller, true);
    }
  }
  return yield* EvaluateCall(func, ref, args);
}

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 10.
  ecmaVersion: 10,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
pp.strictDirective = function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // '['
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion > 10 && starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40) // '('
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  } else if (init.type === "AssignmentPattern") {
    this.raise(init.start, "Invalid left-hand side in for-loop");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassElement = function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition")
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty && this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval  something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (bindingType === BIND_LEXICAL && expr.name === "let")
      { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
    if (element === base || element.type === "ArrowFunctionExpression") { return element }
    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super ( Arguments )
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion >= 11) {
      return this.parseExprImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
};

pp$3.parseExprImport = function() {
  var node = this.startNode();
  this.next(); // skip `import`
  switch (this.type) {
  case types.parenL:
    return this.parseDynamicImport(node)
  default:
    this.unexpected();
  }
};

pp$3.parseDynamicImport = function(node) {
  this.next(); // skip `(`

  // Parse node.source.
  node.source = this.parseMaybeAssign();

  // Verify ending.
  if (!this.eat(types.parenR)) {
    var errorPos = this.start;
    if (this.eat(types.comma) && this.eat(types.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }

  return this.finishNode(node, "ImportExpression")
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target" || containsEsc)
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (isImport && node.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$5.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$5.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$5.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$5.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$5.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);

var pp$8 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise("Invalid property name"); }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$9 = Parser.prototype;

// Move to the next token

pp$9.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$9.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$9[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$9.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$9.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$9.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$9.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$9.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$9.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$9.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$9.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$9.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$9.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};

pp$9.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$9.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$9.readInt = function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$9.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var str$1 = this.input.slice(start, this.pos);
    var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val$1)
  }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$9.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$9.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$9.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$9.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$9.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$9.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$9.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.

var version = "7.1.0";

Parser.acorn = {
  Parser: Parser,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types,
  keywordTypes: keywords$1,
  TokContext: TokContext,
  tokContexts: types$1,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return Parser.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}

var acorn = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Node: Node,
  Parser: Parser,
  Position: Position,
  SourceLocation: SourceLocation,
  TokContext: TokContext,
  Token: Token,
  TokenType: TokenType,
  defaultOptions: defaultOptions,
  getLineInfo: getLineInfo,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  isNewLine: isNewLine,
  keywordTypes: keywords$1,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace,
  parse: parse,
  parseExpressionAt: parseExpressionAt,
  tokContexts: types$1,
  tokTypes: types,
  tokenizer: tokenizer,
  version: version
});

const HasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);

function deepFreeze(o) {
  Object.freeze(o);
  Object.getOwnPropertyNames(o).forEach(prop => {
    if (HasOwnProperty(o, prop) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
} // Copied from acorn/src/scopeflags.js.


const SCOPE_FUNCTION$1 = 2;
const SCOPE_ASYNC$1 = 4;
const SCOPE_GENERATOR$1 = 8;

function functionFlags$1(async, generator) {
  // eslint-disable-next-line no-bitwise
  return SCOPE_FUNCTION$1 | (async ? SCOPE_ASYNC$1 : 0) | (generator ? SCOPE_GENERATOR$1 : 0);
}

const optionalChainToken = {
  label: '?.'
};
const nullishCoalescingToken = {
  label: '??',
  binop: 0
};
const skipWhiteSpace$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const Parser$1 = Parser.extend(P => class Parse262 extends P {
  constructor(options = {}, source) {
    super({ ...options,
      ecmaVersion: 2020,
      // adds needed ParenthesizedExpression production
      preserveParens: true,
      locations: true
    }, source);

    if (options.strict === true) {
      this.strict = true;
    }

    this.containsTopLevelAwait = false;
  }

  parse() {
    const body = super.parse();
    body.containsTopLevelAwait = this.containsTopLevelAwait;
    deepFreeze(body);
    return body;
  }

  finishNode(node, type) {
    node.strict = this.strict;
    const ret = super.finishNode(node, type);

    node.sourceText = () => this.input.slice(node.start, node.end);

    if (ret.type === 'MethodDefinition' && ret.static) {
      ret.start += 7; // don't include `static` in the source text
    }

    if (ret.type === 'Literal' && typeof ret.value === 'bigint') {
      if (/^0[^xbo]/.test(ret.bigint)) {
        this.raise(ret.start, 'Invalid or unexpected token');
      }
    }

    return ret;
  }

  getTokenFromCode(code) {
    if (code === 63) {
      this.pos += 1;
      const next = this.input.charCodeAt(this.pos);

      if (next === 46) {
        const nextNext = this.input.charCodeAt(this.pos + 1);

        if (nextNext < 48 || nextNext > 57) {
          this.pos += 1;
          return this.finishToken(optionalChainToken);
        }
      }

      if (next === 63) {
        this.pos += 1;
        return this.finishToken(nullishCoalescingToken, nullishCoalescingToken.label);
      }

      return this.finishToken(types.question);
    }

    return super.getTokenFromCode(code);
  }

  parseStatement(context, topLevel, exports) {
    if (this.type === types._import && surroundingAgent.feature('import.meta')) {
      // eslint-disable-line no-underscore-dangle
      skipWhiteSpace$1.lastIndex = this.pos;
      const skip = skipWhiteSpace$1.exec(this.input);
      const next = this.pos + skip[0].length;
      const nextCh = this.input.charCodeAt(next);

      if (nextCh === 40 || nextCh === 46) {
        // '(' '.'
        const node = this.startNode();
        return this.parseExpressionStatement(node, this.parseExpression());
      }
    }

    return super.parseStatement(context, topLevel, exports);
  }

  parseExprImport() {
    const node = this.startNode();
    const meta = this.parseIdent(true);

    switch (this.type) {
      case types.parenL:
        return this.parseDynamicImport(node);

      case types.dot:
        if (!surroundingAgent.feature('import.meta')) {
          return this.unexpected();
        }

        if (!(this.inModule || this.allowImportExportAnywhere)) {
          return this.unexpected();
        }

        this.next();
        node.meta = meta;
        node.property = this.parseIdent(true);

        if (node.property.name !== 'meta' || this.containsEsc) {
          return this.unexpected();
        }

        return this.finishNode(node, 'MetaProperty');

      default:
        return this.unexpected();
    }
  }

  parseSubscripts(base, startPos, startLoc, noCalls) {
    if (noCalls) {
      return super.parseSubscripts(base, startPos, startLoc, noCalls);
    }

    const maybeAsyncArrow = base.type === 'Identifier' && base.name === 'async' && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === 'async';
    /**
     * Optional chains are hard okay?
     *
     *  a.b?.c
     *  @=>
     *  OptionalExpression a.b?.c
     *      MemberExpression a.b
     *      OptionalChain ?.c
     *
     *  a.b?.c.d.e
     *  @=>
     *  OptionalExpressoin a.b?.c.d.e
     *      MemberExpression a.b
     *      OptionalChain ?.c.d.e
     *          OptionalChain ?.c.d
     *              OptionalChain ?.c
     *              Identifier .d
     *          Identifier .e
     *
     *  a.b?.c.d
     *  @=>
     *  OptionalExpression a.b?.c.d
     *      MemberExpression a.b
     *      OptionalChain ?.c.d
     *          OptionalChain ?.c
     *          Identifier .d
     *
     *  a.b?.c.d?.e.f
     *  @=>
     *  OptionalExpression a.b?.c.d?.e.f
     *      OptionalExpression a.b?.c.d
     *          MemberExpression a.b
     *          OptionalChain ?.c.d
     *              OptionalChain ?.c
     *              Identifier .d
     *      OptionalChain ?.e.f
     *          OptionalChain ?.e
     *          Identifier .f
     */

    while (true) {
      if (this.eat(optionalChainToken)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.chain = this.parseOptionalChain(startPos, startLoc);
        base = this.finishNode(node, 'OptionalExpression');
      } else {
        const element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);

        if (element === base) {
          break;
        }

        base = element;
      }
    }

    return base;
  }

  parseOptionalChain(startPos, startLoc) {
    let base = this.startNodeAt(startPos, startLoc);

    if (this.eat(types.bracketL)) {
      base.property = this.parseExpression();
      this.expect(types.bracketR);
      base.computed = true;
      base = this.finishNode(base, 'OptionalChain');
    } else if (this.eat(types.parenL)) {
      base.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, undefined);
    } else {
      base.property = this.parseIdent(true);
      base.computed = false;
    }

    base.base = null;
    base = this.finishNode(base, 'OptionalChain');

    while (true) {
      const computed = this.eat(types.bracketL);

      if (computed || this.eat(types.dot)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.base = base;
        node.property = computed ? this.parseExpression() : this.parseIdent(true);

        if (computed) {
          this.expect(types.bracketR);
        }

        node.computed = computed;
        base = this.finishNode(node, 'OptionalChain');
      } else if (this.eat(types.parenL)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.base = base;
        node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, undefined);
        base = this.finishNode(node, 'OptionalChain');
      } else if (this.eat(types.backQuote)) {
        this.raise(this.start, 'Cannot tag an optional chain');
      } else {
        break;
      }
    }

    return base;
  }

  buildBinary(startPos, startLoc, left, right, op, logical) {
    if (op === '??') {
      if (left.type === 'LogicalExpression') {
        this.raise(left.start, 'Cannot mix &&, ||, and ??');
      }

      if (right.type === 'LogicalExpression') {
        this.raise(right.start, 'Cannot mix &&, ||, and ??');
      }
    } else if (logical) {
      if (left.operator === '??') {
        this.raise(left.start, 'Cannot mix &&, ||, and ??');
      }

      if (right.operator === '??') {
        this.raise(right.start, 'Cannot mix &&, ||, and ??');
      }
    }

    return super.buildBinary(startPos, startLoc, left, right, op, logical);
  }

  parseAwait(...args) {
    const node = super.parseAwait(...args);

    if (!this.inFunction) {
      this.containsTopLevelAwait = true;
    }

    return node;
  } // Adapted from several different places in Acorn.


  static parseFunctionBody(sourceText, async, generator) {
    const parser = new Parser$1({
      sourceType: 'script'
    }, sourceText); // Parser.prototype.parse()

    const node = parser.startNode();
    parser.nextToken(); // Parser.prototype.parseFunction()

    parser.initFunction(node);
    parser.enterScope(functionFlags$1(async, generator)); // Parser.prototype.parseBlock()

    const body = [];

    while (!parser.eat(types.eof)) {
      const stmt = parser.parseStatement(null);
      body.push(stmt);
    } // Parser.prototype.parseFunctionBody()


    parser.adaptDirectivePrologue(body);
    deepFreeze(body);
    return body;
  }

});
function ParseAsFunctionBody(sourceText) {
  return Parser$1.parseFunctionBody(sourceText, false, false);
}
function ParseAsGeneratorBody(sourceText) {
  return Parser$1.parseFunctionBody(sourceText, false, true);
}
function ParseAsAsyncFunctionBody(sourceText) {
  return Parser$1.parseFunctionBody(sourceText, true, false);
}
function ParseAsAsyncGeneratorBody(sourceText) {
  return Parser$1.parseFunctionBody(sourceText, true, true);
} // Adapted from several different places in Acorn.
// `strict` refers to ContainsUseStrict of the corresponding function body.

function ParseAsFormalParameters(sourceText, strict, enableAwait, enableYield) {
  // Adapted from different places in Acorn.
  const parser = new Parser$1({
    sourceType: 'script'
  }, sourceText);
  parser.strict = strict; // Parser.prototype.parse()

  const node = parser.startNode();
  parser.nextToken(); // Parser.prototype.parseFunction()

  parser.initFunction(node);
  parser.enterScope(functionFlags$1(enableAwait, enableYield)); // Parser.prototype.parseFunctionParams()

  const params = parser.parseBindingList(types.eof, false, true);
  parser.checkYieldAwaitInDefaultParams(); // Parser.prototype.parseFunctionBody()

  const simple = parser.isSimpleParamList(params);

  if (strict && !simple) {
    parser.raiseRecoverable(node.start, 'Illegal \'use strict\' directive in function with non-simple parameter list');
  }

  parser.checkParams({
    params
  }, !strict && simple);
  deepFreeze(params);
  return params;
}
const emptyConstructorNode = Parser$1.parse('(class { constructor() {} })').body[0].expression.expression.body.body[0];
const forwardingConstructorNode = Parser$1.parse('(class extends X { constructor(...args) { super(...args); } })').body[0].expression.expression.body.body[0];

function forwardError(fn) {
  try {
    return fn();
  } catch (e) {
    if (e.name === 'SyntaxError') {
      return [surroundingAgent.Throw('SyntaxError', 'Raw', e.message).Value];
    } else {
      throw e;
    }
  }
}

function ParseScript(sourceText, realm, hostDefined = {}, strict) {
  const body = forwardError(() => Parser$1.parse(sourceText, {
    sourceType: 'script',
    strict
  }));

  if (Array.isArray(body)) {
    return body;
  }

  return {
    Realm: realm,
    Environment: undefined,
    ECMAScriptCode: body,
    HostDefined: hostDefined
  };
}
function ParseModule(sourceText, realm, hostDefined = {}) {
  // Assert: sourceText is an ECMAScript source text (see clause 10).
  const body = forwardError(() => Parser$1.parse(sourceText, {
    sourceType: 'module',
    allowAwaitOutsideFunction: surroundingAgent.feature('TopLevelAwait')
  }));

  if (Array.isArray(body)) {
    return body;
  }

  const requestedModules = ModuleRequests_ModuleItemList(body.body);
  const importEntries = ImportEntries_ModuleItemList(body.body);
  const importedBoundNames = new ValueSet(ImportedLocalNames(importEntries));
  const indirectExportEntries = [];
  const localExportEntries = [];
  const starExportEntries = [];
  const exportEntries = ExportEntries_ModuleItemList(body.body);

  for (const ee of exportEntries) {
    if (ee.ModuleRequest === Value.null) {
      if (!importedBoundNames.has(ee.LocalName)) {
        localExportEntries.push(ee);
      } else {
        const ie = importEntries.find(e => e.LocalName.stringValue() === ee.LocalName.stringValue());

        if (ie.ImportName.stringValue() === '*') {
          // Assert: This is a re-export of an imported module namespace object.
          localExportEntries.push(ee);
        } else {
          indirectExportEntries.push(new ExportEntryRecord({
            ModuleRequest: ie.ModuleRequest,
            ImportName: ie.ImportName,
            LocalName: Value.null,
            ExportName: ee.ExportName
          }));
        }
      }
    } else if (ee.ImportName.stringValue() === '*') {
      starExportEntries.push(ee);
    } else {
      indirectExportEntries.push(ee);
    }
  }

  return new SourceTextModuleRecord({
    Realm: realm,
    Environment: Value.undefined,
    Namespace: Value.undefined,
    ImportMeta: Value.undefined,
    Async: body.containsTopLevelAwait ? Value.true : Value.false,
    AsyncEvaluating: Value.false,
    TopLevelCapability: Value.undefined,
    AsyncParentModules: Value.undefined,
    PendingAsyncDependencies: Value.undefined,
    Status: 'unlinked',
    EvaluationError: Value.undefined,
    HostDefined: hostDefined,
    ECMAScriptCode: body,
    Context: Value.undefined,
    RequestedModules: requestedModules,
    ImportEntries: importEntries,
    LocalExportEntries: localExportEntries,
    IndirectExportEntries: indirectExportEntries,
    StarExportEntries: starExportEntries,
    DFSIndex: Value.undefined,
    DFSAncestorIndex: Value.undefined
  });
}

//   ClassTail : ClassHeritage `{` ClassBody `}`

function* ClassDefinitionEvaluation_ClassTail({
  ClassHeritage,
  ClassBody
}, classBinding, className) {
  const lex = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const classScope = NewDeclarativeEnvironment(lex);
  const classScopeEnvRec = classScope.EnvironmentRecord;

  if (classBinding !== Value.undefined) {
    classScopeEnvRec.CreateImmutableBinding(classBinding, Value.true);
  }

  let protoParent;
  let constructorParent;

  if (!ClassHeritage) {
    protoParent = surroundingAgent.intrinsic('%Object.prototype%');
    constructorParent = surroundingAgent.intrinsic('%Function.prototype%');
  } else {
    surroundingAgent.runningExecutionContext.LexicalEnvironment = classScope;
    const superclassRef = yield* Evaluate(ClassHeritage);
    surroundingAgent.runningExecutionContext.LexicalEnvironment = lex;

    let _temp = GetValue(superclassRef);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const superclass = _temp;

    if (Type(superclass) === 'Null') {
      protoParent = Value.null;
      constructorParent = surroundingAgent.intrinsic('%Function.prototype%');
    } else if (IsConstructor(superclass) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAConstructor', superclass);
    } else {
      let _temp2 = Get(superclass, new Value('prototype'));

      if (_temp2 instanceof AbruptCompletion) {
        return _temp2;
      }

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      protoParent = _temp2;

      if (Type(protoParent) !== 'Object' && Type(protoParent) !== 'Null') {
        return surroundingAgent.Throw('TypeError', 'ObjectPrototypeType');
      }

      constructorParent = superclass;
    }
  }

  const proto = ObjectCreate(protoParent);
  let constructor;

  if (!ClassBody) {
    constructor = undefined;
  } else {
    constructor = ConstructorMethod_ClassBody(ClassBody);
  }

  if (constructor === undefined) {
    if (ClassHeritage) {
      // Set constructor to the result of parsing the source text `constructor(...args) { super(...args); }`
      constructor = forwardingConstructorNode;
    } else {
      // Set constructor to the result of parsing the source text `constructor() {}`
      constructor = emptyConstructorNode;
    }
  }

  surroundingAgent.runningExecutionContext.LexicalEnvironment = classScope;
  const constructorInfo = yield* DefineMethod(constructor, proto, constructorParent);
  Assert(!(constructorInfo instanceof AbruptCompletion), "!(constructorInfo instanceof AbruptCompletion)");
  const F = constructorInfo.Closure;
  MakeConstructor(F, false, proto);

  if (ClassHeritage) {
    F.ConstructorKind = 'derived';
  }

  MakeClassConstructor(F);

  if (className !== Value.undefined) {
    let _temp3 = SetFunctionName(F, className);

    Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionName(F, className)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }
  }

  CreateMethodProperty(proto, new Value('constructor'), F);
  let methods;

  if (!ClassBody) {
    methods = [];
  } else {
    methods = NonConstructorMethodDefinitions_ClassBody(ClassBody);
  }

  for (const m of methods) {
    let status;

    if (IsStatic_ClassElement(m) === false) {
      status = yield* PropertyDefinitionEvaluation_ClassElement(m, proto, false);
    } else {
      status = yield* PropertyDefinitionEvaluation_ClassElement(m, F, false);
    }

    if (status instanceof AbruptCompletion) {
      surroundingAgent.runningExecutionContext.LexicalEnvironment = lex;
      return Completion(status);
    }
  }

  surroundingAgent.runningExecutionContext.LexicalEnvironment = lex;

  if (classBinding !== Value.undefined) {
    classScopeEnvRec.InitializeBinding(classBinding, F);
  }

  return F;
} // 14.6.16 #sec-class-definitions-runtime-semantics-evaluation
//   ClassExpression : `class` BindingIdentifier ClassTail

function* Evaluate_ClassExpression(ClassExpression) {
  const {
    id: BindingIdentifier,
    body,
    superClass
  } = ClassExpression;
  const ClassTail = {
    ClassHeritage: superClass,
    ClassBody: body.body
  };
  let className;

  if (!BindingIdentifier) {
    className = Value.undefined;
  } else {
    className = new Value(BindingIdentifier.name);
  }

  let _temp4 = yield* ClassDefinitionEvaluation_ClassTail(ClassTail, className, className);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const value = _temp4;
  value.SourceText = sourceTextMatchedBy(ClassExpression);
  return value;
} // 14.6.14 #sec-runtime-semantics-bindingclassdeclarationevaluation
//   ClassDeclaration :
//     `class` BindingIdentifier ClassTail
//     `class` ClassTail

function* BindingClassDeclarationEvaluation_ClassDeclaration(ClassDeclaration) {
  const {
    id: BindingIdentifier,
    body,
    superClass: ClassHeritage
  } = ClassDeclaration;
  const ClassTail = {
    ClassHeritage,
    ClassBody: body.body
  };
  let classBinding;
  let className;

  if (!BindingIdentifier) {
    classBinding = Value.undefined;
    className = new Value('default');
  } else {
    classBinding = new Value(BindingIdentifier.name);
    className = classBinding;
  }

  let _temp5 = yield* ClassDefinitionEvaluation_ClassTail(ClassTail, classBinding, className);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const value = _temp5;
  value.SourceText = sourceTextMatchedBy(ClassDeclaration);

  if (BindingIdentifier) {
    const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;

    let _temp6 = InitializeBoundName(className, value, env);

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
  }

  return value;
} // 14.6.16 #sec-class-definitions-runtime-semantics-evaluation
//   ClassDeclaration : `class` BindingIdentifier ClassTail

function* Evaluate_ClassDeclaration(ClassDeclaration) {
  let _temp7 = yield* BindingClassDeclarationEvaluation_ClassDeclaration(ClassDeclaration);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }
  return new NormalCompletion(undefined);
}

// CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression

function* Evaluate_CoalesceExpression({
  left: CoalesceExpressionHead,
  right: BitwiseORExpression
}) {
  // 1. Let lref be the result of evaluating |CoalesceExpressionHead|.
  const lref = yield* Evaluate(CoalesceExpressionHead); // 2. Let lval be ? GetValue(lref).

  let _temp = GetValue(lref);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lval = _temp; // 3. If lval is *undefined* or *null*,

  if (lval === Value.undefined || lval === Value.null) {
    // a. Let rref be the result of evaluating |BitwiseORExpression|.
    const rref = yield* Evaluate(BitwiseORExpression); // b. Return ? GetValue(rref).

    return GetValue(rref);
  } // 4. Otherwise, return lval.


  return lval;
}

// ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

function* Evaluate_ConditionalExpression({
  test: ShortCircuitExpression,
  consequent: FirstAssignmentExpression,
  alternate: SecondAssignmentExpression
}) {
  // 1. Let lref be the result of evaluating ShortCircuitExpression.
  const lref = yield* Evaluate(ShortCircuitExpression); // 2. Let lval be ! ToBoolean(? GetValue(lref)).

  let _temp = GetValue(lref);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lval = ToBoolean(_temp); // 3. If lval is true, then

  if (lval === Value.true) {
    // a. Let trueRef be the result of evaluating the first AssignmentExpression.
    const trueRef = yield* Evaluate(FirstAssignmentExpression); // b. Return ? GetValue(trueRef).

    return GetValue(trueRef);
  } else {
    // a. Let falseRef be the result of evaluating the second AssignmentExpression.
    const falseRef = yield* Evaluate(SecondAssignmentExpression); // b. Return ? GetValue(falseRef).

    return GetValue(falseRef);
  }
}

// ContinueStatement :
//   `continue` `;`
//   `continue` LabelIdentifier `;`

function Evaluate_ContinueStatement({
  label: LabelIdentifier
}) {
  if (LabelIdentifier) {
    const label = new Value(LabelIdentifier.name);
    return new ContinueCompletion(label);
  } else {
    return new ContinueCompletion(undefined);
  }
}

function hasIntersection(reference, check) {
  if (reference.length === 0 || check.length === 0) {
    return false;
  }

  const refSet = new ValueSet(reference);

  for (const el of check) {
    if (refSet.has(el)) {
      return el;
    }
  }

  return false;
} // #table-dynamic-function-sourcetext-prefixes


const DynamicFunctionSourceTextPrefixes = {
  'normal': 'function',
  'generator': 'function*',
  'async': 'async function',
  'async generator': 'async function*'
}; // 19.2.1.1.1 #sec-createdynamicfunction

function CreateDynamicFunction(constructor, newTarget, kind, args) {
  Assert(surroundingAgent.executionContextStack.length >= 2, "surroundingAgent.executionContextStack.length >= 2");
  const callerContext = surroundingAgent.executionContextStack[surroundingAgent.executionContextStack.length - 2];
  const callerRealm = callerContext.Realm;
  const calleeRealm = surroundingAgent.currentRealmRecord;

  let _temp = HostEnsureCanCompileStrings(callerRealm, calleeRealm);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  if (Type(newTarget) === 'Undefined') {
    newTarget = constructor;
  }

  let bodyParser;
  let enableYield;
  let enableAwait;
  let fallbackProto;

  if (kind === 'normal') {
    bodyParser = ParseAsFunctionBody;
    enableYield = false;
    enableAwait = false;
    fallbackProto = '%Function.prototype%';
  } else if (kind === 'generator') {
    bodyParser = ParseAsGeneratorBody;
    enableYield = true;
    enableAwait = false;
    fallbackProto = '%Generator%';
  } else if (kind === 'async') {
    bodyParser = ParseAsAsyncFunctionBody;
    enableYield = false;
    enableAwait = true;
    fallbackProto = '%AsyncFunction.prototype%';
  } else if (kind === 'async generator') {
    bodyParser = ParseAsAsyncGeneratorBody;
    enableYield = true;
    enableAwait = true;
    fallbackProto = '%AsyncGeneratorFunction.prototype%';
  }

  const argCount = args.length;
  let P = '';
  let bodyText;

  if (argCount === 0) {
    bodyText = new Value('');
  } else if (argCount === 1) {
    bodyText = args[0];
  } else {
    const firstArg = args[0];

    let _temp2 = ToString(firstArg);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    P = _temp2.stringValue();
    let k = 1;

    while (k < argCount - 1) {
      const nextArg = args[k];

      let _temp3 = ToString(nextArg);

      if (_temp3 instanceof AbruptCompletion) {
        return _temp3;
      }

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      const nextArgString = _temp3;
      P = `${P},${nextArgString.stringValue()}`;
      k += 1;
    }

    bodyText = args[k];
  }

  let _temp4 = ToString(bodyText);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  bodyText = `\u000A${_temp4.stringValue()}\u000A`;
  let body;

  try {
    body = bodyParser(bodyText);
  } catch (err) {
    return surroundingAgent.Throw('SyntaxError', 'Raw', err.message);
  }

  const strict = ContainsUseStrict_FunctionBody(body);
  let parameters;

  try {
    parameters = ParseAsFormalParameters(P, strict, enableAwait, enableYield);
  } catch (err) {
    return surroundingAgent.Throw('SyntaxError', 'Raw', err.message);
  } // These steps are included in ParseAsFormalParameters:
  // 20. If strict is true, the Early Error rules for UniqueFormalParameters : FormalParameters are applied.
  // 21. If strict is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.
  // 24. If parameters Contains SuperCall is true, throw a SyntaxError exception.
  // 26. If parameters Contains SuperProperty is true, throw a SyntaxError exception.
  // 27. If kind is "generator" or "async generator", then
  //   a. If parameters Contains YieldExpression is true, throw a SyntaxError exception.
  // 28. If kind is "async" or "async generator", then
  //   a. If parameters Contains AwaitExpression is true, throw a SyntaxError exception.
  // 29. If strict is true, then
  //   a. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.
  // 22. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.


  const intersected = hasIntersection(BoundNames_FormalParameters(parameters), LexicallyDeclaredNames_FunctionBody(body));

  if (intersected !== false) {
    return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', intersected);
  }

  const fabricatedFunctionNode = {
    type: 'FunctionExpression',
    id: null,
    generator: enableYield,
    expression: false,
    async: enableAwait,
    params: parameters,
    strict,
    body: {
      type: 'BlockStatement',
      body,
      strict
    }
  };

  let _temp5 = GetPrototypeFromConstructor(newTarget, fallbackProto);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const proto = _temp5;
  const realmF = surroundingAgent.currentRealmRecord;
  const scope = realmF.GlobalEnv;

  let _temp6 = OrdinaryFunctionCreate(proto, parameters, fabricatedFunctionNode, 'Normal', scope);

  Assert(!(_temp6 instanceof AbruptCompletion), "OrdinaryFunctionCreate(proto, parameters, fabricatedFunctionNode, 'Normal', scope)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const F = _temp6;

  if (kind === 'generator') {
    const prototype = ObjectCreate(surroundingAgent.intrinsic('%Generator.prototype%'));

    let _temp7 = DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    }));

    Assert(!(_temp7 instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    }))" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }
  } else if (kind === 'async generator') {
    const prototype = ObjectCreate(surroundingAgent.intrinsic('%AsyncGenerator.prototype%'));

    let _temp8 = DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    }));

    Assert(!(_temp8 instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    }))" + ' returned an abrupt completion');

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }
  } else if (kind === 'normal') {
    MakeConstructor(F);
  }

  SetFunctionName(F, new Value('anonymous'));
  const prefix = DynamicFunctionSourceTextPrefixes[kind];
  const sourceText = `${prefix} anonymous(${P}\u000A) {${bodyText}}`;
  F.SourceText = new Value(sourceText);
  return F;
}

// DebuggerStatement : `debugger` `;`

function Evaluate_DebuggerStatement() {
  let result; // 1. If an implementation-defined debugging facility is available and enabled, then

  if (surroundingAgent.hostDefinedOptions.onDebugger) {
    // a. Perform an implementation-defined debugging action.
    // b. Let result be an implementation-defined Completion value.
    result = EnsureCompletion(surroundingAgent.hostDefinedOptions.onDebugger());
  } else {
    // a. Let result be NormalCompletion(empty).
    result = NormalCompletion(undefined);
  } // 2. Return result.


  return result;
}

// MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`

function* DefineMethod(MethodDefinition, object, functionPrototype) {
  const PropertyName = MethodDefinition.key;
  const UniqueFormalParameters = MethodDefinition.value.params;
  let propKey = yield* Evaluate_PropertyName(PropertyName, MethodDefinition.computed);

  /* istanbul ignore if */
  if (propKey instanceof AbruptCompletion) {
    return propKey;
  }
  /* istanbul ignore if */


  if (propKey instanceof Completion) {
    propKey = propKey.Value;
  }
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  let prototype;

  if (functionPrototype !== undefined) {
    prototype = functionPrototype;
  } else {
    prototype = surroundingAgent.intrinsic('%Function.prototype%');
  }

  let _temp = OrdinaryFunctionCreate(prototype, UniqueFormalParameters, MethodDefinition.value, 'non-lexical-this', scope);

  Assert(!(_temp instanceof AbruptCompletion), "OrdinaryFunctionCreate(prototype, UniqueFormalParameters, MethodDefinition.value, 'non-lexical-this', scope)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const closure = _temp;

  let _temp2 = MakeMethod(closure, object);

  Assert(!(_temp2 instanceof AbruptCompletion), "MakeMethod(closure, object)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  closure.SourceText = sourceTextMatchedBy(MethodDefinition);
  return {
    Key: propKey,
    Closure: closure
  };
}

//   AssignmentPattern :
//     ObjectAssignmentPattern
//     ArrayAssignmentPattern

function* DestructuringAssignmentEvaluation_AssignmentPattern(AssignmentPattern, value) {
  switch (true) {
    case isObjectAssignmentPattern(AssignmentPattern):
      return yield* DestructuringAssignmentEvaluation_ObjectAssignmentPattern(AssignmentPattern, value);

    case isArrayAssignmentPattern(AssignmentPattern):
      return yield* DestructuringAssignmentEvaluation_ArrayAssignmentPattern(AssignmentPattern, value);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('DestructuringAssignmentEvaluation_AssignmentPattern', AssignmentPattern);
  }
} // 12.15.5.2 #sec-runtime-semantics-destructuringassignmentevaluation
//   ObjectAssignmentPattern :
//     `{` `}`
//     `{` AssignmentRestProperty `}`
//     `{` AssignmentPropertyList `}`
//     `{` AssignmentPropertyList `,` `}`
//     `{` AssignmentPropertyList `,` AssignmentRestProperty `}`

function* DestructuringAssignmentEvaluation_ObjectAssignmentPattern(ObjectAssignmentPattern, value) {
  let AssignmentPropertyList = ObjectAssignmentPattern.properties;
  let AssignmentRestProperty; // Members of the AssignmentPropertyList may be null, so add a truthyness check.

  if (AssignmentPropertyList.length > 0 && AssignmentPropertyList[AssignmentPropertyList.length - 1] && isAssignmentRestProperty(AssignmentPropertyList[AssignmentPropertyList.length - 1])) {
    AssignmentRestProperty = AssignmentPropertyList[AssignmentPropertyList.length - 1];
    AssignmentPropertyList = AssignmentPropertyList.slice(0, -1);
  }

  let _temp = RequireObjectCoercible(value);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  let excludedNames = [];

  if (AssignmentPropertyList.length > 0) {
    let _temp2 = yield* PropertyDestructuringAssignmentEvaluation_AssignmentPropertyList(AssignmentPropertyList, value);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    excludedNames = _temp2;
  }

  if (AssignmentRestProperty === undefined) {
    return new NormalCompletion(undefined);
  }

  return yield* RestDestructuringAssignmentEvaluation_AssignmentRestProperty(AssignmentRestProperty, value, excludedNames);
} // 12.15.5.2 #sec-runtime-semantics-destructuringassignmentevaluation
//   ArrayAssignmentPattern :
//     `[` `]`
//     `[` Elision `]`
//     `[` Elision_opt AssignmentRestProperty `]`
//     `[` AssignmentElementList `]`
//     `[` AssignmentElementList `,` Elision_opt AssignmentRestProperty_opt `]`


function* DestructuringAssignmentEvaluation_ArrayAssignmentPattern(ArrayAssignmentPattern, value) {
  let Elision;
  let AssignmentElementList = ArrayAssignmentPattern.elements;
  let AssignmentRestProperty; // Members of the AssignmentElementList may be null, so add a truthyness check.

  if (AssignmentElementList.length > 0 && AssignmentElementList[AssignmentElementList.length - 1] && isAssignmentRestProperty(AssignmentElementList[AssignmentElementList.length - 1])) {
    AssignmentRestProperty = AssignmentElementList[AssignmentElementList.length - 1];
    AssignmentElementList = AssignmentElementList.slice(0, -1);
  }

  if (AssignmentElementList.length > 0) {
    let begin;

    for (begin = AssignmentElementList.length; begin > 0; begin -= 1) {
      if (AssignmentElementList[begin - 1] !== null) {
        break;
      }
    }

    if (begin !== AssignmentElementList.length) {
      Elision = AssignmentElementList.slice(begin);
      AssignmentElementList = AssignmentElementList.slice(0, begin);
    }
  }

  let _temp3 = GetIterator(value);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const iteratorRecord = _temp3; // ArrayAssignmentPattern : `[` `]`

  if (AssignmentElementList.length === 0 && Elision === undefined && AssignmentRestProperty === undefined) {
    return IteratorClose(iteratorRecord, new NormalCompletion(undefined));
  }

  let status;

  if (AssignmentElementList.length > 0) {
    status = yield* IteratorDestructuringAssignmentEvaluation_AssignmentElementList(AssignmentElementList, iteratorRecord);

    if (status instanceof AbruptCompletion) {
      if (iteratorRecord.Done === Value.false) {
        return IteratorClose(iteratorRecord, status);
      }

      return Completion(status);
    }
  }

  if (Elision !== undefined) {
    status = IteratorDestructuringAssignmentEvaluation_Elision(Elision, iteratorRecord);

    if (AssignmentRestProperty === undefined) ; else {
      // ArrayAssignmentPattern :
      //   `[` Elision AssignmentRestElement `]`
      //   `[` AssignmentElementList `,` Elision AssignmentRestElement_opt `]`
      if (status instanceof AbruptCompletion) {
        Assert(iteratorRecord.Done === Value.true, "iteratorRecord.Done === Value.true");
        return Completion(status);
      }
    }
  }

  if (AssignmentRestProperty !== undefined) {
    status = yield* IteratorDestructuringAssignmentEvaluation_AssignmentRestProperty(AssignmentRestProperty, iteratorRecord);
  }

  if (iteratorRecord.Done === Value.false) {
    return IteratorClose(iteratorRecord, status);
  }

  return Completion(status);
} // 12.15.5.3 #sec-runtime-semantics-propertydestructuringassignmentevaluation
//   AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty
//
// (implicit)
//   AssignmentPropertyList : AssignmentProperty


function* PropertyDestructuringAssignmentEvaluation_AssignmentPropertyList(AssignmentPropertyList, value) {
  const propertyNames = [];

  for (const AssignmentProperty of AssignmentPropertyList) {
    let _temp4 = yield* PropertyDestructuringAssignmentEvaluation_AssignmentProperty(AssignmentProperty, value);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const nextNames = _temp4;
    propertyNames.push(...nextNames);
  }

  return propertyNames;
} // 12.15.5.3 #sec-runtime-semantics-propertydestructuringassignmentevaluation
//   AssignmentProperty :
//     IdentifierReference Initializer_opt
//     PropertyName `:` AssignmentElement


function* PropertyDestructuringAssignmentEvaluation_AssignmentProperty(AssignmentProperty, value) {
  if (AssignmentProperty.shorthand) {
    // AssignmentProperty : IdentifierReference Initializer_opt
    const IdentifierReference = AssignmentProperty.key;
    let Initializer;

    if (AssignmentProperty.value.type === 'AssignmentPattern') {
      Initializer = AssignmentProperty.value.right;
    }

    const P = new Value(IdentifierReference.name);

    let _temp5 = ResolveBinding(P, undefined, IdentifierReference.strict);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const lref = _temp5;

    let _temp6 = GetV(value, P);

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    let v = _temp6;

    if (Initializer !== undefined && Type(v) === 'Undefined') {
      if (IsAnonymousFunctionDefinition(Initializer)) {
        v = yield* NamedEvaluation_Expression(Initializer, P);
      } else {
        const defaultValue = yield* Evaluate(Initializer);

        let _temp7 = GetValue(defaultValue);

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        v = _temp7;
      }
    }

    let _temp8 = PutValue(lref, v);

    if (_temp8 instanceof AbruptCompletion) {
      return _temp8;
    }

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }
    return [P];
  }

  const {
    key: PropertyName,
    value: AssignmentElement
  } = AssignmentProperty;
  let name = yield* Evaluate_PropertyName(PropertyName, AssignmentProperty.computed);

  /* istanbul ignore if */
  if (name instanceof AbruptCompletion) {
    return name;
  }
  /* istanbul ignore if */


  if (name instanceof Completion) {
    name = name.Value;
  }

  let _temp9 = yield* KeyedDestructuringAssignmentEvaluation_AssignmentElement(AssignmentElement, value, name);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }
  return [name];
} // 12.15.5.4 #sec-runtime-semantics-restdestructuringassignmentevaluation
//   AssignmentRestProperty : `...` DestructuringAssignmentTarget


function* RestDestructuringAssignmentEvaluation_AssignmentRestProperty(AssignmentRestProperty, value, excludedNames) {
  const DestructuringAssignmentTarget = AssignmentRestProperty.argument;
  let lref = yield* Evaluate(DestructuringAssignmentTarget);

  if (lref instanceof AbruptCompletion) {
    return lref;
  }

  if (lref instanceof Completion) {
    lref = lref.Value;
  }
  const restObj = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  let _temp10 = CopyDataProperties(restObj, value, excludedNames);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }
  return PutValue(lref, restObj);
} // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
//   AssignmentElementList :
//     AssignmentElisionElement
//     AssignmentElementList `,` AssignmentElisionElement


function* IteratorDestructuringAssignmentEvaluation_AssignmentElementList(AssignmentElementList, iteratorRecord) {
  Assert(AssignmentElementList.length > 0, "AssignmentElementList.length > 0");
  let result;

  for (const AssignmentElisionElement of AssignmentElementList) {
    let _temp11 = yield* IteratorDestructuringAssignmentEvaluation_AssignmentElisionElement(AssignmentElisionElement, iteratorRecord);

    if (_temp11 instanceof AbruptCompletion) {
      return _temp11;
    }

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    result = _temp11;
  }

  return result;
} // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
//   AssignmentElisionElement :
//     AssignmentElement
//     Elision AssignmentElement


function* IteratorDestructuringAssignmentEvaluation_AssignmentElisionElement(AssignmentElisionElement, iteratorRecord) {
  if (!AssignmentElisionElement) {
    // This is an elision.
    return IteratorDestructuringAssignmentEvaluation_Elision([AssignmentElisionElement], iteratorRecord);
  }

  return yield* IteratorDestructuringAssignmentEvaluation_AssignmentElement(AssignmentElisionElement, iteratorRecord);
} // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
//   AssignmentElement : DestructuringAssignmentTarget Initializer_opt


function* IteratorDestructuringAssignmentEvaluation_AssignmentElement(AssignmentElement, iteratorRecord) {
  let DestructuringAssignmentTarget = AssignmentElement;
  let Initializer;

  if (AssignmentElement.type === 'AssignmentPattern') {
    DestructuringAssignmentTarget = AssignmentElement.left;
    Initializer = AssignmentElement.right;
  }

  let lref;

  if (!isAssignmentPattern(DestructuringAssignmentTarget)) {
    lref = yield* Evaluate(DestructuringAssignmentTarget);

    if (lref instanceof AbruptCompletion) {
      return lref;
    }

    if (lref instanceof Completion) {
      lref = lref.Value;
    }
  }

  let value;

  if (iteratorRecord.Done === Value.false) {
    let next = IteratorStep(iteratorRecord);

    if (next instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (next instanceof AbruptCompletion) {
      return next;
    }

    if (next instanceof Completion) {
      next = next.Value;
    }

    if (next === Value.false) {
      iteratorRecord.Done = Value.true;
    } else {
      value = IteratorValue(next);

      if (value instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (value instanceof AbruptCompletion) {
        return value;
      }

      if (value instanceof Completion) {
        value = value.Value;
      }
    }
  }

  if (iteratorRecord.Done === Value.true) {
    value = Value.undefined;
  }

  let v;

  if (Initializer !== undefined && value === Value.undefined) {
    if (IsAnonymousFunctionDefinition(Initializer) && IsIdentifierRef(DestructuringAssignmentTarget)) {
      v = yield* NamedEvaluation_Expression(Initializer, GetReferencedName(lref));
    } else {
      const defaultValue = yield* Evaluate(Initializer);

      let _temp12 = GetValue(defaultValue);

      if (_temp12 instanceof AbruptCompletion) {
        return _temp12;
      }

      if (_temp12 instanceof Completion) {
        _temp12 = _temp12.Value;
      }

      v = _temp12;
    }
  } else {
    v = value;
  }

  if (isAssignmentPattern(DestructuringAssignmentTarget)) {
    const nestedAssignmentPattern = DestructuringAssignmentTarget;
    return yield* DestructuringAssignmentEvaluation_AssignmentPattern(nestedAssignmentPattern, v);
  }

  return PutValue(lref, v);
} // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
//   Elision :
//     `,`
//     Elision `,`


function IteratorDestructuringAssignmentEvaluation_Elision(Elision, iteratorRecord) {
  let remaining = Elision.length;

  while (remaining > 0 && iteratorRecord.Done === Value.false) {
    let next = IteratorStep(iteratorRecord);

    if (next instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (next instanceof AbruptCompletion) {
      return next;
    }

    if (next instanceof Completion) {
      next = next.Value;
    }

    if (next === Value.false) {
      iteratorRecord.Done = Value.true;
    }

    remaining -= 1;
  }

  return new NormalCompletion(undefined);
} // 12.15.5.5 #sec-runtime-semantics-iteratordestructuringassignmentevaluation
//   AssignmentRestElement : `...` DestructuringAssignmentTarget

function* IteratorDestructuringAssignmentEvaluation_AssignmentRestProperty(AssignmentRestProperty, iteratorRecord) {
  const DestructuringAssignmentTarget = AssignmentRestProperty.argument;
  let lref;

  if (!isAssignmentPattern(DestructuringAssignmentTarget)) {
    lref = yield* Evaluate(DestructuringAssignmentTarget);

    if (lref instanceof AbruptCompletion) {
      return lref;
    }

    if (lref instanceof Completion) {
      lref = lref.Value;
    }
  }

  let _temp13 = ArrayCreate(new Value(0));

  Assert(!(_temp13 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  const A = _temp13;
  let n = 0;

  while (iteratorRecord.Done === Value.false) {
    let next = IteratorStep(iteratorRecord);

    if (next instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (next instanceof AbruptCompletion) {
      return next;
    }

    if (next instanceof Completion) {
      next = next.Value;
    }

    if (next === Value.false) {
      iteratorRecord.Done = Value.true;
    } else {
      let nextValue = IteratorValue(next);

      if (nextValue instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (nextValue instanceof AbruptCompletion) {
        return nextValue;
      }

      if (nextValue instanceof Completion) {
        nextValue = nextValue.Value;
      }

      let _temp14 = CreateDataProperty(A, ToString(new Value(n)), nextValue);

      Assert(!(_temp14 instanceof AbruptCompletion), "CreateDataProperty(A, ToString(new Value(n)), nextValue)" + ' returned an abrupt completion');

      if (_temp14 instanceof Completion) {
        _temp14 = _temp14.Value;
      }

      const status = _temp14;
      Assert(status === Value.true, "status === Value.true");
      n += 1;
    }
  }

  if (!isAssignmentPattern(DestructuringAssignmentTarget)) {
    return PutValue(lref, A);
  }

  const nestedAssignmentPattern = DestructuringAssignmentTarget;
  return yield* DestructuringAssignmentEvaluation_AssignmentPattern(nestedAssignmentPattern, A);
} // 12.15.5.6 #sec-runtime-semantics-keyeddestructuringassignmentevaluation
//   AssignmentElement : DestructuringAssignmentTarget Initializer_opt


function* KeyedDestructuringAssignmentEvaluation_AssignmentElement(AssignmentElement, value, propertyName) {
  let DestructuringAssignmentTarget = AssignmentElement;
  let Initializer;

  if (AssignmentElement.type === 'AssignmentPattern') {
    DestructuringAssignmentTarget = AssignmentElement.left;
    Initializer = AssignmentElement.right;
  }

  let lref;

  if (!isAssignmentPattern(DestructuringAssignmentTarget)) {
    lref = yield* Evaluate(DestructuringAssignmentTarget);

    if (lref instanceof AbruptCompletion) {
      return lref;
    }

    if (lref instanceof Completion) {
      lref = lref.Value;
    }
  }

  let _temp15 = GetV(value, propertyName);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const v = _temp15;
  let rhsValue;

  if (Initializer !== undefined && v === Value.undefined) {
    if (IsAnonymousFunctionDefinition(Initializer) && IsIdentifierRef(DestructuringAssignmentTarget)) {
      rhsValue = yield* NamedEvaluation_Expression(Initializer, GetReferencedName(lref));
    } else {
      const defaultValue = yield* Evaluate(Initializer);

      let _temp16 = GetValue(defaultValue);

      if (_temp16 instanceof AbruptCompletion) {
        return _temp16;
      }

      if (_temp16 instanceof Completion) {
        _temp16 = _temp16.Value;
      }

      rhsValue = _temp16;
    }
  } else {
    rhsValue = v;
  }

  if (isAssignmentPattern(DestructuringAssignmentTarget)) {
    const assignmentPattern = DestructuringAssignmentTarget;
    return yield* DestructuringAssignmentEvaluation_AssignmentPattern(assignmentPattern, rhsValue);
  }

  return PutValue(lref, rhsValue);
}

//   EmptyStatement : `;`

function Evaluate_EmptyStatement()
/* EmptyStatement */
{
  return new NormalCompletion(undefined);
}

// EqualityExpression :
//   EqualityExpression `==` RelationalExpression
//   EqualityExpression `!=` RelationalExpression
//   EqualityExpression `===` RelationalExpression
//   EqualityExpression `!==` RelationalExpression

function* Evaluate_EqualityExpression({
  left: EqualityExpression,
  operator,
  right: RelationalExpression
}) {
  const lref = yield* Evaluate(EqualityExpression);

  let _temp = GetValue(lref);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lval = _temp;
  const rref = yield* Evaluate(RelationalExpression);

  let _temp2 = GetValue(rref);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const rval = _temp2;

  switch (operator) {
    case '==':
      return AbstractEqualityComparison(rval, lval);

    case '!=':
      {
        let _temp3 = AbstractEqualityComparison(rval, lval);

        if (_temp3 instanceof AbruptCompletion) {
          return _temp3;
        }

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }

        const r = _temp3;

        if (r === Value.true) {
          return Value.false;
        } else {
          return Value.true;
        }
      }

    case '===':
      return StrictEqualityComparison(rval, lval);

    case '!==':
      {
        let _temp4 = StrictEqualityComparison(rval, lval);

        Assert(!(_temp4 instanceof AbruptCompletion), "StrictEqualityComparison(rval, lval)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }

        const r = _temp4;

        if (r === Value.true) {
          return Value.false;
        } else {
          return Value.true;
        }
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_EqualityExpression', operator);
  }
}

function* FunctionDeclarationInstantiation(func, argumentsList) {
  const calleeContext = surroundingAgent.runningExecutionContext;
  const env = calleeContext.LexicalEnvironment;
  const envRec = env.EnvironmentRecord;
  const code = func.ECMAScriptCode;
  const strict = func.Strict;
  const formals = func.FormalParameters;
  const parameterNames = BoundNames_FormalParameters(formals);
  const hasDuplicates = parameterNames.some(e => parameterNames.indexOf(e) !== parameterNames.lastIndexOf(e));
  const simpleParameterList = IsSimpleParameterList_FormalParameters(formals);
  const hasParameterExpressions = ContainsExpression_FormalParameters(formals);
  let varNames;
  let varDeclarations;
  let lexicalNames;

  switch (getFunctionBodyType(code)) {
    case 'FunctionBody':
      varNames = VarDeclaredNames_FunctionBody(code.body.body);
      varDeclarations = VarScopedDeclarations_FunctionBody(code.body.body);
      lexicalNames = LexicallyDeclaredNames_FunctionBody(code.body.body);
      break;

    case 'ConciseBody_ExpressionBody':
    case 'ConciseBody_FunctionBody':
    case 'AsyncConciseBody_AsyncFunctionBody':
    case 'AsyncConciseBody_ExpressionBody':
    case 'AsyncGeneratorBody':
      varNames = VarDeclaredNames_ConciseBody(code.body);
      varDeclarations = VarScopedDeclarations_ConciseBody(code.body);
      lexicalNames = LexicallyDeclaredNames_ConciseBody(code.body);
      break;

    case 'GeneratorBody':
      varNames = VarDeclaredNames_GeneratorBody(code.body.body);
      varDeclarations = VarScopedDeclarations_GeneratorBody(code.body.body);
      lexicalNames = LexicallyDeclaredNames_GeneratorBody(code.body.body);
      break;

    case 'AsyncFunctionBody':
      varNames = VarDeclaredNames_AsyncFunctionBody(code.body.body);
      varDeclarations = VarScopedDeclarations_AsyncFunctionBody(code.body.body);
      lexicalNames = LexicallyDeclaredNames_AsyncFunctionBody(code.body.body);
      break;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('FunctionDeclarationInstantiation', code);
  }

  const functionNames = [];
  const functionsToInitialize = [];

  for (const d of [...varDeclarations].reverse()) {
    if (!isVariableDeclaration(d) && !isForBinding(d) && !isBindingIdentifier(d)) {
      Assert(isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d), "isFunctionDeclaration(d) || isGeneratorDeclaration(d)\n             || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)");
      const fn = BoundNames_FunctionDeclaration(d)[0];

      if (!functionNames.includes(fn)) {
        functionNames.unshift(fn);
        functionsToInitialize.unshift(d);
      }
    }
  }

  let argumentsObjectNeeded = true;

  if (func.ThisMode === 'lexical') {
    argumentsObjectNeeded = false;
  } else if (parameterNames.includes('arguments')) {
    argumentsObjectNeeded = false;
  } else if (hasParameterExpressions === false) {
    if (functionNames.includes('arguments') || lexicalNames.includes('arguments')) {
      argumentsObjectNeeded = false;
    }
  }

  for (const paramName of parameterNames) {
    const alreadyDeclared = envRec.HasBinding(new Value(paramName));

    if (alreadyDeclared === Value.false) {
      let _temp = envRec.CreateMutableBinding(new Value(paramName), false);

      Assert(!(_temp instanceof AbruptCompletion), "envRec.CreateMutableBinding(new Value(paramName), false)" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      if (hasDuplicates === true) {
        let _temp2 = envRec.InitializeBinding(new Value(paramName), Value.undefined);

        Assert(!(_temp2 instanceof AbruptCompletion), "envRec.InitializeBinding(new Value(paramName), Value.undefined)" + ' returned an abrupt completion');

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }
      }
    }
  }

  let parameterBindings;

  if (argumentsObjectNeeded === true) {
    let ao;

    if (strict || simpleParameterList === false) {
      ao = CreateUnmappedArgumentsObject(argumentsList);
    } else {
      ao = CreateMappedArgumentsObject(func, formals, argumentsList, envRec);
    }

    if (strict) {
      let _temp3 = envRec.CreateImmutableBinding(new Value('arguments'), Value.false);

      Assert(!(_temp3 instanceof AbruptCompletion), "envRec.CreateImmutableBinding(new Value('arguments'), Value.false)" + ' returned an abrupt completion');

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }
    } else {
      let _temp4 = envRec.CreateMutableBinding(new Value('arguments'), false);

      Assert(!(_temp4 instanceof AbruptCompletion), "envRec.CreateMutableBinding(new Value('arguments'), false)" + ' returned an abrupt completion');

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }
    }

    envRec.InitializeBinding(new Value('arguments'), ao);
    parameterBindings = [...parameterNames, 'arguments'];
  } else {
    parameterBindings = parameterNames;
  }

  const iteratorRecord = CreateListIteratorRecord(argumentsList);

  if (hasDuplicates) {
    let _temp5 = yield* IteratorBindingInitialization_FormalParameters(formals, iteratorRecord, Value.undefined);
    /* istanbul ignore if */


    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }
    /* istanbul ignore if */


    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }
  } else {
    let _temp6 = yield* IteratorBindingInitialization_FormalParameters(formals, iteratorRecord, env);

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
  }

  let varEnv;
  let varEnvRec;

  if (hasParameterExpressions === false) {
    const instantiatedVarNames = [...parameterBindings];

    for (const n of varNames) {
      if (!instantiatedVarNames.includes(n)) {
        instantiatedVarNames.push(n);

        let _temp7 = envRec.CreateMutableBinding(new Value(n), false);

        Assert(!(_temp7 instanceof AbruptCompletion), "envRec.CreateMutableBinding(new Value(n), false)" + ' returned an abrupt completion');

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }
        envRec.InitializeBinding(new Value(n), Value.undefined);
      }
    }

    varEnv = env;
    varEnvRec = envRec;
  } else {
    varEnv = NewDeclarativeEnvironment(env);
    varEnvRec = varEnv.EnvironmentRecord;
    calleeContext.VariableEnvironment = varEnv;
    const instantiatedVarNames = [];

    for (const n of varNames) {
      if (!instantiatedVarNames.includes(n)) {
        instantiatedVarNames.push(n);

        let _temp8 = varEnvRec.CreateMutableBinding(new Value(n), false);

        Assert(!(_temp8 instanceof AbruptCompletion), "varEnvRec.CreateMutableBinding(new Value(n), false)" + ' returned an abrupt completion');

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }
        let initialValue;

        if (!parameterBindings.includes(n) || functionNames.includes(n)) {
          initialValue = Value.undefined;
        } else {
          let _temp9 = envRec.GetBindingValue(new Value(n), Value.false);

          Assert(!(_temp9 instanceof AbruptCompletion), "envRec.GetBindingValue(new Value(n), Value.false)" + ' returned an abrupt completion');

          if (_temp9 instanceof Completion) {
            _temp9 = _temp9.Value;
          }

          initialValue = _temp9;
        }

        varEnvRec.InitializeBinding(new Value(n), initialValue);
      }
    }
  } // NOTE: Annex B.3.3.1 adds additional steps at this point.


  let lexEnv;

  if (strict === false) {
    lexEnv = NewDeclarativeEnvironment(varEnv);
  } else {
    lexEnv = varEnv;
  }

  const lexEnvRec = lexEnv.EnvironmentRecord;
  lexEnv.EnvironmentRecord = lexEnvRec;
  calleeContext.LexicalEnvironment = lexEnv;
  let lexDeclarations;

  switch (getFunctionBodyType(code)) {
    case 'FunctionBody':
      lexDeclarations = LexicallyScopedDeclarations_FunctionBody(code.body.body);
      break;

    case 'ConciseBody_ExpressionBody':
    case 'ConciseBody_FunctionBody':
    case 'AsyncConciseBody_ExpressionBody':
    case 'AsyncConciseBody_AsyncFunctionBody':
      lexDeclarations = LexicallyScopedDeclarations_ConciseBody(code.body);
      break;

    case 'GeneratorBody':
      lexDeclarations = LexicallyScopedDeclarations_GeneratorBody(code.body.body);
      break;

    case 'AsyncFunctionBody':
    case 'AsyncGeneratorBody':
      lexDeclarations = LexicallyScopedDeclarations_AsyncFunctionBody(code.body.body);
      break;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('FunctionDeclarationInstantiation', code);
  }

  for (const d of lexDeclarations) {
    for (const dn of BoundNames_Declaration(d)) {
      if (IsConstantDeclaration(d)) {
        let _temp10 = lexEnvRec.CreateImmutableBinding(new Value(dn), Value.true);

        Assert(!(_temp10 instanceof AbruptCompletion), "lexEnvRec.CreateImmutableBinding(new Value(dn), Value.true)" + ' returned an abrupt completion');

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }
      } else {
        let _temp11 = lexEnvRec.CreateMutableBinding(new Value(dn), false);

        Assert(!(_temp11 instanceof AbruptCompletion), "lexEnvRec.CreateMutableBinding(new Value(dn), false)" + ' returned an abrupt completion');

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }
      }
    }
  }

  for (const f of functionsToInitialize) {
    const fn = BoundNames_FunctionDeclaration(f)[0];
    const fo = InstantiateFunctionObject(f, lexEnv);

    let _temp12 = varEnvRec.SetMutableBinding(new Value(fn), fo, Value.false);

    Assert(!(_temp12 instanceof AbruptCompletion), "varEnvRec.SetMutableBinding(new Value(fn), fo, Value.false)" + ' returned an abrupt completion');

    if (_temp12 instanceof Completion) {
      _temp12 = _temp12.Value;
    }
  }

  return new NormalCompletion(undefined);
}
function getFunctionBodyType(ECMAScriptCode) {
  switch (true) {
    // FunctionBody : FunctionStatementList
    case isFunctionDeclaration(ECMAScriptCode) || isFunctionExpression(ECMAScriptCode):
      // includes MethodDefinitions
      return 'FunctionBody';
    // ConciseBody : `{` FunctionBody `}`

    case isArrowFunction(ECMAScriptCode) && !ECMAScriptCode.expression:
      return 'ConciseBody_FunctionBody';
    // ConciseBody : ExpressionBody

    case isArrowFunction(ECMAScriptCode) && ECMAScriptCode.expression:
      return 'ConciseBody_ExpressionBody';
    // AsyncConciseBody : `{` AsyncFunctionBody `}`

    case isAsyncArrowFunction(ECMAScriptCode) && !ECMAScriptCode.expression:
      return 'AsyncConciseBody_AsyncFunctionBody';
    // AsyncConciseBody : ExpressionBody

    case isAsyncArrowFunction(ECMAScriptCode) && ECMAScriptCode.expression:
      return 'AsyncConciseBody_ExpressionBody';
    // GeneratorBody : FunctionBody

    case isGeneratorDeclaration(ECMAScriptCode) || isGeneratorExpression(ECMAScriptCode):
      return 'GeneratorBody';
    // AsyncFunctionBody : FunctionBody

    case isAsyncFunctionDeclaration(ECMAScriptCode) || isAsyncFunctionExpression(ECMAScriptCode):
      return 'AsyncFunctionBody';

    case isAsyncGeneratorDeclaration(ECMAScriptCode) || isAsyncGeneratorExpression(ECMAScriptCode):
      return 'AsyncGeneratorBody';

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('getFunctionBodyType', ECMAScriptCode);
  }
} // 14.2.15 #sec-arrow-function-definitions-runtime-semantics-evaluatebody
// ConciseBody : ExpressionBody

function* EvaluateBody_ConciseBody_ExpressionBody(ExpressionBody, functionObject, argumentsList) {
  let _temp13 = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }
  return yield* Evaluate_ExpressionBody(ExpressionBody);
} // 14.1.18 #sec-function-definitions-runtime-semantics-evaluatebody
// FunctionBody : FunctionStatementList

function* EvaluateBody_FunctionBody(FunctionStatementList, functionObject, argumentsList) {
  let _temp14 = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }
  return yield* Evaluate_FunctionStatementList(FunctionStatementList);
} // 14.4.10 #sec-generator-function-definitions-runtime-semantics-evaluatebody
// GeneratorBody : FunctionBody

function* EvaluateBody_GeneratorBody(GeneratorBody, functionObject, argumentsList) {
  let _temp15 = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  let _temp16 = OrdinaryCreateFromConstructor(functionObject, '%Generator.prototype%', ['GeneratorState', 'GeneratorContext']);

  if (_temp16 instanceof AbruptCompletion) {
    return _temp16;
  }

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }

  const G = _temp16;
  GeneratorStart(G, GeneratorBody);
  return new ReturnCompletion(G);
} // 14.7.11 #sec-async-function-definitions-EvaluateBody
// AsyncFunctionBody : FunctionBody

function* EvaluateBody_AsyncFunctionBody(FunctionBody, functionObject, argumentsList) {
  let _temp17 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

  Assert(!(_temp17 instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  const promiseCapability = _temp17;
  const declResult = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

  if (!(declResult instanceof AbruptCompletion)) {
    let _temp18 = AsyncFunctionStart(promiseCapability, FunctionBody);

    Assert(!(_temp18 instanceof AbruptCompletion), "AsyncFunctionStart(promiseCapability, FunctionBody)" + ' returned an abrupt completion');

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }
  } else {
    let _temp19 = Call(promiseCapability.Reject, Value.undefined, [declResult.Value]);

    Assert(!(_temp19 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [declResult.Value])" + ' returned an abrupt completion');

    if (_temp19 instanceof Completion) {
      _temp19 = _temp19.Value;
    }
  }

  return new Completion('return', promiseCapability.Promise, undefined);
} // 14.8.14 #sec-async-arrow-function-definitions-EvaluateBody
// AsyncConciseBody : ExpressionBody

function* EvaluateBody_AsyncConciseBody_ExpressionBody(ExpressionBody, functionObject, argumentsList) {
  let _temp20 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

  Assert(!(_temp20 instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }

  const promiseCapability = _temp20;
  const declResult = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

  if (!(declResult instanceof AbruptCompletion)) {
    let _temp21 = AsyncFunctionStart(promiseCapability, ExpressionBody);

    Assert(!(_temp21 instanceof AbruptCompletion), "AsyncFunctionStart(promiseCapability, ExpressionBody)" + ' returned an abrupt completion');

    if (_temp21 instanceof Completion) {
      _temp21 = _temp21.Value;
    }
  } else {
    let _temp22 = Call(promiseCapability.Reject, Value.undefined, [declResult.Value]);

    Assert(!(_temp22 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [declResult.Value])" + ' returned an abrupt completion');

    if (_temp22 instanceof Completion) {
      _temp22 = _temp22.Value;
    }
  }

  return new Completion('return', promiseCapability.Promise, undefined);
}
function* EvaluateBody_AsyncGeneratorBody(FunctionBody, functionObject, argumentsList) {
  let _temp23 = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);

  if (_temp23 instanceof AbruptCompletion) {
    return _temp23;
  }

  if (_temp23 instanceof Completion) {
    _temp23 = _temp23.Value;
  }

  let _temp24 = OrdinaryCreateFromConstructor(functionObject, '%AsyncGenerator.prototype%', ['AsyncGeneratorState', 'AsyncGeneratorContext', 'AsyncGeneratorQueue']);

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  const generator = _temp24;

  let _temp25 = AsyncGeneratorStart(generator, FunctionBody);

  Assert(!(_temp25 instanceof AbruptCompletion), "AsyncGeneratorStart(generator, FunctionBody)" + ' returned an abrupt completion');

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }
  return new Completion('return', generator, undefined);
}

function* EvaluatePropertyAccessWithExpressionKey(baseValue, expression, strict) {
  // 1. Let propertyNameReference be the result of evaluating expression.
  const propertyNameReference = yield* Evaluate(expression); // 2. Let propertyNameValue be ? GetValue(propertyNameReference).

  let _temp = GetValue(propertyNameReference);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const propertyNameValue = _temp; // 3. Let bv be ? RequireObjectCoercible(baseValue).

  let _temp2 = RequireObjectCoercible(baseValue);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const bv = _temp2; // 4. Let propertyKey be ? ToPropertyKey(propertyNameValue).

  let _temp3 = ToPropertyKey(propertyNameValue);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const propertyKey = _temp3; // 5. Return a value of type Reference whose base value component is bv, whose
  //    referenced name component is propertyKey, and whose strict reference flag is strict.

  return new Reference({
    BaseValue: bv,
    ReferencedName: propertyKey,
    StrictReference: strict ? Value.true : Value.false
  });
} // #sec-evaluate-identifier-key-property-access

function EvaluatePropertyAccessWithIdentifierKey(baseValue, identifierName, strict) {
  // 1. Assert: identifierName is an IdentifierName.
  Assert(isIdentifier(identifierName), "isIdentifier(identifierName)"); // 2. Let bv be ? RequireObjectCoercible(baseValue).

  let _temp4 = RequireObjectCoercible(baseValue);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const bv = _temp4; // 3. Let propertyNameString be StringValue of IdentifierName

  const propertyNameString = new Value(identifierName.name); // 4. Return a value of type Reference whose base value component is bv, whose
  //    referenced name component is propertyNameString, and whose strict reference flag is strict.

  return new Reference({
    BaseValue: bv,
    ReferencedName: propertyNameString,
    StrictReference: strict ? Value.true : Value.false
  });
}

function EvaluateBinopValues_ExponentiationExpression(lval, rval) {
  let _temp = ToNumeric(lval);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const base = _temp;

  let _temp2 = ToNumeric(rval);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const exponent = _temp2;

  if (Type(base) !== Type(exponent)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }

  return TypeNumeric(base).exponentiate(base, exponent);
} // 12.6.3 #sec-exp-operator-runtime-semantics-evaluation
// ExponentiationExpression : UpdateExpression ** ExponentiationExpression

function* Evaluate_ExponentiationExpression({
  left: UpdateExpression,
  right: ExponentiationExpression
}) {
  const left = yield* Evaluate(UpdateExpression);

  let _temp3 = GetValue(left);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const leftValue = _temp3;
  const right = yield* Evaluate(ExponentiationExpression);

  let _temp4 = GetValue(right);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const rightValue = _temp4;
  return EvaluateBinopValues_ExponentiationExpression(leftValue, rightValue);
}

// Expression : Expression `,` AssignmentExpression

function* Evaluate_ExpressionWithComma(ExpressionWithComma) {
  const expressions = [...ExpressionWithComma.expressions];
  const AssignmentExpression = expressions.pop();

  for (const Expression of expressions) {
    const lref = yield* Evaluate(Expression);

    let _temp = GetValue(lref);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }
  }

  const rref = yield* Evaluate(AssignmentExpression);
  return GetValue(rref);
}

function* Evaluate_ExportDeclaration(ExportDeclaration) {
  switch (true) {
    case isExportDeclarationWithStar(ExportDeclaration):
    case isExportDeclarationWithExportAndFrom(ExportDeclaration):
    case isExportDeclarationWithExport(ExportDeclaration):
      return new NormalCompletion(undefined);

    case isExportDeclarationWithVariable(ExportDeclaration):
    case isExportDeclarationWithDeclaration(ExportDeclaration):
    case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
      return yield* Evaluate(ExportDeclaration.declaration);

    case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
      {
        const ClassDeclaration = ExportDeclaration.declaration;

        let _temp = yield* BindingClassDeclarationEvaluation_ClassDeclaration(ClassDeclaration);
        /* istanbul ignore if */


        if (_temp instanceof AbruptCompletion) {
          return _temp;
        }
        /* istanbul ignore if */


        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }

        const value = _temp;
        const className = BoundNames_ClassDeclaration(ClassDeclaration)[0];

        if (className === '*default*') {
          const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;

          let _temp2 = InitializeBoundName(new Value('*default*'), value, env);

          if (_temp2 instanceof AbruptCompletion) {
            return _temp2;
          }

          if (_temp2 instanceof Completion) {
            _temp2 = _temp2.Value;
          }
        }

        return new NormalCompletion(undefined);
      }

    case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
      {
        const AssignmentExpression = ExportDeclaration.declaration;
        let value;

        if (IsAnonymousFunctionDefinition(AssignmentExpression)) {
          value = yield* NamedEvaluation_Expression(AssignmentExpression, new Value('default'));

          /* istanbul ignore if */
          if (value instanceof AbruptCompletion) {
            return value;
          }
          /* istanbul ignore if */


          if (value instanceof Completion) {
            value = value.Value;
          }
        } else {
          const rhs = yield* Evaluate(AssignmentExpression);

          let _temp3 = GetValue(rhs);

          if (_temp3 instanceof AbruptCompletion) {
            return _temp3;
          }

          if (_temp3 instanceof Completion) {
            _temp3 = _temp3.Value;
          }

          value = _temp3;
        }

        const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;

        let _temp4 = InitializeBoundName(new Value('*default*'), value, env);

        if (_temp4 instanceof AbruptCompletion) {
          return _temp4;
        }

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }
        return new NormalCompletion(undefined);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_ExportDeclaration', ExportDeclaration);
  }
}

function LoopContinues(completion, labelSet) {
  if (completion.Type === 'normal') {
    return true;
  }

  if (completion.Type !== 'continue') {
    return false;
  }

  if (completion.Target === undefined) {
    return true;
  }

  if (labelSet.has(completion.Target)) {
    return true;
  }

  return false;
} // 13.7.4.8 #sec-forbodyevaluation


function* ForBodyEvaluation(test, increment, stmt, perIterationBindings, labelSet) {
  let V = Value.undefined;

  let _temp = CreatePerIterationEnvironment(perIterationBindings);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  while (true) {
    if (test) {
      const testRef = yield* Evaluate(test);

      let _temp2 = GetValue(testRef);

      if (_temp2 instanceof AbruptCompletion) {
        return _temp2;
      }

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      const testValue = _temp2;

      if (ToBoolean(testValue) === Value.false) {
        return new NormalCompletion(V);
      }
    }

    const result = EnsureCompletion((yield* Evaluate(stmt)));

    if (LoopContinues(result, labelSet) === false) {
      return Completion(UpdateEmpty(result, V));
    }

    if (result.Value !== undefined) {
      V = result.Value;
    }

    let _temp3 = CreatePerIterationEnvironment(perIterationBindings);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    if (increment) {
      const incRef = yield* Evaluate(increment);

      let _temp4 = GetValue(incRef);

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }
    }
  }
} // 13.7.4.9 #sec-createperiterationenvironment


function CreatePerIterationEnvironment(perIterationBindings) {
  if (perIterationBindings.length > 0) {
    const lastIterationEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    const lastIterationEnvRec = lastIterationEnv.EnvironmentRecord;
    const outer = lastIterationEnv.outerEnvironmentReference;
    Assert(Type(outer) !== 'Null', "Type(outer) !== 'Null'");
    const thisIterationEnv = NewDeclarativeEnvironment(outer);
    const thisIterationEnvRec = thisIterationEnv.EnvironmentRecord;

    for (const bn of perIterationBindings) {
      let _temp5 = thisIterationEnvRec.CreateMutableBinding(bn, false);

      Assert(!(_temp5 instanceof AbruptCompletion), "thisIterationEnvRec.CreateMutableBinding(bn, false)" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp5 instanceof Completion) {
        _temp5 = _temp5.Value;
      }

      let _temp6 = lastIterationEnvRec.GetBindingValue(bn, Value.true);

      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }

      const lastValue = _temp6;
      thisIterationEnvRec.InitializeBinding(bn, lastValue);
    }

    surroundingAgent.runningExecutionContext.LexicalEnvironment = thisIterationEnv;
  }

  return Value.undefined;
} // 13.7.5.10 #sec-runtime-semantics-bindinginstantiation


function BindingInstantiation_ForDeclaration(ForDeclaration, environment) {
  const envRec = environment.EnvironmentRecord;
  Assert(envRec instanceof DeclarativeEnvironmentRecord, "envRec instanceof DeclarativeEnvironmentRecord");
  const ForBinding = ForDeclaration.declarations[0].id;

  for (const name of BoundNames_ForBinding(ForBinding).map(Value)) {
    if (IsConstantDeclaration(ForDeclaration)) {
      let _temp7 = envRec.CreateImmutableBinding(name, Value.true);

      Assert(!(_temp7 instanceof AbruptCompletion), "envRec.CreateImmutableBinding(name, Value.true)" + ' returned an abrupt completion');

      if (_temp7 instanceof Completion) {
        _temp7 = _temp7.Value;
      }
    } else {
      let _temp8 = envRec.CreateMutableBinding(name, false);

      Assert(!(_temp8 instanceof AbruptCompletion), "envRec.CreateMutableBinding(name, false)" + ' returned an abrupt completion');

      if (_temp8 instanceof Completion) {
        _temp8 = _temp8.Value;
      }
    }
  }
} // 13.7.5.12 #sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind


function* ForInOfHeadEvaluation(TDZnames, expr, iterationKind) {
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;

  if (TDZnames.length > 0) {
    Assert(new ValueSet(TDZnames).size === TDZnames.length, "new ValueSet(TDZnames).size === TDZnames.length");
    const TDZ = NewDeclarativeEnvironment(oldEnv);
    const TDZEnvRec = TDZ.EnvironmentRecord;

    for (const name of TDZnames) {
      let _temp9 = TDZEnvRec.CreateMutableBinding(name, false);

      Assert(!(_temp9 instanceof AbruptCompletion), "TDZEnvRec.CreateMutableBinding(name, false)" + ' returned an abrupt completion');

      if (_temp9 instanceof Completion) {
        _temp9 = _temp9.Value;
      }
    }

    surroundingAgent.runningExecutionContext.LexicalEnvironment = TDZ;
  }

  const exprRef = yield* Evaluate(expr);
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;

  let _temp10 = GetValue(exprRef);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const exprValue = _temp10;

  if (iterationKind === 'enumerate') {
    if (Type(exprValue) === 'Undefined' || Type(exprValue) === 'Null') {
      return new BreakCompletion(undefined);
    }

    let _temp11 = ToObject(exprValue);

    Assert(!(_temp11 instanceof AbruptCompletion), "ToObject(exprValue)" + ' returned an abrupt completion');

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    const obj = _temp11;
    return EnumerateObjectProperties(obj);
  } else {
    Assert(iterationKind === 'iterate' || iterationKind === 'async-iterate', "iterationKind === 'iterate' || iterationKind === 'async-iterate'");
    const iteratorHint = iterationKind === 'async-iterate' ? 'async' : 'sync';
    return GetIterator(exprValue, iteratorHint);
  }
} // 13.7.5.13 #sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset


function* ForInOfBodyEvaluation(lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet, iteratorKind = 'sync', strict) {
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  let V = Value.undefined;
  const destructuring = lhs.type === 'VariableDeclaration' ? IsDestructuring_ForDeclaration(lhs) : IsDestructuring_LeftHandSideExpression(lhs);
  let assignmentPattern;

  if (destructuring && lhsKind === 'assignment') {
    assignmentPattern = lhs;
    Assert(isAssignmentPattern(assignmentPattern), "isAssignmentPattern(assignmentPattern)");
  }

  while (true) {
    let _temp12 = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator);

    if (_temp12 instanceof AbruptCompletion) {
      return _temp12;
    }

    if (_temp12 instanceof Completion) {
      _temp12 = _temp12.Value;
    }

    let nextResult = _temp12;

    if (iteratorKind === 'async') {
      let _temp13 = yield* Await(nextResult);

      if (_temp13 instanceof AbruptCompletion) {
        return _temp13;
      }

      if (_temp13 instanceof Completion) {
        _temp13 = _temp13.Value;
      }

      nextResult = _temp13;
    }

    if (Type(nextResult) !== 'Object') {
      return surroundingAgent.Throw('TypeError');
    }

    let _temp14 = IteratorComplete(nextResult);

    if (_temp14 instanceof AbruptCompletion) {
      return _temp14;
    }

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    const done = _temp14;

    if (done === Value.true) {
      return new NormalCompletion(V);
    }

    let _temp15 = IteratorValue(nextResult);

    if (_temp15 instanceof AbruptCompletion) {
      return _temp15;
    }

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    const nextValue = _temp15;
    let iterationEnv;
    let lhsRef;

    if (lhsKind === 'assignment' || lhsKind === 'varBinding') {
      if (!destructuring) {
        lhsRef = yield* Evaluate(lhs);
      }
    } else {
      Assert(lhsKind === 'lexicalBinding', "lhsKind === 'lexicalBinding'");
      Assert(isForDeclaration(lhs), "isForDeclaration(lhs)");
      iterationEnv = NewDeclarativeEnvironment(oldEnv);
      BindingInstantiation_ForDeclaration(lhs, iterationEnv);
      surroundingAgent.runningExecutionContext.LexicalEnvironment = iterationEnv;

      if (!destructuring) {
        const lhsNames = BoundNames_ForDeclaration(lhs);
        Assert(lhsNames.length === 1, "lhsNames.length === 1");
        const lhsName = new Value(lhsNames[0]);

        let _temp16 = ResolveBinding(lhsName, undefined, strict);

        Assert(!(_temp16 instanceof AbruptCompletion), "ResolveBinding(lhsName, undefined, strict)" + ' returned an abrupt completion');

        if (_temp16 instanceof Completion) {
          _temp16 = _temp16.Value;
        }

        lhsRef = _temp16;
      }
    }

    let status;

    if (!destructuring) {
      if (lhsRef instanceof AbruptCompletion) {
        status = lhsRef;
      } else if (lhsKind === 'lexicalBinding') {
        status = InitializeReferencedBinding(lhsRef, nextValue);
      } else {
        status = PutValue(lhsRef, nextValue);
      }
    } else {
      if (lhsKind === 'assignment') {
        status = yield* DestructuringAssignmentEvaluation_AssignmentPattern(assignmentPattern, nextValue);
      } else if (lhsKind === 'varBinding') {
        Assert(isForBinding(lhs), "isForBinding(lhs)");
        status = yield* BindingInitialization_ForBinding(lhs, nextValue, Value.undefined);
      } else {
        Assert(lhsKind === 'lexicalBinding', "lhsKind === 'lexicalBinding'");
        Assert(isForDeclaration(lhs), "isForDeclaration(lhs)");
        status = yield* BindingInitialization_ForDeclaration(lhs, nextValue, iterationEnv);
      }
    }

    if (status instanceof AbruptCompletion) {
      surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;

      if (iteratorKind === 'async') {
        return yield* AsyncIteratorClose(iteratorRecord, status);
      }

      if (iterationKind === 'enumerate') {
        return status;
      } else {
        Assert(iterationKind === 'iterate', "iterationKind === 'iterate'");
        return IteratorClose(iteratorRecord, status);
      }
    }

    const result = EnsureCompletion((yield* Evaluate(stmt)));
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;

    if (LoopContinues(result, labelSet) === false) {
      if (iterationKind === 'enumerate') {
        return Completion(UpdateEmpty(result, V));
      } else {
        Assert(iterationKind === 'iterate', "iterationKind === 'iterate'");
        status = UpdateEmpty(result, V);

        if (iteratorKind === 'async') {
          return yield* AsyncIteratorClose(iteratorRecord, status);
        }

        return IteratorClose(iteratorRecord, status);
      }
    }

    if (result.Value !== undefined) {
      V = result.Value;
    }
  }
} // 13.7.2.6 #sec-do-while-statement-runtime-semantics-labelledevaluation
//   IterationStatement : `do` Statement `while` `(` Expression `)` `;`
//
// 13.7.3.6 #sec-while-statement-runtime-semantics-labelledevaluation
//   IterationStatement : `while` `(` Expression `)` Statement
//
// 13.7.4.7 #sec-for-statement-runtime-semantics-labelledevaluation
//   IterationStatement :
//     `for` `(` Expression `;` Expression `;` Expression `)` Statement
//     `for` `(` `var` VariableDeclarationList `;` Expression `;` Expression `)` Statement
//     `for` `(` LexicalDeclarationExpression `;` Expression `)` Statement
//
// 13.7.5.11 #sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation
//   IterationStatement :
//     `for` `(` LeftHandSideExpression `in` Expression `)` Statement
//     `for` `(` `var` ForBinding `in` Expression `)` Statement
//     `for` `(` ForDeclaration `in` Expression `)` Statement
//     `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
//     `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
//     `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
//     `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
//     `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
//     `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement


function* LabelledEvaluation_IterationStatement(IterationStatement, labelSet) {
  switch (true) {
    case isDoWhileStatement(IterationStatement):
      {
        const Statement = IterationStatement.body;
        const Expression = IterationStatement.test;
        let V = Value.undefined;

        while (true) {
          const stmtResult = EnsureCompletion((yield* Evaluate(Statement)));

          if (!LoopContinues(stmtResult, labelSet)) {
            return Completion(UpdateEmpty(stmtResult, V));
          }

          if (stmtResult.Value !== undefined) {
            V = stmtResult.Value;
          }

          const exprRef = yield* Evaluate(Expression);

          let _temp17 = GetValue(exprRef);

          if (_temp17 instanceof AbruptCompletion) {
            return _temp17;
          }

          if (_temp17 instanceof Completion) {
            _temp17 = _temp17.Value;
          }

          const exprValue = _temp17;

          if (ToBoolean(exprValue) === Value.false) {
            return new NormalCompletion(V);
          }
        }
      }

    case isWhileStatement(IterationStatement):
      {
        const Expression = IterationStatement.test;
        const Statement = IterationStatement.body;
        let V = Value.undefined;

        while (true) {
          const exprRef = yield* Evaluate(Expression);

          let _temp18 = GetValue(exprRef);

          if (_temp18 instanceof AbruptCompletion) {
            return _temp18;
          }

          if (_temp18 instanceof Completion) {
            _temp18 = _temp18.Value;
          }

          const exprValue = _temp18;

          if (ToBoolean(exprValue) === Value.false) {
            return new NormalCompletion(V);
          }

          const stmtResult = EnsureCompletion((yield* Evaluate(Statement)));

          if (!LoopContinues(stmtResult, labelSet)) {
            return Completion(UpdateEmpty(stmtResult, V));
          }

          if (stmtResult.Value !== undefined) {
            V = stmtResult.Value;
          }
        }
      }

    case isForStatementWithExpression(IterationStatement):
      if (IterationStatement.init) {
        const exprRef = yield* Evaluate(IterationStatement.init);

        let _temp19 = GetValue(exprRef);

        if (_temp19 instanceof AbruptCompletion) {
          return _temp19;
        }

        if (_temp19 instanceof Completion) {
          _temp19 = _temp19.Value;
        }
      }

      return yield* ForBodyEvaluation(IterationStatement.test, IterationStatement.update, IterationStatement.body, [], labelSet);

    case isForStatementWithVariableStatement(IterationStatement):
      {
        let varDcl = yield* Evaluate(IterationStatement.init);

        /* istanbul ignore if */
        if (varDcl instanceof AbruptCompletion) {
          return varDcl;
        }
        /* istanbul ignore if */


        if (varDcl instanceof Completion) {
          varDcl = varDcl.Value;
        }
        return yield* ForBodyEvaluation(IterationStatement.test, IterationStatement.update, IterationStatement.body, [], labelSet);
      }

    case isForStatementWithLexicalDeclaration(IterationStatement):
      {
        const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
        const loopEnv = NewDeclarativeEnvironment(oldEnv);
        const loopEnvRec = loopEnv.EnvironmentRecord;
        const isConst = IsConstantDeclaration(IterationStatement.init);
        const boundNames = BoundNames_LexicalDeclaration(IterationStatement.init).map(Value);

        for (const dn of boundNames) {
          if (isConst) {
            let _temp20 = loopEnvRec.CreateImmutableBinding(dn, Value.true);

            Assert(!(_temp20 instanceof AbruptCompletion), "loopEnvRec.CreateImmutableBinding(dn, Value.true)" + ' returned an abrupt completion');

            if (_temp20 instanceof Completion) {
              _temp20 = _temp20.Value;
            }
          } else {
            let _temp21 = loopEnvRec.CreateMutableBinding(dn, true);

            Assert(!(_temp21 instanceof AbruptCompletion), "loopEnvRec.CreateMutableBinding(dn, true)" + ' returned an abrupt completion');

            if (_temp21 instanceof Completion) {
              _temp21 = _temp21.Value;
            }
          }
        }

        surroundingAgent.runningExecutionContext.LexicalEnvironment = loopEnv;
        const forDcl = yield* Evaluate(IterationStatement.init);

        if (forDcl instanceof AbruptCompletion) {
          surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
          return Completion(forDcl);
        }

        const perIterationLets = isConst ? [] : boundNames;
        const bodyResult = yield* ForBodyEvaluation(IterationStatement.test, IterationStatement.update, IterationStatement.body, perIterationLets, labelSet);
        surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
        return Completion(bodyResult);
      }

    case isForInStatementWithExpression(IterationStatement):
      {
        const {
          left: LeftHandSideExpression,
          right: Expression,
          body: Statement,
          strict
        } = IterationStatement;

        let _temp22 = yield* ForInOfHeadEvaluation([], Expression, 'enumerate');

        if (_temp22 instanceof AbruptCompletion) {
          return _temp22;
        }

        if (_temp22 instanceof Completion) {
          _temp22 = _temp22.Value;
        }

        const keyResult = _temp22;
        return yield* ForInOfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, 'enumerate', 'assignment', labelSet, 'sync', strict);
      }

    case isForInStatementWithVarForBinding(IterationStatement):
      {
        const {
          left: {
            declarations: [{
              id: ForBinding
            }]
          },
          right: Expression,
          body: Statement,
          strict
        } = IterationStatement;

        let _temp23 = yield* ForInOfHeadEvaluation([], Expression, 'enumerate');

        if (_temp23 instanceof AbruptCompletion) {
          return _temp23;
        }

        if (_temp23 instanceof Completion) {
          _temp23 = _temp23.Value;
        }

        const keyResult = _temp23;
        return yield* ForInOfBodyEvaluation(ForBinding, Statement, keyResult, 'enumerate', 'varBinding', labelSet, 'sync', strict);
      }

    case isForInStatementWithForDeclaration(IterationStatement):
      {
        const {
          left: ForDeclaration,
          right: Expression,
          body: Statement,
          strict
        } = IterationStatement;

        let _temp24 = yield* ForInOfHeadEvaluation(BoundNames_ForDeclaration(ForDeclaration).map(Value), Expression, 'enumerate');

        if (_temp24 instanceof AbruptCompletion) {
          return _temp24;
        }

        if (_temp24 instanceof Completion) {
          _temp24 = _temp24.Value;
        }

        const keyResult = _temp24;
        return yield* ForInOfBodyEvaluation(ForDeclaration, Statement, keyResult, 'enumerate', 'lexicalBinding', labelSet, 'sync', strict);
      }

    case isForOfStatementWithExpression(IterationStatement):
      {
        const {
          left: LeftHandSideExpression,
          right: AssignmentExpression,
          body: Statement,
          await: isAwait,
          strict
        } = IterationStatement;

        let _temp25 = yield* ForInOfHeadEvaluation([], AssignmentExpression, isAwait ? 'async-iterate' : 'iterate');

        if (_temp25 instanceof AbruptCompletion) {
          return _temp25;
        }

        if (_temp25 instanceof Completion) {
          _temp25 = _temp25.Value;
        }

        const keyResult = _temp25;
        return yield* ForInOfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, 'iterate', 'assignment', labelSet, isAwait ? 'async' : 'sync', strict);
      }

    case isForOfStatementWithVarForBinding(IterationStatement):
      {
        const {
          left: {
            declarations: [{
              id: ForBinding
            }]
          },
          right: AssignmentExpression,
          body: Statement,
          await: isAwait,
          strict
        } = IterationStatement;

        let _temp26 = yield* ForInOfHeadEvaluation([], AssignmentExpression, isAwait ? 'async-iterate' : 'iterate');

        if (_temp26 instanceof AbruptCompletion) {
          return _temp26;
        }

        if (_temp26 instanceof Completion) {
          _temp26 = _temp26.Value;
        }

        const keyResult = _temp26;
        return yield* ForInOfBodyEvaluation(ForBinding, Statement, keyResult, 'iterate', 'varBinding', labelSet, isAwait ? 'async' : 'sync', strict);
      }

    case isForOfStatementWithForDeclaration(IterationStatement):
      {
        const {
          left: ForDeclaration,
          right: AssignmentExpression,
          body: Statement,
          await: isAwait,
          strict
        } = IterationStatement;

        let _temp27 = yield* ForInOfHeadEvaluation(BoundNames_ForDeclaration(ForDeclaration).map(Value), AssignmentExpression, isAwait ? 'async-iterate' : 'iterate');

        if (_temp27 instanceof AbruptCompletion) {
          return _temp27;
        }

        if (_temp27 instanceof Completion) {
          _temp27 = _temp27.Value;
        }

        const keyResult = _temp27;
        return yield* ForInOfBodyEvaluation(ForDeclaration, Statement, keyResult, 'iterate', 'lexicalBinding', labelSet, isAwait ? 'async' : 'sync', strict);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('LabelledEvaluation_IterationStatement', IterationStatement);
  }
}

function* InternalEnumerateObjectProperties(O) {
  const visited = new ValueSet();

  let _temp28 = O.OwnPropertyKeys();

  if (_temp28 instanceof AbruptCompletion) {
    return _temp28;
  }

  if (_temp28 instanceof Completion) {
    _temp28 = _temp28.Value;
  }

  const keys = _temp28;

  for (const key of keys) {
    if (Type(key) === 'Symbol') {
      continue;
    }

    let _temp29 = O.GetOwnProperty(key);

    if (_temp29 instanceof AbruptCompletion) {
      return _temp29;
    }

    if (_temp29 instanceof Completion) {
      _temp29 = _temp29.Value;
    }

    const desc = _temp29;

    if (Type(desc) !== 'Undefined') {
      visited.add(key);

      if (desc.Enumerable === Value.true) {
        yield key;
      }
    }
  }

  let _temp30 = O.GetPrototypeOf();

  if (_temp30 instanceof AbruptCompletion) {
    return _temp30;
  }

  if (_temp30 instanceof Completion) {
    _temp30 = _temp30.Value;
  }

  const proto = _temp30;

  if (Type(proto) === 'Null') {
    return;
  }

  for (const protoKey of InternalEnumerateObjectProperties(proto)) {
    if (!visited.has(protoKey)) {
      yield protoKey;
    }
  }
} // 13.7.5.15 #sec-enumerate-object-properties


function EnumerateObjectProperties(O) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  const internalIterator = InternalEnumerateObjectProperties(O);

  let _temp31 = ObjectCreate(Value.null);

  Assert(!(_temp31 instanceof AbruptCompletion), "ObjectCreate(Value.null)" + ' returned an abrupt completion');

  if (_temp31 instanceof Completion) {
    _temp31 = _temp31.Value;
  }

  const iterator = _temp31;
  const nextMethod = CreateBuiltinFunction(() => {
    let {
      value,
      done
    } = internalIterator.next();

    if (value instanceof AbruptCompletion) {
      return value;
    }

    if (value instanceof Completion) {
      value = value.Value;
    }

    let _temp32 = CreateIterResultObject(value === undefined ? Value.undefined : value, done ? Value.true : Value.false);

    Assert(!(_temp32 instanceof AbruptCompletion), "CreateIterResultObject(\n      value === undefined ? Value.undefined : value,\n      done ? Value.true : Value.false,\n    )" + ' returned an abrupt completion');

    if (_temp32 instanceof Completion) {
      _temp32 = _temp32.Value;
    }

    return _temp32;
  }, []);

  let _temp33 = CreateDataProperty(iterator, new Value('next'), nextMethod);

  Assert(!(_temp33 instanceof AbruptCompletion), "CreateDataProperty(iterator, new Value('next'), nextMethod)" + ' returned an abrupt completion');

  if (_temp33 instanceof Completion) {
    _temp33 = _temp33.Value;
  }

  let _temp34 = CreateDataProperty(iterator, new Value('throw'), Value.null);

  Assert(!(_temp34 instanceof AbruptCompletion), "CreateDataProperty(iterator, new Value('throw'), Value.null)" + ' returned an abrupt completion');

  if (_temp34 instanceof Completion) {
    _temp34 = _temp34.Value;
  }

  let _temp35 = CreateDataProperty(iterator, new Value('return'), Value.null);

  Assert(!(_temp35 instanceof AbruptCompletion), "CreateDataProperty(iterator, new Value('return'), Value.null)" + ' returned an abrupt completion');

  if (_temp35 instanceof Completion) {
    _temp35 = _temp35.Value;
  }
  return {
    Iterator: iterator,
    NextMethod: nextMethod,
    Done: Value.false
  };
}

// FunctionDeclaration :
//   function BindingIdentifier ( FormalParameters ) { FunctionBody }
//   function ( FormalParameters ) { FunctionBody }

function Evaluate_FunctionDeclaration() {
  return new NormalCompletion(undefined);
}

function Evaluate_FunctionExpression_BindingIdentifier(FunctionExpression) {
  const {
    id: BindingIdentifier,
    params: FormalParameters
  } = FunctionExpression;
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const funcEnv = NewDeclarativeEnvironment(scope);
  const envRec = funcEnv.EnvironmentRecord;
  const name = new Value(BindingIdentifier.name);
  envRec.CreateImmutableBinding(name, Value.false);

  let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), FormalParameters, FunctionExpression, 'non-lexical-this', funcEnv);

  Assert(!(_temp instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), FormalParameters, FunctionExpression, 'non-lexical-this', funcEnv)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const closure = _temp;
  MakeConstructor(closure);
  SetFunctionName(closure, name);
  closure.SourceText = sourceTextMatchedBy(FunctionExpression);
  envRec.InitializeBinding(name, closure);
  return closure;
}

function Evaluate_FunctionExpression(FunctionExpression) {
  if (isFunctionExpressionWithBindingIdentifier(FunctionExpression)) {
    return Evaluate_FunctionExpression_BindingIdentifier(FunctionExpression);
  }

  const FormalParameters = FunctionExpression.params;
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;

  let _temp2 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), FormalParameters, FunctionExpression, 'non-lexical-this', scope);

  Assert(!(_temp2 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), FormalParameters, FunctionExpression, 'non-lexical-this', scope)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const closure = _temp2;
  MakeConstructor(closure);
  closure.SourceText = sourceTextMatchedBy(FunctionExpression);
  return closure;
}

//   FunctionStatementList : [empty]
//
// (implicit)
//   FunctionStatementList : StatementList

const Evaluate_FunctionStatementList = Evaluate_StatementList; // (implicit)
//   FunctionBody : FunctionStatementList

const Evaluate_FunctionBody = Evaluate_FunctionStatementList;

//   GeneratorExpression :
//     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
//     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

function Evaluate_GeneratorExpression(GeneratorExpression) {
  const {
    id: BindingIdentifier,
    params: FormalParameters
  } = GeneratorExpression;
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  let funcEnv = scope;
  let envRec;
  let name;

  if (BindingIdentifier) {
    funcEnv = NewDeclarativeEnvironment(scope);
    envRec = funcEnv.EnvironmentRecord;
    name = new Value(BindingIdentifier.name);
    envRec.CreateImmutableBinding(name, Value.false);
  }

  let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Generator%'), FormalParameters, GeneratorExpression, 'non-lexical-this', funcEnv);

  Assert(!(_temp instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Generator%'), FormalParameters, GeneratorExpression, 'non-lexical-this', funcEnv)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const closure = _temp;
  const prototype = ObjectCreate(surroundingAgent.intrinsic('%Generator.prototype%'));

  let _temp2 = DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp2 instanceof AbruptCompletion), "DefinePropertyOrThrow(\n    closure,\n    new Value('prototype'),\n    Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    }),\n  )" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  closure.SourceText = sourceTextMatchedBy(GeneratorExpression);

  if (BindingIdentifier) {
    let _temp3 = SetFunctionName(closure, name);

    Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }
    envRec.InitializeBinding(name, closure);
  }

  return closure;
}

function GetSubstitution(matched, str, position, captures, namedCaptures, replacement) {
  Assert(Type(matched) === 'String', "Type(matched) === 'String'");
  const matchLength = matched.stringValue().length;
  Assert(Type(str) === 'String', "Type(str) === 'String'");
  const stringLength = str.stringValue().length;
  Assert(Type(position) === 'Number' && Number.isInteger(position.numberValue()) && position.numberValue() >= 0, "Type(position) === 'Number' && Number.isInteger(position.numberValue()) && position.numberValue() >= 0");
  Assert(position.numberValue() <= stringLength, "position.numberValue() <= stringLength");
  Assert(Array.isArray(captures) && captures.every(value => Type(value) === 'String' || Type(value) === 'Undefined'), "Array.isArray(captures) && captures.every((value) => Type(value) === 'String' || Type(value) === 'Undefined')");
  Assert(Type(replacement) === 'String', "Type(replacement) === 'String'");
  const tailPos = position.numberValue() + matchLength;
  const m = captures.length;
  const replacementStr = replacement.stringValue();
  let result = '';
  let i = 0;

  while (i < replacementStr.length) {
    const currentChar = replacementStr[i];

    if (currentChar === '$' && i < replacementStr.length - 1) {
      const nextChar = replacementStr[i + 1];

      if (nextChar === '$') {
        result += '$';
        i += 2;
      } else if (nextChar === '&') {
        result += matched.stringValue();
        i += 2;
      } else if (nextChar === '`') {
        if (position.numberValue() === 0) ; else {
          result += str.stringValue().substring(0, position.numberValue());
        }

        i += 2;
      } else if (nextChar === '\'') {
        if (tailPos >= stringLength) ; else {
          result += str.stringValue().substring(tailPos);
        }

        i += 2;
      } else if ('123456789'.includes(nextChar) && (i === replacementStr.length - 2 || !'0123456789'.includes(replacementStr[i + 2]))) {
        const n = Number(nextChar);

        if (n <= m) {
          const capture = captures[n - 1];

          if (capture !== Value.undefined) {
            result += capture.stringValue();
          }
        } else {
          result += `$${nextChar}`;
        }

        i += 2;
      } else if (i < replacementStr.length - 2 && '0123456789'.includes(nextChar) && '0123456789'.includes(replacementStr[i + 2])) {
        const nextNextChar = replacementStr[i + 2];
        const n = Number(nextChar + nextNextChar);

        if (n !== 0 && n <= m) {
          const capture = captures[n - 1];

          if (capture !== Value.undefined) {
            result += capture.stringValue();
          }
        } else {
          result += `$${nextChar}${nextNextChar}`;
        }

        i += 3;
      } else if (nextChar === '<') {
        if (namedCaptures === Value.undefined) {
          result += '$<';
          i += 2;
        } else {
          Assert(Type(namedCaptures) === 'Object', "Type(namedCaptures) === 'Object'");
          const nextSign = replacementStr.indexOf('>', i);

          if (nextSign === -1) {
            result += '$<';
            i += 2;
          } else {
            const groupName = new Value(replacementStr.substring(i + 1, nextSign));

            let _temp = Get(namedCaptures, groupName);
            /* istanbul ignore if */


            if (_temp instanceof AbruptCompletion) {
              return _temp;
            }
            /* istanbul ignore if */


            if (_temp instanceof Completion) {
              _temp = _temp.Value;
            }

            const capture = _temp;

            if (capture === Value.undefined) ; else {
              let _temp2 = ToString(capture);

              if (_temp2 instanceof AbruptCompletion) {
                return _temp2;
              }

              if (_temp2 instanceof Completion) {
                _temp2 = _temp2.Value;
              }

              result += _temp2.stringValue();
            }

            i = nextSign + 1;
          }
        }
      } else {
        result += '$';
        i += 1;
      }
    } else {
      result += currentChar;
      i += 1;
    }
  }

  return new Value(result);
}

function GlobalDeclarationInstantiation(script, env) {
  const envRec = env.EnvironmentRecord;
  Assert(envRec instanceof EnvironmentRecord, "envRec instanceof EnvironmentRecord");
  const lexNames = LexicallyDeclaredNames_ScriptBody(script).map(Value);
  const varNames = VarDeclaredNames_ScriptBody(script).map(Value);

  for (const name of lexNames) {
    if (envRec.HasVarDeclaration(name) === Value.true) {
      return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
    }

    if (envRec.HasLexicalDeclaration(name) === Value.true) {
      return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
    }

    let _temp = envRec.HasRestrictedGlobalProperty(name);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const hasRestrictedGlobal = _temp;

    if (hasRestrictedGlobal === Value.true) {
      return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
    }
  }

  for (const name of varNames) {
    if (envRec.HasLexicalDeclaration(name) === Value.true) {
      return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
    }
  }

  const varDeclarations = VarScopedDeclarations_ScriptBody(script);
  const functionsToInitialize = [];
  const declaredFunctionNames = [];

  for (const d of [...varDeclarations].reverse()) {
    if (!isVariableDeclaration(d) && !isForBinding(d) && !isBindingIdentifier(d)) {
      Assert(isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d), "isFunctionDeclaration(d) || isGeneratorDeclaration(d)\n             || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)");
      const fn = BoundNames_FunctionDeclaration(d)[0];

      if (!declaredFunctionNames.includes(fn)) {
        let _temp2 = envRec.CanDeclareGlobalFunction(new Value(fn));

        if (_temp2 instanceof AbruptCompletion) {
          return _temp2;
        }

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }

        const fnDefinable = _temp2;

        if (fnDefinable === Value.false) {
          return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', fn);
        }

        declaredFunctionNames.push(fn);
        functionsToInitialize.unshift(d);
      }
    }
  }

  const declaredVarNames = [];

  for (const d of varDeclarations) {
    let boundNames;

    if (isVariableDeclaration(d)) {
      boundNames = BoundNames_VariableDeclaration(d);
    } else if (isForBinding(d)) {
      boundNames = BoundNames_ForBinding(d);
    } else if (isBindingIdentifier(d)) {
      boundNames = BoundNames_BindingIdentifier(d);
    }

    if (boundNames !== undefined) {
      for (const vn of boundNames.map(Value)) {
        if (!declaredFunctionNames.includes(vn)) {
          let _temp3 = envRec.CanDeclareGlobalVar(vn);

          if (_temp3 instanceof AbruptCompletion) {
            return _temp3;
          }

          if (_temp3 instanceof Completion) {
            _temp3 = _temp3.Value;
          }

          const vnDefinable = _temp3;

          if (vnDefinable === Value.false) {
            return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', vn);
          }

          if (!declaredVarNames.includes(vn)) {
            declaredVarNames.push(vn);
          }
        }
      }
    }
  } // NOTE: Annex B.3.3.2 adds additional steps at this point.
  // TODO(devsnek): Annex B.3.3.2


  const lexDeclarations = LexicallyScopedDeclarations_ScriptBody(script);

  for (const d of lexDeclarations) {
    for (const dn of BoundNames_Declaration(d).map(Value)) {
      if (IsConstantDeclaration(d)) {
        let _temp4 = envRec.CreateImmutableBinding(dn, Value.true);

        if (_temp4 instanceof AbruptCompletion) {
          return _temp4;
        }

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }
      } else {
        let _temp5 = envRec.CreateMutableBinding(dn, Value.false);

        if (_temp5 instanceof AbruptCompletion) {
          return _temp5;
        }

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }
      }
    }
  }

  for (const f of functionsToInitialize) {
    const fn = new Value(BoundNames_FunctionDeclaration(f)[0]);
    const fo = InstantiateFunctionObject(f, env);

    let _temp6 = envRec.CreateGlobalFunctionBinding(fn, fo, Value.false);

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
  }

  for (const vn of declaredVarNames) {
    let _temp7 = envRec.CreateGlobalVarBinding(vn, Value.false);

    if (_temp7 instanceof AbruptCompletion) {
      return _temp7;
    }

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }
  }

  return new NormalCompletion(undefined);
}

//   HoistableDeclaration :
//     GeneratorDeclaration
//     AsyncFunctionDeclaration
//     AsyncGeneratorDeclaration
//     FunctionDeclaration

function Evaluate_HoistableDeclaration(HoistableDeclaration) {
  switch (true) {
    case isGeneratorDeclaration(HoistableDeclaration):
    case isAsyncFunctionDeclaration(HoistableDeclaration):
    case isAsyncGeneratorDeclaration(HoistableDeclaration):
      return new NormalCompletion(undefined);

    case isFunctionDeclaration(HoistableDeclaration):
      return Evaluate_FunctionDeclaration();

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_HoistableDeclaration', HoistableDeclaration);
  }
}

// IdentifierReference :
//   Identifier
//   yield
//   await

function Evaluate_Identifier(Identifier) {
  return ResolveBinding(new Value(Identifier.name), undefined, Identifier.strict);
}

//   IfStatement :
//     `if` `(` Expression `)` Statement `else` Statement
//     `if` `(` Expression `)` Statement

function* Evaluate_IfStatement({
  test: Expression,
  consequent: Statement,
  alternate: AlternateStatement
}) {
  const exprRef = yield* Evaluate(Expression);

  let _temp = GetValue(exprRef);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const exprValue = ToBoolean(_temp);

  if (AlternateStatement !== null) {
    let stmtCompletion;

    if (exprValue === Value.true) {
      stmtCompletion = EnsureCompletion((yield* Evaluate(Statement)));
    } else {
      stmtCompletion = EnsureCompletion((yield* Evaluate(AlternateStatement)));
    }

    return Completion(UpdateEmpty(stmtCompletion, Value.undefined));
  } else {
    if (exprValue === Value.false) {
      return new NormalCompletion(Value.undefined);
    } else {
      const stmtCompletion = EnsureCompletion((yield* Evaluate(Statement)));
      return Completion(UpdateEmpty(stmtCompletion, Value.undefined));
    }
  }
}

// ImportCall : `import` `(` AssignmentExpression `)`

function* Evaluate_ImportCall({
  source: AssignmentExpression
}) {
  let _temp = GetActiveScriptOrModule();

  Assert(!(_temp instanceof AbruptCompletion), "GetActiveScriptOrModule()" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const referencingScriptOrModule = _temp;
  const argRef = yield* Evaluate(AssignmentExpression);

  let _temp2 = GetValue(argRef);
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const specifier = _temp2;

  let _temp3 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

  Assert(!(_temp3 instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const promiseCapability = _temp3;
  let specifierString = ToString(specifier);

  /* istanbul ignore if */
  if (specifierString instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [specifierString.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }
  /* istanbul ignore if */


  if (specifierString instanceof Completion) {
    specifierString = specifierString.Value;
  }

  let _temp4 = HostImportModuleDynamically(referencingScriptOrModule, specifierString, promiseCapability);

  Assert(!(_temp4 instanceof AbruptCompletion), "HostImportModuleDynamically(referencingScriptOrModule, specifierString, promiseCapability)" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  return promiseCapability.Promise;
}

//   FunctionDeclaration :
//     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
//     `function` `(` FormalParameters `)` `{` FunctionBody `}`

function InstantiateFunctionObject_FunctionDeclaration(FunctionDeclaration, scope) {
  const {
    id: BindingIdentifier,
    params: FormalParameters
  } = FunctionDeclaration;
  const name = new Value(BindingIdentifier ? BindingIdentifier.name : 'default');

  let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), FormalParameters, FunctionDeclaration, 'non-lexical-this', scope);

  Assert(!(_temp instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), FormalParameters, FunctionDeclaration, 'non-lexical-this', scope)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const F = _temp;
  MakeConstructor(F);
  SetFunctionName(F, name);
  F.SourceText = sourceTextMatchedBy(FunctionDeclaration);
  return F;
} // 14.4.11 #sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject
//   GeneratorDeclaration :
//     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
//     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

function InstantiateFunctionObject_GeneratorDeclaration(GeneratorDeclaration, scope) {
  const {
    id: BindingIdentifier,
    params: FormalParameters
  } = GeneratorDeclaration;
  const name = new Value(BindingIdentifier ? BindingIdentifier.name : 'default');

  let _temp2 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Generator%'), FormalParameters, GeneratorDeclaration, 'non-lexical-this', scope);

  Assert(!(_temp2 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Generator%'), FormalParameters, GeneratorDeclaration, 'non-lexical-this', scope)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const F = _temp2;

  let _temp3 = ObjectCreate(surroundingAgent.intrinsic('%Generator.prototype%'));

  Assert(!(_temp3 instanceof AbruptCompletion), "ObjectCreate(surroundingAgent.intrinsic('%Generator.prototype%'))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const prototype = _temp3;

  let _temp4 = DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp4 instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  SetFunctionName(F, name);
  F.SourceText = sourceTextMatchedBy(GeneratorDeclaration);
  return F;
}
function InstantiateFunctionObject_AsyncFunctionDeclaration(AsyncFunctionDeclaration, scope) {
  const {
    id: BindingIdentifier,
    params: FormalParameters
  } = AsyncFunctionDeclaration;
  const name = new Value(BindingIdentifier ? BindingIdentifier.name : 'default');

  let _temp5 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), FormalParameters, AsyncFunctionDeclaration, 'non-lexical-this', scope);

  Assert(!(_temp5 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), FormalParameters, AsyncFunctionDeclaration, 'non-lexical-this', scope)" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const F = _temp5;
  SetFunctionName(F, name);
  F.SourceText = sourceTextMatchedBy(AsyncFunctionDeclaration);
  return F;
}
function InstantiateFunctionObject_AsyncGeneratorDeclaration(AsyncGeneratorDeclaration, scope) {
  const {
    id: BindingIdentifier,
    params: FormalParameters
  } = AsyncGeneratorDeclaration;
  const name = new Value(BindingIdentifier ? BindingIdentifier.name : 'default');

  let _temp6 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), FormalParameters, AsyncGeneratorDeclaration, 'non-lexical-this', scope);

  Assert(!(_temp6 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), FormalParameters, AsyncGeneratorDeclaration, 'non-lexical-this', scope)" + ' returned an abrupt completion');

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const F = _temp6;

  let _temp7 = ObjectCreate(surroundingAgent.intrinsic('%AsyncGenerator.prototype%'));

  Assert(!(_temp7 instanceof AbruptCompletion), "ObjectCreate(surroundingAgent.intrinsic('%AsyncGenerator.prototype%'))" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const prototype = _temp7;

  let _temp8 = DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp8 instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }
  SetFunctionName(F, name);
  F.SourceText = sourceTextMatchedBy(AsyncGeneratorDeclaration);
  return F;
}
function InstantiateFunctionObject(AnyFunctionDeclaration, scope) {
  switch (true) {
    case isFunctionDeclaration(AnyFunctionDeclaration):
      return InstantiateFunctionObject_FunctionDeclaration(AnyFunctionDeclaration, scope);

    case isGeneratorDeclaration(AnyFunctionDeclaration):
      return InstantiateFunctionObject_GeneratorDeclaration(AnyFunctionDeclaration, scope);

    case isAsyncFunctionDeclaration(AnyFunctionDeclaration):
      return InstantiateFunctionObject_AsyncFunctionDeclaration(AnyFunctionDeclaration, scope);

    case isAsyncGeneratorDeclaration(AnyFunctionDeclaration):
      return InstantiateFunctionObject_AsyncGeneratorDeclaration(AnyFunctionDeclaration, scope);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('InstantiateFunctionObject', AnyFunctionDeclaration);
  }
}

//   ArrayBindingPattern :
//     `[` `]`
//     `[` Elision `]`
//     `[` Elision BindingRestElement `]`
//     `[` BindingElementList `]`
//     `[` BindingElementList `,` `]`
//     `[` BindingElementList `,` Elision `]`
//     `[` BindingElementList `,` Elision BindingRestElement `]`

function* IteratorBindingInitialization_ArrayBindingPattern(ArrayBindingPattern, iteratorRecord, environment) {
  let Elision;
  let BindingElementList = ArrayBindingPattern.elements;
  let BindingRestElement; // Members of the BindingElementList may be null, so add a truthyness check.

  if (BindingElementList.length > 0 && BindingElementList[BindingElementList.length - 1] && isBindingRestElement(BindingElementList[BindingElementList.length - 1])) {
    BindingRestElement = BindingElementList[BindingElementList.length - 1];
    BindingElementList = BindingElementList.slice(0, -1);
  }

  if (BindingElementList.length > 0) {
    let begin;

    for (begin = BindingElementList.length; begin > 0; begin -= 1) {
      if (BindingElementList[begin - 1] !== null) {
        break;
      }
    }

    if (begin !== BindingElementList.length) {
      Elision = BindingElementList.slice(begin);
      BindingElementList = BindingElementList.slice(0, begin);
    }
  }

  let status = new NormalCompletion(undefined);

  if (BindingElementList.length > 0) {
    let _temp = yield* IteratorBindingInitialization_BindingElementList(BindingElementList, iteratorRecord, environment);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    status = _temp;
  }

  if (Elision !== undefined) {
    let _temp2 = IteratorDestructuringAssignmentEvaluation_Elision(Elision, iteratorRecord);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    status = _temp2;
  }

  if (BindingRestElement !== undefined) {
    let _temp3 = yield* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    status = _temp3;
  }

  return status;
} // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
//   BindingElement : BindingPattern Initializer

function* IteratorBindingInitialization_BindingElement_BindingPattern(BindingElement, iteratorRecord, environment) {
  let BindingPattern;
  let Initializer;

  switch (true) {
    case isBindingPattern(BindingElement):
      BindingPattern = BindingElement;
      Initializer = undefined;
      break;

    case isBindingPatternAndInitializer(BindingElement):
      BindingPattern = BindingElement.left;
      Initializer = BindingElement.right;
      break;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('IteratorBindingInitialization_BindingElement_BindingPattern', BindingElement);
  }

  let v;

  if (iteratorRecord.Done === Value.false) {
    let next = IteratorStep(iteratorRecord);

    if (next instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    /* istanbul ignore if */
    if (next instanceof AbruptCompletion) {
      return next;
    }
    /* istanbul ignore if */


    if (next instanceof Completion) {
      next = next.Value;
    }

    if (next === Value.false) {
      iteratorRecord.Done = Value.true;
    } else {
      v = IteratorValue(next);

      if (v instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (v instanceof AbruptCompletion) {
        return v;
      }

      if (v instanceof Completion) {
        v = v.Value;
      }
    }
  }

  if (iteratorRecord.Done === Value.true) {
    v = Value.undefined;
  }

  if (Initializer !== undefined && Type(v) === 'Undefined') {
    const defaultValue = yield* Evaluate(Initializer);

    let _temp4 = GetValue(defaultValue);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    v = _temp4;
  }

  return yield* BindingInitialization_BindingPattern(BindingPattern, v, environment);
} // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
//   SingleNameBinding : BindingIdentifier Initializer


function* IteratorBindingInitialization_SingleNameBinding(SingleNameBinding, iteratorRecord, environment) {
  let BindingIdentifier;
  let Initializer;

  switch (true) {
    case isBindingIdentifier(SingleNameBinding):
      BindingIdentifier = SingleNameBinding;
      Initializer = undefined;
      break;

    case isBindingIdentifierAndInitializer(SingleNameBinding):
      BindingIdentifier = SingleNameBinding.left;
      Initializer = SingleNameBinding.right;
      break;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('IteratorBindingInitialization_SingleNameBinding', SingleNameBinding);
  }

  const bindingId = new Value(BindingIdentifier.name);

  let _temp5 = ResolveBinding(bindingId, environment, BindingIdentifier.strict);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const lhs = _temp5;
  let v;

  if (iteratorRecord.Done === Value.false) {
    let next = IteratorStep(iteratorRecord);

    if (next instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (next instanceof AbruptCompletion) {
      return next;
    }

    if (next instanceof Completion) {
      next = next.Value;
    }

    if (next === Value.false) {
      iteratorRecord.Done = Value.true;
    } else {
      v = IteratorValue(next);

      if (v instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (v instanceof AbruptCompletion) {
        return v;
      }

      if (v instanceof Completion) {
        v = v.Value;
      }
    }
  }

  if (iteratorRecord.Done === Value.true) {
    v = Value.undefined;
  }

  if (Initializer !== undefined && v === Value.undefined) {
    if (IsAnonymousFunctionDefinition(Initializer)) {
      v = yield* NamedEvaluation_Expression(Initializer, bindingId);
    } else {
      const defaultValue = yield* Evaluate(Initializer);

      let _temp6 = GetValue(defaultValue);

      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }

      v = _temp6;
    }
  }

  if (Type(environment) === 'Undefined') {
    return PutValue(lhs, v);
  }

  return InitializeReferencedBinding(lhs, v);
} // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
//   BindingElementList : BindingElementList `,` BindingElisionElement
//
// (implicit)
//   BindingElementList : BindingElisionElement


function* IteratorBindingInitialization_BindingElementList(BindingElementList, iteratorRecord, environment) {
  Assert(BindingElementList.length > 0, "BindingElementList.length > 0");
  let result;

  for (const BindingElisionElement of BindingElementList) {
    let _temp7 = yield* IteratorBindingInitialization_BindingElisionElement(BindingElisionElement, iteratorRecord, environment);

    if (_temp7 instanceof AbruptCompletion) {
      return _temp7;
    }

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    result = _temp7;
  }

  return result;
} // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
//   BindingElisionElement :
//     BindingElement
//     Elision BindingElement


function* IteratorBindingInitialization_BindingElisionElement(BindingElisionElement, iteratorRecord, environment) {
  if (!BindingElisionElement) {
    // This is an elision.
    return IteratorDestructuringAssignmentEvaluation_Elision([BindingElisionElement], iteratorRecord);
  }

  return yield* IteratorBindingInitialization_BindingElement(BindingElisionElement, iteratorRecord, environment);
} // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
//   BindingElement : SingleNameBinding


function* IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment) {
  switch (true) {
    case isSingleNameBinding(BindingElement):
      return yield* IteratorBindingInitialization_SingleNameBinding(BindingElement, iteratorRecord, environment);

    case isBindingPattern(BindingElement) || isBindingPatternAndInitializer(BindingElement):
      return yield* IteratorBindingInitialization_BindingElement_BindingPattern(BindingElement, iteratorRecord, environment);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('IteratorBindingInitialization_BindingElement', BindingElement);
  }
} // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
//   BindingRestElement : `...` BindingIdentifier


function IteratorBindingInitialization_BindingRestElement_Identifier(BindingRestElement, iteratorRecord, environment) {
  const BindingIdentifier = BindingRestElement.argument;

  let _temp8 = ResolveBinding(new Value(BindingIdentifier.name), environment, BindingIdentifier.strict);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const lhs = _temp8;

  let _temp9 = ArrayCreate(new Value(0));

  Assert(!(_temp9 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const A = _temp9;
  let n = 0;

  while (true) {
    let next;

    if (iteratorRecord.Done === Value.false) {
      next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
      }
    }

    if (iteratorRecord.Done === Value.true) {
      if (Type(environment) === 'Undefined') {
        return PutValue(lhs, A);
      }

      return InitializeReferencedBinding(lhs, A);
    }

    let nextValue = IteratorValue(next);

    if (nextValue instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (nextValue instanceof AbruptCompletion) {
      return nextValue;
    }

    if (nextValue instanceof Completion) {
      nextValue = nextValue.Value;
    }

    let _temp10 = ToString(new Value(n));

    Assert(!(_temp10 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }

    const nStr = _temp10;

    let _temp11 = CreateDataProperty(A, nStr, nextValue);

    Assert(!(_temp11 instanceof AbruptCompletion), "CreateDataProperty(A, nStr, nextValue)" + ' returned an abrupt completion');

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    const status = _temp11;
    Assert(status === Value.true, "status === Value.true");
    n += 1;
  }
} // 13.3.3.8 #sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
//   BindingRestElement :
//     `...` BindingPattern


function* IteratorBindingInitialization_BindingRestElement_Pattern(BindingRestElement, iteratorRecord, environment) {
  const BindingPattern = BindingRestElement.argument;

  let _temp12 = ArrayCreate(new Value(0));

  Assert(!(_temp12 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const A = _temp12;
  let n = 0;

  while (true) {
    let next;

    if (iteratorRecord.Done === Value.false) {
      next = IteratorStep(iteratorRecord);

      if (next instanceof AbruptCompletion) {
        iteratorRecord.Done = Value.true;
      }

      if (next instanceof AbruptCompletion) {
        return next;
      }

      if (next instanceof Completion) {
        next = next.Value;
      }

      if (next === Value.false) {
        iteratorRecord.Done = Value.true;
      }
    }

    if (iteratorRecord.Done === Value.true) {
      return yield* BindingInitialization_BindingPattern(BindingPattern, A, environment);
    }

    let nextValue = IteratorValue(next);

    if (nextValue instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (nextValue instanceof AbruptCompletion) {
      return nextValue;
    }

    if (nextValue instanceof Completion) {
      nextValue = nextValue.Value;
    }

    let _temp13 = ToString(new Value(n));

    Assert(!(_temp13 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }

    const nStr = _temp13;

    let _temp14 = CreateDataProperty(A, nStr, nextValue);

    Assert(!(_temp14 instanceof AbruptCompletion), "CreateDataProperty(A, nStr, nextValue)" + ' returned an abrupt completion');

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    const status = _temp14;
    Assert(status === Value.true, "status === Value.true");
    n += 1;
  }
}

function* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment) {
  switch (true) {
    case isBindingIdentifier(BindingRestElement.argument):
      return IteratorBindingInitialization_BindingRestElement_Identifier(BindingRestElement, iteratorRecord, environment);

    case isBindingPattern(BindingRestElement.argument):
      return yield* IteratorBindingInitialization_BindingRestElement_Pattern(BindingRestElement, iteratorRecord, environment);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('IteratorBindingInitialization_BindingRestElement', BindingRestElement);
  }
} // 14.1.19 #sec-function-definitions-runtime-semantics-iteratorbindinginitialization
//   FormalParameter : BindingElement


function* IteratorBindingInitialization_FormalParameter(FormalParameter, iteratorRecord, environment) {
  const BindingElement = FormalParameter;

  if (!ContainsExpression_BindingElement(BindingElement)) {
    return yield* IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment);
  }

  const currentContext = surroundingAgent.runningExecutionContext;
  const originalEnv = currentContext.VariableEnvironment;
  Assert(currentContext.VariableEnvironment === currentContext.LexicalEnvironment, "currentContext.VariableEnvironment === currentContext.LexicalEnvironment");

  if (environment !== Value.undefined) {
    Assert(environment === originalEnv, "environment === originalEnv");
  }

  const paramVarEnv = NewDeclarativeEnvironment(originalEnv);
  currentContext.VariableEnvironment = paramVarEnv;
  currentContext.LexicalEnvironment = paramVarEnv;
  const result = yield* IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment);
  currentContext.VariableEnvironment = originalEnv;
  currentContext.LexicalEnvironment = originalEnv;
  return result;
} // 14.1.19 #sec-function-definitions-runtime-semantics-iteratorbindinginitialization
//   FunctionRestParameter : BindingRestElement


function* IteratorBindingInitialization_FunctionRestParameter(FunctionRestParameter, iteratorRecord, environment) {
  const BindingRestElement = FunctionRestParameter;

  if (!ContainsExpression_BindingRestElement(BindingRestElement)) {
    return yield* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment);
  }

  const currentContext = surroundingAgent.runningExecutionContext;
  const originalEnv = currentContext.VariableEnvironment;
  Assert(currentContext.VariableEnvironment === currentContext.LexicalEnvironment, "currentContext.VariableEnvironment === currentContext.LexicalEnvironment");

  if (environment !== Value.undefined) {
    Assert(environment === originalEnv, "environment === originalEnv");
  }

  const paramVarEnv = NewDeclarativeEnvironment(originalEnv);
  currentContext.VariableEnvironment = paramVarEnv;
  currentContext.LexicalEnvironment = paramVarEnv;
  const result = yield* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment);
  currentContext.VariableEnvironment = originalEnv;
  currentContext.LexicalEnvironment = originalEnv;
  return result;
} // 14.1.19 #sec-function-definitions-runtime-semantics-iteratorbindinginitialization
//   FormalParameters :
//     [empty]
//     FormalParameterList `,` FunctionRestParameter
//   FormalParameterList : FormalParameterList `,` FormalParameter
//
// (implicit)
//   FormalParameters :
//     FunctionRestParameter
//     FormalParameterList
//     FormalParameterList `,`
//   FormalParameterList : FormalParameter


function* IteratorBindingInitialization_FormalParameters(FormalParameters, iteratorRecord, environment) {
  if (FormalParameters.length === 0) {
    return new NormalCompletion(undefined);
  }

  for (const FormalParameter of FormalParameters.slice(0, -1)) {
    Assert(isFormalParameter(FormalParameter), "isFormalParameter(FormalParameter)");

    let _temp15 = yield* IteratorBindingInitialization_FormalParameter(FormalParameter, iteratorRecord, environment);

    if (_temp15 instanceof AbruptCompletion) {
      return _temp15;
    }

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }
  }

  const last = FormalParameters[FormalParameters.length - 1];

  if (isFunctionRestParameter(last)) {
    return yield* IteratorBindingInitialization_FunctionRestParameter(last, iteratorRecord, environment);
  }

  Assert(isFormalParameter(last), "isFormalParameter(last)");
  return yield* IteratorBindingInitialization_FormalParameter(last, iteratorRecord, environment);
}

//   BindingElement : BindingPattern Initializer
//
// (implicit)
//   BindingElement : SingleNameBinding

function* KeyedBindingInitialization_BindingElement(BindingElement, value, environment, propertyName) {
  let BindingPattern;
  let Initializer;

  switch (true) {
    case isSingleNameBinding(BindingElement):
      return yield* KeyedBindingInitialization_SingleNameBinding(BindingElement, value, environment, propertyName);

    case isBindingPattern(BindingElement):
      BindingPattern = BindingElement;
      Initializer = undefined;
      break;

    case isBindingPatternAndInitializer(BindingElement):
      BindingPattern = BindingElement.left;
      Initializer = BindingElement.right;
      break;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('KeyedBindingInitialization_BindingElement', BindingElement);
  }

  let _temp = GetV(value, propertyName);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let v = _temp;

  if (Initializer !== undefined && Type(v) === 'Undefined') {
    const defaultValue = yield* Evaluate(Initializer);

    let _temp2 = GetValue(defaultValue);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    v = _temp2;
  }

  return yield* BindingInitialization_BindingPattern(BindingPattern, v, environment);
} // 13.3.3.9 #sec-runtime-semantics-keyedbindinginitialization
//   SingleNameBinding : BindingIdentifier Initializer

function* KeyedBindingInitialization_SingleNameBinding(SingleNameBinding, value, environment, propertyName) {
  let BindingIdentifier;
  let Initializer;

  switch (true) {
    case isBindingIdentifier(SingleNameBinding):
      BindingIdentifier = SingleNameBinding;
      Initializer = undefined;
      break;

    case isBindingIdentifierAndInitializer(SingleNameBinding):
      BindingIdentifier = SingleNameBinding.left;
      Initializer = SingleNameBinding.right;
      break;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('KeyedBindingInitialization_SingleNameBinding', SingleNameBinding);
  }

  const bindingId = new Value(BindingIdentifier.name);

  let _temp3 = ResolveBinding(bindingId, environment, BindingIdentifier.strict);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const lhs = _temp3;

  let _temp4 = GetV(value, propertyName);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  let v = _temp4;

  if (Initializer !== undefined && Type(v) === 'Undefined') {
    if (IsAnonymousFunctionDefinition(Initializer)) {
      v = yield* NamedEvaluation_Expression(Initializer, bindingId);
    } else {
      const defaultValue = yield* Evaluate(Initializer);

      let _temp5 = GetValue(defaultValue);

      if (_temp5 instanceof AbruptCompletion) {
        return _temp5;
      }

      if (_temp5 instanceof Completion) {
        _temp5 = _temp5.Value;
      }

      v = _temp5;
    }
  }

  if (Type(environment) === 'Undefined') {
    return PutValue(lhs, v);
  }

  return InitializeReferencedBinding(lhs, v);
}

function* LabelledEvaluation({
  label: LabelIdentifier,
  body: LabelledItem
}, labelSet) {
  const label = new Value(LabelIdentifier.name);
  labelSet.add(label);
  let stmtResult;

  switch (true) {
    case isBreakableStatement(LabelledItem):
      stmtResult = yield* LabelledEvaluation_BreakableStatement(LabelledItem, labelSet);
      break;

    case isLabelledStatement(LabelledItem):
      stmtResult = yield* LabelledEvaluation(LabelledItem, labelSet);
      break;

    case isStatement(LabelledItem):
      stmtResult = yield* Evaluate(LabelledItem);
      break;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('LabelledEvaluation', LabelledItem);
  }

  stmtResult = EnsureCompletion(stmtResult);

  if (stmtResult.Type === 'break' && SameValue(stmtResult.Target, label) === Value.true) {
    stmtResult = new NormalCompletion(stmtResult.Value);
  }

  return Completion(stmtResult);
} // 13.13.15 #sec-labelled-statements-runtime-semantics-evaluation


function* Evaluate_LabelledStatement(LabelledStatement) {
  const newLabelSet = new ValueSet();
  return yield* LabelledEvaluation(LabelledStatement, newLabelSet);
}

//   LexicalBinding :
//     BindingIdentifier
//     BindingIdentifier Initializer

function* Evaluate_LexicalBinding_BindingIdentifier(LexicalBinding) {
  const {
    id: BindingIdentifier,
    init: Initializer,
    strict
  } = LexicalBinding;
  const bindingId = new Value(BindingIdentifier.name);

  let _temp = ResolveBinding(bindingId, undefined, strict);

  Assert(!(_temp instanceof AbruptCompletion), "ResolveBinding(bindingId, undefined, strict)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lhs = _temp;

  if (Initializer) {
    let value;

    if (IsAnonymousFunctionDefinition(Initializer)) {
      value = yield* NamedEvaluation_Expression(Initializer, bindingId);
    } else {
      const rhs = yield* Evaluate(Initializer);

      let _temp2 = GetValue(rhs);
      /* istanbul ignore if */


      if (_temp2 instanceof AbruptCompletion) {
        return _temp2;
      }
      /* istanbul ignore if */


      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      value = _temp2;
    }

    return InitializeReferencedBinding(lhs, value);
  } else {
    return InitializeReferencedBinding(lhs, Value.undefined);
  }
} // 13.3.1.4 #sec-let-and-const-declarations-runtime-semantics-evaluation
//   LexicalBinding : BindingPattern Initializer


function* Evaluate_LexicalBinding_BindingPattern(LexicalBinding) {
  const {
    id: BindingPattern,
    init: Initializer
  } = LexicalBinding;
  const rhs = yield* Evaluate(Initializer);

  let _temp3 = GetValue(rhs);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const value = _temp3;
  const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  return yield* BindingInitialization_BindingPattern(BindingPattern, value, env);
}

function* Evaluate_LexicalBinding(LexicalBinding) {
  switch (true) {
    case isBindingIdentifier(LexicalBinding.id):
      return yield* Evaluate_LexicalBinding_BindingIdentifier(LexicalBinding);

    case isBindingPattern(LexicalBinding.id):
      return yield* Evaluate_LexicalBinding_BindingPattern(LexicalBinding);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_LexicalBinding', LexicalBinding.id);
  }
} // 13.3.1.4 #sec-let-and-const-declarations-runtime-semantics-evaluation
//   BindingList : BindingList `,` LexicalBinding
//
// (implicit)
//   BindingList : LexicalBinding

function* Evaluate_BindingList(BindingList) {
  let last;

  for (const LexicalBinding of BindingList) {
    last = yield* Evaluate_LexicalBinding(LexicalBinding);

    /* istanbul ignore if */
    if (last instanceof AbruptCompletion) {
      return last;
    }
    /* istanbul ignore if */


    if (last instanceof Completion) {
      last = last.Value;
    }
  }

  return last;
} // 13.3.1.4 #sec-let-and-const-declarations-runtime-semantics-evaluation
//   LexicalDeclaration : LetOrConst BindingList `;`

function* Evaluate_LexicalDeclaration({
  declarations: BindingList
}) {
  let next = yield* Evaluate_BindingList(BindingList);

  if (next instanceof AbruptCompletion) {
    return next;
  }

  if (next instanceof Completion) {
    next = next.Value;
  }
  return new NormalCompletion(undefined);
}

//   Literal : StringLiteral
//   Literal : BooleanLiteral
//   Literal : NumericLiteral

function Evaluate_Literal(Literal) {
  switch (true) {
    case Literal.raw === 'null':
      return Value.null;

    case Literal.raw === 'true':
      return Value.true;

    case Literal.raw === 'false':
      return Value.false;

    case typeof Literal.value === 'number':
      return new Value(MV_NumericLiteral(Literal.raw));

    case typeof Literal.value === 'bigint':
      // TODO: Run MV parser on Literal.raw.
      return new Value(Literal.value);

    case typeof Literal.value === 'string':
      return new Value(Literal.value);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_Literal', Literal);
  }
}

// LogicalANDExpression : LogicalANDExpression `&&` BitwiseORExpression

function* Evaluate_LogicalANDExpression({
  left: LogicalANDExpression,
  right: BitwiseORExpression
}) {
  const lref = yield* Evaluate(LogicalANDExpression);

  let _temp = GetValue(lref);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lval = _temp;
  const lbool = ToBoolean(lval);

  if (lbool === Value.false) {
    return lval;
  }

  const rref = yield* Evaluate(BitwiseORExpression);
  return GetValue(rref);
}

// LogicalORExpression : LogicalORExpression `||` LogicalANDExpression

function* Evaluate_LogicalORExpression({
  left: LogicalORExpression,
  right: LogicalANDExpression
}) {
  const lref = yield* Evaluate(LogicalORExpression);

  let _temp = GetValue(lref);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lval = _temp;
  const lbool = ToBoolean(lval);

  if (lbool === Value.true) {
    return lval;
  }

  const rref = yield* Evaluate(LogicalANDExpression);
  return GetValue(rref);
}

//   MemberExpression : MemberExpression `[` Expression `]`
//   CallExpression : CallExpression `[` Expression `]`

function* Evaluate_MemberExpression_Expression(MemberExpression, Expression) {
  // 1. Let baseReference be the result of evaluating |MemberExpression|.
  const baseReference = yield* Evaluate(MemberExpression); // 2. Let baseValue be ? GetValue(baseReference).

  let _temp = GetValue(baseReference);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const baseValue = _temp; // 3. If the code matched by this |MemberExpression| is strict mode code, let strict be true; else let strict be false.

  const strict = MemberExpression.strict; // 4. Return ? EvaluatePropertyAccessWithExpressionKey(baseValue, |Expression|, strict).

  return yield* EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict);
} // 12.3.2.1 #sec-property-accessors-runtime-semantics-evaluation
//   MemberExpression : MemberExpression `.` IdentifierName
//   CallExpression : CallExpression `.` IdentifierName


function* Evaluate_MemberExpression_IdentifierName(MemberExpression, IdentifierName) {
  // 1. Let baseReference be the result of evaluating |MemberExpression|.
  const baseReference = yield* Evaluate(MemberExpression); // 2. Let baseValue be ? GetValue(baseReference).

  let _temp2 = GetValue(baseReference);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const baseValue = _temp2; // 3. If the code matched by this |MemberExpression| is strict mode code, let strict be true; else let strict be false.

  const strict = MemberExpression.strict; // 4. Return ? EvaluatePropertyAccessWithIdentifierKey(baseValue, |IdentifierName|, strict).

  return EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict);
} // 12.3.2.1 #sec-property-accessors-runtime-semantics-evaluation
//   MemberExpression :
//     MemberExpression `[` Expression `]`
//     MemberExpression `.` IdentifierName
//   CallExpression :
//     CallExpression `[` Expression `]`
//     CallExpression `.` IdentifierName


function* Evaluate_MemberExpression(MemberExpression) {
  switch (true) {
    case isActualMemberExpressionWithBrackets(MemberExpression):
      return yield* Evaluate_MemberExpression_Expression(MemberExpression.object, MemberExpression.property);

    case isActualMemberExpressionWithDot(MemberExpression):
      return yield* Evaluate_MemberExpression_IdentifierName(MemberExpression.object, MemberExpression.property);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_MemberExpression', MemberExpression);
  }
}

// NewTarget : `new` `.` `target`

function Evaluate_NewTarget() {
  return GetNewTarget();
} // https://tc39.es/proposal-import-meta/#sec-meta-properties
// ImportMeta : `import` `.` `meta`


function Evaluate_ImportMeta() {
  const module = GetActiveScriptOrModule();
  Assert(module instanceof AbstractModuleRecord, "module instanceof AbstractModuleRecord");
  let importMeta = module.ImportMeta;

  if (importMeta === Value.undefined) {
    importMeta = ObjectCreate(Value.null);

    let _temp = HostGetImportMetaProperties(module);

    Assert(!(_temp instanceof AbruptCompletion), "HostGetImportMetaProperties(module)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const importMetaValues = _temp;

    for (const p of importMetaValues) {
      let _temp2 = CreateDataProperty(importMeta, p.Key, p.Value);

      Assert(!(_temp2 instanceof AbruptCompletion), "CreateDataProperty(importMeta, p.Key, p.Value)" + ' returned an abrupt completion');

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }
    }

    let _temp3 = HostFinalizeImportMeta(importMeta, module);

    Assert(!(_temp3 instanceof AbruptCompletion), "HostFinalizeImportMeta(importMeta, module)" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }
    module.ImportMeta = importMeta;
    return importMeta;
  } else {
    Assert(Type(importMeta) === 'Object', "Type(importMeta) === 'Object'");
    return importMeta;
  }
} // #prod-MetaProperty
// MetaProperty : NewTarget


function* Evaluate_MetaProperty(MetaProperty) {
  // eslint-disable-line require-yield
  switch (true) {
    case isNewTarget(MetaProperty):
      return Evaluate_NewTarget();

    case isImportMeta(MetaProperty):
      return Evaluate_ImportMeta();

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_MetaProperty', MetaProperty);
  }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var nearley = createCommonjsModule(function (module) {
(function(root, factory) {
    if ( module.exports) {
        module.exports = factory();
    } else {
        root.nearley = factory();
    }
}(commonjsGlobal, function() {

    function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;        // a list of literal | regex class | nonterminal
        this.postprocess = postprocess;
        return this;
    }
    Rule.highestId = 0;

    Rule.prototype.toString = function(withCursorAt) {
        function stringifySymbolSequence (e) {
            return e.literal ? JSON.stringify(e.literal) :
                   e.type ? '%' + e.type : e.toString();
        }
        var symbolSequence = (typeof withCursorAt === "undefined")
                             ? this.symbols.map(stringifySymbolSequence).join(' ')
                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')
                                 + "  "
                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );
        return this.name + "  " + symbolSequence;
    };


    // a State is a rule at a position from a given starting point in the input stream (reference)
    function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
    }

    State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
    };

    State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
            state.data = state.build();
        }
        return state;
    };

    State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
            children.push(node.right.data);
            node = node.left;
        } while (node.left);
        children.reverse();
        return children;
    };

    State.prototype.finish = function() {
        if (this.rule.postprocess) {
            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
    };


    function Column(grammar, index) {
        this.grammar = grammar;
        this.index = index;
        this.states = [];
        this.wants = {}; // states indexed by the non-terminal they expect
        this.scannable = []; // list of states that expect a token
        this.completed = {}; // states that are nullable
    }


    Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;

        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration
            var state = states[w];

            if (state.isComplete) {
                state.finish();
                if (state.data !== Parser.fail) {
                    // complete
                    var wantedBy = state.wantedBy;
                    for (var i = wantedBy.length; i--; ) { // this line is hot
                        var left = wantedBy[i];
                        this.complete(left, state);
                    }

                    // special-case nullables
                    if (state.reference === this.index) {
                        // make sure future predictors of this rule get completed.
                        var exp = state.rule.name;
                        (this.completed[exp] = this.completed[exp] || []).push(state);
                    }
                }

            } else {
                // queue scannable states
                var exp = state.rule.symbols[state.dot];
                if (typeof exp !== 'string') {
                    this.scannable.push(state);
                    continue;
                }

                // predict
                if (wants[exp]) {
                    wants[exp].push(state);

                    if (completed.hasOwnProperty(exp)) {
                        var nulls = completed[exp];
                        for (var i = 0; i < nulls.length; i++) {
                            var right = nulls[i];
                            this.complete(state, right);
                        }
                    }
                } else {
                    wants[exp] = [state];
                    this.predict(exp);
                }
            }
        }
    };

    Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];

        for (var i = 0; i < rules.length; i++) {
            var r = rules[i];
            var wantedBy = this.wants[exp];
            var s = new State(r, 0, this.index, wantedBy);
            this.states.push(s);
        }
    };

    Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
    };


    function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
            if (!byName.hasOwnProperty(rule.name)) {
                byName[rule.name] = [];
            }
            byName[rule.name].push(rule);
        });
    }

    // So we can allow passing (rules, start) directly to Parser for backwards compatibility
    Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });
        var g = new Grammar(rules, start);
        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable
        return g;
    };


    function StreamLexer() {
      this.reset("");
    }

    StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
    };

    StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
            var ch = this.buffer[this.index++];
            if (ch === '\n') {
              this.line += 1;
              this.lastLineBreak = this.index;
            }
            return {value: ch};
        }
    };

    StreamLexer.prototype.save = function() {
      return {
        line: this.line,
        col: this.index - this.lastLineBreak,
      }
    };

    StreamLexer.prototype.formatError = function(token, message) {
        // nb. this gets called after consuming the offending token,
        // so the culprit is index-1
        var buffer = this.buffer;
        if (typeof buffer === 'string') {
            var nextLineBreak = buffer.indexOf('\n', this.index);
            if (nextLineBreak === -1) nextLineBreak = buffer.length;
            var line = buffer.substring(this.lastLineBreak, nextLineBreak);
            var col = this.index - this.lastLineBreak;
            message += " at line " + this.line + " col " + col + ":\n\n";
            message += "  " + line + "\n";
            message += "  " + Array(col).join(" ") + "^";
            return message;
        } else {
            return message + " at index " + (this.index - 1);
        }
    };


    function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
            var grammar = rules;
            var options = start;
        } else {
            var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;

        // Read options
        this.options = {
            keepHistory: false,
            lexer: grammar.lexer || new StreamLexer,
        };
        for (var key in (options || {})) {
            this.options[key] = options[key];
        }

        // Setup lexer
        this.lexer = this.options.lexer;
        this.lexerState = undefined;

        // Setup a table
        var column = new Column(grammar, 0);
        var table = this.table = [column];

        // I could be expecting anything.
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        // TODO what if start rule is nullable?
        column.process();
        this.current = 0; // token index
    }

    // create a reserved token for indicating a parse fail
    Parser.fail = {};

    Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);

        var token;
        while (token = lexer.next()) {
            // We add new states to table[current+1]
            var column = this.table[this.current];

            // GC unused states
            if (!this.options.keepHistory) {
                delete this.table[this.current - 1];
            }

            var n = this.current + 1;
            var nextColumn = new Column(this.grammar, n);
            this.table.push(nextColumn);

            // Advance all tokens that expect the symbol
            var literal = token.text !== undefined ? token.text : token.value;
            var value = lexer.constructor === StreamLexer ? token.value : token;
            var scannable = column.scannable;
            for (var w = scannable.length; w--; ) {
                var state = scannable[w];
                var expect = state.rule.symbols[state.dot];
                // Try to consume the token
                // either regex or literal
                if (expect.test ? expect.test(value) :
                    expect.type ? expect.type === token.type
                                : expect.literal === literal) {
                    // Add it
                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});
                    nextColumn.states.push(next);
                }
            }

            // Next, for each of the rules, we either
            // (a) complete it, and try to see if the reference row expected that
            //     rule
            // (b) predict the next nonterminal it expects by adding that
            //     nonterminal's start state
            // To prevent duplication, we also keep track of rules we have already
            // added

            nextColumn.process();

            // If needed, throw an error:
            if (nextColumn.states.length === 0) {
                // No states at all! This is not good.
                var message = this.lexer.formatError(token, "invalid syntax") + "\n";
                message += "Unexpected " + (token.type ? token.type + " token: " : "");
                message += JSON.stringify(token.value !== undefined ? token.value : token) + "\n";
                var err = new Error(message);
                err.offset = this.current;
                err.token = token;
                throw err;
            }

            // maybe save lexer state
            if (this.options.keepHistory) {
              column.lexerState = lexer.save();
            }

            this.current++;
        }
        if (column) {
          this.lexerState = lexer.save();
        }

        // Incrementally keep track of results
        this.results = this.finish();

        // Allow chaining, for whatever it's worth
        return this;
    };

    Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
    };

    Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;

        // Incrementally keep track of results
        this.results = this.finish();
    };

    // nb. deprecated: use save/restore instead!
    Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
            throw new Error('set option `keepHistory` to enable rewinding')
        }
        // nb. recall column (table) indicies fall between token indicies.
        //        col 0   --   token 0   --   col 1
        this.restore(this.table[index]);
    };

    Parser.prototype.finish = function() {
        // Return the possible parsings
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function (t) {
            if (t.rule.name === start
                    && t.dot === t.rule.symbols.length
                    && t.reference === 0
                    && t.data !== Parser.fail) {
                considerations.push(t);
            }
        });
        return considerations.map(function(c) {return c.data; });
    };

    return {
        Parser: Parser,
        Grammar: Grammar,
        Rule: Rule,
    };

}));
});

const {
  isNewLine: isNewLine$1,
  nonASCIIwhitespace: nonASCIIwhitespace$1
} = acorn;

function isWhiteSpace(c) {
  return c === '\x09' // CHARACTER TABULATION
  || c === '\x0B' // LINE TABULATION
  || c === '\x0C' // FORM FEED (FF)
  || c === '\x20' // SPACE
  || c === '\xA0' // NO-BREAK SPACE
  || nonASCIIwhitespace$1.test(c);
}

const isLineTerminator = c => isNewLine$1(c.charCodeAt(0), false);

const isStrWhiteSpaceChar = c => isWhiteSpace(c) || isLineTerminator(c); // Returns index of first non-StrWhiteSpaceChar character.


function searchNotStrWhiteSpaceChar(str) {
  for (let i = 0; i < str.length; i += 1) {
    if (!isStrWhiteSpaceChar(str[i])) return i;
  }

  return str.length;
} // Returns index of last non-StrWhiteSpaceChar character + 1.

function reverseSearchNotStrWhiteSpaceChar(str) {
  for (let i = str.length - 1; i >= 0; i -= 1) {
    if (!isStrWhiteSpaceChar(str[i])) return i + 1;
  }

  return 0;
}

/* eslint-disable no-bitwise */
// Divide a non-negative `num` by a positive `den`. The quotient is rounded to
// its nearest integer, or the even integer if there are two equally near
// integer.
function roundQuotientBigInt(num, den) {
  const quo = num / den;
  const rem = num % den;
  const rem2 = rem * 2n;

  if (rem2 > den || rem2 === den && quo % 2n !== 0n) {
    return quo + 1n;
  } else {
    return quo;
  }
}

const throwawayArray = new Float64Array(1);
const throwawayArrayInt = new Uint32Array(throwawayArray.buffer); // Find out if the host's [[BigEndian]] is true or false, by checking the
// representation for -0.

throwawayArray[0] = -0;
const float64High = throwawayArrayInt[0] === 0 ? 1 : 0; // Return x * 2 ** exp where x is a Number, and exp is an integer.
//
// Derived from
// https://github.com/JuliaMath/openlibm/blob/0f22aeb0a9104c52106f42ce1fa8ebe96fb498f1/src/s_scalbn.c.
//
// License:
//
//     Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//     Developed at SunPro, a Sun Microsystems, Inc. business.
//     Permission to use, copy, modify, and distribute this
//     software is freely granted, provided that this notice
//     is preserved.

function scalb(x, exp) {
  if (x === 0 || exp === 0 || !Number.isFinite(x)) {
    return x;
  }

  if (exp >= 2000) {
    return x * Infinity;
  } else if (exp <= -2000) {
    return x * 0;
  }

  throwawayArray[0] = x;
  let origExp = throwawayArrayInt[float64High] >>> 20 & 0x7ff;

  if (origExp === 0) {
    // x is denormalized. Multiply x by 2**54 (1 + number of mantissa bits),
    // and correspondingly reduce exp by 54.
    throwawayArray[0] *= 18014398509481984;
    exp -= 54;
    if (exp === 0) return throwawayArray[0];
    origExp = throwawayArrayInt[float64High] >>> 20 & 0x7ff;
  }

  const newExp = origExp + exp;

  if (newExp > 0x7fe) {
    // Overflow. Return Infinity, but of the appropriate sign.
    return throwawayArray[0] * Infinity;
  }

  if (newExp > 0) {
    // Normalized, okay.
    throwawayArrayInt[float64High] ^= (origExp ^ newExp) << 20;
    return throwawayArray[0];
  }

  if (newExp <= -54) {
    // Underflow. Return 0, but of the appropriate sign.
    return throwawayArray[0] * 0;
  } // Denormalized result. Add 54 to newExp and multiply the resultant number by
  // 2**-54.


  throwawayArrayInt[float64High] ^= (origExp ^ newExp + 54) << 20;
  return throwawayArray[0] * 5.55111512312578270212e-17;
} // Return the minimum number of bits it takes to store `bint`. This function
// assumes a host implementation on which a BigInt value cannot exceed 2^(4n),
// where n is the maximum length of a String value on that host (usually around
// 2^31, but can be up to 2^53 - 1 by spec).


function bitLengthBigInt(bint) {
  if (bint < 0n) {
    bint = -bint;
  }

  let increment = 0;

  if (bint > (1n << 32n) - 1n) {
    // This number is larger than 2^32 - 1, which is just huge. Let's form an
    // estimate of how many bits it requires first, accurate to the nearest
    // multiple of log2(16) = 4, by converting it to a hexadecimal string and
    // measuring the resulting length.
    const hexLength = bint.toString(16).length;
    const estimatedBitLength = (hexLength - 1) * 4;
    increment += estimatedBitLength;
    bint >>= BigInt(estimatedBitLength);
  } // As we are sure that bint is within the range of an unsigned 32-bit
  // integer, we can use Math.clz32().


  return 32 - Math.clz32(Number(bint)) + increment;
}

function approximateLog10BigInt(bint) {
  return bint.toString(10).length;
} // Number of mantissa bits in a IEEE 754-2008 binary64 value.


const MANTISSA_BITS = 53; // A class representing a decimal number in scientific notation, or otherwise
// known as a decimal floating-point number.

class Scientific {
  constructor(num, exp = 0n) {
    if (typeof num !== 'bigint') {
      // eslint-disable-line valid-typeof
      throw new TypeError('Numerator must be a BigInt');
    }

    if (typeof exp !== 'bigint') {
      // eslint-disable-line valid-typeof
      throw new TypeError('Numerator must be a BigInt');
    }

    this.num = num;
    this.exp = exp;
  }

  negate() {
    return new this.constructor(-this.num, this.exp);
  }

  convExp(exp) {
    if (this.exp === exp) {
      return this;
    } else if (this.exp > exp) {
      return new this.constructor(this.num * 10n ** (this.exp - exp), exp);
    }

    throw new RangeError('Requested exponent must be less than or equal to the current exponent');
  }

  expAdd(e) {
    return new this.constructor(this.num, this.exp + e);
  }

  addSci(sci) {
    const expectedExp = this.exp < sci.exp ? this.exp : sci.exp;
    const conv1 = this.convExp(expectedExp);
    const conv2 = sci.convExp(expectedExp);
    return new this.constructor(conv1.num + conv2.num, expectedExp);
  } // Derived from "Easy Accurate Reading and Writing of Floating-Point Numbers"
  // by Aubrey Jaffer, <https://arxiv.org/abs/1310.8121v7>.


  toNumber() {
    if (this.num === 0n) {
      return 0;
    }

    if (this.num < 0) {
      return -new this.constructor(-this.num, this.exp).toNumber();
    }

    let {
      num,
      exp
    } = this; // According to V8, the "Maximum number of significant digits in decimal
    // representation" for a binary64 value is 772. See [1]. Let's first make
    // sure we have a reasonably small this.num ( 10**800) while not losing
    // accuracy, so that we can fast-path numbers with astronomical exponents.
    //
    // [1]: https://cs.chromium.org/chromium/src/v8/src/conversions.cc?l=565-571&rcl=dadf4cbe89c1e9ee9fed6181216cb4d3ba647a68

    const approximateDecimalDigits = approximateLog10BigInt(this.num);

    if (approximateDecimalDigits > 800) {
      const comp = BigInt(approximateDecimalDigits - 800); // We don't care about rounding as we still have quite a large margin of
      // error.

      num /= 10n ** comp;
      exp += comp;
    }

    if (exp > 310n) {
      // Largest possible value is < 2e308.
      return Infinity;
    } else if (exp < -1150n) {
      // Smallest possible value is 5e-324, but num may be at most 1e801, so we
      // are slightly more careful and only fast-path truly miniscule
      // exponents.
      return 0;
    }

    const expNum = Number(exp);

    if (expNum >= 0) {
      const numScaled = num * 5n ** exp;
      const bex = bitLengthBigInt(numScaled) - MANTISSA_BITS;

      if (bex <= 0) {
        return scalb(Number(numScaled), expNum);
      }

      const quo = roundQuotientBigInt(numScaled, 1n << BigInt(bex));
      return scalb(Number(quo), bex + expNum);
    }

    const scl = 5n ** -exp;
    let mantlen = MANTISSA_BITS;
    let bex = bitLengthBigInt(num) - bitLengthBigInt(scl) - mantlen;
    const tmp = bex + expNum + 1021 + mantlen;

    if (tmp < 0) {
      bex -= tmp + 1;
      mantlen += tmp;
    }

    const numScaled = num << BigInt(-bex);
    let quo = roundQuotientBigInt(numScaled, scl);

    if (bitLengthBigInt(quo) > mantlen) {
      bex += 1;
      quo = roundQuotientBigInt(numScaled, scl << 1n);
    }

    return scalb(Number(quo), bex + expNum);
  }

}

// Generated automatically by nearley, version 2.19.0

function c(val) {
  return () => val;
}

let Lexer = undefined;
let ParserRules = [{
  "name": "StrNumericLiteral",
  "symbols": ["StrDecimalLiteral"],
  "postprocess": ([StrDecimalLiteral]) => StrDecimalLiteral
}, {
  "name": "StrNumericLiteral",
  "symbols": ["BinaryIntegerLiteral"],
  "postprocess": ([BinaryIntegerLiteral]) => BinaryIntegerLiteral
}, {
  "name": "StrNumericLiteral",
  "symbols": ["OctalIntegerLiteral"],
  "postprocess": ([OctalIntegerLiteral]) => OctalIntegerLiteral
}, {
  "name": "StrNumericLiteral",
  "symbols": ["HexIntegerLiteral"],
  "postprocess": ([HexIntegerLiteral]) => HexIntegerLiteral
}, {
  "name": "StrDecimalLiteral",
  "symbols": ["StrUnsignedDecimalLiteral"],
  "postprocess": ([StrUnsignedDecimalLiteral]) => StrUnsignedDecimalLiteral
}, {
  "name": "StrDecimalLiteral",
  "symbols": [{
    "literal": "+"
  }, "StrUnsignedDecimalLiteral"],
  "postprocess": ([_, StrUnsignedDecimalLiteral]) => StrUnsignedDecimalLiteral
}, {
  "name": "StrDecimalLiteral",
  "symbols": [{
    "literal": "-"
  }, "StrUnsignedDecimalLiteral"],
  "postprocess": ([_, StrUnsignedDecimalLiteral]) => StrUnsignedDecimalLiteral.negate()
}, {
  "name": "StrUnsignedDecimalLiteral$string$1",
  "symbols": [{
    "literal": "I"
  }, {
    "literal": "n"
  }, {
    "literal": "f"
  }, {
    "literal": "i"
  }, {
    "literal": "n"
  }, {
    "literal": "i"
  }, {
    "literal": "t"
  }, {
    "literal": "y"
  }],
  "postprocess": function joiner(d) {
    return d.join('');
  }
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": ["StrUnsignedDecimalLiteral$string$1"],
  "postprocess": () => new Scientific(1n, 10000n)
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": ["DecimalDigits", {
    "literal": "."
  }],
  "postprocess": ([[DecimalDigits]]) => new Scientific(DecimalDigits)
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": ["DecimalDigits", {
    "literal": "."
  }, "DecimalDigits"],
  "postprocess": ([[first], _, [second, n]]) => new Scientific(first).addSci(new Scientific(second, -n))
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": ["DecimalDigits", {
    "literal": "."
  }, "ExponentPart"],
  "postprocess": ([[DecimalDigits], _, e]) => new Scientific(DecimalDigits, e)
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": ["DecimalDigits", {
    "literal": "."
  }, "DecimalDigits", "ExponentPart"],
  "postprocess": ([[first], _, [second, n], e]) => new Scientific(first).addSci(new Scientific(second, -n)).expAdd(e)
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": [{
    "literal": "."
  }, "DecimalDigits"],
  "postprocess": ([_, [DecimalDigits, n]]) => new Scientific(DecimalDigits, -n)
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": [{
    "literal": "."
  }, "DecimalDigits", "ExponentPart"],
  "postprocess": ([_, [DecimalDigits, n], e]) => new Scientific(DecimalDigits, e - n)
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": ["DecimalDigits"],
  "postprocess": ([[DecimalDigits]]) => new Scientific(DecimalDigits)
}, {
  "name": "StrUnsignedDecimalLiteral",
  "symbols": ["DecimalDigits", "ExponentPart"],
  "postprocess": ([[DecimalDigits], e]) => new Scientific(DecimalDigits, e)
}, {
  "name": "NumericLiteral",
  "symbols": ["DecimalLiteral"],
  "postprocess": ([DecimalLiteral]) => DecimalLiteral
}, {
  "name": "NumericLiteral",
  "symbols": ["BinaryIntegerLiteral"],
  "postprocess": ([BinaryIntegerLiteral]) => BinaryIntegerLiteral
}, {
  "name": "NumericLiteral",
  "symbols": ["OctalIntegerLiteral"],
  "postprocess": ([OctalIntegerLiteral]) => OctalIntegerLiteral
}, {
  "name": "NumericLiteral",
  "symbols": ["HexIntegerLiteral"],
  "postprocess": ([HexIntegerLiteral]) => HexIntegerLiteral
}, {
  "name": "DecimalLiteral",
  "symbols": ["DecimalIntegerLiteral", {
    "literal": "."
  }],
  "postprocess": ([DecimalIntegerLiteral]) => new Scientific(DecimalIntegerLiteral)
}, {
  "name": "DecimalLiteral",
  "symbols": ["DecimalIntegerLiteral", {
    "literal": "."
  }, "DecimalDigits"],
  "postprocess": ([DecimalIntegerLiteral, _, [DecimalDigits, n]]) => new Scientific(DecimalIntegerLiteral).addSci(new Scientific(DecimalDigits, -n))
}, {
  "name": "DecimalLiteral",
  "symbols": ["DecimalIntegerLiteral", {
    "literal": "."
  }, "ExponentPart"],
  "postprocess": ([DecimalIntegerLiteral, _, e]) => new Scientific(DecimalIntegerLiteral, e)
}, {
  "name": "DecimalLiteral",
  "symbols": ["DecimalIntegerLiteral", {
    "literal": "."
  }, "DecimalDigits", "ExponentPart"],
  "postprocess": ([DecimalIntegerLiteral, _, [DecimalDigits, n], e]) => new Scientific(DecimalIntegerLiteral).addSci(new Scientific(DecimalDigits, -n)).expAdd(e)
}, {
  "name": "DecimalLiteral",
  "symbols": [{
    "literal": "."
  }, "DecimalDigits"],
  "postprocess": ([_, [DecimalDigits, n]]) => new Scientific(DecimalDigits, -n)
}, {
  "name": "DecimalLiteral",
  "symbols": [{
    "literal": "."
  }, "DecimalDigits", "ExponentPart"],
  "postprocess": ([_, [DecimalDigits, n], e]) => new Scientific(DecimalDigits, e - n)
}, {
  "name": "DecimalLiteral",
  "symbols": ["DecimalIntegerLiteral"],
  "postprocess": ([DecimalIntegerLiteral]) => new Scientific(DecimalIntegerLiteral)
}, {
  "name": "DecimalLiteral",
  "symbols": ["DecimalIntegerLiteral", "ExponentPart"],
  "postprocess": ([DecimalIntegerLiteral, e]) => new Scientific(DecimalIntegerLiteral, e)
}, {
  "name": "DecimalIntegerLiteral",
  "symbols": [{
    "literal": "0"
  }],
  "postprocess": c(0n)
}, {
  "name": "DecimalIntegerLiteral",
  "symbols": ["NonZeroDigit"],
  "postprocess": ([NonZeroDigit]) => NonZeroDigit
}, {
  "name": "DecimalIntegerLiteral",
  "symbols": ["NonZeroDigit", "DecimalDigits"],
  "postprocess": ([NonZeroDigit, [DecimalDigits, n]]) => NonZeroDigit * 10n ** n + DecimalDigits
}, {
  "name": "DecimalDigits",
  "symbols": ["DecimalDigit"],
  "postprocess": ([DecimalDigit]) => [DecimalDigit, 1n]
}, {
  "name": "DecimalDigits",
  "symbols": ["DecimalDigits", "DecimalDigit"],
  "postprocess": ([[DecimalDigits, n], DecimalDigit]) => [DecimalDigits * 10n + DecimalDigit, n + 1n]
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "0"
  }],
  "postprocess": c(0n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "1"
  }],
  "postprocess": c(1n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "2"
  }],
  "postprocess": c(2n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "3"
  }],
  "postprocess": c(3n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "4"
  }],
  "postprocess": c(4n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "5"
  }],
  "postprocess": c(5n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "6"
  }],
  "postprocess": c(6n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "7"
  }],
  "postprocess": c(7n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "8"
  }],
  "postprocess": c(8n)
}, {
  "name": "DecimalDigit",
  "symbols": [{
    "literal": "9"
  }],
  "postprocess": c(9n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "1"
  }],
  "postprocess": c(1n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "2"
  }],
  "postprocess": c(2n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "3"
  }],
  "postprocess": c(3n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "4"
  }],
  "postprocess": c(4n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "5"
  }],
  "postprocess": c(5n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "6"
  }],
  "postprocess": c(6n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "7"
  }],
  "postprocess": c(7n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "8"
  }],
  "postprocess": c(8n)
}, {
  "name": "NonZeroDigit",
  "symbols": [{
    "literal": "9"
  }],
  "postprocess": c(9n)
}, {
  "name": "ExponentPart",
  "symbols": ["ExponentIndicator", "SignedInteger"],
  "postprocess": ([_, SignedInteger]) => SignedInteger
}, {
  "name": "ExponentIndicator$subexpression$1",
  "symbols": [/[eE]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "ExponentIndicator",
  "symbols": ["ExponentIndicator$subexpression$1"]
}, {
  "name": "SignedInteger",
  "symbols": ["DecimalDigits"],
  "postprocess": ([[DecimalDigits]]) => DecimalDigits
}, {
  "name": "SignedInteger",
  "symbols": [{
    "literal": "+"
  }, "DecimalDigits"],
  "postprocess": ([_, [DecimalDigits]]) => DecimalDigits
}, {
  "name": "SignedInteger",
  "symbols": [{
    "literal": "-"
  }, "DecimalDigits"],
  "postprocess": ([_, [DecimalDigits]]) => -DecimalDigits
}, {
  "name": "BinaryIntegerLiteral$subexpression$1",
  "symbols": [{
    "literal": "0"
  }, /[bB]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "BinaryIntegerLiteral",
  "symbols": ["BinaryIntegerLiteral$subexpression$1", "BinaryDigits"],
  "postprocess": ([_, BinaryDigits]) => new Scientific(BinaryDigits)
}, {
  "name": "BinaryDigits",
  "symbols": ["BinaryDigit"],
  "postprocess": ([BinaryDigit]) => BinaryDigit
}, {
  "name": "BinaryDigits",
  "symbols": ["BinaryDigits", "BinaryDigit"],
  "postprocess": ([BinaryDigits, BinaryDigit]) => BinaryDigits * 2n + BinaryDigit
}, {
  "name": "BinaryDigit",
  "symbols": [{
    "literal": "0"
  }],
  "postprocess": c(0n)
}, {
  "name": "BinaryDigit",
  "symbols": [{
    "literal": "1"
  }],
  "postprocess": c(1n)
}, {
  "name": "OctalIntegerLiteral$subexpression$1",
  "symbols": [{
    "literal": "0"
  }, /[oO]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "OctalIntegerLiteral",
  "symbols": ["OctalIntegerLiteral$subexpression$1", "OctalDigits"],
  "postprocess": ([_, OctalDigits]) => new Scientific(OctalDigits)
}, {
  "name": "OctalDigits",
  "symbols": ["OctalDigit"],
  "postprocess": ([OctalDigit]) => OctalDigit
}, {
  "name": "OctalDigits",
  "symbols": ["OctalDigits", "OctalDigit"],
  "postprocess": ([OctalDigits, OctalDigit]) => OctalDigits * 8n + OctalDigit
}, {
  "name": "OctalDigit",
  "symbols": [{
    "literal": "0"
  }],
  "postprocess": c(0n)
}, {
  "name": "OctalDigit",
  "symbols": [{
    "literal": "1"
  }],
  "postprocess": c(1n)
}, {
  "name": "OctalDigit",
  "symbols": [{
    "literal": "2"
  }],
  "postprocess": c(2n)
}, {
  "name": "OctalDigit",
  "symbols": [{
    "literal": "3"
  }],
  "postprocess": c(3n)
}, {
  "name": "OctalDigit",
  "symbols": [{
    "literal": "4"
  }],
  "postprocess": c(4n)
}, {
  "name": "OctalDigit",
  "symbols": [{
    "literal": "5"
  }],
  "postprocess": c(5n)
}, {
  "name": "OctalDigit",
  "symbols": [{
    "literal": "6"
  }],
  "postprocess": c(6n)
}, {
  "name": "OctalDigit",
  "symbols": [{
    "literal": "7"
  }],
  "postprocess": c(7n)
}, {
  "name": "HexIntegerLiteral$subexpression$1",
  "symbols": [{
    "literal": "0"
  }, /[xX]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "HexIntegerLiteral",
  "symbols": ["HexIntegerLiteral$subexpression$1", "HexDigits"],
  "postprocess": ([_, HexDigits]) => new Scientific(HexDigits)
}, {
  "name": "HexDigits",
  "symbols": ["HexDigit"],
  "postprocess": ([HexDigit]) => HexDigit
}, {
  "name": "HexDigits",
  "symbols": ["HexDigits", "HexDigit"],
  "postprocess": ([HexDigits, HexDigit]) => HexDigits * 16n + HexDigit
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "0"
  }],
  "postprocess": c(0n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "1"
  }],
  "postprocess": c(1n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "2"
  }],
  "postprocess": c(2n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "3"
  }],
  "postprocess": c(3n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "4"
  }],
  "postprocess": c(4n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "5"
  }],
  "postprocess": c(5n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "6"
  }],
  "postprocess": c(6n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "7"
  }],
  "postprocess": c(7n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "8"
  }],
  "postprocess": c(8n)
}, {
  "name": "HexDigit",
  "symbols": [{
    "literal": "9"
  }],
  "postprocess": c(9n)
}, {
  "name": "HexDigit$subexpression$1",
  "symbols": [/[aA]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "HexDigit",
  "symbols": ["HexDigit$subexpression$1"],
  "postprocess": c(10n)
}, {
  "name": "HexDigit$subexpression$2",
  "symbols": [/[bB]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "HexDigit",
  "symbols": ["HexDigit$subexpression$2"],
  "postprocess": c(11n)
}, {
  "name": "HexDigit$subexpression$3",
  "symbols": [/[cC]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "HexDigit",
  "symbols": ["HexDigit$subexpression$3"],
  "postprocess": c(12n)
}, {
  "name": "HexDigit$subexpression$4",
  "symbols": [/[dD]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "HexDigit",
  "symbols": ["HexDigit$subexpression$4"],
  "postprocess": c(13n)
}, {
  "name": "HexDigit$subexpression$5",
  "symbols": [/[eE]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "HexDigit",
  "symbols": ["HexDigit$subexpression$5"],
  "postprocess": c(14n)
}, {
  "name": "HexDigit$subexpression$6",
  "symbols": [/[fF]/],
  "postprocess": function (d) {
    return d.join("");
  }
}, {
  "name": "HexDigit",
  "symbols": ["HexDigit$subexpression$6"],
  "postprocess": c(15n)
}];
let ParserStart = "StrNumericLiteral";
var grammar = {
  Lexer,
  ParserRules,
  ParserStart
};

const {
  ParserRules: ParserRules$1
} = grammar;
const StrNumericLiteralGrammar = nearley.Grammar.fromCompiled({
  ParserRules: ParserRules$1,
  ParserStart: 'StrNumericLiteral'
});
const StrDecimalLiteralGrammar = nearley.Grammar.fromCompiled({
  ParserRules: ParserRules$1,
  ParserStart: 'StrDecimalLiteral'
}); // 7.1.3.1.1 #sec-runtime-semantics-mv-s
// Once the exact MV for a String numeric literal has been determined, it is
// then rounded to a value of the Number type. If the MV is 0, then the rounded
// value is +0 unless the first non white space code point in the String
// numeric literal is "-", in which case the rounded value is -0. Otherwise,
// the rounded value must be the Number value for the MV

function convertScientificMVToNumber(scientific, strWithoutWhitespace) {
  const prelimMV = scientific.toNumber();

  if (prelimMV === 0) {
    if (strWithoutWhitespace[0] === '-') {
      return new Value(-0);
    } else {
      return new Value(+0);
    }
  }

  return new Value(prelimMV);
} // 7.1.3.1.1 #sec-runtime-semantics-mv-s
//   StringNumericLiteral :::
//     [empty]
//     StrWhiteSpace
//     StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt


function MV_StringNumericLiteral(StringNumericLiteral) {
  if (StringNumericLiteral === '') {
    // StringNumericLiteral ::: [empty]
    return new Value(0);
  }

  const leadingWhitespaceStripped = StringNumericLiteral.slice(searchNotStrWhiteSpaceChar(StringNumericLiteral));

  if (leadingWhitespaceStripped === '') {
    // StringNumericLiteral ::: StrWhiteSpace
    return new Value(0);
  } // StringNumericLiteral ::: StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt


  const StrNumericLiteral = leadingWhitespaceStripped.slice(0, reverseSearchNotStrWhiteSpaceChar(leadingWhitespaceStripped));
  return MV_StrNumericLiteral(StrNumericLiteral);
} // 7.1.3.1.1 #sec-runtime-semantics-mv-s
//   StrNumericLiteral :::
//     StrDecimalLiteral
//     BinaryIntegerLiteral
//     OctalIntegerLiteral
//     HexIntegerLiteral

function MV_StrNumericLiteral(StrNumericLiteral) {
  const parser = new nearley.Parser(StrNumericLiteralGrammar);

  try {
    parser.feed(StrNumericLiteral);
  } catch (err) {
    return new Value(NaN);
  }

  if (parser.results.length === 0) {
    return new Value(NaN);
  }

  Assert(parser.results.length === 1, "parser.results.length === 1");
  return convertScientificMVToNumber(parser.results[0], StrNumericLiteral);
} // 7.1.3.1.1 #sec-runtime-semantics-mv-s
//   StrDecimalLiteral :::
//     StrUnsignedDecimalLiteral
//     `+` StrUnsignedDecimalLiteral
//     `-` StrUnsignedDecimalLiteral


function MV_StrDecimalLiteral(StrDecimalLiteral, prefixOk = false) {
  const parser = new nearley.Parser(StrDecimalLiteralGrammar, {
    keepHistory: prefixOk
  });

  try {
    parser.feed(StrDecimalLiteral);
  } catch (err) {
    if (!prefixOk) {
      return new Value(NaN);
    }
  }

  if (prefixOk) {
    // Backtrack until we find a prefix of StrDecimalLiteral that is indeed a
    // StrDecimalLiteral.
    while (parser.table[parser.current]) {
      parser.restore(parser.table[parser.current]);

      if (parser.results.length !== 0) {
        break;
      }

      parser.current -= 1;
    }

    if (parser.results.length === 0) {
      return new Value(NaN);
    }
  }

  Assert(parser.results.length === 1, "parser.results.length === 1");
  return convertScientificMVToNumber(parser.results[0], StrDecimalLiteral);
}

function EvaluateBinopValues_MultiplicativeExpression(MultiplicativeOperator, lval, rval) {
  let _temp = ToNumeric(lval);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lnum = _temp;

  let _temp2 = ToNumeric(rval);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const rnum = _temp2;

  if (Type(lnum) !== Type(rnum)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }

  const T = TypeNumeric(lnum);

  switch (MultiplicativeOperator) {
    case '*':
      return T.multiply(lnum, rnum);

    case '/':
      return T.divide(lnum, rnum);

    case '%':
      return T.remainder(lnum, rnum);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('EvaluateBinopValues_MultiplicativeExpression', MultiplicativeOperator);
  }
}
function* Evaluate_MultiplicativeExpression({
  left: MultiplicativeExpression,
  operator: MultiplicativeOperator,
  right: ExponentiationExpression
}) {
  const left = yield* Evaluate(MultiplicativeExpression);

  let _temp3 = GetValue(left);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const leftValue = _temp3;
  const right = yield* Evaluate(ExponentiationExpression);

  let _temp4 = GetValue(right);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const rightValue = _temp4;
  return EvaluateBinopValues_MultiplicativeExpression(MultiplicativeOperator, leftValue, rightValue);
}

//   ParenthesizedExpression : `(` Expression `)`

function* NamedEvaluation_ParenthesizedExpression(ParenthesizedExpression, name) {
  const {
    expression: Expression
  } = ParenthesizedExpression;
  Assert(IsAnonymousFunctionDefinition(Expression), "IsAnonymousFunctionDefinition(Expression)");
  return yield* NamedEvaluation_Expression(Expression, name);
} // 14.1.21 #sec-function-definitions-runtime-semantics-namedevaluation
//   FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`


function NamedEvaluation_FunctionExpression(FunctionExpression, name) {
  const closure = Evaluate_FunctionExpression(FunctionExpression);

  let _temp = SetFunctionName(closure, name);

  Assert(!(_temp instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  return closure;
} // 14.2.16 #sec-arrow-function-definitions-runtime-semantics-namedevaluation
//   ArrowFunction : ArrowParameters `=>` ConciseBody


function NamedEvaluation_ArrowFunction(ArrowFunction, name) {
  const closure = Evaluate_ArrowFunction(ArrowFunction);

  let _temp2 = SetFunctionName(closure, name);

  Assert(!(_temp2 instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  return closure;
} // 14.4.13 #sec-generator-function-definitions-runtime-semantics-namedevaluation
//   GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`


function NamedEvaluation_GeneratorExpression(GeneratorExpression, name) {
  const closure = Evaluate_GeneratorExpression(GeneratorExpression);

  let _temp3 = SetFunctionName(closure, name);

  Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  return closure;
} // 14.5.13 #sec-asyncgenerator-definitions-namedevaluation
//   AsyncGeneratorExpression :
//     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`


function NamedEvaluation_AsyncGeneratorExpression(AsyncGeneratorExpression, name) {
  const closure = Evaluate_AsyncGeneratorExpression(AsyncGeneratorExpression);

  let _temp4 = SetFunctionName(closure, name);

  Assert(!(_temp4 instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  return closure;
} // 14.6.15 #sec-class-definitions-runtime-semantics-namedevaluation
//   ClassExpression : `class` ClassTail


function* NamedEvaluation_ClassExpression(ClassExpression, name) {
  const {
    body,
    superClass
  } = ClassExpression;
  const ClassTail = {
    ClassHeritage: superClass,
    ClassBody: body.body
  };
  let value = yield* ClassDefinitionEvaluation_ClassTail(ClassTail, Value.undefined, name);

  /* istanbul ignore if */
  if (value instanceof AbruptCompletion) {
    return value;
  }
  /* istanbul ignore if */


  if (value instanceof Completion) {
    value = value.Value;
  }
  value.SourceText = sourceTextMatchedBy(ClassExpression);
  return value;
} // 14.7.13 #sec-async-function-definitions-runtime-semantics-namedevaluation
//   AsyncFunctionExpression :
//     `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`


function NamedEvaluation_AsyncFunctionExpression(AsyncFunctionExpression, name) {
  const closure = Evaluate_AsyncFunctionExpression(AsyncFunctionExpression);

  let _temp5 = SetFunctionName(closure, name);

  Assert(!(_temp5 instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }
  return closure;
} // 14.8.15 #sec-async-arrow-function-definitions-runtime-semantics-namedevaluation
//   AsyncArrowFunction :
//     `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
//     CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody


function NamedEvaluation_AsyncArrowFunction(AsyncArrowFunction, name) {
  const closure = Evaluate_AsyncArrowFunction(AsyncArrowFunction);

  let _temp6 = SetFunctionName(closure, name);

  Assert(!(_temp6 instanceof AbruptCompletion), "SetFunctionName(closure, name)" + ' returned an abrupt completion');

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }
  return closure;
} // (implicit)


function* NamedEvaluation_Expression(Expression, name) {
  switch (true) {
    case isFunctionExpression(Expression):
      return NamedEvaluation_FunctionExpression(Expression, name);

    case isClassExpression(Expression):
      return yield* NamedEvaluation_ClassExpression(Expression, name);

    case isGeneratorExpression(Expression):
      return NamedEvaluation_GeneratorExpression(Expression, name);

    case isAsyncFunctionExpression(Expression):
      return NamedEvaluation_AsyncFunctionExpression(Expression, name);

    case isAsyncGeneratorExpression(Expression):
      return NamedEvaluation_AsyncGeneratorExpression(Expression, name);

    case isArrowFunction(Expression):
      return NamedEvaluation_ArrowFunction(Expression, name);

    case isAsyncArrowFunction(Expression):
      return NamedEvaluation_AsyncArrowFunction(Expression, name);

    case isParenthesizedExpression(Expression):
      return yield* NamedEvaluation_ParenthesizedExpression(Expression, name);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('NamedEvaluation_Expression', Expression);
  }
}

function* EvaluateNew(constructExpr, args = []) {
  Assert(isActualNewExpression(constructExpr), "isActualNewExpression(constructExpr)");
  Assert(Array.isArray(args), "Array.isArray(args)");
  const ref = yield* Evaluate(constructExpr.callee);

  let _temp = GetValue(ref);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const constructor = _temp; // We convert empty to [] as part of the default parameter.

  let _temp2 = yield* ArgumentListEvaluation(args);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const argList = _temp2;

  if (IsConstructor(constructor) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', constructor);
  }

  return Construct(constructor, argList);
} // 12.3.3.1 #sec-new-operator-runtime-semantics-evaluation
//   NewExpression :
//     `new` NewExpression
//     `new` MemberExpression Arguments


function* Evaluate_NewExpression(NewExpression) {
  return yield* EvaluateNew(NewExpression, NewExpression.arguments);
}

function NumberToBigInt(number) {
  Assert(Type(number) === 'Number', "Type(number) === 'Number'");

  if (IsInteger(number) === Value.false) {
    return surroundingAgent.Throw('RangeError', 'CannotConvertDecimalToBigInt', number);
  }

  return new Value(BigInt(number.numberValue()));
}

//   ObjectLiteral :
//     `{` `}`
//     `{` PropertyDefintionList `}`
//     `{` PropertyDefintionList `,` `}`

function* Evaluate_ObjectLiteral(ObjectLiteral) {
  if (ObjectLiteral.properties.length === 0) {
    return ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  }

  const PropertyDefintionList = ObjectLiteral.properties;
  const obj = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  let _temp = yield* PropertyDefinitionEvaluation_PropertyDefinitionList(PropertyDefintionList, obj, true);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  return obj;
}

// OptionalExpression :
//   MemberExpression OptionalChain
//   CallExpression OptionalChain
//   OptionalExpression OptionalChain

function* Evaluate_OptionalExpression({
  object: MemberExpression,
  chain: OptionalChain
}) {
  // 1. Let baseReference be the result of evaluating MemberExpression.
  const baseReference = yield* Evaluate(MemberExpression); // 2. Let baseValue be ? GetValue(baseReference).

  let _temp = GetValue(baseReference);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const baseValue = _temp; // 3. If baseValue is undefined or null, then

  if (baseValue === Value.undefined || baseValue === Value.null) {
    // a. Return undefined.
    return Value.undefined;
  } // Return the result of performing ChainEvaluation of OptionalChain with arguments baseValue and baseReference.


  return yield* ChainEvaluation(OptionalChain, baseValue, baseReference);
} // #sec-optional-chaining-chain-evaluation
// OptionalChain :
//   `?.` `[` Expression `]`
//   `?.` IdentifierName
//   `?.` Arguments
//   OptionalChain `[` Expression `]`
//   OptionalChain `.` IdentifierName
//   OptionalChain Arguments

function* ChainEvaluation(OptionalChain, baseValue, baseReference) {
  const strict = OptionalChain.strict;

  if (isOptionalChainWithOptionalChain(OptionalChain)) {
    Assert(isOptionalChain(OptionalChain.base), "isOptionalChain(OptionalChain.base)");
    const newReference = yield* ChainEvaluation(OptionalChain.base, baseValue, baseReference);

    let _temp2 = GetValue(newReference);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const newValue = _temp2;

    switch (true) {
      // OptionalChain : OptionalChain `?.` `[` Expression `]`
      case isOptionalChainWithExpression(OptionalChain):
        return yield* EvaluatePropertyAccessWithExpressionKey(newValue, OptionalChain.property, strict);
      // OptionalChain : OptionalChain `?.` IdentifierName

      case isOptionalChainWithIdentifierName(OptionalChain):
        return EvaluatePropertyAccessWithIdentifierKey(newValue, OptionalChain.property, strict);
      // OptionalChain : OptionalChain `?.` Arguments

      case isOptionalChainWithArguments(OptionalChain):
        {
          return yield* EvaluateCall(newValue, newReference, OptionalChain.arguments);
        }

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('ChainEvaluation', OptionalChain);
    }
  }

  switch (true) {
    // OptionalChain : `?.` `[` Expression `]`
    case isOptionalChainWithExpression(OptionalChain):
      return yield* EvaluatePropertyAccessWithExpressionKey(baseValue, OptionalChain.property, strict);
    // OptionalChain : `?.` IdentifierName

    case isOptionalChainWithIdentifierName(OptionalChain):
      return EvaluatePropertyAccessWithIdentifierKey(baseValue, OptionalChain.property, strict);
    // OptionalChain : `?.` Arguments

    case isOptionalChainWithArguments(OptionalChain):
      {
        return yield* EvaluateCall(baseValue, baseReference, OptionalChain.arguments);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ChainEvaluation', OptionalChain);
  }
}

//   BindingPropertyList : BindingPropertyList `,` BindingProperty
//
// (implicit)
//   BindingPropertyList : BindingProperty

function* PropertyBindingInitialization_BindingPropertyList(BindingPropertyList, value, environment) {
  const boundNames = [];

  for (const BindingProperty of BindingPropertyList) {
    let _temp = yield* PropertyBindingInitialization_BindingProperty(BindingProperty, value, environment);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const nextNames = _temp;
    boundNames.push(...nextNames);
  }

  return boundNames;
} // 13.3.3.6 #sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization
//   BindingProperty :
//     SingleNameBinding
//     PropertyName `:` BindingElement

function* PropertyBindingInitialization_BindingProperty(BindingProperty, value, environment) {
  switch (true) {
    case isBindingPropertyWithSingleNameBinding(BindingProperty):
      {
        const name = new Value(BindingProperty.key.name);

        let _temp2 = yield* KeyedBindingInitialization_SingleNameBinding(BindingProperty.value, value, environment, name);

        if (_temp2 instanceof AbruptCompletion) {
          return _temp2;
        }

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }
        return [name];
      }

    case isBindingPropertyWithColon(BindingProperty):
      {
        const {
          key: PropertyName,
          value: BindingElement
        } = BindingProperty;
        let P = yield* Evaluate_PropertyName(PropertyName, BindingProperty.computed);

        /* istanbul ignore if */
        if (P instanceof AbruptCompletion) {
          return P;
        }
        /* istanbul ignore if */


        if (P instanceof Completion) {
          P = P.Value;
        }

        let _temp3 = yield* KeyedBindingInitialization_BindingElement(BindingElement, value, environment, P);

        if (_temp3 instanceof AbruptCompletion) {
          return _temp3;
        }

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }
        return [P];
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('PropertyBindingInitialization_BindingProperty', BindingProperty);
  }
}

function hasNonConfigurableProperties(obj) {
  for (const desc of obj.properties.values()) {
    if (desc.Configurable === Value.false) {
      return true;
    }
  }

  return false;
} // 12.2.6.8 #sec-object-initializer-runtime-semantics-propertydefinitionevaluation
//   PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition
//
// (implicit)
//   PropertyDefinitionList : PropertyDefinition


function* PropertyDefinitionEvaluation_PropertyDefinitionList(PropertyDefinitionList, object, enumerable) {
  Assert(PropertyDefinitionList.length > 0, "PropertyDefinitionList.length > 0");
  let lastReturn;

  for (const PropertyDefinition of PropertyDefinitionList) {
    let _temp = yield* PropertyDefinitionEvaluation_PropertyDefinition(PropertyDefinition, object, enumerable);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    lastReturn = _temp;
  }

  return lastReturn;
} // 12.2.6.8 #sec-object-initializer-runtime-semantics-propertydefinitionevaluation
//   PropertyDefinition : `...` AssignmentExpression

function* PropertyDefinitionEvaluation_PropertyDefinition_Spread(PropertyDefinition, object) {
  const AssignmentExpression = PropertyDefinition.argument;
  const exprValue = yield* Evaluate(AssignmentExpression);

  let _temp2 = GetValue(exprValue);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const fromValue = _temp2;
  const excludedNames = [];
  return CopyDataProperties(object, fromValue, excludedNames);
} // 12.2.6.8 #sec-object-initializer-runtime-semantics-propertydefinitionevaluation
//   PropertyDefinition : IdentifierReference


function* PropertyDefinitionEvaluation_PropertyDefinition_IdentifierReference(PropertyDefinition, object, enumerable) {
  const IdentifierReference = PropertyDefinition.key;
  const propName = new Value(IdentifierReference.name);
  const exprValue = yield* Evaluate(IdentifierReference);

  let _temp3 = GetValue(exprValue);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const propValue = _temp3;
  Assert(enumerable, "enumerable");
  Assert(object.isOrdinary, "object.isOrdinary");
  Assert(object.Extensible === Value.true, "object.Extensible === Value.true");
  Assert(!hasNonConfigurableProperties(object), "!hasNonConfigurableProperties(object)");

  let _temp4 = CreateDataPropertyOrThrow(object, propName, propValue);

  Assert(!(_temp4 instanceof AbruptCompletion), "CreateDataPropertyOrThrow(object, propName, propValue)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  return _temp4;
} // 12.2.6.8 #sec-object-initializer-runtime-semantics-propertydefinitionevaluation
//   PropertyDefinition : PropertyName `:` AssignmentExpression


function* PropertyDefinitionEvaluation_PropertyDefinition_KeyValue(PropertyDefinition, object, enumerable) {
  const {
    key: PropertyName,
    value: AssignmentExpression
  } = PropertyDefinition;
  let propKey = yield* Evaluate_PropertyName(PropertyName, PropertyDefinition.computed);

  /* istanbul ignore if */
  if (propKey instanceof AbruptCompletion) {
    return propKey;
  }
  /* istanbul ignore if */


  if (propKey instanceof Completion) {
    propKey = propKey.Value;
  }
  let propValue;

  if (IsAnonymousFunctionDefinition(AssignmentExpression)) {
    propValue = yield* NamedEvaluation_Expression(AssignmentExpression, propKey);

    if (propValue instanceof AbruptCompletion) {
      return propValue;
    }

    if (propValue instanceof Completion) {
      propValue = propValue.Value;
    }
  } else {
    const exprValueRef = yield* Evaluate(AssignmentExpression);

    let _temp5 = GetValue(exprValueRef);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    propValue = _temp5;
  }

  Assert(enumerable, "enumerable");
  Assert(object.isOrdinary, "object.isOrdinary");
  Assert(object.Extensible === Value.true, "object.Extensible === Value.true");
  Assert(!hasNonConfigurableProperties(object), "!hasNonConfigurableProperties(object)");

  let _temp6 = CreateDataPropertyOrThrow(object, propKey, propValue);

  Assert(!(_temp6 instanceof AbruptCompletion), "CreateDataPropertyOrThrow(object, propKey, propValue)" + ' returned an abrupt completion');

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  return _temp6;
} // 14.3.8 #sec-method-definitions-runtime-semantics-propertydefinitionevaluation
//   MethodDefinition :
//     PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
//     `get` PropertyName `(` `)` `{` FunctionBody `}`
//     `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`
//
// (implicit)
//   MethodDefinition : GeneratorMethod


function* PropertyDefinitionEvaluation_MethodDefinition(MethodDefinition, object, enumerable) {
  switch (true) {
    case isMethodDefinitionRegularFunction(MethodDefinition):
      {
        let _temp7 = yield* DefineMethod(MethodDefinition, object);

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        const methodDef = _temp7;

        let _temp8 = SetFunctionName(methodDef.Closure, methodDef.Key);

        Assert(!(_temp8 instanceof AbruptCompletion), "SetFunctionName(methodDef.Closure, methodDef.Key)" + ' returned an abrupt completion');

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }
        const desc = Descriptor({
          Value: methodDef.Closure,
          Writable: Value.true,
          Enumerable: enumerable ? Value.true : Value.false,
          Configurable: Value.true
        });
        return DefinePropertyOrThrow(object, methodDef.Key, desc);
      }

    case isGeneratorMethod(MethodDefinition):
      return yield* PropertyDefinitionEvaluation_GeneratorMethod(MethodDefinition, object, enumerable);

    case isAsyncMethod(MethodDefinition):
      return yield* PropertyDefinitionEvaluation_AsyncMethod(MethodDefinition, object, enumerable);

    case isAsyncGeneratorMethod(MethodDefinition):
      return yield* PropertyDefinitionEvaluation_AsyncGeneratorMethod(MethodDefinition, object, enumerable);

    case isMethodDefinitionGetter(MethodDefinition):
      {
        const PropertyName = MethodDefinition.key;
        let propKey = yield* Evaluate_PropertyName(PropertyName, MethodDefinition.computed);

        if (propKey instanceof AbruptCompletion) {
          return propKey;
        }

        if (propKey instanceof Completion) {
          propKey = propKey.Value;
        }
        const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
        const formalParameterList = [];

        let _temp9 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), formalParameterList, MethodDefinition.value, 'non-lexical-this', scope);

        Assert(!(_temp9 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), formalParameterList, MethodDefinition.value, 'non-lexical-this', scope)" + ' returned an abrupt completion');

        if (_temp9 instanceof Completion) {
          _temp9 = _temp9.Value;
        }

        const closure = _temp9;

        let _temp10 = MakeMethod(closure, object);

        Assert(!(_temp10 instanceof AbruptCompletion), "MakeMethod(closure, object)" + ' returned an abrupt completion');

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }

        let _temp11 = SetFunctionName(closure, propKey, new Value('get'));

        Assert(!(_temp11 instanceof AbruptCompletion), "SetFunctionName(closure, propKey, new Value('get'))" + ' returned an abrupt completion');

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }
        closure.SourceText = sourceTextMatchedBy(MethodDefinition);
        const desc = Descriptor({
          Get: closure,
          Enumerable: enumerable ? Value.true : Value.false,
          Configurable: Value.true
        });
        return DefinePropertyOrThrow(object, propKey, desc);
      }

    case isMethodDefinitionSetter(MethodDefinition):
      {
        const PropertyName = MethodDefinition.key;
        const PropertySetParameterList = MethodDefinition.value.params;
        let propKey = yield* Evaluate_PropertyName(PropertyName, MethodDefinition.computed);

        if (propKey instanceof AbruptCompletion) {
          return propKey;
        }

        if (propKey instanceof Completion) {
          propKey = propKey.Value;
        }
        const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;

        let _temp12 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), PropertySetParameterList, MethodDefinition.value, 'non-lexical-this', scope);

        Assert(!(_temp12 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), PropertySetParameterList, MethodDefinition.value, 'non-lexical-this', scope)" + ' returned an abrupt completion');

        if (_temp12 instanceof Completion) {
          _temp12 = _temp12.Value;
        }

        const closure = _temp12;

        let _temp13 = MakeMethod(closure, object);

        Assert(!(_temp13 instanceof AbruptCompletion), "MakeMethod(closure, object)" + ' returned an abrupt completion');

        if (_temp13 instanceof Completion) {
          _temp13 = _temp13.Value;
        }

        let _temp14 = SetFunctionName(closure, propKey, new Value('set'));

        Assert(!(_temp14 instanceof AbruptCompletion), "SetFunctionName(closure, propKey, new Value('set'))" + ' returned an abrupt completion');

        if (_temp14 instanceof Completion) {
          _temp14 = _temp14.Value;
        }
        closure.SourceText = sourceTextMatchedBy(MethodDefinition);
        const desc = Descriptor({
          Set: closure,
          Enumerable: enumerable ? Value.true : Value.false,
          Configurable: Value.true
        });
        return DefinePropertyOrThrow(object, propKey, desc);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('PropertyDefinitionEvaluation_MethodDefinition', MethodDefinition);
  }
} // (implicit)
//   ClassElement :
//     MethodDefinition
//     `static` MethodDefinition

const PropertyDefinitionEvaluation_ClassElement = PropertyDefinitionEvaluation_MethodDefinition; // 14.4.12 #sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation
//   GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

function* PropertyDefinitionEvaluation_GeneratorMethod(GeneratorMethod, object, enumerable) {
  const {
    key: PropertyName,
    value: GeneratorExpression
  } = GeneratorMethod;
  const UniqueFormalParameters = GeneratorExpression.params;
  let propKey = yield* Evaluate_PropertyName(PropertyName, GeneratorMethod.computed);

  if (propKey instanceof AbruptCompletion) {
    return propKey;
  }

  if (propKey instanceof Completion) {
    propKey = propKey.Value;
  }
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;

  let _temp15 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Generator%'), UniqueFormalParameters, GeneratorExpression, 'non-lexical-this', scope);

  Assert(!(_temp15 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Generator%'), UniqueFormalParameters, GeneratorExpression, 'non-lexical-this', scope)" + ' returned an abrupt completion');

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const closure = _temp15;
  MakeMethod(closure, object);
  const prototype = ObjectCreate(surroundingAgent.intrinsic('%Generator.prototype%'));

  let _temp16 = DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp16 instanceof AbruptCompletion), "DefinePropertyOrThrow(\n    closure,\n    new Value('prototype'),\n    Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    }),\n  )" + ' returned an abrupt completion');

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }

  let _temp17 = SetFunctionName(closure, propKey);

  Assert(!(_temp17 instanceof AbruptCompletion), "SetFunctionName(closure, propKey)" + ' returned an abrupt completion');

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }
  closure.SourceText = sourceTextMatchedBy(GeneratorExpression);
  const desc = Descriptor({
    Value: closure,
    Writable: Value.true,
    Enumerable: enumerable ? Value.true : Value.false,
    Configurable: Value.true
  });
  return DefinePropertyOrThrow(object, propKey, desc);
} // AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`


function* PropertyDefinitionEvaluation_AsyncMethod(AsyncMethod, object, enumerable) {
  const {
    key: PropertyName,
    value: AsyncExpression
  } = AsyncMethod;
  const UniqueFormalParameters = AsyncExpression.params;
  let propKey = yield* Evaluate_PropertyName(PropertyName, AsyncMethod.computed);

  if (propKey instanceof AbruptCompletion) {
    return propKey;
  }

  if (propKey instanceof Completion) {
    propKey = propKey.Value;
  }
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;

  let _temp18 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), UniqueFormalParameters, AsyncExpression, 'non-lexical-this', scope);

  Assert(!(_temp18 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), UniqueFormalParameters, AsyncExpression, 'non-lexical-this', scope)" + ' returned an abrupt completion');

  if (_temp18 instanceof Completion) {
    _temp18 = _temp18.Value;
  }

  const closure = _temp18;

  let _temp19 = MakeMethod(closure, object);

  Assert(!(_temp19 instanceof AbruptCompletion), "MakeMethod(closure, object)" + ' returned an abrupt completion');

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  let _temp20 = SetFunctionName(closure, propKey);

  Assert(!(_temp20 instanceof AbruptCompletion), "SetFunctionName(closure, propKey)" + ' returned an abrupt completion');

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }
  closure.SourceText = sourceTextMatchedBy(AsyncMethod);
  const desc = Descriptor({
    Value: closure,
    Writable: Value.true,
    Enumerable: enumerable ? Value.true : Value.false,
    Configurable: Value.true
  });
  return DefinePropertyOrThrow(object, propKey, desc);
} // AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorFunctionBody `}`


function* PropertyDefinitionEvaluation_AsyncGeneratorMethod(AsyncGeneratorMethod, object, enumerable) {
  const {
    key: PropertyName,
    value: AsyncGeneratorExpression
  } = AsyncGeneratorMethod;
  const UniqueFormalParameters = AsyncGeneratorExpression.params;
  let propKey = yield* Evaluate_PropertyName(PropertyName, AsyncGeneratorMethod.computed);

  if (propKey instanceof AbruptCompletion) {
    return propKey;
  }

  if (propKey instanceof Completion) {
    propKey = propKey.Value;
  }
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;

  let _temp21 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), UniqueFormalParameters, AsyncGeneratorExpression, 'non-lexical-this', scope);

  Assert(!(_temp21 instanceof AbruptCompletion), "OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), UniqueFormalParameters, AsyncGeneratorExpression, 'non-lexical-this', scope)" + ' returned an abrupt completion');

  if (_temp21 instanceof Completion) {
    _temp21 = _temp21.Value;
  }

  const closure = _temp21;

  let _temp22 = MakeMethod(closure, object);

  Assert(!(_temp22 instanceof AbruptCompletion), "MakeMethod(closure, object)" + ' returned an abrupt completion');

  if (_temp22 instanceof Completion) {
    _temp22 = _temp22.Value;
  }

  let _temp23 = ObjectCreate(surroundingAgent.intrinsic('%AsyncGenerator.prototype%'));

  Assert(!(_temp23 instanceof AbruptCompletion), "ObjectCreate(surroundingAgent.intrinsic('%AsyncGenerator.prototype%'))" + ' returned an abrupt completion');

  if (_temp23 instanceof Completion) {
    _temp23 = _temp23.Value;
  }

  const prototype = _temp23;

  let _temp24 = DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp24 instanceof AbruptCompletion), "DefinePropertyOrThrow(closure, new Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  let _temp25 = SetFunctionName(closure, propKey);

  Assert(!(_temp25 instanceof AbruptCompletion), "SetFunctionName(closure, propKey)" + ' returned an abrupt completion');

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }
  closure.SourceText = sourceTextMatchedBy(AsyncGeneratorMethod);
  const desc = Descriptor({
    Value: closure,
    Writable: Value.true,
    Enumerable: enumerable ? Value.true : Value.false,
    Configurable: Value.true
  });
  return DefinePropertyOrThrow(object, propKey, desc);
} // (implicit)
//   PropertyDefinition : MethodDefinition
//
// Note: PropertyDefinition : CoverInitializedName is an early error.


function* PropertyDefinitionEvaluation_PropertyDefinition(PropertyDefinition, object, enumerable) {
  switch (true) {
    case isPropertyDefinitionIdentifierReference(PropertyDefinition):
      return yield* PropertyDefinitionEvaluation_PropertyDefinition_IdentifierReference(PropertyDefinition, object, enumerable);

    case isPropertyDefinitionKeyValue(PropertyDefinition):
      return yield* PropertyDefinitionEvaluation_PropertyDefinition_KeyValue(PropertyDefinition, object, enumerable);

    case isMethodDefinition(PropertyDefinition):
      return yield* PropertyDefinitionEvaluation_MethodDefinition(PropertyDefinition, object, enumerable);

    case isPropertyDefinitionSpread(PropertyDefinition):
      return yield* PropertyDefinitionEvaluation_PropertyDefinition_Spread(PropertyDefinition, object);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('PropertyDefinitionEvaluation_PropertyDefinition', PropertyDefinition);
  }
}

//   LiteralPropertyName :
//     IdentifierName
//     StringLiteral
//     NumericLiteral

function Evaluate_LiteralPropertyName(LiteralPropertyName) {
  switch (true) {
    case isIdentifierName(LiteralPropertyName):
      return new Value(LiteralPropertyName.name);

    case isStringLiteral(LiteralPropertyName):
      return new Value(LiteralPropertyName.value);

    case isNumericLiteral(LiteralPropertyName):
      {
        const nbr = new Value(LiteralPropertyName.value);

        let _temp = ToString(nbr);

        Assert(!(_temp instanceof AbruptCompletion), "ToString(nbr)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }

        return _temp;
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_LiteralPropertyName', LiteralPropertyName);
  }
} // 12.2.6.7 #sec-object-initializer-runtime-semantics-evaluation
//   ComputedPropertyName : `[` AssignmentExpression `]`


function* Evaluate_ComputedPropertyName(ComputedPropertyName) {
  const AssignmentExpression = ComputedPropertyName;
  const exprValue = yield* Evaluate(AssignmentExpression);

  let _temp2 = GetValue(exprValue);
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const propName = _temp2;
  return ToPropertyKey(propName);
} // 12.2.6.7 #sec-object-initializer-runtime-semantics-evaluation
//   PropertyName :
//     LiteralPropertyName
//     ComputedPropertyName
//
// Note: We need some out-of-band information on whether the PropertyName is
// computed.


function* Evaluate_PropertyName(PropertyName, computed) {
  return computed ? yield* Evaluate_ComputedPropertyName(PropertyName) : Evaluate_LiteralPropertyName(PropertyName);
}

// (implicit)
//   PrimaryExpression : RegularExpressionLiteral

function Evaluate_RegularExpressionLiteral(RegularExpressionLiteral) {
  const pattern = new Value(RegularExpressionLiteral.regex.pattern);
  const flags = new Value(RegularExpressionLiteral.regex.flags);
  return RegExpCreate(pattern, flags);
}

function InstanceofOperator(V, target) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  let _temp = GetMethod(target, wellKnownSymbols.hasInstance);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const instOfHandler = _temp;

  if (Type(instOfHandler) !== 'Undefined') {
    let _temp2 = Call(instOfHandler, target, [V]);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    return ToBoolean(_temp2);
  }

  if (IsCallable(target) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', target);
  }

  return OrdinaryHasInstance(target, V);
}
function* Evaluate_RelationalExpression({
  left: RelationalExpression,
  right: ShiftExpression,
  operator
}) {
  const lref = yield* Evaluate(RelationalExpression);

  let _temp3 = GetValue(lref);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const lval = _temp3;
  const rref = yield* Evaluate(ShiftExpression);

  let _temp4 = GetValue(rref);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const rval = _temp4;

  switch (operator) {
    case '<':
      {
        let r = AbstractRelationalComparison(lval, rval);

        /* istanbul ignore if */
        if (r instanceof AbruptCompletion) {
          return r;
        }
        /* istanbul ignore if */


        if (r instanceof Completion) {
          r = r.Value;
        }

        if (Type(r) === 'Undefined') {
          return Value.false;
        }

        return r;
      }

    case '>':
      {
        let r = AbstractRelationalComparison(rval, lval, false);

        if (r instanceof AbruptCompletion) {
          return r;
        }

        if (r instanceof Completion) {
          r = r.Value;
        }

        if (Type(r) === 'Undefined') {
          return Value.false;
        }

        return r;
      }

    case '<=':
      {
        let r = AbstractRelationalComparison(rval, lval, false);

        if (r instanceof AbruptCompletion) {
          return r;
        }

        if (r instanceof Completion) {
          r = r.Value;
        }

        if (Type(r) === 'Undefined' || r === Value.true) {
          return Value.false;
        }

        return Value.true;
      }

    case '>=':
      {
        let r = AbstractRelationalComparison(lval, rval);

        if (r instanceof AbruptCompletion) {
          return r;
        }

        if (r instanceof Completion) {
          r = r.Value;
        }

        if (Type(r) === 'Undefined' || r === Value.true) {
          return Value.false;
        }

        return Value.true;
      }

    case 'instanceof':
      return InstanceofOperator(lval, rval);

    case 'in':
      if (Type(rval) !== 'Object') {
        return surroundingAgent.Throw('TypeError', 'NotAnObject', rval);
      }

      return HasProperty(rval, ToPropertyKey(lval));

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_RelationalExpression', operator);
  }
}

//   BindingRestProperty : `...` BindingIdentifier

function RestBindingInitialization_BindingRestProperty(BindingRestProperty, value, environment, excludedNames) {
  const BindingIdentifier = BindingRestProperty.argument;

  let _temp = ResolveBinding(new Value(BindingIdentifier.name), environment, BindingIdentifier.strict);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lhs = _temp;
  const restObj = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  let _temp2 = CopyDataProperties(restObj, value, excludedNames);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  if (Type(environment) === 'Undefined') {
    return PutValue(lhs, restObj);
  }

  return InitializeReferencedBinding(lhs, restObj);
}

function* Evaluate_ReturnStatement({
  argument: Expression
}) {
  if (Expression === null) {
    // ReturnStatement : return `;`
    return new ReturnCompletion(Value.undefined);
  } else {
    // ReturnStatement : return Expression `;`
    const exprRef = yield* Evaluate(Expression);

    let _temp = GetValue(exprRef);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    let exprValue = _temp;

    let _temp2 = GetGeneratorKind();

    Assert(!(_temp2 instanceof AbruptCompletion), "GetGeneratorKind()" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    if (_temp2 === 'async') {
      let _temp3 = yield* Await(exprValue);

      if (_temp3 instanceof AbruptCompletion) {
        return _temp3;
      }

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      exprValue = _temp3;
    }

    return new ReturnCompletion(exprValue);
  }
}

/* eslint-disable no-bitwise */

function EvaluateBinopValues_ShiftExpression(operator, lval, rval) {
  let _temp = ToNumeric(lval);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const lnum = _temp;

  let _temp2 = ToNumeric(rval);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const rnum = _temp2;

  if (Type(lnum) !== Type(rnum)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }

  const T = TypeNumeric(lnum);

  switch (operator) {
    case '<<':
      return T.leftShift(lnum, rnum);

    case '>>':
      return T.signedRightShift(lnum, rnum);

    case '>>>':
      return T.unsignedRightShift(lnum, rnum);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('EvaluateBinopValues_ShiftExpression', operator);
  }
} // ShiftExpression :
//   ShiftExpression << AdditiveExpression
//   ShiftExpression >> AdditiveExpression
//   ShiftExpression >>> AdditiveExpression

function* Evaluate_ShiftExpression({
  left: ShiftExpression,
  operator,
  right: AdditiveExpression
}) {
  const lref = yield* Evaluate(ShiftExpression);

  let _temp3 = GetValue(lref);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const lval = _temp3;
  const rref = yield* Evaluate(AdditiveExpression);

  let _temp4 = GetValue(rref);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const rval = _temp4;
  return EvaluateBinopValues_ShiftExpression(operator, lval, rval);
}

function StringPad(O, maxLength, fillString, placement) {
  Assert(placement === 'start' || placement === 'end', "placement === 'start' || placement === 'end'");

  let _temp = ToString(O);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const S = _temp;

  let _temp2 = ToLength(maxLength);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const intMaxLength = _temp2.numberValue();

  const stringLength = S.stringValue().length;

  if (intMaxLength <= stringLength) {
    return S;
  }

  let filler;

  if (fillString === Value.undefined) {
    filler = ' ';
  } else {
    let _temp3 = ToString(fillString);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    filler = _temp3.stringValue();
  }

  if (filler === '') {
    return S;
  }

  const fillLen = intMaxLength - stringLength;
  const stringFiller = filler.repeat(Math.ceil(fillLen / filler.length));
  const truncatedStringFiller = stringFiller.slice(0, fillLen);

  if (placement === 'start') {
    return new Value(truncatedStringFiller + S.stringValue());
  } else {
    return new Value(S.stringValue() + truncatedStringFiller);
  }
}

function GetSuperConstructor() {
  const envRec = GetThisEnvironment();
  Assert(envRec instanceof FunctionEnvironmentRecord, "envRec instanceof FunctionEnvironmentRecord");
  const activeFunction = envRec.FunctionObject;
  Assert(activeFunction instanceof FunctionValue, "activeFunction instanceof FunctionValue");

  let _temp = activeFunction.GetPrototypeOf();

  Assert(!(_temp instanceof AbruptCompletion), "activeFunction.GetPrototypeOf()" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const superConstructor = _temp;

  if (IsConstructor(superConstructor) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', superConstructor);
  }

  return superConstructor;
} // 12.3.5.1 #sec-super-keyword-runtime-semantics-evaluation
// SuperCall : `super` Arguments


function* Evaluate_SuperCall({
  arguments: Arguments
}) {
  const newTarget = GetNewTarget();
  Assert(Type(newTarget) === 'Object', "Type(newTarget) === 'Object'");

  let _temp2 = GetSuperConstructor();
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const func = _temp2;

  let _temp3 = yield* ArgumentListEvaluation(Arguments);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const argList = _temp3;

  let _temp4 = Construct(func, argList, newTarget);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const result = _temp4;
  const thisER = GetThisEnvironment();
  return thisER.BindThisValue(result);
}

function MakeSuperPropertyReference(actualThis, propertyKey, strict) {
  const env = GetThisEnvironment();
  Assert(env.HasSuperBinding() === Value.true, "env.HasSuperBinding() === Value.true");

  let _temp = env.GetSuperBase();
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const baseValue = _temp;

  let _temp2 = RequireObjectCoercible(baseValue);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const bv = _temp2;
  return new SuperReference({
    BaseValue: bv,
    ReferencedName: propertyKey,
    thisValue: actualThis,
    StrictReference: strict ? Value.true : Value.false
  });
} // 12.3.5.1 #sec-super-keyword-runtime-semantics-evaluation
// SuperProperty :
//   `super` `[` Expression `]`
//   `super` `.` IdentifierName


function* Evaluate_SuperProperty(SuperProperty) {
  if (SuperProperty.computed) {
    const Expression = SuperProperty.property;
    const env = GetThisEnvironment();

    let _temp3 = env.GetThisBinding();

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const actualThis = _temp3;
    const propertyNameReference = yield* Evaluate(Expression);

    let _temp4 = GetValue(propertyNameReference);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const propertyNameValue = _temp4;

    let _temp5 = ToPropertyKey(propertyNameValue);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const propertyKey = _temp5;
    const strict = SuperProperty.strict;
    return MakeSuperPropertyReference(actualThis, propertyKey, strict);
  } else {
    const IdentifierName = SuperProperty.property;
    const env = GetThisEnvironment();

    let _temp6 = env.GetThisBinding();

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    const actualThis = _temp6;
    const propertyKey = new Value(IdentifierName.name);
    const strict = SuperProperty.strict;
    return MakeSuperPropertyReference(actualThis, propertyKey, strict);
  }
}

function* CaseClauseIsSelected(C, input) {
  // Assert: C is an instance of the production CaseClause : `case` Expression : StatementList.
  const exprRef = yield* Evaluate(C.test);

  let _temp = GetValue(exprRef);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const clauseSelector = _temp;
  return StrictEqualityComparison(input, clauseSelector);
} // 13.12.9 #sec-runtime-semantics-caseblockevaluation
// CaseBlock :
//   `{` `}`
//   `{` CaseClauses `}`
//   `{` CaseClauses DefaultClause CaseClauses `}`


function* CaseBlockEvaluation(CaseBlock, input) {
  if (CaseBlock.length === 0) {
    return new NormalCompletion(Value.undefined);
  }

  const defaultIndex = CaseBlock.findIndex(c => c.test === null);

  if (defaultIndex !== -1) {
    // CaseBlock : `{` CaseClauses DefaultClause CaseClauses `}`
    const firstCaseClauses = CaseBlock.slice(0, defaultIndex);
    const secondCaseClauses = CaseBlock.slice(defaultIndex + 1);
    const DefaultClause = CaseBlock[defaultIndex];
    let V = Value.undefined;
    let A;

    if (firstCaseClauses.length > 0) {
      A = firstCaseClauses;
    } else {
      A = [];
    }

    let found = false;

    for (const C of A) {
      if (found === false) {
        let _temp2 = yield* CaseClauseIsSelected(C, input);

        if (_temp2 instanceof AbruptCompletion) {
          return _temp2;
        }

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }

        found = _temp2 === Value.true;
      }

      if (found === true) {
        const R = EnsureCompletion((yield* Evaluate_StatementList(C.consequent)));

        if (R.Value !== undefined) {
          V = R.Value;
        }

        if (R instanceof AbruptCompletion) {
          return Completion(UpdateEmpty(R, V));
        }
      }
    }

    let foundInB = false;
    let B;

    if (secondCaseClauses.length > 0) {
      B = secondCaseClauses;
    } else {
      B = [];
    }

    if (found === false) {
      for (const C of B) {
        if (foundInB === false) {
          let _temp3 = yield* CaseClauseIsSelected(C, input);

          if (_temp3 instanceof AbruptCompletion) {
            return _temp3;
          }

          if (_temp3 instanceof Completion) {
            _temp3 = _temp3.Value;
          }

          foundInB = _temp3 === Value.true;
        }

        if (foundInB === true) {
          const R = EnsureCompletion((yield* Evaluate_StatementList(C.consequent)));

          if (R.Value !== undefined) {
            V = R.Value;
          }

          if (R instanceof AbruptCompletion) {
            return Completion(UpdateEmpty(R, V));
          }
        }
      }
    }

    if (foundInB === true) {
      return new NormalCompletion(V);
    }

    const R = EnsureCompletion((yield* Evaluate_StatementList(DefaultClause.consequent)));

    if (R.Value !== undefined) {
      V = R.Value;
    }

    if (R instanceof AbruptCompletion) {
      return Completion(UpdateEmpty(R, V));
    }

    for (const C of B) {
      const R = EnsureCompletion((yield* Evaluate_StatementList(C.consequent))); // eslint-disable-line no-shadow

      if (R.Value !== undefined) {
        V = R.Value;
      }

      if (R instanceof AbruptCompletion) {
        return Completion(UpdateEmpty(R, V));
      }
    }

    return new NormalCompletion(V);
  } else {
    // CaseBlock : `{` CaseClauses `}`
    let V = Value.undefined; // Let A be the List of CaseClause items in CaseClauses, in source text order.

    const A = CaseBlock;
    let found = false;

    for (const C of A) {
      if (found === false) {
        let _temp4 = yield* CaseClauseIsSelected(C, input);

        if (_temp4 instanceof AbruptCompletion) {
          return _temp4;
        }

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }

        found = _temp4 === Value.true;
      }

      if (found === true) {
        const R = EnsureCompletion((yield* Evaluate_StatementList(C.consequent)));

        if (R.Value !== undefined) {
          V = R.Value;
        }

        if (R instanceof AbruptCompletion) {
          return Completion(UpdateEmpty(R, V));
        }
      }
    }

    return new NormalCompletion(V);
  }
} // 13.12.11 #sec-switch-statement-runtime-semantics-evaluation
// SwitchStatement : `switch` `(` Expression `)` CaseBlock


function* Evaluate_SwitchStatement({
  discriminant: Expression,
  cases: CaseBlock
}) {
  const exprRef = yield* Evaluate(Expression);

  let _temp5 = GetValue(exprRef);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const switchValue = _temp5;
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const blockEnv = NewDeclarativeEnvironment(oldEnv);
  BlockDeclarationInstantiation(CaseBlock, blockEnv);
  surroundingAgent.runningExecutionContext.LexicalEnvironment = blockEnv;
  const R = yield* CaseBlockEvaluation(CaseBlock, switchValue);
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  return R;
}

function GetTemplateObject(templateLiteral) {
  const rawStrings = TemplateStrings_TemplateLiteral(templateLiteral, true).map(Value);
  const realm = surroundingAgent.currentRealmRecord;
  const templateRegistry = realm.TemplateMap;

  for (const e of templateRegistry) {
    if (e.Site === templateLiteral) {
      return e.Array;
    }
  }

  const cookedStrings = TemplateStrings_TemplateLiteral(templateLiteral, false).map(v => v === undefined ? Value.undefined : new Value(v));
  const count = cookedStrings.length;
  Assert(count < 2 ** 32 - 1, "count < (2 ** 32) - 1");

  let _temp = ArrayCreate(new Value(count));

  Assert(!(_temp instanceof AbruptCompletion), "ArrayCreate(new Value(count))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const template = _temp;

  let _temp2 = ArrayCreate(new Value(count));

  Assert(!(_temp2 instanceof AbruptCompletion), "ArrayCreate(new Value(count))" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const rawObj = _temp2;
  let index = 0;

  while (index < count) {
    let _temp3 = ToString(new Value(index));

    Assert(!(_temp3 instanceof AbruptCompletion), "ToString(new Value(index))" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const prop = _temp3;
    const cookedValue = cookedStrings[index];

    let _temp4 = template.DefineOwnProperty(prop, Descriptor({
      Value: cookedValue,
      Writable: Value.false,
      Enumerable: Value.true,
      Configurable: Value.false
    }));

    Assert(!(_temp4 instanceof AbruptCompletion), "template.DefineOwnProperty(prop, Descriptor({\n      Value: cookedValue,\n      Writable: Value.false,\n      Enumerable: Value.true,\n      Configurable: Value.false,\n    }))" + ' returned an abrupt completion');

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }
    const rawValue = rawStrings[index];

    let _temp5 = rawObj.DefineOwnProperty(prop, Descriptor({
      Value: rawValue,
      Writable: Value.false,
      Enumerable: Value.true,
      Configurable: Value.false
    }));

    Assert(!(_temp5 instanceof AbruptCompletion), "rawObj.DefineOwnProperty(prop, Descriptor({\n      Value: rawValue,\n      Writable: Value.false,\n      Enumerable: Value.true,\n      Configurable: Value.false,\n    }))" + ' returned an abrupt completion');

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }
    index += 1;
  }

  let _temp6 = SetIntegrityLevel(rawObj, 'frozen');

  Assert(!(_temp6 instanceof AbruptCompletion), "SetIntegrityLevel(rawObj, 'frozen')" + ' returned an abrupt completion');

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  let _temp7 = template.DefineOwnProperty(new Value('raw'), Descriptor({
    Value: rawObj,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp7 instanceof AbruptCompletion), "template.DefineOwnProperty(new Value('raw'), Descriptor({\n    Value: rawObj,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  let _temp8 = SetIntegrityLevel(template, 'frozen');

  Assert(!(_temp8 instanceof AbruptCompletion), "SetIntegrityLevel(template, 'frozen')" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }
  templateRegistry.push({
    Site: templateLiteral,
    Array: template
  });
  return template;
} // 12.3.8.1 #sec-tagged-templates-runtime-semantics-evaluation

function* Evaluate_TaggedTemplate({
  tag: Expression,
  quasi: TemplateLiteral
}) {
  const tagRef = yield* Evaluate(Expression);

  let _temp9 = GetValue(tagRef);
  /* istanbul ignore if */


  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }
  /* istanbul ignore if */


  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const tagFunc = _temp9;
  return yield* EvaluateCall(tagFunc, tagRef, TemplateLiteral);
}

//   TemplateLiteral : NoSubstitutionTemplate
//   SubstitutionTemplate : TemplateHead Expression TemplateSpans
//   TemplateSpans : TemplateTail
//   TemplateSpans : TemplateMiddleList TemplateTail
//   TemplateMiddleList : TemplateMiddle Expression
//   TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
//
// (implicit)
//   TemplateLiteral : SubstitutionTemplate

function* Evaluate_TemplateLiteral(TemplateLiteral) {
  let str = '';

  for (let i = 0; i < TemplateLiteral.quasis.length - 1; i += 1) {
    const TemplateHead = TemplateLiteral.quasis[i];
    const Expression = TemplateLiteral.expressions[i];
    const head = TemplateHead.value.cooked;
    const subRef = yield* Evaluate(Expression);

    let _temp = GetValue(subRef);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const sub = _temp;

    let _temp2 = ToString(sub);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const middle = _temp2;
    str += head;
    str += middle.stringValue();
  }

  const TemplateTail = TemplateLiteral.quasis[TemplateLiteral.quasis.length - 1];
  const tail = TemplateTail.value.cooked;
  return new Value(str + tail);
}

// PrimaryExpression : this

function Evaluate_ThisExpression() {
  return ResolveThisBinding();
}

function* Evaluate_ThrowStatement(Expression) {
  const exprRef = yield* Evaluate(Expression);

  let _temp = GetValue(exprRef);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const exprValue = _temp;
  return new ThrowCompletion(exprValue);
}

function TrimString(string, where) {
  let _temp = RequireObjectCoercible(string);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const str = _temp;

  let _temp2 = ToString(str);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const S = _temp2.stringValue();

  let T;

  if (where === 'start') {
    T = S.trimStart();
  } else if (where === 'end') {
    T = S.trimEnd();
  } else {
    Assert(where === 'start+end', "where === 'start+end'");
    T = S.trim();
  }

  return new Value(T);
}

//    With parameter thrownValue.
//    Catch :
//      `catch` `(` CatchParameter `)` Block
//      `catch` Block

function* CatchClauseEvaluation({
  param: CatchParameter,
  body: Block
}, thrownValue) {
  if (!CatchParameter) {
    //  Catch : `catch` Block
    return yield* Evaluate_Block(Block);
  }

  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const catchEnv = NewDeclarativeEnvironment(oldEnv);
  const catchEnvRec = catchEnv.EnvironmentRecord;

  for (const argName of BoundNames_CatchParameter(CatchParameter)) {
    let _temp = catchEnvRec.CreateMutableBinding(new Value(argName), false);

    Assert(!(_temp instanceof AbruptCompletion), "catchEnvRec.CreateMutableBinding(new Value(argName), false)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }
  }

  surroundingAgent.runningExecutionContext.LexicalEnvironment = catchEnv;
  const status = yield* BindingInitialization_CatchParameter(CatchParameter, thrownValue, catchEnv);

  if (status instanceof AbruptCompletion) {
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
    return status;
  }

  const B = yield* Evaluate_Block(Block);
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  return B;
} // (implicit)
//   Finally : `finally` Block


const Evaluate_Finally = Evaluate_Block; // 13.15.8 #sec-try-statement-runtime-semantics-evaluation
//   TryStatement : `try` Block Catch

function* Evaluate_TryStatement_Catch(Block, Catch) {
  const B = EnsureCompletion((yield* Evaluate_Block(Block)));
  let C;

  if (B.Type === 'throw') {
    C = EnsureCompletion((yield* CatchClauseEvaluation(Catch, B.Value)));
  } else {
    C = B;
  }

  return Completion(UpdateEmpty(C, Value.undefined));
} // 13.15.8 #sec-try-statement-runtime-semantics-evaluation
//   TryStatement : `try` Block Finally


function* Evaluate_TryStatement_Finally(Block, Finally) {
  const B = EnsureCompletion((yield* Evaluate_Block(Block)));
  let F = EnsureCompletion((yield* Evaluate_Finally(Finally)));

  if (F.Type === 'normal') {
    F = B;
  }

  return Completion(UpdateEmpty(F, Value.undefined));
} // 13.15.8 #sec-try-statement-runtime-semantics-evaluation
//   TryStatement : `try` Block Catch Finally


function* Evaluate_TryStatement_CatchFinally(Block, Catch, Finally) {
  const B = EnsureCompletion((yield* Evaluate_Block(Block)));
  let C;

  if (B.Type === 'throw') {
    C = EnsureCompletion((yield* CatchClauseEvaluation(Catch, B.Value)));
  } else {
    C = B;
  }

  let F = EnsureCompletion((yield* Evaluate_Finally(Finally)));

  if (F.Type === 'normal') {
    F = C;
  }

  return Completion(UpdateEmpty(F, Value.undefined));
} // 13.15.8 #sec-try-statement-runtime-semantics-evaluation


function* Evaluate_TryStatement(Expression) {
  switch (true) {
    case isTryStatementWithCatch(Expression) && isTryStatementWithFinally(Expression):
      return yield* Evaluate_TryStatement_CatchFinally(Expression.block, Expression.handler, Expression.finalizer);

    case isTryStatementWithCatch(Expression):
      return yield* Evaluate_TryStatement_Catch(Expression.block, Expression.handler);

    case isTryStatementWithFinally(Expression):
      return yield* Evaluate_TryStatement_Finally(Expression.block, Expression.finalizer);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_TryStatement', Expression);
  }
}

// UnaryExpression : `delete` UnaryExpression

function* Evaluate_UnaryExpression_Delete(UnaryExpression) {
  let ref = yield* Evaluate(UnaryExpression);

  /* istanbul ignore if */
  if (ref instanceof AbruptCompletion) {
    return ref;
  }
  /* istanbul ignore if */


  if (ref instanceof Completion) {
    ref = ref.Value;
  }

  if (Type(ref) !== 'Reference') {
    return Value.true;
  }

  if (IsUnresolvableReference(ref) === Value.true) {
    Assert(IsStrictReference(ref) === Value.false, "IsStrictReference(ref) === Value.false");
    return Value.true;
  }

  if (IsPropertyReference(ref) === Value.true) {
    if (IsSuperReference(ref) === Value.true) {
      return surroundingAgent.Throw('ReferenceError', 'CannotDeleteSuper');
    }

    let _temp = ToObject(GetBase(ref));

    Assert(!(_temp instanceof AbruptCompletion), "ToObject(GetBase(ref))" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const baseObj = _temp;

    let _temp2 = baseObj.Delete(GetReferencedName(ref));
    /* istanbul ignore if */


    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }
    /* istanbul ignore if */


    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const deleteStatus = _temp2;

    if (deleteStatus === Value.false && IsStrictReference(ref) === Value.true) {
      return surroundingAgent.Throw('TypeError', 'StrictModeDelete', GetReferencedName(ref));
    }

    return deleteStatus;
  } else {
    const bindings = GetBase(ref);
    return bindings.DeleteBinding(GetReferencedName(ref));
  }
} // 12.5.4.1 #sec-void-operator-runtime-semantics-evaluation
// UnaryExpression : `void` UnaryExpression


function* Evaluate_UnaryExpression_Void(UnaryExpression) {
  const expr = yield* Evaluate(UnaryExpression);

  let _temp3 = GetValue(expr);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  return Value.undefined;
} // 12.5.5.1 #sec-typeof-operator-runtime-semantics-evaluation
// UnaryExpression : `typeof` UnaryExpression


function* Evaluate_UnaryExpression_Typeof(UnaryExpression) {
  let val = yield* Evaluate(UnaryExpression);

  if (Type(val) === 'Reference') {
    if (IsUnresolvableReference(val) === Value.true) {
      return new Value('undefined');
    }
  }

  let _temp4 = GetValue(val);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  val = _temp4; // Return a String according to Table 37.

  const type = Type(val);

  switch (type) {
    case 'Undefined':
      return new Value('undefined');

    case 'Null':
      return new Value('object');

    case 'Boolean':
      return new Value('boolean');

    case 'Number':
      return new Value('number');

    case 'String':
      return new Value('string');

    case 'BigInt':
      return new Value('bigint');

    case 'Symbol':
      return new Value('symbol');

    case 'Object':
      if (IsCallable(val) === Value.true) {
        return new Value('function');
      }

      return new Value('object');

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_UnaryExpression_Typeof', type);
  }
} // 12.5.6.1 #sec-unary-plus-operator-runtime-semantics-evaluation
// UnaryExpression : `+` UnaryExpression


function* Evaluate_UnaryExpression_Plus(UnaryExpression) {
  const expr = yield* Evaluate(UnaryExpression);

  let _temp5 = GetValue(expr);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  return ToNumber(_temp5);
} // 12.5.7.1 #sec-unary-minus-operator-runtime-semantics-evaluation
// UnaryExpression : `-` UnaryExpression


function* Evaluate_UnaryExpression_Minus(UnaryExpression) {
  // 1. Let expr be the result of evaluating UnaryExpression.
  const expr = yield* Evaluate(UnaryExpression); // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).

  let _temp8 = GetValue(expr);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  let _temp6 = ToNumeric(_temp8);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const oldValue = _temp6; // 3. Let T be Type(oldValue).

  const T = TypeNumeric(oldValue); // 4. Return ! T::unaryMinus(oldValue).

  let _temp7 = T.unaryMinus(oldValue);

  Assert(!(_temp7 instanceof AbruptCompletion), "T.unaryMinus(oldValue)" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  return _temp7;
} // 12.5.8.1 #sec-bitwise-not-operator-runtime-semantics-evaluation
// UnaryExpression : `~` UnaryExpression


function* Evaluate_UnaryExpression_Tilde(UnaryExpression) {
  // 1. Let expr be the result of evaluating UnaryExpression.
  const expr = yield* Evaluate(UnaryExpression); // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).

  let _temp11 = GetValue(expr);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  let _temp9 = ToNumeric(_temp11);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const oldValue = _temp9; // 3. Let T be Type(oldValue).

  const T = TypeNumeric(oldValue); // 4. Return ! T::bitwiseNOT(oldValue).

  let _temp10 = T.bitwiseNOT(oldValue);

  Assert(!(_temp10 instanceof AbruptCompletion), "T.bitwiseNOT(oldValue)" + ' returned an abrupt completion');

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  return _temp10;
} // 12.5.9.1 #sec-logical-not-operator-runtime-semantics-evaluation
// UnaryExpression : `!` UnaryExpression


function* Evaluate_UnaryExpression_Bang(UnaryExpression) {
  const expr = yield* Evaluate(UnaryExpression);

  let _temp12 = GetValue(expr);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const oldValue = ToBoolean(_temp12);

  if (oldValue === Value.true) {
    return Value.false;
  }

  return Value.true;
}

function* Evaluate_UnaryExpression(UnaryExpression) {
  switch (true) {
    case isUnaryExpressionWithDelete(UnaryExpression):
      return yield* Evaluate_UnaryExpression_Delete(UnaryExpression.argument);

    case isUnaryExpressionWithVoid(UnaryExpression):
      return yield* Evaluate_UnaryExpression_Void(UnaryExpression.argument);

    case isUnaryExpressionWithTypeof(UnaryExpression):
      return yield* Evaluate_UnaryExpression_Typeof(UnaryExpression.argument);

    case isUnaryExpressionWithPlus(UnaryExpression):
      return yield* Evaluate_UnaryExpression_Plus(UnaryExpression.argument);

    case isUnaryExpressionWithMinus(UnaryExpression):
      return yield* Evaluate_UnaryExpression_Minus(UnaryExpression.argument);

    case isUnaryExpressionWithTilde(UnaryExpression):
      return yield* Evaluate_UnaryExpression_Tilde(UnaryExpression.argument);

    case isUnaryExpressionWithBang(UnaryExpression):
      return yield* Evaluate_UnaryExpression_Bang(UnaryExpression.argument);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_UnaryExpression', UnaryExpression);
  }
}

function* Evaluate_UpdateExpression({
  operator,
  prefix,
  argument
}) {
  switch (true) {
    // UpdateExpression : LeftHandSideExpression `++`
    case operator === '++' && !prefix:
      {
        const LeftHandSideExpression = argument;
        const lhs = yield* Evaluate(LeftHandSideExpression);

        let _temp4 = GetValue(lhs);
        /* istanbul ignore if */


        if (_temp4 instanceof AbruptCompletion) {
          return _temp4;
        }
        /* istanbul ignore if */


        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }

        let _temp = ToNumeric(_temp4);

        if (_temp instanceof AbruptCompletion) {
          return _temp;
        }

        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }

        const oldValue = _temp;

        let _temp2 = TypeNumeric(oldValue).add(oldValue, TypeNumeric(oldValue).unit);

        Assert(!(_temp2 instanceof AbruptCompletion), "TypeNumeric(oldValue).add(oldValue, TypeNumeric(oldValue).unit)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }

        const newValue = _temp2;

        let _temp3 = PutValue(lhs, newValue);

        if (_temp3 instanceof AbruptCompletion) {
          return _temp3;
        }

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }
        return oldValue;
      }
    // UpdateExpression : LeftHandSideExpression `--`

    case operator === '--' && !prefix:
      {
        const LeftHandSideExpression = argument;
        const lhs = yield* Evaluate(LeftHandSideExpression);

        let _temp8 = GetValue(lhs);

        if (_temp8 instanceof AbruptCompletion) {
          return _temp8;
        }

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }

        let _temp5 = ToNumeric(_temp8);

        if (_temp5 instanceof AbruptCompletion) {
          return _temp5;
        }

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }

        const oldValue = _temp5;

        let _temp6 = TypeNumeric(oldValue).subtract(oldValue, TypeNumeric(oldValue).unit);

        Assert(!(_temp6 instanceof AbruptCompletion), "TypeNumeric(oldValue).subtract(oldValue, TypeNumeric(oldValue).unit)" + ' returned an abrupt completion');

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        const newValue = _temp6;

        let _temp7 = PutValue(lhs, newValue);

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }
        return oldValue;
      }
    // UpdateExpression : `++` UnaryExpression

    case operator === '++' && prefix:
      {
        const UnaryExpression = argument;
        const expr = yield* Evaluate(UnaryExpression);

        let _temp12 = GetValue(expr);

        if (_temp12 instanceof AbruptCompletion) {
          return _temp12;
        }

        if (_temp12 instanceof Completion) {
          _temp12 = _temp12.Value;
        }

        let _temp9 = ToNumeric(_temp12);

        if (_temp9 instanceof AbruptCompletion) {
          return _temp9;
        }

        if (_temp9 instanceof Completion) {
          _temp9 = _temp9.Value;
        }

        const oldValue = _temp9;

        let _temp10 = TypeNumeric(oldValue).add(oldValue, TypeNumeric(oldValue).unit);

        Assert(!(_temp10 instanceof AbruptCompletion), "TypeNumeric(oldValue).add(oldValue, TypeNumeric(oldValue).unit)" + ' returned an abrupt completion');

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }

        const newValue = _temp10;

        let _temp11 = PutValue(expr, newValue);

        if (_temp11 instanceof AbruptCompletion) {
          return _temp11;
        }

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }
        return newValue;
      }
    // UpdateExpression : `--` UnaryExpression

    case operator === '--' && prefix:
      {
        const UnaryExpression = argument;
        const expr = yield* Evaluate(UnaryExpression);

        let _temp16 = GetValue(expr);

        if (_temp16 instanceof AbruptCompletion) {
          return _temp16;
        }

        if (_temp16 instanceof Completion) {
          _temp16 = _temp16.Value;
        }

        let _temp13 = ToNumeric(_temp16);

        if (_temp13 instanceof AbruptCompletion) {
          return _temp13;
        }

        if (_temp13 instanceof Completion) {
          _temp13 = _temp13.Value;
        }

        const oldValue = _temp13;

        let _temp14 = TypeNumeric(oldValue).subtract(oldValue, TypeNumeric(oldValue).unit);

        Assert(!(_temp14 instanceof AbruptCompletion), "TypeNumeric(oldValue).subtract(oldValue, TypeNumeric(oldValue).unit)" + ' returned an abrupt completion');

        if (_temp14 instanceof Completion) {
          _temp14 = _temp14.Value;
        }

        const newValue = _temp14;

        let _temp15 = PutValue(expr, newValue);

        if (_temp15 instanceof AbruptCompletion) {
          return _temp15;
        }

        if (_temp15 instanceof Completion) {
          _temp15 = _temp15.Value;
        }
        return newValue;
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_UpdateExpression', operator, prefix);
  }
}

//   VariableDeclaration :
//     BindingIdentifier
//     BindingIdentifier Initializer
//     BindingPattern Initializer

function* Evaluate_VariableDeclaration(VariableDeclaration) {
  switch (true) {
    case isBindingIdentifier(VariableDeclaration.id) && VariableDeclaration.init === null:
      return new NormalCompletion(undefined);

    case isBindingIdentifier(VariableDeclaration.id) && VariableDeclaration.init !== null:
      {
        const {
          id: BindingIdentifier,
          init: Initializer
        } = VariableDeclaration;
        const bindingId = new Value(BindingIdentifier.name);

        let _temp = ResolveBinding(bindingId, undefined, BindingIdentifier.strict);
        /* istanbul ignore if */


        if (_temp instanceof AbruptCompletion) {
          return _temp;
        }
        /* istanbul ignore if */


        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }

        const lhs = _temp;
        let value;

        if (IsAnonymousFunctionDefinition(Initializer)) {
          value = yield* NamedEvaluation_Expression(Initializer, bindingId);
        } else {
          const rhs = yield* Evaluate(Initializer);

          let _temp2 = GetValue(rhs);

          if (_temp2 instanceof AbruptCompletion) {
            return _temp2;
          }

          if (_temp2 instanceof Completion) {
            _temp2 = _temp2.Value;
          }

          value = _temp2;
        }

        return PutValue(lhs, value);
      }

    case isBindingPattern(VariableDeclaration.id) && VariableDeclaration.init !== null:
      {
        const {
          id: BindingPattern,
          init: Initializer
        } = VariableDeclaration;
        const rhs = yield* Evaluate(Initializer);

        let _temp3 = GetValue(rhs);

        if (_temp3 instanceof AbruptCompletion) {
          return _temp3;
        }

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }

        const rval = _temp3;
        return yield* BindingInitialization_BindingPattern(BindingPattern, rval, Value.undefined);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_VariableDeclaration', VariableDeclaration);
  }
} // 13.3.2.4 #sec-variable-statement-runtime-semantics-evaluation
//   VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration
//
// (implicit)
//   VariableDeclarationList : VariableDeclaration

function* Evaluate_VariableDeclarationList(VariableDeclarationList) {
  let next;

  for (const VariableDeclaration of VariableDeclarationList) {
    next = yield* Evaluate_VariableDeclaration(VariableDeclaration);

    /* istanbul ignore if */
    if (next instanceof AbruptCompletion) {
      return next;
    }
    /* istanbul ignore if */


    if (next instanceof Completion) {
      next = next.Value;
    }
  }

  return next;
} // 13.3.2.4 #sec-variable-statement-runtime-semantics-evaluation
//   VariableStatement : `var` VariableDeclarationList `;`

function* Evaluate_VariableStatement(VariableStatement) {
  let next = yield* Evaluate_VariableDeclarationList(VariableStatement.declarations);

  if (next instanceof AbruptCompletion) {
    return next;
  }

  if (next instanceof Completion) {
    next = next.Value;
  }
  return new NormalCompletion(undefined);
}

// WithStatement : `with` `(` Expression `)` Statement

function* Evaluate_WithStatement({
  object: Expression,
  body: Statement
}) {
  const val = yield* Evaluate(Expression);

  let _temp2 = GetValue(val);
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  let _temp = ToObject(_temp2);

  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const obj = _temp;
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  const newEnv = NewObjectEnvironment(obj, oldEnv);
  newEnv.EnvironmentRecord.withEnvironment = true;
  surroundingAgent.runningExecutionContext.LexicalEnvironment = newEnv;
  const C = EnsureCompletion((yield* Evaluate(Statement)));
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  return Completion(UpdateEmpty(C, Value.undefined));
}

//   YieldExpression :
//     `yield`
//     `yield` AssignmentExpression

function* Evaluate_YieldExpression_WithoutStar(YieldExpression) {
  let _temp = GetGeneratorKind();

  Assert(!(_temp instanceof AbruptCompletion), "GetGeneratorKind()" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const generatorKind = _temp;
  let value = Value.undefined;

  if (YieldExpression.argument) {
    const AssignmentExpression = YieldExpression.argument;
    const exprRef = yield* Evaluate(AssignmentExpression);

    let _temp2 = GetValue(exprRef);
    /* istanbul ignore if */


    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }
    /* istanbul ignore if */


    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    value = _temp2;
  }

  if (generatorKind === 'async') {
    return yield* AsyncGeneratorYield(value);
  }

  Assert(generatorKind === 'sync', "generatorKind === 'sync'");
  return yield* GeneratorYield(CreateIterResultObject(value, Value.false));
} // 14.4.14 #sec-generator-function-definitions-runtime-semantics-evaluation
//   YieldExpression :
//     `yield` `*` AssignmentExpression


function* Evaluate_YieldExpression_Star({
  argument: AssignmentExpression
}) {
  let _temp3 = GetGeneratorKind();

  Assert(!(_temp3 instanceof AbruptCompletion), "GetGeneratorKind()" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const generatorKind = _temp3;
  const exprRef = yield* Evaluate(AssignmentExpression);

  let _temp4 = GetValue(exprRef);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const value = _temp4;

  let _temp5 = GetIterator(value, generatorKind);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const iteratorRecord = _temp5;
  const iterator = iteratorRecord.Iterator;
  let received = new NormalCompletion(Value.undefined);

  while (true) {
    if (received.Type === 'normal') {
      let _temp6 = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, [received.Value]);

      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }

      let innerResult = _temp6;

      if (generatorKind === 'async') {
        let _temp7 = yield* Await(innerResult);

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        innerResult = _temp7;
      }

      if (Type(innerResult) !== 'Object') {
        return surroundingAgent.Throw('TypeError', 'NotAnObject', innerResult);
      }

      let _temp8 = IteratorComplete(innerResult);

      if (_temp8 instanceof AbruptCompletion) {
        return _temp8;
      }

      if (_temp8 instanceof Completion) {
        _temp8 = _temp8.Value;
      }

      const done = _temp8;

      if (done === Value.true) {
        return IteratorValue(innerResult);
      }

      if (generatorKind === 'async') {
        let _temp9 = IteratorValue(innerResult);

        if (_temp9 instanceof AbruptCompletion) {
          return _temp9;
        }

        if (_temp9 instanceof Completion) {
          _temp9 = _temp9.Value;
        }

        received = EnsureCompletion((yield* AsyncGeneratorYield(_temp9)));
      } else {
        received = EnsureCompletion((yield* GeneratorYield(innerResult)));
      }
    } else if (received.Type === 'throw') {
      let _temp10 = GetMethod(iterator, new Value('throw'));

      if (_temp10 instanceof AbruptCompletion) {
        return _temp10;
      }

      if (_temp10 instanceof Completion) {
        _temp10 = _temp10.Value;
      }

      const thr = _temp10;

      if (Type(thr) !== 'Undefined') {
        let _temp11 = Call(thr, iterator, [received.Value]);

        if (_temp11 instanceof AbruptCompletion) {
          return _temp11;
        }

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }

        let innerResult = _temp11;

        if (generatorKind === 'async') {
          let _temp12 = yield* Await(innerResult);

          if (_temp12 instanceof AbruptCompletion) {
            return _temp12;
          }

          if (_temp12 instanceof Completion) {
            _temp12 = _temp12.Value;
          }

          innerResult = _temp12;
        }

        if (Type(innerResult) !== 'Object') {
          return surroundingAgent.Throw('TypeError', 'NotAnObject', innerResult);
        }

        let _temp13 = IteratorComplete(innerResult);

        if (_temp13 instanceof AbruptCompletion) {
          return _temp13;
        }

        if (_temp13 instanceof Completion) {
          _temp13 = _temp13.Value;
        }

        const done = _temp13;

        if (done === Value.true) {
          return IteratorValue(innerResult);
        }

        if (generatorKind === 'async') {
          let _temp14 = IteratorValue(innerResult);

          if (_temp14 instanceof AbruptCompletion) {
            return _temp14;
          }

          if (_temp14 instanceof Completion) {
            _temp14 = _temp14.Value;
          }

          received = EnsureCompletion((yield* AsyncGeneratorYield(_temp14)));
        } else {
          received = EnsureCompletion((yield* GeneratorYield(innerResult)));
        }
      } else {
        const closeCompletion = new NormalCompletion(undefined);

        if (generatorKind === 'async') {
          let _temp15 = yield* AsyncIteratorClose(iteratorRecord, closeCompletion);

          if (_temp15 instanceof AbruptCompletion) {
            return _temp15;
          }

          if (_temp15 instanceof Completion) {
            _temp15 = _temp15.Value;
          }
        } else {
          let _temp16 = IteratorClose(iteratorRecord, closeCompletion);

          if (_temp16 instanceof AbruptCompletion) {
            return _temp16;
          }

          if (_temp16 instanceof Completion) {
            _temp16 = _temp16.Value;
          }
        }

        return surroundingAgent.Throw('TypeError', 'IteratorThrowMissing');
      }
    } else {
      Assert(received.Type === 'return', "received.Type === 'return'");

      let _temp17 = GetMethod(iterator, new Value('return'));

      if (_temp17 instanceof AbruptCompletion) {
        return _temp17;
      }

      if (_temp17 instanceof Completion) {
        _temp17 = _temp17.Value;
      }

      const ret = _temp17;

      if (Type(ret) === 'Undefined') {
        if (generatorKind === 'async') {
          let _temp18 = yield* Await(received.Value);

          if (_temp18 instanceof AbruptCompletion) {
            return _temp18;
          }

          if (_temp18 instanceof Completion) {
            _temp18 = _temp18.Value;
          }

          received.Value = _temp18;
        }

        return Completion(received);
      }

      let _temp19 = Call(ret, iterator, [received.Value]);

      if (_temp19 instanceof AbruptCompletion) {
        return _temp19;
      }

      if (_temp19 instanceof Completion) {
        _temp19 = _temp19.Value;
      }

      let innerReturnResult = _temp19;

      if (generatorKind === 'async') {
        let _temp20 = yield* Await(innerReturnResult);

        if (_temp20 instanceof AbruptCompletion) {
          return _temp20;
        }

        if (_temp20 instanceof Completion) {
          _temp20 = _temp20.Value;
        }

        innerReturnResult = _temp20;
      }

      if (Type(innerReturnResult) !== 'Object') {
        return surroundingAgent.Throw('TypeError', 'NotAnObject', innerReturnResult);
      }

      let _temp21 = IteratorComplete(innerReturnResult);

      if (_temp21 instanceof AbruptCompletion) {
        return _temp21;
      }

      if (_temp21 instanceof Completion) {
        _temp21 = _temp21.Value;
      }

      const done = _temp21;

      if (done === Value.true) {
        let _temp22 = IteratorValue(innerReturnResult);

        if (_temp22 instanceof AbruptCompletion) {
          return _temp22;
        }

        if (_temp22 instanceof Completion) {
          _temp22 = _temp22.Value;
        }

        const innerValue = _temp22;
        return new ReturnCompletion(innerValue);
      }

      if (generatorKind === 'async') {
        let _temp23 = IteratorValue(innerReturnResult);

        if (_temp23 instanceof AbruptCompletion) {
          return _temp23;
        }

        if (_temp23 instanceof Completion) {
          _temp23 = _temp23.Value;
        }

        received = EnsureCompletion((yield* AsyncGeneratorYield(_temp23)));
      } else {
        received = EnsureCompletion((yield* GeneratorYield(innerReturnResult)));
      }
    }
  }
}

function* Evaluate_YieldExpression(YieldExpression) {
  if (isYieldExpressionWithStar(YieldExpression)) {
    return yield* Evaluate_YieldExpression_Star(YieldExpression);
  }

  return yield* Evaluate_YieldExpression_WithoutStar(YieldExpression);
}

//   StatementList : StatementList StatementListItem
//
// (implicit)
//   StatementList : StatementListItem

function* Evaluate_StatementList(StatementList) {
  if (StatementList.length === 0) {
    return new NormalCompletion(undefined);
  }

  let sl = yield* Evaluate(StatementList[0]);

  if (StatementList.length === 1) {
    return sl;
  }

  for (const StatementListItem of StatementList.slice(1)) {
    /* istanbul ignore if */
    if (sl instanceof AbruptCompletion) {
      return sl;
    }
    /* istanbul ignore if */


    if (sl instanceof Completion) {
      sl = sl.Value;
    }
    let s = yield* Evaluate(StatementListItem); // We don't always return a Completion value, but here we actually need it
    // to be a Completion.

    s = EnsureCompletion(s);
    sl = UpdateEmpty(s, sl);
  }

  return sl;
} // 15.2.1.23 #sec-module-semantics-runtime-semantics-evaluation
//   ModuleItemList :
//     ModuleItem
//     ModuleItemList ModuleItem

function* Evaluate_ModuleItemList(ModuleItemList) {
  let sl = yield* Evaluate(ModuleItemList[0]);

  if (ModuleItemList.length === 1) {
    return sl;
  }

  for (const ModuleItemListItem of ModuleItemList.slice(1)) {
    if (sl instanceof AbruptCompletion) {
      return sl;
    }

    if (sl instanceof Completion) {
      sl = sl.Value;
    }
    let s = yield* Evaluate(ModuleItemListItem); // We don't always return a Completion value, but here we actually need it
    // to be a Completion.

    s = EnsureCompletion(s);
    sl = UpdateEmpty(s, sl);
  }

  return sl;
} // (implicit)
//   StatementListItem :
//     Statement
//     Declaration
//
//   Statement :
//     BlockStatement
//     ExpressionStatement
//     VariableStatement
//     EmptyStatement
//     ExpressionStatement
//     IfStatement
//     BreakableStatement
//     ContinueStatement
//     BreakStatement
//     ReturnStatement
//     WithStatement
//     LabelledStatement
//     ThrowStatement
//     TryStatement
//     DebuggerStatement
//
//   Declaration :
//     HoistableDeclaration
//     ClassDeclaration
//     LexicalDeclaration

function* Evaluate_StatementListItem(StatementListItem) {
  switch (true) {
    case isBlockStatement(StatementListItem):
      return yield* Evaluate_BlockStatement(StatementListItem);

    case isVariableStatement(StatementListItem):
      return yield* Evaluate_VariableStatement(StatementListItem);

    case isEmptyStatement(StatementListItem):
      return Evaluate_EmptyStatement();

    case isExpressionStatement(StatementListItem):
      return yield* Evaluate_ExpressionStatement(StatementListItem);

    case isIfStatement(StatementListItem):
      return yield* Evaluate_IfStatement(StatementListItem);

    case isBreakableStatement(StatementListItem):
      return yield* Evaluate_BreakableStatement(StatementListItem);

    case isContinueStatement(StatementListItem):
      return Evaluate_ContinueStatement(StatementListItem);

    case isBreakStatement(StatementListItem):
      return Evaluate_BreakStatement(StatementListItem);

    case isReturnStatement(StatementListItem):
      return yield* Evaluate_ReturnStatement(StatementListItem);

    case isWithStatement(StatementListItem):
      return yield* Evaluate_WithStatement(StatementListItem);

    case isLabelledStatement(StatementListItem):
      return yield* Evaluate_LabelledStatement(StatementListItem);

    case isThrowStatement(StatementListItem):
      return yield* Evaluate_ThrowStatement(StatementListItem.argument);

    case isTryStatement(StatementListItem):
      return yield* Evaluate_TryStatement(StatementListItem);

    case isDebuggerStatement(StatementListItem):
      return Evaluate_DebuggerStatement();

    case isHoistableDeclaration(StatementListItem):
      return Evaluate_HoistableDeclaration(StatementListItem);

    case isClassDeclaration(StatementListItem):
      return yield* Evaluate_ClassDeclaration(StatementListItem);

    case isLexicalDeclaration(StatementListItem):
      return yield* Evaluate_LexicalDeclaration(StatementListItem);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_StatementListItem', StatementListItem);
  }
}

const Evaluate_Statement = Evaluate_StatementListItem; // 13.5.1 #sec-expression-statement-runtime-semantics-evaluation
//   ExpressionStatement : Expression `;`

function* Evaluate_ExpressionStatement(ExpressionStatement) {
  const exprRef = yield* Evaluate(ExpressionStatement.expression);
  return GetValue(exprRef);
}

function EvaluateBinopValues(operator, lval, rval) {
  switch (operator) {
    case '*':
    case '/':
    case '%':
      return EvaluateBinopValues_MultiplicativeExpression(operator, lval, rval);

    case '+':
      return EvaluateBinopValues_AdditiveExpression_Plus(lval, rval);

    case '-':
      return EvaluateBinopValues_AdditiveExpression_Minus(lval, rval);

    case '<<':
    case '>>':
    case '>>>':
      return EvaluateBinopValues_ShiftExpression(operator, lval, rval);

    case '&':
      return EvaluateBinopValues_BitwiseANDExpression(lval, rval);

    case '^':
      return EvaluateBinopValues_BitwiseXORExpression(lval, rval);

    case '|':
      return EvaluateBinopValues_BitwiseORExpression(lval, rval);

    case '**':
      return EvaluateBinopValues_ExponentiationExpression(lval, rval);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('EvaluateBinopValues', operator);
  }
}
function* Evaluate_Expression(Expression) {
  return EnsureCompletion((yield* Inner_Evaluate_Expression(Expression)));
} // (implicit)

function* Inner_Evaluate_Expression(Expression) {
  switch (true) {
    case isThis(Expression):
      return Evaluate_ThisExpression();

    case isIdentifierReference(Expression):
      return Evaluate_Identifier(Expression);

    case isLiteral(Expression):
      return Evaluate_Literal(Expression);

    case isArrayLiteral(Expression):
      return yield* Evaluate_ArrayLiteral(Expression);

    case isObjectLiteral(Expression):
      return yield* Evaluate_ObjectLiteral(Expression);

    case isFunctionExpression(Expression):
      return Evaluate_FunctionExpression(Expression);

    case isClassExpression(Expression):
      return yield* Evaluate_ClassExpression(Expression);

    case isGeneratorExpression(Expression):
      return Evaluate_GeneratorExpression(Expression);

    case isAsyncFunctionExpression(Expression):
      return Evaluate_AsyncFunctionExpression(Expression);

    case isAsyncGeneratorExpression(Expression):
      return Evaluate_AsyncGeneratorExpression(Expression);

    case isRegularExpressionLiteral(Expression):
      return Evaluate_RegularExpressionLiteral(Expression);

    case isTemplateLiteral(Expression):
      return yield* Evaluate_TemplateLiteral(Expression);

    case isActualMemberExpression(Expression):
      return yield* Evaluate_MemberExpression(Expression);

    case isOptionalExpression(Expression):
      return yield* Evaluate_OptionalExpression(Expression);

    case isSuperProperty(Expression):
      return yield* Evaluate_SuperProperty(Expression);

    case isSuperCall(Expression):
      return yield* Evaluate_SuperCall(Expression);

    case isImportCall(Expression):
      return yield* Evaluate_ImportCall(Expression);

    case isTaggedTemplate(Expression):
      return yield* Evaluate_TaggedTemplate(Expression);

    case isMetaProperty(Expression):
      return yield* Evaluate_MetaProperty(Expression);

    case isActualNewExpression(Expression):
      return yield* Evaluate_NewExpression(Expression);

    case isActualCallExpression(Expression):
      return yield* Evaluate_CallExpression(Expression);

    case isActualUpdateExpression(Expression):
      return yield* Evaluate_UpdateExpression(Expression);

    case isActualUnaryExpression(Expression):
      return yield* Evaluate_UnaryExpression(Expression);

    case isAwaitExpression(Expression):
      return yield* Evaluate_AwaitExpression(Expression);

    case isActualExponentiationExpression(Expression):
      return yield* Evaluate_ExponentiationExpression(Expression);

    case isActualMultiplicativeExpression(Expression):
      return yield* Evaluate_MultiplicativeExpression(Expression);

    case isActualAdditiveExpression(Expression):
      return yield* Evaluate_AdditiveExpression(Expression);

    case isActualShiftExpression(Expression):
      return yield* Evaluate_ShiftExpression(Expression);

    case isActualRelationalExpression(Expression):
      return yield* Evaluate_RelationalExpression(Expression);

    case isActualEqualityExpression(Expression):
      return yield* Evaluate_EqualityExpression(Expression);

    case isActualBitwiseANDExpression(Expression):
    case isActualBitwiseXORExpression(Expression):
    case isActualBitwiseORExpression(Expression):
      return yield* Evaluate_BinaryBitwiseExpression(Expression);

    case isActualLogicalANDExpression(Expression):
      return yield* Evaluate_LogicalANDExpression(Expression);

    case isActualLogicalORExpression(Expression):
      return yield* Evaluate_LogicalORExpression(Expression);

    case isActualCoalesceExpression(Expression):
      return yield* Evaluate_CoalesceExpression(Expression);

    case isActualConditionalExpression(Expression):
      return yield* Evaluate_ConditionalExpression(Expression);

    case isYieldExpression(Expression):
      return yield* Evaluate_YieldExpression(Expression);

    case isArrowFunction(Expression):
      return Evaluate_ArrowFunction(Expression);

    case isAsyncArrowFunction(Expression):
      return Evaluate_AsyncArrowFunction(Expression);

    case isActualAssignmentExpression(Expression):
      return yield* Evaluate_AssignmentExpression(Expression);

    case isExpressionWithComma(Expression):
      return yield* Evaluate_ExpressionWithComma(Expression);
    // 12.2.10.5 #sec-grouping-operator-runtime-semantics-evaluation

    case isParenthesizedExpression(Expression):
      return yield* Evaluate(Expression.expression);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate_Expression', Expression);
  }
} // 15.1.7 #sec-script-semantics-runtime-semantics-evaluation
//   Script : [empty]
//
// (implicit)
//   Script : ScriptBody
//   ScriptBody : StatementList


function Evaluate_Script(Script) {
  if (Script.length === 0) {
    return new NormalCompletion(Value.undefined);
  }

  return unwind(Evaluate_StatementList(Script));
} // 15.2.1.23 #sec-module-semantics-runtime-semantics-evaluation
//   ModuleBody : ModuleItemList

function* Evaluate_ModuleBody(ModuleBody) {
  const ModuleItemList = ModuleBody;
  const result = EnsureCompletion((yield* Evaluate_ModuleItemList(ModuleItemList)));

  if (result.Type === 'normal' && result.Value === undefined) {
    return new NormalCompletion(Value.undefined);
  }

  return Completion(result);
} // 15.2.1.23 #sec-module-semantics-runtime-semantics-evaluation
//   Module : [empty]
//
// (implicit)
//   Module : ModuleBody

function Evaluate_Module(Module) {
  if (Module.length === 0) {
    return new NormalCompletion(Value.undefined);
  }

  return unwind(Evaluate_ModuleBody(Module));
}
function* Evaluate(Production) {
  surroundingAgent.runningExecutionContext.callSite.setLocation(Production);

  if (surroundingAgent.hostDefinedOptions.onNodeEvaluation) {
    surroundingAgent.hostDefinedOptions.onNodeEvaluation(Production, surroundingAgent.currentRealmRecord);
  }

  switch (true) {
    case isImportDeclaration(Production):
      return new NormalCompletion(undefined);

    case isExportDeclaration(Production):
      return yield* Evaluate_ExportDeclaration(Production);

    case isStatement(Production):
    case isDeclaration(Production):
      return yield* Evaluate_Statement(Production);

    case isExpression(Production):
      return yield* Evaluate_Expression(Production);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('Evaluate', Production);
  }
}

class ImportEntryRecord {
  constructor({
    ModuleRequest,
    ImportName,
    LocalName
  }) {
    Assert(Type(ModuleRequest) === 'String', "Type(ModuleRequest) === 'String'");
    Assert(Type(ImportName) === 'String', "Type(ImportName) === 'String'");
    Assert(Type(LocalName) === 'String', "Type(LocalName) === 'String'");
    this.ModuleRequest = ModuleRequest;
    this.ImportName = ImportName;
    this.LocalName = LocalName;
  }

} // #exportentry-record

class ExportEntryRecord {
  constructor({
    ExportName,
    ModuleRequest,
    ImportName,
    LocalName
  }) {
    Assert(Type(ExportName) === 'String' || Type(ExportName) === 'Null', "Type(ExportName) === 'String' || Type(ExportName) === 'Null'");
    Assert(Type(ModuleRequest) === 'String' || Type(ModuleRequest) === 'Null', "Type(ModuleRequest) === 'String' || Type(ModuleRequest) === 'Null'");
    Assert(Type(ImportName) === 'String' || Type(ImportName) === 'Null', "Type(ImportName) === 'String' || Type(ImportName) === 'Null'");
    Assert(Type(LocalName) === 'String' || Type(LocalName) === 'Null', "Type(LocalName) === 'String' || Type(LocalName) === 'Null'");
    this.ExportName = ExportName;
    this.ModuleRequest = ModuleRequest;
    this.ImportName = ImportName;
    this.LocalName = LocalName;
  }

} // #resolvedbinding-record

class ResolvedBindingRecord {
  constructor({
    Module,
    BindingName
  }) {
    Assert(Module instanceof AbstractModuleRecord, "Module instanceof AbstractModuleRecord");
    Assert(Type(BindingName) === 'String', "Type(BindingName) === 'String'");
    this.Module = Module;
    this.BindingName = BindingName;
  }

} // 15.2.1.15 #sec-abstract-module-records

class AbstractModuleRecord {
  constructor({
    Realm,
    Environment,
    Namespace,
    HostDefined
  }) {
    this.Realm = Realm;
    this.Environment = Environment;
    this.Namespace = Namespace;
    this.HostDefined = HostDefined;
  }

} // 15.2.1.16 #sec-cyclic-module-records

class CyclicModuleRecord extends AbstractModuleRecord {
  constructor(init) {
    super(init);
    this.Status = init.Status;
    this.EvaluationError = init.EvaluationError;
    this.DFSIndex = init.DFSIndex;
    this.DFSAncestorIndex = init.DFSAncestorIndex;
    this.RequestedModules = init.RequestedModules;
    this.Async = init.Async;
    this.AsyncEvaluating = init.AsyncEvaluating;
    this.TopLevelCapability = init.TopLevelCapability;
    this.AsyncParentModules = init.AsyncParentModules;
    this.PendingAsyncDependencies = init.PendingAsyncDependencies;
  } // 15.2.1.16.1 #sec-moduledeclarationlinking


  Link() {
    const module = this;
    Assert(module.Status !== 'linking' && module.Status !== 'evaluating', "module.Status !== 'linking' && module.Status !== 'evaluating'");
    const stack = [];
    const result = InnerModuleLinking(module, stack, 0);

    if (result instanceof AbruptCompletion) {
      for (const m of stack) {
        Assert(m.Status === 'linking', "m.Status === 'linking'");
        m.Status = 'unlinked';
        m.Environment = Value.undefined;
        m.DFSIndex = Value.undefined;
        m.DFSAncestorIndex = Value.undefined;
      }

      Assert(module.Status === 'unlinked', "module.Status === 'unlinked'");
      return result;
    }

    Assert(module.Status === 'linked' || module.Status === 'evaluated', "module.Status === 'linked' || module.Status === 'evaluated'");
    Assert(stack.length === 0, "stack.length === 0");
    return Value.undefined;
  } // 15.2.1.16.2 #sec-moduleevaluation


  Evaluate() {
    let module = this;
    Assert(module.Status === 'linked' || module.Status === 'evaluated', "module.Status === 'linked' || module.Status === 'evaluated'");

    if (module.Status === 'evaluated') {
      module = GetAsyncCycleRoot(module);
    }

    if (module.TopLevelCapability !== Value.undefined) {
      return module.TopLevelCapability.Promise;
    }

    const stack = [];

    let _temp = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

    Assert(!(_temp instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const capability = _temp;
    module.TopLevelCapability = capability;
    const result = InnerModuleEvaluation(module, stack, 0);

    if (result instanceof AbruptCompletion) {
      for (const m of stack) {
        Assert(m.Status === 'evaluating', "m.Status === 'evaluating'");
        m.Status = 'evaluated';
        m.EvaluationError = result;
      }

      Assert(module.Status === 'evaluated' && module.EvaluationError === result, "module.Status === 'evaluated' && module.EvaluationError === result");

      let _temp2 = Call(capability.Reject, Value.undefined, [result.Value]);

      Assert(!(_temp2 instanceof AbruptCompletion), "Call(capability.Reject, Value.undefined, [result.Value])" + ' returned an abrupt completion');

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }
    } else {
      Assert(module.Status === 'evaluated' && module.EvaluationError === Value.undefined, "module.Status === 'evaluated' && module.EvaluationError === Value.undefined");

      if (module.AsyncEvaluating === Value.false) {
        let _temp3 = Call(capability.Resolve, Value.undefined, [Value.undefined]);

        Assert(!(_temp3 instanceof AbruptCompletion), "Call(capability.Resolve, Value.undefined, [Value.undefined])" + ' returned an abrupt completion');

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }
      }

      Assert(stack.length === 0, "stack.length === 0");
    }

    return capability.Promise;
  }

} // 15.2.1.17 #sec-source-text-module-records

class SourceTextModuleRecord extends CyclicModuleRecord {
  constructor(init) {
    super(init);
    ({
      ImportMeta: this.ImportMeta,
      ECMAScriptCode: this.ECMAScriptCode,
      Context: this.Context,
      ImportEntries: this.ImportEntries,
      LocalExportEntries: this.LocalExportEntries,
      IndirectExportEntries: this.IndirectExportEntries,
      StarExportEntries: this.StarExportEntries
    } = init);
  } // 15.2.1.17.2 #sec-getexportednames


  GetExportedNames(exportStarSet) {
    const module = this;

    if (!exportStarSet) {
      exportStarSet = [];
    }

    Assert(Array.isArray(exportStarSet) && exportStarSet.every(e => e instanceof SourceTextModuleRecord), "Array.isArray(exportStarSet) && exportStarSet.every((e) => e instanceof SourceTextModuleRecord)");

    if (exportStarSet.includes(module)) {
      // Assert: We've reached the starting point of an import * circularity.
      return [];
    }

    exportStarSet.push(module);
    const exportedNames = [];

    for (const e of module.LocalExportEntries) {
      // Assert: module provides the direct binding for this export.
      exportedNames.push(e.ExportName);
    }

    for (const e of module.IndirectExportEntries) {
      // Assert: module imports a specific binding for this export.
      exportedNames.push(e.ExportName);
    }

    for (const e of module.StarExportEntries) {
      let _temp4 = HostResolveImportedModule(module, e.ModuleRequest);
      /* istanbul ignore if */


      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }
      /* istanbul ignore if */


      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      const requestedModule = _temp4;

      let _temp5 = requestedModule.GetExportedNames(exportStarSet);

      if (_temp5 instanceof AbruptCompletion) {
        return _temp5;
      }

      if (_temp5 instanceof Completion) {
        _temp5 = _temp5.Value;
      }

      const starNames = _temp5;

      for (const n of starNames) {
        if (SameValue(n, new Value('default')) === Value.false) {
          if (!exportedNames.includes(n)) {
            exportedNames.push(n);
          }
        }
      }
    }

    return exportedNames;
  } // 15.2.1.17.3 #sec-resolveexport


  ResolveExport(exportName, resolveSet) {
    const module = this;

    if (!resolveSet) {
      resolveSet = [];
    }

    Assert(Array.isArray(resolveSet) && resolveSet.every(e => 'Module' in e && 'ExportName' in e), "Array.isArray(resolveSet) && resolveSet.every((e) => 'Module' in e && 'ExportName' in e)");

    for (const r of resolveSet) {
      if (module === r.Module && SameValue(exportName, r.ExportName) === Value.true) {
        // Assert: This is a circular import request.
        return null;
      }
    }

    resolveSet.push({
      Module: module,
      ExportName: exportName
    });

    for (const e of module.LocalExportEntries) {
      if (SameValue(exportName, e.ExportName) === Value.true) {
        // Assert: module provides the direct binding for this export.
        return new ResolvedBindingRecord({
          Module: module,
          BindingName: e.LocalName
        });
      }
    }

    for (const e of module.IndirectExportEntries) {
      if (SameValue(exportName, e.ExportName) === Value.true) {
        let _temp6 = HostResolveImportedModule(module, e.ModuleRequest);

        if (_temp6 instanceof AbruptCompletion) {
          return _temp6;
        }

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        // Assert: module provides the direct binding for this export.
        const importedModule = _temp6;
        return importedModule.ResolveExport(e.ImportName, resolveSet);
      }
    }

    if (SameValue(exportName, new Value('default')) === Value.true) {
      // Assert: A default export was not explicitly defined by this module.
      return null; // NOTE: A default export cannot be provided by an export *.
    }

    let starResolution = null;

    for (const e of module.StarExportEntries) {
      let _temp7 = HostResolveImportedModule(module, e.ModuleRequest);

      if (_temp7 instanceof AbruptCompletion) {
        return _temp7;
      }

      if (_temp7 instanceof Completion) {
        _temp7 = _temp7.Value;
      }

      const importedModule = _temp7;

      let _temp8 = importedModule.ResolveExport(exportName, resolveSet);

      if (_temp8 instanceof AbruptCompletion) {
        return _temp8;
      }

      if (_temp8 instanceof Completion) {
        _temp8 = _temp8.Value;
      }

      const resolution = _temp8;

      if (resolution === 'ambiguous') {
        return 'ambiguous';
      }

      if (resolution !== null) {
        Assert(resolution instanceof ResolvedBindingRecord, "resolution instanceof ResolvedBindingRecord");

        if (starResolution === null) {
          starResolution = resolution;
        } else {
          // Assert: There is more than one * import that includes the requested name.
          if (resolution.Module !== starResolution.Module || SameValue(resolution.BindingName, starResolution.BindingName) === Value.false) {
            return 'ambiguous';
          }
        }
      }
    }

    return starResolution;
  } // 15.2.1.17.4 #sec-source-text-module-record-initialize-environment


  InitializeEnvironment() {
    const module = this;

    for (const e of module.IndirectExportEntries) {
      let _temp9 = module.ResolveExport(e.ExportName);

      if (_temp9 instanceof AbruptCompletion) {
        return _temp9;
      }

      if (_temp9 instanceof Completion) {
        _temp9 = _temp9.Value;
      }

      const resolution = _temp9;

      if (resolution === null || resolution === 'ambiguous') {
        return surroundingAgent.Throw('SyntaxError', 'ResolutionNullOrAmbiguous', resolution, e.ExportName, module);
      } // Assert: resolution is a ResolvedBinding Record.

    } // Assert: All named exports from module are resolvable.


    const realm = module.Realm;
    Assert(realm !== Value.undefined, "realm !== Value.undefined");
    const env = NewModuleEnvironment(realm.GlobalEnv);
    module.Environment = env;
    const envRec = env.EnvironmentRecord;

    for (const ie of module.ImportEntries) {
      let _temp10 = HostResolveImportedModule(module, ie.ModuleRequest);

      Assert(!(_temp10 instanceof AbruptCompletion), "HostResolveImportedModule(module, ie.ModuleRequest)" + ' returned an abrupt completion');

      if (_temp10 instanceof Completion) {
        _temp10 = _temp10.Value;
      }

      const importedModule = _temp10;

      if (ie.ImportName.stringValue() === '*') {
        let _temp11 = GetModuleNamespace(importedModule);

        if (_temp11 instanceof AbruptCompletion) {
          return _temp11;
        }

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }

        const namespace = _temp11;

        let _temp12 = envRec.CreateImmutableBinding(ie.LocalName, Value.true);

        Assert(!(_temp12 instanceof AbruptCompletion), "envRec.CreateImmutableBinding(ie.LocalName, Value.true)" + ' returned an abrupt completion');

        if (_temp12 instanceof Completion) {
          _temp12 = _temp12.Value;
        }
        envRec.InitializeBinding(ie.LocalName, namespace);
      } else {
        let _temp13 = importedModule.ResolveExport(ie.ImportName);

        if (_temp13 instanceof AbruptCompletion) {
          return _temp13;
        }

        if (_temp13 instanceof Completion) {
          _temp13 = _temp13.Value;
        }

        const resolution = _temp13;

        if (resolution === null || resolution === 'ambiguous') {
          return surroundingAgent.Throw('SyntaxError', 'ResolutionNullOrAmbiguous', resolution, ie.ImportName, importedModule);
        }

        envRec.CreateImportBinding(ie.LocalName, resolution.Module, resolution.BindingName);
      }
    }

    const moduleContext = new ExecutionContext();
    moduleContext.Function = Value.null;
    Assert(module.Realm !== Value.undefined, "module.Realm !== Value.undefined");
    moduleContext.Realm = module.Realm;
    moduleContext.ScriptOrModule = module;
    moduleContext.VariableEnvironment = module.Environment;
    moduleContext.LexicalEnvironment = module.Environment;
    module.Context = moduleContext;
    surroundingAgent.executionContextStack.push(moduleContext);
    const code = module.ECMAScriptCode.body;
    const varDeclarations = VarScopedDeclarations_ModuleBody(code);
    const declaredVarNames = [];

    for (const d of varDeclarations) {
      for (const dn of BoundNames_VariableDeclaration(d)) {
        if (!declaredVarNames.includes(dn)) {
          let _temp14 = envRec.CreateMutableBinding(new Value(dn), Value.false);

          Assert(!(_temp14 instanceof AbruptCompletion), "envRec.CreateMutableBinding(new Value(dn), Value.false)" + ' returned an abrupt completion');

          if (_temp14 instanceof Completion) {
            _temp14 = _temp14.Value;
          }
          envRec.InitializeBinding(new Value(dn), Value.undefined);
          declaredVarNames.push(dn);
        }
      }
    }

    const lexDeclarations = LexicallyScopedDeclarations_Module(code);

    for (const d of lexDeclarations) {
      for (const dn of BoundNames_ModuleItem(d)) {
        if (IsConstantDeclaration(d)) {
          let _temp15 = envRec.CreateImmutableBinding(new Value(dn), Value.true);

          if (_temp15 instanceof AbruptCompletion) {
            return _temp15;
          }

          if (_temp15 instanceof Completion) {
            _temp15 = _temp15.Value;
          }
        } else {
          let _temp16 = envRec.CreateMutableBinding(new Value(dn), Value.false);

          if (_temp16 instanceof AbruptCompletion) {
            return _temp16;
          }

          if (_temp16 instanceof Completion) {
            _temp16 = _temp16.Value;
          }
        }

        if (isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)) {
          const fo = InstantiateFunctionObject(d, env);
          envRec.InitializeBinding(new Value(dn), fo);
        }
      }
    }

    surroundingAgent.executionContextStack.pop(moduleContext);
    return new NormalCompletion(undefined);
  } // 15.2.1.17.5 #sec-source-text-module-record-execute-module


  ExecuteModule(capability) {
    const module = this;
    const moduleContext = module.Context;

    if (module.Async === Value.false) {
      Assert(capability === undefined, "capability === undefined");
      surroundingAgent.executionContextStack.push(moduleContext);
      const result = Evaluate_Module(module.ECMAScriptCode.body);
      surroundingAgent.executionContextStack.pop(moduleContext); // Resume the context that is now on the top of the execution context stack as the running execution context.

      return Completion(result);
    } else {
      Assert(capability instanceof PromiseCapabilityRecord, "capability instanceof PromiseCapabilityRecord");

      let _temp17 = AsyncBlockStart(capability, module.ECMAScriptCode.body, moduleContext);

      Assert(!(_temp17 instanceof AbruptCompletion), "AsyncBlockStart(capability, module.ECMAScriptCode.body, moduleContext)" + ' returned an abrupt completion');

      if (_temp17 instanceof Completion) {
        _temp17 = _temp17.Value;
      }
      return Value.undefined;
    }
  }

}

//   ExportList : ExportList `,` ExportSpecifier
//
// (implicit)
//   ExportList : ExportSpecifier

function ExportEntriesForModule_ExportList(ExportList, module) {
  const specs = [];

  for (const ExportSpecifier of ExportList) {
    specs.push(...ExportEntriesForModule_ExportSpecifier(ExportSpecifier, module));
  }

  return specs;
} // 15.2.3.6 #sec-static-semantics-exportentriesformodule
//   ExportClause : `{` `}`
//
// (implicit)
//   ExportClause :
//     `{` ExportList `}`
//     `{` ExportList `,` `}`

const ExportEntriesForModule_ExportClause = ExportEntriesForModule_ExportList; // 15.2.3.6 #sec-static-semantics-exportentriesformodule
//   ExportSpecifier :
//     IdentifierName
//     IdentifierName `as` IdentifierName

function ExportEntriesForModule_ExportSpecifier(ExportSpecifier, module) {
  const sourceName = new Value(ExportSpecifier.local.name);
  const exportName = new Value(ExportSpecifier.exported.name);
  let localName;
  let importName;

  if (module === Value.null) {
    localName = sourceName;
    importName = Value.null;
  } else {
    localName = Value.null;
    importName = sourceName;
  }

  return [new ExportEntryRecord({
    ModuleRequest: module,
    ImportName: importName,
    LocalName: localName,
    ExportName: exportName
  })];
}

//   ModuleItemList : ModuleItemList ModuleItem
//
// (implicit)
//   ModuleItemList : ModuleItem

function ModuleRequests_ModuleItemList(ModuleItemList) {
  const moduleNames = new Set();

  for (const ModuleItem of ModuleItemList) {
    for (const additionalName of ModuleRequests_ModuleItem(ModuleItem)) {
      moduleNames.add(additionalName);
    }
  }

  return [...moduleNames];
} // (implicit)
//   ModuleItem : StatementListItem
//
// (implicit)
//   ModuleItem : ImportDeclaration
//   ModuleItem : ExportDeclaration

function ModuleRequests_ModuleItem(ModuleItem) {
  switch (true) {
    case isStatementListItem(ModuleItem):
      return [];

    case isImportDeclaration(ModuleItem):
      return ModuleRequests_ImportDeclaration(ModuleItem);

    case isExportDeclaration(ModuleItem):
      return ModuleRequests_ExportDeclaration(ModuleItem);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ModuleRequests_ModuleItem', ModuleItem);
  }
} // 15.2.2.5 #sec-imports-static-semantics-modulerequests
//   ImportDeclaration : `import` ImportClause FromClause `;`

function ModuleRequests_ImportDeclaration(ImportDeclaration) {
  const {
    source: FromClause
  } = ImportDeclaration;
  return ModuleRequests_FromClause(FromClause);
} // 15.2.2.5 #sec-imports-static-semantics-modulerequests
//   ModuleSpecifier : StringLiteral
//
// (implicit)
//   FromClause : `from` ModuleSpecifier

function ModuleRequests_FromClause(FromClause) {
  return [new Value(FromClause.value)];
} // 15.2.3.9 #sec-exports-static-semantics-modulerequests
//   ExportDeclaration :
//     `export` `*` FromClause `;`
//     `export` ExportClause FromClause `;`
//     `export` ExportClause `;`
//     `export` VariableStatement
//     `export` Declaration
//     `export` `default` HoistableDeclaration
//     `export` `default` ClassDeclaration
//     `export` `default` AssignmentExpression `;`

function ModuleRequests_ExportDeclaration(ExportDeclaration) {
  switch (true) {
    case isExportDeclarationWithStar(ExportDeclaration):
    case isExportDeclarationWithExportAndFrom(ExportDeclaration):
      return ModuleRequests_FromClause(ExportDeclaration.source);

    case isExportDeclarationWithExport(ExportDeclaration):
    case isExportDeclarationWithVariable(ExportDeclaration):
    case isExportDeclarationWithDeclaration(ExportDeclaration):
    case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
    case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
    case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
      return [];

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ModuleRequests_ExportDeclaration', ExportDeclaration);
  }
}

//   ModuleItemList : ModuleItemList ModuleItem
//
// (implicit)
//   ModuleItemList : ModuleItem

function ExportEntries_ModuleItemList(ModuleItemList) {
  const entries = [];

  for (const ModuleItem of ModuleItemList) {
    entries.push(...ExportEntries_ModuleItem(ModuleItem));
  }

  return entries;
} // (implicit)
//   ModuleItem :
//     ImportDeclaration
//     StatementListItem
//
// (implicit)
//   ModuleItem : ExportDeclaration

function ExportEntries_ModuleItem(ModuleItem) {
  switch (true) {
    case isImportDeclaration(ModuleItem):
    case isStatementListItem(ModuleItem):
      return [];

    case isExportDeclaration(ModuleItem):
      return ExportEntries_ExportDeclaration(ModuleItem);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ExportEntries_ModuleItem', ModuleItem);
  }
} // 15.2.3.5 #sec-exports-static-semantics-exportentries
//   ExportDeclaration :
//     `export` `*` FromClause `;`
//     `export` ExportClause FromClause `;`
//     `export` ExportClause `;`
//     `export` VariableStatement
//     `export` Declaration
//     `export` `default` HoistableDeclaration
//     `export` `default` ClassDeclaration
//     `export` `default` AssignmentExpression `;`

function ExportEntries_ExportDeclaration(ExportDeclaration) {
  switch (true) {
    case isExportDeclarationWithStar(ExportDeclaration):
      {
        const FromClause = ExportDeclaration.source;
        const modules = ModuleRequests_FromClause(FromClause);
        Assert(modules.length === 1, "modules.length === 1");
        const [module] = modules;
        const entry = new ExportEntryRecord({
          ModuleRequest: module,
          ImportName: new Value('*'),
          LocalName: Value.null,
          ExportName: Value.null
        });
        return [entry];
      }

    case isExportDeclarationWithExportAndFrom(ExportDeclaration):
      {
        const {
          specifiers: ExportClause,
          source: FromClause
        } = ExportDeclaration;
        const modules = ModuleRequests_FromClause(FromClause);
        Assert(modules.length === 1, "modules.length === 1");
        const [module] = modules;
        return ExportEntriesForModule_ExportClause(ExportClause, module);
      }

    case isExportDeclarationWithExport(ExportDeclaration):
      {
        const ExportClause = ExportDeclaration.specifiers;
        return ExportEntriesForModule_ExportClause(ExportClause, Value.null);
      }

    case isExportDeclarationWithVariable(ExportDeclaration):
      {
        const VariableStatement = ExportDeclaration.declaration;
        const entries = [];
        const names = BoundNames_VariableStatement(VariableStatement);

        for (const name of names) {
          entries.push(new ExportEntryRecord({
            ModuleRequest: Value.null,
            ImportName: Value.null,
            LocalName: new Value(name),
            ExportName: new Value(name)
          }));
        }

        return entries;
      }

    case isExportDeclarationWithDeclaration(ExportDeclaration):
      {
        const Declaration = ExportDeclaration.declaration;
        const entries = [];
        const names = BoundNames_Declaration(Declaration);

        for (const name of names) {
          entries.push(new ExportEntryRecord({
            ModuleRequest: Value.null,
            ImportName: Value.null,
            LocalName: new Value(name),
            ExportName: new Value(name)
          }));
        }

        return entries;
      }

    case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
      {
        const HoistableDeclaration = ExportDeclaration.declaration;
        const names = BoundNames_HoistableDeclaration(HoistableDeclaration);
        Assert(names.length === 1, "names.length === 1");
        const [localName] = names;
        return [new ExportEntryRecord({
          ModuleRequest: Value.null,
          ImportName: Value.null,
          LocalName: new Value(localName),
          ExportName: new Value('default')
        })];
      }

    case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
      {
        const ClassDeclaration = ExportDeclaration.declaration;
        const names = BoundNames_ClassDeclaration(ClassDeclaration);
        Assert(names.length === 1, "names.length === 1");
        const [localName] = names;
        return [new ExportEntryRecord({
          ModuleRequest: Value.null,
          ImportName: Value.null,
          LocalName: new Value(localName),
          ExportName: new Value('default')
        })];
      }

    case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
      return [new ExportEntryRecord({
        ModuleRequest: Value.null,
        ImportName: Value.null,
        LocalName: new Value('*default*'),
        ExportName: new Value('default')
      })];

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ExportEntries_ExportDeclaration', ExportDeclaration);
  }
}

//   SingleNameBinding :
//     BindingIdentifier
//     BindingIdentifier Initializer

function HasInitializer_SingleNameBinding(SingleNameBinding) {
  switch (true) {
    case isBindingIdentifier(SingleNameBinding):
      return false;

    case isBindingIdentifierAndInitializer(SingleNameBinding):
      return true;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('HasInitializer_SingleNameBinding', SingleNameBinding);
  }
} // 13.3.3.3 #sec-destructuring-binding-patterns-static-semantics-hasinitializer
//   BindingElement :
//     BindingPattern
//     BindingPattern Initializer
//
// (implicit)
//   BindingElement : SingleNameBinding

function HasInitializer_BindingElement(BindingElement) {
  switch (true) {
    case isBindingPattern(BindingElement):
      return false;

    case isBindingPatternAndInitializer(BindingElement):
      return true;

    case isSingleNameBinding(BindingElement):
      return HasInitializer_SingleNameBinding(BindingElement);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('HasInitializer_BindingElement', BindingElement);
  }
} // 14.1.8 #sec-function-definitions-static-semantics-hasinitializer
//   FormalParameterList : FormalParameterList `,` FormalParameter
// is implemented directly as part of ExpectedArgumentCount for FormalParameters.

//   PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
//
// 14.1.9 #sec-function-definitions-static-semantics-hasname
//   FunctionExpression :
//     `function` `(` FormalParameters `)` `{` FunctionBody `}`
//     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
//
// 14.2.7 #sec-arrow-function-definitions-static-semantics-hasname
//   ArrowFunction : ArrowParameters `=>` ConciseBody
//
// 14.4.6 #sec-generator-function-definitions-static-semantics-hasname
//   GeneratorExpression :
//     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
//     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
//
// 14.5.6 #sec-async-generator-function-definitions-static-semantics-hasname
//   AsyncGeneratorExpression :
//     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
//     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
//
// 14.6.6 #sec-class-definitions-static-semantics-hasname
//   ClassExpression :
//     `class` ClassTail
//     `class` BindingIdentifier ClassTail
//
// 14.7.6 #sec-async-function-definitions-static-semantics-HasName
//   AsyncFunctionExpression :
//     `async` [no LineTerminator here] `function` `(` FormalParameters `)`
//       `{` AsyncFunctionBody `}`
//     `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)`
//       `{` AsyncFunctionBody `}`
//
// 14.8.7 #sec-async-arrow-function-definitions-static-semantics-HasName
//   AsyncArrowFunction:
//     `async` [no LineTerminator here] AsyncArrowBindingIdentifier [no LineTerminator here]
//       `=>` AsyncConciseBody
//     CoverCallExpressionAndAsyncArrowHead [no LineTerminator here] `=>` AsyncConciseBody
//
// (implicit)
//   ParenthesizedExpression : `(` Expression `)`
//
//   PrimaryExpression :
//     FunctionExpression
//     ClassExpression
//     GeneratorExpression
//     AsyncFunctionExpression
//     AsyncGeneratorExpression
//     ArrowFunction
//
//   MemberExpression : PrimaryExpression
//
//   (From MemberExpression to ConditionalExpression omitted.)
//
//   AssignmentExpression :
//     ConditionalExpression
//     ArrowFunction
//     AsyncArrowFunction
//
//   Expression : AssignmentExpression

function HasName_Expression(Expression) {
  switch (true) {
    case isFunctionExpression(Expression):
    case isGeneratorExpression(Expression):
    case isAsyncGeneratorExpression(Expression):
    case isClassExpression(Expression):
    case isAsyncFunctionExpression(Expression):
      return Expression.id !== null;

    case isArrowFunction(Expression):
    case isAsyncArrowFunction(Expression):
      return false;

    case isParenthesizedExpression(Expression):
      {
        const expr = Expression.expression;

        if (!IsFunctionDefinition_Expression(expr)) {
          return false;
        }

        return HasName_Expression(expr);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('HasName_Expression', Expression);
  }
}

//   ImportClause :
//     ImportedDefaultBinding `,` NameSpaceImport
//     ImportedDefaultBinding `,` NamedImports
//
//   NamedImports : `{` `}`
//
//   ImportsList : ImportsList `,` ImportSpecifier
//
// (implicit)
//   ImportClause :
//     ImportedDefaultBinding
//     NameSpaceImport
//     NamedImports
//
//   NamedImports :
//     `{` ImportsList `}`
//     `{` ImportsList `,` `}`
//
//   ImportsList : ImportSpecifier

function ImportEntriesForModule_ImportClause(ImportClause, module) {
  const entries = [];

  for (const binding of ImportClause) {
    switch (true) {
      case isImportedDefaultBinding(binding):
        entries.push(...ImportEntriesForModule_ImportedDefaultBinding(binding, module));
        break;

      case isNameSpaceImport(binding):
        entries.push(...ImportEntriesForModule_NameSpaceImport(binding, module));
        break;

      case isImportSpecifier(binding):
        entries.push(...ImportEntriesForModule_ImportSpecifier(binding, module));
        break;

      /*istanbul ignore next*/
      default:
        throw new OutOfRange('ImportEntriesForModule_ImportClause binding', binding);
    }
  }

  return entries;
} // 15.2.2.4 #sec-static-semantics-importentriesformodule
//   ImportedDefaultBinding : ImportedBinding

function ImportEntriesForModule_ImportedDefaultBinding(ImportedDefaultBinding, module) {
  const ImportedBinding = ImportedDefaultBinding.local;
  const localNames = BoundNames_ImportedBinding(ImportedBinding);
  Assert(localNames.length === 1, "localNames.length === 1");
  const [localName] = localNames;
  const defaultEntry = new ImportEntryRecord({
    ModuleRequest: module,
    ImportName: new Value('default'),
    LocalName: new Value(localName)
  });
  return [defaultEntry];
} // 15.2.2.4 #sec-static-semantics-importentriesformodule
//   NameSpaceImport : `*` `as` ImportedBinding

function ImportEntriesForModule_NameSpaceImport(NameSpaceImport, module) {
  const ImportedBinding = NameSpaceImport.local;
  const localNames = BoundNames_ImportedBinding(ImportedBinding);
  Assert(localNames.length === 1, "localNames.length === 1");
  const [localName] = localNames;
  const entry = new ImportEntryRecord({
    ModuleRequest: module,
    ImportName: new Value('*'),
    LocalName: new Value(localName)
  });
  return [entry];
} // 15.2.2.4 #sec-static-semantics-importentriesformodule
//   ImportSpecifier :
//     ImportedBinding
//     IdentifierName `as` ImportedBinding

function ImportEntriesForModule_ImportSpecifier(ImportSpecifier, module) {
  const {
    imported: IdentifierName,
    local: ImportedBinding
  } = ImportSpecifier;
  const importName = IdentifierName.name;
  const localName = ImportedBinding.name;
  const entry = new ImportEntryRecord({
    ModuleRequest: module,
    ImportName: new Value(importName),
    LocalName: new Value(localName)
  });
  return [entry];
}

//   ModuleItemList : ModuleItemList ModuleItem
//
// (implicit)
//   ModuleItemList : ModuleItem

function ImportEntries_ModuleItemList(ModuleItemList) {
  const entries = [];

  for (const ModuleItem of ModuleItemList) {
    entries.push(...ImportEntries_ModuleItem(ModuleItem));
  }

  return entries;
} // (implicit)
//   ModuleItem :
//     ExportDeclaration
//     StatementListItem
//
// (implicit)
//   ModuleItem : ImportDeclaration

function ImportEntries_ModuleItem(ModuleItem) {
  switch (true) {
    case isExportDeclaration(ModuleItem):
    case isStatementListItem(ModuleItem):
      return [];

    case isImportDeclaration(ModuleItem):
      return ImportEntries_ImportDeclaration(ModuleItem);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ImportEntries_ModuleItem', ModuleItem);
  }
} // 15.2.2.3 #sec-imports-static-semantics-importentries
//   ImportDeclaration :
//     `import` ImportClause FromClause `;`
//     `import` ModuleSpecifier `;`

function ImportEntries_ImportDeclaration(ImportDeclaration) {
  switch (true) {
    case isImportDeclarationWithClause(ImportDeclaration):
      {
        const {
          specifiers: ImportClause,
          source: FromClause
        } = ImportDeclaration;
        const reqs = ModuleRequests_FromClause(FromClause);
        Assert(reqs.length === 1, "reqs.length === 1");
        const [module] = reqs;
        return ImportEntriesForModule_ImportClause(ImportClause, module);
      }

    case isImportDeclarationWithSpecifierOnly(ImportDeclaration):
      return [];

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ImportEntries_ImportDeclaration', ImportDeclaration);
  }
}

// 15.2.1.9 #sec-importedlocalnames
function ImportedLocalNames(importEntries) {
  const localNames = [];

  for (const i of importEntries) {
    localNames.push(i.LocalName);
  }

  return localNames;
}

function IsAnonymousFunctionDefinition(expr) {
  if (IsFunctionDefinition_Expression(expr) === false) {
    return false;
  }

  const hasName = HasName_Expression(expr);

  if (hasName === true) {
    return false;
  }

  return true;
}

function IsConstantDeclaration(node) {
  return node.kind === 'const';
}

//   MemberExpression :
//     PrimaryExpression
//     MemberExpression `[` Expression `]`
//     MemberExpression `.` IdentifierName
//     MemberExpression TemplateLiteral
//     SuperProperty
//     MetaProperty
//     `new` MemberExpression Arguments
//
//   NewExpression : `new` NewExpression
//
//   LeftHandSideExpression : CallExpression
//
// (implicit)
//   NewExpression : MemberExpression
//
//   LeftHandSideExpression : NewExpression

function IsDestructuring_LeftHandSideExpression(LeftHandSideExpression) {
  switch (true) {
    case isExpression(LeftHandSideExpression):
      Assert(!isBindingPattern(LeftHandSideExpression), "!isBindingPattern(LeftHandSideExpression)");
      return false;

    case isBindingPattern(LeftHandSideExpression):
      return true;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('IsDestructuring_LeftHandSideExpression', LeftHandSideExpression);
  }
} // 13.7.5.6 #sec-for-in-and-for-of-statements-static-semantics-isdestructuring
//   ForDeclaration : LetOrConst ForBinding

function IsDestructuring_ForDeclaration(ForDeclaration) {
  return IsDestructuring_ForBinding(ForDeclaration.declarations[0].id);
} // 13.7.5.6 #sec-for-in-and-for-of-statements-static-semantics-isdestructuring
//   ForBinding :
//     BindingIdentifier
//     BindingPattern

function IsDestructuring_ForBinding(ForBinding) {
  switch (true) {
    case isBindingIdentifier(ForBinding):
      return false;

    case isBindingPattern(ForBinding):
      return true;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('IsDestructuring_ForBinding', ForBinding);
  }
}

// for this static semantic:
//
// 12.15.2 #sec-assignment-operators-static-semantics-isfunctiondefinition
//   AssignmentExpression :
//     ArrowFunction
//     AsyncArrowFunction
//
// 14.1.12 #sec-function-definitions-static-semantics-isfunctiondefinition
//   FunctionExpression :
//     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
//
// 14.4.8 #sec-generator-function-definitions-static-semantics-isfunctiondefinition
//   GeneratorExpression :
//     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
//
// 14.5.8 #sec-async-generator-function-definitions-static-semantics-isfunctiondefinition
//   AsyncGeneratorExpression :
//     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
//
// 14.6.8 #sec-class-definitions-static-semantics-isfunctiondefinition
//   ClassExpression : `class` BindingIdentifier_opt ClassTail
//
// 14.7.8 #sec-async-function-definitions-static-semantics-IsFunctionDefinition
//   AsyncFunctionExpression :
//     `async` [no LineTerminator here] `function` `(` FormalParameters `)`
//       `{` AsyncFunctionBody `}`
//     `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)`
//       `{` AsyncFunctionBody `}`
//
// The following sections contain other special cases for
// ParenthesizedExpressions:
//
// 12.2.1.3 #sec-semantics-static-semantics-isfunctiondefinition
//   PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
//
// 12.2.10.2 #sec-grouping-operator-static-semantics-isfunctiondefinition
//   ParenthesizedExpression : `(` Expression `)`
//
// All other explicit and implicit productions return false, including those
// specified at the following anchors:
//
// 12.2.1.3 #sec-semantics-static-semantics-isfunctiondefinition
// 12.3.1.3 #sec-static-semantics-static-semantics-isfunctiondefinition
// 12.4.2 #sec-update-expressions-static-semantics-isfunctiondefinition
// 12.5.1 #sec-unary-operators-static-semantics-isfunctiondefinition
// 12.6.1 #sec-exp-operator-static-semantics-isfunctiondefinition
// 12.7.1 #sec-multiplicative-operators-static-semantics-isfunctiondefinition
// 12.8.1 #sec-additive-operators-static-semantics-isfunctiondefinition
// 12.9.1 #sec-bitwise-shift-operators-static-semantics-isfunctiondefinition
// 12.10.1 #sec-relational-operators-static-semantics-isfunctiondefinition
// 12.11.1 #sec-equality-operators-static-semantics-isfunctiondefinition
// 12.12.1 #sec-binary-bitwise-operators-static-semantics-isfunctiondefinition
// 12.13.1 #sec-binary-logical-operators-static-semantics-isfunctiondefinition
// 12.14.1 #sec-conditional-operator-static-semantics-isfunctiondefinition
// 12.15.2 #sec-assignment-operators-static-semantics-isfunctiondefinition
// 12.16.1 #sec-comma-operator-static-semantics-isfunctiondefinition

function IsFunctionDefinition_Expression(Expression) {
  if (isParenthesizedExpression(Expression)) {
    const expr = Expression.expression;
    return IsFunctionDefinition_Expression(expr);
  }

  return isArrowFunction(Expression) || isAsyncArrowFunction(Expression) || isFunctionExpression(Expression) || isGeneratorExpression(Expression) || isAsyncGeneratorExpression(Expression) || isClassExpression(Expression) || isAsyncFunctionExpression(Expression);
}

//   PrimaryExpression :
//     IdentifierReference
//     ... (omitted)
//
// 12.3.1.5 #sec-static-semantics-static-semantics-isidentifierref
//   ... (omitted)

function IsIdentifierRef(node) {
  return isIdentifierReference(node);
}

//   BindingElement :
//     BindingPattern
//     BindingPattern Initializer
//
// (implicit)
//   BindingElement : SingleNameBinding

function IsSimpleParameterList_BindingElement(BindingElement) {
  switch (true) {
    case isSingleNameBinding(BindingElement):
      return IsSimpleParameterList_SingleNameBinding(BindingElement);

    case isBindingPattern(BindingElement):
    case isBindingPatternAndInitializer(BindingElement):
      return false;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('IsSimpleParameterList_BindingElement', BindingElement);
  }
} // 13.3.3.4 #sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist
//   SingleNameBinding :
//     BindingIdentifier
//     BindingIdentifier Initializer

function IsSimpleParameterList_SingleNameBinding(SingleNameBinding) {
  switch (true) {
    case isBindingIdentifier(SingleNameBinding):
      return true;

    case isBindingIdentifierAndInitializer(SingleNameBinding):
      return false;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('IsSimpleParameterList_SingleNameBinding', SingleNameBinding);
  }
} // 14.1.13 #sec-function-definitions-static-semantics-issimpleparameterlist
//   FormalParameters :
//     [empty]
//     FormalParameterList `,` FunctionRestParameter
//
// (implicit)
//   FormalParameters :
//     FormalParameterList
//     FormalParameterList `,`
//
// https://github.com/tc39/ecma262/pull/1301
//   FormalParameters : FunctionRestParameter

function IsSimpleParameterList_FormalParameters(FormalParameters) {
  if (FormalParameters.length === 0) {
    return true;
  }

  if (isFunctionRestParameter(FormalParameters[FormalParameters.length - 1])) {
    return false;
  }

  return IsSimpleParameterList_FormalParameterList(FormalParameters);
} // 14.1.13 #sec-function-definitions-static-semantics-issimpleparameterlist
//   FormalParameterList :
//     FormalParameter
//     FormalParameterList `,` FormalParameter

function IsSimpleParameterList_FormalParameterList(FormalParameterList) {
  for (const FormalParameter of FormalParameterList) {
    if (IsSimpleParameterList_FormalParameter(FormalParameter) === false) {
      return false;
    }
  }

  return true;
} // TODO(TimothyGu): does not need to be explicitly declared
// 14.1.13 #sec-function-definitions-static-semantics-issimpleparameterlist
//   FormalParameter : BindingElement

const IsSimpleParameterList_FormalParameter = IsSimpleParameterList_BindingElement;

// 14.6.9 #sec-static-semantics-isstatic
//   ClassElement :
//     MethodDefinition
//     `static` MethodDefinition
//     `;`
function IsStatic_ClassElement(ClassElement) {
  return ClassElement.static;
}

function IsStrict(node) {
  return isStrictModeCode(node);
}

//   StatementList : StatementList StatementListItem
//
// (implicit)
//   StatementList : StatementListItem

function TopLevelLexicallyDeclaredNames_StatementList(StatementList) {
  const names = [];

  for (const StatementListItem of StatementList) {
    names.push(...TopLevelLexicallyDeclaredNames_StatementListItem(StatementListItem));
  }

  return names;
} // 13.2.7 #sec-block-static-semantics-toplevellexicallydeclarednames
//   StatementListItem :
//     Statement
//     Declaration

function TopLevelLexicallyDeclaredNames_StatementListItem(StatementListItem) {
  switch (true) {
    case isStatement(StatementListItem):
      return [];

    case isDeclaration(StatementListItem):
      if (isHoistableDeclaration(StatementListItem)) {
        return [];
      }

      return BoundNames_Declaration(StatementListItem);

    default:
      throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
  }
}

//   StatementList : StatementList StatementListItem

function TopLevelVarDeclaredNames_StatementList(StatementList) {
  const names = [];

  for (const StatementListItem of StatementList) {
    names.push(...TopLevelVarDeclaredNames_StatementListItem(StatementListItem));
  }

  return names;
} // 13.2.9 #sec-block-static-semantics-toplevelvardeclarednames
//   StatementListItem :
//     Declaration
//     Statement

function TopLevelVarDeclaredNames_StatementListItem(StatementListItem) {
  switch (true) {
    case isDeclaration(StatementListItem):
      if (isHoistableDeclaration(StatementListItem)) {
        return BoundNames_HoistableDeclaration(StatementListItem);
      }

      return [];

    case isStatement(StatementListItem):
      if (isLabelledStatement(StatementListItem)) {
        return TopLevelVarDeclaredNames_LabelledStatement(StatementListItem);
      }

      return VarDeclaredNames_Statement(StatementListItem);

    default:
      throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
  }
} // 13.13.10 #sec-labelled-statements-static-semantics-toplevelvardeclarednames
//   LabelledStatement : LabelIdentifier `:` LabelledItem

function TopLevelVarDeclaredNames_LabelledStatement(LabelledStatement) {
  return TopLevelVarDeclaredNames_LabelledItem(LabelledStatement.body);
} // 13.13.10 #sec-labelled-statements-static-semantics-toplevelvardeclarednames
//   LabelledItem :
//     Statement
//     FunctionDeclaration

function TopLevelVarDeclaredNames_LabelledItem(LabelledItem) {
  switch (true) {
    case isStatement(LabelledItem):
      if (isLabelledStatement(LabelledItem)) {
        return TopLevelVarDeclaredNames_LabelledItem(LabelledItem.body);
      }

      return VarDeclaredNames_Statement(LabelledItem);

    case isFunctionDeclaration(LabelledItem):
      return BoundNames_FunctionDeclaration(LabelledItem);

    default:
      throw new TypeError(`Unexpected LabelledItem: ${LabelledItem.type}`);
  }
}

//   Statement :
//     EmptyStatement
//     ExpressionStatement
//     ContinueStatement
//     ContinueStatement
//     BreakStatement
//     ReturnStatement
//     ThrowStatement
//     DebuggerStatement
//
// (implicit)
//   Statement :
//     BlockStatement
//     VariableStatement
//     IfStatement
//     BreakableStatement
//     WithStatement
//     LabelledStatement
//     TryStatement
//   BreakableStatement :
//     IterationStatement
//     SwitchStatement

function VarDeclaredNames_Statement(Statement) {
  switch (true) {
    case isEmptyStatement(Statement):
    case isExpressionStatement(Statement):
    case isContinueStatement(Statement):
    case isBreakStatement(Statement):
    case isReturnStatement(Statement):
    case isThrowStatement(Statement):
    case isDebuggerStatement(Statement):
      return [];

    case isBlockStatement(Statement):
      return VarDeclaredNames_BlockStatement(Statement);

    case isVariableStatement(Statement):
      return VarDeclaredNames_VariableStatement(Statement);

    case isIfStatement(Statement):
      return VarDeclaredNames_IfStatement(Statement);

    case isWithStatement(Statement):
      return VarDeclaredNames_WithStatement(Statement);

    case isLabelledStatement(Statement):
      return VarDeclaredNames_LabelledStatement(Statement);

    case isTryStatement(Statement):
      return VarDeclaredNames_TryStatement(Statement);

    case isIterationStatement(Statement):
      return VarDeclaredNames_IterationStatement(Statement);

    case isSwitchStatement(Statement):
      return VarDeclaredNames_SwitchStatement(Statement);

    default:
      throw new TypeError(`Invalid Statement: ${Statement.type}`);
  }
} // 13.2.11 #sec-block-static-semantics-vardeclarednames
//   StatementList : StatementList StatementListItem
//
// (implicit)
//   StatementList : StatementListItem

function VarDeclaredNames_StatementList(StatementList) {
  const names = [];

  for (const StatementListItem of StatementList) {
    names.push(...VarDeclaredNames_StatementListItem(StatementListItem));
  }

  return names;
} // 13.2.11 #sec-block-static-semantics-vardeclarednames
//   Block : `{` `}`
//
// (implicit)
//   Block : `{` StatementList `}`

function VarDeclaredNames_Block(Block) {
  return VarDeclaredNames_StatementList(Block.body);
} // (implicit)
//   BlockStatement : Block

const VarDeclaredNames_BlockStatement = VarDeclaredNames_Block; // 13.2.11 #sec-block-static-semantics-vardeclarednames
//   StatementListItem : Declaration
//
// (implicit)
//   StatementListItem : Statement

function VarDeclaredNames_StatementListItem(StatementListItem) {
  switch (true) {
    case isDeclaration(StatementListItem):
      return [];

    case isStatement(StatementListItem):
      return VarDeclaredNames_Statement(StatementListItem);

    default:
      throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
  }
} // 13.3.2.2 #sec-variable-statement-static-semantics-vardeclarednames
//   VariableStatement : `var` VariableDeclarationList `;`

const VarDeclaredNames_VariableStatement = BoundNames_VariableStatement; // 13.6.5 #sec-if-statement-static-semantics-vardeclarednames
//   IfStatement :
//     `if` `(` Expression `)` Statement `else` Statement
//     `if` `(` Expression `)` Statement

function VarDeclaredNames_IfStatement(IfStatement) {
  if (IfStatement.alternate) {
    return [...VarDeclaredNames_Statement(IfStatement.consequent), ...VarDeclaredNames_Statement(IfStatement.alternate)];
  }

  return VarDeclaredNames_Statement(IfStatement.consequent);
} // 13.7.2.4 #sec-do-while-statement-static-semantics-vardeclarednames
//   IterationStatement : `do` Statement `while` `(` Expression `)` `;`
//
// 13.7.3.4 #sec-while-statement-static-semantics-vardeclarednames
//   IterationStatement : `while` `(` Expression `)` Statement
//
// 13.7.4.5 #sec-for-statement-static-semantics-vardeclarednames
//   IterationStatement :
//     `for` `(` Expression `;` Expression `;` Expression `)` Statement
//     `for` `(` `var` VariableDeclarationList `;` Expression `;` Expression `)` Statement
//     `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
//
// 13.7.5.7 #sec-for-in-and-for-of-statements-static-semantics-vardeclarednames
//   IterationStatement :
//     `for` `(` LeftHandSideExpression `in` Expression `)` Statement
//     `for` `(` `var` ForBinding `in` Expression `)` Statement
//     `for` `(` ForDeclaration `in` Expression `)` Statement
//     `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
//     `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
//     `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
//     `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
//     `for` `(` ForDeclaration `of` Expression `)` Statement
//     `for` `await` `(` ForDeclaration `of` Expression `)` Statement

function VarDeclaredNames_IterationStatement(IterationStatement) {
  let namesFromBinding = [];

  switch (IterationStatement.type) {
    case 'DoWhileStatement':
    case 'WhileStatement':
      break;

    case 'ForStatement':
      if (IterationStatement.init && isVariableStatement(IterationStatement.init)) {
        const VariableDeclarationList = IterationStatement.init.declarations;
        namesFromBinding = BoundNames_VariableDeclarationList(VariableDeclarationList);
      }

      break;

    case 'ForInStatement':
    case 'ForOfStatement':
      // https://github.com/tc39/ecma262/pull/1284
      if (isVariableStatement(IterationStatement.left)) {
        const ForBinding = IterationStatement.left.declarations[0].id;
        namesFromBinding = BoundNames_ForBinding(ForBinding);
      }

      break;

    default:
      throw new TypeError(`Invalid IterationStatement: ${IterationStatement.type}`);
  }

  return [...namesFromBinding, ...VarDeclaredNames_Statement(IterationStatement.body)];
} // 13.11.6 #sec-with-statement-static-semantics-varscopeddeclarations
//   WithStatement : `with` `(` Expression `)` Statement

function VarDeclaredNames_WithStatement(WithStatement) {
  return VarDeclaredNames_Statement(WithStatement.body);
} // 13.12.7 #sec-switch-statement-static-semantics-vardeclarednames
//   SwitchStatement : `switch` `(` Expression `)` CaseBlock

function VarDeclaredNames_SwitchStatement(SwitchStatement) {
  return VarDeclaredNames_CaseBlock(SwitchStatement.cases);
} // 13.12.7 #sec-switch-statement-static-semantics-vardeclarednames
//   CaseBlock :
//     `{` `}`
//     `{` CaseClauses_opt DefaultClause CaseClauses_opt `}`
//   CaseClauses : CaseClauses CaseClause
//   CaseClause : `case` Expression `:` StatementList_opt
//   DefaultClause : `default` `:` StatementList_opt
//
// (implicit)
//   CaseBlock : `{` CaseClauses `}`
//   CaseClauses : CaseClause

function VarDeclaredNames_CaseBlock(CaseBlock) {
  const names = [];

  for (const CaseClauseOrDefaultClause of CaseBlock) {
    names.push(...VarDeclaredNames_StatementList(CaseClauseOrDefaultClause.consequent));
  }

  return names;
} // 13.13.12 #sec-labelled-statements-static-semantics-vardeclarednames
//   LabelledStatement : LabelIdentifier `:` LabelledItem
//   LabelledItem : FunctionDeclaration
//
// (implicit)
//   LabelledItem : Statement

function VarDeclaredNames_LabelledStatement(LabelledStatement) {
  const LabelledItem = LabelledStatement.body;

  switch (true) {
    case isFunctionDeclaration(LabelledItem):
      return [];

    case isStatement(LabelledItem):
      return VarDeclaredNames_Statement(LabelledItem);

    default:
      throw new TypeError(`Invalid LabelledItem: ${LabelledItem.type}`);
  }
} // 13.15.5 #sec-try-statement-static-semantics-vardeclarednames
//   TryStatement :
//     `try` Block Catch
//     `try` Block Finally
//     `try` Block Catch Finally
//   Catch : `catch` `(` CatchParameter `)` Block
//
// (implicit)
//   Catch : `catch` Block
//   Finally : `finally` Block

function VarDeclaredNames_TryStatement(TryStatement) {
  const namesBlock = VarDeclaredNames_Block(TryStatement.block);
  const namesCatch = TryStatement.handler !== null ? VarDeclaredNames_Block(TryStatement.handler.body) : [];
  const namesFinally = TryStatement.finalizer !== null ? VarDeclaredNames_Block(TryStatement.finalizer) : [];
  return [...namesBlock, ...namesCatch, ...namesFinally];
} // 14.1.16 #sec-function-definitions-static-semantics-vardeclarednames
//   FunctionStatementList :
//     [empty]
//     StatementList

const VarDeclaredNames_FunctionStatementList = TopLevelVarDeclaredNames_StatementList; // (implicit)
//   FunctionBody : FunctionStatementList

const VarDeclaredNames_FunctionBody = VarDeclaredNames_FunctionStatementList; // (implicit)
//   GeneratorBody : FunctionBody

const VarDeclaredNames_GeneratorBody = VarDeclaredNames_FunctionBody; // (implicit)
//   AsyncFunctionBody : FunctionBody

const VarDeclaredNames_AsyncFunctionBody = VarDeclaredNames_FunctionBody; // 14.2.12 #sec-arrow-function-definitions-static-semantics-vardeclarednames
//   ConciseBody : ExpressionBody
//
// (implicit)
//   ConciseBody : `{` FunctionBody `}`

function VarDeclaredNames_ConciseBody(ConciseBody) {
  switch (true) {
    case isExpressionBody(ConciseBody):
      return [];

    case isBlockStatement(ConciseBody):
      return VarDeclaredNames_FunctionBody(ConciseBody.body);

    default:
      throw new TypeError(`Unexpected ConciseBody: ${ConciseBody.type}`);
  }
} // 14.8.11 #sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames
//   ScriptBody : StatementList

const VarDeclaredNames_ScriptBody = TopLevelVarDeclaredNames_StatementList; // (implicit)

//   FunctionStatementList :
//     [empty]
//     StatementList

const LexicallyDeclaredNames_FunctionStatementList = TopLevelLexicallyDeclaredNames_StatementList; // (implicit)
//   FunctionBody : FunctionStatementList

const LexicallyDeclaredNames_FunctionBody = LexicallyDeclaredNames_FunctionStatementList; // (implicit)
//   GeneratorBody : FunctionBody

const LexicallyDeclaredNames_GeneratorBody = LexicallyDeclaredNames_FunctionBody; // (implicit)
//   AsyncFunctionBody : FunctionBody

const LexicallyDeclaredNames_AsyncFunctionBody = LexicallyDeclaredNames_FunctionBody; // (implicit)
//   ConciseBody : ExpressionBody
//
// (implicit)
//   ConciseBody : `{` FunctionBody `}`

function LexicallyDeclaredNames_ConciseBody(ConciseBody) {
  switch (true) {
    case isExpressionBody(ConciseBody):
      return [];

    case isBlockStatement(ConciseBody):
      return LexicallyDeclaredNames_FunctionBody(ConciseBody.body);

    default:
      throw new TypeError(`Unexpected ConciseBody: ${ConciseBody.type}`);
  }
} // 14.8.9 #sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames
//   ScriptBody : StatementList

const LexicallyDeclaredNames_ScriptBody = TopLevelLexicallyDeclaredNames_StatementList;

//   StatementList : StatementList StatementListItem
//
// (implicit)
//   StatementList : StatementListItem

function LexicallyScopedDeclarations_StatementList(StatementList) {
  const declarations = [];

  for (const StatementListItem of StatementList) {
    declarations.push(...LexicallyScopedDeclarations_StatementListItem(StatementListItem));
  }

  return declarations;
} // 13.2.6 #sec-block-static-semantics-lexicallyscopeddeclarations
//   StatementListItem :
//     Statement
//     Declaration

function LexicallyScopedDeclarations_StatementListItem(StatementListItem) {
  switch (true) {
    case isStatement(StatementListItem):
      if (isLabelledStatement(StatementListItem)) {
        return LexicallyScopedDeclarations_LabelledStatement(StatementListItem);
      }

      return [];

    case isDeclaration(StatementListItem):
      return [DeclarationPart_Declaration(StatementListItem)];

    case isSwitchCase(StatementListItem):
      return LexicallyScopedDeclarations_StatementList(StatementListItem.consequent);

    default:
      throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
  }
} // 13.13.7 #sec-labelled-statements-static-semantics-lexicallyscopeddeclarations
//   LabelledStatement : LabelIdentifier `:` LabelledItem

function LexicallyScopedDeclarations_LabelledStatement(LabelledStatement) {
  return LexicallyScopedDeclarations_LabelledItem(LabelledStatement.body);
} // 13.13.7 #sec-labelled-statements-static-semantics-lexicallyscopeddeclarations
//   LabelledItem :
//     Statement
//     FunctionDeclaration

function LexicallyScopedDeclarations_LabelledItem(LabelledItem) {
  switch (true) {
    case isStatement(LabelledItem):
      return [];

    case isFunctionDeclaration(LabelledItem):
      return [LabelledItem];

    default:
      throw new TypeError(`Unexpected LabelledItem: ${LabelledItem.type}`);
  }
} // 14.1.14 #sec-function-definitions-static-semantics-lexicallydeclarednames
//   FunctionStatementList :
//     [empty]
//     StatementList

const // eslint-disable-next-line max-len
LexicallyScopedDeclarations_FunctionStatementList = TopLevelLexicallyScopedDeclarations_StatementList; // (implicit)
//   FunctionBody : FunctionStatementList

const LexicallyScopedDeclarations_FunctionBody = LexicallyScopedDeclarations_FunctionStatementList; // (implicit)
//   GeneratorBody : FunctionBody
//   AsyncFunctionBody : FunctionBody

const LexicallyScopedDeclarations_GeneratorBody = LexicallyScopedDeclarations_FunctionBody;
const LexicallyScopedDeclarations_AsyncFunctionBody = LexicallyScopedDeclarations_FunctionBody; // 14.2.11 #sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations
//   ConciseBody : ExpressionBody
//
// (implicit)
//   ConciseBody : `{` FunctionBody `}`

function LexicallyScopedDeclarations_ConciseBody(ConciseBody) {
  switch (true) {
    case isExpressionBody(ConciseBody):
      return [];

    case isBlockStatement(ConciseBody):
      return LexicallyScopedDeclarations_FunctionBody(ConciseBody.body);

    default:
      throw new TypeError(`Unexpected ConciseBody: ${ConciseBody.type}`);
  }
} // 14.8.10 #sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations
//   ScriptBody : StatementList

const LexicallyScopedDeclarations_ScriptBody = TopLevelLexicallyScopedDeclarations_StatementList; // 15.2.3.8 #sec-exports-static-semantics-lexicallyscopeddeclarations
//   ExportDeclaration :
//     `export` `*` FromClause `;`
//     `export` ExportClause FromClause `;`
//     `export` ExportClause `;`
//     `export` VariableStatement
//     `export` Declaration
//     `export` `default` HoistableDeclaration
//     `export` `default` ClassDeclaration
//     `export` `default` AssignmentExpression `;`

function LexicallyScopedDeclarations_ExportDeclaration(ExportDeclaration) {
  switch (true) {
    case isExportDeclarationWithStar(ExportDeclaration):
    case isExportDeclarationWithExportAndFrom(ExportDeclaration):
    case isExportDeclarationWithExport(ExportDeclaration):
    case isExportDeclarationWithVariable(ExportDeclaration):
      return [];

    case isExportDeclarationWithDeclaration(ExportDeclaration):
      return [DeclarationPart_Declaration(ExportDeclaration.declaration)];

    case isExportDeclarationWithDefaultAndHoistable(ExportDeclaration):
      return [DeclarationPart_HoistableDeclaration(ExportDeclaration.declaration)];

    case isExportDeclarationWithDefaultAndClass(ExportDeclaration):
      return [ExportDeclaration.declaration];

    case isExportDeclarationWithDefaultAndExpression(ExportDeclaration):
      return [ExportDeclaration];

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('LexicallyScopedDeclarations_ExportDeclaration', ExportDeclaration);
  }
} // 15.2.1.12 #sec-module-semantics-static-semantics-lexicallyscopeddeclarations
//   ModuleItem : ImportDeclaration
//
// (implicit)
//   ModuleItem :
//     ExportDeclaration
//     StatementListItem

function LexicallyScopedDeclarations_ModuleItem(ModuleItem) {
  switch (true) {
    case isImportDeclaration(ModuleItem):
      return [];

    case isExportDeclaration(ModuleItem):
      return LexicallyScopedDeclarations_ExportDeclaration(ModuleItem);

    case isStatementListItem(ModuleItem):
      return LexicallyScopedDeclarations_StatementListItem(ModuleItem);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('LexicallyScopedDeclarations_ModuleItem', ModuleItem);
  }
} // 15.2.1.12 #sec-module-semantics-static-semantics-lexicallyscopeddeclarations
//   ModuleItemList : ModuleItemList ModuleItem
//
// (implicit)
//   ModuleItemList : ModuleItem

function LexicallyScopedDeclarations_ModuleItemList(ModuleItemList) {
  const declarations = [];

  for (const ModuleItem of ModuleItemList) {
    declarations.push(...LexicallyScopedDeclarations_ModuleItem(ModuleItem));
  }

  return declarations;
} // (implicit)
//   ModuleBody : ModuleItemList

const LexicallyScopedDeclarations_ModuleBody = LexicallyScopedDeclarations_ModuleItemList; // 15.2.1.12 #sec-module-semantics-static-semantics-lexicallyscopeddeclarations
//   Module : [empty]
//
// (implicit)
//   Module : ModuleBody

const LexicallyScopedDeclarations_Module = LexicallyScopedDeclarations_ModuleBody;

const {
  ParserRules: ParserRules$2
} = grammar;
const NumericLiteralGrammar = nearley.Grammar.fromCompiled({
  ParserRules: ParserRules$2,
  ParserStart: 'NumericLiteral'
}); // 11.8.3.1 #sec-static-semantics-mv
//   NumericLiteral ::
//     DecimalLiteral
//     BinaryIntegerLiteral
//     OctalIntegerLiteral
//     HexIntegerLiteral

function MV_NumericLiteral(NumericLiteral) {
  const parser = new nearley.Parser(NumericLiteralGrammar);

  try {
    parser.feed(NumericLiteral);
  } catch (err) {
    return NaN;
  }

  Assert(parser.results.length === 1, "parser.results.length === 1");
  return parser.results[0].toNumber();
}

// 14.6.10 #sec-static-semantics-nonconstructormethoddefinitions
//   ClassElementList :
//     ClassElement
//     ClassElementList ClassElement
function NonConstructorMethodDefinitions_ClassElementList(ClassElementList) {
  return ClassElementList.filter(ClassElement => ClassElement.kind !== 'constructor');
} // (implicit)
//   ClassBody : ClassElementList


const NonConstructorMethodDefinitions_ClassBody = NonConstructorMethodDefinitions_ClassElementList;

//   NoSubstitutionTemplate ::
//     `\`` `\``
//     `\`` TemplateCharacters `\``

function TRV_NoSubstitutionTemplate(NoSubstitutionTemplate) {
  if (NoSubstitutionTemplate.quasis.length !== 1) {
    throw new OutOfRange('TRV_NoSubstitutionTemplate', NoSubstitutionTemplate);
  }

  return TRV_TemplateCharacters(NoSubstitutionTemplate.quasis[0]);
} // 11.8.6.1 #sec-static-semantics-tv-and-trv
//   TemplateCharacters ::
//     TemplateCharacter
//     TemplateCharacter TemplateCharacters

function TRV_TemplateCharacters(TemplateCharacters) {
  Assert(typeof TemplateCharacters.value.raw === 'string', "typeof TemplateCharacters.value.raw === 'string'");
  return TemplateCharacters.value.raw;
} // 11.8.6.1 #sec-static-semantics-tv-and-trv
//   TemplateHead ::
//     `\`` `${`
//     `\`` TemplateCharacters `${`

const TRV_TemplateHead = TRV_TemplateCharacters; // 11.8.6.1 #sec-static-semantics-tv-and-trv
//   TemplateMiddle ::
//     `}` `${`
//     `}` TemplateCharacters `${`

const TRV_TemplateMiddle = TRV_TemplateCharacters; // 11.8.6.1 #sec-static-semantics-tv-and-trv
//   TemplateTail ::
//     `}` `\``
//     `}` TemplateCharacters `\``

const TRV_TemplateTail = TRV_TemplateCharacters;

//   NoSubstitutionTemplate ::
//     `\`` `\``
//     `\`` TemplateCharacters `\``

function TV_NoSubstitutionTemplate(NoSubstitutionTemplate) {
  if (NoSubstitutionTemplate.quasis.length !== 1) {
    throw new OutOfRange('TV_NoSubstitutionTemplate', NoSubstitutionTemplate);
  }

  return TV_TemplateCharacters(NoSubstitutionTemplate.quasis[0]);
} // 11.8.6.1 #sec-static-semantics-tv-and-trv
//   TemplateCharacters ::
//     TemplateCharacter
//     TemplateCharacter TemplateCharacters

function TV_TemplateCharacters(TemplateCharacters) {
  if (TemplateCharacters.value.cooked === null) {
    return undefined;
  }

  return TemplateCharacters.value.cooked;
} // 11.8.6.1 #sec-static-semantics-tv-and-trv
//   TemplateHead ::
//     `\`` `${`
//     `\`` TemplateCharacters `${`

const TV_TemplateHead = TV_TemplateCharacters; // 11.8.6.1 #sec-static-semantics-tv-and-trv
//   TemplateMiddle ::
//     `}` `${`
//     `}` TemplateCharacters `${`

const TV_TemplateMiddle = TV_TemplateCharacters; // 11.8.6.1 #sec-static-semantics-tv-and-trv
//   TemplateTail ::
//     `}` `\``
//     `}` TemplateCharacters `\``

const TV_TemplateTail = TV_TemplateCharacters;

//   TemplateLiteral : NoSubstitutionTemplate
//
// (implicit)
//   TemplateLiteral : SubstitutionTemplate

function TemplateStrings_TemplateLiteral(TemplateLiteral, raw) {
  switch (true) {
    case isNoSubstitutionTemplate(TemplateLiteral):
      {
        let string;

        if (raw === false) {
          string = TV_NoSubstitutionTemplate(TemplateLiteral);
        } else {
          string = TRV_NoSubstitutionTemplate(TemplateLiteral);
        }

        return [string];
      }

    case isSubstitutionTemplate(TemplateLiteral):
      return TemplateStrings_SubstitutionTemplate(TemplateLiteral, raw);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('TemplateStrings_TemplateLiteral', TemplateLiteral);
  }
} // 12.2.9.2 #sec-static-semantics-templatestrings
//   SubstitutionTemplate : TemplateHead Expression TemplateSpans

function TemplateStrings_SubstitutionTemplate(SubstitutionTemplate, raw) {
  const [TemplateHead,,
  /* Expression */
  ...TemplateSpans] = unrollTemplateLiteral(SubstitutionTemplate);
  let head;

  if (raw === false) {
    head = TV_TemplateHead(TemplateHead);
  } else {
    head = TRV_TemplateHead(TemplateHead);
  }

  const tail = TemplateStrings_TemplateSpans(TemplateSpans, raw);
  return [head, ...tail];
} // 12.2.9.2 #sec-static-semantics-templatestrings
//   TemplateSpans :
//     TemplateTail
//     TemplateMiddleList TemplateTail

function TemplateStrings_TemplateSpans(TemplateSpans, raw) {
  let middle = [];
  Assert(TemplateSpans.length % 2 === 1, "TemplateSpans.length % 2 === 1");

  if (TemplateSpans.length > 1) {
    middle = TemplateStrings_TemplateMiddleList(TemplateSpans.slice(0, -1), raw);
  }

  const TemplateTail = TemplateSpans[TemplateSpans.length - 1];
  let tail;

  if (raw === false) {
    tail = TV_TemplateTail(TemplateTail);
  } else {
    tail = TRV_TemplateTail(TemplateTail);
  }

  return [...middle, tail];
} // 12.2.9.2 #sec-static-semantics-templatestrings
//   TemplateMiddleList :
//     TemplateMiddle Expression
//     TemplateMiddleList TemplateMiddle Expression

function TemplateStrings_TemplateMiddleList(TemplateMiddleList, raw) {
  const front = [];
  Assert(TemplateMiddleList.length % 2 === 0, "TemplateMiddleList.length % 2 === 0");

  for (let i = 0; i < TemplateMiddleList.length; i += 2) {
    const TemplateMiddle = TemplateMiddleList[i];
    let last;

    if (raw === false) {
      last = TV_TemplateMiddle(TemplateMiddle);
    } else {
      last = TRV_TemplateMiddle(TemplateMiddle);
    }

    front.push(last);
  }

  return front;
}

//   StatementList : StatementList StatementListItem
//
// (implicit)
//   StatementList : StatementListItem

function TopLevelLexicallyScopedDeclarations_StatementList(StatementList) {
  const declarations = [];

  for (const StatementListItem of StatementList) {
    declarations.push(...TopLevelLexicallyScopedDeclarations_StatementListItem(StatementListItem));
  }

  return declarations;
} // 13.2.8 #sec-block-static-semantics-toplevellexicallyscopeddeclarations
//   StatementListItem :
//     Statement
//     Declaration

function TopLevelLexicallyScopedDeclarations_StatementListItem(StatementListItem) {
  switch (true) {
    case isStatement(StatementListItem):
      return [];

    case isDeclaration(StatementListItem):
      if (isHoistableDeclaration(StatementListItem)) {
        return [];
      }

      return [StatementListItem];

    default:
      throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
  }
}

//   Statement :
//     EmptyStatement
//     ExpressionStatement
//     ContinueStatement
//     BreakStatement
//     ReturnStatement
//     ThrowStatement
//     DebuggerStatement
//
// (implicit)
//   Statement :
//     BlockStatement
//     VariableStatement
//     IfStatement
//     BreakableStatement
//     WithStatement
//     LabelledStatement
//     TryStatement
//   BreakableStatement :
//     IterationStatement
//     SwitchStatement

function VarScopedDeclarations_Statement(Statement) {
  switch (true) {
    case isEmptyStatement(Statement):
    case isExpressionStatement(Statement):
    case isContinueStatement(Statement):
    case isBreakStatement(Statement):
    case isReturnStatement(Statement):
    case isThrowStatement(Statement):
    case isDebuggerStatement(Statement):
      return [];

    case isBlockStatement(Statement):
      return VarScopedDeclarations_BlockStatement(Statement);

    case isVariableStatement(Statement):
      return VarScopedDeclarations_VariableStatement(Statement);

    case isIfStatement(Statement):
      return VarScopedDeclarations_IfStatement(Statement);

    case isWithStatement(Statement):
      return VarScopedDeclarations_WithStatement(Statement);

    case isLabelledStatement(Statement):
      return VarScopedDeclarations_LabelledStatement(Statement);

    case isTryStatement(Statement):
      return VarScopedDeclarations_TryStatement(Statement);

    case isIterationStatement(Statement):
      return VarScopedDeclarations_IterationStatement(Statement);

    case isSwitchStatement(Statement):
      return VarScopedDeclarations_SwitchStatement(Statement);

    default:
      throw new TypeError(`Invalid Statement: ${Statement.type}`);
  }
} // 13.2.12 #sec-block-static-semantics-varscopeddeclarations
//   StatementList : StatementList StatementListItem
//
// (implicit)
//   StatementList : StatementListItem

function VarScopedDeclarations_StatementList(StatementList) {
  const declarations = [];

  for (const StatementListItem of StatementList) {
    declarations.push(...VarScopedDeclarations_StatementListItem(StatementListItem));
  }

  return declarations;
} // 13.2.12 #sec-block-static-semantics-varscopeddeclarations
//   Block : `{` `}`
//
// (implicit)
//   Block : `{` StatementList `}`

function VarScopedDeclarations_Block(Block) {
  return VarScopedDeclarations_StatementList(Block.body);
} // (implicit)
//   BlockStatement : Block

const VarScopedDeclarations_BlockStatement = VarScopedDeclarations_Block; // 13.2.12 #sec-block-static-semantics-varscopeddeclarations
//   StatementListItem : Declaration
//
// (implicit)
//   StatementListItem : Statement

function VarScopedDeclarations_StatementListItem(StatementListItem) {
  switch (true) {
    case isDeclaration(StatementListItem):
      return [];

    case isStatement(StatementListItem):
      return VarScopedDeclarations_Statement(StatementListItem);

    default:
      throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
  }
} // 13.3.2.3 #sec-variable-statement-static-semantics-varscopeddeclarations
//   VariableDeclarationList :
//     VariableDeclaration
//     VariableDeclarationList `,` VariableDeclaration

function VarScopedDeclarations_VariableDeclarationList(VariableDeclarationList) {
  return VariableDeclarationList;
} // (implicit)
//   VariableStatement : `var` VariableDeclarationList `;`

function VarScopedDeclarations_VariableStatement(VariableStatement) {
  return VarScopedDeclarations_VariableDeclarationList(VariableStatement.declarations);
} // 13.6.6 #sec-if-statement-static-semantics-varscopeddeclarations
//   IfStatement :
//     `if` `(` Expression `)` Statement `else` Statement
//     `if` `(` Expression `)` Statement

function VarScopedDeclarations_IfStatement(IfStatement) {
  if (IfStatement.alternate) {
    return [...VarScopedDeclarations_Statement(IfStatement.consequent), ...VarScopedDeclarations_Statement(IfStatement.alternate)];
  }

  return VarScopedDeclarations_Statement(IfStatement.consequent);
} // 13.7.2.5 #sec-do-while-statement-static-semantics-varscopeddeclarations
//   IterationStatement : `do` Statement `while` `(` Expression `)` `;`
//
// 13.7.3.5 #sec-while-statement-static-semantics-varscopeddeclarations
//   IterationStatement : `while` `(` Expression `)` Statement
//
// 13.7.4.6 #sec-for-statement-static-semantics-varscopeddeclarations
//   IterationStatement :
//     `for` `(` Expression `;` Expression `;` Expression `)` Statement
//     `for` `(` `var` VariableDeclarationList `;` Expression `;` Expression `)` Statement
//     `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
//
// 13.7.5.8 #sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations
//   IterationStatement :
//     `for` `(` LeftHandSideExpression `in` Expression `)` Statement
//     `for` `(` `var` ForBinding `in` Expression `)` Statement
//     `for` `(` ForDeclaration `in` Expression `)` Statement
//     `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
//     `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
//     `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
//     `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
//     `for` `(` ForDeclaration `of` Expression `)` Statement
//     `for` `await` `(` ForDeclaration `of` Expression `)` Statement

function VarScopedDeclarations_IterationStatement(IterationStatement) {
  let declarationsFromBinding = [];

  switch (IterationStatement.type) {
    case 'DoWhileStatement':
    case 'WhileStatement':
      break;

    case 'ForStatement':
      if (IterationStatement.init && isVariableStatement(IterationStatement.init)) {
        const VariableDeclarationList = IterationStatement.init.declarations;
        declarationsFromBinding = VarScopedDeclarations_VariableDeclarationList(VariableDeclarationList);
      }

      break;

    case 'ForInStatement':
    case 'ForOfStatement':
      if (isVariableStatement(IterationStatement.left)) {
        const ForBinding = IterationStatement.left.declarations[0].id;
        declarationsFromBinding = [ForBinding];
      }

      break;

    default:
      throw new TypeError(`Invalid IterationStatement: ${IterationStatement.type}`);
  }

  return [...declarationsFromBinding, ...VarScopedDeclarations_Statement(IterationStatement.body)];
} // 13.11.6 #sec-with-statement-static-semantics-varscopeddeclarations
//   WithStatement : `with` `(` Expression `)` Statement

function VarScopedDeclarations_WithStatement(WithStatement) {
  return VarScopedDeclarations_Statement(WithStatement.body);
} // 13.12.8 #sec-switch-statement-static-semantics-varscopeddeclarations
//   SwitchStatement : `switch` `(` Expression `)` CaseBlock

function VarScopedDeclarations_SwitchStatement(SwitchStatement) {
  return VarScopedDeclarations_CaseBlock(SwitchStatement.cases);
} // 13.12.8 #sec-switch-statement-static-semantics-varscopeddeclarations
//   CaseBlock :
//     `{` `}`
//     `{` CaseClauses_opt DefaultClause CaseClauses_opt `}`
//   CaseClauses : CaseClauses CaseClause
//   CaseClause : `case` Expression `:` StatementList_opt
//   DefaultClause : `default` `:` StatementList_opt
//
// (implicit)
//   CaseBlock : `{` CaseClauses `}`
//   CaseClauses : CaseClause

function VarScopedDeclarations_CaseBlock(CaseBlock) {
  const declarations = [];

  for (const CaseClauseOrDefaultClause of CaseBlock) {
    declarations.push(...VarScopedDeclarations_StatementList(CaseClauseOrDefaultClause.consequent));
  }

  return declarations;
} // 13.13.13 #sec-labelled-statements-static-semantics-varscopeddeclarations
//   LabelledStatement : LabelIdentifier `:` LabelledItem
//   LabelledItem : FunctionDeclaration
//
// (implicit)
//   LabelledItem : Statement

function VarScopedDeclarations_LabelledStatement(LabelledStatement) {
  const LabelledItem = LabelledStatement.body;

  switch (true) {
    case isFunctionDeclaration(LabelledItem):
      return [];

    case isStatement(LabelledItem):
      return VarScopedDeclarations_Statement(LabelledItem);

    default:
      throw new TypeError(`Invalid LabelledItem: ${LabelledItem.type}`);
  }
} // 13.15.6 #sec-try-statement-static-semantics-varscopeddeclarations
//   TryStatement :
//     `try` Block Catch
//     `try` Block Finally
//     `try` Block Catch Finally
//   Catch : `catch` `(` CatchParameter `)` Block
//
// (implicit)
//   Catch : `catch` Block
//   Finally : `finally` Block

function VarScopedDeclarations_TryStatement(TryStatement) {
  const declarationsBlock = VarScopedDeclarations_Block(TryStatement.block);
  const declarationsCatch = TryStatement.handler !== null ? VarScopedDeclarations_Block(TryStatement.handler.body) : [];
  const declarationsFinally = TryStatement.finalizer !== null ? VarScopedDeclarations_Block(TryStatement.finalizer) : [];
  return [...declarationsBlock, ...declarationsCatch, ...declarationsFinally];
} // 14.1.17 #sec-function-definitions-static-semantics-varscopeddeclarations
//   FunctionStatementList :
//     [empty]
//     StatementList

const VarScopedDeclarations_FunctionStatementList = TopLevelVarScopedDeclarations_StatementList; // (implicit)
//   FunctionBody : FunctionStatementList

const VarScopedDeclarations_FunctionBody = VarScopedDeclarations_FunctionStatementList; // (implicit)
//   GeneratorBody : FunctionBody

const VarScopedDeclarations_GeneratorBody = VarScopedDeclarations_FunctionBody; // (implicit)
//   AsyncFunctionBody : FunctionBody

const VarScopedDeclarations_AsyncFunctionBody = VarScopedDeclarations_FunctionBody; // 14.2.13 #sec-arrow-function-definitions-static-semantics-varscopeddeclarations
//   ConciseBody : ExpressionBody
//
// (implicit)
//   ConciseBody : `{` FunctionBody `}`

function VarScopedDeclarations_ConciseBody(ConciseBody) {
  switch (true) {
    case isExpressionBody(ConciseBody):
      return [];

    case isBlockStatement(ConciseBody):
      return VarScopedDeclarations_FunctionBody(ConciseBody.body);

    default:
      throw new TypeError(`Unexpected ConciseBody: ${ConciseBody.type}`);
  }
} // 14.8.12 #sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations
//   ScriptBody : StatementList

const VarScopedDeclarations_ScriptBody = TopLevelVarScopedDeclarations_StatementList; // (implicit)
//   ModuleItemList : ModuleItemList ModuleItem
//
// (implicit)
//   ModuleItemList : ModuleItem

function VarScopedDeclarations_ModuleItemList(ModuleItemList) {
  const declarations = [];

  for (const ModuleItem of ModuleItemList) {
    declarations.push(...VarScopedDeclarations_ModuleItem(ModuleItem));
  }

  return declarations;
} // (implicit)
//   ModuleBody : ModuleItemList

const VarScopedDeclarations_ModuleBody = VarScopedDeclarations_ModuleItemList; // 15.2.1.14 #sec-module-semantics-static-semantics-varscopeddeclarations
//   ModuleItem :
//     ImportDeclaration
//     ExportDeclaration
//
// (implicit)
//   ModuleItem : StatementListItem

function VarScopedDeclarations_ModuleItem(ModuleItem) {
  switch (true) {
    case isImportDeclaration(ModuleItem):
      return [];

    case isExportDeclaration(ModuleItem):
      if (isExportDeclarationWithVariable(ModuleItem)) {
        return VarScopedDeclarations_VariableStatement(ModuleItem.declaration);
      }

      return [];

    default:
      return VarScopedDeclarations_StatementListItem(ModuleItem);
  }
}

//   StatementList : StatementList StatementListItem

function TopLevelVarScopedDeclarations_StatementList(StatementList) {
  const declarations = [];

  for (const StatementListItem of StatementList) {
    declarations.push(...TopLevelVarScopedDeclarations_StatementListItem(StatementListItem));
  }

  return declarations;
} // 13.2.10 #sec-block-static-semantics-toplevelvarscopeddeclarations
//   StatementListItem :
//     Statement
//     Declaration

function TopLevelVarScopedDeclarations_StatementListItem(StatementListItem) {
  switch (true) {
    case isStatement(StatementListItem):
      if (isLabelledStatement(StatementListItem)) {
        return TopLevelVarScopedDeclarations_LabelledStatement(StatementListItem);
      }

      return VarScopedDeclarations_Statement(StatementListItem);

    case isDeclaration(StatementListItem):
      if (isHoistableDeclaration(StatementListItem)) {
        return [DeclarationPart_Declaration(StatementListItem)];
      }

      return [];

    default:
      throw new TypeError(`Unexpected StatementListItem: ${StatementListItem.type}`);
  }
} // 13.13.11 #sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations
//   LabelledStatement : LabelIdentifier `:` LabelledItem

function TopLevelVarScopedDeclarations_LabelledStatement(LabelledStatement) {
  return TopLevelVarScopedDeclarations_LabelledItem(LabelledStatement.body);
} // 13.13.11 #sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations
//   LabelledItem :
//     Statement
//     FunctionDeclaration

function TopLevelVarScopedDeclarations_LabelledItem(LabelledItem) {
  switch (true) {
    case isStatement(LabelledItem):
      if (isLabelledStatement(LabelledItem)) {
        return TopLevelVarScopedDeclarations_LabelledItem(LabelledItem.body);
      }

      return VarScopedDeclarations_Statement(LabelledItem);

    case isFunctionDeclaration(LabelledItem):
      return [LabelledItem];

    default:
      throw new TypeError(`Unexpected LabelledItem: ${LabelledItem.type}`);
  }
}

// 9.4.4 #sec-arguments-exotic-objects
// 9.4.4.6 #sec-createunmappedargumentsobject

function CreateUnmappedArgumentsObject(argumentsList) {
  const len = argumentsList.length;
  const obj = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'), ['ParameterMap']);
  obj.ParameterMap = Value.undefined;
  DefinePropertyOrThrow(obj, new Value('length'), Descriptor({
    Value: new Value(len),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  let index = 0;

  while (index < len) {
    const val = argumentsList[index];

    let _temp = ToString(new Value(index));

    Assert(!(_temp instanceof AbruptCompletion), "ToString(new Value(index))" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const idxStr = _temp;

    let _temp2 = CreateDataProperty(obj, idxStr, val);

    Assert(!(_temp2 instanceof AbruptCompletion), "CreateDataProperty(obj, idxStr, val)" + ' returned an abrupt completion');

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }
    index += 1;
  }

  let _temp3 = DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, Descriptor({
    Value: surroundingAgent.intrinsic('%Array.prototype.values%'),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp3 instanceof AbruptCompletion), "DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, Descriptor({\n    Value: surroundingAgent.intrinsic('%Array.prototype.values%'),\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  let _temp4 = DefinePropertyOrThrow(obj, new Value('callee'), Descriptor({
    Get: surroundingAgent.intrinsic('%ThrowTypeError%'),
    Set: surroundingAgent.intrinsic('%ThrowTypeError%'),
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp4 instanceof AbruptCompletion), "DefinePropertyOrThrow(obj, new Value('callee'), Descriptor({\n    Get: surroundingAgent.intrinsic('%ThrowTypeError%'),\n    Set: surroundingAgent.intrinsic('%ThrowTypeError%'),\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  return obj;
}

function ArgGetterSteps() {
  const f = this;
  const name = f.Name;
  const env = f.Env;
  return env.GetBindingValue(name, Value.false);
} // 9.4.4.7.1 #sec-makearggetter


function MakeArgGetter(name, env) {
  const steps = ArgGetterSteps;

  let _temp5 = CreateBuiltinFunction(steps, ['Name', 'Env']);

  Assert(!(_temp5 instanceof AbruptCompletion), "CreateBuiltinFunction(steps, ['Name', 'Env'])" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const getter = _temp5;
  getter.Name = name;
  getter.Env = env;
  return getter;
}

function ArgSetterSteps([value]) {
  Assert(value !== undefined, "value !== undefined");
  const f = this;
  const name = f.Name;
  const env = f.Env;
  return env.SetMutableBinding(name, value, Value.false);
} // 9.4.4.7.2 #sec-makeargsetter


function MakeArgSetter(name, env) {
  const steps = ArgSetterSteps;

  let _temp6 = CreateBuiltinFunction(steps, ['Name', 'Env']);

  Assert(!(_temp6 instanceof AbruptCompletion), "CreateBuiltinFunction(steps, ['Name', 'Env'])" + ' returned an abrupt completion');

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const setter = _temp6;
  SetFunctionLength(setter, new Value(1));
  setter.Name = name;
  setter.Env = env;
  return setter;
} // 9.4.4.7 #sec-createmappedargumentsobject


function CreateMappedArgumentsObject(func, formals, argumentsList, env) {
  // Assert: formals does not contain a rest parameter, any binding
  // patterns, or any initializers. It may contain duplicate identifiers.
  const len = argumentsList.length;
  const obj = new ArgumentsExoticObjectValue();
  obj.Prototype = surroundingAgent.intrinsic('%Object.prototype%');
  obj.Extensible = Value.true;
  const map = ObjectCreate(Value.null);
  obj.ParameterMap = map;
  const parameterNames = BoundNames_FormalParameters(formals).map(Value);
  const numberOfParameters = parameterNames.length;
  let index = 0;

  while (index < len) {
    const val = argumentsList[index];

    let _temp7 = ToString(new Value(index));

    Assert(!(_temp7 instanceof AbruptCompletion), "ToString(new Value(index))" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    const idxStr = _temp7;

    let _temp8 = CreateDataProperty(obj, idxStr, val);

    Assert(!(_temp8 instanceof AbruptCompletion), "CreateDataProperty(obj, idxStr, val)" + ' returned an abrupt completion');

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }
    index += 1;
  }

  let _temp9 = DefinePropertyOrThrow(obj, new Value('length'), Descriptor({
    Value: new Value(len),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp9 instanceof AbruptCompletion), "DefinePropertyOrThrow(obj, new Value('length'), Descriptor({\n    Value: new Value(len),\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }
  const mappedNames = new ValueSet();
  index = numberOfParameters - 1;

  while (index >= 0) {
    const name = parameterNames[index];

    if (!mappedNames.has(name)) {
      mappedNames.add(name);

      if (index < len) {
        const g = MakeArgGetter(name, env);
        const p = MakeArgSetter(name, env);

        let _temp11 = ToString(new Value(index));

        Assert(!(_temp11 instanceof AbruptCompletion), "ToString(new Value(index))" + ' returned an abrupt completion');

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }

        let _temp10 = map.DefineOwnProperty(_temp11, Descriptor({
          Set: p,
          Get: g,
          Enumerable: Value.false,
          Configurable: Value.true
        }));

        Assert(!(_temp10 instanceof AbruptCompletion), "map.DefineOwnProperty(X(ToString(new Value(index))), Descriptor({\n          Set: p,\n          Get: g,\n          Enumerable: Value.false,\n          Configurable: Value.true,\n        }))" + ' returned an abrupt completion');

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }
      }
    }

    index -= 1;
  }

  let _temp12 = DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, Descriptor({
    Value: surroundingAgent.intrinsic('%Array.prototype.values%'),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp12 instanceof AbruptCompletion), "DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, Descriptor({\n    Value: surroundingAgent.intrinsic('%Array.prototype.values%'),\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  let _temp13 = DefinePropertyOrThrow(obj, new Value('callee'), Descriptor({
    Value: func,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp13 instanceof AbruptCompletion), "DefinePropertyOrThrow(obj, new Value('callee'), Descriptor({\n    Value: func,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }
  return obj;
}

// 9.4.2 #sec-array-exotic-objects
// and
// 22.1 #sec-array-objects
// 9.4.2.2 #sec-arraycreate

function ArrayCreate(length, proto) {
  Assert(length.numberValue() >= 0, "length.numberValue() >= 0");

  if (Object.is(length.numberValue(), -0)) {
    length = new Value(0);
  }

  if (length.numberValue() > 2 ** 32 - 1) {
    return surroundingAgent.Throw('RangeError', 'InvalidArrayLength', length);
  }

  if (proto === undefined) {
    proto = surroundingAgent.intrinsic('%Array.prototype%');
  }

  const A = new ArrayExoticObjectValue();
  A.Prototype = proto;
  A.Extensible = Value.true;

  let _temp = OrdinaryDefineOwnProperty(A, new Value('length'), Descriptor({
    Value: length,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp instanceof AbruptCompletion), "OrdinaryDefineOwnProperty(A, new Value('length'), Descriptor({\n    Value: length,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  return A;
} // 9.4.2.3 #sec-arrayspeciescreate

function ArraySpeciesCreate(originalArray, length) {
  Assert(Type(length) === 'Number' && Number.isInteger(length.numberValue()) && length.numberValue() >= 0, "Type(length) === 'Number' && Number.isInteger(length.numberValue()) && length.numberValue() >= 0");

  if (Object.is(length.numberValue(), -0)) {
    length = new Value(+0);
  }

  let _temp2 = IsArray(originalArray);
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const isArray = _temp2;

  if (isArray === Value.false) {
    return ArrayCreate(length);
  }

  let _temp3 = Get(originalArray, new Value('constructor'));

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  let C = _temp3;

  if (IsConstructor(C) === Value.true) {
    const thisRealm = surroundingAgent.currentRealmRecord;

    let _temp4 = GetFunctionRealm(C);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const realmC = _temp4;

    if (thisRealm !== realmC) {
      if (SameValue(C, realmC.Intrinsics['%Array%']) === Value.true) {
        C = Value.undefined;
      }
    }
  }

  if (Type(C) === 'Object') {
    let _temp5 = Get(C, wellKnownSymbols.species);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    C = _temp5;

    if (C === Value.null) {
      C = Value.undefined;
    }
  }

  if (C === Value.undefined) {
    return ArrayCreate(length);
  }

  if (IsConstructor(C) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', C);
  }

  return Construct(C, [length]);
} // 9.4.2.4 #sec-arraysetlength

function ArraySetLength(A, Desc) {
  if (Desc.Value === undefined) {
    return OrdinaryDefineOwnProperty(A, new Value('length'), Desc);
  }

  const newLenDesc = Descriptor({ ...Desc
  });

  let _temp6 = ToUint32(Desc.Value);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const newLen = _temp6.numberValue();

  let _temp7 = ToNumber(Desc.Value);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const numberLen = _temp7.numberValue();

  if (newLen !== numberLen) {
    return surroundingAgent.Throw('RangeError', 'InvalidArrayLength', Desc.Value);
  }

  newLenDesc.Value = new Value(newLen);
  const oldLenDesc = OrdinaryGetOwnProperty(A, new Value('length'));
  Assert(Type(oldLenDesc) !== 'Undefined' && !IsAccessorDescriptor(oldLenDesc), "Type(oldLenDesc) !== 'Undefined' && !IsAccessorDescriptor(oldLenDesc)");
  const oldLen = oldLenDesc.Value.numberValue();

  if (newLen >= oldLen) {
    return OrdinaryDefineOwnProperty(A, new Value('length'), newLenDesc);
  }

  if (oldLenDesc.Writable === Value.false) {
    return Value.false;
  }

  let newWritable;

  if (newLenDesc.Writable === undefined || newLenDesc.Writable === Value.true) {
    newWritable = true;
  } else {
    newWritable = false;
    newLenDesc.Writable = Value.true;
  }

  let _temp8 = OrdinaryDefineOwnProperty(A, new Value('length'), newLenDesc);

  Assert(!(_temp8 instanceof AbruptCompletion), "OrdinaryDefineOwnProperty(A, new Value('length'), newLenDesc)" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const succeeded = _temp8;

  if (succeeded === Value.false) {
    return Value.false;
  }

  const keys = [];
  A.properties.forEach((value, key) => {
    if (isArrayIndex(key) && Number(key.stringValue()) >= newLen) {
      keys.push(key);
    }
  });
  keys.sort((a, b) => Number(b.stringValue()) - Number(a.stringValue()));

  for (const P of keys) {
    let _temp9 = A.Delete(P);

    Assert(!(_temp9 instanceof AbruptCompletion), "A.Delete(P)" + ' returned an abrupt completion');

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }

    const deleteSucceeded = _temp9;

    if (deleteSucceeded === Value.false) {
      let _temp10 = ToUint32(P);

      Assert(!(_temp10 instanceof AbruptCompletion), "ToUint32(P)" + ' returned an abrupt completion');

      if (_temp10 instanceof Completion) {
        _temp10 = _temp10.Value;
      }

      newLenDesc.Value = new Value(_temp10.numberValue() + 1);

      if (newWritable === false) {
        newLenDesc.Writable = Value.false;
      }

      let _temp11 = OrdinaryDefineOwnProperty(A, new Value('length'), newLenDesc);

      Assert(!(_temp11 instanceof AbruptCompletion), "OrdinaryDefineOwnProperty(A, new Value('length'), newLenDesc)" + ' returned an abrupt completion');

      if (_temp11 instanceof Completion) {
        _temp11 = _temp11.Value;
      }
      return Value.false;
    }
  }

  if (newWritable === false) {
    OrdinaryDefineOwnProperty(A, new Value('length'), Descriptor({
      Writable: Value.false
    }));
  }

  return Value.true;
} // 22.1.3.1.1 #sec-isconcatspreadable

function IsConcatSpreadable(O) {
  if (Type(O) !== 'Object') {
    return Value.false;
  }

  let _temp12 = Get(O, wellKnownSymbols.isConcatSpreadable);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const spreadable = _temp12;

  if (spreadable !== Value.undefined) {
    return ToBoolean(spreadable);
  }

  return IsArray(O);
} // 22.1.3.27.1 #sec-sortcompare

function SortCompare(x, y, comparefn) {
  if (x === Value.undefined && y === Value.undefined) {
    return new Value(+0);
  }

  if (x === Value.undefined) {
    return new Value(1);
  }

  if (y === Value.undefined) {
    return new Value(-1);
  }

  if (comparefn !== Value.undefined) {
    let _temp13 = Call(comparefn, Value.undefined, [x, y]);

    if (_temp13 instanceof AbruptCompletion) {
      return _temp13;
    }

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }

    const callRes = _temp13;

    let _temp14 = ToNumber(callRes);

    if (_temp14 instanceof AbruptCompletion) {
      return _temp14;
    }

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    const v = _temp14;

    if (v.isNaN()) {
      return new Value(+0);
    }

    return v;
  }

  let _temp15 = ToString(x);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const xString = _temp15;

  let _temp16 = ToString(y);

  if (_temp16 instanceof AbruptCompletion) {
    return _temp16;
  }

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }

  const yString = _temp16;
  const xSmaller = AbstractRelationalComparison(xString, yString);

  if (xSmaller === Value.true) {
    return new Value(-1);
  }

  const ySmaller = AbstractRelationalComparison(yString, xString);

  if (ySmaller === Value.true) {
    return new Value(1);
  }

  return new Value(+0);
} // 22.1.5.1 #sec-createarrayiterator

function CreateArrayIterator(array, kind) {
  Assert(Type(array) === 'Object', "Type(array) === 'Object'");
  const iterator = ObjectCreate(surroundingAgent.intrinsic('%ArrayIterator.prototype%'), ['IteratedArrayLike', 'ArrayLikeNextIndex', 'ArrayLikeIterationKind']);
  iterator.IteratedArrayLike = array;
  iterator.ArrayLikeNextIndex = 0;
  iterator.ArrayLikeIterationKind = kind;
  return iterator;
}

// 24.1 #sec-arraybuffer-objects
// and, for now
// 24.2 #sec-sharedarraybuffer-objects
// 24.1.1.1 #sec-allocatearraybuffer

function AllocateArrayBuffer(constructor, byteLength) {
  let _temp = OrdinaryCreateFromConstructor(constructor, '%ArrayBuffer.prototype%', ['ArrayBufferData', 'ArrayBufferByteLength', 'ArrayBufferDetachKey']);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const obj = _temp;
  Assert(byteLength.numberValue() >= 0, "byteLength.numberValue() >= 0");
  Assert(Number.isInteger(byteLength.numberValue()), "Number.isInteger(byteLength.numberValue())");

  let _temp2 = CreateByteDataBlock(byteLength);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const block = _temp2;
  obj.ArrayBufferData = block;
  obj.ArrayBufferByteLength = byteLength;
  return obj;
} // 24.1.1.2 #sec-isdetachedbuffer

function IsDetachedBuffer(arrayBuffer) {
  Assert(Type(arrayBuffer) === 'Object' && 'ArrayBufferData' in arrayBuffer, "Type(arrayBuffer) === 'Object' && 'ArrayBufferData' in arrayBuffer");

  if (Type(arrayBuffer.ArrayBufferData) === 'Null') {
    return true;
  }

  return false;
} // 24.1.1.3 #sec-detacharraybuffer

function DetachArrayBuffer(arrayBuffer, key) {
  Assert(Type(arrayBuffer) === 'Object' && 'ArrayBufferData' in arrayBuffer && 'ArrayBufferByteLength' in arrayBuffer && 'ArrayBufferDetachKey' in arrayBuffer, "Type(arrayBuffer) === 'Object' && 'ArrayBufferData' in arrayBuffer && 'ArrayBufferByteLength' in arrayBuffer && 'ArrayBufferDetachKey' in arrayBuffer");
  Assert(IsSharedArrayBuffer(arrayBuffer) === Value.false, "IsSharedArrayBuffer(arrayBuffer) === Value.false");

  if (key === undefined) {
    key = Value.undefined;
  }

  if (SameValue(arrayBuffer.ArrayBufferDetachKey, key) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'BufferDetachKeyMismatch', key, arrayBuffer);
  }

  arrayBuffer.ArrayBufferData = Value.null;
  arrayBuffer.ArrayBufferByteLength = new Value(0);
  return new NormalCompletion(Value.null);
} // 24.1.1.4 #sec-clonearraybuffer

function CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor) {
  Assert(Type(srcBuffer) === 'Object' && 'ArrayBufferData' in srcBuffer, "Type(srcBuffer) === 'Object' && 'ArrayBufferData' in srcBuffer");
  Assert(IsConstructor(cloneConstructor) === Value.true, "IsConstructor(cloneConstructor) === Value.true");

  let _temp3 = AllocateArrayBuffer(cloneConstructor, srcLength);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const targetBuffer = _temp3;

  if (IsDetachedBuffer(srcBuffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const srcBlock = srcBuffer.ArrayBufferData;
  const targetBlock = targetBuffer.ArrayBufferData;
  CopyDataBlockBytes(targetBlock, new Value(0), srcBlock, srcByteOffset, srcLength);
  return targetBuffer;
}
const throwawayBuffer = new ArrayBuffer(8);
const throwawayDataView = new DataView(throwawayBuffer);
const throwawayArray$1 = new Uint8Array(throwawayBuffer); // 24.1.1.5 #sec-rawbytestonumber
// Sigh

function RawBytesToNumber(type, rawBytes, isLittleEndian) {
  isLittleEndian = isLittleEndian === Value.true;
  const elementSize = numericTypeInfo.get(type).ElementSize;
  Assert(elementSize === rawBytes.length, "elementSize === rawBytes.length");
  const dataViewType = type === 'Uint8C' ? 'Uint8' : type;
  Object.assign(throwawayArray$1, rawBytes);
  return new Value(throwawayDataView[`get${dataViewType}`](0, isLittleEndian));
} // 24.1.1.6 #sec-getvaluefrombuffer

function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order, isLittleEndian) {
  byteIndex = byteIndex.numberValue();
  Assert(!IsDetachedBuffer(arrayBuffer), "!IsDetachedBuffer(arrayBuffer)");
  const info = numericTypeInfo.get(type);
  Assert(info !== undefined, "info !== undefined");
  Assert(arrayBuffer.ArrayBufferByteLength.numberValue() - byteIndex >= info.ElementSize, "arrayBuffer.ArrayBufferByteLength.numberValue() - byteIndex >= info.ElementSize");
  Assert(byteIndex >= 0 && Number.isInteger(byteIndex), "byteIndex >= 0 && Number.isInteger(byteIndex)");
  const block = arrayBuffer.ArrayBufferData;
  const elementSize = info.ElementSize; // if (IsSharedArrayBuffer(arrayBuffer) === Value.true) {
  //
  // } else {

  const rawValue = [...block.subarray(byteIndex, byteIndex + elementSize)]; // }

  if (isLittleEndian === undefined) {
    isLittleEndian = surroundingAgent.LittleEndian;
  }

  return RawBytesToNumber(type, rawValue, isLittleEndian);
} // An implementation must always choose the same encoding for each
// implementation distinguishable NaN value.

const float32NaNLE = Object.freeze([0, 0, 192, 127]);
const float32NaNBE = Object.freeze([127, 192, 0, 0]);
const float64NaNLE = Object.freeze([0, 0, 0, 0, 0, 0, 248, 127]);
const float64NaNBE = Object.freeze([127, 248, 0, 0, 0, 0, 0, 0]); // 24.1.1.7 #sec-numbertorawbytes

function NumberToRawBytes(type, value, isLittleEndian) {
  Assert(Type(isLittleEndian) === 'Boolean', "Type(isLittleEndian) === 'Boolean'");
  isLittleEndian = isLittleEndian === Value.true;
  let rawBytes; // One day, we will write our own IEEE 754 and two's complement encoder

  if (type === 'Float32') {
    if (Number.isNaN(value.numberValue())) {
      rawBytes = isLittleEndian ? [...float32NaNLE] : [...float32NaNBE];
    } else {
      throwawayDataView.setFloat32(0, value.numberValue(), isLittleEndian);
      rawBytes = [...throwawayArray$1.subarray(0, 4)];
    }
  } else if (type === 'Float64') {
    if (Number.isNaN(value.numberValue())) {
      rawBytes = isLittleEndian ? [...float64NaNLE] : [...float64NaNBE];
    } else {
      throwawayDataView.setFloat64(0, value.numberValue(), isLittleEndian);
      rawBytes = [...throwawayArray$1.subarray(0, 8)];
    }
  } else {
    const info = numericTypeInfo.get(type);
    const n = info.ElementSize;
    const convOp = info.ConversionOperation;

    let _temp4 = convOp(value);

    Assert(!(_temp4 instanceof AbruptCompletion), "convOp(value)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const intValue = _temp4.numberValue();

    const dataViewType = type === 'Uint8C' ? 'Uint8' : type;
    throwawayDataView[`set${dataViewType}`](0, intValue, isLittleEndian);
    rawBytes = [...throwawayArray$1.subarray(0, n)];
  }

  return rawBytes;
} // 24.1.1.8 #sec-setvalueinbuffer

function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order, isLittleEndian) {
  byteIndex = byteIndex.numberValue();
  Assert(!IsDetachedBuffer(arrayBuffer), "!IsDetachedBuffer(arrayBuffer)");
  const info = numericTypeInfo.get(type);
  Assert(info !== undefined, "info !== undefined");
  Assert(arrayBuffer.ArrayBufferByteLength.numberValue() - byteIndex >= info.ElementSize, "arrayBuffer.ArrayBufferByteLength.numberValue() - byteIndex >= info.ElementSize");
  Assert(byteIndex >= 0 && Number.isInteger(byteIndex), "byteIndex >= 0 && Number.isInteger(byteIndex)");
  Assert(Type(value) === 'Number', "Type(value) === 'Number'");
  const block = arrayBuffer.ArrayBufferData; // const elementSize = info.ElementSize;

  if (isLittleEndian === undefined) {
    isLittleEndian = surroundingAgent.LittleEndian;
  }

  const rawBytes = NumberToRawBytes(type, value, isLittleEndian); // if (IsSharedArrayBuffer(arrayBuffer) === Value.true) {
  //
  // } else {

  for (let i = 0; i < rawBytes.length; i += 1) {
    block[byteIndex + i] = rawBytes[i];
  } // }


  return new NormalCompletion(Value.undefined);
} // 24.2.1.2 #sec-issharedarraybuffer

function IsSharedArrayBuffer(obj) {
  Assert(Type(obj) === 'Object' && 'ArrayBufferData' in obj, "Type(obj) === 'Object' && 'ArrayBufferData' in obj");
  const bufferData = obj.ArrayBufferData;

  if (Type(bufferData) === 'Null') {
    return Value.false;
  }

  if (Type(bufferData) === 'Data Block') {
    return Value.false;
  }

  Assert(Type(bufferData) === 'Shared Data Block', "Type(bufferData) === 'Shared Data Block'");
  return Value.true;
}

// 25.7 #sec-async-function-objects
// https://tc39.es/proposal-top-level-await/#sec-asyncblockstart

function AsyncBlockStart(promiseCapability, asyncBody, asyncContext) {
  asyncContext.promiseCapability = promiseCapability;
  const runningContext = surroundingAgent.runningExecutionContext;

  asyncContext.codeEvaluationState = function* resumer() {
    const evaluator = isExpressionBody(asyncBody) ? Evaluate_ExpressionBody : Evaluate_FunctionBody;
    const result = EnsureCompletion((yield* evaluator(asyncBody))); // Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.

    surroundingAgent.executionContextStack.pop(asyncContext);

    if (result.Type === 'normal') {
      let _temp = Call(promiseCapability.Resolve, Value.undefined, [Value.undefined]);

      Assert(!(_temp instanceof AbruptCompletion), "Call(promiseCapability.Resolve, Value.undefined, [Value.undefined])" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }
    } else if (result.Type === 'return') {
      let _temp2 = Call(promiseCapability.Resolve, Value.undefined, [result.Value]);

      Assert(!(_temp2 instanceof AbruptCompletion), "Call(promiseCapability.Resolve, Value.undefined, [result.Value])" + ' returned an abrupt completion');

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }
    } else {
      Assert(result.Type === 'throw', "result.Type === 'throw'");

      let _temp3 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

      Assert(!(_temp3 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [result.Value])" + ' returned an abrupt completion');

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }
    }

    return Value.undefined;
  }();

  surroundingAgent.executionContextStack.push(asyncContext);
  const result = EnsureCompletion(resume(asyncContext, undefined));
  Assert(surroundingAgent.runningExecutionContext === runningContext, "surroundingAgent.runningExecutionContext === runningContext");
  Assert(result.Type === 'normal' && result.Value === Value.undefined, "result.Type === 'normal' && result.Value === Value.undefined");
  return Value.undefined;
} // 25.7.5.1 #sec-async-functions-abstract-operations-async-function-start

function AsyncFunctionStart(promiseCapability, asyncFunctionBody) {
  const runningContext = surroundingAgent.runningExecutionContext;
  const asyncContext = runningContext.copy();

  let _temp4 = AsyncBlockStart(promiseCapability, asyncFunctionBody, asyncContext);

  Assert(!(_temp4 instanceof AbruptCompletion), "AsyncBlockStart(promiseCapability, asyncFunctionBody, asyncContext)" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
}

// 25.5 #sec-asyncgenerator-objects
// 25.5.3.1 #sec-asyncgeneratorrequest-records

class AsyncGeneratorRequestRecord {
  constructor(completion, promiseCapability) {
    this.Completion = completion;
    this.Capability = promiseCapability;
  }

} // 25.5.3.2 #sec-asyncgeneratorstart


function AsyncGeneratorStart(generator, generatorBody) {
  // Assert: generator is an AsyncGenerator instance.
  Assert(generator.AsyncGeneratorState === Value.undefined, "generator.AsyncGeneratorState === Value.undefined");
  const genContext = surroundingAgent.runningExecutionContext;
  genContext.Generator = generator;

  genContext.codeEvaluationState = function* resumer() {
    const result = EnsureCompletion((yield* Evaluate_FunctionBody(generatorBody))); // Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.

    surroundingAgent.executionContextStack.pop(genContext);
    generator.AsyncGeneratorState = 'completed';
    let resultValue;

    if (result instanceof NormalCompletion) {
      resultValue = Value.undefined;
    } else {
      resultValue = result.Value;

      if (result.Type !== 'return') {
        let _temp = AsyncGeneratorReject(generator, resultValue);

        Assert(!(_temp instanceof AbruptCompletion), "AsyncGeneratorReject(generator, resultValue)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }

        return _temp;
      }
    }

    let _temp2 = AsyncGeneratorResolve(generator, resultValue, Value.true);

    Assert(!(_temp2 instanceof AbruptCompletion), "AsyncGeneratorResolve(generator, resultValue, Value.true)" + ' returned an abrupt completion');

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    return _temp2;
  }();

  generator.AsyncGeneratorContext = genContext;
  generator.AsyncGeneratorState = 'suspendedStart';
  generator.AsyncGeneratorQueue = [];
  return Value.undefined;
} // 25.5.3.3 #sec-asyncgeneratorresolve

function AsyncGeneratorResolve(generator, value, done) {
  // Assert: generator is an AsyncGenerator instance.
  const queue = generator.AsyncGeneratorQueue;
  Assert(queue.length > 0, "queue.length > 0");
  const next = queue.shift();
  const promiseCapability = next.Capability;

  let _temp3 = CreateIterResultObject(value, done);

  Assert(!(_temp3 instanceof AbruptCompletion), "CreateIterResultObject(value, done)" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const iteratorResult = _temp3;

  let _temp4 = Call(promiseCapability.Resolve, Value.undefined, [iteratorResult]);

  Assert(!(_temp4 instanceof AbruptCompletion), "Call(promiseCapability.Resolve, Value.undefined, [iteratorResult])" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  let _temp5 = AsyncGeneratorResumeNext(generator);

  Assert(!(_temp5 instanceof AbruptCompletion), "AsyncGeneratorResumeNext(generator)" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }
  return Value.undefined;
} // 25.5.3.4 #sec-asyncgeneratorreject


function AsyncGeneratorReject(generator, exception) {
  // Assert: generator is an AsyncGenerator instance.
  const queue = generator.AsyncGeneratorQueue;
  Assert(queue.length > 0, "queue.length > 0");
  const next = queue.shift();
  const promiseCapability = next.Capability;

  let _temp6 = Call(promiseCapability.Reject, Value.undefined, [exception]);

  Assert(!(_temp6 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [exception])" + ' returned an abrupt completion');

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  let _temp7 = AsyncGeneratorResumeNext(generator);

  Assert(!(_temp7 instanceof AbruptCompletion), "AsyncGeneratorResumeNext(generator)" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }
  return Value.undefined;
} // 25.5.3.5.1 #async-generator-resume-next-return-processor-fulfilled


function AsyncGeneratorResumeNextReturnProcessorFulfilledFunctions([value = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  F.Generator.AsyncGeneratorState = 'completed';

  let _temp8 = AsyncGeneratorResolve(F.Generator, value, Value.true);

  Assert(!(_temp8 instanceof AbruptCompletion), "AsyncGeneratorResolve(F.Generator, value, Value.true)" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  return _temp8;
} // 25.5.3.5.2 #async-generator-resume-next-return-processor-rejected


function AsyncGeneratorResumeNextReturnProcessorRejectedFunctions([reason = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  F.Generator.AsyncGeneratorState = 'completed';

  let _temp9 = AsyncGeneratorReject(F.Generator, reason);

  Assert(!(_temp9 instanceof AbruptCompletion), "AsyncGeneratorReject(F.Generator, reason)" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  return _temp9;
} // 25.5.3.5 #sec-asyncgeneratorresumenext


function AsyncGeneratorResumeNext(generator) {
  // Assert: generator is an AsyncGenerator instance.
  let state = generator.AsyncGeneratorState;
  Assert(state !== 'executing', "state !== 'executing'");

  if (state === 'awaiting-return') {
    return Value.undefined;
  }

  const queue = generator.AsyncGeneratorQueue;

  if (queue.length === 0) {
    return Value.undefined;
  }

  const next = queue[0];
  Assert(next instanceof AsyncGeneratorRequestRecord, "next instanceof AsyncGeneratorRequestRecord");
  const completion = next.Completion;

  if (completion instanceof AbruptCompletion) {
    if (state === 'suspendedStart') {
      generator.AsyncGeneratorState = 'completed';
      state = 'completed';
    }

    if (state === 'completed') {
      if (completion.Type === 'return') {
        generator.AsyncGeneratorState = 'awaiting-return';

        let _temp10 = PromiseResolve(surroundingAgent.intrinsic('%Promise%'), completion.Value);
        /* istanbul ignore if */


        if (_temp10 instanceof AbruptCompletion) {
          return _temp10;
        }
        /* istanbul ignore if */


        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }

        const promise = _temp10;
        const stepsFulfilled = AsyncGeneratorResumeNextReturnProcessorFulfilledFunctions;

        let _temp11 = CreateBuiltinFunction(stepsFulfilled, ['Generator']);

        Assert(!(_temp11 instanceof AbruptCompletion), "CreateBuiltinFunction(stepsFulfilled, ['Generator'])" + ' returned an abrupt completion');

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }

        const onFulfilled = _temp11;
        onFulfilled.Generator = generator;
        const stepsRejected = AsyncGeneratorResumeNextReturnProcessorRejectedFunctions;

        let _temp12 = CreateBuiltinFunction(stepsRejected, ['Generator']);

        Assert(!(_temp12 instanceof AbruptCompletion), "CreateBuiltinFunction(stepsRejected, ['Generator'])" + ' returned an abrupt completion');

        if (_temp12 instanceof Completion) {
          _temp12 = _temp12.Value;
        }

        const onRejected = _temp12;
        onRejected.Generator = generator;

        let _temp13 = PerformPromiseThen(promise, onFulfilled, onRejected);

        Assert(!(_temp13 instanceof AbruptCompletion), "PerformPromiseThen(promise, onFulfilled, onRejected)" + ' returned an abrupt completion');

        if (_temp13 instanceof Completion) {
          _temp13 = _temp13.Value;
        }
        return Value.undefined;
      } else {
        Assert(completion.Type === 'throw', "completion.Type === 'throw'");

        let _temp14 = AsyncGeneratorReject(generator, completion.Value);

        Assert(!(_temp14 instanceof AbruptCompletion), "AsyncGeneratorReject(generator, completion.Value)" + ' returned an abrupt completion');

        if (_temp14 instanceof Completion) {
          _temp14 = _temp14.Value;
        }
        return Value.undefined;
      }
    }
  } else if (state === 'completed') {
    let _temp15 = AsyncGeneratorResolve(generator, Value.undefined, Value.true);

    Assert(!(_temp15 instanceof AbruptCompletion), "AsyncGeneratorResolve(generator, Value.undefined, Value.true)" + ' returned an abrupt completion');

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    return _temp15;
  }

  Assert(state === 'suspendedStart' || state === 'suspendedYield', "state === 'suspendedStart' || state === 'suspendedYield'");
  const genContext = generator.AsyncGeneratorContext;
  const callerContext = surroundingAgent.runningExecutionContext; // Suspend callerContext

  generator.AsyncGeneratorState = 'executing';
  surroundingAgent.executionContextStack.push(genContext);
  const result = resume(genContext, completion);
  Assert(!(result instanceof AbruptCompletion), "!(result instanceof AbruptCompletion)");
  Assert(surroundingAgent.runningExecutionContext === callerContext, "surroundingAgent.runningExecutionContext === callerContext");
  return Value.undefined;
} // 25.5.3.6 #sec-asyncgeneratorenqueue


function AsyncGeneratorEnqueue(generator, completion) {
  Assert(completion instanceof Completion, "completion instanceof Completion");

  let _temp16 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

  Assert(!(_temp16 instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }

  const promiseCapability = _temp16;

  if (Type(generator) !== 'Object' || !('AsyncGeneratorState' in generator)) {
    const badGeneratorError = surroundingAgent.Throw('TypeError', 'NotATypeObject', 'AsyncGenerator', generator).Value;

    let _temp17 = Call(promiseCapability.Reject, Value.undefined, [badGeneratorError]);

    Assert(!(_temp17 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [badGeneratorError])" + ' returned an abrupt completion');

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }
    return promiseCapability.Promise;
  }

  const queue = generator.AsyncGeneratorQueue;
  const request = new AsyncGeneratorRequestRecord(completion, promiseCapability);
  queue.push(request);
  const state = generator.AsyncGeneratorState;

  if (state !== 'executing') {
    let _temp18 = AsyncGeneratorResumeNext(generator);

    Assert(!(_temp18 instanceof AbruptCompletion), "AsyncGeneratorResumeNext(generator)" + ' returned an abrupt completion');

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }
  }

  return promiseCapability.Promise;
} // 25.5.3.7 #sec-asyncgeneratoryield

function* AsyncGeneratorYield(value) {
  const genContext = surroundingAgent.runningExecutionContext;
  Assert(genContext.Generator !== Value.undefined, "genContext.Generator !== Value.undefined");
  const generator = genContext.Generator;
  Assert(GetGeneratorKind() === 'async', "GetGeneratorKind() === 'async'");

  let _temp19 = yield* Await(value);

  if (_temp19 instanceof AbruptCompletion) {
    return _temp19;
  }

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  value = _temp19;
  generator.AsyncGeneratorState = 'suspendedYield';
  surroundingAgent.executionContextStack.pop(genContext);
  const resumptionValue = EnsureCompletion((yield handleInResume(AsyncGeneratorResolve, generator, value, Value.false)));

  if (resumptionValue.Type !== 'return') {
    return Completion(resumptionValue);
  }

  const awaited = EnsureCompletion((yield* Await(resumptionValue.Value)));

  if (awaited.Type === 'Throw') {
    return Completion(awaited);
  }

  Assert(awaited.Type === 'normal', "awaited.Type === 'normal'");
  return new Completion('return', awaited.Value, undefined);
}

// 6 #sec-ecmascript-data-types-and-values
// 6.1.4 #leading-surrogate

function isLeadingSurrogate(cp) {
  return cp >= 0xD800 && cp <= 0xDBFF;
} // 6.1.4 #trailing-surrogate

function isTrailingSurrogate(cp) {
  return cp >= 0xDC00 && cp <= 0xDFFF;
} // 6.1.7 #integer-index

function isIntegerIndex(V) {
  if (Type(V) !== 'String') {
    return false;
  }

  let _temp = CanonicalNumericIndexString(V);

  Assert(!(_temp instanceof AbruptCompletion), "CanonicalNumericIndexString(V)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const numeric = _temp;

  if (numeric === Value.undefined) {
    return false;
  }

  if (Object.is(numeric.numberValue(), +0)) {
    return true;
  }

  return numeric.numberValue() > 0 && Number.isSafeInteger(numeric.numberValue());
} // 6.1.7 #array-index

function isArrayIndex(V) {
  if (Type(V) !== 'String') {
    return false;
  }

  let _temp2 = CanonicalNumericIndexString(V);

  Assert(!(_temp2 instanceof AbruptCompletion), "CanonicalNumericIndexString(V)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const numeric = _temp2;

  if (numeric === Value.undefined) {
    return false;
  }

  if (!Number.isInteger(numeric.numberValue())) {
    return false;
  }

  if (Object.is(numeric.numberValue(), +0)) {
    return true;
  }

  return numeric.numberValue() > 0 && numeric.numberValue() < 2 ** 32 - 1;
}

// 24.3 #sec-dataview-objects
// 24.3.1.1 #sec-getviewvalue

function GetViewValue(view, requestIndex, isLittleEndian, type) {
  let _temp = RequireInternalSlot(view, 'DataView');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  Assert('ViewedArrayBuffer' in view, "'ViewedArrayBuffer' in view");

  let _temp2 = ToIndex(requestIndex);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const getIndex = _temp2.numberValue();

  let _temp3 = ToBoolean(isLittleEndian);

  Assert(!(_temp3 instanceof AbruptCompletion), "ToBoolean(isLittleEndian)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  isLittleEndian = _temp3;
  const buffer = view.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const viewOffset = view.ByteOffset.numberValue();
  const viewSize = view.ByteLength.numberValue();
  const elementSize = numericTypeInfo.get(type).ElementSize;

  if (getIndex + elementSize > viewSize) {
    return surroundingAgent.Throw('RangeError', 'DataViewOOB');
  }

  const bufferIndex = new Value(getIndex + viewOffset);
  return GetValueFromBuffer(buffer, bufferIndex, type, false, 'Unordered', isLittleEndian);
} // 24.3.1.2 #sec-setviewvalue

function SetViewValue(view, requestIndex, isLittleEndian, type, value) {
  let _temp4 = RequireInternalSlot(view, 'DataView');

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  Assert('ViewedArrayBuffer' in view, "'ViewedArrayBuffer' in view");

  let _temp5 = ToIndex(requestIndex);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const getIndex = _temp5.numberValue();

  let _temp6 = ToNumber(value);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const numberValue = _temp6;

  let _temp7 = ToBoolean(isLittleEndian);

  Assert(!(_temp7 instanceof AbruptCompletion), "ToBoolean(isLittleEndian)" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  isLittleEndian = _temp7;
  const buffer = view.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const viewOffset = view.ByteOffset.numberValue();
  const viewSize = view.ByteLength.numberValue();
  const elementSize = numericTypeInfo.get(type).ElementSize;

  if (getIndex + elementSize > viewSize) {
    return surroundingAgent.Throw('RangeError', 'DataViewOOB');
  }

  const bufferIndex = new Value(getIndex + viewOffset);
  return SetValueInBuffer(buffer, bufferIndex, type, numberValue, false, 'Unordered', isLittleEndian);
}

const mod = (n, m) => {
  const r = n % m;
  return Math.floor(r >= 0 ? r : r + m);
}; // 20.3.1.2 #sec-day-number-and-time-within-day


function Day(t) {
  return new Value(Math.floor(t.numberValue() / msPerDay));
}
const msPerDay = 86400000;
function TimeWithinDay(t) {
  return new Value(mod(t.numberValue(), msPerDay));
} // 20.3.1.3 #sec-year-number

function DaysInYear(y) {
  y = y.numberValue();

  if (mod(y, 4) !== 0) {
    return new Value(365);
  }

  if (mod(y, 4) === 0 && mod(y, 100) !== 0) {
    return new Value(366);
  }

  if (mod(y, 100) === 0 && mod(y, 400) !== 0) {
    return new Value(365);
  }

  if (mod(y, 400) === 0) {
    return new Value(366);
  }
}
function DayFromYear(y) {
  y = y.numberValue();
  return new Value(365 * (y - 1970) + Math.floor((y - 1969) / 4) - Math.floor((y - 1901) / 100) + Math.floor((y - 1601) / 400));
}
function TimeFromYear(y) {
  return new Value(msPerDay * DayFromYear(y).numberValue());
}
const msPerAverageYear = 12 * 30.436875 * msPerDay;
function YearFromTime(t) {
  t = t.numberValue();
  let year = Math.floor((t + msPerAverageYear / 2) / msPerAverageYear) + 1970;

  if (TimeFromYear(new Value(year)).numberValue() > t) {
    year -= 1;
  }

  return new Value(year);
}
function InLeapYear(t) {
  if (DaysInYear(YearFromTime(t)).numberValue() === 365) {
    return new Value(0);
  }

  if (DaysInYear(YearFromTime(t)).numberValue() === 366) {
    return new Value(1);
  }
} // 20.3.1.4 #sec-month-number

function MonthFromTime(t) {
  const dayWithinYear = DayWithinYear(t).numberValue();
  const inLeapYear = InLeapYear(t).numberValue();

  if (dayWithinYear >= 0 && dayWithinYear < 31) {
    return new Value(0);
  }

  if (dayWithinYear >= 31 && dayWithinYear < 59 + inLeapYear) {
    return new Value(1);
  }

  if (dayWithinYear >= 59 + inLeapYear && dayWithinYear < 90 + inLeapYear) {
    return new Value(2);
  }

  if (dayWithinYear >= 90 + inLeapYear && dayWithinYear < 120 + inLeapYear) {
    return new Value(3);
  }

  if (dayWithinYear >= 120 + inLeapYear && dayWithinYear < 151 + inLeapYear) {
    return new Value(4);
  }

  if (dayWithinYear >= 151 + inLeapYear && dayWithinYear < 181 + inLeapYear) {
    return new Value(5);
  }

  if (dayWithinYear >= 181 + inLeapYear && dayWithinYear < 212 + inLeapYear) {
    return new Value(6);
  }

  if (dayWithinYear >= 212 + inLeapYear && dayWithinYear < 243 + inLeapYear) {
    return new Value(7);
  }

  if (dayWithinYear >= 243 + inLeapYear && dayWithinYear < 273 + inLeapYear) {
    return new Value(8);
  }

  if (dayWithinYear >= 273 + inLeapYear && dayWithinYear < 304 + inLeapYear) {
    return new Value(9);
  }

  if (dayWithinYear >= 304 + inLeapYear && dayWithinYear < 334 + inLeapYear) {
    return new Value(10);
  }

  if (dayWithinYear >= 334 + inLeapYear && dayWithinYear < 365 + inLeapYear) {
    return new Value(11);
  }
}
function DayWithinYear(t) {
  return new Value(Day(t).numberValue() - DayFromYear(YearFromTime(t)).numberValue());
} // 20.3.1.5 #sec-date-number

function DateFromTime(t) {
  const dayWithinYear = DayWithinYear(t).numberValue();
  const monthFromTime = MonthFromTime(t).numberValue();
  const inLeapYear = InLeapYear(t).numberValue();

  switch (monthFromTime) {
    case 0:
      return new Value(dayWithinYear + 1);

    case 1:
      return new Value(dayWithinYear - 30);

    case 2:
      return new Value(dayWithinYear - 58 - inLeapYear);

    case 3:
      return new Value(dayWithinYear - 89 - inLeapYear);

    case 4:
      return new Value(dayWithinYear - 119 - inLeapYear);

    case 5:
      return new Value(dayWithinYear - 150 - inLeapYear);

    case 6:
      return new Value(dayWithinYear - 180 - inLeapYear);

    case 7:
      return new Value(dayWithinYear - 211 - inLeapYear);

    case 8:
      return new Value(dayWithinYear - 242 - inLeapYear);

    case 9:
      return new Value(dayWithinYear - 272 - inLeapYear);

    case 10:
      return new Value(dayWithinYear - 303 - inLeapYear);

    case 11:
      return new Value(dayWithinYear - 333 - inLeapYear);

  }
} // 20.3.1.6 #sec-week-day

function WeekDay(t) {
  return new Value(mod(Day(t).numberValue() + 4, 7));
} // 20.3.1.7 #sec-local-time-zone-adjustment

function LocalTZA()
/* t, isUTC */
{
  // TODO: implement this function properly.
  return 0;
} // 20.3.1.8 #sec-localtime

function LocalTime(t) {
  return new Value(t.numberValue() + LocalTZA());
} // 20.3.1.9 #sec-utc-t

function UTC(t) {
  return new Value(t.numberValue() - LocalTZA());
} // 20.3.1.10 #sec-hours-minutes-second-and-milliseconds

function HourFromTime(t) {
  return new Value(mod(Math.floor(t.numberValue() / msPerHour), HoursPerDay));
}
function MinFromTime(t) {
  return new Value(mod(Math.floor(t.numberValue() / msPerMinute), MinutesPerHour));
}
function SecFromTime(t) {
  return new Value(mod(Math.floor(t.numberValue() / msPerSecond), SecondsPerMinute));
}
function msFromTime(t) {
  return new Value(mod(t.numberValue(), msPerSecond));
}
const HoursPerDay = 24;
const MinutesPerHour = 60;
const SecondsPerMinute = 60;
const msPerSecond = 1000;
const msPerMinute = msPerSecond * SecondsPerMinute;
const msPerHour = msPerMinute * MinutesPerHour; // 20.3.1.11 #sec-maketime

function MakeTime(hour, min, sec, ms) {
  if (!Number.isFinite(hour.numberValue()) || !Number.isFinite(min.numberValue()) || !Number.isFinite(sec.numberValue()) || !Number.isFinite(ms.numberValue())) {
    return new Value(NaN);
  }

  let _temp = ToInteger(hour);

  Assert(!(_temp instanceof AbruptCompletion), "ToInteger(hour)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const h = _temp.numberValue();

  let _temp2 = ToInteger(min);

  Assert(!(_temp2 instanceof AbruptCompletion), "ToInteger(min)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const m = _temp2.numberValue();

  let _temp3 = ToInteger(sec);

  Assert(!(_temp3 instanceof AbruptCompletion), "ToInteger(sec)" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const s = _temp3.numberValue();

  let _temp4 = ToInteger(ms);

  Assert(!(_temp4 instanceof AbruptCompletion), "ToInteger(ms)" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const milli = _temp4.numberValue();

  const t = h * msPerHour + m * msPerMinute + s * msPerSecond + milli;
  return new Value(t);
}
const daysWithinYearToEndOfMonth = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]; // 20.3.1.12 #sec-makeday

function MakeDay(year, month, date) {
  if (!Number.isFinite(year.numberValue()) || !Number.isFinite(month.numberValue()) || !Number.isFinite(date.numberValue())) {
    return new Value(NaN);
  }

  let _temp5 = ToInteger(year);

  Assert(!(_temp5 instanceof AbruptCompletion), "ToInteger(year)" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const y = _temp5.numberValue();

  let _temp6 = ToInteger(month);

  Assert(!(_temp6 instanceof AbruptCompletion), "ToInteger(month)" + ' returned an abrupt completion');

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const m = _temp6.numberValue();

  let _temp7 = ToInteger(date);

  Assert(!(_temp7 instanceof AbruptCompletion), "ToInteger(date)" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const dt = _temp7.numberValue();

  const ym = y + Math.floor(m / 12);
  const mn = mod(m, 12);
  const ymday = DayFromYear(new Value(ym + (mn > 1 ? 1 : 0))).numberValue() - 365 * (mn > 1 ? 1 : 0) + daysWithinYearToEndOfMonth[mn];
  const t = new Value(ymday * msPerDay);
  return new Value(Day(t).numberValue() + dt - 1);
} // 20.3.1.13 #sec-makedate

function MakeDate(day, time) {
  if (!Number.isFinite(day.numberValue()) || !Number.isFinite(time.numberValue())) {
    return new Value(NaN);
  }

  return new Value(day.numberValue() * msPerDay + time.numberValue());
} // 20.3.1.14 #sec-timeclip

function TimeClip(time) {
  if (!Number.isFinite(time.numberValue())) {
    return new Value(NaN);
  }

  if (Math.abs(time.numberValue()) > 8.64e15) {
    return new Value(NaN);
  }

  let _temp8 = ToInteger(time);

  Assert(!(_temp8 instanceof AbruptCompletion), "ToInteger(time)" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  let clippedTime = _temp8.numberValue();

  if (Object.is(clippedTime, -0)) {
    clippedTime = 0;
  }

  return new Value(clippedTime);
}

// 8.3 #sec-execution-contexts
// 8.3.1 #sec-getactivescriptormodule

function GetActiveScriptOrModule() {
  if (surroundingAgent.executionContextStack.length === 0) {
    return Value.null;
  }

  for (let i = surroundingAgent.executionContextStack.length - 1; i >= 0; i -= 1) {
    const e = surroundingAgent.executionContextStack[i];

    if (e.ScriptOrModule !== undefined) {
      return e.ScriptOrModule;
    }
  }

  return Value.null;
} // 8.3.2 #sec-resolvebinding

function ResolveBinding(name, env, strict) {
  if (!env || Type(env) === 'Undefined') {
    env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  }

  Assert(env instanceof LexicalEnvironment, "env instanceof LexicalEnvironment");
  return GetIdentifierReference(env, name, strict ? Value.true : Value.false);
} // 8.3.3 #sec-getthisenvironment

function GetThisEnvironment() {
  let lex = surroundingAgent.runningExecutionContext.LexicalEnvironment;

  while (true) {
    // eslint-disable-line no-constant-condition
    const envRec = lex.EnvironmentRecord;
    const exists = envRec.HasThisBinding();

    if (exists === Value.true) {
      return envRec;
    }

    const outer = lex.outerEnvironmentReference;
    Assert(Type(outer) !== 'Null', "Type(outer) !== 'Null'");
    lex = outer;
  }
} // 8.3.4 #sec-resolvethisbinding

function ResolveThisBinding() {
  const envRec = GetThisEnvironment();
  return envRec.GetThisBinding();
} // 8.3.5 #sec-getnewtarget

function GetNewTarget() {
  const envRec = GetThisEnvironment();
  Assert('NewTarget' in envRec, "'NewTarget' in envRec");
  return envRec.NewTarget;
} // 8.3.6 #sec-getglobalobject

function GetGlobalObject() {
  const currentRealm = surroundingAgent.currentRealmRecord;
  return currentRealm.GlobalObject;
}

// 9.2 #sec-ecmascript-function-objects
// 9.3 #sec-built-in-function-objects
// and
// 14.9 #sec-tail-position-calls
// 9.2.1.1 #sec-prepareforordinarycall

function PrepareForOrdinaryCall(F, newTarget) {
  Assert(Type(newTarget) === 'Undefined' || Type(newTarget) === 'Object', "Type(newTarget) === 'Undefined' || Type(newTarget) === 'Object'"); // const callerContext = surroundingAgent.runningExecutionContext;

  const calleeContext = new ExecutionContext();
  calleeContext.Function = F;
  const calleeRealm = F.Realm;
  calleeContext.Realm = calleeRealm;
  calleeContext.ScriptOrModule = F.ScriptOrModule;
  const localEnv = NewFunctionEnvironment(F, newTarget);
  calleeContext.LexicalEnvironment = localEnv;
  calleeContext.VariableEnvironment = localEnv; // Suspend(callerContext);

  surroundingAgent.executionContextStack.push(calleeContext);
  return calleeContext;
} // 9.2.1.2 #sec-ordinarycallbindthis


function OrdinaryCallBindThis(F, calleeContext, thisArgument) {
  const thisMode = F.ThisMode;

  if (thisMode === 'lexical') {
    return new NormalCompletion(Value.undefined);
  }

  const calleeRealm = F.Realm;
  const localEnv = calleeContext.LexicalEnvironment;
  let thisValue;

  if (thisMode === 'strict') {
    thisValue = thisArgument;
  } else {
    if (thisArgument === Value.undefined || thisArgument === Value.null) {
      const globalEnv = calleeRealm.GlobalEnv;
      const globalEnvRec = globalEnv.EnvironmentRecord;
      Assert(globalEnvRec instanceof GlobalEnvironmentRecord, "globalEnvRec instanceof GlobalEnvironmentRecord");
      thisValue = globalEnvRec.GlobalThisValue;
    } else {
      let _temp = ToObject(thisArgument);

      Assert(!(_temp instanceof AbruptCompletion), "ToObject(thisArgument)" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      thisValue = _temp; // NOTE: ToObject produces wrapper objects using calleeRealm.
    }
  }

  const envRec = localEnv.EnvironmentRecord;
  Assert(envRec instanceof FunctionEnvironmentRecord, "envRec instanceof FunctionEnvironmentRecord");
  Assert(envRec.ThisBindingStatus !== 'initialized', "envRec.ThisBindingStatus !== 'initialized'");
  return envRec.BindThisValue(thisValue);
} // 9.2.1.3 #sec-ordinarycallevaluatebody


function* OrdinaryCallEvaluateBody(F, argumentsList) {
  switch (getFunctionBodyType(F.ECMAScriptCode)) {
    // FunctionBody : FunctionStatementList
    // ConciseBody : `{` FunctionBody `}`
    case 'FunctionBody':
    case 'ConciseBody_FunctionBody':
      return yield* EvaluateBody_FunctionBody(F.ECMAScriptCode.body.body, F, argumentsList);
    // ConciseBody : ExpressionBody

    case 'ConciseBody_ExpressionBody':
      return yield* EvaluateBody_ConciseBody_ExpressionBody(F.ECMAScriptCode.body, F, argumentsList);

    case 'GeneratorBody':
      return yield* EvaluateBody_GeneratorBody(F.ECMAScriptCode.body.body, F, argumentsList);

    case 'AsyncFunctionBody':
    case 'AsyncConciseBody_AsyncFunctionBody':
      return yield* EvaluateBody_AsyncFunctionBody(F.ECMAScriptCode.body.body, F, argumentsList);

    case 'AsyncConciseBody_ExpressionBody':
      return yield* EvaluateBody_AsyncConciseBody_ExpressionBody(F.ECMAScriptCode.body, F, argumentsList);

    case 'AsyncGeneratorBody':
      return yield* EvaluateBody_AsyncGeneratorBody(F.ECMAScriptCode.body.body, F, argumentsList);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('OrdinaryCallEvaluateBody', F.ECMAScriptCode);
  }
} // 9.2.1 #sec-ecmascript-function-objects-call-thisargument-argumentslist

function FunctionCallSlot(thisArgument, argumentsList) {
  const F = this;
  Assert(F instanceof FunctionValue, "F instanceof FunctionValue");

  if (F.IsClassConstructor === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', F);
  } // const callerContext = surroundingAgent.runningExecutionContext;


  const calleeContext = PrepareForOrdinaryCall(F, Value.undefined);
  Assert(surroundingAgent.runningExecutionContext === calleeContext, "surroundingAgent.runningExecutionContext === calleeContext");
  OrdinaryCallBindThis(F, calleeContext, thisArgument);
  let result = EnsureCompletion(unwind(OrdinaryCallEvaluateBody(F, argumentsList))); // Remove calleeContext from the execution context stack and
  // restore callerContext as the running execution context.

  surroundingAgent.executionContextStack.pop(calleeContext);

  if (result.Type === 'return') {
    return new NormalCompletion(result.Value);
  }

  /* istanbul ignore if */
  if (result instanceof AbruptCompletion) {
    return result;
  }
  /* istanbul ignore if */


  if (result instanceof Completion) {
    result = result.Value;
  }
  return new NormalCompletion(Value.undefined);
} // 9.2.2 #sec-ecmascript-function-objects-construct-argumentslist-newtarget


function FunctionConstructSlot(argumentsList, newTarget) {
  const F = this;
  Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
  Assert(Type(newTarget) === 'Object', "Type(newTarget) === 'Object'"); // const callerContext = surroundingAgent.runningExecutionContext;

  const kind = F.ConstructorKind;
  let thisArgument;

  if (kind === 'base') {
    let _temp2 = OrdinaryCreateFromConstructor(newTarget, '%Object.prototype%');
    /* istanbul ignore if */


    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }
    /* istanbul ignore if */


    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    thisArgument = _temp2;
  }

  const calleeContext = PrepareForOrdinaryCall(F, newTarget);
  Assert(surroundingAgent.runningExecutionContext === calleeContext, "surroundingAgent.runningExecutionContext === calleeContext");

  if (kind === 'base') {
    OrdinaryCallBindThis(F, calleeContext, thisArgument);
  }

  const constructorEnv = calleeContext.LexicalEnvironment;
  const envRec = constructorEnv.EnvironmentRecord;
  let result = EnsureCompletion(unwind(OrdinaryCallEvaluateBody(F, argumentsList))); // Remove calleeContext from the execution context stack and
  // restore callerContext as the running execution context.

  surroundingAgent.executionContextStack.pop(calleeContext);

  if (result.Type === 'return') {
    if (Type(result.Value) === 'Object') {
      return new NormalCompletion(result.Value);
    }

    if (kind === 'base') {
      return new NormalCompletion(thisArgument);
    }

    if (Type(result.Value) !== 'Undefined') {
      return surroundingAgent.Throw('TypeError', 'DerivedConstructorReturnedNonObject');
    }
  } else {
    if (result instanceof AbruptCompletion) {
      return result;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }
  }

  return envRec.GetThisBinding();
} // 9.2 #sec-ecmascript-function-objects


const esFunctionInternalSlots = Object.freeze(['Environment', 'FormalParameters', 'ECMAScriptCode', 'ConstructorKind', 'Realm', 'ScriptOrModule', 'ThisMode', 'Strict', 'HomeObject', 'IsClassConstructor']); // 9.2.3 #sec-functionallocate

function OrdinaryFunctionCreate(functionPrototype, ParameterList, Body, thisMode, Scope) {
  Assert(Type(functionPrototype) === 'Object', "Type(functionPrototype) === 'Object'");
  const F = new FunctionValue(functionPrototype);

  for (const internalSlot of esFunctionInternalSlots) {
    F[internalSlot] = Value.undefined;
  }

  F.Call = FunctionCallSlot;
  F.Prototype = functionPrototype;
  F.Extensible = Value.true;
  F.Environment = Scope;
  F.FormalParameters = ParameterList;
  F.ECMAScriptCode = Body;
  const Strict = isStrictModeCode(Body);
  F.Strict = Strict;

  if (thisMode === 'lexical-this') {
    F.ThisMode = 'lexical';
  } else if (Strict) {
    F.ThisMode = 'strict';
  } else {
    F.ThisMode = 'global';
  }

  F.IsClassConstructor = Value.false;
  F.Environment = Scope;
  F.ScriptOrModule = GetActiveScriptOrModule();
  F.Realm = surroundingAgent.currentRealmRecord;
  const len = ExpectedArgumentCount(ParameterList);

  let _temp3 = SetFunctionLength(F, new Value(len));

  Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionLength(F, new Value(len))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  return F;
} // 9.2.10 #sec-makeconstructor

function MakeConstructor(F, writablePrototype, prototype) {
  Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
  Assert(IsConstructor(F) === Value.false, "IsConstructor(F) === Value.false");

  let _temp4 = IsExtensible(F);

  Assert(!(_temp4 instanceof AbruptCompletion), "IsExtensible(F)" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  let _temp5 = HasOwnProperty$1(F, new Value('prototype'));

  Assert(!(_temp5 instanceof AbruptCompletion), "HasOwnProperty(F, new Value('prototype'))" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  Assert(_temp4 === Value.true && _temp5 === Value.false, "X(IsExtensible(F)) === Value.true && X(HasOwnProperty(F, new Value('prototype'))) === Value.false");
  F.Construct = FunctionConstructSlot;
  F.ConstructorKind = 'base';

  if (writablePrototype === undefined) {
    writablePrototype = true;
  }

  if (prototype === undefined) {
    prototype = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

    let _temp6 = DefinePropertyOrThrow(prototype, new Value('constructor'), Descriptor({
      Value: F,
      Writable: writablePrototype ? Value.true : Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }));

    Assert(!(_temp6 instanceof AbruptCompletion), "DefinePropertyOrThrow(prototype, new Value('constructor'), Descriptor({\n      Value: F,\n      Writable: writablePrototype ? Value.true : Value.false,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    }))" + ' returned an abrupt completion');

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
  }

  let _temp7 = DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({
    Value: prototype,
    Writable: writablePrototype ? Value.true : Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp7 instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: writablePrototype ? Value.true : Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }
  return new NormalCompletion(Value.undefined);
} // 9.2.11 #sec-makeclassconstructor

function MakeClassConstructor(F) {
  Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
  Assert(F.IsClassConstructor === Value.false, "F.IsClassConstructor === Value.false");
  F.IsClassConstructor = Value.true;
  return new NormalCompletion(Value.undefined);
} // 9.2.12 #sec-makemethod

function MakeMethod(F, homeObject) {
  Assert(F instanceof FunctionValue, "F instanceof FunctionValue");
  Assert(Type(homeObject) === 'Object', "Type(homeObject) === 'Object'");
  F.HomeObject = homeObject;
  return new NormalCompletion(Value.undefined);
} // 9.2.13 #sec-setfunctionname

function SetFunctionName(F, name, prefix) {
  Assert(IsExtensible(F) === Value.true && HasOwnProperty$1(F, new Value('name')) === Value.false, "IsExtensible(F) === Value.true && HasOwnProperty(F, new Value('name')) === Value.false");
  Assert(Type(name) === 'Symbol' || Type(name) === 'String', "Type(name) === 'Symbol' || Type(name) === 'String'");
  Assert(!prefix || Type(prefix) === 'String', "!prefix || Type(prefix) === 'String'");

  if (Type(name) === 'Symbol') {
    const description = name.Description;

    if (Type(description) === 'Undefined') {
      name = new Value('');
    } else {
      name = new Value(`[${description.stringValue()}]`);
    }
  }

  if (prefix !== undefined) {
    name = new Value(`${prefix.stringValue()} ${name.stringValue()}`);
  }

  let _temp8 = DefinePropertyOrThrow(F, new Value('name'), Descriptor({
    Value: name,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp8 instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('name'), Descriptor({\n    Value: name,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  return _temp8;
} // 9.2.14 #sec-setfunctionlength

function SetFunctionLength(F, length) {
  Assert(IsExtensible(F) === Value.true && HasOwnProperty$1(F, new Value('length')) === Value.false, "IsExtensible(F) === Value.true && HasOwnProperty(F, new Value('length')) === Value.false");
  Assert(Type(length) === 'Number', "Type(length) === 'Number'");

  let _temp9 = IsInteger(length);

  Assert(!(_temp9 instanceof AbruptCompletion), "IsInteger(length)" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  Assert(length.numberValue() >= 0 && _temp9 === Value.true, "length.numberValue() >= 0 && X(IsInteger(length)) === Value.true");

  let _temp10 = DefinePropertyOrThrow(F, new Value('length'), Descriptor({
    Value: length,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp10 instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('length'), Descriptor({\n    Value: length,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  return _temp10;
} // 9.3.3 #sec-createbuiltinfunction

function CreateBuiltinFunction(steps, internalSlotsList, realm, prototype, isConstructor = Value.false) {
  Assert(typeof steps === 'function', "typeof steps === 'function'");

  if (realm === undefined) {
    realm = surroundingAgent.currentRealmRecord;
  }

  Assert(realm instanceof Realm, "realm instanceof Realm");

  if (prototype === undefined) {
    prototype = realm.Intrinsics['%Function.prototype%'];
  }

  const func = new BuiltinFunctionValue(steps, isConstructor);

  for (const slot of internalSlotsList) {
    func[slot] = Value.undefined;
  }

  func.Realm = realm;
  func.Prototype = prototype;
  func.Extensible = Value.true;
  func.ScriptOrModule = Value.null;
  return func;
} // 14.9.3 #sec-preparefortailcall

function PrepareForTailCall() {// const leafContext = surroundingAgent.runningExecutionContext;
  // Suspend(leafContext);
  // surroundingAgent.executionContextStack.pop();
  // Assert: leafContext has no further use. It will never
  // be activated as the running execution context.
}

// 25.4 #sec-generator-objects
// 25.4.3.1 #sec-generatorstart

function GeneratorStart(generator, generatorBody) {
  Assert(Type(generator.GeneratorState) === 'Undefined', "Type(generator.GeneratorState) === 'Undefined'");
  const genContext = surroundingAgent.runningExecutionContext;
  genContext.Generator = generator;

  genContext.codeEvaluationState = function* resumer() {
    const result = EnsureCompletion((yield* Evaluate_FunctionBody(generatorBody)));
    surroundingAgent.executionContextStack.pop(genContext);
    generator.GeneratorState = 'completed';
    genContext.codeEvaluationState = null;
    let resultValue;

    if (result.Type === 'normal') {
      resultValue = Value.undefined;
    } else if (result.Type === 'return') {
      resultValue = result.Value;
    } else {
      Assert(result.Type === 'throw', "result.Type === 'throw'");
      return Completion(result);
    }

    let _temp = CreateIterResultObject(resultValue, Value.true);

    Assert(!(_temp instanceof AbruptCompletion), "CreateIterResultObject(resultValue, Value.true)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    return _temp;
  }();

  generator.GeneratorContext = genContext;
  generator.GeneratorState = 'suspendedStart';
  return new NormalCompletion(Value.undefined);
} // 25.4.3.2 #sec-generatorvalidate

function GeneratorValidate(generator) {
  let _temp2 = RequireInternalSlot(generator, 'GeneratorState');
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  Assert('GeneratorContext' in generator, "'GeneratorContext' in generator");
  const state = generator.GeneratorState;

  if (state === 'executing') {
    return surroundingAgent.Throw('TypeError', 'GeneratorRunning');
  }

  return state;
} // 25.4.3.3 #sec-generatorresume

function GeneratorResume(generator, value) {
  let _temp3 = GeneratorValidate(generator);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const state = _temp3;

  if (state === 'completed') {
    let _temp4 = CreateIterResultObject(Value.undefined, Value.true);

    Assert(!(_temp4 instanceof AbruptCompletion), "CreateIterResultObject(Value.undefined, Value.true)" + ' returned an abrupt completion');

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    return _temp4;
  }

  Assert(state === 'suspendedStart' || state === 'suspendedYield', "state === 'suspendedStart' || state === 'suspendedYield'");
  const genContext = generator.GeneratorContext;
  const originalStackLength = surroundingAgent.executionContextStack.length;
  const methodContext = surroundingAgent.runningExecutionContext; // Suspend methodContext.

  generator.GeneratorState = 'executing';
  surroundingAgent.executionContextStack.push(genContext);
  const result = resume(genContext, new NormalCompletion(value));
  Assert(surroundingAgent.runningExecutionContext === methodContext, "surroundingAgent.runningExecutionContext === methodContext");
  Assert(surroundingAgent.executionContextStack.length === originalStackLength, "surroundingAgent.executionContextStack.length === originalStackLength");
  return Completion(result);
} // 25.4.3.4 #sec-generatorresumeabrupt

function GeneratorResumeAbrupt(generator, abruptCompletion) {
  Assert(abruptCompletion instanceof AbruptCompletion, "abruptCompletion instanceof AbruptCompletion");

  let _temp5 = GeneratorValidate(generator);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  let state = _temp5;

  if (state === 'suspendedStart') {
    generator.GeneratorState = 'completed';
    generator.GeneratorContext = null;
    state = 'completed';
  }

  if (state === 'completed') {
    if (abruptCompletion.Type === 'return') {
      let _temp6 = CreateIterResultObject(abruptCompletion.Value, Value.true);

      Assert(!(_temp6 instanceof AbruptCompletion), "CreateIterResultObject(abruptCompletion.Value, Value.true)" + ' returned an abrupt completion');

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }

      return _temp6;
    }

    return Completion(abruptCompletion);
  }

  Assert(state === 'suspendedYield', "state === 'suspendedYield'");
  const genContext = generator.GeneratorContext;
  const originalStackLength = surroundingAgent.executionContextStack.length;
  const methodContext = surroundingAgent.runningExecutionContext; // Suspend methodContext.

  generator.GeneratorState = 'executing';
  surroundingAgent.executionContextStack.push(genContext);
  const result = resume(genContext, abruptCompletion);
  Assert(surroundingAgent.runningExecutionContext === methodContext, "surroundingAgent.runningExecutionContext === methodContext");
  Assert(surroundingAgent.executionContextStack.length === originalStackLength, "surroundingAgent.executionContextStack.length === originalStackLength");
  return Completion(result);
} // 25.4.3.5 #sec-getgeneratorkind

function GetGeneratorKind() {
  const genContext = surroundingAgent.runningExecutionContext;

  if (!genContext.Generator) {
    return 'non-generator';
  }

  const generator = genContext.Generator;

  if ('AsyncGeneratorState' in generator) {
    return 'async';
  }

  return 'sync';
} // 25.4.3.6 #sec-generatoryield

function* GeneratorYield(iterNextObj) {
  const genContext = surroundingAgent.runningExecutionContext;
  const generator = genContext.Generator;
  Assert(GetGeneratorKind() === 'sync', "GetGeneratorKind() === 'sync'");
  generator.GeneratorState = 'suspendedYield';
  surroundingAgent.executionContextStack.pop(genContext);
  const resumptionValue = yield new NormalCompletion(iterNextObj);
  return resumptionValue;
}

// 18 #sec-global-object
// 18.2.1.1 #sec-performeval

function PerformEval(x, callerRealm, strictCaller, direct) {
  if (direct === false) {
    Assert(strictCaller === false, "strictCaller === false");
  }

  if (Type(x) !== 'String') {
    return x;
  }

  const evalRealm = surroundingAgent.currentRealmRecord;

  let _temp = HostEnsureCanCompileStrings(callerRealm, evalRealm);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  /*
  const thisEnvRec = X(GetThisEnvironment());
  let inFunction;
  let inMethod;
  let inDerivedConstructor;
  if (thisEnvRec instanceof FunctionEnvironmentRecord) {
    const F = thisEnvRec.FunctionObject;
    inFunction = true;
    inMethod = thisEnvRec.HasSuperBinding() === Value.true;
    if (F.ConstructorKind === 'derived') {
      inDerivedConstructor = true;
    } else {
      inDerivedConstructor = false;
    }
  } else {
    inFunction = false;
    inMethod = false;
    inDerivedConstructor = false;
  }
  */

  const r = ParseScript(x.stringValue(), evalRealm, undefined, strictCaller);

  if (Array.isArray(r)) {
    return surroundingAgent.Throw(r[0]);
  }

  const script = r.ECMAScriptCode; // If script Contains ScriptBody is false, return undefined.

  const body = script.body;
  let strictEval;

  if (strictCaller === true) {
    strictEval = true;
  } else {
    strictEval = IsStrict(script);
  }

  const runningContext = surroundingAgent.runningExecutionContext;
  let lexEnv;
  let varEnv;

  if (direct === true) {
    lexEnv = NewDeclarativeEnvironment(runningContext.LexicalEnvironment);
    varEnv = runningContext.VariableEnvironment;
  } else {
    lexEnv = NewDeclarativeEnvironment(evalRealm.GlobalEnv);
    varEnv = evalRealm.GlobalEnv;
  }

  if (strictEval === true) {
    varEnv = lexEnv;
  } // If runningContext is not already suspended, suspend runningContext.


  const evalContext = new ExecutionContext();
  evalContext.Function = Value.null;
  evalContext.Realm = evalRealm;
  evalContext.ScriptOrModule = runningContext.ScriptOrModule;
  evalContext.VariableEnvironment = varEnv;
  evalContext.LexicalEnvironment = lexEnv;
  surroundingAgent.executionContextStack.push(evalContext);
  let result = EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval);

  if (result.Type === 'normal') {
    result = Evaluate_Script(body);
  }

  if (result.Type === 'normal' && result.Value === undefined) {
    result = new NormalCompletion(Value.undefined);
  }

  surroundingAgent.executionContextStack.pop(evalContext); // Resume the context that is now on the top of the execution context stack as the running execution context.

  return Completion(result);
} // 18.2.1.3 #sec-evaldeclarationinstantiation

function EvalDeclarationInstantiation(body, varEnv, lexEnv, strict) {
  const varNames = VarDeclaredNames_ScriptBody(body).map(Value);
  const varDeclarations = VarScopedDeclarations_ScriptBody(body);
  const lexEnvRec = lexEnv.EnvironmentRecord;
  const varEnvRec = varEnv.EnvironmentRecord;

  if (strict === false) {
    if (varEnvRec instanceof GlobalEnvironmentRecord) {
      for (const name of varNames) {
        if (varEnvRec.HasLexicalDeclaration(name) === Value.true) {
          return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
        } // NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.

      }
    }

    let thisLex = lexEnv; // Assert: The following loop will terminate.

    while (thisLex !== varEnv) {
      const thisEnvRec = thisLex.EnvironmentRecord;

      if (!(thisEnvRec instanceof ObjectEnvironmentRecord)) {
        for (const name of varNames) {
          if (thisEnvRec.HasBinding(name) === Value.true) {
            return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name); // NOTE: Annex B.3.5 defines alternate semantics for the above step.
          } // NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration

        }
      }

      thisLex = thisLex.outerEnvironmentReference;
    }
  }

  const functionsToInitialize = [];
  const declaredFunctionNames = [];

  for (const d of [...varDeclarations].reverse()) {
    if (!isVariableDeclaration(d) && !isForBinding(d) && !isBindingIdentifier(d)) {
      Assert(isFunctionDeclaration(d) || isGeneratorDeclaration(d) || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d), "isFunctionDeclaration(d) || isGeneratorDeclaration(d)\n             || isAsyncFunctionDeclaration(d) || isAsyncGeneratorDeclaration(d)");
      const fn = new Value(BoundNames_FunctionDeclaration(d)[0]);

      if (!declaredFunctionNames.includes(fn)) {
        if (varEnvRec instanceof GlobalEnvironmentRecord) {
          let _temp2 = varEnvRec.CanDeclareGlobalFunction(fn);

          if (_temp2 instanceof AbruptCompletion) {
            return _temp2;
          }

          if (_temp2 instanceof Completion) {
            _temp2 = _temp2.Value;
          }

          const fnDefinable = _temp2;

          if (fnDefinable === Value.false) {
            return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', fn);
          }
        }

        declaredFunctionNames.push(fn);
        functionsToInitialize.unshift(d);
      }
    }
  } // NOTE: Annex B.3.3.3 adds additional steps at this point.


  const declaredVarNames = [];

  for (const d of varDeclarations) {
    let boundNames;

    if (isVariableDeclaration(d)) {
      boundNames = BoundNames_VariableDeclaration(d);
    } else if (isForBinding(d)) {
      boundNames = BoundNames_ForBinding(d);
    } else if (isBindingIdentifier(d)) {
      boundNames = BoundNames_BindingIdentifier(d);
    }

    if (boundNames !== undefined) {
      for (const vn of boundNames.map(Value)) {
        if (!declaredFunctionNames.includes(vn)) {
          if (varEnvRec instanceof GlobalEnvironmentRecord) {
            let _temp3 = varEnvRec.CanDeclareGlobalVar(vn);

            if (_temp3 instanceof AbruptCompletion) {
              return _temp3;
            }

            if (_temp3 instanceof Completion) {
              _temp3 = _temp3.Value;
            }

            const vnDefinable = _temp3;

            if (vnDefinable === Value.false) {
              return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', vn);
            }
          }

          if (!declaredVarNames.includes(vn)) {
            declaredVarNames.push(vn);
          }
        }
      }
    }
  } // NOTE: No abnormal terminations occur after this algorithm step unless
  // varEnvRec is a global Environment Record and the global object is a Proxy exotic object.


  const lexDeclarations = LexicallyScopedDeclarations_ScriptBody(body);

  for (const d of lexDeclarations) {
    for (const dn of BoundNames_Declaration(d).map(Value)) {
      if (IsConstantDeclaration(d)) {
        let _temp4 = lexEnvRec.CreateImmutableBinding(dn, Value.true);

        if (_temp4 instanceof AbruptCompletion) {
          return _temp4;
        }

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }
      } else {
        let _temp5 = lexEnvRec.CreateMutableBinding(dn, Value.false);

        if (_temp5 instanceof AbruptCompletion) {
          return _temp5;
        }

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }
      }
    }
  }

  for (const f of functionsToInitialize) {
    const fn = new Value(BoundNames_FunctionDeclaration(f)[0]);
    const fo = InstantiateFunctionObject(f, lexEnv);

    if (varEnvRec instanceof GlobalEnvironmentRecord) {
      let _temp6 = varEnvRec.CreateGlobalFunctionBinding(fn, fo, Value.true);

      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }
    } else {
      const bindingExists = varEnvRec.HasBinding(fn);

      if (bindingExists === Value.false) {
        let _temp7 = varEnvRec.CreateMutableBinding(fn, Value.true);

        Assert(!(_temp7 instanceof AbruptCompletion), "varEnvRec.CreateMutableBinding(fn, Value.true)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        const status = _temp7;
        Assert(!(status instanceof AbruptCompletion), "!(status instanceof AbruptCompletion)");

        let _temp8 = varEnvRec.InitializeBinding(fn, fo);

        Assert(!(_temp8 instanceof AbruptCompletion), "varEnvRec.InitializeBinding(fn, fo)" + ' returned an abrupt completion');

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }
      } else {
        let _temp9 = varEnvRec.SetMutableBinding(fn, fo, Value.false);

        Assert(!(_temp9 instanceof AbruptCompletion), "varEnvRec.SetMutableBinding(fn, fo, Value.false)" + ' returned an abrupt completion');

        if (_temp9 instanceof Completion) {
          _temp9 = _temp9.Value;
        }
      }
    }
  }

  for (const vn of declaredVarNames) {
    if (!declaredFunctionNames.includes(vn)) {
      if (varEnvRec instanceof GlobalEnvironmentRecord) {
        let _temp10 = varEnvRec.CreateGlobalVarBinding(vn, Value.true);

        if (_temp10 instanceof AbruptCompletion) {
          return _temp10;
        }

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }
      } else {
        const bindingExists = varEnvRec.HasBinding(vn);

        if (bindingExists === Value.false) {
          let _temp11 = varEnvRec.CreateMutableBinding(vn, Value.true);

          Assert(!(_temp11 instanceof AbruptCompletion), "varEnvRec.CreateMutableBinding(vn, Value.true)" + ' returned an abrupt completion');

          if (_temp11 instanceof Completion) {
            _temp11 = _temp11.Value;
          }

          const status = _temp11;
          Assert(!(status instanceof AbruptCompletion), "!(status instanceof AbruptCompletion)");

          let _temp12 = varEnvRec.InitializeBinding(vn, Value.undefined);

          Assert(!(_temp12 instanceof AbruptCompletion), "varEnvRec.InitializeBinding(vn, Value.undefined)" + ' returned an abrupt completion');

          if (_temp12 instanceof Completion) {
            _temp12 = _temp12.Value;
          }
        }
      }
    }
  }

  return new NormalCompletion(undefined);
}

// 7.4 #sec-operations-on-iterator-objects
// and
// 25.1 #sec-iteration
// 7.4.1 #sec-getiterator

function GetIterator(obj, hint, method) {
  if (!hint) {
    hint = 'sync';
  }

  Assert(hint === 'sync' || hint === 'async', "hint === 'sync' || hint === 'async'");

  if (!method) {
    if (hint === 'async') {
      let _temp = GetMethod(obj, wellKnownSymbols.asyncIterator);
      /* istanbul ignore if */


      if (_temp instanceof AbruptCompletion) {
        return _temp;
      }
      /* istanbul ignore if */


      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      method = _temp;

      if (method === Value.undefined) {
        let _temp2 = GetMethod(obj, wellKnownSymbols.iterator);

        if (_temp2 instanceof AbruptCompletion) {
          return _temp2;
        }

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }

        const syncMethod = _temp2;

        let _temp3 = GetIterator(obj, 'sync', syncMethod);

        if (_temp3 instanceof AbruptCompletion) {
          return _temp3;
        }

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }

        const syncIteratorRecord = _temp3;
        return CreateAsyncFromSyncIterator(syncIteratorRecord);
      }
    } else {
      let _temp4 = GetMethod(obj, wellKnownSymbols.iterator);

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      method = _temp4;
    }
  }

  let _temp5 = Call(method, obj);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const iterator = _temp5;

  if (Type(iterator) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', iterator);
  }

  let _temp6 = GetV(iterator, new Value('next'));

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const nextMethod = _temp6;
  const iteratorRecord = {
    Iterator: iterator,
    NextMethod: nextMethod,
    Done: Value.false
  };
  return EnsureCompletion(iteratorRecord);
} // 7.4.2 #sec-iteratornext

function IteratorNext(iteratorRecord, value) {
  let result;

  if (!value) {
    let _temp7 = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator);

    if (_temp7 instanceof AbruptCompletion) {
      return _temp7;
    }

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    result = _temp7;
  } else {
    let _temp8 = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, [value]);

    if (_temp8 instanceof AbruptCompletion) {
      return _temp8;
    }

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }

    result = _temp8;
  }

  if (Type(result) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', result);
  }

  return EnsureCompletion(result);
} // 7.4.3 #sec-iteratorcomplete

function IteratorComplete(iterResult) {
  Assert(Type(iterResult) === 'Object', "Type(iterResult) === 'Object'");

  let _temp9 = Get(iterResult, new Value('done'));

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  return EnsureCompletion(ToBoolean(_temp9));
} // 7.4.4 #sec-iteratorvalue

function IteratorValue(iterResult) {
  Assert(Type(iterResult) === 'Object', "Type(iterResult) === 'Object'");

  let _temp10 = Get(iterResult, new Value('value'));

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  return EnsureCompletion(_temp10);
} // 7.4.5 #sec-iteratorstep

function IteratorStep(iteratorRecord) {
  let _temp11 = IteratorNext(iteratorRecord);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const result = _temp11;

  let _temp12 = IteratorComplete(result);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const done = _temp12;

  if (done === Value.true) {
    return EnsureCompletion(Value.false);
  }

  return EnsureCompletion(result);
} // 7.4.6 #sec-iteratorclose

function IteratorClose(iteratorRecord, completion) {
  // TODO: completion should be a Completion Record so this should not be necessary
  completion = EnsureCompletion(completion);
  Assert(Type(iteratorRecord.Iterator) === 'Object', "Type(iteratorRecord.Iterator) === 'Object'");
  Assert(completion instanceof Completion, "completion instanceof Completion");
  const iterator = iteratorRecord.Iterator;

  let _temp13 = GetMethod(iterator, new Value('return'));

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  const ret = _temp13;

  if (ret === Value.undefined) {
    return Completion(completion);
  }

  const innerResult = EnsureCompletion(Call(ret, iterator));

  if (completion.Type === 'throw') {
    return Completion(completion);
  }

  if (innerResult.Type === 'throw') {
    return Completion(innerResult);
  }

  if (Type(innerResult.Value) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', innerResult.Value);
  }

  return Completion(completion);
} // 7.4.7 #sec-asynciteratorclose

function* AsyncIteratorClose(iteratorRecord, completion) {
  Assert(Type(iteratorRecord.Iterator) === 'Object', "Type(iteratorRecord.Iterator) === 'Object'");
  Assert(completion instanceof Completion, "completion instanceof Completion");
  const iterator = iteratorRecord.Iterator;

  let _temp14 = GetMethod(iterator, new Value('return'));

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const ret = _temp14;

  if (ret === Value.undefined) {
    return Completion(completion);
  }

  let innerResult = EnsureCompletion(Call(ret, iterator));

  if (innerResult.Type === 'normal') {
    innerResult = EnsureCompletion((yield* Await(innerResult.Value)));
  }

  if (completion.Type === 'throw') {
    return Completion(completion);
  }

  if (innerResult.Type === 'throw') {
    return Completion(innerResult);
  }

  if (Type(innerResult.Value) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', innerResult.Value);
  }

  return Completion(completion);
} // 7.4.8 #sec-createiterresultobject

function CreateIterResultObject(value, done) {
  Assert(Type(done) === 'Boolean', "Type(done) === 'Boolean'");
  const obj = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  let _temp15 = CreateDataProperty(obj, new Value('value'), value);

  Assert(!(_temp15 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('value'), value)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  let _temp16 = CreateDataProperty(obj, new Value('done'), done);

  Assert(!(_temp16 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('done'), done)" + ' returned an abrupt completion');

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }
  return obj;
} // 7.4.9 #sec-createlistiteratorRecord

function CreateListIteratorRecord(list) {
  const iterator = ObjectCreate(surroundingAgent.intrinsic('%IteratorPrototype%'), ['IteratedList', 'ListNextIndex']);
  iterator.IteratedList = list;
  iterator.ListNextIndex = 0;
  const steps = ListIteratorNextSteps;

  let _temp17 = CreateBuiltinFunction(steps, []);

  Assert(!(_temp17 instanceof AbruptCompletion), "CreateBuiltinFunction(steps, [])" + ' returned an abrupt completion');

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  const next = _temp17;
  return {
    Iterator: iterator,
    NextMethod: next,
    Done: Value.false
  };
} // 7.4.9.1 #sec-listiterator-next

function ListIteratorNextSteps(args, {
  thisValue
}) {
  const O = thisValue;
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert('IteratedList' in O, "'IteratedList' in O");
  const list = O.IteratedList;
  const index = O.ListNextIndex;
  const len = list.length;

  if (index >= len) {
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  O.ListNextIndex += 1;
  return CreateIterResultObject(list[index], Value.false);
} // 25.1.4.1 #sec-createasyncfromsynciterator


function CreateAsyncFromSyncIterator(syncIteratorRecord) {
  let _temp18 = ObjectCreate(surroundingAgent.intrinsic('%AsyncFromSyncIteratorPrototype%'), ['SyncIteratorRecord']);

  Assert(!(_temp18 instanceof AbruptCompletion), "ObjectCreate(surroundingAgent.intrinsic('%AsyncFromSyncIteratorPrototype%'), [\n    'SyncIteratorRecord',\n  ])" + ' returned an abrupt completion');

  if (_temp18 instanceof Completion) {
    _temp18 = _temp18.Value;
  }

  const asyncIterator = _temp18;
  asyncIterator.SyncIteratorRecord = syncIteratorRecord;

  let _temp19 = Get(asyncIterator, new Value('next'));

  Assert(!(_temp19 instanceof AbruptCompletion), "Get(asyncIterator, new Value('next'))" + ' returned an abrupt completion');

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  const nextMethod = _temp19;
  return {
    Iterator: asyncIterator,
    NextMethod: nextMethod,
    Done: Value.false
  };
} // 25.1.4.2.4 #sec-async-from-sync-iterator-value-unwrap-functions

function AsyncFromSyncIteratorValueUnwrapFunctions([value = Value.undefined]) {
  const F = this;

  let _temp20 = CreateIterResultObject(value, F.Done);

  Assert(!(_temp20 instanceof AbruptCompletion), "CreateIterResultObject(value, F.Done)" + ' returned an abrupt completion');

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }

  return _temp20;
} // 25.1.4.4 #sec-asyncfromsynciteratorcontinuation


function AsyncFromSyncIteratorContinuation(result, promiseCapability) {
  let done = IteratorComplete(result);

  /* istanbul ignore if */
  if (done instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [done.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }
  /* istanbul ignore if */


  if (done instanceof Completion) {
    done = done.Value;
  }

  let value = IteratorValue(result);

  if (value instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [value.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }

  if (value instanceof Completion) {
    value = value.Value;
  }

  let valueWrapper = PromiseResolve(surroundingAgent.intrinsic('%Promise%'), value);

  if (valueWrapper instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [valueWrapper.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }

  if (valueWrapper instanceof Completion) {
    valueWrapper = valueWrapper.Value;
  }

  const steps = AsyncFromSyncIteratorValueUnwrapFunctions;

  let _temp21 = CreateBuiltinFunction(steps, ['Done']);

  Assert(!(_temp21 instanceof AbruptCompletion), "CreateBuiltinFunction(steps, ['Done'])" + ' returned an abrupt completion');

  if (_temp21 instanceof Completion) {
    _temp21 = _temp21.Value;
  }

  const onFulfilled = _temp21;
  onFulfilled.Done = done;

  let _temp22 = PerformPromiseThen(valueWrapper, onFulfilled, Value.undefined, promiseCapability);

  Assert(!(_temp22 instanceof AbruptCompletion), "PerformPromiseThen(valueWrapper, onFulfilled, Value.undefined, promiseCapability)" + ' returned an abrupt completion');

  if (_temp22 instanceof Completion) {
    _temp22 = _temp22.Value;
  }
  return promiseCapability.Promise;
}

function ModuleNamespaceCreate(module, exports) {
  Assert(module instanceof AbstractModuleRecord, "module instanceof AbstractModuleRecord");
  Assert(module.Namespace === Value.undefined, "module.Namespace === Value.undefined");
  Assert(Array.isArray(exports), "Array.isArray(exports)");
  const M = new ModuleNamespaceExoticObjectValue();
  M.properties.set(wellKnownSymbols.toStringTag, Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false,
    Value: new Value('Module')
  }));
  M.Module = module;
  const sortedExports = [...exports].sort((x, y) => {
    let _temp = SortCompare(x, y, Value.undefined);

    Assert(!(_temp instanceof AbruptCompletion), "SortCompare(x, y, Value.undefined)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const result = _temp;
    return result.numberValue();
  });
  M.Exports = new ValueSet(sortedExports);
  module.Namespace = M;
  return M;
}

function InnerModuleLinking(module, stack, index) {
  if (!(module instanceof CyclicModuleRecord)) {
    let _temp = module.Link();
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }
    return index;
  }

  if (module.Status === 'linking' || module.Status === 'linked' || module.Status === 'evaluated') {
    return index;
  }

  Assert(module.Status === 'unlinked', "module.Status === 'unlinked'");
  module.Status = 'linking';
  module.DFSIndex = index;
  module.DFSAncestorIndex = index;
  index += 1;
  stack.push(module);

  for (const required of module.RequestedModules) {
    let _temp2 = HostResolveImportedModule(module, required);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const requiredModule = _temp2;

    let _temp3 = InnerModuleLinking(requiredModule, stack, index);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    index = _temp3;

    if (requiredModule instanceof CyclicModuleRecord) {
      Assert(requiredModule.Status === 'linking' || requiredModule.Status === 'linked' || requiredModule.Status === 'evaluated', "requiredModule.Status === 'linking' || requiredModule.Status === 'linked' || requiredModule.Status === 'evaluated'");
      Assert(requiredModule.Status === 'linking' === stack.includes(requiredModule), "(requiredModule.Status === 'linking') === stack.includes(requiredModule)");

      if (requiredModule.Status === 'linking') {
        module.DFSAncestorIndex = Math.min(module.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
      }
    }
  }

  let _temp4 = module.InitializeEnvironment();

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  Assert(stack.indexOf(module) === stack.lastIndexOf(module), "stack.indexOf(module) === stack.lastIndexOf(module)");
  Assert(module.DFSAncestorIndex <= module.DFSIndex, "module.DFSAncestorIndex <= module.DFSIndex");

  if (module.DFSAncestorIndex === module.DFSIndex) {
    let done = false;

    while (done === false) {
      const requiredModule = stack.pop();
      Assert(requiredModule instanceof CyclicModuleRecord, "requiredModule instanceof CyclicModuleRecord");
      requiredModule.Status = 'linked';

      if (requiredModule === module) {
        done = true;
      }
    }
  }

  return index;
} // 15.2.1.16.2.1 #sec-innermoduleevaluation

function InnerModuleEvaluation(module, stack, index) {
  if (!(module instanceof CyclicModuleRecord)) {
    let _temp5 = module.Evaluate();

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }
    return index;
  }

  if (module.Status === 'evaluated') {
    if (module.EvaluationError === Value.undefined) {
      return index;
    } else {
      return module.EvaluationError;
    }
  }

  if (module.Status === 'evaluating') {
    return index;
  }

  Assert(module.Status === 'linked', "module.Status === 'linked'");
  module.Status = 'evaluating';
  module.DFSIndex = index;
  module.DFSAncestorIndex = index;
  module.PendingAsyncDependencies = 0;
  module.AsyncParentModules = [];
  index += 1;
  stack.push(module);

  for (const required of module.RequestedModules) {
    let _temp6 = HostResolveImportedModule(module, required);

    Assert(!(_temp6 instanceof AbruptCompletion), "HostResolveImportedModule(module, required)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    let requiredModule = _temp6;

    let _temp7 = InnerModuleEvaluation(requiredModule, stack, index);

    if (_temp7 instanceof AbruptCompletion) {
      return _temp7;
    }

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    index = _temp7;

    if (requiredModule instanceof CyclicModuleRecord) {
      Assert(requiredModule.Status === 'evaluating' || requiredModule.Status === 'evaluated', "requiredModule.Status === 'evaluating' || requiredModule.Status === 'evaluated'");

      if (stack.includes(requiredModule)) {
        Assert(requiredModule.Status === 'evaluating', "requiredModule.Status === 'evaluating'");
      }

      if (requiredModule.Status === 'evaluating') {
        module.DFSAncestorIndex = Math.min(module.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
      } else {
        requiredModule = GetAsyncCycleRoot(requiredModule);
        Assert(requiredModule.Status === 'evaluated', "requiredModule.Status === 'evaluated'");

        if (requiredModule.EvaluationError !== Value.undefined) {
          return module.EvaluationError;
        }
      }

      if (requiredModule.AsyncEvaluating === Value.true) {
        module.PendingAsyncDependencies += 1;
        requiredModule.AsyncParentModules.push(module);
      }
    }
  }

  if (module.PendingAsyncDependencies > 0) {
    module.AsyncEvaluating = Value.true;
  } else if (module.Async === Value.true) {
    let _temp8 = ExecuteAsyncModule(module);

    Assert(!(_temp8 instanceof AbruptCompletion), "ExecuteAsyncModule(module)" + ' returned an abrupt completion');

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }
  } else {
    let _temp9 = module.ExecuteModule();

    if (_temp9 instanceof AbruptCompletion) {
      return _temp9;
    }

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }
  }

  Assert(stack.indexOf(module) === stack.lastIndexOf(module), "stack.indexOf(module) === stack.lastIndexOf(module)");
  Assert(module.DFSAncestorIndex <= module.DFSIndex, "module.DFSAncestorIndex <= module.DFSIndex");

  if (module.DFSAncestorIndex === module.DFSIndex) {
    let done = false;

    while (done === false) {
      const requiredModule = stack.pop();
      Assert(requiredModule instanceof CyclicModuleRecord, "requiredModule instanceof CyclicModuleRecord");
      requiredModule.Status = 'evaluated';

      if (requiredModule === module) {
        done = true;
      }
    }
  }

  return index;
} // https://tc39.es/proposal-top-level-await/#sec-execute-async-module

function ExecuteAsyncModule(module) {
  Assert(module.Status === 'evaluating' || module.Status === 'evaluated', "module.Status === 'evaluating' || module.Status === 'evaluated'");
  Assert(module.Async === Value.true, "module.Async === Value.true");
  module.AsyncEvaluating = Value.true;

  let _temp10 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

  Assert(!(_temp10 instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const capability = _temp10;
  const stepsFulfilled = CallAsyncModuleFulfilled;
  const onFulfilled = CreateBuiltinFunction(stepsFulfilled, ['Module']);
  onFulfilled.Module = module;
  const stepsRejected = CallAsyncModuleRejected;
  const onRejected = CreateBuiltinFunction(stepsRejected, ['Module']);
  onRejected.Module = module;

  let _temp11 = PerformPromiseThen(capability.Promise, onFulfilled, onRejected);

  Assert(!(_temp11 instanceof AbruptCompletion), "PerformPromiseThen(capability.Promise, onFulfilled, onRejected)" + ' returned an abrupt completion');

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  let _temp12 = module.ExecuteModule(capability);

  Assert(!(_temp12 instanceof AbruptCompletion), "module.ExecuteModule(capability)" + ' returned an abrupt completion');

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }
  return Value.undefined;
} // https://tc39.es/proposal-top-level-await/#sec-execute-async-module


function CallAsyncModuleFulfilled() {
  const f = surroundingAgent.activeFunctionObject;
  const module = f.Module;

  let _temp13 = AsyncModuleExecutionFulfilled(module);

  Assert(!(_temp13 instanceof AbruptCompletion), "AsyncModuleExecutionFulfilled(module)" + ' returned an abrupt completion');

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }
  return Value.undefined;
} // https://tc39.es/proposal-top-level-await/#sec-execute-async-module


function CallAsyncModuleRejected([error = Value.undefined]) {
  const f = surroundingAgent.activeFunctionObject;
  const module = f.Module;

  let _temp14 = AsyncModuleExecutionRejected(module, error);

  Assert(!(_temp14 instanceof AbruptCompletion), "AsyncModuleExecutionRejected(module, error)" + ' returned an abrupt completion');

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }
  return Value.undefined;
} // https://tc39.es/proposal-top-level-await/#sec-getcycleroot


function GetAsyncCycleRoot(module) {
  Assert(module.Status === 'evaluated', "module.Status === 'evaluated'");

  if (module.AsyncParentModules.length === 0) {
    return module;
  }

  while (module.DFSIndex > module.DFSAncestorIndex) {
    Assert(module.AsyncParentModules.length > 0, "module.AsyncParentModules.length > 0");
    const nextCycleModule = module.AsyncParentModules[0];
    Assert(nextCycleModule.DFSAncestorIndex === module.DFSAncestorIndex, "nextCycleModule.DFSAncestorIndex === module.DFSAncestorIndex");
    module = nextCycleModule;
  }

  Assert(module.DFSIndex === module.DFSAncestorIndex, "module.DFSIndex === module.DFSAncestorIndex");
  return module;
} // https://tc39.es/proposal-top-level-await/#sec-asyncmodulexecutionfulfilled

function AsyncModuleExecutionFulfilled(module) {
  Assert(module.Status === 'evaluated', "module.Status === 'evaluated'");

  if (module.AsyncEvaluating === Value.false) {
    Assert(module.EvaluationError !== Value.undefined, "module.EvaluationError !== Value.undefined");
    return Value.undefined;
  }

  Assert(module.EvaluationError === Value.undefined, "module.EvaluationError === Value.undefined");
  module.AsyncEvaluating = Value.false;

  for (const m of module.AsyncParentModules) {
    if (module.DFSIndex !== module.DFSAncestorIndex) {
      Assert(m.DFSAncestorIndex === module.DFSAncestorIndex, "m.DFSAncestorIndex === module.DFSAncestorIndex");
    }

    m.PendingAsyncDependencies -= 1;

    if (m.PendingAsyncDependencies === 0 && m.EvaluationError === Value.undefined) {
      Assert(m.AsyncEvaluating === Value.true, "m.AsyncEvaluating === Value.true");

      let _temp15 = GetAsyncCycleRoot(m);

      Assert(!(_temp15 instanceof AbruptCompletion), "GetAsyncCycleRoot(m)" + ' returned an abrupt completion');

      if (_temp15 instanceof Completion) {
        _temp15 = _temp15.Value;
      }

      const cycleRoot = _temp15;

      if (cycleRoot.EvaluationError !== Value.undefined) {
        return Value.undefined;
      }

      if (m.Async === Value.true) {
        let _temp16 = ExecuteAsyncModule(m);

        Assert(!(_temp16 instanceof AbruptCompletion), "ExecuteAsyncModule(m)" + ' returned an abrupt completion');

        if (_temp16 instanceof Completion) {
          _temp16 = _temp16.Value;
        }
      } else {
        const result = m.ExecuteModule();

        if (result instanceof NormalCompletion) {
          let _temp17 = AsyncModuleExecutionFulfilled(m);

          Assert(!(_temp17 instanceof AbruptCompletion), "AsyncModuleExecutionFulfilled(m)" + ' returned an abrupt completion');

          if (_temp17 instanceof Completion) {
            _temp17 = _temp17.Value;
          }
        } else {
          let _temp18 = AsyncModuleExecutionRejected(m, result.Value);

          Assert(!(_temp18 instanceof AbruptCompletion), "AsyncModuleExecutionRejected(m, result.Value)" + ' returned an abrupt completion');

          if (_temp18 instanceof Completion) {
            _temp18 = _temp18.Value;
          }
        }
      }
    }
  }

  if (module.TopLevelCapability !== Value.undefined) {
    Assert(module.DFSIndex === module.DFSAncestorIndex, "module.DFSIndex === module.DFSAncestorIndex");

    let _temp19 = Call(module.TopLevelCapability.Resolve, Value.undefined, [Value.undefined]);

    Assert(!(_temp19 instanceof AbruptCompletion), "Call(module.TopLevelCapability.Resolve, Value.undefined, [Value.undefined])" + ' returned an abrupt completion');

    if (_temp19 instanceof Completion) {
      _temp19 = _temp19.Value;
    }
  }

  return Value.undefined;
} // https://tc39.es/proposal-top-level-await/#sec-AsyncModuleExecutionRejected


function AsyncModuleExecutionRejected(module, error) {
  Assert(module.Status === 'evaluated', "module.Status === 'evaluated'");

  if (module.AsyncEvaluating === Value.false) {
    Assert(module.EvaluationError !== Value.undefined, "module.EvaluationError !== Value.undefined");
    return Value.undefined;
  }

  Assert(module.EvaluationError === Value.undefined, "module.EvaluationError === Value.undefined");
  module.EvaluationError = new ThrowCompletion(error);
  module.AsyncEvaluating = Value.false;

  for (const m of module.AsyncParentModules) {
    if (module.DFSIndex !== module.DFSAncestorIndex) {
      Assert(m.DFSAncestorIndex === module.DFSAncestorIndex, "m.DFSAncestorIndex === module.DFSAncestorIndex");
    }

    let _temp20 = AsyncModuleExecutionRejected(m, error);

    Assert(!(_temp20 instanceof AbruptCompletion), "AsyncModuleExecutionRejected(m, error)" + ' returned an abrupt completion');

    if (_temp20 instanceof Completion) {
      _temp20 = _temp20.Value;
    }
  }

  if (module.TopLevelCapability !== Value.undefined) {
    Assert(module.DFSIndex === module.DFSAncestorIndex, "module.DFSIndex === module.DFSAncestorIndex");

    let _temp21 = Call(module.TopLevelCapability.Reject, Value.undefined, [error]);

    Assert(!(_temp21 instanceof AbruptCompletion), "Call(module.TopLevelCapability.Reject, Value.undefined, [error])" + ' returned an abrupt completion');

    if (_temp21 instanceof Completion) {
      _temp21 = _temp21.Value;
    }
  }

  return Value.undefined;
} // 15.2.1.21 #sec-getmodulenamespace


function GetModuleNamespace(module) {
  Assert(module instanceof AbstractModuleRecord, "module instanceof AbstractModuleRecord");

  if (module instanceof CyclicModuleRecord) {
    Assert(module.Status !== 'unlinked', "module.Status !== 'unlinked'");
  }

  let namespace = module.Namespace;

  if (namespace === Value.undefined) {
    let _temp22 = module.GetExportedNames();

    if (_temp22 instanceof AbruptCompletion) {
      return _temp22;
    }

    if (_temp22 instanceof Completion) {
      _temp22 = _temp22.Value;
    }

    const exportedNames = _temp22;
    const unambiguousNames = [];

    for (const name of exportedNames) {
      let _temp23 = module.ResolveExport(name);

      if (_temp23 instanceof AbruptCompletion) {
        return _temp23;
      }

      if (_temp23 instanceof Completion) {
        _temp23 = _temp23.Value;
      }

      const resolution = _temp23;

      if (resolution instanceof ResolvedBindingRecord) {
        unambiguousNames.push(name);
      }
    }

    namespace = ModuleNamespaceCreate(module, unambiguousNames);
  }

  return namespace;
}

// 7.3 #sec-operations-on-objects
// 7.3.1 #sec-get-o-p

function Get(O, P) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)"); // TODO: This should just return Q(O.Get(P, O))

  let _temp = O.Get(P, O);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  return new NormalCompletion(_temp);
} // 7.3.2 #sec-getv

function GetV(V, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp2 = ToObject(V);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const O = _temp2;
  return O.Get(P, V);
} // 7.3.3 #sec-set-o-p-v-throw

function Set$1(O, P, V, Throw) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  Assert(Type(Throw) === 'Boolean', "Type(Throw) === 'Boolean'");

  let _temp3 = O.Set(P, V, O);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const success = _temp3;

  if (success === Value.false && Throw === Value.true) {
    return surroundingAgent.Throw('TypeError', 'CannotSetProperty', P, O);
  }

  return success;
} // 7.3.4 #sec-createdataproperty

function CreateDataProperty(O, P, V) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  const newDesc = Descriptor({
    Value: V,
    Writable: Value.true,
    Enumerable: Value.true,
    Configurable: Value.true
  });
  return O.DefineOwnProperty(P, newDesc);
} // 7.3.5 #sec-createmethodproperty

function CreateMethodProperty(O, P, V) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  const newDesc = Descriptor({
    Value: V,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  });
  return O.DefineOwnProperty(P, newDesc);
} // 7.3.6 #sec-createdatapropertyorthrow

function CreateDataPropertyOrThrow(O, P, V) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp4 = CreateDataProperty(O, P, V);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const success = _temp4;

  if (success === Value.false) {
    return surroundingAgent.Throw('TypeError', 'CannotDefineProperty', P);
  }

  return success;
} // 7.3.7 #sec-definepropertyorthrow

function DefinePropertyOrThrow(O, P, desc) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp5 = O.DefineOwnProperty(P, desc);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const success = _temp5;

  if (success === Value.false) {
    return surroundingAgent.Throw('TypeError', 'CannotDefineProperty', P);
  }

  return success;
} // 7.3.8 #sec-deletepropertyorthrow

function DeletePropertyOrThrow(O, P) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp6 = O.Delete(P);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const success = _temp6;

  if (success === Value.false) {
    return surroundingAgent.Throw('TypeError', 'CannotDeleteProperty', P);
  }

  return success;
} // 7.3.9 #sec-getmethod

function GetMethod(V, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp7 = GetV(V, P);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const func = _temp7;

  if (func === Value.null || func === Value.undefined) {
    return Value.undefined;
  }

  if (IsCallable(func) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
  }

  return func;
} // 7.3.10 #sec-hasproperty

function HasProperty(O, P) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  return O.HasProperty(P);
} // 7.3.11 #sec-hasownproperty

function HasOwnProperty$1(O, P) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp8 = O.GetOwnProperty(P);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const desc = _temp8;

  if (desc === Value.undefined) {
    return Value.false;
  }

  return Value.true;
} // 7.3.12 #sec-call

function Call(F, V, argumentsList) {
  if (!argumentsList) {
    argumentsList = [];
  }

  Assert(argumentsList.every(a => a instanceof Value), "argumentsList.every((a) => a instanceof Value)");

  if (IsCallable(F) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', F);
  }

  return F.Call(V, argumentsList);
} // 7.3.13 #sec-construct

function Construct(F, argumentsList, newTarget) {
  if (!newTarget) {
    newTarget = F;
  }

  if (!argumentsList) {
    argumentsList = [];
  }

  Assert(IsConstructor(F) === Value.true, "IsConstructor(F) === Value.true");
  Assert(IsConstructor(newTarget) === Value.true, "IsConstructor(newTarget) === Value.true");
  return F.Construct(argumentsList, newTarget);
} // 7.3.14 #sec-setintegritylevel

function SetIntegrityLevel(O, level) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(level === 'sealed' || level === 'frozen', "level === 'sealed' || level === 'frozen'");

  let _temp9 = O.PreventExtensions();

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const status = _temp9;

  if (status === Value.false) {
    return Value.false;
  }

  let _temp10 = O.OwnPropertyKeys();

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const keys = _temp10;

  if (level === 'sealed') {
    for (const k of keys) {
      let _temp11 = DefinePropertyOrThrow(O, k, Descriptor({
        Configurable: Value.false
      }));

      if (_temp11 instanceof AbruptCompletion) {
        return _temp11;
      }

      if (_temp11 instanceof Completion) {
        _temp11 = _temp11.Value;
      }
    }
  } else if (level === 'frozen') {
    for (const k of keys) {
      let _temp12 = O.GetOwnProperty(k);

      if (_temp12 instanceof AbruptCompletion) {
        return _temp12;
      }

      if (_temp12 instanceof Completion) {
        _temp12 = _temp12.Value;
      }

      const currentDesc = _temp12;

      if (currentDesc !== Value.undefined) {
        let desc;

        if (IsAccessorDescriptor(currentDesc) === true) {
          desc = Descriptor({
            Configurable: Value.false
          });
        } else {
          desc = Descriptor({
            Configurable: Value.false,
            Writable: Value.false
          });
        }

        let _temp13 = DefinePropertyOrThrow(O, k, desc);

        if (_temp13 instanceof AbruptCompletion) {
          return _temp13;
        }

        if (_temp13 instanceof Completion) {
          _temp13 = _temp13.Value;
        }
      }
    }
  }

  return Value.true;
} // 7.3.15 #sec-testintegritylevel

function TestIntegrityLevel(O, level) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(level === 'sealed' || level === 'frozen', "level === 'sealed' || level === 'frozen'");

  let _temp14 = IsExtensible(O);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const extensible = _temp14;

  if (extensible === Value.true) {
    return Value.false;
  }

  let _temp15 = O.OwnPropertyKeys();

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const keys = _temp15;

  for (const k of keys) {
    let _temp16 = O.GetOwnProperty(k);

    if (_temp16 instanceof AbruptCompletion) {
      return _temp16;
    }

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }

    const currentDesc = _temp16;

    if (currentDesc !== Value.undefined) {
      if (currentDesc.Configurable === Value.true) {
        return Value.false;
      }

      if (level === 'frozen' && IsDataDescriptor(currentDesc)) {
        if (currentDesc.Writable === Value.true) {
          return Value.false;
        }
      }
    }
  }

  return Value.true;
} // 7.3.16 #sec-createarrayfromlist

function CreateArrayFromList(elements) {
  Assert(elements.every(e => e instanceof Value), "elements.every((e) => e instanceof Value)");

  let _temp17 = ArrayCreate(new Value(0));

  Assert(!(_temp17 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  const array = _temp17;
  let n = 0;

  for (const e of elements) {
    let _temp18 = ToString(new Value(n));

    Assert(!(_temp18 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }

    const nStr = _temp18;

    let _temp19 = CreateDataProperty(array, nStr, e);

    Assert(!(_temp19 instanceof AbruptCompletion), "CreateDataProperty(array, nStr, e)" + ' returned an abrupt completion');

    if (_temp19 instanceof Completion) {
      _temp19 = _temp19.Value;
    }

    const status = _temp19;
    Assert(status === Value.true, "status === Value.true");
    n += 1;
  }

  return array;
} // 7.3.17 #sec-lengthofarraylike

function LengthOfArrayLike(obj) {
  Assert(Type(obj) === 'Object', "Type(obj) === 'Object'");

  let _temp20 = Get(obj, new Value('length'));

  if (_temp20 instanceof AbruptCompletion) {
    return _temp20;
  }

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }

  return ToLength(_temp20);
} // 7.3.17 #sec-createlistfromarraylike

function CreateListFromArrayLike(obj, elementTypes) {
  if (!elementTypes) {
    elementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'Object'];
  }

  if (Type(obj) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', obj);
  }

  let _temp21 = LengthOfArrayLike(obj);

  if (_temp21 instanceof AbruptCompletion) {
    return _temp21;
  }

  if (_temp21 instanceof Completion) {
    _temp21 = _temp21.Value;
  }

  const len = _temp21.numberValue();

  const list = [];
  let index = 0;

  while (index < len) {
    let _temp22 = ToString(new Value(index));

    Assert(!(_temp22 instanceof AbruptCompletion), "ToString(new Value(index))" + ' returned an abrupt completion');

    if (_temp22 instanceof Completion) {
      _temp22 = _temp22.Value;
    }

    const indexName = _temp22;

    let _temp23 = Get(obj, indexName);

    if (_temp23 instanceof AbruptCompletion) {
      return _temp23;
    }

    if (_temp23 instanceof Completion) {
      _temp23 = _temp23.Value;
    }

    const next = _temp23;

    if (!elementTypes.includes(Type(next))) {
      return surroundingAgent.Throw('TypeError', 'NotPropertyName', next);
    }

    list.push(next);
    index += 1;
  }

  return list;
} // 7.3.18 #sec-invoke

function Invoke(V, P, argumentsList) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  if (!argumentsList) {
    argumentsList = [];
  }

  let _temp24 = GetV(V, P);

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  const func = _temp24;
  return Call(func, V, argumentsList);
} // 7.3.19 #sec-ordinaryhasinstance

function OrdinaryHasInstance(C, O) {
  if (IsCallable(C) === Value.false) {
    return Value.false;
  }

  if ('BoundTargetFunction' in C) {
    const BC = C.BoundTargetFunction;
    return InstanceofOperator(O, BC);
  }

  if (Type(O) !== 'Object') {
    return Value.false;
  }

  let _temp25 = Get(C, new Value('prototype'));

  if (_temp25 instanceof AbruptCompletion) {
    return _temp25;
  }

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }

  const P = _temp25;

  if (Type(P) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', P);
  }

  while (true) {
    let _temp26 = O.GetPrototypeOf();

    if (_temp26 instanceof AbruptCompletion) {
      return _temp26;
    }

    if (_temp26 instanceof Completion) {
      _temp26 = _temp26.Value;
    }

    O = _temp26;

    if (O === Value.null) {
      return Value.false;
    }

    if (SameValue(P, O) === Value.true) {
      return Value.true;
    }
  }
} // 7.3.20 #sec-speciesconstructor

function SpeciesConstructor(O, defaultConstructor) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");

  let _temp27 = Get(O, new Value('constructor'));

  if (_temp27 instanceof AbruptCompletion) {
    return _temp27;
  }

  if (_temp27 instanceof Completion) {
    _temp27 = _temp27.Value;
  }

  const C = _temp27;

  if (C === Value.undefined) {
    return defaultConstructor;
  }

  if (Type(C) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', C);
  }

  let _temp28 = Get(C, wellKnownSymbols.species);

  if (_temp28 instanceof AbruptCompletion) {
    return _temp28;
  }

  if (_temp28 instanceof Completion) {
    _temp28 = _temp28.Value;
  }

  const S = _temp28;

  if (S === Value.undefined || S === Value.null) {
    return defaultConstructor;
  }

  if (IsConstructor(S) === Value.true) {
    return S;
  }

  return surroundingAgent.Throw('TypeError', 'SpeciesNotConstructor');
} // 7.3.21 #sec-enumerableownpropertynames

function EnumerableOwnPropertyNames(O, kind) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");

  let _temp29 = O.OwnPropertyKeys();

  if (_temp29 instanceof AbruptCompletion) {
    return _temp29;
  }

  if (_temp29 instanceof Completion) {
    _temp29 = _temp29.Value;
  }

  const ownKeys = _temp29;
  const properties = [];

  for (const key of ownKeys) {
    if (Type(key) === 'String') {
      let _temp30 = O.GetOwnProperty(key);

      if (_temp30 instanceof AbruptCompletion) {
        return _temp30;
      }

      if (_temp30 instanceof Completion) {
        _temp30 = _temp30.Value;
      }

      const desc = _temp30;

      if (desc !== Value.undefined && desc.Enumerable === Value.true) {
        if (kind === 'key') {
          properties.push(key);
        } else {
          let _temp31 = Get(O, key);

          if (_temp31 instanceof AbruptCompletion) {
            return _temp31;
          }

          if (_temp31 instanceof Completion) {
            _temp31 = _temp31.Value;
          }

          const value = _temp31;

          if (kind === 'value') {
            properties.push(value);
          } else {
            Assert(kind === 'key+value', "kind === 'key+value'");

            let _temp32 = CreateArrayFromList([key, value]);

            Assert(!(_temp32 instanceof AbruptCompletion), "CreateArrayFromList([key, value])" + ' returned an abrupt completion');

            if (_temp32 instanceof Completion) {
              _temp32 = _temp32.Value;
            }

            const entry = _temp32;
            properties.push(entry);
          }
        }
      }
    }
  }

  return properties;
} // 7.3.22 #sec-getfunctionrealm

function GetFunctionRealm(obj) {
  let _temp33 = IsCallable(obj);

  Assert(!(_temp33 instanceof AbruptCompletion), "IsCallable(obj)" + ' returned an abrupt completion');

  if (_temp33 instanceof Completion) {
    _temp33 = _temp33.Value;
  }

  Assert(_temp33 === Value.true, "X(IsCallable(obj)) === Value.true");

  if ('Realm' in obj) {
    return obj.Realm;
  }

  if ('BoundTargetFunction' in obj) {
    const target = obj.BoundTargetFunction;
    return GetFunctionRealm(target);
  }

  if (obj instanceof ProxyExoticObjectValue) {
    if (Type(obj.ProxyHandler) === 'Null') {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'GetFunctionRealm');
    }

    const proxyTarget = obj.ProxyTarget;
    return GetFunctionRealm(proxyTarget);
  }

  return surroundingAgent.currentRealmRecord;
} // 7.3.23 #sec-copydataproperties

function CopyDataProperties(target, source, excludedItems) {
  Assert(Type(target) === 'Object', "Type(target) === 'Object'");
  Assert(excludedItems.every(i => IsPropertyKey(i)), "excludedItems.every((i) => IsPropertyKey(i))");

  if (source === Value.undefined || source === Value.null) {
    return target;
  }

  let _temp34 = ToObject(source);

  Assert(!(_temp34 instanceof AbruptCompletion), "ToObject(source)" + ' returned an abrupt completion');

  if (_temp34 instanceof Completion) {
    _temp34 = _temp34.Value;
  }

  const from = _temp34;

  let _temp35 = from.OwnPropertyKeys();

  if (_temp35 instanceof AbruptCompletion) {
    return _temp35;
  }

  if (_temp35 instanceof Completion) {
    _temp35 = _temp35.Value;
  }

  const keys = _temp35;

  for (const nextKey of keys) {
    let excluded = false;

    for (const e of excludedItems) {
      if (SameValue(e, nextKey) === Value.true) {
        excluded = true;
      }
    }

    if (excluded === false) {
      let _temp36 = from.GetOwnProperty(nextKey);

      if (_temp36 instanceof AbruptCompletion) {
        return _temp36;
      }

      if (_temp36 instanceof Completion) {
        _temp36 = _temp36.Value;
      }

      const desc = _temp36;

      if (desc !== Value.undefined && desc.Enumerable === Value.true) {
        let _temp37 = Get(from, nextKey);

        if (_temp37 instanceof AbruptCompletion) {
          return _temp37;
        }

        if (_temp37 instanceof Completion) {
          _temp37 = _temp37.Value;
        }

        const propValue = _temp37;

        let _temp38 = CreateDataProperty(target, nextKey, propValue);

        Assert(!(_temp38 instanceof AbruptCompletion), "CreateDataProperty(target, nextKey, propValue)" + ' returned an abrupt completion');

        if (_temp38 instanceof Completion) {
          _temp38 = _temp38.Value;
        }
      }
    }
  }

  return target;
}

function OrdinaryGetPrototypeOf(O) {
  return O.Prototype;
} // 9.1.2.1 OrdinarySetPrototypeOf

function OrdinarySetPrototypeOf(O, V) {
  Assert(Type(V) === 'Object' || Type(V) === 'Null', "Type(V) === 'Object' || Type(V) === 'Null'");
  const current = O.Prototype;

  if (SameValue(V, current) === Value.true) {
    return Value.true;
  }

  const extensible = O.Extensible;

  if (extensible === Value.false) {
    return Value.false;
  }

  let p = V;
  let done = false;

  while (done === false) {
    if (p === Value.null) {
      done = true;
    } else if (SameValue(p, O) === Value.true) {
      return Value.false;
    } else if (p.GetPrototypeOf !== ObjectValue.prototype.GetPrototypeOf) {
      done = true;
    } else {
      p = p.Prototype;
    }
  }

  O.Prototype = V;
  return Value.true;
} // 9.1.3.1 OrdinaryIsExtensible

function OrdinaryIsExtensible(O) {
  return O.Extensible;
} // 9.1.4.1 OrdinaryPreventExtensions

function OrdinaryPreventExtensions(O) {
  O.Extensible = Value.false;
  return Value.true;
} // 9.1.5.1 OrdinaryGetOwnProperty

function OrdinaryGetOwnProperty(O, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  if (!O.properties.has(P)) {
    return Value.undefined;
  }

  const D = Descriptor({});
  const x = O.properties.get(P);

  if (IsDataDescriptor(x)) {
    D.Value = x.Value;
    D.Writable = x.Writable;
  } else if (IsAccessorDescriptor(x)) {
    D.Get = x.Get;
    D.Set = x.Set;
  }

  D.Enumerable = x.Enumerable;
  D.Configurable = x.Configurable;
  return D;
} // 9.1.6.1 OrdinaryDefineOwnProperty

function OrdinaryDefineOwnProperty(O, P, Desc) {
  let _temp = O.GetOwnProperty(P);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const current = _temp;

  let _temp2 = IsExtensible(O);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const extensible = _temp2;
  return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
} // 9.1.6.2 #sec-iscompatiblepropertydescriptor

function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
  return ValidateAndApplyPropertyDescriptor(Value.undefined, Value.undefined, Extensible, Desc, Current);
} // 9.1.6.3 ValidateAndApplyPropertyDescriptor

function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
  Assert(O === Value.undefined || IsPropertyKey(P), "O === Value.undefined || IsPropertyKey(P)");

  if (current === Value.undefined) {
    if (extensible === Value.false) {
      return Value.false;
    }

    Assert(extensible === Value.true, "extensible === Value.true");

    if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
      if (Type(O) !== 'Undefined') {
        O.properties.set(P, Descriptor({
          Value: Desc.Value === undefined ? Value.undefined : Desc.Value,
          Writable: Desc.Writable === undefined ? Value.false : Desc.Writable,
          Enumerable: Desc.Enumerable === undefined ? Value.false : Desc.Enumerable,
          Configurable: Desc.Configurable === undefined ? Value.false : Desc.Configurable
        }));
      }
    } else {
      Assert(IsAccessorDescriptor(Desc), "IsAccessorDescriptor(Desc)");

      if (Type(O) !== 'Undefined') {
        O.properties.set(P, Descriptor({
          Get: Desc.Get === undefined ? Value.undefined : Desc.Get,
          Set: Desc.Set === undefined ? Value.undefined : Desc.Set,
          Enumerable: Desc.Enumerable === undefined ? Value.false : Desc.Enumerable,
          Configurable: Desc.Configurable === undefined ? Value.false : Desc.Configurable
        }));
      }
    }

    return Value.true;
  }

  if (Desc.everyFieldIsAbsent()) {
    return Value.true;
  }

  if (current.Configurable === Value.false) {
    if (Desc.Configurable !== undefined && Desc.Configurable === Value.true) {
      return Value.false;
    }

    if (Desc.Enumerable !== undefined && Desc.Enumerable !== current.Enumerable) {
      return Value.false;
    }
  }

  if (IsGenericDescriptor(Desc)) ; else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
    if (current.Configurable === Value.false) {
      return Value.false;
    }

    if (IsDataDescriptor(current)) {
      if (Type(O) !== 'Undefined') {
        const entry = O.properties.get(P);
        entry.Value = undefined;
        entry.Writable = undefined;
        entry.Get = Value.undefined;
        entry.Set = Value.undefined;
      }
    } else {
      if (Type(O) !== 'Undefined') {
        const entry = O.properties.get(P);
        entry.Get = undefined;
        entry.Set = undefined;
        entry.Value = Value.undefined;
        entry.Writable = Value.false;
      }
    }
  } else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
    if (current.Configurable === Value.false && current.Writable === Value.false) {
      if (Desc.Writable !== undefined && Desc.Writable === Value.true) {
        return Value.false;
      }

      if (Desc.Value !== undefined && SameValue(Desc.Value, current.Value) === Value.false) {
        return Value.false;
      }

      return Value.true;
    }
  } else {
    Assert(IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc), "IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)");

    if (current.Configurable === Value.false) {
      if (Desc.Set !== undefined && SameValue(Desc.Set, current.Set) === Value.false) {
        return Value.false;
      }

      if (Desc.Get !== undefined && SameValue(Desc.Get, current.Get) === Value.false) {
        return Value.false;
      }

      return Value.true;
    }
  }

  if (Type(O) !== 'Undefined') {
    const target = O.properties.get(P);

    if (Desc.Value !== undefined) {
      target.Value = Desc.Value;
    }

    if (Desc.Writable !== undefined) {
      target.Writable = Desc.Writable;
    }

    if (Desc.Get !== undefined) {
      target.Get = Desc.Get;
    }

    if (Desc.Set !== undefined) {
      target.Set = Desc.Set;
    }

    if (Desc.Enumerable !== undefined) {
      target.Enumerable = Desc.Enumerable;
    }

    if (Desc.Configurable !== undefined) {
      target.Configurable = Desc.Configurable;
    }
  }

  return Value.true;
} // 9.1.7.1 OrdinaryHasProperty

function OrdinaryHasProperty(O, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp3 = O.GetOwnProperty(P);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const hasOwn = _temp3;

  if (Type(hasOwn) !== 'Undefined') {
    return Value.true;
  }

  let _temp4 = O.GetPrototypeOf();

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const parent = _temp4;

  if (Type(parent) !== 'Null') {
    return parent.HasProperty(P);
  }

  return Value.false;
} // 9.1.8.1

function OrdinaryGet(O, P, Receiver) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp5 = O.GetOwnProperty(P);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const desc = _temp5;

  if (Type(desc) === 'Undefined') {
    let _temp6 = O.GetPrototypeOf();

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    const parent = _temp6;

    if (Type(parent) === 'Null') {
      return Value.undefined;
    }

    return parent.Get(P, Receiver);
  }

  if (IsDataDescriptor(desc)) {
    return desc.Value;
  }

  Assert(IsAccessorDescriptor(desc), "IsAccessorDescriptor(desc)");
  const getter = desc.Get;

  if (Type(getter) === 'Undefined') {
    return Value.undefined;
  }

  return Call(getter, Receiver);
} // 9.1.9.1 OrdinarySet

function OrdinarySet(O, P, V, Receiver) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp7 = O.GetOwnProperty(P);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const ownDesc = _temp7;
  return OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc);
} // 9.1.9.2 OrdinarySetWithOwnDescriptor

function OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  if (Type(ownDesc) === 'Undefined') {
    let _temp8 = O.GetPrototypeOf();

    if (_temp8 instanceof AbruptCompletion) {
      return _temp8;
    }

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }

    const parent = _temp8;

    if (Type(parent) !== 'Null') {
      return parent.Set(P, V, Receiver);
    }

    ownDesc = Descriptor({
      Value: Value.undefined,
      Writable: Value.true,
      Enumerable: Value.true,
      Configurable: Value.true
    });
  }

  if (IsDataDescriptor(ownDesc)) {
    if (ownDesc.Writable !== undefined && ownDesc.Writable === Value.false) {
      return Value.false;
    }

    if (Type(Receiver) !== 'Object') {
      return Value.false;
    }

    let _temp9 = Receiver.GetOwnProperty(P);

    if (_temp9 instanceof AbruptCompletion) {
      return _temp9;
    }

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }

    const existingDescriptor = _temp9;

    if (Type(existingDescriptor) !== 'Undefined') {
      if (IsAccessorDescriptor(existingDescriptor)) {
        return Value.false;
      }

      if (existingDescriptor.Writable === Value.false) {
        return Value.false;
      }

      const valueDesc = Descriptor({
        Value: V
      });
      return Receiver.DefineOwnProperty(P, valueDesc);
    }

    return CreateDataProperty(Receiver, P, V);
  }

  Assert(IsAccessorDescriptor(ownDesc), "IsAccessorDescriptor(ownDesc)");
  const setter = ownDesc.Set;

  if (setter === undefined || Type(setter) === 'Undefined') {
    return Value.false;
  }

  let _temp10 = Call(setter, Receiver, [V]);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }
  return Value.true;
} // 9.1.10.1 OrdinaryDelete

function OrdinaryDelete(O, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  let _temp11 = O.GetOwnProperty(P);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const desc = _temp11;

  if (Type(desc) === 'Undefined') {
    return Value.true;
  }

  if (desc.Configurable === Value.true) {
    O.properties.delete(P);
    return Value.true;
  }

  return Value.false;
} // 9.1.11.1

function OrdinaryOwnPropertyKeys(O) {
  const keys = []; // For each own property key P of O that is an array index, in ascending numeric index order, do
  //   Add P as the last element of keys.

  for (const P of O.properties.keys()) {
    if (isArrayIndex(P)) {
      keys.push(P);
    }
  }

  keys.sort((a, b) => Number.parseInt(a.stringValue(), 10) - Number.parseInt(b.stringValue(), 10)); // For each own property key P of O such that Type(P) is String and
  // P is not an array index, in ascending chronological order of property creation, do
  //   Add P as the last element of keys.

  for (const P of O.properties.keys()) {
    if (Type(P) === 'String' && isArrayIndex(P) === false) {
      keys.push(P);
    }
  } // For each own property key P of O such that Type(P) is Symbol,
  // in ascending chronological order of property creation, do
  //   Add P as the last element of keys.


  for (const P of O.properties.keys()) {
    if (Type(P) === 'Symbol') {
      keys.push(P);
    }
  }

  return keys;
} // 9.1.12 ObjectCreate

function ObjectCreate(proto, internalSlotsList) {
  Assert(Type(proto) === 'Null' || Type(proto) === 'Object', "Type(proto) === 'Null' || Type(proto) === 'Object'");

  if (!internalSlotsList) {
    internalSlotsList = [];
  }

  const obj = new ObjectValue();

  for (const slot of internalSlotsList) {
    obj[slot] = Value.undefined;
  } // The following steps happen in ObjectValue constructor:
  //
  // Set obj's essential internal methods to the default ordinary
  // object definitions specified in 9.1.


  obj.Prototype = proto;
  obj.Extensible = Value.true;
  return obj;
} // 9.1.13 OrdinaryCreateFromConstructor

function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto, internalSlotsList) {
  let _temp12 = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  // Assert: intrinsicDefaultProto is a String value that
  // is this specification's name of an intrinsic object.
  const proto = _temp12;
  return ObjectCreate(proto, internalSlotsList);
} // 9.1.14 GetPrototypeFromConstructor

function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
  // Assert: intrinsicDefaultProto is a String value that
  // is this specification's name of an intrinsic object.
  Assert(IsCallable(constructor) === Value.true, "IsCallable(constructor) === Value.true");

  let _temp13 = Get(constructor, new Value('prototype'));

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  let proto = _temp13;

  if (Type(proto) !== 'Object') {
    let _temp14 = GetFunctionRealm(constructor);

    if (_temp14 instanceof AbruptCompletion) {
      return _temp14;
    }

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    const realm = _temp14;
    proto = realm.Intrinsics[intrinsicDefaultProto];
  }

  return proto;
} // 9.4.5.7 #sec-integerindexedobjectcreate

function IntegerIndexedObjectCreate(prototype, internalSlotsList) {
  Assert(internalSlotsList.includes('ViewedArrayBuffer'), "internalSlotsList.includes('ViewedArrayBuffer')");
  Assert(internalSlotsList.includes('ArrayLength'), "internalSlotsList.includes('ArrayLength')");
  Assert(internalSlotsList.includes('ByteOffset'), "internalSlotsList.includes('ByteOffset')");
  Assert(internalSlotsList.includes('TypedArrayName'), "internalSlotsList.includes('TypedArrayName')");
  const A = new IntegerIndexedExoticObjectValue();

  for (const slot of internalSlotsList) {
    A[slot] = Value.undefined;
  }

  A.Prototype = prototype;
  A.Extensible = Value.true;
  return A;
} // 9.4.5.8 #sec-integerindexedelementget

function IntegerIndexedElementGet(O, index) {
  Assert(O instanceof IntegerIndexedExoticObjectValue, "O instanceof IntegerIndexedExoticObjectValue");
  Assert(Type(index) === 'Number', "Type(index) === 'Number'");
  const buffer = O.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }

  if (IsValidIntegerIndex(O, index) === Value.false) {
    return Value.undefined;
  }

  const offset = O.ByteOffset;
  const arrayTypeName = O.TypedArrayName.stringValue();
  const {
    ElementSize: elementSize,
    ElementType: elementType
  } = typedArrayInfo.get(arrayTypeName);
  const indexedPosition = new Value(index.numberValue() * elementSize + offset.numberValue());
  return GetValueFromBuffer(buffer, indexedPosition, elementType);
} // 9.4.5.9 #sec-integerindexedelementset

function IntegerIndexedElementSet(O, index, value) {
  Assert(O instanceof IntegerIndexedExoticObjectValue, "O instanceof IntegerIndexedExoticObjectValue");
  Assert(Type(index) === 'Number', "Type(index) === 'Number'");

  let _temp15 = ToNumber(value);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const numValue = _temp15;
  const buffer = O.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }

  if (IsValidIntegerIndex(O, index) === Value.false) {
    return Value.false;
  }

  const offset = O.ByteOffset;
  const arrayTypeName = O.TypedArrayName.stringValue();
  const {
    ElementSize: elementSize,
    ElementType: elementType
  } = typedArrayInfo.get(arrayTypeName);
  const indexedPosition = new Value(index.numberValue() * elementSize + offset.numberValue());

  let _temp16 = SetValueInBuffer(buffer, indexedPosition, elementType, numValue);

  Assert(!(_temp16 instanceof AbruptCompletion), "SetValueInBuffer(buffer, indexedPosition, elementType, numValue, true, 'Unordered')" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }
  return Value.true;
}

// 25.6 #sec-promise-objects
// 25.6.1.1 #sec-promisecapability-records

class PromiseCapabilityRecord {
  constructor() {
    this.Promise = Value.undefined;
    this.Resolve = Value.undefined;
    this.Reject = Value.undefined;
  }

} // 25.6.1.2 #sec-promisereaction-records

class PromiseReactionRecord {
  constructor(O) {
    Assert(O.Capability instanceof PromiseCapabilityRecord || O.Capability === Value.undefined, "O.Capability instanceof PromiseCapabilityRecord\n        || O.Capability === Value.undefined");
    Assert(O.Type === 'Fulfill' || O.Type === 'Reject', "O.Type === 'Fulfill' || O.Type === 'Reject'");
    Assert(O.Handler instanceof FunctionValue || O.Handler === Value.undefined, "O.Handler instanceof FunctionValue\n        || O.Handler === Value.undefined");
    this.Capability = O.Capability;
    this.Type = O.Type;
    this.Handler = O.Handler;
  }

} // 25.6.1.3 #sec-createresolvingfunctions

function CreateResolvingFunctions(promise) {
  const alreadyResolved = {
    Value: false
  };
  const stepsResolve = PromiseResolveFunctions;

  let _temp = CreateBuiltinFunction(stepsResolve, ['Promise', 'AlreadyResolved']);

  Assert(!(_temp instanceof AbruptCompletion), "CreateBuiltinFunction(stepsResolve, ['Promise', 'AlreadyResolved'])" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const resolve = _temp;
  SetFunctionLength(resolve, new Value(1));
  resolve.Promise = promise;
  resolve.AlreadyResolved = alreadyResolved;
  const stepsReject = PromiseRejectFunctions;

  let _temp2 = CreateBuiltinFunction(stepsReject, ['Promise', 'AlreadyResolved']);

  Assert(!(_temp2 instanceof AbruptCompletion), "CreateBuiltinFunction(stepsReject, ['Promise', 'AlreadyResolved'])" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const reject = _temp2;
  SetFunctionLength(reject, new Value(1));
  reject.Promise = promise;
  reject.AlreadyResolved = alreadyResolved;
  return {
    Resolve: resolve,
    Reject: reject
  };
} // 25.6.1.3.1 #sec-promise-reject-functions

function PromiseRejectFunctions([reason = Value.undefined]) {
  const F = this;
  Assert('Promise' in F && Type(F.Promise) === 'Object', "'Promise' in F && Type(F.Promise) === 'Object'");
  const promise = F.Promise;
  const alreadyResolved = F.AlreadyResolved;

  if (alreadyResolved.Value === true) {
    return Value.undefined;
  }

  alreadyResolved.Value = true;
  return RejectPromise(promise, reason);
} // 25.6.1.3.2 #sec-promise-resolve-functions


function PromiseResolveFunctions([resolution = Value.undefined]) {
  const F = this;
  Assert('Promise' in F && Type(F.Promise) === 'Object', "'Promise' in F && Type(F.Promise) === 'Object'");
  const promise = F.Promise;
  const alreadyResolved = F.AlreadyResolved;

  if (alreadyResolved.Value === true) {
    return Value.undefined;
  }

  alreadyResolved.Value = true;

  if (SameValue(resolution, promise) === Value.true) {
    const selfResolutionError = surroundingAgent.Throw('TypeError', 'CannotResolvePromiseWithItself').Value;
    return RejectPromise(promise, selfResolutionError);
  }

  if (Type(resolution) !== 'Object') {
    return FulfillPromise(promise, resolution);
  }

  const then = Get(resolution, new Value('then'));

  if (then instanceof AbruptCompletion) {
    return RejectPromise(promise, then.Value);
  }

  const thenAction = then.Value;

  if (IsCallable(thenAction) === Value.false) {
    return FulfillPromise(promise, resolution);
  }

  EnqueueJob('PromiseJobs', PromiseResolveThenableJob, [promise, resolution, thenAction]);
  return Value.undefined;
} // 25.6.1.4 #sec-fulfillpromise


function FulfillPromise(promise, value) {
  Assert(promise.PromiseState === 'pending', "promise.PromiseState === 'pending'");
  const reactions = promise.PromiseFulfillReactions;
  promise.PromiseResult = value;
  promise.PromiseFulfillReactions = undefined;
  promise.PromiseRejectReactions = undefined;
  promise.PromiseState = 'fulfilled';
  return TriggerPromiseReactions(reactions, value);
} // 25.6.1.5 #sec-newpromisecapability


function NewPromiseCapability(C) {
  if (IsConstructor(C) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', C);
  }

  const promiseCapability = new PromiseCapabilityRecord();
  const steps = GetCapabilitiesExecutorFunctions;

  let _temp3 = CreateBuiltinFunction(steps, ['Capability']);

  Assert(!(_temp3 instanceof AbruptCompletion), "CreateBuiltinFunction(steps, ['Capability'])" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const executor = _temp3;
  SetFunctionLength(executor, new Value(2));
  executor.Capability = promiseCapability;

  let _temp4 = Construct(C, [executor]);
  /* istanbul ignore if */


  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }
  /* istanbul ignore if */


  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const promise = _temp4;

  if (IsCallable(promiseCapability.Resolve) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'PromiseResolveFunction', promiseCapability.Resolve);
  }

  if (IsCallable(promiseCapability.Reject) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'PromiseRejectFunction', promiseCapability.Reject);
  }

  promiseCapability.Promise = promise;
  return promiseCapability;
} // 25.6.1.5.1 #sec-getcapabilitiesexecutor-functions

function GetCapabilitiesExecutorFunctions([resolve = Value.undefined, reject = Value.undefined]) {
  const F = this;
  const promiseCapability = F.Capability;

  if (Type(promiseCapability.Resolve) !== 'Undefined') {
    return surroundingAgent.Throw('TypeError', 'PromiseCapabilityFunctionAlreadySet', 'resolve');
  }

  if (Type(promiseCapability.Reject) !== 'Undefined') {
    return surroundingAgent.Throw('TypeError', 'PromiseCapabilityFunctionAlreadySet', 'reject');
  }

  promiseCapability.Resolve = resolve;
  promiseCapability.Reject = reject;
  return Value.undefined;
} // 25.6.1.6 #sec-ispromise


function IsPromise(x) {
  if (Type(x) !== 'Object') {
    return Value.false;
  }

  if (!('PromiseState' in x)) {
    return Value.false;
  }

  return Value.true;
} // 25.6.1.7 #sec-rejectpromise

function RejectPromise(promise, reason) {
  Assert(promise.PromiseState === 'pending', "promise.PromiseState === 'pending'");
  const reactions = promise.PromiseRejectReactions;
  promise.PromiseResult = reason;
  promise.PromiseFulfillReactions = undefined;
  promise.PromiseRejectReactions = undefined;
  promise.PromiseState = 'rejected';

  if (promise.PromiseIsHandled === Value.false) {
    HostPromiseRejectionTracker(promise, 'reject');
  }

  return TriggerPromiseReactions(reactions, reason);
} // 25.6.1.8 #sec-triggerpromisereactions


function TriggerPromiseReactions(reactions, argument) {
  reactions.forEach(reaction => {
    EnqueueJob('PromiseJobs', PromiseReactionJob, [reaction, argument]);
  });
  return Value.undefined;
} // 25.6.2.1 #sec-promisereactionjob


function PromiseReactionJob(reaction, argument) {
  Assert(reaction instanceof PromiseReactionRecord, "reaction instanceof PromiseReactionRecord");
  const promiseCapability = reaction.Capability;
  const type = reaction.Type;
  const handler = reaction.Handler;
  let handlerResult;

  if (handler === Value.undefined) {
    if (type === 'Fulfill') {
      handlerResult = new NormalCompletion(argument);
    } else {
      Assert(type === 'Reject', "type === 'Reject'");
      handlerResult = new ThrowCompletion(argument);
    }
  } else {
    handlerResult = Call(handler, Value.undefined, [argument]);
  }

  if (promiseCapability === Value.undefined) {
    Assert(!(handlerResult instanceof AbruptCompletion), "!(handlerResult instanceof AbruptCompletion)");
    return new NormalCompletion(undefined);
  }

  let status;

  if (handlerResult instanceof AbruptCompletion) {
    status = Call(promiseCapability.Reject, Value.undefined, [handlerResult.Value]);
  } else {
    status = Call(promiseCapability.Resolve, Value.undefined, [EnsureCompletion(handlerResult).Value]);
  }

  return status;
} // 25.6.2.2 #sec-promiseresolvethenablejob

function PromiseResolveThenableJob(promiseToResolve, thenable, then) {
  const resolvingFunctions = CreateResolvingFunctions(promiseToResolve);
  const thenCallResult = Call(then, thenable, [resolvingFunctions.Resolve, resolvingFunctions.Reject]);

  if (thenCallResult instanceof AbruptCompletion) {
    const status = Call(resolvingFunctions.Reject, Value.undefined, [thenCallResult.Value]);
    return status;
  }

  return thenCallResult;
} // 25.6.4.5.1 #sec-promise-resolve


function PromiseResolve(C, x) {
  Assert(Type(C) === 'Object', "Type(C) === 'Object'");

  if (IsPromise(x) === Value.true) {
    let _temp5 = Get(x, new Value('constructor'));

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const xConstructor = _temp5;

    if (SameValue(xConstructor, C) === Value.true) {
      return x;
    }
  }

  let _temp6 = NewPromiseCapability(C);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const promiseCapability = _temp6;

  let _temp7 = Call(promiseCapability.Resolve, Value.undefined, [x]);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }
  return promiseCapability.Promise;
} // 25.6.5.4.1 #sec-performpromisethen

function PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability) {
  Assert(IsPromise(promise) === Value.true, "IsPromise(promise) === Value.true");

  if (resultCapability) {
    Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
  } else {
    resultCapability = Value.undefined;
  }

  if (IsCallable(onFulfilled) === Value.false) {
    onFulfilled = Value.undefined;
  }

  if (IsCallable(onRejected) === Value.false) {
    onRejected = Value.undefined;
  }

  const fulfillReaction = new PromiseReactionRecord({
    Capability: resultCapability,
    Type: 'Fulfill',
    Handler: onFulfilled
  });
  const rejectReaction = new PromiseReactionRecord({
    Capability: resultCapability,
    Type: 'Reject',
    Handler: onRejected
  });

  if (promise.PromiseState === 'pending') {
    promise.PromiseFulfillReactions.push(fulfillReaction);
    promise.PromiseRejectReactions.push(rejectReaction);
  } else if (promise.PromiseState === 'fulfilled') {
    const value = promise.PromiseResult;
    EnqueueJob('PromiseJobs', PromiseReactionJob, [fulfillReaction, value]);
  } else {
    Assert(promise.PromiseState === 'rejected', "promise.PromiseState === 'rejected'");
    const reason = promise.PromiseResult;

    if (promise.PromiseIsHandled === Value.false) {
      HostPromiseRejectionTracker(promise, 'handle');
    }

    EnqueueJob('PromiseJobs', PromiseReactionJob, [rejectReaction, reason]);
  }

  promise.PromiseIsHandled = Value.true;

  if (resultCapability === Value.undefined) {
    return Value.undefined;
  } else {
    return resultCapability.Promise;
  }
}

function GetBase(V) {
  Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
  return V.BaseValue;
} // 6.2.4.2 #sec-getreferencedname

function GetReferencedName(V) {
  Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
  return V.ReferencedName;
} // 6.2.4.3 #sec-isstrictreference

function IsStrictReference(V) {
  Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
  return V.StrictReference;
} // 6.2.4.4 #sec-hasprimitivebase

function HasPrimitiveBase(V) {
  Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");

  if (V.BaseValue instanceof PrimitiveValue) {
    return Value.true;
  }

  return Value.false;
} // 6.2.4.5 #sec-ispropertyreference

function IsPropertyReference(V) {
  Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");

  if (Type(V.BaseValue) === 'Object' || HasPrimitiveBase(V) === Value.true) {
    return Value.true;
  }

  return Value.false;
} // 6.2.4.6 #sec-isunresolvablereference

function IsUnresolvableReference(V) {
  Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");

  if (V.BaseValue === Value.undefined) {
    return Value.true;
  }

  return Value.false;
} // 6.2.4.7 #sec-issuperreference

function IsSuperReference(V) {
  // 1. Assert: Type(V) is Reference.
  Assert(Type(V) === 'Reference', "Type(V) === 'Reference'"); // 2. If V has a thisValue component, return true; otherwise return false.

  return 'thisValue' in V ? Value.true : Value.false;
} // 6.2.4.8 #sec-getvalue

function GetValue(V) {
  /* istanbul ignore if */
  if (V instanceof AbruptCompletion) {
    return V;
  }
  /* istanbul ignore if */


  if (V instanceof Completion) {
    V = V.Value;
  }

  if (Type(V) !== 'Reference') {
    return V;
  }

  let base = GetBase(V);

  if (IsUnresolvableReference(V) === Value.true) {
    return surroundingAgent.Throw('ReferenceError', 'NotDefined', GetReferencedName(V));
  }

  if (IsPropertyReference(V) === Value.true) {
    if (HasPrimitiveBase(V) === Value.true) {
      Assert(base !== Value.undefined && base !== Value.null, "base !== Value.undefined && base !== Value.null");

      let _temp = ToObject(base);

      Assert(!(_temp instanceof AbruptCompletion), "ToObject(base)" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      base = _temp;
    }

    return base.Get(GetReferencedName(V), GetThisValue(V));
  } else {
    return base.GetBindingValue(GetReferencedName(V), IsStrictReference(V));
  }
} // 6.2.4.9 #sec-putvalue

function PutValue(V, W) {
  if (V instanceof AbruptCompletion) {
    return V;
  }

  if (V instanceof Completion) {
    V = V.Value;
  }

  if (W instanceof AbruptCompletion) {
    return W;
  }

  if (W instanceof Completion) {
    W = W.Value;
  }

  if (Type(V) !== 'Reference') {
    return surroundingAgent.Throw('ReferenceError');
  }

  let base = GetBase(V);

  if (IsUnresolvableReference(V) === Value.true) {
    if (IsStrictReference(V) === Value.true) {
      return surroundingAgent.Throw('ReferenceError', 'NotDefined', GetReferencedName(V));
    }

    const globalObj = GetGlobalObject();
    return Set$1(globalObj, GetReferencedName(V), W, Value.false);
  } else if (IsPropertyReference(V) === Value.true) {
    if (HasPrimitiveBase(V) === Value.true) {
      Assert(Type(base) !== 'Undefined' && Type(base) !== 'Null', "Type(base) !== 'Undefined' && Type(base) !== 'Null'");

      let _temp2 = ToObject(base);

      Assert(!(_temp2 instanceof AbruptCompletion), "ToObject(base)" + ' returned an abrupt completion');

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      base = _temp2;
    }

    let _temp3 = base.Set(GetReferencedName(V), W, GetThisValue(V));
    /* istanbul ignore if */


    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }
    /* istanbul ignore if */


    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const succeeded = _temp3;

    if (succeeded === Value.false && IsStrictReference(V) === Value.true) {
      return surroundingAgent.Throw('TypeError', 'CannotSetProperty', GetReferencedName(V), base);
    }

    return new NormalCompletion(Value.undefined);
  } else {
    return base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V));
  }
} // 6.2.4.10 #sec-getthisvalue

function GetThisValue(V) {
  // 1. Assert: IsPropertyReference(V) is true.
  Assert(IsPropertyReference(V) === Value.true, "IsPropertyReference(V) === Value.true"); // 2. If IsSuperReference(V) is true, then

  if (IsSuperReference(V) === Value.true) {
    // a. Return the value of the thisValue component of the reference V.
    return V.thisValue;
  } // 3. Return GetBase(V).


  return GetBase(V);
} // 6.2.4.11 #sec-initializereferencedbinding

function InitializeReferencedBinding(V, W) {
  if (V instanceof AbruptCompletion) {
    return V;
  }

  if (V instanceof Completion) {
    V = V.Value;
  }

  if (W instanceof AbruptCompletion) {
    return W;
  }

  if (W instanceof Completion) {
    W = W.Value;
  }
  Assert(Type(V) === 'Reference', "Type(V) === 'Reference'");
  Assert(IsUnresolvableReference(V) === Value.false, "IsUnresolvableReference(V) === Value.false");
  const base = GetBase(V);
  Assert(Type(base) === 'EnvironmentRecord', "Type(base) === 'EnvironmentRecord'");
  return base.InitializeBinding(GetReferencedName(V), W);
}

function RegExpAlloc(newTarget) {
  let _temp = OrdinaryCreateFromConstructor(newTarget, '%RegExp.prototype%', ['RegExpMatcher', 'OriginalSource', 'OriginalFlags']);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const obj = _temp;

  let _temp2 = DefinePropertyOrThrow(obj, new Value('lastIndex'), Descriptor({
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp2 instanceof AbruptCompletion), "DefinePropertyOrThrow(obj, new Value('lastIndex'), Descriptor({\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  return obj;
} // 21.2.3.2.2 #sec-regexpinitialize

function RegExpInitialize(obj, pattern, flags) {
  let P;

  if (pattern === Value.undefined) {
    P = new Value('');
  } else {
    let _temp3 = ToString(pattern);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    P = _temp3;
  }

  let F;

  if (flags === Value.undefined) {
    F = new Value('');
  } else {
    let _temp4 = ToString(flags);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    F = _temp4;
  }

  const f = F.stringValue();

  if (/^[gimsuy]*$/.test(f) === false || new globalThis.Set(f).size !== f.length) {
    return surroundingAgent.Throw('SyntaxError', 'InvalidRegExpFlags', f);
  }

  const BMP = !f.includes('u');
    // TODO: remove this once internal parsing is implemented


  try {
    new RegExp(P.stringValue(), F.stringValue()); // eslint-disable-line no-new
  } catch (e) {
    if (e instanceof SyntaxError) {
      return surroundingAgent.Throw('SyntaxError', 'Raw', e.message);
    }

    throw e;
  }

  obj.OriginalSource = P;
  obj.OriginalFlags = F;
  obj.RegExpMatcher = getMatcher(P, F);

  let _temp5 = Set$1(obj, new Value('lastIndex'), new Value(0), Value.true);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }
  return obj;
} // TODO: implement an independant matcher

function getMatcher(P, F) {
  const regex = new RegExp(P.stringValue(), F.stringValue());
  const unicode = F.stringValue().includes('u');
  return function RegExpMatcher(S, lastIndex) {
    regex.lastIndex = lastIndex.numberValue();
    const result = regex.exec(S.stringValue());

    if (result === null) {
      return null;
    }

    if (result.index > lastIndex.numberValue()) {
      return null;
    }

    const captures = [];

    for (const capture of result.slice(1)) {
      if (capture === undefined) {
        captures.push(Value.undefined);
      } else if (unicode) {
        captures.push(Array.from(capture).map(char => char.codePointAt(0)));
      } else {
        captures.push(capture.split('').map(char => char.charCodeAt(0)));
      }
    }

    return {
      endIndex: new Value(result.index + result[0].length),
      captures
    };
  };
} // 21.2.3.2.3 #sec-regexpcreate


function RegExpCreate(P, F) {
  let _temp6 = RegExpAlloc(surroundingAgent.intrinsic('%RegExp%'));

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const obj = _temp6;
  return RegExpInitialize(obj, P, F);
} // 21.2.3.2.4 #sec-escaperegexppattern

function EscapeRegExpPattern(P, F) {
  // TODO: implement this without host
  const re = new RegExp(P.stringValue(), F.stringValue());
  return new Value(re.source);
}

// 10 #sec-ecmascript-language-source-code
// 10.1.1 #sec-utf16encoding

function UTF16Encoding(cp) {
  Assert(cp >= 0 && cp <= 0x10FFFF, "cp >= 0 && cp <= 0x10FFFF");

  if (cp <= 0xFFFF) {
    return [cp];
  }

  const cu1 = Math.floor((cp - 0x10000) / 0x400) + 0xD800;
  const cu2 = (cp - 0x10000) % 0x400 + 0xDC00;
  return [cu1, cu2];
} // 10.1.2 #sec-utf16decode

function UTF16Decode(lead, trail) {
  Assert(isLeadingSurrogate(lead) && isTrailingSurrogate(trail), "isLeadingSurrogate(lead) && isTrailingSurrogate(trail)");
  const cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
  return cp;
} // 10.1.3 #sec-codepointat

function CodePointAt(string, position) {
  const size = string.stringValue().length;
  Assert(position >= 0 && position < size, "position >= 0 && position < size");
  const first = string.stringValue().charCodeAt(position);
  let cp = first;

  if (!isLeadingSurrogate(first) && !isTrailingSurrogate(first)) {
    return {
      CodePoint: new Value(cp),
      CodeUnitCount: new Value(1),
      IsUnpairedSurrogate: Value.false
    };
  }

  if (isTrailingSurrogate(first) || position + 1 === size) {
    return {
      CodePoint: new Value(cp),
      CodeUnitCount: new Value(1),
      IsUnpairedSurrogate: Value.true
    };
  }

  const second = string.stringValue().charCodeAt(position + 1);

  if (!isTrailingSurrogate(second)) {
    return {
      CodePoint: new Value(cp),
      CodeUnitCount: new Value(1),
      IsUnpairedSurrogate: Value.true
    };
  }

  let _temp = UTF16Decode(first, second);

  Assert(!(_temp instanceof AbruptCompletion), "UTF16Decode(first, second)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  cp = _temp;
  return {
    CodePoint: new Value(cp),
    CodeUnitCount: new Value(2),
    IsUnpairedSurrogate: Value.false
  };
}

function IsAccessorDescriptor(Desc) {
  if (Type(Desc) === 'Undefined') {
    return false;
  }

  if (Desc.Get === undefined && Desc.Set === undefined) {
    return false;
  }

  return true;
} // 6.2.5.2 IsDataDescriptor

function IsDataDescriptor(Desc) {
  if (Type(Desc) === 'Undefined') {
    return false;
  }

  if (Desc.Value === undefined && Desc.Writable === undefined) {
    return false;
  }

  return true;
} // 6.2.5.3 IsGenericDescriptor

function IsGenericDescriptor(Desc) {
  if (Type(Desc) === 'Undefined') {
    return false;
  }

  if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
    return true;
  }

  return false;
} // 6.2.5.4 #sec-frompropertydescriptor

function FromPropertyDescriptor(Desc) {
  if (Type(Desc) === 'Undefined') {
    return Value.undefined;
  }

  const obj = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  if (Desc.Value !== undefined) {
    let _temp = CreateDataProperty(obj, new Value('value'), Desc.Value);

    Assert(!(_temp instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('value'), Desc.Value)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }
  }

  if (Desc.Writable !== undefined) {
    let _temp2 = CreateDataProperty(obj, new Value('writable'), Desc.Writable);

    Assert(!(_temp2 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('writable'), Desc.Writable)" + ' returned an abrupt completion');

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }
  }

  if (Desc.Get !== undefined) {
    let _temp3 = CreateDataProperty(obj, new Value('get'), Desc.Get);

    Assert(!(_temp3 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('get'), Desc.Get)" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }
  }

  if (Desc.Set !== undefined) {
    let _temp4 = CreateDataProperty(obj, new Value('set'), Desc.Set);

    Assert(!(_temp4 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('set'), Desc.Set)" + ' returned an abrupt completion');

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }
  }

  if (Desc.Enumerable !== undefined) {
    let _temp5 = CreateDataProperty(obj, new Value('enumerable'), Desc.Enumerable);

    Assert(!(_temp5 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('enumerable'), Desc.Enumerable)" + ' returned an abrupt completion');

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }
  }

  if (Desc.Configurable !== undefined) {
    let _temp6 = CreateDataProperty(obj, new Value('configurable'), Desc.Configurable);

    Assert(!(_temp6 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('configurable'), Desc.Configurable)" + ' returned an abrupt completion');

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
  } // Assert: All of the above CreateDataProperty operations return true.


  return obj;
} // 6.2.5.5 #sec-topropertydescriptor

function ToPropertyDescriptor(Obj) {
  if (Type(Obj) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', Obj);
  }

  const desc = Descriptor({});

  let _temp7 = HasProperty(Obj, new Value('enumerable'));
  /* istanbul ignore if */


  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }
  /* istanbul ignore if */


  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const hasEnumerable = _temp7;

  if (hasEnumerable === Value.true) {
    let _temp8 = Get(Obj, new Value('enumerable'));

    if (_temp8 instanceof AbruptCompletion) {
      return _temp8;
    }

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }

    const enumerable = ToBoolean(_temp8);
    desc.Enumerable = enumerable;
  }

  let _temp9 = HasProperty(Obj, new Value('configurable'));

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const hasConfigurable = _temp9;

  if (hasConfigurable === Value.true) {
    let _temp10 = Get(Obj, new Value('configurable'));

    if (_temp10 instanceof AbruptCompletion) {
      return _temp10;
    }

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }

    const conf = ToBoolean(_temp10);
    desc.Configurable = conf;
  }

  let _temp11 = HasProperty(Obj, new Value('value'));

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const hasValue = _temp11;

  if (hasValue === Value.true) {
    let _temp12 = Get(Obj, new Value('value'));

    if (_temp12 instanceof AbruptCompletion) {
      return _temp12;
    }

    if (_temp12 instanceof Completion) {
      _temp12 = _temp12.Value;
    }

    const value = _temp12;
    desc.Value = value;
  }

  let _temp13 = HasProperty(Obj, new Value('writable'));

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  const hasWritable = _temp13;

  if (hasWritable === Value.true) {
    let _temp14 = Get(Obj, new Value('writable'));

    if (_temp14 instanceof AbruptCompletion) {
      return _temp14;
    }

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    const writable = ToBoolean(_temp14);
    desc.Writable = writable;
  }

  let _temp15 = HasProperty(Obj, new Value('get'));

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const hasGet = _temp15;

  if (hasGet === Value.true) {
    let _temp16 = Get(Obj, new Value('get'));

    if (_temp16 instanceof AbruptCompletion) {
      return _temp16;
    }

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }

    const getter = _temp16;

    if (IsCallable(getter) === Value.false && Type(getter) !== 'Undefined') {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', getter);
    }

    desc.Get = getter;
  }

  let _temp17 = HasProperty(Obj, new Value('set'));

  if (_temp17 instanceof AbruptCompletion) {
    return _temp17;
  }

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  const hasSet = _temp17;

  if (hasSet === Value.true) {
    let _temp18 = Get(Obj, new Value('set'));

    if (_temp18 instanceof AbruptCompletion) {
      return _temp18;
    }

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }

    const setter = _temp18;

    if (IsCallable(setter) === Value.false && Type(setter) !== 'Undefined') {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', setter);
    }

    desc.Set = setter;
  }

  if (desc.Get !== undefined || desc.Set !== undefined) {
    if (desc.Value !== undefined || desc.Writable !== undefined) {
      return surroundingAgent.Throw('TypeError', 'InvalidPropertyDescriptor');
    }
  }

  return desc;
} // 6.2.5.6 #sec-completepropertydescriptor

function CompletePropertyDescriptor(Desc) {
  Assert(Type(Desc) === 'Descriptor', "Type(Desc) === 'Descriptor'");
  const like = Descriptor({
    Value: Value.undefined,
    Writable: false,
    Get: Value.undefined,
    Set: Value.undefined,
    Enumerable: false,
    Configurable: false
  });

  if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
    if (Desc.Value === undefined) {
      Desc.Value = like.Value;
    }

    if (Desc.Writable === undefined) {
      Desc.Writable = like.Writable;
    }
  } else {
    if (Desc.Get === undefined) {
      Desc.Get = like.Get;
    }

    if (Desc.Set === undefined) {
      Desc.Set = like.Set;
    }
  }

  if (Desc.Enumerable === undefined) {
    Desc.Enumerable = like.Enumerable;
  }

  if (Desc.Configurable === undefined) {
    Desc.Configurable = like.Configurable;
  }

  return Desc;
} // 6.2.7.1 #sec-createbytedatablock

function CreateByteDataBlock(size) {
  size = size.numberValue();
  Assert(size >= 0, "size >= 0");
  let db;

  try {
    db = new DataBlock(size);
  } catch (err) {
    return surroundingAgent.Throw('RangeError', 'CannotAllocateDataBlock');
  }

  return db;
} // 6.2.7.3 #sec-copydatablockbytes

function CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) {
  Assert(Type(toIndex) === 'Number', "Type(toIndex) === 'Number'");
  Assert(Type(fromIndex) === 'Number', "Type(fromIndex) === 'Number'");
  Assert(Type(count) === 'Number', "Type(count) === 'Number'");
  toIndex = toIndex.numberValue();
  fromIndex = fromIndex.numberValue();
  count = count.numberValue();
  Assert(fromBlock !== toBlock, "fromBlock !== toBlock");
  Assert(Type(fromBlock) === 'Data Block'
  /* || Type(fromBlock) === 'Shared Data Block' */
  , "Type(fromBlock) === 'Data Block'");
  Assert(Type(toBlock) === 'Data Block'
  /* || Type(toBlock) === 'Shared Data Block' */
  , "Type(toBlock) === 'Data Block'");
  Assert(Number.isSafeInteger(fromIndex) && fromIndex >= 0, "Number.isSafeInteger(fromIndex) && fromIndex >= 0");
  Assert(Number.isSafeInteger(toIndex) && toIndex >= 0, "Number.isSafeInteger(toIndex) && toIndex >= 0");
  Assert(Number.isSafeInteger(count) && count >= 0, "Number.isSafeInteger(count) && count >= 0");
  const fromSize = fromBlock.byteLength;
  Assert(fromIndex + count <= fromSize, "fromIndex + count <= fromSize");
  const toSize = toBlock.byteLength;
  Assert(toIndex + count <= toSize, "toIndex + count <= toSize");

  while (count > 0) {
    // if (Type(fromBlock) === 'Shared Data Block') {
    //   ...
    // } else {
    Assert(Type(toBlock) !== 'Shared Data Block', "Type(toBlock) !== 'Shared Data Block'");
    toBlock[toIndex] = fromBlock[fromIndex]; // }

    toIndex += 1;
    fromIndex += 1;
    count -= 1;
  }

  return new NormalCompletion(undefined);
}

function StringCreate(value, prototype) {
  Assert(Type(value) === 'String', "Type(value) === 'String'");
  const S = new StringExoticObjectValue();
  S.StringData = value;
  S.Prototype = prototype;
  S.Extensible = Value.true;
  const length = new Value(value.stringValue().length);

  let _temp = DefinePropertyOrThrow(S, new Value('length'), Descriptor({
    Value: length,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp instanceof AbruptCompletion), "DefinePropertyOrThrow(S, new Value('length'), Descriptor({\n    Value: length,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  return S;
} // 9.4.3.5 #sec-stringgetownproperty

function StringGetOwnProperty(S, P) {
  Assert(Type(S) === 'Object' && 'StringData' in S, "Type(S) === 'Object' && 'StringData' in S");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");

  if (Type(P) !== 'String') {
    return Value.undefined;
  }

  let _temp2 = CanonicalNumericIndexString(P);

  Assert(!(_temp2 instanceof AbruptCompletion), "CanonicalNumericIndexString(P)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const index = _temp2;

  if (Type(index) === 'Undefined') {
    return Value.undefined;
  }

  if (IsInteger(index) === Value.false) {
    return Value.undefined;
  }

  if (Object.is(index.numberValue(), -0)) {
    return Value.undefined;
  }

  const str = S.StringData;
  Assert(Type(str) === 'String', "Type(str) === 'String'");
  const len = str.stringValue().length;

  if (index.numberValue() < 0 || len <= index.numberValue()) {
    return Value.undefined;
  }

  const resultStr = str.stringValue()[index.numberValue()];
  return Descriptor({
    Value: new Value(resultStr),
    Writable: Value.false,
    Enumerable: Value.true,
    Configurable: Value.false
  });
}

function SymbolDescriptiveString(sym) {
  Assert(Type(sym) === 'Symbol', "Type(sym) === 'Symbol'");
  let desc = sym.Description;

  if (Type(desc) === 'Undefined') {
    desc = new Value('');
  }

  return new Value(`Symbol(${desc.stringValue()})`);
}

// 7.2 #sec-testing-and-comparison-operations
// 7.2.1 #sec-requireobjectcoercible

function RequireObjectCoercible(argument) {
  const type = Type(argument);

  switch (type) {
    case 'Undefined':
      return surroundingAgent.Throw('TypeError', 'CannotConvertToObject', 'undefined');

    case 'Null':
      return surroundingAgent.Throw('TypeError', 'CannotConvertToObject', 'null');

    case 'Boolean':
    case 'Number':
    case 'String':
    case 'Symbol':
    case 'BigInt':
    case 'Object':
      return argument;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('RequireObjectCoercible', {
        type,
        argument
      });
  }
} // 7.2.2 #sec-isarray

function IsArray(argument) {
  if (Type(argument) !== 'Object') {
    return Value.false;
  }

  if (argument instanceof ArrayExoticObjectValue) {
    return Value.true;
  }

  if (argument instanceof ProxyExoticObjectValue) {
    if (Type(argument.ProxyHandler) === 'Null') {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'IsArray');
    }

    const target = argument.ProxyTarget;
    return IsArray(target);
  }

  return Value.false;
} // 7.2.3 #sec-iscallable

function IsCallable(argument) {
  if (Type(argument) !== 'Object') {
    return Value.false;
  }

  if ('Call' in argument) {
    return Value.true;
  }

  return Value.false;
} // 7.2.4 #sec-isconstructor

function IsConstructor(argument) {
  if (Type(argument) !== 'Object') {
    return Value.false;
  }

  if ('Construct' in argument) {
    return Value.true;
  }

  return Value.false;
} // 7.2.5 #sec-isextensible-o

function IsExtensible(O) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  return O.IsExtensible();
} // 7.2.6 #sec-isinteger

function IsInteger(argument) {
  if (Type(argument) !== 'Number') {
    return Value.false;
  }

  if (argument.isNaN() || argument.isInfinity()) {
    return Value.false;
  }

  if (Math.floor(Math.abs(argument.numberValue())) !== Math.abs(argument.numberValue())) {
    return Value.false;
  }

  return Value.true;
} // 7.2.7 #sec-ispropertykey

function IsPropertyKey(argument) {
  if (Type(argument) === 'String') {
    return true;
  }

  if (Type(argument) === 'Symbol') {
    return true;
  }

  return false;
} // 7.2.8 #sec-isregexp

function IsRegExp(argument) {
  if (Type(argument) !== 'Object') {
    return Value.false;
  }

  let _temp = Get(argument, wellKnownSymbols.match);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const matcher = _temp;

  if (matcher !== Value.undefined) {
    return ToBoolean(matcher);
  }

  if ('RegExpMatcher' in argument) {
    return Value.true;
  }

  return Value.false;
} // 7.2.9 #sec-isstringprefix

function IsStringPrefix(p, q) {
  Assert(Type(p) === 'String', "Type(p) === 'String'");
  Assert(Type(q) === 'String', "Type(q) === 'String'");
  return q.stringValue().startsWith(p.stringValue());
} // 7.2.10 #sec-samevalue

function SameValue(x, y) {
  // 1. If Type(x) is different from Type(y), return false.
  if (Type(x) !== Type(y)) {
    return Value.false;
  } // 2. If Type(x) is Number or BigInt, then


  if (Type(x) === 'Number' || Type(x) === 'BigInt') {
    // a. Return ! Type(x)::sameValue(x, y).
    return TypeNumeric(x).sameValue(x, y);
  } // 3. Return ! SameValueNonNumeric(x, y).


  let _temp2 = SameValueNonNumber(x, y);

  Assert(!(_temp2 instanceof AbruptCompletion), "SameValueNonNumber(x, y)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  return _temp2;
} // 7.2.11 #sec-samevaluezero

function SameValueZero(x, y) {
  // 1. If Type(x) is different from Type(y), return false.
  if (Type(x) !== Type(y)) {
    return Value.false;
  } // 2. If Type(x) is Number or BigInt, then


  if (Type(x) === 'Number' || Type(x) === 'BigInt') {
    // a. Return ! Type(x)::sameValueZero(x, y).
    return TypeNumeric(x).sameValueZero(x, y);
  } // 3. Return ! SameValueNonNumeric(x, y).


  return SameValueNonNumber(x, y);
} // 7.2.12 #sec-samevaluenonnumber

function SameValueNonNumber(x, y) {
  Assert(Type(x) !== 'Number', "Type(x) !== 'Number'");
  Assert(Type(x) === Type(y), "Type(x) === Type(y)");

  if (Type(x) === 'Undefined') {
    return Value.true;
  }

  if (Type(x) === 'Null') {
    return Value.true;
  }

  if (Type(x) === 'String') {
    if (x.stringValue() === y.stringValue()) {
      return Value.true;
    }

    return Value.false;
  }

  if (Type(x) === 'Boolean') {
    if (x === y) {
      return Value.true;
    }

    return Value.false;
  }

  if (Type(x) === 'Symbol') {
    return x === y ? Value.true : Value.false;
  }

  return x === y ? Value.true : Value.false;
} // 7.2.13 #sec-abstract-relational-comparison

function AbstractRelationalComparison(x, y, LeftFirst = true) {
  let px;
  let py; // 1. If the LeftFirst flag is true, then

  if (LeftFirst === true) {
    let _temp3 = ToPrimitive(x, 'Number');

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    // a. Let px be ? ToPrimitive(x, hint Number).
    px = _temp3; // b. Let py be ? ToPrimitive(y, hint Number).

    let _temp4 = ToPrimitive(y, 'Number');

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    py = _temp4;
  } else {
    let _temp5 = ToPrimitive(y, 'Number');

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    // a. NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.
    // b. Let py be ? ToPrimitive(y, hint Number).
    py = _temp5; // c. Let px be ? ToPrimitive(x, hint Number).

    let _temp6 = ToPrimitive(x, 'Number');

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    px = _temp6;
  } // 3. If Type(px) is String and Type(py) is String, then


  if (Type(px) === 'String' && Type(py) === 'String') {
    // a. If IsStringPrefix(py, px) is true, return false.
    if (IsStringPrefix(py, px)) {
      return Value.false;
    } // b. If IsStringPrefix(px, py) is true, return true.


    if (IsStringPrefix(px, py)) {
      return Value.true;
    } // c. Let k be the smallest nonnegative integer such that the code unit at index k within px
    //    is different from the code unit at index k within py. (There must be such a k, for
    //    neither String is a prefix of the other.)


    let k = 0;

    while (true) {
      if (px.stringValue()[k] !== py.stringValue()[k]) {
        break;
      }

      k += 1;
    } // d. Let m be the integer that is the numeric value of the code unit at index k within px.


    const m = px.stringValue().charCodeAt(k); // e. Let n be the integer that is the numeric value of the code unit at index k within py.

    const n = py.stringValue().charCodeAt(k); // f. If m < n, return true. Otherwise, return false.

    if (m < n) {
      return Value.true;
    } else {
      return Value.false;
    }
  } else {
    // a. If Type(px) is BigInt and Type(py) is String, then
    if (Type(px) === 'BigInt' && Type(py) === 'String') {
      let _temp7 = StringToBigInt(py);

      Assert(!(_temp7 instanceof AbruptCompletion), "StringToBigInt(py)" + ' returned an abrupt completion');

      if (_temp7 instanceof Completion) {
        _temp7 = _temp7.Value;
      }

      // i. Let ny be ! StringToBigInt(py).
      const ny = _temp7; // ii. If ny is NaN, return undefined.

      if (Number.isNaN(ny)) {
        return Value.undefined;
      } // iii. Return BigInt::lessThan(px, ny).


      return BigIntValue.lessThan(px, ny);
    } // b. If Type(px) is String and Type(py) is BigInt, then


    if (Type(px) === 'String' && Type(py) === 'BigInt') {
      let _temp8 = StringToBigInt(px);

      Assert(!(_temp8 instanceof AbruptCompletion), "StringToBigInt(px)" + ' returned an abrupt completion');

      if (_temp8 instanceof Completion) {
        _temp8 = _temp8.Value;
      }

      // i. Let ny be ! StringToBigInt(py).
      const nx = _temp8; // ii. If ny is NaN, return undefined.

      if (Number.isNaN(nx)) {
        return Value.undefined;
      } // iii. Return BigInt::lessThan(px, ny).


      return BigIntValue.lessThan(nx, py);
    } // c. Let nx be ? ToNumeric(px). NOTE: Because px and py are primitive values evaluation order is not important.


    let _temp9 = ToNumeric(px);

    if (_temp9 instanceof AbruptCompletion) {
      return _temp9;
    }

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }

    const nx = _temp9; // d. Let ny be ? ToNumeric(py).

    let _temp10 = ToNumeric(py);

    if (_temp10 instanceof AbruptCompletion) {
      return _temp10;
    }

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }

    const ny = _temp10; // e. If Type(nx) is the same as Type(ny), return Type(nx)::lessThan(nx, ny).

    if (Type(nx) === Type(ny)) {
      return TypeNumeric(nx).lessThan(nx, ny);
    } // f. Assert: Type(nx) is BigInt and Type(ny) is Number, or Type(nx) is Number and Type(ny) is BigInt.


    Assert(Type(nx) === 'BigInt' && Type(ny) === 'Number' || Type(nx) === 'Number' && Type(ny) === 'BigInt', "(Type(nx) === 'BigInt' && Type(ny) === 'Number') || (Type(nx) === 'Number' && Type(ny) === 'BigInt')"); // g. If nx or ny is NaN, return undefined.

    if (nx.isNaN && nx.isNaN() || ny.isNaN && ny.isNaN()) {
      return Value.undefined;
    } // h. If nx is - or ny is +, return true.


    if (nx.numberValue && nx.numberValue() === -Infinity || ny.numberValue && ny.numberValue() === +Infinity) {
      return Value.true;
    } // i. If nx is + or ny is -, return false.


    if (nx.numberValue && nx.numberValue() === +Infinity || ny.numberValue && ny.numberValue() === -Infinity) {
      return Value.false;
    } // j. If the mathematical value of nx is less than the mathematical value of ny, return true; otherwise return false.


    const a = nx.numberValue ? nx.numberValue() : nx.bigintValue();
    const b = ny.numberValue ? ny.numberValue() : ny.bigintValue();
    return a < b ? Value.true : Value.false;
  }
} // 7.2.14 #sec-abstract-equality-comparison

function AbstractEqualityComparison(x, y) {
  // 1. If Type(x) is the same as Type(y), then
  if (Type(x) === Type(y)) {
    // a. Return the result of performing Strict Equality Comparison x === y.
    return StrictEqualityComparison(x, y);
  } // 2. If x is null and y is undefined, return true.


  if (x === Value.null && y === Value.undefined) {
    return Value.true;
  } // 3. If x is undefined and y is null, return true.


  if (x === Value.undefined && y === Value.null) {
    return Value.true;
  } // 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y).


  if (Type(x) === 'Number' && Type(y) === 'String') {
    let _temp11 = ToNumber(y);

    Assert(!(_temp11 instanceof AbruptCompletion), "ToNumber(y)" + ' returned an abrupt completion');

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    return AbstractEqualityComparison(x, _temp11);
  } // 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y.


  if (Type(x) === 'String' && Type(y) === 'Number') {
    let _temp12 = ToNumber(x);

    Assert(!(_temp12 instanceof AbruptCompletion), "ToNumber(x)" + ' returned an abrupt completion');

    if (_temp12 instanceof Completion) {
      _temp12 = _temp12.Value;
    }

    return AbstractEqualityComparison(_temp12, y);
  } // 6. If Type(x) is BigInt and Type(y) is String, then


  if (Type(x) === 'BigInt' && Type(y) === 'String') {
    let _temp13 = StringToBigInt(y);

    Assert(!(_temp13 instanceof AbruptCompletion), "StringToBigInt(y)" + ' returned an abrupt completion');

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }

    // a. Let n be ! StringToBigInt(y).
    const n = _temp13; // b. If n is NaN, return false.

    if (Number.isNaN(n)) {
      return Value.false;
    } // c. Return the result of the comparison x == n.


    return AbstractEqualityComparison(x, n);
  } // 7. If Type(x) is String and Type(y) is BigInt, return the result of the comparison y == x.


  if (Type(x) === 'String' && Type(y) === 'BigInt') {
    return AbstractEqualityComparison(y, x);
  } // 8. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y.


  if (Type(x) === 'Boolean') {
    let _temp14 = ToNumber(x);

    Assert(!(_temp14 instanceof AbruptCompletion), "ToNumber(x)" + ' returned an abrupt completion');

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    return AbstractEqualityComparison(_temp14, y);
  } // 9. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y).


  if (Type(y) === 'Boolean') {
    let _temp15 = ToNumber(y);

    Assert(!(_temp15 instanceof AbruptCompletion), "ToNumber(y)" + ' returned an abrupt completion');

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    return AbstractEqualityComparison(x, _temp15);
  } // 10. If Type(x) is either String, Number, BigInt, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).


  if (['String', 'Number', 'BigInt', 'Symbol'].includes(Type(x)) && Type(y) === 'Object') {
    let _temp16 = ToPrimitive(y);

    if (_temp16 instanceof AbruptCompletion) {
      return _temp16;
    }

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }

    return AbstractEqualityComparison(x, _temp16);
  } // 11. If Type(x) is Object and Type(y) is either String, Number, BigInt, or Symbol, return the result of the comparison ToPrimitive(x) == y.


  if (Type(x) === 'Object' && ['String', 'Number', 'BigInt', 'Symbol'].includes(Type(y))) {
    let _temp17 = ToPrimitive(x);

    if (_temp17 instanceof AbruptCompletion) {
      return _temp17;
    }

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    return AbstractEqualityComparison(_temp17, y);
  } // 12. If Type(x) is BigInt and Type(y) is Number, or if Type(x) is Number and Type(y) is BigInt, then


  if (Type(x) === 'BigInt' && Type(y) === 'Number' || Type(x) === 'Number' && Type(y) === 'BigInt') {
    // a. If x or y are any of NaN, +, or -, return false.
    if (x.isNaN && (x.isNaN() || !x.isFinite()) || y.isNaN && (y.isNaN() || !y.isFinite())) {
      return Value.false;
    } // b. If the mathematical value of x is equal to the mathematical value of y, return true; otherwise return false.


    const a = x.numberValue ? x.numberValue() : x.bigintValue();
    const b = y.numberValue ? y.numberValue() : y.bigintValue();
    return a == b ? Value.true : Value.false; // eslint-disable-line eqeqeq
  } // 13. Return false.


  return Value.false;
} // 7.2.15 #sec-strict-equality-comparison

function StrictEqualityComparison(x, y) {
  // 1. If Type(x) is different from Type(y), return false.
  if (Type(x) !== Type(y)) {
    return Value.false;
  } // 2. If Type(x) is Number or BigInt, then


  if (Type(x) === 'Number' || Type(x) === 'BigInt') {
    let _temp18 = TypeNumeric(x).equal(x, y);

    Assert(!(_temp18 instanceof AbruptCompletion), "TypeNumeric(x).equal(x, y)" + ' returned an abrupt completion');

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }

    // a. Return ! Type(x)::equal(x, y).
    return _temp18;
  } // 3. Return ! SameValueNonNumeric(x, y).


  return SameValueNonNumber(x, y);
} // #sec-isvalidintegerindex

function IsValidIntegerIndex(O, index) {
  Assert(O instanceof IntegerIndexedExoticObjectValue, "O instanceof IntegerIndexedExoticObjectValue");
  Assert(Type(index) === 'Number', "Type(index) === 'Number'");

  if (IsInteger(index) === Value.false) {
    return Value.false;
  }

  index = index.numberValue();

  if (Object.is(index, -0)) {
    return Value.false;
  }

  if (index < 0 || index >= O.ArrayLength.numberValue()) {
    return Value.false;
  }

  return Value.true;
}

function ToPrimitive(input, PreferredType) {
  Assert(input instanceof Value, "input instanceof Value");

  if (Type(input) === 'Object') {
    let hint;

    if (PreferredType === undefined) {
      hint = new Value('default');
    } else if (PreferredType === 'String') {
      hint = new Value('string');
    } else {
      Assert(PreferredType === 'Number', "PreferredType === 'Number'");
      hint = new Value('number');
    }

    let _temp = GetMethod(input, wellKnownSymbols.toPrimitive);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const exoticToPrim = _temp;

    if (exoticToPrim !== Value.undefined) {
      let _temp2 = Call(exoticToPrim, input, [hint]);

      if (_temp2 instanceof AbruptCompletion) {
        return _temp2;
      }

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      const result = _temp2;

      if (Type(result) !== 'Object') {
        return result;
      }

      return surroundingAgent.Throw('TypeError', 'ObjectToPrimitive');
    }

    if (hint.stringValue() === 'default') {
      hint = new Value('number');
    }

    return OrdinaryToPrimitive(input, hint);
  }

  return input;
} // 7.1.1.1 #sec-ordinarytoprimitive

function OrdinaryToPrimitive(O, hint) {
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(Type(hint) === 'String' && (hint.stringValue() === 'string' || hint.stringValue() === 'number'), "Type(hint) === 'String' && (hint.stringValue() === 'string' || hint.stringValue() === 'number')");
  let methodNames;

  if (hint.stringValue() === 'string') {
    methodNames = [new Value('toString'), new Value('valueOf')];
  } else {
    methodNames = [new Value('valueOf'), new Value('toString')];
  }

  for (const name of methodNames) {
    let _temp3 = Get(O, name);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const method = _temp3;

    if (IsCallable(method) === Value.true) {
      let _temp4 = Call(method, O);

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      const result = _temp4;

      if (Type(result) !== 'Object') {
        return result;
      }
    }
  }

  return surroundingAgent.Throw('TypeError', 'ObjectToPrimitive');
} // 7.1.2 #sec-toboolean

function ToBoolean(argument) {
  const type = Type(argument);

  switch (type) {
    case 'Undefined':
      return Value.false;

    case 'Null':
      return Value.false;

    case 'Boolean':
      return argument;

    case 'Number':
      if (argument.numberValue() === 0 || argument.isNaN()) {
        return Value.false;
      }

      return Value.true;

    case 'String':
      if (argument.stringValue().length === 0) {
        return Value.false;
      }

      return Value.true;

    case 'Symbol':
      return Value.true;

    case 'BigInt':
      if (argument.bigintValue() === 0n) {
        return Value.false;
      }

      return Value.true;

    case 'Object':
      return Value.true;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ToBoolean', {
        type,
        argument
      });
  }
} // #sec-tonumeric

function ToNumeric(value) {
  let _temp5 = ToPrimitive(value, 'Number');

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  // 1. Let primValue be ? ToPrimitive(value, hint Number).
  const primValue = _temp5; // 2. If Type(primValue) is BigInt, return primValue.

  if (Type(primValue) === 'BigInt') {
    return primValue;
  } // 3. Return ? ToNumber(primValue).


  return ToNumber(primValue);
} // 7.1.3 #sec-tonumber

function ToNumber(argument) {
  const type = Type(argument);

  switch (type) {
    case 'Undefined':
      return new Value(NaN);

    case 'Null':
      return new Value(0);

    case 'Boolean':
      if (argument === Value.true) {
        return new Value(1);
      }

      return new Value(0);

    case 'Number':
      return argument;

    case 'String':
      return MV_StringNumericLiteral(argument.stringValue());

    case 'BigInt':
      return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');

    case 'Symbol':
      return surroundingAgent.Throw('TypeError', 'CannotConvertSymbol', 'number');

    case 'Object':
      {
        let _temp6 = ToPrimitive(argument, 'Number');

        if (_temp6 instanceof AbruptCompletion) {
          return _temp6;
        }

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        const primValue = _temp6;
        return ToNumber(primValue);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ToNumber', {
        type,
        argument
      });
  }
}

const sign = n => n >= 0 ? 1 : -1;

const mod$1 = (n, m) => {
  const r = n % m;
  return Math.floor(r >= 0 ? r : r + m);
}; // 7.1.4 #sec-tointeger


function ToInteger(argument) {
  let _temp7 = ToNumber(argument);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const number = _temp7.numberValue();

  if (Number.isNaN(number)) {
    return new Value(0);
  }

  if (number === 0 || !Number.isFinite(number)) {
    return new Value(number);
  }

  const int = sign(number) * Math.floor(Math.abs(number));
  return new Value(int);
} // 7.1.5 #sec-toint32

function ToInt32(argument) {
  let _temp8 = ToNumber(argument);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const number = _temp8.numberValue();

  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return new Value(0);
  }

  const int = sign(number) * Math.floor(Math.abs(number));
  const int32bit = mod$1(int, 2 ** 32);

  if (int32bit >= 2 ** 31) {
    return new Value(int32bit - 2 ** 32);
  }

  return new Value(int32bit);
} // 7.1.6 #sec-touint32

function ToUint32(argument) {
  let _temp9 = ToNumber(argument);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const number = _temp9.numberValue();

  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return new Value(0);
  }

  const int = sign(number) * Math.floor(Math.abs(number));
  const int32bit = mod$1(int, 2 ** 32);
  return new Value(int32bit);
} // 7.1.7 #sec-toint16

function ToInt16(argument) {
  let _temp10 = ToNumber(argument);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const number = _temp10.numberValue();

  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return new Value(0);
  }

  const int = sign(number) * Math.floor(Math.abs(number));
  const int16bit = mod$1(int, 2 ** 16);

  if (int16bit >= 2 ** 15) {
    return new Value(int16bit - 2 ** 16);
  }

  return new Value(int16bit);
} // 7.1.8 #sec-touint16

function ToUint16(argument) {
  let _temp11 = ToNumber(argument);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const number = _temp11.numberValue();

  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return new Value(0);
  }

  const int = sign(number) * Math.floor(Math.abs(number));
  const int16bit = mod$1(int, 2 ** 16);
  return new Value(int16bit);
} // 7.1.9 #sec-toint8

function ToInt8(argument) {
  let _temp12 = ToNumber(argument);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const number = _temp12.numberValue();

  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return new Value(0);
  }

  const int = sign(number) * Math.floor(Math.abs(number));
  const int8bit = mod$1(int, 2 ** 8);

  if (int8bit >= 2 ** 7) {
    return new Value(int8bit - 2 ** 8);
  }

  return new Value(int8bit);
} // 7.1.10 #sec-touint8

function ToUint8(argument) {
  let _temp13 = ToNumber(argument);

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  const number = _temp13.numberValue();

  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return new Value(0);
  }

  const int = sign(number) * Math.floor(Math.abs(number));
  const int8bit = mod$1(int, 2 ** 8);
  return new Value(int8bit);
} // 7.1.11 #sec-touint8clamp

function ToUint8Clamp(argument) {
  let _temp14 = ToNumber(argument);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const number = _temp14.numberValue();

  if (Number.isNaN(number)) {
    return new Value(0);
  }

  if (number <= 0) {
    return new Value(0);
  }

  if (number >= 255) {
    return new Value(255);
  }

  const f = Math.floor(number);

  if (f + 0.5 < number) {
    return new Value(f + 1);
  }

  if (number < f + 0.5) {
    return new Value(f);
  }

  if (f % 2 === 1) {
    return new Value(f + 1);
  }

  return new Value(f);
} // #sec-tobigint

function ToBigInt(argument) {
  let _temp15 = ToPrimitive(argument, 'Number');

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  // 1. Let prim be ? ToPrimitive(argument, hint Number).
  const prim = _temp15; // 2. Return the value that prim corresponds to in Table 12 (#table-tobigint).

  switch (Type(prim)) {
    case 'Undefined':
      // Throw a TypeError exception.
      return surroundingAgent.Throw('TypeError', 'CannotConvertToBigInt', prim);

    case 'Null':
      // Throw a TypeError exception.
      return surroundingAgent.Throw('TypeError', 'CannotConvertToBigInt', argument);

    case 'Boolean':
      // Return 1n if prim is true and 0n if prim is false.
      if (prim === Value.true) {
        return new Value(1n);
      }

      return new Value(0n);

    case 'BigInt':
      // Return prim.
      return prim;

    case 'Number':
      // Throw a TypeError exception.
      return surroundingAgent.Throw('TypeError', 'CannotConvertToBigInt', prim);

    case 'String':
      {
        let _temp16 = StringToBigInt(prim);

        Assert(!(_temp16 instanceof AbruptCompletion), "StringToBigInt(prim)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp16 instanceof Completion) {
          _temp16 = _temp16.Value;
        }

        // 1. Let n be ! StringToBigInt(prim).
        const n = _temp16; // 2. If n is NaN, throw a SyntaxError exception.

        if (Number.isNaN(n)) {
          return surroundingAgent.Throw('SyntaxError', 'CannotConvertToBigInt', prim);
        } // 3. Return n.


        return n;
      }

    case 'Symbol':
      return surroundingAgent.Throw('TypeError', 'CannotConvertSymbol', 'bigint');

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ToBigInt', argument);
  }
} // #sec-stringtobigint

function StringToBigInt(argument) {
  // Apply the algorithm in 7.1.4.1 (#sec-tonumber-applied-to-the-string-type) with the following changes:
  // 1. Replace the StrUnsignedDecimalLiteral production with DecimalDigits to not allow Infinity, decimal points, or exponents.
  // 2. If the MV is NaN, return NaN, otherwise return the BigInt which exactly corresponds to the MV, rather than rounding to a Number.
  // TODO: Adapt nearley grammar for this.
  try {
    return new Value(BigInt(argument.stringValue()));
  } catch {
    return NaN;
  }
} // #sec-tobigint64

function ToBigInt64(argument) {
  let _temp17 = ToBigInt(argument);

  if (_temp17 instanceof AbruptCompletion) {
    return _temp17;
  }

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  // 1. Let n be ? ToBigInt(argument).
  const n = _temp17; // 2. Let int64bit be n modulo 2^64.

  const int64bit = n.bigintValue() % 2n ** 64n; // 3. If int64bit  2^63, return int64bit - 2^64; otherwise return int64bit.

  if (int64bit >= 2n ** 63n) {
    return new Value(int64bit - 2n ** 64n);
  }

  return new Value(int64bit);
} // #sec-tobiguint64

function ToBigUint64(argument) {
  let _temp18 = ToBigInt(argument);

  if (_temp18 instanceof AbruptCompletion) {
    return _temp18;
  }

  if (_temp18 instanceof Completion) {
    _temp18 = _temp18.Value;
  }

  // 1. Let n be ? ToBigInt(argument).
  const n = _temp18; // 2. Let int64bit be n modulo 2^64.

  const int64bit = n.bigintValue() % 2n ** 64n; // 3. Return int64bit.

  return new Value(int64bit);
} // 7.1.12 #sec-tostring

function ToString(argument) {
  const type = Type(argument);

  switch (type) {
    case 'Undefined':
      return new Value('undefined');

    case 'Null':
      return new Value('null');

    case 'Boolean':
      return new Value(argument === Value.true ? 'true' : 'false');

    case 'Number':
      let _temp19 = NumberValue.toString(argument);

      Assert(!(_temp19 instanceof AbruptCompletion), "NumberValue.toString(argument)" + ' returned an abrupt completion');

      if (_temp19 instanceof Completion) {
        _temp19 = _temp19.Value;
      }

      // Return ! Number::toString(argument).
      return _temp19;

    case 'String':
      return argument;

    case 'Symbol':
      return surroundingAgent.Throw('TypeError', 'CannotConvertSymbol', 'string');

    case 'BigInt':
      let _temp20 = BigIntValue.toString(argument);

      Assert(!(_temp20 instanceof AbruptCompletion), "BigIntValue.toString(argument)" + ' returned an abrupt completion');

      if (_temp20 instanceof Completion) {
        _temp20 = _temp20.Value;
      }

      // Return ! BigInt::toString(argument).
      return _temp20;

    case 'Object':
      {
        let _temp21 = ToPrimitive(argument, 'String');

        if (_temp21 instanceof AbruptCompletion) {
          return _temp21;
        }

        if (_temp21 instanceof Completion) {
          _temp21 = _temp21.Value;
        }

        const primValue = _temp21;
        return ToString(primValue);
      }

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ToString', {
        type,
        argument
      });
  }
} // 7.1.13 #sec-toobject

function ToObject(argument) {
  const type = Type(argument);

  switch (type) {
    case 'Undefined':
      return surroundingAgent.Throw('TypeError', 'CannotConvertToObject', 'undefined');

    case 'Null':
      return surroundingAgent.Throw('TypeError', 'CannotConvertToObject', 'null');

    case 'Boolean':
      {
        const obj = ObjectCreate(surroundingAgent.intrinsic('%Boolean.prototype%'));
        obj.BooleanData = argument;
        return obj;
      }

    case 'Number':
      {
        const obj = ObjectCreate(surroundingAgent.intrinsic('%Number.prototype%'));
        obj.NumberData = argument;
        return obj;
      }

    case 'String':
      return StringCreate(argument, surroundingAgent.intrinsic('%String.prototype%'));

    case 'Symbol':
      {
        const obj = ObjectCreate(surroundingAgent.intrinsic('%Symbol.prototype%'));
        obj.SymbolData = argument;
        return obj;
      }

    case 'BigInt':
      {
        const obj = ObjectCreate(surroundingAgent.intrinsic('%BigInt.prototype%'));
        obj.BigIntData = argument;
        return obj;
      }

    case 'Object':
      return argument;

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('ToObject', {
        type,
        argument
      });
  }
} // 7.1.14 #sec-topropertykey

function ToPropertyKey(argument) {
  let _temp22 = ToPrimitive(argument, 'String');

  if (_temp22 instanceof AbruptCompletion) {
    return _temp22;
  }

  if (_temp22 instanceof Completion) {
    _temp22 = _temp22.Value;
  }

  const key = _temp22;

  if (Type(key) === 'Symbol') {
    return key;
  }

  let _temp23 = ToString(key);

  Assert(!(_temp23 instanceof AbruptCompletion), "ToString(key)" + ' returned an abrupt completion');

  if (_temp23 instanceof Completion) {
    _temp23 = _temp23.Value;
  }

  return _temp23;
} // 7.1.15 #sec-tolength

function ToLength(argument) {
  let _temp24 = ToInteger(argument);

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  const len = _temp24;

  if (len.numberValue() <= 0) {
    return new Value(0);
  }

  return new Value(Math.min(len.numberValue(), 2 ** 53 - 1));
} // 7.1.16 #sec-canonicalnumericindexstring

function CanonicalNumericIndexString(argument) {
  Assert(Type(argument) === 'String', "Type(argument) === 'String'");

  if (argument.stringValue() === '-0') {
    return new Value(-0);
  }

  let _temp25 = ToNumber(argument);

  Assert(!(_temp25 instanceof AbruptCompletion), "ToNumber(argument)" + ' returned an abrupt completion');

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }

  const n = _temp25;

  let _temp26 = ToString(n);

  Assert(!(_temp26 instanceof AbruptCompletion), "ToString(n)" + ' returned an abrupt completion');

  if (_temp26 instanceof Completion) {
    _temp26 = _temp26.Value;
  }

  if (SameValue(_temp26, argument) === Value.false) {
    return Value.undefined;
  }

  return n;
} // 7.1.17 #sec-toindex

function ToIndex(value) {
  let index;

  if (Type(value) === 'Undefined') {
    index = new Value(0);
  } else {
    let _temp27 = ToInteger(value);

    if (_temp27 instanceof AbruptCompletion) {
      return _temp27;
    }

    if (_temp27 instanceof Completion) {
      _temp27 = _temp27.Value;
    }

    const integerIndex = _temp27;

    if (integerIndex.numberValue() < 0) {
      return surroundingAgent.Throw('RangeError', 'NegativeIndex', 'Index');
    }

    let _temp28 = ToLength(integerIndex);

    Assert(!(_temp28 instanceof AbruptCompletion), "ToLength(integerIndex)" + ' returned an abrupt completion');

    if (_temp28 instanceof Completion) {
      _temp28 = _temp28.Value;
    }

    index = _temp28;

    if (SameValueZero(integerIndex, index) === Value.false) {
      return surroundingAgent.Throw('RangeError', 'OutOfRange', 'Index');
    }
  }

  return index;
}

const typedArrayInfo = new Map([['Int8Array', {
  Intrinsic: '%Int8Array%',
  ElementType: 'Int8',
  ElementSize: 1,
  ConversionOperation: ToInt8
}], ['Uint8Array', {
  Intrinsic: '%Uint8Array%',
  ElementType: 'Uint8',
  ElementSize: 1,
  ConversionOperation: ToUint8
}], ['Uint8ClampedArray', {
  Intrinsic: '%Uint8ClampedArray%',
  ElementType: 'Uint8C',
  ElementSize: 1,
  ConversionOperation: ToUint8Clamp
}], ['Int16Array', {
  Intrinsic: '%Int16Array%',
  ElementType: 'Int16',
  ElementSize: 2,
  ConversionOperation: ToInt16
}], ['Uint16Array', {
  Intrinsic: '%Uint16Array%',
  ElementType: 'Uint16',
  ElementSize: 2,
  ConversionOperation: ToUint16
}], ['Int32Array', {
  Intrinsic: '%Int32Array%',
  ElementType: 'Int32',
  ElementSize: 4,
  ConversionOperation: ToInt32
}], ['Uint32Array', {
  Intrinsic: '%Uint32Array%',
  ElementType: 'Uint32',
  ElementSize: 4,
  ConversionOperation: ToUint32
}], ['Float32Array', {
  Intrinsic: '%Float32Array%',
  ElementType: 'Float32',
  ElementSize: 4
}], ['Float64Array', {
  Intrinsic: '%Float64Array%',
  ElementType: 'Float64',
  ElementSize: 8
}]]);
const numericTypeInfo = new Map([...typedArrayInfo.values()].map(info => [info.ElementType, info])); // 22.2.2.1.1 #sec-iterabletolist

function IterableToList(items, method) {
  let _temp = GetIterator(items, 'sync', method);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const iteratorRecord = _temp;
  const values = [];
  let next = Value.true;

  while (next !== Value.false) {
    let _temp2 = IteratorStep(iteratorRecord);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    next = _temp2;

    if (next !== Value.false) {
      let _temp3 = IteratorValue(next);

      if (_temp3 instanceof AbruptCompletion) {
        return _temp3;
      }

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      const nextValue = _temp3;
      values.push(nextValue);
    }
  }

  return values;
} // 22.2.3.5.1 #sec-validatetypedarray

function ValidateTypedArray(O) {
  let _temp4 = RequireInternalSlot(O, 'TypedArrayName');

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  return buffer;
} // 22.2.4.2.1 #sec-allocatetypedarray

function AllocateTypedArray(constructorName, newTarget, defaultProto, length) {
  let _temp5 = GetPrototypeFromConstructor(newTarget, defaultProto);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const proto = _temp5;
  const obj = IntegerIndexedObjectCreate(proto, ['ViewedArrayBuffer', 'TypedArrayName', 'ByteLength', 'ByteOffset', 'ArrayLength']);
  Assert(obj.ViewedArrayBuffer === Value.undefined, "obj.ViewedArrayBuffer === Value.undefined");
  obj.TypedArrayName = constructorName;

  if (length === undefined) {
    obj.ByteLength = new Value(0);
    obj.ByteOffset = new Value(0);
    obj.ArrayLength = new Value(0);
  } else {
    let _temp6 = AllocateTypedArrayBuffer(obj, length);

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
  }

  return obj;
} // 22.2.4.2.2 #sec-allocatetypedarraybuffer

function AllocateTypedArrayBuffer(O, length) {
  Assert(Type(O) === 'Object' && 'ViewedArrayBuffer' in O, "Type(O) === 'Object' && 'ViewedArrayBuffer' in O");
  Assert(O.ViewedArrayBuffer === Value.undefined, "O.ViewedArrayBuffer === Value.undefined");
  Assert(length.numberValue() >= 0, "length.numberValue() >= 0");
  const constructorName = O.TypedArrayName.stringValue();
  const elementSize = typedArrayInfo.get(constructorName).ElementSize;
  const byteLength = new Value(elementSize * length.numberValue());

  let _temp7 = AllocateArrayBuffer(surroundingAgent.intrinsic('%ArrayBuffer%'), byteLength);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const data = _temp7;
  O.ViewedArrayBuffer = data;
  O.ByteLength = byteLength;
  O.ByteOffset = new Value(0);
  O.ArrayLength = length;
  return O;
} // 22.2.4.6 #typedarray-create

function TypedArrayCreate(constructor, argumentList) {
  let _temp8 = Construct(constructor, argumentList);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const newTypedArray = _temp8;

  let _temp9 = ValidateTypedArray(newTypedArray);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  if (argumentList.length === 1 && Type(argumentList[0]) === 'Number') {
    if (newTypedArray.ArrayLength.numberValue() < argumentList[0].numberValue()) {
      return surroundingAgent.Throw('TypeError', 'TypedArrayTooSmall');
    }
  }

  return newTypedArray;
} // 22.2.4.7 #typedarray-species-create

function TypedArraySpeciesCreate(exemplar, argumentList) {
  Assert(Type(exemplar) === 'Object' && 'TypedArrayName' in exemplar, "Type(exemplar) === 'Object' && 'TypedArrayName' in exemplar");
  const intrinsicName = typedArrayInfo.get(exemplar.TypedArrayName.stringValue()).Intrinsic;
  const defaultConstructor = surroundingAgent.intrinsic(intrinsicName);

  let _temp10 = SpeciesConstructor(exemplar, defaultConstructor);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const constructor = _temp10;
  return TypedArrayCreate(constructor, argumentList);
}



var AbstractOps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CreateUnmappedArgumentsObject: CreateUnmappedArgumentsObject,
  CreateMappedArgumentsObject: CreateMappedArgumentsObject,
  ArrayCreate: ArrayCreate,
  ArraySpeciesCreate: ArraySpeciesCreate,
  ArraySetLength: ArraySetLength,
  IsConcatSpreadable: IsConcatSpreadable,
  SortCompare: SortCompare,
  CreateArrayIterator: CreateArrayIterator,
  AllocateArrayBuffer: AllocateArrayBuffer,
  IsDetachedBuffer: IsDetachedBuffer,
  DetachArrayBuffer: DetachArrayBuffer,
  CloneArrayBuffer: CloneArrayBuffer,
  RawBytesToNumber: RawBytesToNumber,
  GetValueFromBuffer: GetValueFromBuffer,
  NumberToRawBytes: NumberToRawBytes,
  SetValueInBuffer: SetValueInBuffer,
  IsSharedArrayBuffer: IsSharedArrayBuffer,
  AsyncBlockStart: AsyncBlockStart,
  AsyncFunctionStart: AsyncFunctionStart,
  AsyncGeneratorStart: AsyncGeneratorStart,
  AsyncGeneratorEnqueue: AsyncGeneratorEnqueue,
  AsyncGeneratorYield: AsyncGeneratorYield,
  isLeadingSurrogate: isLeadingSurrogate,
  isTrailingSurrogate: isTrailingSurrogate,
  isIntegerIndex: isIntegerIndex,
  isArrayIndex: isArrayIndex,
  GetViewValue: GetViewValue,
  SetViewValue: SetViewValue,
  Day: Day,
  msPerDay: msPerDay,
  TimeWithinDay: TimeWithinDay,
  DaysInYear: DaysInYear,
  DayFromYear: DayFromYear,
  TimeFromYear: TimeFromYear,
  msPerAverageYear: msPerAverageYear,
  YearFromTime: YearFromTime,
  InLeapYear: InLeapYear,
  MonthFromTime: MonthFromTime,
  DayWithinYear: DayWithinYear,
  DateFromTime: DateFromTime,
  WeekDay: WeekDay,
  LocalTZA: LocalTZA,
  LocalTime: LocalTime,
  UTC: UTC,
  HourFromTime: HourFromTime,
  MinFromTime: MinFromTime,
  SecFromTime: SecFromTime,
  msFromTime: msFromTime,
  HoursPerDay: HoursPerDay,
  MinutesPerHour: MinutesPerHour,
  SecondsPerMinute: SecondsPerMinute,
  msPerSecond: msPerSecond,
  msPerMinute: msPerMinute,
  msPerHour: msPerHour,
  MakeTime: MakeTime,
  MakeDay: MakeDay,
  MakeDate: MakeDate,
  TimeClip: TimeClip,
  GetActiveScriptOrModule: GetActiveScriptOrModule,
  ResolveBinding: ResolveBinding,
  GetThisEnvironment: GetThisEnvironment,
  ResolveThisBinding: ResolveThisBinding,
  GetNewTarget: GetNewTarget,
  GetGlobalObject: GetGlobalObject,
  OrdinaryCallEvaluateBody: OrdinaryCallEvaluateBody,
  OrdinaryFunctionCreate: OrdinaryFunctionCreate,
  MakeConstructor: MakeConstructor,
  MakeClassConstructor: MakeClassConstructor,
  MakeMethod: MakeMethod,
  SetFunctionName: SetFunctionName,
  SetFunctionLength: SetFunctionLength,
  CreateBuiltinFunction: CreateBuiltinFunction,
  PrepareForTailCall: PrepareForTailCall,
  GeneratorStart: GeneratorStart,
  GeneratorValidate: GeneratorValidate,
  GeneratorResume: GeneratorResume,
  GeneratorResumeAbrupt: GeneratorResumeAbrupt,
  GetGeneratorKind: GetGeneratorKind,
  GeneratorYield: GeneratorYield,
  PerformEval: PerformEval,
  GetIterator: GetIterator,
  IteratorNext: IteratorNext,
  IteratorComplete: IteratorComplete,
  IteratorValue: IteratorValue,
  IteratorStep: IteratorStep,
  IteratorClose: IteratorClose,
  AsyncIteratorClose: AsyncIteratorClose,
  CreateIterResultObject: CreateIterResultObject,
  CreateListIteratorRecord: CreateListIteratorRecord,
  CreateAsyncFromSyncIterator: CreateAsyncFromSyncIterator,
  AsyncFromSyncIteratorContinuation: AsyncFromSyncIteratorContinuation,
  ModuleNamespaceCreate: ModuleNamespaceCreate,
  InnerModuleLinking: InnerModuleLinking,
  InnerModuleEvaluation: InnerModuleEvaluation,
  GetAsyncCycleRoot: GetAsyncCycleRoot,
  GetModuleNamespace: GetModuleNamespace,
  Assert: Assert,
  RequireInternalSlot: RequireInternalSlot,
  sourceTextMatchedBy: sourceTextMatchedBy,
  isStrictModeCode: isStrictModeCode,
  Get: Get,
  GetV: GetV,
  Set: Set$1,
  CreateDataProperty: CreateDataProperty,
  CreateMethodProperty: CreateMethodProperty,
  CreateDataPropertyOrThrow: CreateDataPropertyOrThrow,
  DefinePropertyOrThrow: DefinePropertyOrThrow,
  DeletePropertyOrThrow: DeletePropertyOrThrow,
  GetMethod: GetMethod,
  HasProperty: HasProperty,
  HasOwnProperty: HasOwnProperty$1,
  Call: Call,
  Construct: Construct,
  SetIntegrityLevel: SetIntegrityLevel,
  TestIntegrityLevel: TestIntegrityLevel,
  CreateArrayFromList: CreateArrayFromList,
  LengthOfArrayLike: LengthOfArrayLike,
  CreateListFromArrayLike: CreateListFromArrayLike,
  Invoke: Invoke,
  OrdinaryHasInstance: OrdinaryHasInstance,
  SpeciesConstructor: SpeciesConstructor,
  EnumerableOwnPropertyNames: EnumerableOwnPropertyNames,
  GetFunctionRealm: GetFunctionRealm,
  CopyDataProperties: CopyDataProperties,
  OrdinaryGetPrototypeOf: OrdinaryGetPrototypeOf,
  OrdinarySetPrototypeOf: OrdinarySetPrototypeOf,
  OrdinaryIsExtensible: OrdinaryIsExtensible,
  OrdinaryPreventExtensions: OrdinaryPreventExtensions,
  OrdinaryGetOwnProperty: OrdinaryGetOwnProperty,
  OrdinaryDefineOwnProperty: OrdinaryDefineOwnProperty,
  IsCompatiblePropertyDescriptor: IsCompatiblePropertyDescriptor,
  ValidateAndApplyPropertyDescriptor: ValidateAndApplyPropertyDescriptor,
  OrdinaryHasProperty: OrdinaryHasProperty,
  OrdinaryGet: OrdinaryGet,
  OrdinarySet: OrdinarySet,
  OrdinarySetWithOwnDescriptor: OrdinarySetWithOwnDescriptor,
  OrdinaryDelete: OrdinaryDelete,
  OrdinaryOwnPropertyKeys: OrdinaryOwnPropertyKeys,
  ObjectCreate: ObjectCreate,
  OrdinaryCreateFromConstructor: OrdinaryCreateFromConstructor,
  GetPrototypeFromConstructor: GetPrototypeFromConstructor,
  IntegerIndexedObjectCreate: IntegerIndexedObjectCreate,
  IntegerIndexedElementGet: IntegerIndexedElementGet,
  IntegerIndexedElementSet: IntegerIndexedElementSet,
  PromiseCapabilityRecord: PromiseCapabilityRecord,
  PromiseReactionRecord: PromiseReactionRecord,
  CreateResolvingFunctions: CreateResolvingFunctions,
  NewPromiseCapability: NewPromiseCapability,
  IsPromise: IsPromise,
  PromiseReactionJob: PromiseReactionJob,
  PromiseResolve: PromiseResolve,
  PerformPromiseThen: PerformPromiseThen,
  GetBase: GetBase,
  GetReferencedName: GetReferencedName,
  IsStrictReference: IsStrictReference,
  HasPrimitiveBase: HasPrimitiveBase,
  IsPropertyReference: IsPropertyReference,
  IsUnresolvableReference: IsUnresolvableReference,
  IsSuperReference: IsSuperReference,
  GetValue: GetValue,
  PutValue: PutValue,
  GetThisValue: GetThisValue,
  InitializeReferencedBinding: InitializeReferencedBinding,
  RegExpAlloc: RegExpAlloc,
  RegExpInitialize: RegExpInitialize,
  RegExpCreate: RegExpCreate,
  EscapeRegExpPattern: EscapeRegExpPattern,
  UTF16Encoding: UTF16Encoding,
  UTF16Decode: UTF16Decode,
  CodePointAt: CodePointAt,
  IsAccessorDescriptor: IsAccessorDescriptor,
  IsDataDescriptor: IsDataDescriptor,
  IsGenericDescriptor: IsGenericDescriptor,
  FromPropertyDescriptor: FromPropertyDescriptor,
  ToPropertyDescriptor: ToPropertyDescriptor,
  CompletePropertyDescriptor: CompletePropertyDescriptor,
  CreateByteDataBlock: CreateByteDataBlock,
  CopyDataBlockBytes: CopyDataBlockBytes,
  StringCreate: StringCreate,
  StringGetOwnProperty: StringGetOwnProperty,
  SymbolDescriptiveString: SymbolDescriptiveString,
  RequireObjectCoercible: RequireObjectCoercible,
  IsArray: IsArray,
  IsCallable: IsCallable,
  IsConstructor: IsConstructor,
  IsExtensible: IsExtensible,
  IsInteger: IsInteger,
  IsPropertyKey: IsPropertyKey,
  IsRegExp: IsRegExp,
  IsStringPrefix: IsStringPrefix,
  SameValue: SameValue,
  SameValueZero: SameValueZero,
  SameValueNonNumber: SameValueNonNumber,
  AbstractRelationalComparison: AbstractRelationalComparison,
  AbstractEqualityComparison: AbstractEqualityComparison,
  StrictEqualityComparison: StrictEqualityComparison,
  IsValidIntegerIndex: IsValidIntegerIndex,
  ToPrimitive: ToPrimitive,
  OrdinaryToPrimitive: OrdinaryToPrimitive,
  ToBoolean: ToBoolean,
  ToNumeric: ToNumeric,
  ToNumber: ToNumber,
  ToInteger: ToInteger,
  ToInt32: ToInt32,
  ToUint32: ToUint32,
  ToInt16: ToInt16,
  ToUint16: ToUint16,
  ToInt8: ToInt8,
  ToUint8: ToUint8,
  ToUint8Clamp: ToUint8Clamp,
  ToBigInt: ToBigInt,
  StringToBigInt: StringToBigInt,
  ToBigInt64: ToBigInt64,
  ToBigUint64: ToBigUint64,
  ToString: ToString,
  ToObject: ToObject,
  ToPropertyKey: ToPropertyKey,
  ToLength: ToLength,
  CanonicalNumericIndexString: CanonicalNumericIndexString,
  ToIndex: ToIndex,
  typedArrayInfo: typedArrayInfo,
  numericTypeInfo: numericTypeInfo,
  IterableToList: IterableToList,
  ValidateTypedArray: ValidateTypedArray,
  AllocateTypedArray: AllocateTypedArray,
  AllocateTypedArrayBuffer: AllocateTypedArrayBuffer,
  TypedArrayCreate: TypedArrayCreate,
  TypedArraySpeciesCreate: TypedArraySpeciesCreate
});

function Value(value) {
  if (new.target !== undefined && new.target !== Value) {
    return undefined;
  }

  switch (typeof value) {
    case 'string':
      return new StringValue(value);

    case 'number':
      return new NumberValue(value);

    case 'bigint':
      return new BigIntValue(value);

    case 'function':
      return new BuiltinFunctionValue(value);

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('new Value', value);
  }
}
class PrimitiveValue extends Value {}
class UndefinedValue extends PrimitiveValue {}
class NullValue extends PrimitiveValue {}
class BooleanValue extends PrimitiveValue {
  constructor(v) {
    super();
    this.boolean = v;
  }

  booleanValue() {
    return this.boolean;
  }

  [Symbol.for('nodejs.util.inspect.custom')]() {
    return `Boolean { ${this.boolean} }`;
  }

}
Object.defineProperties(Value, {
  undefined: {
    value: new UndefinedValue(),
    configurable: false,
    writable: false
  },
  null: {
    value: new NullValue(),
    configurable: false,
    writable: false
  },
  true: {
    value: new BooleanValue(true),
    configurable: false,
    writable: false
  },
  false: {
    value: new BooleanValue(false),
    configurable: false,
    writable: false
  }
});
class NumberValue extends PrimitiveValue {
  constructor(number) {
    super();
    this.number = number;
  }

  numberValue() {
    return this.number;
  }

  isNaN() {
    return Number.isNaN(this.number);
  }

  isInfinity() {
    return !Number.isFinite(this.number) && !this.isNaN();
  }

  isFinite() {
    return Number.isFinite(this.number);
  } // #sec-numeric-types-number-unaryMinus


  static unaryMinus(x) {
    if (x.isNaN()) {
      return new Value(NaN);
    }

    return new Value(-x.numberValue());
  } // #sec-numeric-types-number-bitwiseNOT


  static bitwiseNOT(x) {
    let _temp = ToInt32(x);

    Assert(!(_temp instanceof AbruptCompletion), "ToInt32(x)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    // 1. Let oldValue be ! ToInt32(x).
    const oldValue = _temp; // 2. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.

    return new Value(~oldValue.numberValue()); // eslint-disable-line no-bitwise
  } // #sec-numeric-types-number-exponentiate


  static exponentiate(base, exponent) {
    return new Value(base.numberValue() ** exponent.numberValue());
  } // #sec-numeric-types-number-multiply


  static multiply(x, y) {
    return new Value(x.numberValue() * y.numberValue());
  } // #sec-numeric-types-number-divide


  static divide(x, y) {
    return new Value(x.numberValue() / y.numberValue());
  } // #sec-numeric-types-number-remainder


  static remainder(n, d) {
    return new Value(n.numberValue() % d.numberValue());
  } // #sec-numeric-types-number-add


  static add(x, y) {
    return new Value(x.numberValue() + y.numberValue());
  } // #sec-numeric-types-number-subtract


  static subtract(x, y) {
    // The result of - operator is x + (-y).
    return NumberValue.add(x, new Value(-y.numberValue()));
  } // #sec-numeric-types-number-leftShift


  static leftShift(x, y) {
    let _temp2 = ToInt32(x);

    Assert(!(_temp2 instanceof AbruptCompletion), "ToInt32(x)" + ' returned an abrupt completion');

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    // 1. Let lnum be ! ToInt32(x).
    const lnum = _temp2; // 2. Let rnum be ! ToUint32(y).

    let _temp3 = ToUint32(y);

    Assert(!(_temp3 instanceof AbruptCompletion), "ToUint32(y)" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const rnum = _temp3; // 3. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.

    const shiftCount = rnum.numberValue() & 0x1F; // eslint-disable-line no-bitwise
    // 4. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.

    return new Value(lnum.numberValue() << shiftCount); // eslint-disable-line no-bitwise
  } // #sec-numeric-types-number-signedRightShift


  static signedRightShift(x, y) {
    let _temp4 = ToInt32(x);

    Assert(!(_temp4 instanceof AbruptCompletion), "ToInt32(x)" + ' returned an abrupt completion');

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    // 1. Let lnum be ! ToInt32(x).
    const lnum = _temp4; // 2. Let rnum be ! ToUint32(y).

    let _temp5 = ToUint32(y);

    Assert(!(_temp5 instanceof AbruptCompletion), "ToUint32(y)" + ' returned an abrupt completion');

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const rnum = _temp5; // 3. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.

    const shiftCount = rnum.numberValue() & 0x1F; // eslint-disable-line no-bitwise
    // 4. Return the result of performing a sign-extending right shift of lnum by shiftCount bits.
    //    The most significant bit is propagated. The result is a signed 32-bit integer.

    return new Value(lnum.numberValue() >> shiftCount); // eslint-disable-line no-bitwise
  } // #sec-numeric-types-number-unsignedRightShift


  static unsignedRightShift(x, y) {
    let _temp6 = ToInt32(x);

    Assert(!(_temp6 instanceof AbruptCompletion), "ToInt32(x)" + ' returned an abrupt completion');

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    // 1. Let lnum be ! ToInt32(x).
    const lnum = _temp6; // 2. Let rnum be ! ToUint32(y).

    let _temp7 = ToUint32(y);

    Assert(!(_temp7 instanceof AbruptCompletion), "ToUint32(y)" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    const rnum = _temp7; // 3. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.

    const shiftCount = rnum.numberValue() & 0x1F; // eslint-disable-line no-bitwise
    // 4. Return the result of performing a zero-filling right shift of lnum by shiftCount bits.
    //    Vacated bits are filled with zero. The result is an unsigned 32-bit integer.

    return new Value(lnum.numberValue() >>> shiftCount); // eslint-disable-line no-bitwise
  } // #sec-numeric-types-number-lessThan


  static lessThan(x, y) {
    if (x.isNaN()) {
      return Value.undefined;
    }

    if (y.isNaN()) {
      return Value.undefined;
    } // If nx and ny are the same Number value, return false.
    // If nx is +0 and ny is -0, return false.
    // If nx is -0 and ny is +0, return false.


    if (x.numberValue() === y.numberValue()) {
      return Value.false;
    }

    if (x.numberValue() === +Infinity) {
      return Value.false;
    }

    if (y.numberValue() === +Infinity) {
      return Value.true;
    }

    if (y.numberValue() === -Infinity) {
      return Value.false;
    }

    if (x.numberValue() === -Infinity) {
      return Value.true;
    }

    return x.numberValue() < y.numberValue() ? Value.true : Value.false;
  } // #sec-numeric-types-number-equal


  static equal(x, y) {
    if (x.isNaN()) {
      return Value.false;
    }

    if (y.isNaN()) {
      return Value.false;
    }

    const xVal = x.numberValue();
    const yVal = y.numberValue();

    if (xVal === yVal) {
      return Value.true;
    }

    if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
      return Value.true;
    }

    if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
      return Value.true;
    }

    return Value.false;
  } // #sec-numeric-types-number-sameValue


  static sameValue(x, y) {
    if (x.isNaN() && y.isNaN()) {
      return Value.true;
    }

    const xVal = x.numberValue();
    const yVal = y.numberValue();

    if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
      return Value.false;
    }

    if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
      return Value.false;
    }

    if (xVal === yVal) {
      return Value.true;
    }

    return Value.false;
  } // #sec-numeric-types-number-sameValueZero


  static sameValueZero(x, y) {
    if (x.isNaN() && y.isNaN()) {
      return Value.true;
    }

    const xVal = x.numberValue();
    const yVal = y.numberValue();

    if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
      return Value.true;
    }

    if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
      return Value.true;
    }

    if (xVal === yVal) {
      return Value.true;
    }

    return Value.false;
  } // #sec-numeric-types-number-bitwiseAND


  static bitwiseAND(x, y) {
    return NumberBitwiseOp('&', x, y);
  } // #sec-numeric-types-number-bitwiseXOR


  static bitwiseXOR(x, y) {
    return NumberBitwiseOp('^', x, y);
  } // #sec-numeric-types-number-bitwiseOR


  static bitwiseOR(x, y) {
    return NumberBitwiseOp('|', x, y);
  } // #sec-numeric-types-number-tostring


  static toString(x) {
    if (x.isNaN()) {
      return new Value('NaN');
    }

    const xVal = x.numberValue();

    if (xVal === 0) {
      return new Value('0');
    }

    if (xVal < 0) {
      let _temp8 = NumberValue.toString(new Value(-xVal));

      Assert(!(_temp8 instanceof AbruptCompletion), "NumberValue.toString(new Value(-xVal))" + ' returned an abrupt completion');

      if (_temp8 instanceof Completion) {
        _temp8 = _temp8.Value;
      }

      const str = _temp8.stringValue();

      return new Value(`-${str}`);
    }

    if (x.isInfinity()) {
      return new Value('Infinity');
    } // TODO: implement properly


    return new Value(`${xVal}`);
  }

}
NumberValue.unit = new NumberValue(1); // #sec-numberbitwiseop

function NumberBitwiseOp(op, x, y) {
  let _temp9 = ToInt32(x);

  Assert(!(_temp9 instanceof AbruptCompletion), "ToInt32(x)" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  // 1. Let lnum be ! ToInt32(x).
  const lnum = _temp9; // 2. Let rnum be ! ToUint32(y).

  let _temp10 = ToUint32(y);

  Assert(!(_temp10 instanceof AbruptCompletion), "ToUint32(y)" + ' returned an abrupt completion');

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const rnum = _temp10; // 3. Return the result of applying the bitwise operator op to lnum and rnum. The result is a signed 32-bit integer.

  switch (op) {
    case '&':
      return new Value(lnum.numberValue() & rnum.numberValue());
    // eslint-disable-line no-bitwise

    case '|':
      return new Value(lnum.numberValue() | rnum.numberValue());
    // eslint-disable-line no-bitwise

    case '^':
      return new Value(lnum.numberValue() ^ rnum.numberValue());
    // eslint-disable-line no-bitwise

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('NumberBitwiseOp', op);
  }
}

class BigIntValue extends PrimitiveValue {
  constructor(bigint) {
    super();
    this.bigint = bigint;
  }

  bigintValue() {
    return this.bigint;
  } // #sec-numeric-types-bigint-unaryMinus


  static unaryMinus(x) {
    if (x.bigintValue() === 0n) {
      return new Value(0n);
    }

    return new Value(-x.bigintValue());
  } // #sec-numeric-types-bigint-bitwiseNOT


  static bitwiseNOT(x) {
    return new Value(-x.bigintValue() - 1n);
  } // #sec-numeric-types-bigint-exponentiate


  static exponentiate(base, exponent) {
    // 1. If exponent < 0n, throw a RangeError exception.
    if (exponent.bigintValue() < 0n) {
      return surroundingAgent.Throw('RangeError', 'BigIntNegativeExponent');
    } // 2. If base is 0n and exponent is 0n, return 1n.


    if (base.bigintValue() === 0n && exponent.bigintValue() === 0n) {
      return new Value(1n);
    } // 3. Return the BigInt value that represents the mathematical value of base raised to the power exponent.


    return new Value(base.bigintValue() ** exponent.bigintValue());
  } // #sec-numeric-types-bigint-multiply


  static multiply(x, y) {
    return new Value(x.bigintValue() * y.bigintValue());
  } // #sec-numeric-types-bigint-divide


  static divide(x, y) {
    // 1. If y is 0n, throw a RangeError exception.
    if (y.bigintValue() === 0n) {
      return surroundingAgent.Throw('RangeError', 'BigIntDivideByZero');
    } // 2. Let quotient be the mathematical value of x divided by y.


    const quotient = x.bigintValue() / y.bigintValue(); // 3. Return the BigInt value that represents quotient rounded towards 0 to the next integral value.

    return new Value(quotient);
  } // #sec-numeric-types-bigint-remainder


  static remainder(n, d) {
    // 1. If d is 0n, throw a RangeError exception.
    if (d.bigintValue() === 0n) {
      return surroundingAgent.Throw('RangeError', 'BigIntDivideByZero');
    } // 2. If n is 0n, return 0n.


    if (n.bigintValue() === 0n) {
      return new Value(0n);
    } // 3. Let r be the BigInt defined by the mathematical relation r = n - (d  q)
    //   where q is a BigInt that is negative only if n/d is negative and positive
    //   only if n/d is positive, and whose magnitude is as large as possible without
    //   exceeding the magnitude of the true mathematical quotient of n and d.


    const r = new Value(n.bigintValue() % d.bigintValue()); // 4. Return r.

    return r;
  } // #sec-numeric-types-bigint-add


  static add(x, y) {
    return new Value(x.bigintValue() + y.bigintValue());
  } // #sec-numeric-types-bigint-subtract


  static subtract(x, y) {
    return new Value(x.bigintValue() - y.bigintValue());
  } // #sec-numeric-types-bigint-leftShift


  static leftShift(x, y) {
    return new Value(x.bigintValue() << y.bigintValue()); // eslint-disable-line no-bitwise
  } // #sec-numeric-types-bigint-signedRightShift


  static signedRightShift(x, y) {
    // 1. Return BigInt::leftShift(x, -y).
    return BigIntValue.leftShift(x, new Value(-y.bigintValue()));
  } // #sec-numeric-types-bigint-unsighedRightShift


  static unsignedRightShift(_x, _y) {
    return surroundingAgent.Throw('TypeError', 'BigIntUnsignedRightShift');
  } // #sec-numeric-types-bigint-lessThan


  static lessThan(x, y) {
    return x.bigintValue() < y.bigintValue() ? Value.true : Value.false;
  } // #sec-numeric-types-bigint-equal


  static equal(x, y) {
    // Return true if x and y have the same mathematical integer value and false otherwise.
    return x.bigintValue() === y.bigintValue() ? Value.true : Value.false;
  } // #sec-numeric-types-bigint-sameValue


  static sameValue(x, y) {
    // 1. Return BigInt::equal(x, y).
    return BigIntValue.equal(x, y);
  } // #sec-numeric-types-bigint-sameValueZero


  static sameValueZero(x, y) {
    // 1. Return BigInt::equal(x, y).
    return BigIntValue.equal(x, y);
  } // #sec-numeric-types-bigint-bitwiseAND


  static bitwiseAND(x, y) {
    // 1. Return BigIntBitwiseOp("&", x, y).
    return BigIntBitwiseOp('&', x.bigintValue(), y.bigintValue());
  } // #sec-numeric-types-bigint-bitwiseXOR


  static bitwiseXOR(x, y) {
    // 1. Return BigIntBitwiseOp("^", x, y).
    return BigIntBitwiseOp('^', x.bigintValue(), y.bigintValue());
  } // #sec-numeric-types-bigint-bitwiseOR


  static bitwiseOR(x, y) {
    // 1. Return BigIntBitwiseOp("|", x, y);
    return BigIntBitwiseOp('|', x.bigintValue(), y.bigintValue());
  } // #sec-numeric-types-bigint-tostring


  static toString(x) {
    // 1. If x is less than zero, return the string-concatenation of the String "-" and ! BigInt::toString(-x).
    if (x.bigintValue() < 0n) {
      let _temp11 = BigIntValue.toString(new Value(-x.bigintValue()));

      Assert(!(_temp11 instanceof AbruptCompletion), "BigIntValue.toString(new Value(-x.bigintValue()))" + ' returned an abrupt completion');

      if (_temp11 instanceof Completion) {
        _temp11 = _temp11.Value;
      }

      const str = _temp11.stringValue();

      return new Value(`-${str}`);
    } // 2. Return the String value consisting of the code units of the digits of the decimal representation of x.


    return new Value(`${x.bigintValue()}`);
  }

}
BigIntValue.unit = new BigIntValue(1n);
/*
// #sec-binaryand
function BinaryAnd(x, y) {
  // 1. Assert: x is 0 or 1.
  Assert(x === 0n || x === 1n);
  // 2. Assert: y is 0 or 1.
  Assert(x === 0n || x === 1n);
  // 3. If x is 1 and y is 1, return 1.
  if (x === 1n && y === 1n) {
    return 1n;
  } else {
    // 4. Else, return 0.
    return 0n;
  }
}

// #sec-binaryor
function BinaryOr(x, y) {
  // 1. Assert: x is 0 or 1.
  Assert(x === 0n || x === 1n);
  // 2. Assert: y is 0 or 1.
  Assert(x === 0n || x === 1n);
  // 3. If x is 1 or y is 1, return 1.
  if (x === 1n || y === 1n) {
    return 1n;
  } else {
    // 4. Else, return 0.
    return 0n;
  }
}

// #sec-binaryxor
function BinaryXor(x, y) {
  // 1. Assert: x is 0 or 1.
  Assert(x === 0n || x === 1n);
  // 2. Assert: y is 0 or 1.
  Assert(x === 0n || x === 1n);
  // 3. If x is 1 and y is 0, return 1.
  if (x === 1n && y === 0n) {
    return 1n;
  } else if (x === 0n && y === 1n) {
    // Else if x is 0 and y is 1, return 1.
    return 1n;
  } else {
    // 4. Else, return 0.
    return 0n;
  }
}
*/
// #sec-bigintbitwiseop

function BigIntBitwiseOp(op, x, y) {
  // TODO: figure out why this doesn't work, probably the modulo.

  /*
  // 1. Assert: op is "&", "|", or "^".
  Assert(['&', '|', '^'].includes(op));
  // 2. Let result be 0n.
  let result = 0n;
  // 3. Let shift be 0.
  let shift = 0n;
  // 4. Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1),
  while (!((x === 0n || x === -1n) && (y === 0n || y === -1n))) {
    // a. Let xDigit be x modulo 2.
    const xDigit = x % 2n;
    // b. Let yDigit be y modulo 2.
    const yDigit = y % 2n;
    // c. If op is "&", set result to result + 2^shift  BinaryAnd(xDigit, yDigit).
    if (op === '&') {
      result += (2n ** shift) * BinaryAnd(xDigit, yDigit);
    } else if (op === '|') {
      // d. Else if op is "|", set result to result + 2shift  BinaryOr(xDigit, yDigit).
      result += (2n ** shift) * BinaryXor(xDigit, yDigit);
    } else {
      // i. Assert: op is "^".
      Assert(op === '^');
      // ii. Set result to result + 2^shift  BinaryXor(xDigit, yDigit).
      result += (2n ** shift) * BinaryXor(xDigit, yDigit);
    }
    // f. Set shift to shift + 1.
    shift += 1n;
    // g. Set x to (x - xDigit) / 2.
    x = (x - xDigit) / 2n;
    // h. Set y to (y - yDigit) / 2.
    y = (y - yDigit) / 2n;
  }
  let tmp;
  // 5. If op is "&", let tmp be BinaryAnd(x modulo 2, y modulo 2).
  if (op === '&') {
    tmp = BinaryAnd(x % 2n, y % 2n);
  } else if (op === '|') {
    // 6. Else if op is "|", let tmp be BinaryOr(x modulo 2, y modulo 2).
    tmp = BinaryOr(x % 2n, y % 2n);
  } else {
    // a. Assert: op is "^".
    Assert(op === '^');
    // b. Let tmp be BinaryXor(x modulo 2, y modulo 2).
    tmp = BinaryXor(x % 2n, y % 2n);
  }
  // 8. If tmp  0, then
  if (tmp !== 0n) {
    // a. Set result to result - 2^shift. NOTE: This extends the sign.
    result -= 2n ** shift;
  }
  // 9. Return result.
  return new Value(result);
  */
  switch (op) {
    case '&':
      return new Value(x & y);
    // eslint-disable-line no-bitwise

    case '|':
      return new Value(x | y);
    // eslint-disable-line no-bitwise

    case '^':
      return new Value(x ^ y);
    // eslint-disable-line no-bitwise

    /*istanbul ignore next*/
    default:
      throw new OutOfRange('BigIntBitwiseOp', op);
  }
}

class StringValue extends PrimitiveValue {
  constructor(string) {
    super();
    this.string = string;
  }

  stringValue() {
    return this.string;
  }

}
class SymbolValue extends PrimitiveValue {
  constructor(Description) {
    super();
    this.Description = Description;
  }

}
const wellKnownSymbols = Object.create(null);

for (const name of ['asyncIterator', 'hasInstance', 'isConcatSpreadable', 'iterator', 'match', 'matchAll', 'replace', 'search', 'species', 'split', 'toPrimitive', 'toStringTag', 'unscopables']) {
  const sym = new SymbolValue(new StringValue(`Symbol.${name}`));
  wellKnownSymbols[name] = sym;
}

Object.freeze(wellKnownSymbols);
class ObjectValue extends Value {
  constructor() {
    super();
    this.Prototype = undefined;
    this.Extensible = undefined;
    this.IsClassPrototype = false;
    this.properties = new ValueMap();
  }

  GetPrototypeOf() {
    return OrdinaryGetPrototypeOf(this);
  }

  SetPrototypeOf(V) {
    return OrdinarySetPrototypeOf(this, V);
  }

  IsExtensible() {
    return OrdinaryIsExtensible(this);
  }

  PreventExtensions() {
    return OrdinaryPreventExtensions(this);
  }

  GetOwnProperty(P) {
    return OrdinaryGetOwnProperty(this, P);
  }

  DefineOwnProperty(P, Desc) {
    return OrdinaryDefineOwnProperty(this, P, Desc);
  }

  HasProperty(P) {
    return OrdinaryHasProperty(this, P);
  }

  Get(P, Receiver) {
    return OrdinaryGet(this, P, Receiver);
  }

  Set(P, V, Receiver) {
    return OrdinarySet(this, P, V, Receiver);
  }

  Delete(P) {
    return OrdinaryDelete(this, P);
  }

  OwnPropertyKeys() {
    return OrdinaryOwnPropertyKeys(this);
  }

}
ObjectValue.prototype.isOrdinary = true;
class ArrayExoticObjectValue extends ObjectValue {
  DefineOwnProperty(P, Desc) {
    const A = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (Type(P) === 'String' && P.stringValue() === 'length') {
      return ArraySetLength(A, Desc);
    } else if (isArrayIndex(P)) {
      const oldLenDesc = OrdinaryGetOwnProperty(A, new Value('length'));
      Assert(Type(oldLenDesc) !== 'Undefined' && !IsAccessorDescriptor(oldLenDesc), "Type(oldLenDesc) !== 'Undefined' && !IsAccessorDescriptor(oldLenDesc)");
      const oldLen = oldLenDesc.Value;

      let _temp12 = ToUint32(P);

      Assert(!(_temp12 instanceof AbruptCompletion), "ToUint32(P)" + ' returned an abrupt completion');

      if (_temp12 instanceof Completion) {
        _temp12 = _temp12.Value;
      }

      const index = _temp12;

      if (index.numberValue() >= oldLen.numberValue() && oldLenDesc.Writable === Value.false) {
        return Value.false;
      }

      let _temp13 = OrdinaryDefineOwnProperty(A, P, Desc);

      Assert(!(_temp13 instanceof AbruptCompletion), "OrdinaryDefineOwnProperty(A, P, Desc)" + ' returned an abrupt completion');

      if (_temp13 instanceof Completion) {
        _temp13 = _temp13.Value;
      }

      const succeeded = _temp13;

      if (succeeded === Value.false) {
        return Value.false;
      }

      if (index.numberValue() >= oldLen.numberValue()) {
        oldLenDesc.Value = new Value(index.numberValue() + 1);
        const succeeded = OrdinaryDefineOwnProperty(A, new Value('length'), oldLenDesc); // eslint-disable-line no-shadow

        Assert(succeeded === Value.true, "succeeded === Value.true");
      }

      return Value.true;
    }

    return OrdinaryDefineOwnProperty(A, P, Desc);
  }

}
ArrayExoticObjectValue.prototype.isOrdinary = false;
class FunctionValue extends ObjectValue {
  static [Symbol.hasInstance](V) {
    return V instanceof ObjectValue && typeof V.Call === 'function';
  }

}

function nativeCall(F, argumentsList, thisArgument, newTarget) {
  return F.nativeFunction(argumentsList, {
    thisValue: thisArgument || Value.undefined,
    NewTarget: newTarget || Value.undefined
  });
}

class BuiltinFunctionValue extends FunctionValue {
  constructor(nativeFunction, isConstructor = Value.false) {
    super();
    this.nativeFunction = nativeFunction;
    this.Realm = undefined;
    this.ScriptOrModule = undefined;

    if (isConstructor === Value.true) {
      this.Construct = function Construct(argumentsList, newTarget) {
        const F = this; // const callerContext = surroundingAgent.runningExecutionContext;
        // If callerContext is not already suspended, suspend callerContext.

        const calleeContext = new ExecutionContext();
        calleeContext.Function = F;
        const calleeRealm = F.Realm;
        calleeContext.Realm = calleeRealm;
        calleeContext.ScriptOrModule = F.ScriptOrModule; // 8. Perform any necessary implementation-defined initialization of calleeContext.

        surroundingAgent.executionContextStack.push(calleeContext);
        const result = nativeCall(F, argumentsList, undefined, newTarget); // Remove calleeContext from the execution context stack and
        // restore callerContext as the running execution context.

        surroundingAgent.executionContextStack.pop(calleeContext);
        return result;
      };
    }
  }

  Call(thisArgument, argumentsList) {
    const F = this; // const callerContext = surroundingAgent.runningExecutionContext;
    // If callerContext is not already suspended, suspend callerContext.

    const calleeContext = new ExecutionContext();
    calleeContext.Function = F;
    const calleeRealm = F.Realm;
    calleeContext.Realm = calleeRealm;
    calleeContext.ScriptOrModule = F.ScriptOrModule; // 8. Perform any necessary implementation-defined initialization of calleeContext.

    surroundingAgent.executionContextStack.push(calleeContext);
    const result = nativeCall(F, argumentsList, thisArgument, Value.undefined); // Remove calleeContext from the execution context stack and
    // restore callerContext as the running execution context.

    surroundingAgent.executionContextStack.pop(calleeContext);
    return result;
  }

}
BuiltinFunctionValue.prototype.isOrdinary = false; // 9.4.3 #sec-string-exotic-objects

class StringExoticObjectValue extends ObjectValue {
  constructor() {
    super();
    this.StringData = undefined;
  }

  GetOwnProperty(P) {
    const S = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const desc = OrdinaryGetOwnProperty(S, P);

    if (Type(desc) !== 'Undefined') {
      return desc;
    }

    let _temp14 = StringGetOwnProperty(S, P);

    Assert(!(_temp14 instanceof AbruptCompletion), "StringGetOwnProperty(S, P)" + ' returned an abrupt completion');

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    return _temp14;
  }

  DefineOwnProperty(P, Desc) {
    const S = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    let _temp15 = StringGetOwnProperty(S, P);

    Assert(!(_temp15 instanceof AbruptCompletion), "StringGetOwnProperty(S, P)" + ' returned an abrupt completion');

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    const stringDesc = _temp15;

    if (Type(stringDesc) !== 'Undefined') {
      const extensible = S.Extensible;

      let _temp16 = IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc);

      Assert(!(_temp16 instanceof AbruptCompletion), "IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc)" + ' returned an abrupt completion');

      if (_temp16 instanceof Completion) {
        _temp16 = _temp16.Value;
      }

      return _temp16;
    }

    let _temp17 = OrdinaryDefineOwnProperty(S, P, Desc);

    Assert(!(_temp17 instanceof AbruptCompletion), "OrdinaryDefineOwnProperty(S, P, Desc)" + ' returned an abrupt completion');

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    return _temp17;
  }

  OwnPropertyKeys() {
    const O = this;
    const keys = [];
    const str = O.StringData;
    Assert(Type(str) === 'String', "Type(str) === 'String'");
    const len = str.stringValue().length;

    for (let i = 0; i < len; i += 1) {
      keys.push(new Value(`${i}`));
    } // For each own property key P of O such that P is an array index and
    // ToInteger(P)  len, in ascending numeric index order, do
    //   Add P as the last element of keys.


    for (const P of O.properties.keys()) {
      // This is written with two nested ifs to work around https://github.com/devsnek/engine262/issues/24
      if (isArrayIndex(P)) {
        let _temp18 = ToInteger(P);

        Assert(!(_temp18 instanceof AbruptCompletion), "ToInteger(P)" + ' returned an abrupt completion');

        if (_temp18 instanceof Completion) {
          _temp18 = _temp18.Value;
        }

        if (_temp18.numberValue() >= len) {
          keys.push(P);
        }
      }
    } // For each own property key P of O such that Type(P) is String and
    // P is not an array index, in ascending chronological order of property creation, do
    //   Add P as the last element of keys.


    for (const P of O.properties.keys()) {
      if (Type(P) === 'String' && isArrayIndex(P) === false) {
        keys.push(P);
      }
    } // For each own property key P of O such that Type(P) is Symbol,
    // in ascending chronological order of property creation, do
    //   Add P as the last element of keys.


    for (const P of O.properties.keys()) {
      if (Type(P) === 'Symbol') {
        keys.push(P);
      }
    }

    return keys;
  }

}
StringExoticObjectValue.prototype.isOrdinary = false; // 9.4.4 #sec-arguments-exotic-objects

class ArgumentsExoticObjectValue extends ObjectValue {
  constructor() {
    super();
    this.ParameterMap = undefined;
  }

  GetOwnProperty(P) {
    const args = this;
    const desc = OrdinaryGetOwnProperty(args, P);

    if (desc === Value.undefined) {
      return desc;
    }

    const map = args.ParameterMap;

    let _temp19 = HasOwnProperty$1(map, P);

    Assert(!(_temp19 instanceof AbruptCompletion), "HasOwnProperty(map, P)" + ' returned an abrupt completion');

    if (_temp19 instanceof Completion) {
      _temp19 = _temp19.Value;
    }

    const isMapped = _temp19;

    if (isMapped === Value.true) {
      desc.Value = Get(map, P);
    }

    return desc;
  }

  DefineOwnProperty(P, Desc) {
    const args = this;
    const map = args.ParameterMap;

    let _temp20 = HasOwnProperty$1(map, P);

    Assert(!(_temp20 instanceof AbruptCompletion), "HasOwnProperty(map, P)" + ' returned an abrupt completion');

    if (_temp20 instanceof Completion) {
      _temp20 = _temp20.Value;
    }

    const isMapped = _temp20;
    let newArgDesc = Desc;

    if (isMapped === Value.true && IsDataDescriptor(Desc) === true) {
      if (Desc.Value === undefined && Desc.Writable !== undefined && Desc.Writable === Value.false) {
        newArgDesc = Descriptor({ ...Desc
        });

        let _temp21 = Get(map, P);

        Assert(!(_temp21 instanceof AbruptCompletion), "Get(map, P)" + ' returned an abrupt completion');

        if (_temp21 instanceof Completion) {
          _temp21 = _temp21.Value;
        }

        newArgDesc.Value = _temp21;
      }
    }

    let _temp22 = OrdinaryDefineOwnProperty(args, P, newArgDesc);
    /* istanbul ignore if */


    if (_temp22 instanceof AbruptCompletion) {
      return _temp22;
    }
    /* istanbul ignore if */


    if (_temp22 instanceof Completion) {
      _temp22 = _temp22.Value;
    }

    const allowed = _temp22;

    if (allowed === Value.false) {
      return Value.false;
    }

    if (isMapped === Value.true) {
      if (IsAccessorDescriptor(Desc) === true) {
        map.Delete(P);
      } else {
        if (Desc.Value !== undefined) {
          const setStatus = Set$1(map, P, Desc.Value, Value.false);
          Assert(setStatus === Value.true, "setStatus === Value.true");
        }

        if (Desc.Writable !== undefined && Desc.Writable === Value.false) {
          map.Delete(P);
        }
      }
    }

    return Value.true;
  }

  Get(P, Receiver) {
    const args = this;
    const map = args.ParameterMap;

    let _temp23 = HasOwnProperty$1(map, P);

    Assert(!(_temp23 instanceof AbruptCompletion), "HasOwnProperty(map, P)" + ' returned an abrupt completion');

    if (_temp23 instanceof Completion) {
      _temp23 = _temp23.Value;
    }

    const isMapped = _temp23;

    if (isMapped === Value.false) {
      return OrdinaryGet(args, P, Receiver);
    } else {
      return Get(map, P);
    }
  }

  Set(P, V, Receiver) {
    const args = this;
    let isMapped;
    let map;

    if (SameValue(args, Receiver) === Value.false) {
      isMapped = false;
    } else {
      map = args.ParameterMap;

      let _temp24 = HasOwnProperty$1(map, P);

      Assert(!(_temp24 instanceof AbruptCompletion), "HasOwnProperty(map, P)" + ' returned an abrupt completion');

      if (_temp24 instanceof Completion) {
        _temp24 = _temp24.Value;
      }

      isMapped = _temp24 === Value.true;
    }

    if (isMapped) {
      const setStatus = Set$1(map, P, V, Value.false);
      Assert(setStatus === Value.true, "setStatus === Value.true");
    }

    return OrdinarySet(args, P, V, Receiver);
  }

  Delete(P) {
    const args = this;
    const map = args.ParameterMap;

    let _temp25 = HasOwnProperty$1(map, P);

    Assert(!(_temp25 instanceof AbruptCompletion), "HasOwnProperty(map, P)" + ' returned an abrupt completion');

    if (_temp25 instanceof Completion) {
      _temp25 = _temp25.Value;
    }

    const isMapped = _temp25;

    let _temp26 = OrdinaryDelete(args, P);

    if (_temp26 instanceof AbruptCompletion) {
      return _temp26;
    }

    if (_temp26 instanceof Completion) {
      _temp26 = _temp26.Value;
    }

    const result = _temp26;

    if (result === Value.true && isMapped === Value.true) {
      map.Delete(P);
    }

    return result;
  }

}
ArgumentsExoticObjectValue.prototype.isOrdinary = false; // 9.4.5 #sec-integer-indexed-exotic-objects

class IntegerIndexedExoticObjectValue extends ObjectValue {
  constructor() {
    super();
    this.ViewedArrayBuffer = Value.undefined;
    this.ArrayLength = Value.undefined;
    this.ByteOffset = Value.undefined;
    this.TypedArrayName = Value.undefined;
  } // 9.4.5.1 #sec-integer-indexed-exotic-objects-getownproperty-p


  GetOwnProperty(P) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    Assert(O instanceof IntegerIndexedExoticObjectValue, "O instanceof IntegerIndexedExoticObjectValue");

    if (Type(P) === 'String') {
      let _temp27 = CanonicalNumericIndexString(P);

      Assert(!(_temp27 instanceof AbruptCompletion), "CanonicalNumericIndexString(P)" + ' returned an abrupt completion');

      if (_temp27 instanceof Completion) {
        _temp27 = _temp27.Value;
      }

      const numericIndex = _temp27;

      if (numericIndex !== Value.undefined) {
        let _temp28 = IntegerIndexedElementGet(O, numericIndex);

        if (_temp28 instanceof AbruptCompletion) {
          return _temp28;
        }

        if (_temp28 instanceof Completion) {
          _temp28 = _temp28.Value;
        }

        const value = _temp28;

        if (value === Value.undefined) {
          return Value.undefined;
        }

        return Descriptor({
          Value: value,
          Writable: Value.true,
          Enumerable: Value.true,
          Configurable: Value.false
        });
      }
    }

    return OrdinaryGetOwnProperty(O, P);
  } // 9.4.5.2 #sec-integer-indexed-exotic-objects-hasproperty-p


  HasProperty(P) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    Assert(O instanceof IntegerIndexedExoticObjectValue, "O instanceof IntegerIndexedExoticObjectValue");

    if (Type(P) === 'String') {
      let _temp29 = CanonicalNumericIndexString(P);

      Assert(!(_temp29 instanceof AbruptCompletion), "CanonicalNumericIndexString(P)" + ' returned an abrupt completion');

      if (_temp29 instanceof Completion) {
        _temp29 = _temp29.Value;
      }

      const numericIndex = _temp29;

      if (numericIndex !== Value.undefined) {
        const buffer = O.ViewedArrayBuffer;

        if (IsDetachedBuffer(buffer)) {
          return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
        }

        if (IsValidIntegerIndex(O, numericIndex) === Value.false) {
          return Value.false;
        }

        return Value.true;
      }
    }

    return OrdinaryHasProperty(O, P);
  } // 9.4.5.3 #sec-integer-indexed-exotic-objects-defineownproperty-p-desc


  DefineOwnProperty(P, Desc) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    Assert(O instanceof ObjectValue && 'ViewedArrayBuffer' in O, "O instanceof ObjectValue && 'ViewedArrayBuffer' in O");

    if (Type(P) === 'String') {
      let _temp30 = CanonicalNumericIndexString(P);

      Assert(!(_temp30 instanceof AbruptCompletion), "CanonicalNumericIndexString(P)" + ' returned an abrupt completion');

      if (_temp30 instanceof Completion) {
        _temp30 = _temp30.Value;
      }

      const numericIndex = _temp30;

      if (numericIndex !== Value.undefined) {
        if (IsValidIntegerIndex(O, numericIndex) === Value.false) {
          return Value.false;
        }

        if (IsAccessorDescriptor(Desc)) {
          return Value.false;
        }

        if (Desc.Configurable === Value.true) {
          return Value.false;
        }

        if (Desc.Enumerable === Value.false) {
          return Value.false;
        }

        if (Desc.Writable === Value.false) {
          return Value.false;
        }

        if (Desc.Value !== undefined) {
          const value = Desc.Value;
          return IntegerIndexedElementSet(O, numericIndex, value);
        }

        return Value.true;
      }
    }

    return OrdinaryDefineOwnProperty(O, P, Desc);
  } // 9.4.5.4 #sec-integer-indexed-exotic-objects-get-p-receiver


  Get(P, Receiver) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (Type(P) === 'String') {
      let _temp31 = CanonicalNumericIndexString(P);

      Assert(!(_temp31 instanceof AbruptCompletion), "CanonicalNumericIndexString(P)" + ' returned an abrupt completion');

      if (_temp31 instanceof Completion) {
        _temp31 = _temp31.Value;
      }

      const numericIndex = _temp31;

      if (numericIndex !== Value.undefined) {
        return IntegerIndexedElementGet(O, numericIndex);
      }
    }

    return OrdinaryGet(O, P, Receiver);
  } // 9.4.5.5 #sec-integer-indexed-exotic-objects-set-p-v-receiver


  Set(P, V, Receiver) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (Type(P) === 'String') {
      let _temp32 = CanonicalNumericIndexString(P);

      Assert(!(_temp32 instanceof AbruptCompletion), "CanonicalNumericIndexString(P)" + ' returned an abrupt completion');

      if (_temp32 instanceof Completion) {
        _temp32 = _temp32.Value;
      }

      const numericIndex = _temp32;

      if (numericIndex !== Value.undefined) {
        return IntegerIndexedElementSet(O, numericIndex, V);
      }
    }

    return OrdinarySet(O, P, V, Receiver);
  } // 9.4.5.6 #sec-integer-indexed-exotic-objects-ownpropertykeys


  OwnPropertyKeys() {
    const O = this;
    const keys = [];
    Assert(O instanceof IntegerIndexedExoticObjectValue, "O instanceof IntegerIndexedExoticObjectValue");
    const len = O.ArrayLength.numberValue();

    for (let i = 0; i < len; i += 1) {
      let _temp33 = ToString(new Value(i));

      Assert(!(_temp33 instanceof AbruptCompletion), "ToString(new Value(i))" + ' returned an abrupt completion');

      if (_temp33 instanceof Completion) {
        _temp33 = _temp33.Value;
      }

      keys.push(_temp33);
    }

    for (const P of O.properties.keys()) {
      if (Type(P) === 'String') {
        if (!isIntegerIndex(P)) {
          keys.push(P);
        }
      }
    }

    for (const P of O.properties.keys()) {
      if (Type(P) === 'Symbol') {
        keys.push(P);
      }
    }

    return keys;
  }

}
IntegerIndexedExoticObjectValue.prototype.isOrdinary = false; // 9.4.7.2 #sec-set-immutable-prototype

function SetImmutablePrototype(O, V) {
  Assert(Type(V) === 'Object' || Type(V) === 'Null', "Type(V) === 'Object' || Type(V) === 'Null'");

  let _temp34 = O.GetPrototypeOf();

  if (_temp34 instanceof AbruptCompletion) {
    return _temp34;
  }

  if (_temp34 instanceof Completion) {
    _temp34 = _temp34.Value;
  }

  const current = _temp34;

  if (SameValue(V, current) === Value.true) {
    return Value.true;
  }

  return Value.false;
} // 9.4.6 #sec-module-namespace-exotic-objects


class ModuleNamespaceExoticObjectValue extends ObjectValue {
  constructor() {
    super();
    this.Module = null;
    this.Exports = null;
    this.Prototype = Value.null;
  }

  SetPrototypeOf(V) {
    const O = this;
    return SetImmutablePrototype(O, V);
  }

  IsExtensible() {
    return Value.false;
  }

  PreventExtensions() {
    return Value.true;
  }

  GetOwnProperty(P) {
    const O = this;

    if (Type(P) === 'Symbol') {
      return OrdinaryGetOwnProperty(O, P);
    }

    const exports = O.Exports;

    if (!exports.has(P)) {
      return Value.undefined;
    }

    let _temp35 = O.Get(P, O);

    if (_temp35 instanceof AbruptCompletion) {
      return _temp35;
    }

    if (_temp35 instanceof Completion) {
      _temp35 = _temp35.Value;
    }

    const value = _temp35;
    return Descriptor({
      Value: value,
      Writable: Value.true,
      Enumerable: Value.true,
      Configurable: Value.false
    });
  }

  DefineOwnProperty(P, Desc) {
    const O = this;

    if (Type(P) === 'Symbol') {
      return OrdinaryDefineOwnProperty(O, P, Desc);
    }

    let _temp36 = O.GetOwnProperty(P);

    if (_temp36 instanceof AbruptCompletion) {
      return _temp36;
    }

    if (_temp36 instanceof Completion) {
      _temp36 = _temp36.Value;
    }

    const current = _temp36;

    if (current === Value.undefined) {
      return Value.false;
    }

    if (IsAccessorDescriptor(Desc)) {
      return Value.false;
    }

    if (Desc.Writable !== undefined && Desc.Writable === Value.false) {
      return Value.false;
    }

    if (Desc.Enumerable !== undefined && Desc.Enumerable === Value.false) {
      return Value.false;
    }

    if (Desc.Configurable !== undefined && Desc.Configurable === Value.true) {
      return Value.false;
    }

    if (Desc.Value !== undefined) {
      return SameValue(Desc.Value, current.Value);
    }

    return Value.true;
  }

  HasProperty(P) {
    const O = this;

    if (Type(P) === 'Symbol') {
      return OrdinaryHasProperty(O, P);
    }

    const exports = O.Exports;

    if (exports.has(P)) {
      return Value.true;
    }

    return Value.false;
  }

  Get(P, Receiver) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (Type(P) === 'Symbol') {
      return OrdinaryGet(O, P, Receiver);
    }

    const exports = O.Exports;

    if (!exports.has(P)) {
      return Value.undefined;
    }

    const m = O.Module;
    const binding = m.ResolveExport(P);
    Assert(binding instanceof ResolvedBindingRecord, "binding instanceof ResolvedBindingRecord");
    const targetModule = binding.Module;
    Assert(targetModule !== Value.undefined, "targetModule !== Value.undefined");
    const targetEnv = targetModule.Environment;

    if (targetEnv === Value.undefined) {
      return surroundingAgent.Throw('ReferenceError', 'NotDefined', P);
    }

    const targetEnvRec = targetEnv.EnvironmentRecord;
    return targetEnvRec.GetBindingValue(binding.BindingName, Value.true);
  }

  Set() {
    return Value.false;
  }

  Delete(P) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");

    if (Type(P) === 'Symbol') {
      return OrdinaryDelete(O, P);
    }

    const exports = O.Exports;

    if (exports.has(P)) {
      return Value.false;
    }

    return Value.true;
  }

  OwnPropertyKeys() {
    const O = this;
    const exports = [...O.Exports];

    let _temp37 = OrdinaryOwnPropertyKeys(O);

    Assert(!(_temp37 instanceof AbruptCompletion), "OrdinaryOwnPropertyKeys(O)" + ' returned an abrupt completion');

    if (_temp37 instanceof Completion) {
      _temp37 = _temp37.Value;
    }

    const symbolKeys = _temp37;
    exports.push(...symbolKeys);
    return exports;
  }

}
ModuleNamespaceExoticObjectValue.prototype.isOrdinary = false; // 9.5 #sec-proxy-object-internal-methods-and-internal-slots

class ProxyExoticObjectValue extends ObjectValue {
  constructor() {
    super();
    this.ProxyTarget = undefined;
    this.ProxyHandler = undefined;
  }

  GetPrototypeOf() {
    const O = this;
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'getPrototypeOf');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp38 = GetMethod(handler, new Value('getPrototypeOf'));

    if (_temp38 instanceof AbruptCompletion) {
      return _temp38;
    }

    if (_temp38 instanceof Completion) {
      _temp38 = _temp38.Value;
    }

    const trap = _temp38;

    if (trap === Value.undefined) {
      return target.GetPrototypeOf();
    }

    let _temp39 = Call(trap, handler, [target]);

    if (_temp39 instanceof AbruptCompletion) {
      return _temp39;
    }

    if (_temp39 instanceof Completion) {
      _temp39 = _temp39.Value;
    }

    const handlerProto = _temp39;

    if (Type(handlerProto) !== 'Object' && Type(handlerProto) !== 'Null') {
      return surroundingAgent.Throw('TypeError', 'ProxyGetPrototypeOfInvalid');
    }

    let _temp40 = IsExtensible(target);

    if (_temp40 instanceof AbruptCompletion) {
      return _temp40;
    }

    if (_temp40 instanceof Completion) {
      _temp40 = _temp40.Value;
    }

    const extensibleTarget = _temp40;

    if (extensibleTarget === Value.true) {
      return handlerProto;
    }

    let _temp41 = target.GetPrototypeOf();

    if (_temp41 instanceof AbruptCompletion) {
      return _temp41;
    }

    if (_temp41 instanceof Completion) {
      _temp41 = _temp41.Value;
    }

    const targetProto = _temp41;

    if (SameValue(handlerProto, targetProto) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyGetPrototypeOfNonExtensible');
    }

    return handlerProto;
  }

  SetPrototypeOf(V) {
    const O = this;
    Assert(Type(V) === 'Object' || Type(V) === 'Null', "Type(V) === 'Object' || Type(V) === 'Null'");
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'setPrototypeOf');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp42 = GetMethod(handler, new Value('setPrototypeOf'));

    if (_temp42 instanceof AbruptCompletion) {
      return _temp42;
    }

    if (_temp42 instanceof Completion) {
      _temp42 = _temp42.Value;
    }

    const trap = _temp42;

    if (trap === Value.undefined) {
      return target.SetPrototypeOf(V);
    }

    let _temp43 = Call(trap, handler, [target, V]);

    if (_temp43 instanceof AbruptCompletion) {
      return _temp43;
    }

    if (_temp43 instanceof Completion) {
      _temp43 = _temp43.Value;
    }

    const booleanTrapResult = ToBoolean(_temp43);

    if (booleanTrapResult === Value.false) {
      return Value.false;
    }

    let _temp44 = IsExtensible(target);

    if (_temp44 instanceof AbruptCompletion) {
      return _temp44;
    }

    if (_temp44 instanceof Completion) {
      _temp44 = _temp44.Value;
    }

    const extensibleTarget = _temp44;

    if (extensibleTarget === Value.true) {
      return Value.true;
    }

    let _temp45 = target.GetPrototypeOf();

    if (_temp45 instanceof AbruptCompletion) {
      return _temp45;
    }

    if (_temp45 instanceof Completion) {
      _temp45 = _temp45.Value;
    }

    const targetProto = _temp45;

    if (SameValue(V, targetProto) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxySetPrototypeOfNonExtensible');
    }

    return Value.true;
  }

  IsExtensible() {
    const O = this;
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'isExtensible');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp46 = GetMethod(handler, new Value('isExtensible'));

    if (_temp46 instanceof AbruptCompletion) {
      return _temp46;
    }

    if (_temp46 instanceof Completion) {
      _temp46 = _temp46.Value;
    }

    const trap = _temp46;

    if (trap === Value.undefined) {
      return IsExtensible(target);
    }

    let _temp47 = Call(trap, handler, [target]);

    if (_temp47 instanceof AbruptCompletion) {
      return _temp47;
    }

    if (_temp47 instanceof Completion) {
      _temp47 = _temp47.Value;
    }

    const booleanTrapResult = ToBoolean(_temp47);

    let _temp48 = IsExtensible(target);

    if (_temp48 instanceof AbruptCompletion) {
      return _temp48;
    }

    if (_temp48 instanceof Completion) {
      _temp48 = _temp48.Value;
    }

    const targetResult = _temp48;

    if (SameValue(booleanTrapResult, targetResult) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyIsExtensibleInconsistent', targetResult);
    }

    return booleanTrapResult;
  }

  PreventExtensions() {
    const O = this;
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'preventExtensions');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp49 = GetMethod(handler, new Value('preventExtensions'));

    if (_temp49 instanceof AbruptCompletion) {
      return _temp49;
    }

    if (_temp49 instanceof Completion) {
      _temp49 = _temp49.Value;
    }

    const trap = _temp49;

    if (trap === Value.undefined) {
      return target.PreventExtensions();
    }

    let _temp50 = Call(trap, handler, [target]);

    if (_temp50 instanceof AbruptCompletion) {
      return _temp50;
    }

    if (_temp50 instanceof Completion) {
      _temp50 = _temp50.Value;
    }

    const booleanTrapResult = ToBoolean(_temp50);

    if (booleanTrapResult === Value.true) {
      let _temp51 = IsExtensible(target);

      if (_temp51 instanceof AbruptCompletion) {
        return _temp51;
      }

      if (_temp51 instanceof Completion) {
        _temp51 = _temp51.Value;
      }

      const extensibleTarget = _temp51;

      if (extensibleTarget === Value.true) {
        return surroundingAgent.Throw('TypeError', 'ProxyPreventExtensionsExtensible');
      }
    }

    return booleanTrapResult;
  }

  GetOwnProperty(P) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'getOwnPropertyDescriptor');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp52 = GetMethod(handler, new Value('getOwnPropertyDescriptor'));

    if (_temp52 instanceof AbruptCompletion) {
      return _temp52;
    }

    if (_temp52 instanceof Completion) {
      _temp52 = _temp52.Value;
    }

    const trap = _temp52;

    if (trap === Value.undefined) {
      return target.GetOwnProperty(P);
    }

    let _temp53 = Call(trap, handler, [target, P]);

    if (_temp53 instanceof AbruptCompletion) {
      return _temp53;
    }

    if (_temp53 instanceof Completion) {
      _temp53 = _temp53.Value;
    }

    const trapResultObj = _temp53;

    if (Type(trapResultObj) !== 'Object' && Type(trapResultObj) !== 'Undefined') {
      return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorInvalid', P);
    }

    let _temp54 = target.GetOwnProperty(P);

    if (_temp54 instanceof AbruptCompletion) {
      return _temp54;
    }

    if (_temp54 instanceof Completion) {
      _temp54 = _temp54.Value;
    }

    const targetDesc = _temp54;

    if (trapResultObj === Value.undefined) {
      if (targetDesc === Value.undefined) {
        return Value.undefined;
      }

      if (targetDesc.Configurable === Value.false) {
        return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorUndefined', P);
      }

      let _temp55 = IsExtensible(target);

      if (_temp55 instanceof AbruptCompletion) {
        return _temp55;
      }

      if (_temp55 instanceof Completion) {
        _temp55 = _temp55.Value;
      }

      const extensibleTarget = _temp55;

      if (extensibleTarget === Value.false) {
        return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorNonExtensible', P);
      }

      return Value.undefined;
    }

    let _temp56 = IsExtensible(target);

    if (_temp56 instanceof AbruptCompletion) {
      return _temp56;
    }

    if (_temp56 instanceof Completion) {
      _temp56 = _temp56.Value;
    }

    const extensibleTarget = _temp56;

    let _temp57 = ToPropertyDescriptor(trapResultObj);

    if (_temp57 instanceof AbruptCompletion) {
      return _temp57;
    }

    if (_temp57 instanceof Completion) {
      _temp57 = _temp57.Value;
    }

    const resultDesc = _temp57;
    CompletePropertyDescriptor(resultDesc);
    const valid = IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc);

    if (valid === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorIncompatible', P);
    }

    if (resultDesc.Configurable === Value.false) {
      if (targetDesc === Value.undefined || targetDesc.Configurable === Value.true) {
        return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorNonConfigurable', P);
      }
    }

    return resultDesc;
  }

  DefineOwnProperty(P, Desc) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'defineProperty');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp58 = GetMethod(handler, new Value('defineProperty'));

    if (_temp58 instanceof AbruptCompletion) {
      return _temp58;
    }

    if (_temp58 instanceof Completion) {
      _temp58 = _temp58.Value;
    }

    const trap = _temp58;

    if (trap === Value.undefined) {
      return target.DefineOwnProperty(P, Desc);
    }

    const descObj = FromPropertyDescriptor(Desc);

    let _temp59 = Call(trap, handler, [target, P, descObj]);

    if (_temp59 instanceof AbruptCompletion) {
      return _temp59;
    }

    if (_temp59 instanceof Completion) {
      _temp59 = _temp59.Value;
    }

    const booleanTrapResult = ToBoolean(_temp59);

    if (booleanTrapResult === Value.false) {
      return Value.false;
    }

    let _temp60 = target.GetOwnProperty(P);

    if (_temp60 instanceof AbruptCompletion) {
      return _temp60;
    }

    if (_temp60 instanceof Completion) {
      _temp60 = _temp60.Value;
    }

    const targetDesc = _temp60;

    let _temp61 = IsExtensible(target);

    if (_temp61 instanceof AbruptCompletion) {
      return _temp61;
    }

    if (_temp61 instanceof Completion) {
      _temp61 = _temp61.Value;
    }

    const extensibleTarget = _temp61;
    let settingConfigFalse;

    if (Desc.Configurable !== undefined && Desc.Configurable === Value.false) {
      settingConfigFalse = true;
    } else {
      settingConfigFalse = false;
    }

    if (targetDesc === Value.undefined) {
      if (extensibleTarget === Value.false) {
        return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyNonExtensible', P);
      }

      if (settingConfigFalse === true) {
        return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyNonConfigurable', P);
      }
    } else {
      if (IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) === Value.false) {
        return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyIncompatible', P);
      }

      if (settingConfigFalse === true && targetDesc.Configurable === Value.true) {
        return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyNonConfigurableWritable', P);
      }
    }

    return Value.true;
  }

  HasProperty(P) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'has');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp62 = GetMethod(handler, new Value('has'));

    if (_temp62 instanceof AbruptCompletion) {
      return _temp62;
    }

    if (_temp62 instanceof Completion) {
      _temp62 = _temp62.Value;
    }

    const trap = _temp62;

    if (trap === Value.undefined) {
      return target.HasProperty(P);
    }

    let _temp63 = Call(trap, handler, [target, P]);

    if (_temp63 instanceof AbruptCompletion) {
      return _temp63;
    }

    if (_temp63 instanceof Completion) {
      _temp63 = _temp63.Value;
    }

    const booleanTrapResult = ToBoolean(_temp63);

    if (booleanTrapResult === Value.false) {
      let _temp64 = target.GetOwnProperty(P);

      if (_temp64 instanceof AbruptCompletion) {
        return _temp64;
      }

      if (_temp64 instanceof Completion) {
        _temp64 = _temp64.Value;
      }

      const targetDesc = _temp64;

      if (targetDesc !== Value.undefined) {
        if (targetDesc.Configurable === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxyHasNonConfigurable', P);
        }

        let _temp65 = IsExtensible(target);

        if (_temp65 instanceof AbruptCompletion) {
          return _temp65;
        }

        if (_temp65 instanceof Completion) {
          _temp65 = _temp65.Value;
        }

        const extensibleTarget = _temp65;

        if (extensibleTarget === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxyHasNonExtensible', P);
        }
      }
    }

    return booleanTrapResult;
  }

  Get(P, Receiver) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'get');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp66 = GetMethod(handler, new Value('get'));

    if (_temp66 instanceof AbruptCompletion) {
      return _temp66;
    }

    if (_temp66 instanceof Completion) {
      _temp66 = _temp66.Value;
    }

    const trap = _temp66;

    if (trap === Value.undefined) {
      return target.Get(P, Receiver);
    }

    let _temp67 = Call(trap, handler, [target, P, Receiver]);

    if (_temp67 instanceof AbruptCompletion) {
      return _temp67;
    }

    if (_temp67 instanceof Completion) {
      _temp67 = _temp67.Value;
    }

    const trapResult = _temp67;

    let _temp68 = target.GetOwnProperty(P);

    if (_temp68 instanceof AbruptCompletion) {
      return _temp68;
    }

    if (_temp68 instanceof Completion) {
      _temp68 = _temp68.Value;
    }

    const targetDesc = _temp68;

    if (targetDesc !== Value.undefined && targetDesc.Configurable === Value.false) {
      if (IsDataDescriptor(targetDesc) === true && targetDesc.Writable === Value.false) {
        if (SameValue(trapResult, targetDesc.Value) === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxyGetNonConfigurableData', P);
        }
      }

      if (IsAccessorDescriptor(targetDesc) === true && targetDesc.Get === Value.undefined) {
        if (trapResult !== Value.undefined) {
          return surroundingAgent.Throw('TypeError', 'ProxyGetNonConfigurableAccessor', P);
        }
      }
    }

    return trapResult;
  }

  Set(P, V, Receiver) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'set');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp69 = GetMethod(handler, new Value('set'));

    if (_temp69 instanceof AbruptCompletion) {
      return _temp69;
    }

    if (_temp69 instanceof Completion) {
      _temp69 = _temp69.Value;
    }

    const trap = _temp69;

    if (trap === Value.undefined) {
      return target.Set(P, V, Receiver);
    }

    let _temp70 = Call(trap, handler, [target, P, V, Receiver]);

    if (_temp70 instanceof AbruptCompletion) {
      return _temp70;
    }

    if (_temp70 instanceof Completion) {
      _temp70 = _temp70.Value;
    }

    const booleanTrapResult = ToBoolean(_temp70);

    if (booleanTrapResult === Value.false) {
      return Value.false;
    }

    let _temp71 = target.GetOwnProperty(P);

    if (_temp71 instanceof AbruptCompletion) {
      return _temp71;
    }

    if (_temp71 instanceof Completion) {
      _temp71 = _temp71.Value;
    }

    const targetDesc = _temp71;

    if (targetDesc !== Value.undefined && targetDesc.Configurable === Value.false) {
      if (IsDataDescriptor(targetDesc) === true && targetDesc.Writable === Value.false) {
        if (SameValue(V, targetDesc.Value) === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxySetFrozenData', P);
        }
      }

      if (IsAccessorDescriptor(targetDesc) === true) {
        if (targetDesc.Set === Value.undefined) {
          return surroundingAgent.Throw('TypeError', 'ProxySetFrozenAccessor', P);
        }
      }
    }

    return Value.true;
  }

  Delete(P) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'deleteProperty');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp72 = GetMethod(handler, new Value('deleteProperty'));

    if (_temp72 instanceof AbruptCompletion) {
      return _temp72;
    }

    if (_temp72 instanceof Completion) {
      _temp72 = _temp72.Value;
    }

    const trap = _temp72;

    if (trap === Value.undefined) {
      return target.Delete(P);
    }

    let _temp73 = Call(trap, handler, [target, P]);

    if (_temp73 instanceof AbruptCompletion) {
      return _temp73;
    }

    if (_temp73 instanceof Completion) {
      _temp73 = _temp73.Value;
    }

    const booleanTrapResult = ToBoolean(_temp73);

    if (booleanTrapResult === Value.false) {
      return Value.false;
    }

    let _temp74 = target.GetOwnProperty(P);

    if (_temp74 instanceof AbruptCompletion) {
      return _temp74;
    }

    if (_temp74 instanceof Completion) {
      _temp74 = _temp74.Value;
    }

    const targetDesc = _temp74;

    if (targetDesc === Value.undefined) {
      return Value.true;
    }

    if (targetDesc.Configurable === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyDeletePropertyNonConfigurable', P);
    }

    return Value.true;
  }

  OwnPropertyKeys() {
    const O = this;
    const handler = O.ProxyHandler;

    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'ownKeys');
    }

    Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
    const target = O.ProxyTarget;

    let _temp75 = GetMethod(handler, new Value('ownKeys'));

    if (_temp75 instanceof AbruptCompletion) {
      return _temp75;
    }

    if (_temp75 instanceof Completion) {
      _temp75 = _temp75.Value;
    }

    const trap = _temp75;

    if (trap === Value.undefined) {
      return target.OwnPropertyKeys();
    }

    let _temp76 = Call(trap, handler, [target]);

    if (_temp76 instanceof AbruptCompletion) {
      return _temp76;
    }

    if (_temp76 instanceof Completion) {
      _temp76 = _temp76.Value;
    }

    const trapResultArray = _temp76;

    let _temp77 = CreateListFromArrayLike(trapResultArray, ['String', 'Symbol']);

    if (_temp77 instanceof AbruptCompletion) {
      return _temp77;
    }

    if (_temp77 instanceof Completion) {
      _temp77 = _temp77.Value;
    }

    const trapResult = _temp77;

    if (new ValueSet(trapResult).size !== trapResult.length) {
      return surroundingAgent.Throw('TypeError', 'ProxyOwnKeysDuplicateEntries');
    }

    let _temp78 = IsExtensible(target);

    if (_temp78 instanceof AbruptCompletion) {
      return _temp78;
    }

    if (_temp78 instanceof Completion) {
      _temp78 = _temp78.Value;
    }

    const extensibleTarget = _temp78;

    let _temp79 = target.OwnPropertyKeys();

    if (_temp79 instanceof AbruptCompletion) {
      return _temp79;
    }

    if (_temp79 instanceof Completion) {
      _temp79 = _temp79.Value;
    }

    const targetKeys = _temp79; // Assert: targetKeys is a List containing only String and Symbol values.
    // Assert: targetKeys contains no duplicate entries.

    const targetConfigurableKeys = [];
    const targetNonconfigurableKeys = [];

    for (const key of targetKeys) {
      let _temp80 = target.GetOwnProperty(key);

      if (_temp80 instanceof AbruptCompletion) {
        return _temp80;
      }

      if (_temp80 instanceof Completion) {
        _temp80 = _temp80.Value;
      }

      const desc = _temp80;

      if (desc !== Value.undefined && desc.Configurable === Value.false) {
        targetNonconfigurableKeys.push(key);
      } else {
        targetConfigurableKeys.push(key);
      }
    }

    if (extensibleTarget === Value.true && targetNonconfigurableKeys.length === 0) {
      return trapResult;
    }

    const uncheckedResultKeys = new ValueSet(trapResult);

    for (const key of targetNonconfigurableKeys) {
      if (!uncheckedResultKeys.has(key)) {
        return surroundingAgent.Throw('TypeError', 'ProxyOwnKeysMissing', 'non-configurable key');
      }

      uncheckedResultKeys.delete(key);
    }

    if (extensibleTarget === Value.true) {
      return trapResult;
    }

    for (const key of targetConfigurableKeys) {
      if (!uncheckedResultKeys.has(key)) {
        return surroundingAgent.Throw('TypeError', 'ProxyOwnKeysMissing', 'configurable key');
      }

      uncheckedResultKeys.delete(key);
    }

    if (uncheckedResultKeys.size > 0) {
      return surroundingAgent.Throw('TypeError', 'ProxyOwnKeysNonExtensible');
    }

    return trapResult;
  }

}
ProxyExoticObjectValue.prototype.isOrdinary = false;
class Reference {
  constructor({
    BaseValue,
    ReferencedName,
    StrictReference
  }) {
    this.BaseValue = BaseValue;
    this.ReferencedName = ReferencedName;
    Assert(Type(StrictReference) === 'Boolean', "Type(StrictReference) === 'Boolean'");
    this.StrictReference = StrictReference;
  }

}
class SuperReference extends Reference {
  constructor({
    BaseValue,
    ReferencedName,
    thisValue,
    StrictReference
  }) {
    super({
      BaseValue,
      ReferencedName,
      StrictReference
    });
    this.thisValue = thisValue;
  }

}
function Descriptor(O) {
  if (new.target === Descriptor) {
    this.Value = O.Value;
    this.Get = O.Get;
    this.Set = O.Set;
    this.Writable = O.Writable;
    this.Enumerable = O.Enumerable;
    this.Configurable = O.Configurable;
  } else {
    return new Descriptor(O);
  }
}

Descriptor.prototype.everyFieldIsAbsent = function everyFieldIsAbsent() {
  return this.Value === undefined && this.Get === undefined && this.Set === undefined && this.Writable === undefined && this.Enumerable === undefined && this.Configurable === undefined;
};

class DataBlock extends Uint8Array {
  constructor(sizeOrBuffer, ...restArgs) {
    if (sizeOrBuffer instanceof ArrayBuffer) {
      // fine.
      super(sizeOrBuffer, ...restArgs);
    } else {
      Assert(typeof sizeOrBuffer === 'number', "typeof sizeOrBuffer === 'number'");
      super(sizeOrBuffer);
    }
  }

}
function Type(val) {
  if (val instanceof UndefinedValue) {
    return 'Undefined';
  }

  if (val instanceof NullValue) {
    return 'Null';
  }

  if (val instanceof BooleanValue) {
    return 'Boolean';
  }

  if (val instanceof StringValue) {
    return 'String';
  }

  if (val instanceof NumberValue) {
    return 'Number';
  }

  if (val instanceof BigIntValue) {
    return 'BigInt';
  }

  if (val instanceof SymbolValue) {
    return 'Symbol';
  }

  if (val instanceof ObjectValue) {
    return 'Object';
  }

  if (val instanceof Reference) {
    return 'Reference';
  }

  if (val instanceof Completion) {
    return 'Completion';
  }

  if (val instanceof EnvironmentRecord) {
    return 'EnvironmentRecord';
  }

  if (val instanceof LexicalEnvironment) {
    return 'LexicalEnvironment';
  }

  if (val instanceof Descriptor) {
    return 'Descriptor';
  }

  if (val instanceof DataBlock) {
    return 'Data Block';
  }

  throw new OutOfRange('Type', val);
} // Used for Type(x)::y for numerics

function TypeNumeric(val) {
  if (val instanceof NumberValue) {
    return NumberValue;
  }

  if (val instanceof BigIntValue) {
    return BigIntValue;
  }

  throw new OutOfRange('TypeNumeric', val);
}

function i(V) {
  if (V instanceof Value) {
    return inspect(V, surroundingAgent.currentRealmRecord);
  }

  return `${V}`;
}

const Raw = s => s;
const AlreadyDeclared = n => `${i(n)} is already declared`;
const ArrayBufferDetached = () => 'Attempt to access detached ArrayBuffer';
const ArrayPastSafeLength = () => 'Cannot make length of array-like object surpass the bounds of an integer index';
const ArrayEmptyReduce = () => 'Cannot reduce an empty array with no initial value';
const AssignmentToConstant = n => `Assignment to constant variable ${i(n)}`;
const BigIntDivideByZero = () => 'Division by zero';
const BigIntNegativeExponent = () => 'Exponent must be positive';
const BigIntUnsignedRightShift = () => 'BigInt has no unsigned right shift, use >> instead';
const BufferDetachKeyMismatch = (k, b) => `${i(k)} is not the [[ArrayBufferDetachKey]] of ${i(b)}`;
const BufferDetached = () => 'Cannot operate on detached ArrayBuffer';
const CannotAllocateDataBlock = () => 'Cannot allocate memory';
const CannotCreateProxyWith = (x, y) => `Cannot create a proxy with a ${x} as ${y}`;
const CannotConvertDecimalToBigInt = n => `Cannot convert ${i(n)} to a BigInt because it is not an integer`;
const CannotConvertSymbol = t => `Cannot convert a Symbol value to a ${t}`;
const CannotConvertToBigInt = v => `Cannot convert ${i(v)} to a BigInt`;
const CannotConvertToObject = t => `Cannot convert ${t} to object`;
const CannotDefineProperty = p => `Cannot define property ${i(p)}`;
const CannotDeleteProperty = p => `Cannot delete property ${i(p)}`;
const CannotDeleteSuper = () => 'Cannot delete a super property';
const CannotJSONSerializeBigInt = () => 'Cannot serialize a BigInt to JSON';
const CannotMixBigInts = () => 'Cannot mix BigInt and other types, use explicit conversions';
const CannotResolvePromiseWithItself = () => 'Cannot resolve a promise with itself';
const CannotSetProperty = (p, o) => `Cannot set property ${i(p)} on ${i(o)}`;
const ConstructorNonCallable = f => `${i(f)} cannot be invoked without new`;
const ConstructorRequiresNew = n => `${n} constructor requires new`;
const CouldNotResolveModule = s => `Could not resolve module ${i(s)}`;
const DataViewOOB = () => 'Offset is outside the bounds of the DataView';
const DateInvalidTime = () => 'Invalid time';
const DerivedConstructorReturnedNonObject = () => 'Derived constructors may only return object or undefined';
const GeneratorRunning = () => 'Cannot manipulate a running generator';
const InternalSlotMissing = (o, s) => `Internal slot ${s} is missing for ${i(o)}`;
const InvalidArrayLength = l => `Invalid array length: ${i(l)}`;
const InvalidHint = v => `Invalid hint: ${i(v)}`;
const InvalidPropertyDescriptor = () => 'Invalid property descriptor. Cannot both specify accessors and a value or writable attribute';
const InvalidRadix = () => 'Radix must be between 2 and 36, inclusive';
const InvalidReceiver = (f, v) => `${f} called on invalid receiver: ${i(v)}`;
const InvalidRegExpFlags = f => `Invalid RegExp flags: ${f}`;
const InvalidThis = () => 'Invalid `this` access';
const IteratorThrowMissing = () => 'The iterator does not provide a throw method';
const JSONCircular = () => 'Cannot JSON stringify a circular structure';
const JSONUnexpectedToken = () => 'Unexpected token in JSON';
const JSONUnexpectedChar = c => `Unexpected character ${c} in JSON`;
const JSONExpected = (e, a) => `Expected character ${e} but got ${a} in JSON`;
const NegativeIndex = n => `${n} cannot be negative`;
const NormalizeInvalidForm = () => 'Invalid normalization form';
const NotAConstructor = v => `${i(v)} is not a constructor`;
const NotAFunction = v => `${i(v)} is not a function`;
const NotATypeObject = (t, v) => `${i(v)} is not a ${t} object`;
const NotAnObject = v => `${i(v)} is not an object`;
const NotASymbol = v => `${i(v)} is not a symbol`;
const NotDefined = n => `${i(n)} is not defined`;
const NotPropertyName = p => `${i(p)} is not a valid property name`;
const ObjectToPrimitive = () => 'Cannot convert object to primitive value';
const ObjectPrototypeType = () => 'Object prototype must be an Object or null';
const ObjectSetPrototype = () => 'Could not set prototype of object';
const OutOfRange$1 = n => `${n} is out of range`;
const PromiseCapabilityFunctionAlreadySet = f => `Promise ${f} function already set`;
const PromiseRejectFunction = v => `Promise reject function ${i(v)} is not callable`;
const PromiseResolveFunction = v => `Promise resolve function ${i(v)} is not callable`;
const ProxyRevoked = n => `Cannot perform '${n}' on a proxy that has been revoked`;
const ProxyDefinePropertyNonConfigurable = p => `'defineProperty' on proxy: trap returned truish for defining non-configurable property ${i(p)} which is either non-existent or configurable in the proxy target`;
const ProxyDefinePropertyNonConfigurableWritable = p => `'defineProperty' on proxy: trap returned truish for defining non-configurable property ${i(p)} which cannot be non-writable, unless there exists a corresponding non-configurable, non-writable own property of the target object.`;
const ProxyDefinePropertyNonExtensible = p => `'defineProperty' on proxy: trap returned truish for adding property ${i(p)} to the non-extensible proxy target`;
const ProxyDefinePropertyIncompatible = p => `'defineProperty' on proxy: trap returned truish for adding property ${i(p)} that is incompatible with the existing property in the proxy target`;
const ProxyDeletePropertyNonConfigurable = p => `'deleteProperty' on proxy: trap returned truthy for property ${i(p)} which is non-configurable in the proxy target`;
const ProxyGetNonConfigurableData = p => `'get' on proxy: property ${i(p)} is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value`;
const ProxyGetNonConfigurableAccessor = p => `'get' on proxy: property ${i(p)} is a non-configurable accessor property on the proxy target and does not have a getter function, but the trap did not return 'undefined'`;
const ProxyGetPrototypeOfInvalid = () => '\'getPrototypeOf\' on proxy: trap returned neither object nor null';
const ProxyGetPrototypeOfNonExtensible = () => '\'getPrototypeOf\' on proxy: proxy target is non-extensible but the trap did not return its actual prototype';
const ProxyGetOwnPropertyDescriptorIncompatible = p => `'getOwnPropertyDescriptor' on proxy: trap returned descriptor for property ${i(p)} that is incompatible with the existing property in the proxy target`;
const ProxyGetOwnPropertyDescriptorInvalid = p => `'getOwnPropertyDescriptor' on proxy: trap returned neither object nor undefined for property ${i(p)}`;
const ProxyGetOwnPropertyDescriptorUndefined = p => `'getOwnPropertyDescriptor' on proxy: trap returned undefined for property ${i(p)} which is non-configurable in the proxy target`;
const ProxyGetOwnPropertyDescriptorNonExtensible = p => `'getOwnPropertyDescriptor' on proxy: trap returned undefined for property ${i(p)} which exists in the non-extensible target`;
const ProxyGetOwnPropertyDescriptorNonConfigurable = p => `'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property ${i(p)} which is either non-existent or configurable in the proxy target`;
const ProxyHasNonConfigurable = p => `'has' on proxy: trap returned falsy for property ${i(p)} which exists in the proxy target as non-configurable`;
const ProxyHasNonExtensible = p => `'has' on proxy: trap returned falsy for property ${i(p)} but the proxy target is not extensible`;
const ProxyIsExtensibleInconsistent = e => `'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is ${i(e)})`;
const ProxyOwnKeysMissing = p => `'ownKeys' on proxy: trap result did not include ${i(p)}`;
const ProxyOwnKeysNonExtensible = () => '\'ownKeys\' on proxy: trap result returned extra keys but proxy target is non-extensible';
const ProxyOwnKeysDuplicateEntries = () => '\'ownKeys\' on proxy: trap returned duplicate entries';
const ProxyPreventExtensionsExtensible = () => '\'preventExtensions\' on proxy: trap returned truthy but the proxy target is extensible';
const ProxySetPrototypeOfNonExtensible = () => '\'setPrototypeOf\' on proxy: trap returned truthy for setting a new prototype on the non-extensible proxy target';
const ProxySetFrozenData = p => `'set' on proxy: trap returned truthy for property ${i(p)} which exists in the proxy target as a non-configurable and non-writable data property with a different value`;
const ProxySetFrozenAccessor = p => `'set' on proxy: trap returned truish for property ${i(p)} which exists in the proxy target as a non-configurable and non-writable accessor property without a setter`;
const RegExpArgumentNotAllowed = m => `First argument to ${m} must not be a regular expression`;
const RegExpExecNotObject = o => `${i(o)} is not object or null`;
const ResolutionNullOrAmbiguous = (r, n, m) => r === null ? `Could not resolve import ${i(n)} from ${m.HostDefined.specifier}` : `Star export ${i(n)} from ${m.HostDefined.specifier} is ambiguous`;
const SpeciesNotConstructor = () => 'object.constructor[Symbol.species] is not a constructor';
const StrictModeDelete = n => `Cannot not delete property ${i(n)}`;
const StrictPoisonPill = () => 'The caller, callee, and arguments properties may not be accessed on strict mode functions or the arguments objects for calls to them';
const StringRepeatCount = v => `Count ${i(v)} is invalid`;
const StringCodePointInvalid = n => `Invalid code point ${i(n)}`;
const SubclassLengthTooSmall = v => `Subclass constructor returned a smaller-than-requested object ${i(v)}`;
const SubclassSameValue = v => `Subclass constructor returned the same object ${i(v)}`;
const TypedArrayCreationOOB = () => 'Sum of start offset and byte length should be less than the size of underlying buffer';
const TypedArrayLengthAlignment = (n, m) => `Size of ${n} should be a multiple of ${m}`;
const TypedArrayOOB = () => 'Sum of start offset and byte length should be less than the size of the TypedArray';
const TypedArrayOffsetAlignment = (n, m) => `Start offset of ${n} should be a multiple of ${m}`;
const TypedArrayTooSmall = () => 'Derived TypedArray constructor created an array which was too small';
const UnableToSeal = o => `Unable to seal object ${i(o)}`;
const UnableToFreeze = o => `Unable to freeze object ${i(o)}`;
const UnableToPreventExtensions = o => `Unable to prevent extensions on object ${i(o)}`;

var messages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Raw: Raw,
  AlreadyDeclared: AlreadyDeclared,
  ArrayBufferDetached: ArrayBufferDetached,
  ArrayPastSafeLength: ArrayPastSafeLength,
  ArrayEmptyReduce: ArrayEmptyReduce,
  AssignmentToConstant: AssignmentToConstant,
  BigIntDivideByZero: BigIntDivideByZero,
  BigIntNegativeExponent: BigIntNegativeExponent,
  BigIntUnsignedRightShift: BigIntUnsignedRightShift,
  BufferDetachKeyMismatch: BufferDetachKeyMismatch,
  BufferDetached: BufferDetached,
  CannotAllocateDataBlock: CannotAllocateDataBlock,
  CannotCreateProxyWith: CannotCreateProxyWith,
  CannotConvertDecimalToBigInt: CannotConvertDecimalToBigInt,
  CannotConvertSymbol: CannotConvertSymbol,
  CannotConvertToBigInt: CannotConvertToBigInt,
  CannotConvertToObject: CannotConvertToObject,
  CannotDefineProperty: CannotDefineProperty,
  CannotDeleteProperty: CannotDeleteProperty,
  CannotDeleteSuper: CannotDeleteSuper,
  CannotJSONSerializeBigInt: CannotJSONSerializeBigInt,
  CannotMixBigInts: CannotMixBigInts,
  CannotResolvePromiseWithItself: CannotResolvePromiseWithItself,
  CannotSetProperty: CannotSetProperty,
  ConstructorNonCallable: ConstructorNonCallable,
  ConstructorRequiresNew: ConstructorRequiresNew,
  CouldNotResolveModule: CouldNotResolveModule,
  DataViewOOB: DataViewOOB,
  DateInvalidTime: DateInvalidTime,
  DerivedConstructorReturnedNonObject: DerivedConstructorReturnedNonObject,
  GeneratorRunning: GeneratorRunning,
  InternalSlotMissing: InternalSlotMissing,
  InvalidArrayLength: InvalidArrayLength,
  InvalidHint: InvalidHint,
  InvalidPropertyDescriptor: InvalidPropertyDescriptor,
  InvalidRadix: InvalidRadix,
  InvalidReceiver: InvalidReceiver,
  InvalidRegExpFlags: InvalidRegExpFlags,
  InvalidThis: InvalidThis,
  IteratorThrowMissing: IteratorThrowMissing,
  JSONCircular: JSONCircular,
  JSONUnexpectedToken: JSONUnexpectedToken,
  JSONUnexpectedChar: JSONUnexpectedChar,
  JSONExpected: JSONExpected,
  NegativeIndex: NegativeIndex,
  NormalizeInvalidForm: NormalizeInvalidForm,
  NotAConstructor: NotAConstructor,
  NotAFunction: NotAFunction,
  NotATypeObject: NotATypeObject,
  NotAnObject: NotAnObject,
  NotASymbol: NotASymbol,
  NotDefined: NotDefined,
  NotPropertyName: NotPropertyName,
  ObjectToPrimitive: ObjectToPrimitive,
  ObjectPrototypeType: ObjectPrototypeType,
  ObjectSetPrototype: ObjectSetPrototype,
  OutOfRange: OutOfRange$1,
  PromiseCapabilityFunctionAlreadySet: PromiseCapabilityFunctionAlreadySet,
  PromiseRejectFunction: PromiseRejectFunction,
  PromiseResolveFunction: PromiseResolveFunction,
  ProxyRevoked: ProxyRevoked,
  ProxyDefinePropertyNonConfigurable: ProxyDefinePropertyNonConfigurable,
  ProxyDefinePropertyNonConfigurableWritable: ProxyDefinePropertyNonConfigurableWritable,
  ProxyDefinePropertyNonExtensible: ProxyDefinePropertyNonExtensible,
  ProxyDefinePropertyIncompatible: ProxyDefinePropertyIncompatible,
  ProxyDeletePropertyNonConfigurable: ProxyDeletePropertyNonConfigurable,
  ProxyGetNonConfigurableData: ProxyGetNonConfigurableData,
  ProxyGetNonConfigurableAccessor: ProxyGetNonConfigurableAccessor,
  ProxyGetPrototypeOfInvalid: ProxyGetPrototypeOfInvalid,
  ProxyGetPrototypeOfNonExtensible: ProxyGetPrototypeOfNonExtensible,
  ProxyGetOwnPropertyDescriptorIncompatible: ProxyGetOwnPropertyDescriptorIncompatible,
  ProxyGetOwnPropertyDescriptorInvalid: ProxyGetOwnPropertyDescriptorInvalid,
  ProxyGetOwnPropertyDescriptorUndefined: ProxyGetOwnPropertyDescriptorUndefined,
  ProxyGetOwnPropertyDescriptorNonExtensible: ProxyGetOwnPropertyDescriptorNonExtensible,
  ProxyGetOwnPropertyDescriptorNonConfigurable: ProxyGetOwnPropertyDescriptorNonConfigurable,
  ProxyHasNonConfigurable: ProxyHasNonConfigurable,
  ProxyHasNonExtensible: ProxyHasNonExtensible,
  ProxyIsExtensibleInconsistent: ProxyIsExtensibleInconsistent,
  ProxyOwnKeysMissing: ProxyOwnKeysMissing,
  ProxyOwnKeysNonExtensible: ProxyOwnKeysNonExtensible,
  ProxyOwnKeysDuplicateEntries: ProxyOwnKeysDuplicateEntries,
  ProxyPreventExtensionsExtensible: ProxyPreventExtensionsExtensible,
  ProxySetPrototypeOfNonExtensible: ProxySetPrototypeOfNonExtensible,
  ProxySetFrozenData: ProxySetFrozenData,
  ProxySetFrozenAccessor: ProxySetFrozenAccessor,
  RegExpArgumentNotAllowed: RegExpArgumentNotAllowed,
  RegExpExecNotObject: RegExpExecNotObject,
  ResolutionNullOrAmbiguous: ResolutionNullOrAmbiguous,
  SpeciesNotConstructor: SpeciesNotConstructor,
  StrictModeDelete: StrictModeDelete,
  StrictPoisonPill: StrictPoisonPill,
  StringRepeatCount: StringRepeatCount,
  StringCodePointInvalid: StringCodePointInvalid,
  SubclassLengthTooSmall: SubclassLengthTooSmall,
  SubclassSameValue: SubclassSameValue,
  TypedArrayCreationOOB: TypedArrayCreationOOB,
  TypedArrayLengthAlignment: TypedArrayLengthAlignment,
  TypedArrayOOB: TypedArrayOOB,
  TypedArrayOffsetAlignment: TypedArrayOffsetAlignment,
  TypedArrayTooSmall: TypedArrayTooSmall,
  UnableToSeal: UnableToSeal,
  UnableToFreeze: UnableToFreeze,
  UnableToPreventExtensions: UnableToPreventExtensions
});

const FEATURES = Object.freeze([{
  name: 'TopLevelAwait',
  url: 'https://github.com/tc39/proposal-top-level-await'
}, {
  name: 'import.meta',
  url: 'https://github.com/tc39/proposal-import-meta'
}].map(Object.freeze)); // #sec-agents

class Agent {
  constructor(options = {}) {
    this.LittleEndian = Value.true;
    this.CanBlock = true;
    this.Signifier = Agent.Increment;
    Agent.Increment += 1;
    this.IsLockFree1 = true;
    this.IsLockFree2 = true;
    this.CandidateExecution = undefined;
    this.executionContextStack = [];
    const stackPop = this.executionContextStack.pop;

    this.executionContextStack.pop = function pop(...args) {
      const popped = stackPop.call(this);

      if (args.length === 1) {
        Assert(args[0] === popped, "args[0] === popped");
      }
    };

    this.jobQueue = [];
    this.hostDefinedOptions = { ...options,
      features: FEATURES.reduce((acc, {
        name
      }) => {
        if (options.features) {
          acc[name] = options.features.includes(name);
        } else {
          acc[name] = false;
        }

        return acc;
      }, {})
    };
  } // #sec-running-execution-context


  get runningExecutionContext() {
    return this.executionContextStack[this.executionContextStack.length - 1];
  } // #current-realm


  get currentRealmRecord() {
    return this.runningExecutionContext.Realm;
  } // #active-function-object


  get activeFunctionObject() {
    return this.runningExecutionContext.Function;
  } // Get an intrinsic by name for the current realm


  intrinsic(name) {
    return this.currentRealmRecord.Intrinsics[name];
  } // Generate a throw completion using message templates


  Throw(type, template, ...templateArgs) {
    if (type instanceof Value) {
      return new ThrowCompletion(type);
    }

    if (!template) {
      throw new RangeError('Throw must use a message template');
    }

    const tfn = messages[template];

    if (!tfn) {
      throw new RangeError(`'${template}' is not a valid message template`);
    }

    if (tfn.length !== templateArgs.length) {
      throw new RangeError(`Template '${template}' was passed the wrong number of arguments`);
    }

    const message = tfn(...templateArgs);
    const cons = this.currentRealmRecord.Intrinsics[`%${type}%`];
    const error = Construct(cons, [new Value(message)]);
    return new ThrowCompletion(error);
  } // NON-SPEC: Check if a feature is enabled in this agent.


  feature(name) {
    return this.hostDefinedOptions.features[name];
  }

}
Agent.Increment = 0;
let surroundingAgent;
function setSurroundingAgent(a) {
  surroundingAgent = a;
} // #sec-execution-contexts

class ExecutionContext {
  constructor() {
    this.codeEvaluationState = undefined;
    this.Function = undefined;
    this.Realm = undefined;
    this.ScriptOrModule = undefined;
    this.VariableEnvironment = undefined;
    this.LexicalEnvironment = undefined; // NON-SPEC

    this.callSite = new CallSite(this);
    this.promiseCapability = undefined;
  }

  copy() {
    const e = new ExecutionContext();
    e.codeEvaluationState = this.codeEvaluationState;
    e.Function = this.Function;
    e.Realm = this.Realm;
    e.ScriptOrModule = this.ScriptOrModule;
    e.VariableEnvironment = this.VariableEnvironment;
    e.LexicalEnvironment = this.LexicalEnvironment;
    e.callSite = this.callSite.clone(e);
    e.promiseCapability = this.promiseCapability;
    return e;
  }

} // 8.4.1 #sec-enqueuejob

function EnqueueJob(queueName, job, args) {
  const callerContext = surroundingAgent.runningExecutionContext;
  const callerRealm = callerContext.Realm;
  const callerScriptOrModule = callerContext.ScriptOrModule;
  const pending = {
    Job: job,
    Arguments: args,
    Realm: callerRealm,
    ScriptOrModule: callerScriptOrModule,
    HostDefined: undefined
  };
  surroundingAgent.jobQueue.push(pending);
} // 8.5 #sec-initializehostdefinedrealm

function ScriptEvaluation(scriptRecord) {
  const globalEnv = scriptRecord.Realm.GlobalEnv;
  const scriptContext = new ExecutionContext();
  scriptContext.Function = Value.null;
  scriptContext.Realm = scriptRecord.Realm;
  scriptContext.ScriptOrModule = scriptRecord;
  scriptContext.VariableEnvironment = globalEnv;
  scriptContext.LexicalEnvironment = globalEnv;
  scriptContext.HostDefined = scriptRecord.HostDefined; // Suspend runningExecutionContext

  surroundingAgent.executionContextStack.push(scriptContext);
  const scriptBody = scriptRecord.ECMAScriptCode.body;
  let result = EnsureCompletion(GlobalDeclarationInstantiation(scriptBody, globalEnv));

  if (result.Type === 'normal') {
    result = Evaluate_Script(scriptBody);
  }

  if (result.Type === 'normal' && !result.Value) {
    result = new NormalCompletion(Value.undefined);
  } // Suspend scriptCtx


  surroundingAgent.executionContextStack.pop(scriptContext); // Resume(surroundingAgent.runningExecutionContext);

  return result;
} // 15.1.12 #sec-scriptevaluationjob

function ScriptEvaluationJob(sourceText, hostDefined) {
  const realm = surroundingAgent.currentRealmRecord;
  const s = ParseScript(sourceText, realm, hostDefined);

  if (Array.isArray(s)) {
    HostReportErrors(s);
    return new NormalCompletion(undefined);
  }

  return ScriptEvaluation(s);
} // 15.2.1.22 #sec-toplevelmoduleevaluationjob


function HostReportErrors(errorList) {
  if (surroundingAgent.hostDefinedOptions.reportError) {
    errorList.forEach(error => {
      surroundingAgent.hostDefinedOptions.reportError(error);
    });
  }
}
function HostEnsureCanCompileStrings(callerRealm, calleeRealm) {
  if (surroundingAgent.hostDefinedOptions.ensureCanCompileStrings !== undefined) {
    let _temp2 = surroundingAgent.hostDefinedOptions.ensureCanCompileStrings(callerRealm, calleeRealm);
    /* istanbul ignore if */


    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }
    /* istanbul ignore if */


    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }
  }

  return new NormalCompletion(undefined);
}
function HostPromiseRejectionTracker(promise, operation) {
  const realm = surroundingAgent.currentRealmRecord;

  if (realm && realm.HostDefined.promiseRejectionTracker) {
    let _temp3 = realm.HostDefined.promiseRejectionTracker(promise, operation);

    Assert(!(_temp3 instanceof AbruptCompletion), "realm.HostDefined.promiseRejectionTracker(promise, operation)" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }
  }
}
function HostHasSourceTextAvailable(func) {
  if (surroundingAgent.hostDefinedOptions.hasSourceTextAvailable) {
    let _temp4 = surroundingAgent.hostDefinedOptions.hasSourceTextAvailable(func);

    Assert(!(_temp4 instanceof AbruptCompletion), "surroundingAgent.hostDefinedOptions.hasSourceTextAvailable(func)" + ' returned an abrupt completion');

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    return _temp4;
  }

  return Value.true;
}
function HostResolveImportedModule(referencingScriptOrModule, specifier) {
  const realm = referencingScriptOrModule.Realm || surroundingAgent.currentRealmRecord;

  if (realm.HostDefined.resolveImportedModule) {
    specifier = specifier.stringValue();

    if (referencingScriptOrModule !== Value.null) {
      if (!referencingScriptOrModule.HostDefined.moduleMap) {
        referencingScriptOrModule.HostDefined.moduleMap = new Map();
      }

      if (referencingScriptOrModule.HostDefined.moduleMap.has(specifier)) {
        return referencingScriptOrModule.HostDefined.moduleMap.get(specifier);
      }
    }

    const publicModule = referencingScriptOrModule.HostDefined ? referencingScriptOrModule.HostDefined.public : null;

    let _temp5 = realm.HostDefined.resolveImportedModule(publicModule, specifier);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const apiModule = _temp5;

    if (referencingScriptOrModule !== Value.null) {
      referencingScriptOrModule.HostDefined.moduleMap.set(specifier, apiModule.module);
    }

    return apiModule.module;
  }

  return surroundingAgent.Throw('Error', 'CouldNotResolveModule', specifier);
}

function FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion) {
  if (completion instanceof AbruptCompletion) {
    let _temp6 = Call(promiseCapability.Reject, Value.undefined, [completion.Value]);

    Assert(!(_temp6 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [completion.Value])" + ' returned an abrupt completion');

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
  } else {
    Assert(completion instanceof NormalCompletion, "completion instanceof NormalCompletion");

    let _temp7 = CreateBuiltinFunction(([v = Value.undefined]) => {
      Assert(v === Value.undefined, "v === Value.undefined");

      let _temp10 = HostResolveImportedModule(referencingScriptOrModule, specifier);

      Assert(!(_temp10 instanceof AbruptCompletion), "HostResolveImportedModule(referencingScriptOrModule, specifier)" + ' returned an abrupt completion');

      if (_temp10 instanceof Completion) {
        _temp10 = _temp10.Value;
      }

      const moduleRecord = _temp10; // Assert: Evaluate has already been invoked on moduleRecord and successfully completed.

      const namespace = EnsureCompletion(GetModuleNamespace(moduleRecord));

      if (namespace instanceof AbruptCompletion) {
        let _temp11 = Call(promiseCapability.Reject, Value.undefined, [namespace.Value]);

        Assert(!(_temp11 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [namespace.Value])" + ' returned an abrupt completion');

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }
      } else {
        let _temp12 = Call(promiseCapability.Resolve, Value.undefined, [namespace.Value]);

        Assert(!(_temp12 instanceof AbruptCompletion), "Call(promiseCapability.Resolve, Value.undefined, [namespace.Value])" + ' returned an abrupt completion');

        if (_temp12 instanceof Completion) {
          _temp12 = _temp12.Value;
        }
      }

      return Value.undefined;
    }, []);

    Assert(!(_temp7 instanceof AbruptCompletion), "CreateBuiltinFunction(([v = Value.undefined]) => {\n      Assert(v === Value.undefined);\n      const moduleRecord = X(HostResolveImportedModule(referencingScriptOrModule, specifier));\n      // Assert: Evaluate has already been invoked on moduleRecord and successfully completed.\n      const namespace = EnsureCompletion(GetModuleNamespace(moduleRecord));\n      if (namespace instanceof AbruptCompletion) {\n        X(Call(promiseCapability.Reject, Value.undefined, [namespace.Value]));\n      } else {\n        X(Call(promiseCapability.Resolve, Value.undefined, [namespace.Value]));\n      }\n      return Value.undefined;\n    }, [])" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    const onFulfilled = _temp7;

    let _temp8 = CreateBuiltinFunction(([r = Value.undefined]) => {
      let _temp13 = Call(promiseCapability.Reject, Value.undefined, [r]);

      Assert(!(_temp13 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [r])" + ' returned an abrupt completion');

      if (_temp13 instanceof Completion) {
        _temp13 = _temp13.Value;
      }
      return Value.undefined;
    }, []);

    Assert(!(_temp8 instanceof AbruptCompletion), "CreateBuiltinFunction(([r = Value.undefined]) => {\n      X(Call(promiseCapability.Reject, Value.undefined, [r]));\n      return Value.undefined;\n    }, [])" + ' returned an abrupt completion');

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }

    const onRejected = _temp8;

    let _temp9 = PerformPromiseThen(completion.Value, onFulfilled, onRejected);

    Assert(!(_temp9 instanceof AbruptCompletion), "PerformPromiseThen(completion.Value, onFulfilled, onRejected)" + ' returned an abrupt completion');

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }
  }
}

function HostImportModuleDynamically(referencingScriptOrModule, specifier, promiseCapability) {
  EnqueueJob('ImportModuleDynamicallyJobs', () => {
    let completion = EnsureCompletion(HostResolveImportedModule(referencingScriptOrModule, specifier));

    if (!(completion instanceof AbruptCompletion)) {
      const module = completion.Value;

      if (module instanceof CyclicModuleRecord) {
        if (module.HostDefined.cachedCompletion) {
          completion = module.HostDefined.cachedCompletion;
        } else {
          if (module.Status !== 'linking' && module.Status !== 'evaluating') {
            completion = EnsureCompletion(module.Link());
          }

          if (!(completion instanceof AbruptCompletion)) {
            completion = EnsureCompletion(module.Evaluate());
            module.HostDefined.cachedCompletion = completion;
          }
        }
      } else {
        completion = EnsureCompletion(module.Link());

        if (!(completion instanceof AbruptCompletion)) {
          completion = EnsureCompletion(module.Evaluate());
        }
      }
    }

    FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion);
  }, []);
  return new NormalCompletion(Value.undefined);
} // https://tc39.es/proposal-import-meta/#sec-hostgetimportmetaproperties

function HostGetImportMetaProperties(moduleRecord) {
  const realm = surroundingAgent.currentRealmRecord;

  if (realm.HostDefined.getImportMetaProperties) {
    let _temp14 = realm.HostDefined.getImportMetaProperties(moduleRecord.HostDefined.public);

    Assert(!(_temp14 instanceof AbruptCompletion), "realm.HostDefined.getImportMetaProperties(moduleRecord.HostDefined.public)" + ' returned an abrupt completion');

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    return _temp14;
  }

  return [];
} // https://tc39.es/proposal-import-meta/#sec-hostfinalizeimportmeta

function HostFinalizeImportMeta(importMeta, moduleRecord) {
  const realm = surroundingAgent.currentRealmRecord;

  if (realm.HostDefined.finalizeImportMeta) {
    let _temp15 = realm.HostDefined.finalizeImportMeta(importMeta, moduleRecord.HostDefined.public);

    Assert(!(_temp15 instanceof AbruptCompletion), "realm.HostDefined.finalizeImportMeta(importMeta, moduleRecord.HostDefined.public)" + ' returned an abrupt completion');

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    return _temp15;
  }

  return Value.undefined;
}

function Completion(type, value, target) {
  if (new.target === Completion) {
    if (typeof type !== 'string') {
      throw new TypeError('Completion type is not a string');
    }

    this.Type = type;
    this.Value = value;
    this.Target = target;
  }

  return type;
} // #sec-normalcompletion

function NormalCompletion(value) {
  return new Completion('normal', value);
}
Object.defineProperty(NormalCompletion, Symbol.hasInstance, {
  value: function hasInstance(v) {
    return v instanceof Completion && v.Type === 'normal';
  },
  writable: true,
  enumerable: false,
  configurable: true
});
class AbruptCompletion {
  static [Symbol.hasInstance](v) {
    return v instanceof Completion && v.Type !== 'normal';
  }

}
class BreakCompletion {
  constructor(target) {
    return new Completion('break', undefined, target);
  }

  static [Symbol.hasInstance](v) {
    return v instanceof Completion && v.Type === 'break';
  }

}
class ContinueCompletion {
  constructor(target) {
    return new Completion('continue', undefined, target);
  }

  static [Symbol.hasInstance](v) {
    return v instanceof Completion && v.Type === 'continue';
  }

} // 6.2.3.2 #sec-normalcompletion

class ReturnCompletion {
  constructor(value) {
    return new Completion('return', value);
  }

  static [Symbol.hasInstance](v) {
    return v instanceof Completion && v.Type === 'return';
  }

} // 6.2.3.3 #sec-throwcompletion

class ThrowCompletion {
  constructor(value) {
    return new Completion('throw', value);
  }

  static [Symbol.hasInstance](v) {
    return v instanceof Completion && v.Type === 'throw';
  }

} // 6.2.3.4 #sec-updateempty

function UpdateEmpty(completionRecord, value) {
  Assert(completionRecord instanceof Completion, "completionRecord instanceof Completion");

  if (completionRecord.Type === 'return' || completionRecord.Type === 'throw') {
    Assert(completionRecord.Value !== undefined, "completionRecord.Value !== undefined");
  }

  if (completionRecord.Value !== undefined) {
    return completionRecord;
  }

  return new Completion(completionRecord.Type, value, completionRecord.Target);
} // 5.2.3.3 #sec-returnifabrupt
function EnsureCompletion(val) {
  if (val instanceof Completion) {
    return val;
  }

  if (val instanceof Reference) {
    return val;
  }

  return new NormalCompletion(val);
}
function AwaitFulfilledFunctions([value]) {
  const F = surroundingAgent.activeFunctionObject;
  const asyncContext = F.AsyncContext;
  const prevContext = surroundingAgent.runningExecutionContext; // Suspend prevContext

  surroundingAgent.executionContextStack.push(asyncContext);
  resume(asyncContext, new NormalCompletion(value));
  Assert(surroundingAgent.runningExecutionContext === prevContext, "surroundingAgent.runningExecutionContext === prevContext");
  return Value.undefined;
}

function AwaitRejectedFunctions([reason]) {
  const F = surroundingAgent.activeFunctionObject;
  const asyncContext = F.AsyncContext;
  const prevContext = surroundingAgent.runningExecutionContext; // Suspend prevContext

  surroundingAgent.executionContextStack.push(asyncContext);
  resume(asyncContext, new ThrowCompletion(reason));
  Assert(surroundingAgent.runningExecutionContext === prevContext, "surroundingAgent.runningExecutionContext === prevContext");
  return Value.undefined;
}

function* Await(value) {
  const asyncContext = surroundingAgent.runningExecutionContext;

  let _temp = PromiseResolve(surroundingAgent.intrinsic('%Promise%'), value);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const promise = _temp;
  const stepsFulfilled = AwaitFulfilledFunctions;

  let _temp2 = CreateBuiltinFunction(stepsFulfilled, ['AsyncContext']);

  Assert(!(_temp2 instanceof AbruptCompletion), "CreateBuiltinFunction(stepsFulfilled, ['AsyncContext'])" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const onFulfilled = _temp2;

  let _temp3 = SetFunctionLength(onFulfilled, new Value(1));

  Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionLength(onFulfilled, new Value(1))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  onFulfilled.AsyncContext = asyncContext;
  const stepsRejected = AwaitRejectedFunctions;

  let _temp4 = CreateBuiltinFunction(stepsRejected, ['AsyncContext']);

  Assert(!(_temp4 instanceof AbruptCompletion), "CreateBuiltinFunction(stepsRejected, ['AsyncContext'])" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const onRejected = _temp4;

  let _temp5 = SetFunctionLength(onRejected, new Value(1));

  Assert(!(_temp5 instanceof AbruptCompletion), "SetFunctionLength(onRejected, new Value(1))" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }
  onRejected.AsyncContext = asyncContext;

  let _temp6 = PerformPromiseThen(promise, onFulfilled, onRejected);

  Assert(!(_temp6 instanceof AbruptCompletion), "PerformPromiseThen(promise, onFulfilled, onRejected)" + ' returned an abrupt completion');

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }
  surroundingAgent.executionContextStack.pop(asyncContext);
  const completion = yield Value.undefined;
  return completion;
}

function assignProps(realmRec, obj, props) {
  for (const item of props) {
    if (item === undefined) {
      continue;
    }

    const [n, v, len, descriptor] = item;
    const name = n instanceof Value ? n : new Value(n);

    if (Array.isArray(v)) {
      // Every accessor property described in clauses 18 through 26 and in
      // Annex B.2 has the attributes { [[Enumerable]]: false,
      // [[Configurable]]: true } unless otherwise specified. If only a get
      // accessor function is described, the set accessor function is the
      // default value, undefined. If only a set accessor is described the get
      // accessor is the default value, undefined.
      let [getter = Value.undefined, setter = Value.undefined] = v;

      if (typeof getter === 'function') {
        getter = CreateBuiltinFunction(getter, [], realmRec);

        let _temp = SetFunctionName(getter, name, new Value('get'));

        Assert(!(_temp instanceof AbruptCompletion), "SetFunctionName(getter, name, new Value('get'))" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }

        let _temp2 = SetFunctionLength(getter, new Value(0));

        Assert(!(_temp2 instanceof AbruptCompletion), "SetFunctionLength(getter, new Value(0))" + ' returned an abrupt completion');

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }
      }

      if (typeof setter === 'function') {
        setter = CreateBuiltinFunction(setter, [], realmRec);

        let _temp3 = SetFunctionName(setter, name, new Value('set'));

        Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionName(setter, name, new Value('set'))" + ' returned an abrupt completion');

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }

        let _temp4 = SetFunctionLength(setter, new Value(1));

        Assert(!(_temp4 instanceof AbruptCompletion), "SetFunctionLength(setter, new Value(1))" + ' returned an abrupt completion');

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }
      }

      let _temp5 = obj.DefineOwnProperty(name, Descriptor({
        Get: getter,
        Set: setter,
        Enumerable: Value.false,
        Configurable: Value.true,
        ...descriptor
      }));

      Assert(!(_temp5 instanceof AbruptCompletion), "obj.DefineOwnProperty(name, Descriptor({\n        Get: getter,\n        Set: setter,\n        Enumerable: Value.false,\n        Configurable: Value.true,\n        ...descriptor,\n      }))" + ' returned an abrupt completion');

      if (_temp5 instanceof Completion) {
        _temp5 = _temp5.Value;
      }
    } else {
      // Every other data property described in clauses 18 through 26 and in
      // Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]:
      // false, [[Configurable]]: true } unless otherwise specified.
      let value;

      if (typeof v === 'function') {
        Assert(typeof len === 'number', "typeof len === 'number'");
        value = CreateBuiltinFunction(v, [], realmRec);

        let _temp6 = SetFunctionName(value, name);

        Assert(!(_temp6 instanceof AbruptCompletion), "SetFunctionName(value, name)" + ' returned an abrupt completion');

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        let _temp7 = SetFunctionLength(value, new Value(len));

        Assert(!(_temp7 instanceof AbruptCompletion), "SetFunctionLength(value, new Value(len))" + ' returned an abrupt completion');

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }
      } else {
        value = v;
      }

      obj.properties.set(name, Descriptor({
        Value: value,
        Writable: Value.true,
        Enumerable: Value.false,
        Configurable: Value.true,
        ...descriptor
      }));
    }
  }
}
function BootstrapPrototype(realmRec, props, Prototype, stringTag) {
  Assert(Prototype !== undefined, "Prototype !== undefined");
  const proto = ObjectCreate(Prototype);
  assignProps(realmRec, proto, props);

  if (stringTag !== undefined) {
    let _temp8 = proto.DefineOwnProperty(wellKnownSymbols.toStringTag, Descriptor({
      Value: new Value(stringTag),
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }));

    Assert(!(_temp8 instanceof AbruptCompletion), "proto.DefineOwnProperty(wellKnownSymbols.toStringTag, Descriptor({\n      Value: new Value(stringTag),\n      Writable: Value.false,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    }))" + ' returned an abrupt completion');

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }
  }

  return proto;
}
function BootstrapConstructor(realmRec, Constructor, name, length, Prototype, props = []) {
  const cons = CreateBuiltinFunction(Constructor, [], realmRec, undefined, Value.true);
  SetFunctionName(cons, new Value(name));
  SetFunctionLength(cons, new Value(length));

  let _temp9 = cons.DefineOwnProperty(new Value('prototype'), Descriptor({
    Value: Prototype,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp9 instanceof AbruptCompletion), "cons.DefineOwnProperty(new Value('prototype'), Descriptor({\n    Value: Prototype,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  let _temp10 = Prototype.DefineOwnProperty(new Value('constructor'), Descriptor({
    Value: cons,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp10 instanceof AbruptCompletion), "Prototype.DefineOwnProperty(new Value('constructor'), Descriptor({\n    Value: cons,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }
  assignProps(realmRec, cons, props);
  return cons;
}

function ObjectProto_hasOwnProperty([V = Value.undefined], {
  thisValue
}) {
  let _temp = ToPropertyKey(V);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const P = _temp;

  let _temp2 = ToObject(thisValue);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const O = _temp2;
  return HasOwnProperty$1(O, P);
}

function ObjectProto_isPrototypeOf([V = Value.undefined], {
  thisValue
}) {
  if (Type(V) !== 'Object') {
    return Value.false;
  }

  let _temp3 = ToObject(thisValue);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const O = _temp3;

  while (true) {
    let _temp4 = V.GetPrototypeOf();

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    V = _temp4;

    if (Type(V) === 'Null') {
      return Value.false;
    }

    if (SameValue(O, V) === Value.true) {
      return Value.true;
    }
  }
}

function ObjectProto_propertyIsEnumerable([V = Value.undefined], {
  thisValue
}) {
  let _temp5 = ToPropertyKey(V);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const P = _temp5;

  let _temp6 = ToObject(thisValue);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const O = _temp6;

  let _temp7 = O.GetOwnProperty(P);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const desc = _temp7;

  if (Type(desc) === 'Undefined') {
    return Value.false;
  }

  return desc.Enumerable;
}

function ObjectProto_toLocaleString(argList, {
  thisValue
}) {
  const O = thisValue;
  return Invoke(O, new Value('toString'));
}

function ObjectProto_toString(argList, {
  thisValue
}) {
  if (Type(thisValue) === 'Undefined') {
    return new Value('[object Undefined]');
  }

  if (Type(thisValue) === 'Null') {
    return new Value('[object Null]');
  }

  let _temp8 = ToObject(thisValue);

  Assert(!(_temp8 instanceof AbruptCompletion), "ToObject(thisValue)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const O = _temp8;

  let _temp9 = IsArray(O);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const isArray = _temp9;
  let builtinTag;

  if (isArray === Value.true) {
    builtinTag = 'Array';
  } else if ('ParameterMap' in O) {
    builtinTag = 'Arguments';
  } else if ('Call' in O) {
    builtinTag = 'Function';
  } else if ('ErrorData' in O) {
    builtinTag = 'Error';
  } else if ('BooleanData' in O) {
    builtinTag = 'Boolean';
  } else if ('NumberData' in O) {
    builtinTag = 'Number';
  } else if ('StringData' in O) {
    builtinTag = 'String';
  } else if ('DateValue' in O) {
    builtinTag = 'Date';
  } else if ('RegExpMatcher' in O) {
    builtinTag = 'RegExp';
  } else {
    builtinTag = 'Object';
  }

  let _temp10 = Get(O, wellKnownSymbols.toStringTag);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  let tag = _temp10;

  if (Type(tag) !== 'String') {
    tag = builtinTag;
  }

  return new Value(`[object ${tag.stringValue ? tag.stringValue() : tag}]`);
}

function ObjectProto_valueOf(argList, {
  thisValue
}) {
  return ToObject(thisValue);
}

function CreateObjectPrototype(realmRec) {
  const proto = realmRec.Intrinsics['%Object.prototype%'];
  assignProps(realmRec, proto, [['hasOwnProperty', ObjectProto_hasOwnProperty, 1], ['isPrototypeOf', ObjectProto_isPrototypeOf, 1], ['propertyIsEnumerable', ObjectProto_propertyIsEnumerable, 1], ['toLocaleString', ObjectProto_toLocaleString, 0], ['toString', ObjectProto_toString, 0], ['valueOf', ObjectProto_valueOf, 0]]);

  let _temp11 = Get(proto, new Value('toString'));

  Assert(!(_temp11 instanceof AbruptCompletion), "Get(proto, new Value('toString'))" + ' returned an abrupt completion');

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  realmRec.Intrinsics['%Object.prototype.toString%'] = _temp11;

  let _temp12 = Get(proto, new Value('valueOf'));

  Assert(!(_temp12 instanceof AbruptCompletion), "Get(proto, new Value('valueOf'))" + ' returned an abrupt completion');

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  realmRec.Intrinsics['%Object.prototype.valueOf%'] = _temp12;
}

function AddEntriesFromIterable(target, iterable, adder) {
  if (IsCallable(adder) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', adder);
  }

  Assert(iterable && Type(iterable) !== 'Undefined' && Type(iterable) !== 'Null', "iterable && Type(iterable) !== 'Undefined' && Type(iterable) !== 'Null'");

  let _temp = GetIterator(iterable);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const iteratorRecord = _temp;

  while (true) {
    let _temp2 = IteratorStep(iteratorRecord);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const next = _temp2;

    if (next === Value.false) {
      return target;
    }

    let _temp3 = IteratorValue(next);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const nextItem = _temp3;

    if (Type(nextItem) !== 'Object') {
      const error = new ThrowCompletion(surroundingAgent.Throw('TypeError', 'NotAnObject', nextItem).Value);
      return IteratorClose(iteratorRecord, error);
    }

    const k = Get(nextItem, new Value('0'));

    if (k instanceof AbruptCompletion) {
      return IteratorClose(iteratorRecord, k);
    }

    const v = Get(nextItem, new Value('1'));

    if (v instanceof AbruptCompletion) {
      return IteratorClose(iteratorRecord, v);
    }

    const status = Call(adder, target, [k.Value, v.Value]);

    if (status instanceof AbruptCompletion) {
      return IteratorClose(iteratorRecord, status);
    }
  }
}

function MapConstructor([iterable = Value.undefined], {
  NewTarget
}) {
  if (NewTarget === Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', 'Map');
  }

  let _temp4 = OrdinaryCreateFromConstructor(NewTarget, '%Map.prototype%', ['MapData']);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const map = _temp4;
  map.MapData = [];

  if (iterable === Value.undefined || iterable === Value.null) {
    return map;
  }

  let _temp5 = Get(map, new Value('set'));

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const adder = _temp5;
  return AddEntriesFromIterable(map, iterable, adder);
}

function Map_speciesGetter(args, {
  thisValue
}) {
  return thisValue;
}

function CreateMap(realmRec) {
  const mapConstructor = BootstrapConstructor(realmRec, MapConstructor, 'Map', 0, realmRec.Intrinsics['%Map.prototype%'], [[wellKnownSymbols.species, [Map_speciesGetter]]]);
  realmRec.Intrinsics['%Map%'] = mapConstructor;
}

function ObjectConstructor([value = Value.undefined], {
  NewTarget
}) {
  if (NewTarget !== Value.undefined && NewTarget !== surroundingAgent.activeFunctionObject) {
    return OrdinaryCreateFromConstructor(NewTarget, '%Object.prototype%');
  }

  if (value === Value.null || value === Value.undefined) {
    return ObjectCreate(surroundingAgent.currentRealmRecord.Intrinsics['%Object.prototype%']);
  }

  let _temp = ToObject(value);

  Assert(!(_temp instanceof AbruptCompletion), "ToObject(value)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  return _temp;
}

function Object_assign([target = Value.undefined, ...sources]) {
  let _temp2 = ToObject(target);
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const to = _temp2;

  if (sources.length === 0) {
    return to;
  } // Let sources be the List of argument values starting with the second argument.


  for (const nextSource of sources) {
    if (Type(nextSource) !== 'Undefined' && Type(nextSource) !== 'Null') {
      let _temp3 = ToObject(nextSource);

      Assert(!(_temp3 instanceof AbruptCompletion), "ToObject(nextSource)" + ' returned an abrupt completion');

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      const from = _temp3;

      let _temp4 = from.OwnPropertyKeys();

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      const keys = _temp4;

      for (const nextKey of keys) {
        let _temp5 = from.GetOwnProperty(nextKey);

        if (_temp5 instanceof AbruptCompletion) {
          return _temp5;
        }

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }

        const desc = _temp5;

        if (Type(desc) !== 'Undefined' && desc.Enumerable === Value.true) {
          let _temp6 = Get(from, nextKey);

          if (_temp6 instanceof AbruptCompletion) {
            return _temp6;
          }

          if (_temp6 instanceof Completion) {
            _temp6 = _temp6.Value;
          }

          const propValue = _temp6;

          let _temp7 = Set$1(to, nextKey, propValue, Value.true);

          if (_temp7 instanceof AbruptCompletion) {
            return _temp7;
          }

          if (_temp7 instanceof Completion) {
            _temp7 = _temp7.Value;
          }
        }
      }
    }
  }

  return to;
}

function Object_create([O = Value.undefined, Properties = Value.undefined]) {
  if (Type(O) !== 'Object' && Type(O) !== 'Null') {
    return surroundingAgent.Throw('TypeError', 'ObjectPrototypeType');
  }

  const obj = ObjectCreate(O);

  if (Properties !== Value.undefined) {
    return ObjectDefineProperties(obj, Properties);
  }

  return obj;
}

function Object_defineProperties([O = Value.undefined, Properties = Value.undefined]) {
  return ObjectDefineProperties(O, Properties);
} // #sec-objectdefineproperties ObjectDefineProperties


function ObjectDefineProperties(O, Properties) {
  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }

  let _temp8 = ToObject(Properties);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const props = _temp8;

  let _temp9 = props.OwnPropertyKeys();

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const keys = _temp9;
  const descriptors = [];

  for (const nextKey of keys) {
    let _temp10 = props.GetOwnProperty(nextKey);

    if (_temp10 instanceof AbruptCompletion) {
      return _temp10;
    }

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }

    const propDesc = _temp10;

    if (propDesc !== Value.undefined && propDesc.Enumerable === Value.true) {
      let _temp11 = Get(props, nextKey);

      if (_temp11 instanceof AbruptCompletion) {
        return _temp11;
      }

      if (_temp11 instanceof Completion) {
        _temp11 = _temp11.Value;
      }

      const descObj = _temp11;

      let _temp12 = ToPropertyDescriptor(descObj);

      if (_temp12 instanceof AbruptCompletion) {
        return _temp12;
      }

      if (_temp12 instanceof Completion) {
        _temp12 = _temp12.Value;
      }

      const desc = _temp12;
      descriptors.push([nextKey, desc]);
    }
  }

  for (const pair of descriptors) {
    const P = pair[0];
    const desc = pair[1];

    let _temp13 = DefinePropertyOrThrow(O, P, desc);

    if (_temp13 instanceof AbruptCompletion) {
      return _temp13;
    }

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }
  }

  return O;
}

function Object_defineProperty([O = Value.undefined, P = Value.undefined, Attributes = Value.undefined]) {
  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }

  let _temp14 = ToPropertyKey(P);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const key = _temp14;

  let _temp15 = ToPropertyDescriptor(Attributes);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const desc = _temp15;

  let _temp16 = DefinePropertyOrThrow(O, key, desc);

  if (_temp16 instanceof AbruptCompletion) {
    return _temp16;
  }

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }
  return O;
}

function Object_entries([O = Value.undefined]) {
  let _temp17 = ToObject(O);

  if (_temp17 instanceof AbruptCompletion) {
    return _temp17;
  }

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  const obj = _temp17;

  let _temp18 = EnumerableOwnPropertyNames(obj, 'key+value');

  if (_temp18 instanceof AbruptCompletion) {
    return _temp18;
  }

  if (_temp18 instanceof Completion) {
    _temp18 = _temp18.Value;
  }

  const nameList = _temp18;
  return CreateArrayFromList(nameList);
}

function Object_freeze([O = Value.undefined]) {
  if (Type(O) !== 'Object') {
    return O;
  }

  let _temp19 = SetIntegrityLevel(O, 'frozen');

  if (_temp19 instanceof AbruptCompletion) {
    return _temp19;
  }

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  const status = _temp19;

  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'UnableToFreeze', O);
  }

  return O;
}

function CreateDataPropertyOnObjectFunctions([key, value], {
  thisValue
}) {
  const O = thisValue;
  Assert(Type(O) === 'Object', "Type(O) === 'Object'");
  Assert(O.Extensible === Value.true, "O.Extensible === Value.true");

  let _temp20 = ToPropertyKey(key);

  if (_temp20 instanceof AbruptCompletion) {
    return _temp20;
  }

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }

  const propertyKey = _temp20;

  let _temp21 = CreateDataPropertyOrThrow(O, propertyKey, value);

  Assert(!(_temp21 instanceof AbruptCompletion), "CreateDataPropertyOrThrow(O, propertyKey, value)" + ' returned an abrupt completion');

  if (_temp21 instanceof Completion) {
    _temp21 = _temp21.Value;
  }
}

function Object_fromEntries([iterable = Value.undefined]) {
  let _temp22 = RequireObjectCoercible(iterable);

  if (_temp22 instanceof AbruptCompletion) {
    return _temp22;
  }

  if (_temp22 instanceof Completion) {
    _temp22 = _temp22.Value;
  }
  const obj = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  Assert(obj.Extensible === Value.true && obj.properties.size === 0, "obj.Extensible === Value.true && obj.properties.size === 0");
  const stepsDefine = CreateDataPropertyOnObjectFunctions;

  let _temp23 = CreateBuiltinFunction(stepsDefine, []);

  Assert(!(_temp23 instanceof AbruptCompletion), "CreateBuiltinFunction(stepsDefine, [])" + ' returned an abrupt completion');

  if (_temp23 instanceof Completion) {
    _temp23 = _temp23.Value;
  }

  const adder = _temp23;
  return AddEntriesFromIterable(obj, iterable, adder);
}

function Object_getOwnPropertyDescriptor([O = Value.undefined, P = Value.undefined]) {
  let _temp24 = ToObject(O);

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  const obj = _temp24;

  let _temp25 = ToPropertyKey(P);

  if (_temp25 instanceof AbruptCompletion) {
    return _temp25;
  }

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }

  const key = _temp25;

  let _temp26 = obj.GetOwnProperty(key);

  if (_temp26 instanceof AbruptCompletion) {
    return _temp26;
  }

  if (_temp26 instanceof Completion) {
    _temp26 = _temp26.Value;
  }

  const desc = _temp26;
  return FromPropertyDescriptor(desc);
}

function Object_getOwnPropertyDescriptors([O = Value.undefined]) {
  let _temp27 = ToObject(O);

  if (_temp27 instanceof AbruptCompletion) {
    return _temp27;
  }

  if (_temp27 instanceof Completion) {
    _temp27 = _temp27.Value;
  }

  const obj = _temp27;

  let _temp28 = obj.OwnPropertyKeys();

  if (_temp28 instanceof AbruptCompletion) {
    return _temp28;
  }

  if (_temp28 instanceof Completion) {
    _temp28 = _temp28.Value;
  }

  const ownKeys = _temp28;

  let _temp29 = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  Assert(!(_temp29 instanceof AbruptCompletion), "ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'))" + ' returned an abrupt completion');

  if (_temp29 instanceof Completion) {
    _temp29 = _temp29.Value;
  }

  const descriptors = _temp29;

  for (const key of ownKeys) {
    let _temp30 = obj.GetOwnProperty(key);

    if (_temp30 instanceof AbruptCompletion) {
      return _temp30;
    }

    if (_temp30 instanceof Completion) {
      _temp30 = _temp30.Value;
    }

    const desc = _temp30;

    let _temp31 = FromPropertyDescriptor(desc);

    Assert(!(_temp31 instanceof AbruptCompletion), "FromPropertyDescriptor(desc)" + ' returned an abrupt completion');

    if (_temp31 instanceof Completion) {
      _temp31 = _temp31.Value;
    }

    const descriptor = _temp31;

    if (descriptor !== Value.undefined) {
      let _temp32 = CreateDataProperty(descriptors, key, descriptor);

      Assert(!(_temp32 instanceof AbruptCompletion), "CreateDataProperty(descriptors, key, descriptor)" + ' returned an abrupt completion');

      if (_temp32 instanceof Completion) {
        _temp32 = _temp32.Value;
      }
    }
  }

  return descriptors;
}

function GetOwnPropertyKeys(O, type) {
  let _temp33 = ToObject(O);

  if (_temp33 instanceof AbruptCompletion) {
    return _temp33;
  }

  if (_temp33 instanceof Completion) {
    _temp33 = _temp33.Value;
  }

  const obj = _temp33;

  let _temp34 = obj.OwnPropertyKeys();

  if (_temp34 instanceof AbruptCompletion) {
    return _temp34;
  }

  if (_temp34 instanceof Completion) {
    _temp34 = _temp34.Value;
  }

  const keys = _temp34;
  const nameList = [];
  keys.forEach(nextKey => {
    if (Type(nextKey) === type) {
      nameList.push(nextKey);
    }
  });
  return CreateArrayFromList(nameList);
}

function Object_getOwnPropertyNames([O = Value.undefined]) {
  return GetOwnPropertyKeys(O, 'String');
}

function Object_getOwnPropertySymbols([O = Value.undefined]) {
  return GetOwnPropertyKeys(O, 'Symbol');
}

function Object_getPrototypeOf([O = Value.undefined]) {
  let _temp35 = ToObject(O);

  if (_temp35 instanceof AbruptCompletion) {
    return _temp35;
  }

  if (_temp35 instanceof Completion) {
    _temp35 = _temp35.Value;
  }

  const obj = _temp35;
  return obj.GetPrototypeOf();
}

function Object_is([value1 = Value.undefined, value2 = Value.undefined]) {
  return SameValue(value1, value2);
}

function Object_isExtensible([O = Value.undefined]) {
  if (Type(O) !== 'Object') {
    return Value.false;
  }

  return IsExtensible(O);
}

function Object_isFrozen([O = Value.undefined]) {
  if (Type(O) !== 'Object') {
    return Value.true;
  }

  return TestIntegrityLevel(O, 'frozen');
}

function Object_isSealed([O = Value.undefined]) {
  if (Type(O) !== 'Object') {
    return Value.true;
  }

  return TestIntegrityLevel(O, 'sealed');
}

function Object_keys([O = Value.undefined]) {
  let _temp36 = ToObject(O);

  if (_temp36 instanceof AbruptCompletion) {
    return _temp36;
  }

  if (_temp36 instanceof Completion) {
    _temp36 = _temp36.Value;
  }

  const obj = _temp36;

  let _temp37 = EnumerableOwnPropertyNames(obj, 'key');

  if (_temp37 instanceof AbruptCompletion) {
    return _temp37;
  }

  if (_temp37 instanceof Completion) {
    _temp37 = _temp37.Value;
  }

  const nameList = _temp37;
  return CreateArrayFromList(nameList);
}

function Object_preventExtensions([O = Value.undefined]) {
  if (Type(O) !== 'Object') {
    return O;
  }

  let _temp38 = O.PreventExtensions();

  if (_temp38 instanceof AbruptCompletion) {
    return _temp38;
  }

  if (_temp38 instanceof Completion) {
    _temp38 = _temp38.Value;
  }

  const status = _temp38;

  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'UnableToPreventExtensions', O);
  }

  return O;
}

function Object_seal([O = Value.undefined]) {
  if (Type(O) !== 'Object') {
    return O;
  }

  let _temp39 = SetIntegrityLevel(O, 'sealed');

  if (_temp39 instanceof AbruptCompletion) {
    return _temp39;
  }

  if (_temp39 instanceof Completion) {
    _temp39 = _temp39.Value;
  }

  const status = _temp39;

  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'UnableToSeal', O);
  }

  return O;
}

function Object_setPrototypeOf([O = Value.undefined, proto = Value.undefined]) {
  let _temp40 = RequireObjectCoercible(O);

  if (_temp40 instanceof AbruptCompletion) {
    return _temp40;
  }

  if (_temp40 instanceof Completion) {
    _temp40 = _temp40.Value;
  }

  O = _temp40;

  if (Type(proto) !== 'Object' && Type(proto) !== 'Null') {
    return surroundingAgent.Throw('TypeError', 'ObjectPrototypeType');
  }

  if (Type(O) !== 'Object') {
    return O;
  }

  let _temp41 = O.SetPrototypeOf(proto);

  if (_temp41 instanceof AbruptCompletion) {
    return _temp41;
  }

  if (_temp41 instanceof Completion) {
    _temp41 = _temp41.Value;
  }

  const status = _temp41;

  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'ObjectSetPrototype');
  }

  return O;
}

function Object_values([O = Value.undefined]) {
  let _temp42 = ToObject(O);

  if (_temp42 instanceof AbruptCompletion) {
    return _temp42;
  }

  if (_temp42 instanceof Completion) {
    _temp42 = _temp42.Value;
  }

  const obj = _temp42;

  let _temp43 = EnumerableOwnPropertyNames(obj, 'value');

  if (_temp43 instanceof AbruptCompletion) {
    return _temp43;
  }

  if (_temp43 instanceof Completion) {
    _temp43 = _temp43.Value;
  }

  const nameList = _temp43;
  return CreateArrayFromList(nameList);
}

function CreateObject(realmRec) {
  const objectConstructor = BootstrapConstructor(realmRec, ObjectConstructor, 'Object', 1, realmRec.Intrinsics['%Object.prototype%'], [['assign', Object_assign, 2], ['create', Object_create, 2], ['defineProperties', Object_defineProperties, 2], ['defineProperty', Object_defineProperty, 3], ['entries', Object_entries, 1], ['freeze', Object_freeze, 1], ['fromEntries', Object_fromEntries, 1], ['getOwnPropertyDescriptor', Object_getOwnPropertyDescriptor, 2], ['getOwnPropertyDescriptors', Object_getOwnPropertyDescriptors, 1], ['getOwnPropertyNames', Object_getOwnPropertyNames, 1], ['getOwnPropertySymbols', Object_getOwnPropertySymbols, 1], ['getPrototypeOf', Object_getPrototypeOf, 1], ['is', Object_is, 2], ['isExtensible', Object_isExtensible, 1], ['isFrozen', Object_isFrozen, 1], ['isSealed', Object_isSealed, 1], ['keys', Object_keys, 1], ['preventExtensions', Object_preventExtensions, 1], ['seal', Object_seal, 1], ['setPrototypeOf', Object_setPrototypeOf, 2], ['values', Object_values, 1]]);
  realmRec.Intrinsics['%Object%'] = objectConstructor;
}

// %TypedArray.prototype%.
// 22.1.3.27 #sec-array.prototype.sort
// 22.2.3.26 #sec-%typedarray%.prototype.sort
//
// If internalMethodsRestricted is true, then Asserts are used to ensure that
// "The only internal methods of the this object that the algorithm may call
// are [[Get]] and [[Set]]," a requirement of %TypedArray%.prototype.sort.

function ArrayProto_sortBody(obj, len, SortCompare, internalMethodsRestricted = false) {
  len = len.numberValue(); // Collect all elements. Count how many holes we have for error checking.

  const collected = [];
  let holes = 0;

  for (let k = 0; k < len; k += 1) {
    let _temp = ToString(new Value(k));

    Assert(!(_temp instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const curProp = _temp;

    let _temp2 = Get(obj, curProp);
    /* istanbul ignore if */


    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }
    /* istanbul ignore if */


    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const prop = _temp2;

    if (prop === Value.undefined) {
      Assert(!internalMethodsRestricted, "!internalMethodsRestricted");

      let _temp3 = HasOwnProperty$1(obj, curProp);

      if (_temp3 instanceof AbruptCompletion) {
        return _temp3;
      }

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      const hasOwn = _temp3;

      if (hasOwn === Value.false) {
        holes += 1;
      } else {
        collected.push(prop);
      }
    } else {
      collected.push(prop);
    }
  }

  if (internalMethodsRestricted) {
    Assert(holes === 0, "holes === 0");
  }

  Assert(collected.length + holes === len, "collected.length + holes === len"); // Get rid of holes by deleting properties at the end.
  // See Note 1: Because non-existent property values always compare greater
  // than undefined property values, and undefined always compares greater
  // than any other value, undefined property values always sort to the end
  // of the result, followed by non-existent property values.

  for (let k = collected.length; k < len; k += 1) {
    let _temp4 = ToString(new Value(k));

    Assert(!(_temp4 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const curProp = _temp4;

    let _temp5 = DeletePropertyOrThrow(obj, curProp);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }
  } // Mergesort.


  const lBuffer = [];
  const rBuffer = [];

  for (let step = 1; step < collected.length; step *= 2) {
    for (let start = 0; start < collected.length - 1; start += 2 * step) {
      const sizeLeft = step;
      const mid = start + sizeLeft;
      const sizeRight = Math.min(step, collected.length - mid);

      if (sizeRight < 0) {
        continue;
      } // Merge.


      for (let l = 0; l < sizeLeft; l += 1) {
        lBuffer[l] = collected[start + l];
      }

      for (let r = 0; r < sizeRight; r += 1) {
        rBuffer[r] = collected[mid + r];
      }

      {
        let l = 0;
        let r = 0;
        let o = start;

        while (l < sizeLeft && r < sizeRight) {
          let _temp6 = SortCompare(lBuffer[l], rBuffer[r]);

          if (_temp6 instanceof AbruptCompletion) {
            return _temp6;
          }

          if (_temp6 instanceof Completion) {
            _temp6 = _temp6.Value;
          }

          const cmp = _temp6.numberValue();

          if (cmp <= 0) {
            collected[o] = lBuffer[l];
            o += 1;
            l += 1;
          } else {
            collected[o] = rBuffer[r];
            o += 1;
            r += 1;
          }
        }

        while (l < sizeLeft) {
          collected[o] = lBuffer[l];
          o += 1;
          l += 1;
        }

        while (r < sizeRight) {
          collected[o] = rBuffer[r];
          o += 1;
          r += 1;
        }
      }
    }
  } // Copy the sorted results back to the array.


  for (let k = 0; k < collected.length; k += 1) {
    let _temp7 = ToString(new Value(k));

    Assert(!(_temp7 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    const curProp = _temp7;

    let _temp8 = Set$1(obj, curProp, collected[k], Value.true);

    if (_temp8 instanceof AbruptCompletion) {
      return _temp8;
    }

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }
  }

  return obj;
}
function CreateArrayPrototypeShared(realmRec, proto, priorToEvaluatingAlgorithm, objectToLength) {
  // 22.1.3.5 #sec-array.prototype.every
  // 22.2.3.7 #sec-%typedarray%.prototype.every
  function ArrayProto_every([callbackFn = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    let _temp9 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp9 instanceof AbruptCompletion) {
      return _temp9;
    }

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }

    let _temp10 = ToObject(thisValue);

    if (_temp10 instanceof AbruptCompletion) {
      return _temp10;
    }

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }

    const O = _temp10;

    let _temp11 = objectToLength(O);

    if (_temp11 instanceof AbruptCompletion) {
      return _temp11;
    }

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    const lenProp = _temp11;

    let _temp12 = ToLength(lenProp);

    if (_temp12 instanceof AbruptCompletion) {
      return _temp12;
    }

    if (_temp12 instanceof Completion) {
      _temp12 = _temp12.Value;
    }

    const len = _temp12;

    if (IsCallable(callbackFn) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackFn);
    }

    let k = 0;

    while (k < len.numberValue()) {
      let _temp13 = ToString(new Value(k));

      Assert(!(_temp13 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp13 instanceof Completion) {
        _temp13 = _temp13.Value;
      }

      const Pk = _temp13;

      let _temp14 = HasProperty(O, Pk);

      if (_temp14 instanceof AbruptCompletion) {
        return _temp14;
      }

      if (_temp14 instanceof Completion) {
        _temp14 = _temp14.Value;
      }

      const kPresent = _temp14;

      if (kPresent === Value.true) {
        let _temp15 = Get(O, Pk);

        if (_temp15 instanceof AbruptCompletion) {
          return _temp15;
        }

        if (_temp15 instanceof Completion) {
          _temp15 = _temp15.Value;
        }

        const kValue = _temp15;

        let _temp16 = Call(callbackFn, thisArg, [kValue, new Value(k), O]);

        if (_temp16 instanceof AbruptCompletion) {
          return _temp16;
        }

        if (_temp16 instanceof Completion) {
          _temp16 = _temp16.Value;
        }

        const testResult = ToBoolean(_temp16);

        if (testResult === Value.false) {
          return Value.false;
        }
      }

      k += 1;
    }

    return Value.true;
  } // 22.1.3.8 #sec-array.prototype.find
  // 22.2.3.10 #sec-%typedarray%.prototype.find


  function ArrayProto_find([predicate = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    let _temp17 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp17 instanceof AbruptCompletion) {
      return _temp17;
    }

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    let _temp18 = ToObject(thisValue);

    if (_temp18 instanceof AbruptCompletion) {
      return _temp18;
    }

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }

    const O = _temp18;

    let _temp19 = objectToLength(O);

    if (_temp19 instanceof AbruptCompletion) {
      return _temp19;
    }

    if (_temp19 instanceof Completion) {
      _temp19 = _temp19.Value;
    }

    const lenProp = _temp19;

    let _temp20 = ToLength(lenProp);

    if (_temp20 instanceof AbruptCompletion) {
      return _temp20;
    }

    if (_temp20 instanceof Completion) {
      _temp20 = _temp20.Value;
    }

    const len = _temp20.numberValue();

    if (IsCallable(predicate) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    }

    let k = 0;

    while (k < len) {
      let _temp21 = ToString(new Value(k));

      Assert(!(_temp21 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp21 instanceof Completion) {
        _temp21 = _temp21.Value;
      }

      const Pk = _temp21;

      let _temp22 = Get(O, Pk);

      if (_temp22 instanceof AbruptCompletion) {
        return _temp22;
      }

      if (_temp22 instanceof Completion) {
        _temp22 = _temp22.Value;
      }

      const kValue = _temp22;

      let _temp23 = Call(predicate, thisArg, [kValue, new Value(k), O]);

      if (_temp23 instanceof AbruptCompletion) {
        return _temp23;
      }

      if (_temp23 instanceof Completion) {
        _temp23 = _temp23.Value;
      }

      const testResult = ToBoolean(_temp23);

      if (testResult === Value.true) {
        return kValue;
      }

      k += 1;
    }

    return Value.undefined;
  } // 22.1.3.9 #sec-array.prototype.findindex
  // 22.2.3.11 #sec-%typedarray%.prototype.findindex


  function ArrayProto_findIndex([predicate = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    let _temp24 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp24 instanceof AbruptCompletion) {
      return _temp24;
    }

    if (_temp24 instanceof Completion) {
      _temp24 = _temp24.Value;
    }

    let _temp25 = ToObject(thisValue);

    if (_temp25 instanceof AbruptCompletion) {
      return _temp25;
    }

    if (_temp25 instanceof Completion) {
      _temp25 = _temp25.Value;
    }

    const O = _temp25;

    let _temp26 = objectToLength(O);

    if (_temp26 instanceof AbruptCompletion) {
      return _temp26;
    }

    if (_temp26 instanceof Completion) {
      _temp26 = _temp26.Value;
    }

    const lenProp = _temp26;

    let _temp27 = ToLength(lenProp);

    if (_temp27 instanceof AbruptCompletion) {
      return _temp27;
    }

    if (_temp27 instanceof Completion) {
      _temp27 = _temp27.Value;
    }

    const len = _temp27.numberValue();

    if (IsCallable(predicate) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    }

    let k = 0;

    while (k < len) {
      let _temp28 = ToString(new Value(k));

      Assert(!(_temp28 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp28 instanceof Completion) {
        _temp28 = _temp28.Value;
      }

      const Pk = _temp28;

      let _temp29 = Get(O, Pk);

      if (_temp29 instanceof AbruptCompletion) {
        return _temp29;
      }

      if (_temp29 instanceof Completion) {
        _temp29 = _temp29.Value;
      }

      const kValue = _temp29;

      let _temp30 = Call(predicate, thisArg, [kValue, new Value(k), O]);

      if (_temp30 instanceof AbruptCompletion) {
        return _temp30;
      }

      if (_temp30 instanceof Completion) {
        _temp30 = _temp30.Value;
      }

      const testResult = ToBoolean(_temp30);

      if (testResult === Value.true) {
        return new Value(k);
      }

      k += 1;
    }

    return new Value(-1);
  } // 22.1.3.12 #sec-array.prototype.foreach
  // 22.2.3.12 #sec-%typedarray%.prototype.foreach


  function ArrayProto_forEach([callbackfn = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    let _temp31 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp31 instanceof AbruptCompletion) {
      return _temp31;
    }

    if (_temp31 instanceof Completion) {
      _temp31 = _temp31.Value;
    }

    let _temp32 = ToObject(thisValue);

    if (_temp32 instanceof AbruptCompletion) {
      return _temp32;
    }

    if (_temp32 instanceof Completion) {
      _temp32 = _temp32.Value;
    }

    const O = _temp32;

    let _temp33 = objectToLength(O);

    if (_temp33 instanceof AbruptCompletion) {
      return _temp33;
    }

    if (_temp33 instanceof Completion) {
      _temp33 = _temp33.Value;
    }

    const lenProp = _temp33;

    let _temp34 = ToLength(lenProp);

    if (_temp34 instanceof AbruptCompletion) {
      return _temp34;
    }

    if (_temp34 instanceof Completion) {
      _temp34 = _temp34.Value;
    }

    const len = _temp34.numberValue();

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
    }

    let k = 0;

    while (k < len) {
      let _temp35 = ToString(new Value(k));

      Assert(!(_temp35 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp35 instanceof Completion) {
        _temp35 = _temp35.Value;
      }

      const Pk = _temp35;

      let _temp36 = HasProperty(O, Pk);

      if (_temp36 instanceof AbruptCompletion) {
        return _temp36;
      }

      if (_temp36 instanceof Completion) {
        _temp36 = _temp36.Value;
      }

      const kPresent = _temp36;

      if (kPresent === Value.true) {
        let _temp37 = Get(O, Pk);

        if (_temp37 instanceof AbruptCompletion) {
          return _temp37;
        }

        if (_temp37 instanceof Completion) {
          _temp37 = _temp37.Value;
        }

        const kValue = _temp37;

        let _temp38 = Call(callbackfn, thisArg, [kValue, new Value(k), O]);

        if (_temp38 instanceof AbruptCompletion) {
          return _temp38;
        }

        if (_temp38 instanceof Completion) {
          _temp38 = _temp38.Value;
        }
      }

      k += 1;
    }

    return Value.undefined;
  } // 22.1.3.13 #sec-array.prototype.includes
  // 22.2.3.13 #sec-%typedarray%.prototype.includes


  function ArrayProto_includes([searchElement = Value.undefined, fromIndex = Value.undefined], {
    thisValue
  }) {
    let _temp39 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp39 instanceof AbruptCompletion) {
      return _temp39;
    }

    if (_temp39 instanceof Completion) {
      _temp39 = _temp39.Value;
    }

    let _temp40 = ToObject(thisValue);

    if (_temp40 instanceof AbruptCompletion) {
      return _temp40;
    }

    if (_temp40 instanceof Completion) {
      _temp40 = _temp40.Value;
    }

    const O = _temp40;

    let _temp41 = objectToLength(O);

    if (_temp41 instanceof AbruptCompletion) {
      return _temp41;
    }

    if (_temp41 instanceof Completion) {
      _temp41 = _temp41.Value;
    }

    const lenProp = _temp41;

    let _temp42 = ToLength(lenProp);

    if (_temp42 instanceof AbruptCompletion) {
      return _temp42;
    }

    if (_temp42 instanceof Completion) {
      _temp42 = _temp42.Value;
    }

    const len = _temp42.numberValue();

    if (len === 0) {
      return Value.false;
    }

    let _temp43 = ToInteger(fromIndex);

    if (_temp43 instanceof AbruptCompletion) {
      return _temp43;
    }

    if (_temp43 instanceof Completion) {
      _temp43 = _temp43.Value;
    }

    const n = _temp43.numberValue();

    if (fromIndex === Value.undefined) {
      Assert(n === 0, "n === 0");
    }

    let k;

    if (n >= 0) {
      k = n;
    } else {
      k = len + n;

      if (k < 0) {
        k = 0;
      }
    }

    while (k < len) {
      let _temp44 = ToString(new Value(k));

      Assert(!(_temp44 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp44 instanceof Completion) {
        _temp44 = _temp44.Value;
      }

      const kStr = _temp44;

      let _temp45 = Get(O, kStr);

      if (_temp45 instanceof AbruptCompletion) {
        return _temp45;
      }

      if (_temp45 instanceof Completion) {
        _temp45 = _temp45.Value;
      }

      const elementK = _temp45;

      if (SameValueZero(searchElement, elementK) === Value.true) {
        return Value.true;
      }

      k += 1;
    }

    return Value.false;
  } // 22.1.3.14 #sec-array.prototype.indexof
  // 22.2.3.14 #sec-%typedarray%.prototype.indexof


  function ArrayProto_indexOf([searchElement = Value.undefined, fromIndex = Value.undefined], {
    thisValue
  }) {
    let _temp46 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp46 instanceof AbruptCompletion) {
      return _temp46;
    }

    if (_temp46 instanceof Completion) {
      _temp46 = _temp46.Value;
    }

    let _temp47 = ToObject(thisValue);

    if (_temp47 instanceof AbruptCompletion) {
      return _temp47;
    }

    if (_temp47 instanceof Completion) {
      _temp47 = _temp47.Value;
    }

    const O = _temp47;

    let _temp48 = objectToLength(O);

    if (_temp48 instanceof AbruptCompletion) {
      return _temp48;
    }

    if (_temp48 instanceof Completion) {
      _temp48 = _temp48.Value;
    }

    const lenProp = _temp48;

    let _temp49 = ToLength(lenProp);

    if (_temp49 instanceof AbruptCompletion) {
      return _temp49;
    }

    if (_temp49 instanceof Completion) {
      _temp49 = _temp49.Value;
    }

    const len = _temp49.numberValue();

    if (len === 0) {
      return new Value(-1);
    }

    let _temp50 = ToInteger(fromIndex);

    if (_temp50 instanceof AbruptCompletion) {
      return _temp50;
    }

    if (_temp50 instanceof Completion) {
      _temp50 = _temp50.Value;
    }

    const n = _temp50.numberValue();

    if (fromIndex === Value.undefined) {
      Assert(n === 0, "n === 0");
    }

    if (n >= len) {
      return new Value(-1);
    }

    let k;

    if (n >= 0) {
      if (Object.is(-0, n)) {
        k = 0;
      } else {
        k = n;
      }
    } else {
      k = len + n;

      if (k < 0) {
        k = 0;
      }
    }

    while (k < len) {
      let _temp51 = ToString(new Value(k));

      Assert(!(_temp51 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp51 instanceof Completion) {
        _temp51 = _temp51.Value;
      }

      const kStr = _temp51;

      let _temp52 = HasProperty(O, kStr);

      if (_temp52 instanceof AbruptCompletion) {
        return _temp52;
      }

      if (_temp52 instanceof Completion) {
        _temp52 = _temp52.Value;
      }

      const kPresent = _temp52;

      if (kPresent === Value.true) {
        let _temp53 = Get(O, kStr);

        if (_temp53 instanceof AbruptCompletion) {
          return _temp53;
        }

        if (_temp53 instanceof Completion) {
          _temp53 = _temp53.Value;
        }

        const elementK = _temp53;
        const same = StrictEqualityComparison(searchElement, elementK);

        if (same === Value.true) {
          return new Value(k);
        }
      }

      k += 1;
    }

    return new Value(-1);
  } // 22.1.3.15 #sec-array.prototype.join
  // 22.2.3.15 #sec-%typedarray%.prototype.join


  function ArrayProto_join([separator = Value.undefined], {
    thisValue
  }) {
    let _temp54 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp54 instanceof AbruptCompletion) {
      return _temp54;
    }

    if (_temp54 instanceof Completion) {
      _temp54 = _temp54.Value;
    }

    let _temp55 = ToObject(thisValue);

    if (_temp55 instanceof AbruptCompletion) {
      return _temp55;
    }

    if (_temp55 instanceof Completion) {
      _temp55 = _temp55.Value;
    }

    const O = _temp55;

    let _temp56 = objectToLength(O);

    if (_temp56 instanceof AbruptCompletion) {
      return _temp56;
    }

    if (_temp56 instanceof Completion) {
      _temp56 = _temp56.Value;
    }

    const lenProp = _temp56;

    let _temp57 = ToLength(lenProp);

    if (_temp57 instanceof AbruptCompletion) {
      return _temp57;
    }

    if (_temp57 instanceof Completion) {
      _temp57 = _temp57.Value;
    }

    const len = _temp57.numberValue();

    let sep;

    if (Type(separator) === 'Undefined') {
      sep = ',';
    } else {
      let _temp58 = ToString(separator);

      if (_temp58 instanceof AbruptCompletion) {
        return _temp58;
      }

      if (_temp58 instanceof Completion) {
        _temp58 = _temp58.Value;
      }

      sep = _temp58.stringValue();
    }

    let R = '';
    let k = 0;

    while (k < len) {
      if (k > 0) {
        R = `${R}${sep}`;
      }

      let _temp59 = ToString(new Value(k));

      Assert(!(_temp59 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp59 instanceof Completion) {
        _temp59 = _temp59.Value;
      }

      const kStr = _temp59;

      let _temp60 = Get(O, kStr);

      if (_temp60 instanceof AbruptCompletion) {
        return _temp60;
      }

      if (_temp60 instanceof Completion) {
        _temp60 = _temp60.Value;
      }

      const element = _temp60;
      let next;

      if (Type(element) === 'Undefined' || Type(element) === 'Null') {
        next = '';
      } else {
        let _temp61 = ToString(element);

        if (_temp61 instanceof AbruptCompletion) {
          return _temp61;
        }

        if (_temp61 instanceof Completion) {
          _temp61 = _temp61.Value;
        }

        next = _temp61.stringValue();
      }

      R = `${R}${next}`;
      k += 1;
    }

    return new Value(R);
  } // 22.1.3.17 #sec-array.prototype.lastindexof
  // 22.2.3.17 #sec-%typedarray%.prototype.lastindexof


  function ArrayProto_lastIndexOf([searchElement = Value.undefined, fromIndex], {
    thisValue
  }) {
    let _temp62 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp62 instanceof AbruptCompletion) {
      return _temp62;
    }

    if (_temp62 instanceof Completion) {
      _temp62 = _temp62.Value;
    }

    let _temp63 = ToObject(thisValue);

    if (_temp63 instanceof AbruptCompletion) {
      return _temp63;
    }

    if (_temp63 instanceof Completion) {
      _temp63 = _temp63.Value;
    }

    const O = _temp63;

    let _temp64 = objectToLength(O);

    if (_temp64 instanceof AbruptCompletion) {
      return _temp64;
    }

    if (_temp64 instanceof Completion) {
      _temp64 = _temp64.Value;
    }

    const lenProp = _temp64;

    let _temp65 = ToLength(lenProp);

    if (_temp65 instanceof AbruptCompletion) {
      return _temp65;
    }

    if (_temp65 instanceof Completion) {
      _temp65 = _temp65.Value;
    }

    const len = _temp65.numberValue();

    if (len === 0) {
      return new Value(-1);
    }

    let n;

    if (fromIndex !== undefined) {
      let _temp66 = ToInteger(fromIndex);

      if (_temp66 instanceof AbruptCompletion) {
        return _temp66;
      }

      if (_temp66 instanceof Completion) {
        _temp66 = _temp66.Value;
      }

      n = _temp66.numberValue();
    } else {
      n = len - 1;
    }

    let k;

    if (n >= 0) {
      if (Object.is(n, -0)) {
        k = 0;
      } else {
        k = Math.min(n, len - 1);
      }
    } else {
      k = len + n;
    }

    while (k >= 0) {
      let _temp67 = ToString(new Value(k));

      Assert(!(_temp67 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp67 instanceof Completion) {
        _temp67 = _temp67.Value;
      }

      const kStr = _temp67;

      let _temp68 = HasProperty(O, kStr);

      if (_temp68 instanceof AbruptCompletion) {
        return _temp68;
      }

      if (_temp68 instanceof Completion) {
        _temp68 = _temp68.Value;
      }

      const kPresent = _temp68;

      if (kPresent === Value.true) {
        let _temp69 = Get(O, kStr);

        if (_temp69 instanceof AbruptCompletion) {
          return _temp69;
        }

        if (_temp69 instanceof Completion) {
          _temp69 = _temp69.Value;
        }

        const elementK = _temp69;
        const same = StrictEqualityComparison(searchElement, elementK);

        if (same === Value.true) {
          return new Value(k);
        }
      }

      k -= 1;
    }

    return new Value(-1);
  } // 22.1.3.21 #sec-array.prototype.reduce
  // 22.2.3.20 #sec-%typedarray%.prototype.reduce


  function ArrayProto_reduce([callbackfn = Value.undefined, initialValue], {
    thisValue
  }) {
    let _temp70 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp70 instanceof AbruptCompletion) {
      return _temp70;
    }

    if (_temp70 instanceof Completion) {
      _temp70 = _temp70.Value;
    }

    let _temp71 = ToObject(thisValue);

    if (_temp71 instanceof AbruptCompletion) {
      return _temp71;
    }

    if (_temp71 instanceof Completion) {
      _temp71 = _temp71.Value;
    }

    const O = _temp71;

    let _temp72 = objectToLength(O);

    if (_temp72 instanceof AbruptCompletion) {
      return _temp72;
    }

    if (_temp72 instanceof Completion) {
      _temp72 = _temp72.Value;
    }

    const lenProp = _temp72;

    let _temp73 = ToLength(lenProp);

    if (_temp73 instanceof AbruptCompletion) {
      return _temp73;
    }

    if (_temp73 instanceof Completion) {
      _temp73 = _temp73.Value;
    }

    const len = _temp73.numberValue();

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
    }

    if (len === 0 && initialValue === undefined) {
      return surroundingAgent.Throw('TypeError', 'ArrayEmptyReduce');
    }

    let k = 0;
    let accumulator = Value.undefined;

    if (initialValue !== undefined) {
      accumulator = initialValue;
    } else {
      let kPresent = false;

      while (kPresent === false && k < len) {
        let _temp74 = ToString(new Value(k));

        Assert(!(_temp74 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

        if (_temp74 instanceof Completion) {
          _temp74 = _temp74.Value;
        }

        const Pk = _temp74;

        let _temp75 = HasProperty(O, Pk);

        if (_temp75 instanceof AbruptCompletion) {
          return _temp75;
        }

        if (_temp75 instanceof Completion) {
          _temp75 = _temp75.Value;
        }

        kPresent = _temp75 === Value.true;

        if (kPresent === true) {
          let _temp76 = Get(O, Pk);

          if (_temp76 instanceof AbruptCompletion) {
            return _temp76;
          }

          if (_temp76 instanceof Completion) {
            _temp76 = _temp76.Value;
          }

          accumulator = _temp76;
        }

        k += 1;
      }

      if (kPresent === false) {
        return surroundingAgent.Throw('TypeError', 'ArrayEmptyReduce');
      }
    }

    while (k < len) {
      let _temp77 = ToString(new Value(k));

      Assert(!(_temp77 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp77 instanceof Completion) {
        _temp77 = _temp77.Value;
      }

      const Pk = _temp77;

      let _temp78 = HasProperty(O, Pk);

      if (_temp78 instanceof AbruptCompletion) {
        return _temp78;
      }

      if (_temp78 instanceof Completion) {
        _temp78 = _temp78.Value;
      }

      const kPresent = _temp78;

      if (kPresent === Value.true) {
        let _temp79 = Get(O, Pk);

        if (_temp79 instanceof AbruptCompletion) {
          return _temp79;
        }

        if (_temp79 instanceof Completion) {
          _temp79 = _temp79.Value;
        }

        const kValue = _temp79;

        let _temp80 = Call(callbackfn, Value.undefined, [accumulator, kValue, new Value(k), O]);

        if (_temp80 instanceof AbruptCompletion) {
          return _temp80;
        }

        if (_temp80 instanceof Completion) {
          _temp80 = _temp80.Value;
        }

        accumulator = _temp80;
      }

      k += 1;
    }

    return accumulator;
  } // 22.1.3.22 #sec-array.prototype.reduceright
  // 22.2.3.21 #sec-%typedarray%.prototype.reduceright


  function ArrayProto_reduceRight([callbackfn = Value.undefined, initialValue], {
    thisValue
  }) {
    let _temp81 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp81 instanceof AbruptCompletion) {
      return _temp81;
    }

    if (_temp81 instanceof Completion) {
      _temp81 = _temp81.Value;
    }

    let _temp82 = ToObject(thisValue);

    if (_temp82 instanceof AbruptCompletion) {
      return _temp82;
    }

    if (_temp82 instanceof Completion) {
      _temp82 = _temp82.Value;
    }

    const O = _temp82;

    let _temp83 = objectToLength(O);

    if (_temp83 instanceof AbruptCompletion) {
      return _temp83;
    }

    if (_temp83 instanceof Completion) {
      _temp83 = _temp83.Value;
    }

    const lenProp = _temp83;

    let _temp84 = ToLength(lenProp);

    if (_temp84 instanceof AbruptCompletion) {
      return _temp84;
    }

    if (_temp84 instanceof Completion) {
      _temp84 = _temp84.Value;
    }

    const len = _temp84.numberValue();

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
    }

    if (len === 0 && initialValue === undefined) {
      return surroundingAgent.Throw('TypeError', 'ArrayEmptyReduce');
    }

    let k = len - 1;
    let accumulator = Value.undefined;

    if (initialValue !== undefined) {
      accumulator = initialValue;
    } else {
      let kPresent = false;

      while (kPresent === false && k >= 0) {
        let _temp85 = ToString(new Value(k));

        Assert(!(_temp85 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

        if (_temp85 instanceof Completion) {
          _temp85 = _temp85.Value;
        }

        const Pk = _temp85;

        let _temp86 = HasProperty(O, Pk);

        if (_temp86 instanceof AbruptCompletion) {
          return _temp86;
        }

        if (_temp86 instanceof Completion) {
          _temp86 = _temp86.Value;
        }

        kPresent = _temp86 === Value.true;

        if (kPresent === true) {
          let _temp87 = Get(O, Pk);

          if (_temp87 instanceof AbruptCompletion) {
            return _temp87;
          }

          if (_temp87 instanceof Completion) {
            _temp87 = _temp87.Value;
          }

          accumulator = _temp87;
        }

        k -= 1;
      }

      if (kPresent === false) {
        return surroundingAgent.Throw('TypeError', 'ArrayEmptyReduce');
      }
    }

    while (k >= 0) {
      let _temp88 = ToString(new Value(k));

      Assert(!(_temp88 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp88 instanceof Completion) {
        _temp88 = _temp88.Value;
      }

      const Pk = _temp88;

      let _temp89 = HasProperty(O, Pk);

      if (_temp89 instanceof AbruptCompletion) {
        return _temp89;
      }

      if (_temp89 instanceof Completion) {
        _temp89 = _temp89.Value;
      }

      const kPresent = _temp89;

      if (kPresent === Value.true) {
        let _temp90 = Get(O, Pk);

        if (_temp90 instanceof AbruptCompletion) {
          return _temp90;
        }

        if (_temp90 instanceof Completion) {
          _temp90 = _temp90.Value;
        }

        const kValue = _temp90;

        let _temp91 = Call(callbackfn, Value.undefined, [accumulator, kValue, new Value(k), O]);

        if (_temp91 instanceof AbruptCompletion) {
          return _temp91;
        }

        if (_temp91 instanceof Completion) {
          _temp91 = _temp91.Value;
        }

        accumulator = _temp91;
      }

      k -= 1;
    }

    return accumulator;
  } // 22.1.3.23 #sec-array.prototype.reverse
  // 22.2.3.22 #sec-%typedarray%.prototype.reverse


  function ArrayProto_reverse(args, {
    thisValue
  }) {
    let _temp92 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp92 instanceof AbruptCompletion) {
      return _temp92;
    }

    if (_temp92 instanceof Completion) {
      _temp92 = _temp92.Value;
    }

    let _temp93 = ToObject(thisValue);

    if (_temp93 instanceof AbruptCompletion) {
      return _temp93;
    }

    if (_temp93 instanceof Completion) {
      _temp93 = _temp93.Value;
    }

    const O = _temp93;

    let _temp94 = objectToLength(O);

    if (_temp94 instanceof AbruptCompletion) {
      return _temp94;
    }

    if (_temp94 instanceof Completion) {
      _temp94 = _temp94.Value;
    }

    const lenProp = _temp94;

    let _temp95 = ToLength(lenProp);

    if (_temp95 instanceof AbruptCompletion) {
      return _temp95;
    }

    if (_temp95 instanceof Completion) {
      _temp95 = _temp95.Value;
    }

    const len = _temp95.numberValue();

    const middle = Math.floor(len / 2);
    let lower = 0;

    while (lower !== middle) {
      const upper = len - lower - 1;

      let _temp96 = ToString(new Value(upper));

      Assert(!(_temp96 instanceof AbruptCompletion), "ToString(new Value(upper))" + ' returned an abrupt completion');

      if (_temp96 instanceof Completion) {
        _temp96 = _temp96.Value;
      }

      const upperP = _temp96;

      let _temp97 = ToString(new Value(lower));

      Assert(!(_temp97 instanceof AbruptCompletion), "ToString(new Value(lower))" + ' returned an abrupt completion');

      if (_temp97 instanceof Completion) {
        _temp97 = _temp97.Value;
      }

      const lowerP = _temp97;

      let _temp98 = HasProperty(O, lowerP);

      if (_temp98 instanceof AbruptCompletion) {
        return _temp98;
      }

      if (_temp98 instanceof Completion) {
        _temp98 = _temp98.Value;
      }

      const lowerExists = _temp98;
      let lowerValue;
      let upperValue;

      if (lowerExists === Value.true) {
        let _temp99 = Get(O, lowerP);

        if (_temp99 instanceof AbruptCompletion) {
          return _temp99;
        }

        if (_temp99 instanceof Completion) {
          _temp99 = _temp99.Value;
        }

        lowerValue = _temp99;
      }

      let _temp100 = HasProperty(O, upperP);

      if (_temp100 instanceof AbruptCompletion) {
        return _temp100;
      }

      if (_temp100 instanceof Completion) {
        _temp100 = _temp100.Value;
      }

      const upperExists = _temp100;

      if (upperExists === Value.true) {
        let _temp101 = Get(O, upperP);

        if (_temp101 instanceof AbruptCompletion) {
          return _temp101;
        }

        if (_temp101 instanceof Completion) {
          _temp101 = _temp101.Value;
        }

        upperValue = _temp101;
      }

      if (lowerExists === Value.true && upperExists === Value.true) {
        let _temp102 = Set$1(O, lowerP, upperValue, Value.true);

        if (_temp102 instanceof AbruptCompletion) {
          return _temp102;
        }

        if (_temp102 instanceof Completion) {
          _temp102 = _temp102.Value;
        }

        let _temp103 = Set$1(O, upperP, lowerValue, Value.true);

        if (_temp103 instanceof AbruptCompletion) {
          return _temp103;
        }

        if (_temp103 instanceof Completion) {
          _temp103 = _temp103.Value;
        }
      } else if (lowerExists === Value.false && upperExists === Value.true) {
        let _temp104 = Set$1(O, lowerP, upperValue, Value.true);

        if (_temp104 instanceof AbruptCompletion) {
          return _temp104;
        }

        if (_temp104 instanceof Completion) {
          _temp104 = _temp104.Value;
        }

        let _temp105 = DeletePropertyOrThrow(O, upperP);

        if (_temp105 instanceof AbruptCompletion) {
          return _temp105;
        }

        if (_temp105 instanceof Completion) {
          _temp105 = _temp105.Value;
        }
      } else if (lowerExists === Value.true && upperExists === Value.false) {
        let _temp106 = DeletePropertyOrThrow(O, lowerP);

        if (_temp106 instanceof AbruptCompletion) {
          return _temp106;
        }

        if (_temp106 instanceof Completion) {
          _temp106 = _temp106.Value;
        }

        let _temp107 = Set$1(O, upperP, lowerValue, Value.true);

        if (_temp107 instanceof AbruptCompletion) {
          return _temp107;
        }

        if (_temp107 instanceof Completion) {
          _temp107 = _temp107.Value;
        }
      }

      lower += 1;
    }

    return O;
  } // 22.1.3.26 #sec-array.prototype.some
  // 22.2.3.25 #sec-%typedarray%.prototype.some


  function ArrayProto_some([callbackfn = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    let _temp108 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp108 instanceof AbruptCompletion) {
      return _temp108;
    }

    if (_temp108 instanceof Completion) {
      _temp108 = _temp108.Value;
    }

    let _temp109 = ToObject(thisValue);

    if (_temp109 instanceof AbruptCompletion) {
      return _temp109;
    }

    if (_temp109 instanceof Completion) {
      _temp109 = _temp109.Value;
    }

    const O = _temp109;

    let _temp110 = objectToLength(O);

    if (_temp110 instanceof AbruptCompletion) {
      return _temp110;
    }

    if (_temp110 instanceof Completion) {
      _temp110 = _temp110.Value;
    }

    const lenProp = _temp110;

    let _temp111 = ToLength(lenProp);

    if (_temp111 instanceof AbruptCompletion) {
      return _temp111;
    }

    if (_temp111 instanceof Completion) {
      _temp111 = _temp111.Value;
    }

    const len = _temp111.numberValue();

    if (IsCallable(callbackfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
    }

    let k = 0;

    while (k < len) {
      let _temp112 = ToString(new Value(k));

      Assert(!(_temp112 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp112 instanceof Completion) {
        _temp112 = _temp112.Value;
      }

      const Pk = _temp112;

      let _temp113 = HasProperty(O, Pk);

      if (_temp113 instanceof AbruptCompletion) {
        return _temp113;
      }

      if (_temp113 instanceof Completion) {
        _temp113 = _temp113.Value;
      }

      const kPresent = _temp113;

      if (kPresent === Value.true) {
        let _temp114 = Get(O, Pk);

        if (_temp114 instanceof AbruptCompletion) {
          return _temp114;
        }

        if (_temp114 instanceof Completion) {
          _temp114 = _temp114.Value;
        }

        const kValue = _temp114;

        let _temp115 = Call(callbackfn, thisArg, [kValue, new Value(k), O]);

        if (_temp115 instanceof AbruptCompletion) {
          return _temp115;
        }

        if (_temp115 instanceof Completion) {
          _temp115 = _temp115.Value;
        }

        const testResult = ToBoolean(_temp115);

        if (testResult === Value.true) {
          return Value.true;
        }
      }

      k += 1;
    }

    return Value.false;
  } // 22.1.3.29 #sec-array.prototype.tolocalestring
  // 22.2.3.28 #sec-%typedarray%.prototype.tolocalestring


  function ArrayProto_toLocaleString(args, {
    thisValue
  }) {
    let _temp116 = priorToEvaluatingAlgorithm(thisValue);

    if (_temp116 instanceof AbruptCompletion) {
      return _temp116;
    }

    if (_temp116 instanceof Completion) {
      _temp116 = _temp116.Value;
    }

    let _temp117 = ToObject(thisValue);

    if (_temp117 instanceof AbruptCompletion) {
      return _temp117;
    }

    if (_temp117 instanceof Completion) {
      _temp117 = _temp117.Value;
    }

    const array = _temp117;

    let _temp118 = objectToLength(array);

    if (_temp118 instanceof AbruptCompletion) {
      return _temp118;
    }

    if (_temp118 instanceof Completion) {
      _temp118 = _temp118.Value;
    }

    const lenProp = _temp118;

    let _temp119 = ToLength(lenProp);

    if (_temp119 instanceof AbruptCompletion) {
      return _temp119;
    }

    if (_temp119 instanceof Completion) {
      _temp119 = _temp119.Value;
    }

    const len = _temp119.numberValue();

    const separator = ', ';
    let R = '';
    let k = 0;

    while (k < len) {
      if (k > 0) {
        R = `${R}${separator}`;
      }

      let _temp120 = ToString(new Value(k));

      Assert(!(_temp120 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp120 instanceof Completion) {
        _temp120 = _temp120.Value;
      }

      const kStr = _temp120;

      let _temp121 = Get(array, kStr);

      if (_temp121 instanceof AbruptCompletion) {
        return _temp121;
      }

      if (_temp121 instanceof Completion) {
        _temp121 = _temp121.Value;
      }

      const nextElement = _temp121;

      if (nextElement !== Value.undefined && nextElement !== Value.null) {
        let _temp123 = Invoke(nextElement, new Value('toLocaleString'));

        if (_temp123 instanceof AbruptCompletion) {
          return _temp123;
        }

        if (_temp123 instanceof Completion) {
          _temp123 = _temp123.Value;
        }

        let _temp122 = ToString(_temp123);

        if (_temp122 instanceof AbruptCompletion) {
          return _temp122;
        }

        if (_temp122 instanceof Completion) {
          _temp122 = _temp122.Value;
        }

        const S = _temp122.stringValue();

        R = `${R}${S}`;
      }

      k += 1;
    }

    return new Value(R);
  }

  assignProps(realmRec, proto, [['every', ArrayProto_every, 1], ['find', ArrayProto_find, 1], ['findIndex', ArrayProto_findIndex, 1], ['forEach', ArrayProto_forEach, 1], ['includes', ArrayProto_includes, 1], ['indexOf', ArrayProto_indexOf, 1], ['join', ArrayProto_join, 1], ['lastIndexOf', ArrayProto_lastIndexOf, 1], ['reduce', ArrayProto_reduce, 1], ['reduceRight', ArrayProto_reduceRight, 1], ['reverse', ArrayProto_reverse, 0], ['some', ArrayProto_some, 1], ['toLocaleString', ArrayProto_toLocaleString, 0]]);
}

function ArrayProto_concat(args, {
  thisValue
}) {
  let _temp = ToObject(thisValue);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const O = _temp;

  let _temp2 = ArraySpeciesCreate(O, new Value(0));

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const A = _temp2;
  let n = 0;
  const items = [O, ...args];

  while (items.length > 0) {
    const E = items.shift();

    let _temp3 = IsConcatSpreadable(E);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const spreadable = _temp3;

    if (spreadable === Value.true) {
      let k = 0;

      let _temp4 = LengthOfArrayLike(E);

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      const len = _temp4.numberValue();

      if (n + len > 2 ** 53 - 1) {
        return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
      }

      while (k < len) {
        let _temp5 = ToString(new Value(k));

        Assert(!(_temp5 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }

        const P = _temp5;

        let _temp6 = HasProperty(E, P);

        if (_temp6 instanceof AbruptCompletion) {
          return _temp6;
        }

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        const exists = _temp6;

        if (exists === Value.true) {
          let _temp7 = Get(E, P);

          if (_temp7 instanceof AbruptCompletion) {
            return _temp7;
          }

          if (_temp7 instanceof Completion) {
            _temp7 = _temp7.Value;
          }

          const subElement = _temp7;

          let _temp8 = ToString(new Value(n));

          Assert(!(_temp8 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

          if (_temp8 instanceof Completion) {
            _temp8 = _temp8.Value;
          }

          const nStr = _temp8;

          let _temp9 = CreateDataPropertyOrThrow(A, nStr, subElement);

          if (_temp9 instanceof AbruptCompletion) {
            return _temp9;
          }

          if (_temp9 instanceof Completion) {
            _temp9 = _temp9.Value;
          }
        }

        n += 1;
        k += 1;
      }
    } else {
      if (n >= 2 ** 53 - 1) {
        return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
      }

      let _temp10 = ToString(new Value(n));

      Assert(!(_temp10 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

      if (_temp10 instanceof Completion) {
        _temp10 = _temp10.Value;
      }

      const nStr = _temp10;

      let _temp11 = CreateDataPropertyOrThrow(A, nStr, E);

      if (_temp11 instanceof AbruptCompletion) {
        return _temp11;
      }

      if (_temp11 instanceof Completion) {
        _temp11 = _temp11.Value;
      }
      n += 1;
    }
  }

  let _temp12 = Set$1(A, new Value('length'), new Value(n), Value.true);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }
  return A;
} // 22.1.3.3 #sec-array.prototype.copywithin


function ArrayProto_copyWithin([target = Value.undefined, start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  let _temp13 = ToObject(thisValue);

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  const O = _temp13;

  let _temp14 = LengthOfArrayLike(O);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const len = _temp14;

  let _temp15 = ToInteger(target);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const relativeTarget = _temp15;
  let to;

  if (relativeTarget.numberValue() < 0) {
    to = Math.max(len.numberValue() + relativeTarget.numberValue(), 0);
  } else {
    to = Math.min(relativeTarget.numberValue(), len.numberValue());
  }

  let _temp16 = ToInteger(start);

  if (_temp16 instanceof AbruptCompletion) {
    return _temp16;
  }

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }

  const relativeStart = _temp16;
  let from;

  if (relativeStart.numberValue() < 0) {
    from = Math.max(len.numberValue() + relativeStart.numberValue(), 0);
  } else {
    from = Math.min(relativeStart.numberValue(), len.numberValue());
  }

  let relativeEnd;

  if (end === Value.undefined) {
    relativeEnd = len;
  } else {
    let _temp17 = ToInteger(end);

    if (_temp17 instanceof AbruptCompletion) {
      return _temp17;
    }

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    relativeEnd = _temp17;
  }

  let final;

  if (relativeEnd.numberValue() < 0) {
    final = Math.max(len.numberValue() + relativeEnd.numberValue(), 0);
  } else {
    final = Math.min(relativeEnd.numberValue(), len.numberValue());
  }

  let count = Math.min(final - from, len.numberValue() - to);
  let direction;

  if (from < to && to < from + count) {
    direction = -1;
    from += count - 1;
    to += count - 1;
  } else {
    direction = 1;
  }

  while (count > 0) {
    let _temp18 = ToString(new Value(from));

    Assert(!(_temp18 instanceof AbruptCompletion), "ToString(new Value(from))" + ' returned an abrupt completion');

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }

    const fromKey = _temp18;

    let _temp19 = ToString(new Value(to));

    Assert(!(_temp19 instanceof AbruptCompletion), "ToString(new Value(to))" + ' returned an abrupt completion');

    if (_temp19 instanceof Completion) {
      _temp19 = _temp19.Value;
    }

    const toKey = _temp19;

    let _temp20 = HasProperty(O, fromKey);

    if (_temp20 instanceof AbruptCompletion) {
      return _temp20;
    }

    if (_temp20 instanceof Completion) {
      _temp20 = _temp20.Value;
    }

    const fromPresent = _temp20;

    if (fromPresent === Value.true) {
      let _temp21 = Get(O, fromKey);

      if (_temp21 instanceof AbruptCompletion) {
        return _temp21;
      }

      if (_temp21 instanceof Completion) {
        _temp21 = _temp21.Value;
      }

      const fromVal = _temp21;

      let _temp22 = Set$1(O, toKey, fromVal, Value.true);

      if (_temp22 instanceof AbruptCompletion) {
        return _temp22;
      }

      if (_temp22 instanceof Completion) {
        _temp22 = _temp22.Value;
      }
    } else {
      let _temp23 = DeletePropertyOrThrow(O, toKey);

      if (_temp23 instanceof AbruptCompletion) {
        return _temp23;
      }

      if (_temp23 instanceof Completion) {
        _temp23 = _temp23.Value;
      }
    }

    from += direction;
    to += direction;
    count -= 1;
  }

  return O;
} // 22.1.3.4 #sec-array.prototype.entries


function ArrayProto_entries(args, {
  thisValue
}) {
  let _temp24 = ToObject(thisValue);

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  const O = _temp24;
  return CreateArrayIterator(O, 'key+value');
} // 22.1.3.6 #sec-array.prototype.fill


function ArrayProto_fill([value = Value.undefined, start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  let _temp25 = ToObject(thisValue);

  if (_temp25 instanceof AbruptCompletion) {
    return _temp25;
  }

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }

  const O = _temp25;

  let _temp26 = LengthOfArrayLike(O);

  if (_temp26 instanceof AbruptCompletion) {
    return _temp26;
  }

  if (_temp26 instanceof Completion) {
    _temp26 = _temp26.Value;
  }

  const len = _temp26.numberValue();

  let _temp27 = ToInteger(start);

  if (_temp27 instanceof AbruptCompletion) {
    return _temp27;
  }

  if (_temp27 instanceof Completion) {
    _temp27 = _temp27.Value;
  }

  const relativeStart = _temp27.numberValue();

  let k;

  if (relativeStart < 0) {
    k = Math.max(len + relativeStart, 0);
  } else {
    k = Math.min(relativeStart, len);
  }

  let relativeEnd;

  if (Type(end) === 'Undefined') {
    relativeEnd = len;
  } else {
    let _temp28 = ToInteger(end);

    if (_temp28 instanceof AbruptCompletion) {
      return _temp28;
    }

    if (_temp28 instanceof Completion) {
      _temp28 = _temp28.Value;
    }

    relativeEnd = _temp28.numberValue();
  }

  let final;

  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }

  while (k < final) {
    let _temp29 = ToString(new Value(k));

    Assert(!(_temp29 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp29 instanceof Completion) {
      _temp29 = _temp29.Value;
    }

    const Pk = _temp29;

    let _temp30 = Set$1(O, Pk, value, Value.true);

    if (_temp30 instanceof AbruptCompletion) {
      return _temp30;
    }

    if (_temp30 instanceof Completion) {
      _temp30 = _temp30.Value;
    }
    k += 1;
  }

  return O;
} // 22.1.3.7 #sec-array.prototype.filter


function ArrayProto_filter([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  let _temp31 = ToObject(thisValue);

  if (_temp31 instanceof AbruptCompletion) {
    return _temp31;
  }

  if (_temp31 instanceof Completion) {
    _temp31 = _temp31.Value;
  }

  const O = _temp31;

  let _temp32 = LengthOfArrayLike(O);

  if (_temp32 instanceof AbruptCompletion) {
    return _temp32;
  }

  if (_temp32 instanceof Completion) {
    _temp32 = _temp32.Value;
  }

  const len = _temp32.numberValue();

  if (IsCallable(callbackfn) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }

  let _temp33 = ArraySpeciesCreate(O, new Value(0));

  if (_temp33 instanceof AbruptCompletion) {
    return _temp33;
  }

  if (_temp33 instanceof Completion) {
    _temp33 = _temp33.Value;
  }

  const A = _temp33;
  let k = 0;
  let to = 0;

  while (k < len) {
    let _temp34 = ToString(new Value(k));

    Assert(!(_temp34 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp34 instanceof Completion) {
      _temp34 = _temp34.Value;
    }

    const Pk = _temp34;

    let _temp35 = HasProperty(O, Pk);

    if (_temp35 instanceof AbruptCompletion) {
      return _temp35;
    }

    if (_temp35 instanceof Completion) {
      _temp35 = _temp35.Value;
    }

    const kPresent = _temp35;

    if (kPresent === Value.true) {
      let _temp36 = Get(O, Pk);

      if (_temp36 instanceof AbruptCompletion) {
        return _temp36;
      }

      if (_temp36 instanceof Completion) {
        _temp36 = _temp36.Value;
      }

      const kValue = _temp36;

      let _temp37 = Call(callbackfn, thisArg, [kValue, new Value(k), O]);

      if (_temp37 instanceof AbruptCompletion) {
        return _temp37;
      }

      if (_temp37 instanceof Completion) {
        _temp37 = _temp37.Value;
      }

      const selected = ToBoolean(_temp37);

      if (selected === Value.true) {
        let _temp38 = CreateDataPropertyOrThrow(A, ToString(new Value(to)), kValue);

        if (_temp38 instanceof AbruptCompletion) {
          return _temp38;
        }

        if (_temp38 instanceof Completion) {
          _temp38 = _temp38.Value;
        }
        to += 1;
      }
    }

    k += 1;
  }

  return A;
} // 22.1.3.10.1 #sec-flattenintoarray


function FlattenIntoArray(target, source, sourceLen, start, depth, mapperFunction, thisArg) {
  Assert(Type(target) === 'Object', "Type(target) === 'Object'");
  Assert(Type(source) === 'Object', "Type(source) === 'Object'");
  Assert(sourceLen >= 0, "sourceLen >= 0");
  Assert(start >= 0, "start >= 0"); // Assert: _depth_ is an integer Number, *+&infin;*, or *-&infin;*.
  // Assert(mapperFunction === undefined || (X(IsCallable(mapperFunction)) === Value.true && thisArg !== undefined && depth === 1));

  let targetIndex = start;
  let sourceIndex = 0;

  while (sourceIndex < sourceLen) {
    let _temp39 = ToString(new Value(sourceIndex));

    Assert(!(_temp39 instanceof AbruptCompletion), "ToString(new Value(sourceIndex))" + ' returned an abrupt completion');

    if (_temp39 instanceof Completion) {
      _temp39 = _temp39.Value;
    }

    const P = _temp39;

    let _temp40 = HasProperty(source, P);

    if (_temp40 instanceof AbruptCompletion) {
      return _temp40;
    }

    if (_temp40 instanceof Completion) {
      _temp40 = _temp40.Value;
    }

    const exists = _temp40;

    if (exists === Value.true) {
      let _temp41 = Get(source, P);

      if (_temp41 instanceof AbruptCompletion) {
        return _temp41;
      }

      if (_temp41 instanceof Completion) {
        _temp41 = _temp41.Value;
      }

      let element = _temp41;

      if (mapperFunction) {
        Assert(thisArg, "thisArg");

        let _temp42 = Call(mapperFunction, thisArg, [element, new Value(sourceIndex), source]);

        if (_temp42 instanceof AbruptCompletion) {
          return _temp42;
        }

        if (_temp42 instanceof Completion) {
          _temp42 = _temp42.Value;
        }

        element = _temp42;
      }

      let shouldFlatten = Value.false;

      if (depth > 0) {
        let _temp43 = IsArray(element);

        if (_temp43 instanceof AbruptCompletion) {
          return _temp43;
        }

        if (_temp43 instanceof Completion) {
          _temp43 = _temp43.Value;
        }

        shouldFlatten = _temp43;
      }

      if (shouldFlatten === Value.true) {
        let _temp44 = LengthOfArrayLike(element);

        if (_temp44 instanceof AbruptCompletion) {
          return _temp44;
        }

        if (_temp44 instanceof Completion) {
          _temp44 = _temp44.Value;
        }

        const elementLen = _temp44.numberValue();

        let _temp45 = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);

        if (_temp45 instanceof AbruptCompletion) {
          return _temp45;
        }

        if (_temp45 instanceof Completion) {
          _temp45 = _temp45.Value;
        }

        targetIndex = _temp45;
      } else {
        if (targetIndex >= 2 ** 53 - 1) {
          return surroundingAgent.Throw('TypeError');
        }

        let _temp47 = ToString(new Value(targetIndex));

        Assert(!(_temp47 instanceof AbruptCompletion), "ToString(new Value(targetIndex))" + ' returned an abrupt completion');

        if (_temp47 instanceof Completion) {
          _temp47 = _temp47.Value;
        }

        let _temp46 = CreateDataPropertyOrThrow(target, _temp47, element);

        if (_temp46 instanceof AbruptCompletion) {
          return _temp46;
        }

        if (_temp46 instanceof Completion) {
          _temp46 = _temp46.Value;
        }
        targetIndex += 1;
      }
    }

    sourceIndex += 1;
  }

  return targetIndex;
} // 22.1.3.10 #sec-array.prototype.flat


function ArrayProto_flat([depth = Value.undefined], {
  thisValue
}) {
  let _temp48 = ToObject(thisValue);

  if (_temp48 instanceof AbruptCompletion) {
    return _temp48;
  }

  if (_temp48 instanceof Completion) {
    _temp48 = _temp48.Value;
  }

  const O = _temp48;

  let _temp49 = LengthOfArrayLike(O);

  if (_temp49 instanceof AbruptCompletion) {
    return _temp49;
  }

  if (_temp49 instanceof Completion) {
    _temp49 = _temp49.Value;
  }

  const sourceLen = _temp49.numberValue();

  let depthNum = 1;

  if (depth !== Value.undefined) {
    let _temp50 = ToInteger(depth);

    if (_temp50 instanceof AbruptCompletion) {
      return _temp50;
    }

    if (_temp50 instanceof Completion) {
      _temp50 = _temp50.Value;
    }

    depthNum = _temp50.numberValue();
  }

  let _temp51 = ArraySpeciesCreate(O, new Value(0));

  if (_temp51 instanceof AbruptCompletion) {
    return _temp51;
  }

  if (_temp51 instanceof Completion) {
    _temp51 = _temp51.Value;
  }

  const A = _temp51;

  let _temp52 = FlattenIntoArray(A, O, sourceLen, 0, depthNum);

  if (_temp52 instanceof AbruptCompletion) {
    return _temp52;
  }

  if (_temp52 instanceof Completion) {
    _temp52 = _temp52.Value;
  }
  return A;
} // 22.1.3.11 #sec-array.prototype.flatmap


function ArrayProto_flatMap([mapperFunction = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  let _temp53 = ToObject(thisValue);

  if (_temp53 instanceof AbruptCompletion) {
    return _temp53;
  }

  if (_temp53 instanceof Completion) {
    _temp53 = _temp53.Value;
  }

  const O = _temp53;

  let _temp54 = LengthOfArrayLike(O);

  if (_temp54 instanceof AbruptCompletion) {
    return _temp54;
  }

  if (_temp54 instanceof Completion) {
    _temp54 = _temp54.Value;
  }

  const sourceLen = _temp54.numberValue();

  let _temp55 = IsCallable(mapperFunction);

  Assert(!(_temp55 instanceof AbruptCompletion), "IsCallable(mapperFunction)" + ' returned an abrupt completion');

  if (_temp55 instanceof Completion) {
    _temp55 = _temp55.Value;
  }

  if (_temp55 === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', mapperFunction);
  }

  let _temp56 = ArraySpeciesCreate(O, new Value(0));

  if (_temp56 instanceof AbruptCompletion) {
    return _temp56;
  }

  if (_temp56 instanceof Completion) {
    _temp56 = _temp56.Value;
  }

  const A = _temp56;

  let _temp57 = FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, thisArg);

  if (_temp57 instanceof AbruptCompletion) {
    return _temp57;
  }

  if (_temp57 instanceof Completion) {
    _temp57 = _temp57.Value;
  }
  return A;
} // 22.1.3.16 #sec-array.prototype.keys


function ArrayProto_keys(args, {
  thisValue
}) {
  let _temp58 = ToObject(thisValue);

  if (_temp58 instanceof AbruptCompletion) {
    return _temp58;
  }

  if (_temp58 instanceof Completion) {
    _temp58 = _temp58.Value;
  }

  const O = _temp58;
  return CreateArrayIterator(O, 'key');
} // 22.1.3.18 #sec-array.prototype.map


function ArrayProto_map([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  let _temp59 = ToObject(thisValue);

  if (_temp59 instanceof AbruptCompletion) {
    return _temp59;
  }

  if (_temp59 instanceof Completion) {
    _temp59 = _temp59.Value;
  }

  const O = _temp59;

  let _temp60 = LengthOfArrayLike(O);

  if (_temp60 instanceof AbruptCompletion) {
    return _temp60;
  }

  if (_temp60 instanceof Completion) {
    _temp60 = _temp60.Value;
  }

  const len = _temp60;

  if (IsCallable(callbackfn) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }

  let _temp61 = ArraySpeciesCreate(O, len);

  if (_temp61 instanceof AbruptCompletion) {
    return _temp61;
  }

  if (_temp61 instanceof Completion) {
    _temp61 = _temp61.Value;
  }

  const A = _temp61;
  let k = 0;

  while (k < len.numberValue()) {
    let _temp62 = ToString(new Value(k));

    Assert(!(_temp62 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp62 instanceof Completion) {
      _temp62 = _temp62.Value;
    }

    const Pk = _temp62;

    let _temp63 = HasProperty(O, Pk);

    if (_temp63 instanceof AbruptCompletion) {
      return _temp63;
    }

    if (_temp63 instanceof Completion) {
      _temp63 = _temp63.Value;
    }

    const kPresent = _temp63;

    if (kPresent === Value.true) {
      let _temp64 = Get(O, Pk);

      if (_temp64 instanceof AbruptCompletion) {
        return _temp64;
      }

      if (_temp64 instanceof Completion) {
        _temp64 = _temp64.Value;
      }

      const kValue = _temp64;

      let _temp65 = Call(callbackfn, thisArg, [kValue, new Value(k), O]);

      if (_temp65 instanceof AbruptCompletion) {
        return _temp65;
      }

      if (_temp65 instanceof Completion) {
        _temp65 = _temp65.Value;
      }

      const mappedValue = _temp65;

      let _temp66 = CreateDataPropertyOrThrow(A, Pk, mappedValue);

      if (_temp66 instanceof AbruptCompletion) {
        return _temp66;
      }

      if (_temp66 instanceof Completion) {
        _temp66 = _temp66.Value;
      }
    }

    k += 1;
  }

  return A;
} // 22.1.3.19 #sec-array.prototype.pop


function ArrayProto_pop(args, {
  thisValue
}) {
  let _temp67 = ToObject(thisValue);

  if (_temp67 instanceof AbruptCompletion) {
    return _temp67;
  }

  if (_temp67 instanceof Completion) {
    _temp67 = _temp67.Value;
  }

  const O = _temp67;

  let _temp68 = LengthOfArrayLike(O);

  if (_temp68 instanceof AbruptCompletion) {
    return _temp68;
  }

  if (_temp68 instanceof Completion) {
    _temp68 = _temp68.Value;
  }

  const len = _temp68.numberValue();

  if (len === 0) {
    let _temp69 = Set$1(O, new Value('length'), new Value(0), Value.true);

    if (_temp69 instanceof AbruptCompletion) {
      return _temp69;
    }

    if (_temp69 instanceof Completion) {
      _temp69 = _temp69.Value;
    }
    return Value.undefined;
  } else {
    const newLen = len - 1;

    let _temp70 = ToString(new Value(newLen));

    if (_temp70 instanceof AbruptCompletion) {
      return _temp70;
    }

    if (_temp70 instanceof Completion) {
      _temp70 = _temp70.Value;
    }

    const index = _temp70;

    let _temp71 = Get(O, index);

    if (_temp71 instanceof AbruptCompletion) {
      return _temp71;
    }

    if (_temp71 instanceof Completion) {
      _temp71 = _temp71.Value;
    }

    const element = _temp71;

    let _temp72 = DeletePropertyOrThrow(O, index);

    if (_temp72 instanceof AbruptCompletion) {
      return _temp72;
    }

    if (_temp72 instanceof Completion) {
      _temp72 = _temp72.Value;
    }

    let _temp73 = Set$1(O, new Value('length'), new Value(newLen), Value.true);

    if (_temp73 instanceof AbruptCompletion) {
      return _temp73;
    }

    if (_temp73 instanceof Completion) {
      _temp73 = _temp73.Value;
    }
    return element;
  }
} // 22.1.3.20 #sec-array.prototype.push


function ArrayProto_push(items, {
  thisValue
}) {
  let _temp74 = ToObject(thisValue);

  if (_temp74 instanceof AbruptCompletion) {
    return _temp74;
  }

  if (_temp74 instanceof Completion) {
    _temp74 = _temp74.Value;
  }

  const O = _temp74;

  let _temp75 = LengthOfArrayLike(O);

  if (_temp75 instanceof AbruptCompletion) {
    return _temp75;
  }

  if (_temp75 instanceof Completion) {
    _temp75 = _temp75.Value;
  }

  let len = _temp75.numberValue();

  const argCount = items.length;

  if (len + argCount > 2 ** 53 - 1) {
    return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
  }

  while (items.length > 0) {
    const E = items.shift();

    let _temp77 = ToString(new Value(len));

    Assert(!(_temp77 instanceof AbruptCompletion), "ToString(new Value(len))" + ' returned an abrupt completion');

    if (_temp77 instanceof Completion) {
      _temp77 = _temp77.Value;
    }

    let _temp76 = Set$1(O, _temp77, E, Value.true);

    if (_temp76 instanceof AbruptCompletion) {
      return _temp76;
    }

    if (_temp76 instanceof Completion) {
      _temp76 = _temp76.Value;
    }
    len += 1;
  }

  let _temp78 = Set$1(O, new Value('length'), new Value(len), Value.true);

  if (_temp78 instanceof AbruptCompletion) {
    return _temp78;
  }

  if (_temp78 instanceof Completion) {
    _temp78 = _temp78.Value;
  }
  return new Value(len);
} // 22.1.3.24 #sec-array.prototype.shift


function ArrayProto_shift(args, {
  thisValue
}) {
  let _temp79 = ToObject(thisValue);

  if (_temp79 instanceof AbruptCompletion) {
    return _temp79;
  }

  if (_temp79 instanceof Completion) {
    _temp79 = _temp79.Value;
  }

  const O = _temp79;

  let _temp80 = LengthOfArrayLike(O);

  if (_temp80 instanceof AbruptCompletion) {
    return _temp80;
  }

  if (_temp80 instanceof Completion) {
    _temp80 = _temp80.Value;
  }

  const len = _temp80.numberValue();

  if (len === 0) {
    let _temp81 = Set$1(O, new Value('length'), new Value(0), Value.true);

    if (_temp81 instanceof AbruptCompletion) {
      return _temp81;
    }

    if (_temp81 instanceof Completion) {
      _temp81 = _temp81.Value;
    }
    return Value.undefined;
  }

  let _temp82 = Get(O, new Value('0'));

  if (_temp82 instanceof AbruptCompletion) {
    return _temp82;
  }

  if (_temp82 instanceof Completion) {
    _temp82 = _temp82.Value;
  }

  const first = _temp82;
  let k = 1;

  while (k < len) {
    let _temp83 = ToString(new Value(k));

    Assert(!(_temp83 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp83 instanceof Completion) {
      _temp83 = _temp83.Value;
    }

    const from = _temp83;

    let _temp84 = ToString(new Value(k - 1));

    Assert(!(_temp84 instanceof AbruptCompletion), "ToString(new Value(k - 1))" + ' returned an abrupt completion');

    if (_temp84 instanceof Completion) {
      _temp84 = _temp84.Value;
    }

    const to = _temp84;

    let _temp85 = HasProperty(O, from);

    if (_temp85 instanceof AbruptCompletion) {
      return _temp85;
    }

    if (_temp85 instanceof Completion) {
      _temp85 = _temp85.Value;
    }

    const fromPresent = _temp85;

    if (fromPresent === Value.true) {
      let _temp86 = Get(O, from);

      if (_temp86 instanceof AbruptCompletion) {
        return _temp86;
      }

      if (_temp86 instanceof Completion) {
        _temp86 = _temp86.Value;
      }

      const fromVal = _temp86;

      let _temp87 = Set$1(O, to, fromVal, Value.true);

      if (_temp87 instanceof AbruptCompletion) {
        return _temp87;
      }

      if (_temp87 instanceof Completion) {
        _temp87 = _temp87.Value;
      }
    } else {
      let _temp88 = DeletePropertyOrThrow(O, to);

      if (_temp88 instanceof AbruptCompletion) {
        return _temp88;
      }

      if (_temp88 instanceof Completion) {
        _temp88 = _temp88.Value;
      }
    }

    k += 1;
  }

  let _temp91 = ToString(new Value(len - 1));

  Assert(!(_temp91 instanceof AbruptCompletion), "ToString(new Value(len - 1))" + ' returned an abrupt completion');

  if (_temp91 instanceof Completion) {
    _temp91 = _temp91.Value;
  }

  let _temp89 = DeletePropertyOrThrow(O, _temp91);

  if (_temp89 instanceof AbruptCompletion) {
    return _temp89;
  }

  if (_temp89 instanceof Completion) {
    _temp89 = _temp89.Value;
  }

  let _temp90 = Set$1(O, new Value('length'), new Value(len - 1), Value.true);

  if (_temp90 instanceof AbruptCompletion) {
    return _temp90;
  }

  if (_temp90 instanceof Completion) {
    _temp90 = _temp90.Value;
  }
  return first;
} // 22.1.3.25 #sec-array.prototype.slice


function ArrayProto_slice([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  let _temp92 = ToObject(thisValue);

  if (_temp92 instanceof AbruptCompletion) {
    return _temp92;
  }

  if (_temp92 instanceof Completion) {
    _temp92 = _temp92.Value;
  }

  const O = _temp92;

  let _temp93 = LengthOfArrayLike(O);

  if (_temp93 instanceof AbruptCompletion) {
    return _temp93;
  }

  if (_temp93 instanceof Completion) {
    _temp93 = _temp93.Value;
  }

  const len = _temp93.numberValue();

  let _temp94 = ToInteger(start);

  if (_temp94 instanceof AbruptCompletion) {
    return _temp94;
  }

  if (_temp94 instanceof Completion) {
    _temp94 = _temp94.Value;
  }

  const relativeStart = _temp94.numberValue();

  let k;

  if (relativeStart < 0) {
    k = Math.max(len + relativeStart, 0);
  } else {
    k = Math.min(relativeStart, len);
  }

  let relativeEnd;

  if (Type(end) === 'Undefined') {
    relativeEnd = len;
  } else {
    let _temp95 = ToInteger(end);

    if (_temp95 instanceof AbruptCompletion) {
      return _temp95;
    }

    if (_temp95 instanceof Completion) {
      _temp95 = _temp95.Value;
    }

    relativeEnd = _temp95.numberValue();
  }

  let final;

  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }

  const count = Math.max(final - k, 0);

  let _temp96 = ArraySpeciesCreate(O, new Value(count));

  if (_temp96 instanceof AbruptCompletion) {
    return _temp96;
  }

  if (_temp96 instanceof Completion) {
    _temp96 = _temp96.Value;
  }

  const A = _temp96;
  let n = 0;

  while (k < final) {
    let _temp97 = ToString(new Value(k));

    Assert(!(_temp97 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp97 instanceof Completion) {
      _temp97 = _temp97.Value;
    }

    const Pk = _temp97;

    let _temp98 = HasProperty(O, Pk);

    if (_temp98 instanceof AbruptCompletion) {
      return _temp98;
    }

    if (_temp98 instanceof Completion) {
      _temp98 = _temp98.Value;
    }

    const kPresent = _temp98;

    if (kPresent === Value.true) {
      let _temp99 = Get(O, Pk);

      if (_temp99 instanceof AbruptCompletion) {
        return _temp99;
      }

      if (_temp99 instanceof Completion) {
        _temp99 = _temp99.Value;
      }

      const kValue = _temp99;

      let _temp100 = ToString(new Value(n));

      Assert(!(_temp100 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

      if (_temp100 instanceof Completion) {
        _temp100 = _temp100.Value;
      }

      const nStr = _temp100;

      let _temp101 = CreateDataPropertyOrThrow(A, nStr, kValue);

      if (_temp101 instanceof AbruptCompletion) {
        return _temp101;
      }

      if (_temp101 instanceof Completion) {
        _temp101 = _temp101.Value;
      }
    }

    k += 1;
    n += 1;
  }

  let _temp102 = Set$1(A, new Value('length'), new Value(n), Value.true);

  if (_temp102 instanceof AbruptCompletion) {
    return _temp102;
  }

  if (_temp102 instanceof Completion) {
    _temp102 = _temp102.Value;
  }
  return A;
} // 22.1.3.27 #sec-array.prototype.sort


function ArrayProto_sort([comparefn = Value.undefined], {
  thisValue
}) {
  if (comparefn !== Value.undefined && IsCallable(comparefn) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', comparefn);
  }

  let _temp103 = ToObject(thisValue);

  if (_temp103 instanceof AbruptCompletion) {
    return _temp103;
  }

  if (_temp103 instanceof Completion) {
    _temp103 = _temp103.Value;
  }

  const obj = _temp103;

  let _temp104 = LengthOfArrayLike(obj);

  if (_temp104 instanceof AbruptCompletion) {
    return _temp104;
  }

  if (_temp104 instanceof Completion) {
    _temp104 = _temp104.Value;
  }

  const len = _temp104;
  return ArrayProto_sortBody(obj, len, (x, y) => SortCompare(x, y, comparefn));
} // 22.1.3.28 #sec-array.prototype.splice


function ArrayProto_splice(args, {
  thisValue
}) {
  const [start = Value.undefined, deleteCount = Value.undefined, ...items] = args;

  let _temp105 = ToObject(thisValue);

  if (_temp105 instanceof AbruptCompletion) {
    return _temp105;
  }

  if (_temp105 instanceof Completion) {
    _temp105 = _temp105.Value;
  }

  const O = _temp105;

  let _temp106 = LengthOfArrayLike(O);

  if (_temp106 instanceof AbruptCompletion) {
    return _temp106;
  }

  if (_temp106 instanceof Completion) {
    _temp106 = _temp106.Value;
  }

  const len = _temp106.numberValue();

  let _temp107 = ToInteger(start);

  if (_temp107 instanceof AbruptCompletion) {
    return _temp107;
  }

  if (_temp107 instanceof Completion) {
    _temp107 = _temp107.Value;
  }

  const relativeStart = _temp107.numberValue();

  let actualStart;

  if (relativeStart < 0) {
    actualStart = Math.max(len + relativeStart, 0);
  } else {
    actualStart = Math.min(relativeStart, len);
  }

  let insertCount;
  let actualDeleteCount;

  if (args.length === 0) {
    insertCount = 0;
    actualDeleteCount = 0;
  } else if (args.length === 1) {
    insertCount = 0;
    actualDeleteCount = len - actualStart;
  } else {
    insertCount = args.length - 2;

    let _temp108 = ToInteger(deleteCount);

    if (_temp108 instanceof AbruptCompletion) {
      return _temp108;
    }

    if (_temp108 instanceof Completion) {
      _temp108 = _temp108.Value;
    }

    const dc = _temp108.numberValue();

    actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);
  }

  if (len + insertCount - actualDeleteCount > 2 ** 53 - 1) {
    return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
  }

  let _temp109 = ArraySpeciesCreate(O, new Value(actualDeleteCount));

  if (_temp109 instanceof AbruptCompletion) {
    return _temp109;
  }

  if (_temp109 instanceof Completion) {
    _temp109 = _temp109.Value;
  }

  const A = _temp109;
  let k = 0;

  while (k < actualDeleteCount) {
    let _temp110 = ToString(new Value(actualStart + k));

    Assert(!(_temp110 instanceof AbruptCompletion), "ToString(new Value(actualStart + k))" + ' returned an abrupt completion');

    if (_temp110 instanceof Completion) {
      _temp110 = _temp110.Value;
    }

    const from = _temp110;

    let _temp111 = HasProperty(O, from);

    if (_temp111 instanceof AbruptCompletion) {
      return _temp111;
    }

    if (_temp111 instanceof Completion) {
      _temp111 = _temp111.Value;
    }

    const fromPresent = _temp111;

    if (fromPresent === Value.true) {
      let _temp112 = Get(O, from);

      if (_temp112 instanceof AbruptCompletion) {
        return _temp112;
      }

      if (_temp112 instanceof Completion) {
        _temp112 = _temp112.Value;
      }

      const fromValue = _temp112;

      let _temp114 = ToString(new Value(k));

      Assert(!(_temp114 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp114 instanceof Completion) {
        _temp114 = _temp114.Value;
      }

      let _temp113 = CreateDataPropertyOrThrow(A, _temp114, fromValue);

      if (_temp113 instanceof AbruptCompletion) {
        return _temp113;
      }

      if (_temp113 instanceof Completion) {
        _temp113 = _temp113.Value;
      }
    }

    k += 1;
  }

  let _temp115 = Set$1(A, new Value('length'), new Value(actualDeleteCount), Value.true);

  if (_temp115 instanceof AbruptCompletion) {
    return _temp115;
  }

  if (_temp115 instanceof Completion) {
    _temp115 = _temp115.Value;
  }
  const itemCount = items.length;

  if (itemCount < actualDeleteCount) {
    k = actualStart;

    while (k < len - actualDeleteCount) {
      let _temp116 = ToString(new Value(k + actualDeleteCount));

      Assert(!(_temp116 instanceof AbruptCompletion), "ToString(new Value(k + actualDeleteCount))" + ' returned an abrupt completion');

      if (_temp116 instanceof Completion) {
        _temp116 = _temp116.Value;
      }

      const from = _temp116;

      let _temp117 = ToString(new Value(k + itemCount));

      Assert(!(_temp117 instanceof AbruptCompletion), "ToString(new Value(k + itemCount))" + ' returned an abrupt completion');

      if (_temp117 instanceof Completion) {
        _temp117 = _temp117.Value;
      }

      const to = _temp117;

      let _temp118 = HasProperty(O, from);

      if (_temp118 instanceof AbruptCompletion) {
        return _temp118;
      }

      if (_temp118 instanceof Completion) {
        _temp118 = _temp118.Value;
      }

      const fromPresent = _temp118;

      if (fromPresent === Value.true) {
        let _temp119 = Get(O, from);

        if (_temp119 instanceof AbruptCompletion) {
          return _temp119;
        }

        if (_temp119 instanceof Completion) {
          _temp119 = _temp119.Value;
        }

        const fromValue = _temp119;

        let _temp120 = Set$1(O, to, fromValue, Value.true);

        if (_temp120 instanceof AbruptCompletion) {
          return _temp120;
        }

        if (_temp120 instanceof Completion) {
          _temp120 = _temp120.Value;
        }
      } else {
        let _temp121 = DeletePropertyOrThrow(O, to);

        if (_temp121 instanceof AbruptCompletion) {
          return _temp121;
        }

        if (_temp121 instanceof Completion) {
          _temp121 = _temp121.Value;
        }
      }

      k += 1;
    }

    k = len;

    while (k > len - actualDeleteCount + itemCount) {
      let _temp123 = ToString(new Value(k - 1));

      Assert(!(_temp123 instanceof AbruptCompletion), "ToString(new Value(k - 1))" + ' returned an abrupt completion');

      if (_temp123 instanceof Completion) {
        _temp123 = _temp123.Value;
      }

      let _temp122 = DeletePropertyOrThrow(O, _temp123);

      if (_temp122 instanceof AbruptCompletion) {
        return _temp122;
      }

      if (_temp122 instanceof Completion) {
        _temp122 = _temp122.Value;
      }
      k -= 1;
    }
  } else if (itemCount > actualDeleteCount) {
    k = len - actualDeleteCount;

    while (k > actualStart) {
      let _temp124 = ToString(new Value(k + actualDeleteCount - 1));

      Assert(!(_temp124 instanceof AbruptCompletion), "ToString(new Value(k + actualDeleteCount - 1))" + ' returned an abrupt completion');

      if (_temp124 instanceof Completion) {
        _temp124 = _temp124.Value;
      }

      const from = _temp124;

      let _temp125 = ToString(new Value(k + itemCount - 1));

      Assert(!(_temp125 instanceof AbruptCompletion), "ToString(new Value(k + itemCount - 1))" + ' returned an abrupt completion');

      if (_temp125 instanceof Completion) {
        _temp125 = _temp125.Value;
      }

      const to = _temp125;

      let _temp126 = HasProperty(O, from);

      if (_temp126 instanceof AbruptCompletion) {
        return _temp126;
      }

      if (_temp126 instanceof Completion) {
        _temp126 = _temp126.Value;
      }

      const fromPresent = _temp126;

      if (fromPresent === Value.true) {
        let _temp127 = Get(O, from);

        if (_temp127 instanceof AbruptCompletion) {
          return _temp127;
        }

        if (_temp127 instanceof Completion) {
          _temp127 = _temp127.Value;
        }

        const fromValue = _temp127;

        let _temp128 = Set$1(O, to, fromValue, Value.true);

        if (_temp128 instanceof AbruptCompletion) {
          return _temp128;
        }

        if (_temp128 instanceof Completion) {
          _temp128 = _temp128.Value;
        }
      } else {
        let _temp129 = DeletePropertyOrThrow(O, to);

        if (_temp129 instanceof AbruptCompletion) {
          return _temp129;
        }

        if (_temp129 instanceof Completion) {
          _temp129 = _temp129.Value;
        }
      }

      k -= 1;
    }
  }

  k = actualStart;

  while (items.length > 0) {
    const E = items.shift();

    let _temp131 = ToString(new Value(k));

    Assert(!(_temp131 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp131 instanceof Completion) {
      _temp131 = _temp131.Value;
    }

    let _temp130 = Set$1(O, _temp131, E, Value.true);

    if (_temp130 instanceof AbruptCompletion) {
      return _temp130;
    }

    if (_temp130 instanceof Completion) {
      _temp130 = _temp130.Value;
    }
    k += 1;
  }

  let _temp132 = Set$1(O, new Value('length'), new Value(len - actualDeleteCount + itemCount), Value.true);

  if (_temp132 instanceof AbruptCompletion) {
    return _temp132;
  }

  if (_temp132 instanceof Completion) {
    _temp132 = _temp132.Value;
  }
  return A;
} // 22.1.3.30 #sec-array.prototype.tostring


function ArrayProto_toString(a, {
  thisValue
}) {
  let _temp133 = ToObject(thisValue);

  if (_temp133 instanceof AbruptCompletion) {
    return _temp133;
  }

  if (_temp133 instanceof Completion) {
    _temp133 = _temp133.Value;
  }

  const array = _temp133;

  let _temp134 = Get(array, new Value('join'));

  if (_temp134 instanceof AbruptCompletion) {
    return _temp134;
  }

  if (_temp134 instanceof Completion) {
    _temp134 = _temp134.Value;
  }

  let func = _temp134;

  if (IsCallable(func) === Value.false) {
    func = surroundingAgent.intrinsic('%Object.prototype.toString%');
  }

  return Call(func, array);
} // 22.1.3.31 #sec-array.prototype.unshift


function ArrayProto_unshift(args, {
  thisValue
}) {
  let _temp135 = ToObject(thisValue);

  if (_temp135 instanceof AbruptCompletion) {
    return _temp135;
  }

  if (_temp135 instanceof Completion) {
    _temp135 = _temp135.Value;
  }

  const O = _temp135;

  let _temp136 = LengthOfArrayLike(O);

  if (_temp136 instanceof AbruptCompletion) {
    return _temp136;
  }

  if (_temp136 instanceof Completion) {
    _temp136 = _temp136.Value;
  }

  const len = _temp136.numberValue();

  const argCount = args.length;

  if (argCount > 0) {
    if (len + argCount > 2 ** 53 - 1) {
      return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
    }

    let k = len;

    while (k > 0) {
      let _temp137 = ToString(new Value(k - 1));

      Assert(!(_temp137 instanceof AbruptCompletion), "ToString(new Value(k - 1))" + ' returned an abrupt completion');

      if (_temp137 instanceof Completion) {
        _temp137 = _temp137.Value;
      }

      const from = _temp137;

      let _temp138 = ToString(new Value(k + argCount - 1));

      Assert(!(_temp138 instanceof AbruptCompletion), "ToString(new Value(k + argCount - 1))" + ' returned an abrupt completion');

      if (_temp138 instanceof Completion) {
        _temp138 = _temp138.Value;
      }

      const to = _temp138;

      let _temp139 = HasProperty(O, from);

      if (_temp139 instanceof AbruptCompletion) {
        return _temp139;
      }

      if (_temp139 instanceof Completion) {
        _temp139 = _temp139.Value;
      }

      const fromPresent = _temp139;

      if (fromPresent === Value.true) {
        let _temp140 = Get(O, from);

        if (_temp140 instanceof AbruptCompletion) {
          return _temp140;
        }

        if (_temp140 instanceof Completion) {
          _temp140 = _temp140.Value;
        }

        const fromValue = _temp140;

        let _temp141 = Set$1(O, to, fromValue, Value.true);

        if (_temp141 instanceof AbruptCompletion) {
          return _temp141;
        }

        if (_temp141 instanceof Completion) {
          _temp141 = _temp141.Value;
        }
      } else {
        let _temp142 = DeletePropertyOrThrow(O, to);

        if (_temp142 instanceof AbruptCompletion) {
          return _temp142;
        }

        if (_temp142 instanceof Completion) {
          _temp142 = _temp142.Value;
        }
      }

      k -= 1;
    }

    let j = 0;
    const items = args;

    while (items.length !== 0) {
      const E = items.shift();

      let _temp143 = ToString(new Value(j));

      Assert(!(_temp143 instanceof AbruptCompletion), "ToString(new Value(j))" + ' returned an abrupt completion');

      if (_temp143 instanceof Completion) {
        _temp143 = _temp143.Value;
      }

      const jStr = _temp143;

      let _temp144 = Set$1(O, jStr, E, Value.true);

      if (_temp144 instanceof AbruptCompletion) {
        return _temp144;
      }

      if (_temp144 instanceof Completion) {
        _temp144 = _temp144.Value;
      }
      j += 1;
    }
  }

  let _temp145 = Set$1(O, new Value('length'), new Value(len + argCount), Value.true);

  if (_temp145 instanceof AbruptCompletion) {
    return _temp145;
  }

  if (_temp145 instanceof Completion) {
    _temp145 = _temp145.Value;
  }
  return new Value(len + argCount);
} // 22.1.3.32 #sec-array.prototype.values


function ArrayProto_values(args, {
  thisValue
}) {
  let _temp146 = ToObject(thisValue);

  if (_temp146 instanceof AbruptCompletion) {
    return _temp146;
  }

  if (_temp146 instanceof Completion) {
    _temp146 = _temp146.Value;
  }

  const O = _temp146;
  return CreateArrayIterator(O, 'value');
}

function CreateArrayPrototype(realmRec) {
  const proto = new ArrayExoticObjectValue();
  proto.Prototype = realmRec.Intrinsics['%Object.prototype%'];
  proto.Extensible = Value.true;
  proto.properties.set(new Value('length'), Descriptor({
    Value: new Value(0),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  assignProps(realmRec, proto, [['concat', ArrayProto_concat, 1], ['copyWithin', ArrayProto_copyWithin, 2], ['entries', ArrayProto_entries, 0], ['fill', ArrayProto_fill, 1], ['filter', ArrayProto_filter, 1], ['flat', ArrayProto_flat, 0], ['flatMap', ArrayProto_flatMap, 1], ['keys', ArrayProto_keys, 0], ['map', ArrayProto_map, 1], ['pop', ArrayProto_pop, 0], ['push', ArrayProto_push, 1], ['shift', ArrayProto_shift, 0], ['slice', ArrayProto_slice, 2], ['sort', ArrayProto_sort, 1], ['splice', ArrayProto_splice, 2], ['toString', ArrayProto_toString, 0], ['unshift', ArrayProto_unshift, 1], ['values', ArrayProto_values, 0]]);
  CreateArrayPrototypeShared(realmRec, proto, () => {}, O => Get(O, new Value('length')));
  proto.DefineOwnProperty(wellKnownSymbols.iterator, proto.GetOwnProperty(new Value('values')));
  {
    const unscopableList = ObjectCreate(Value.null);

    let _temp147 = CreateDataProperty(unscopableList, new Value('copyWithin'), Value.true);

    Assert(!(_temp147 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('copyWithin'), Value.true)" + ' returned an abrupt completion');

    if (_temp147 instanceof Completion) {
      _temp147 = _temp147.Value;
    }

    Assert(_temp147 === Value.true, "X(CreateDataProperty(unscopableList, new Value('copyWithin'), Value.true)) === Value.true");

    let _temp148 = CreateDataProperty(unscopableList, new Value('entries'), Value.true);

    Assert(!(_temp148 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('entries'), Value.true)" + ' returned an abrupt completion');

    if (_temp148 instanceof Completion) {
      _temp148 = _temp148.Value;
    }

    Assert(_temp148 === Value.true, "X(CreateDataProperty(unscopableList, new Value('entries'), Value.true)) === Value.true");

    let _temp149 = CreateDataProperty(unscopableList, new Value('fill'), Value.true);

    Assert(!(_temp149 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('fill'), Value.true)" + ' returned an abrupt completion');

    if (_temp149 instanceof Completion) {
      _temp149 = _temp149.Value;
    }

    Assert(_temp149 === Value.true, "X(CreateDataProperty(unscopableList, new Value('fill'), Value.true)) === Value.true");

    let _temp150 = CreateDataProperty(unscopableList, new Value('find'), Value.true);

    Assert(!(_temp150 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('find'), Value.true)" + ' returned an abrupt completion');

    if (_temp150 instanceof Completion) {
      _temp150 = _temp150.Value;
    }

    Assert(_temp150 === Value.true, "X(CreateDataProperty(unscopableList, new Value('find'), Value.true)) === Value.true");

    let _temp151 = CreateDataProperty(unscopableList, new Value('findIndex'), Value.true);

    Assert(!(_temp151 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('findIndex'), Value.true)" + ' returned an abrupt completion');

    if (_temp151 instanceof Completion) {
      _temp151 = _temp151.Value;
    }

    Assert(_temp151 === Value.true, "X(CreateDataProperty(unscopableList, new Value('findIndex'), Value.true)) === Value.true");

    let _temp152 = CreateDataProperty(unscopableList, new Value('flat'), Value.true);

    Assert(!(_temp152 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('flat'), Value.true)" + ' returned an abrupt completion');

    if (_temp152 instanceof Completion) {
      _temp152 = _temp152.Value;
    }

    Assert(_temp152 === Value.true, "X(CreateDataProperty(unscopableList, new Value('flat'), Value.true)) === Value.true");

    let _temp153 = CreateDataProperty(unscopableList, new Value('flatMap'), Value.true);

    Assert(!(_temp153 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('flatMap'), Value.true)" + ' returned an abrupt completion');

    if (_temp153 instanceof Completion) {
      _temp153 = _temp153.Value;
    }

    Assert(_temp153 === Value.true, "X(CreateDataProperty(unscopableList, new Value('flatMap'), Value.true)) === Value.true");

    let _temp154 = CreateDataProperty(unscopableList, new Value('includes'), Value.true);

    Assert(!(_temp154 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('includes'), Value.true)" + ' returned an abrupt completion');

    if (_temp154 instanceof Completion) {
      _temp154 = _temp154.Value;
    }

    Assert(_temp154 === Value.true, "X(CreateDataProperty(unscopableList, new Value('includes'), Value.true)) === Value.true");

    let _temp155 = CreateDataProperty(unscopableList, new Value('keys'), Value.true);

    Assert(!(_temp155 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('keys'), Value.true)" + ' returned an abrupt completion');

    if (_temp155 instanceof Completion) {
      _temp155 = _temp155.Value;
    }

    Assert(_temp155 === Value.true, "X(CreateDataProperty(unscopableList, new Value('keys'), Value.true)) === Value.true");

    let _temp156 = CreateDataProperty(unscopableList, new Value('values'), Value.true);

    Assert(!(_temp156 instanceof AbruptCompletion), "CreateDataProperty(unscopableList, new Value('values'), Value.true)" + ' returned an abrupt completion');

    if (_temp156 instanceof Completion) {
      _temp156 = _temp156.Value;
    }

    Assert(_temp156 === Value.true, "X(CreateDataProperty(unscopableList, new Value('values'), Value.true)) === Value.true");

    let _temp157 = proto.DefineOwnProperty(wellKnownSymbols.unscopables, Descriptor({
      Value: unscopableList,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }));

    Assert(!(_temp157 instanceof AbruptCompletion), "proto.DefineOwnProperty(wellKnownSymbols.unscopables, Descriptor({\n      Value: unscopableList,\n      Writable: Value.false,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    }))" + ' returned an abrupt completion');

    if (_temp157 instanceof Completion) {
      _temp157 = _temp157.Value;
    }
  }
  realmRec.Intrinsics['%Array.prototype%'] = proto;
  realmRec.Intrinsics['%Array.prototype.keys%'] = proto.Get(new Value('keys'), proto);
  realmRec.Intrinsics['%Array.prototype.entries%'] = proto.Get(new Value('entries'), proto);
  realmRec.Intrinsics['%Array.prototype.values%'] = proto.Get(new Value('values'), proto);
}

function ArrayConstructor(argumentsList, {
  NewTarget
}) {
  const numberOfArgs = argumentsList.length;

  if (numberOfArgs === 0) {
    // 22.1.1.1 #sec-array-constructor-array
    Assert(numberOfArgs === 0, "numberOfArgs === 0");

    if (Type(NewTarget) === 'Undefined') {
      NewTarget = surroundingAgent.activeFunctionObject;
    }

    const proto = GetPrototypeFromConstructor(NewTarget, '%Array.prototype%');
    return ArrayCreate(new Value(0), proto);
  } else if (numberOfArgs === 1) {
    // 22.1.1.2 #sec-array-len
    const [len] = argumentsList;
    Assert(numberOfArgs === 1, "numberOfArgs === 1");

    if (Type(NewTarget) === 'Undefined') {
      NewTarget = surroundingAgent.activeFunctionObject;
    }

    const proto = GetPrototypeFromConstructor(NewTarget, '%Array.prototype%');
    const array = ArrayCreate(new Value(0), proto);
    let intLen;

    if (Type(len) !== 'Number') {
      let _temp = CreateDataProperty(array, new Value('0'), len);

      Assert(!(_temp instanceof AbruptCompletion), "CreateDataProperty(array, new Value('0'), len)" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      const defineStatus = _temp;
      Assert(defineStatus === Value.true, "defineStatus === Value.true");
      intLen = new Value(1);
    } else {
      intLen = ToUint32(len);

      if (intLen.numberValue() !== len.numberValue()) {
        return surroundingAgent.Throw('RangeError', 'InvalidArrayLength', len);
      }
    }

    Set$1(array, new Value('length'), intLen, Value.true);
    return array;
  } else if (numberOfArgs >= 2) {
    // 22.1.1.3 #sec-array-items
    const items = argumentsList;
    Assert(numberOfArgs >= 2, "numberOfArgs >= 2");

    if (Type(NewTarget) === 'Undefined') {
      NewTarget = surroundingAgent.activeFunctionObject;
    }

    const proto = GetPrototypeFromConstructor(NewTarget, '%Array.prototype%');
    const array = ArrayCreate(new Value(0), proto);
    let k = 0;

    while (k < numberOfArgs) {
      const Pk = ToString(new Value(k));
      const itemK = items[k];

      let _temp2 = CreateDataProperty(array, Pk, itemK);

      Assert(!(_temp2 instanceof AbruptCompletion), "CreateDataProperty(array, Pk, itemK)" + ' returned an abrupt completion');

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      const defineStatus = _temp2;
      Assert(defineStatus === Value.true, "defineStatus === Value.true");
      k += 1;
    }

    let _temp3 = Get(array, new Value('length'));

    Assert(!(_temp3 instanceof AbruptCompletion), "Get(array, new Value('length'))" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    Assert(_temp3.numberValue() === numberOfArgs, "X(Get(array, new Value('length'))).numberValue() === numberOfArgs");
    return array;
  }

  throw new OutOfRange('ArrayConstructor', numberOfArgs);
} // 22.1.2.1 #sec-array.from


function Array_from([items = Value.undefined, mapfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  const C = thisValue;
  let mapping;
  let A;

  if (mapfn === Value.undefined) {
    mapping = false;
  } else {
    if (IsCallable(mapfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', mapfn);
    }

    mapping = true;
  }

  let _temp4 = GetMethod(items, wellKnownSymbols.iterator);
  /* istanbul ignore if */


  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }
  /* istanbul ignore if */


  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const usingIterator = _temp4;

  if (usingIterator !== Value.undefined) {
    if (IsConstructor(C) === Value.true) {
      let _temp5 = Construct(C);

      if (_temp5 instanceof AbruptCompletion) {
        return _temp5;
      }

      if (_temp5 instanceof Completion) {
        _temp5 = _temp5.Value;
      }

      A = _temp5;
    } else {
      let _temp6 = ArrayCreate(new Value(0));

      Assert(!(_temp6 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }

      A = _temp6;
    }

    let _temp7 = GetIterator(items, 'sync', usingIterator);

    if (_temp7 instanceof AbruptCompletion) {
      return _temp7;
    }

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    const iteratorRecord = _temp7;
    let k = 0;

    while (true) {
      // eslint-disable-line no-constant-condition
      if (k >= 2 ** 53 - 1) {
        const error = new ThrowCompletion(surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength').Value);
        return IteratorClose(iteratorRecord, error);
      }

      let _temp8 = ToString(new Value(k));

      Assert(!(_temp8 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp8 instanceof Completion) {
        _temp8 = _temp8.Value;
      }

      const Pk = _temp8;

      let _temp9 = IteratorStep(iteratorRecord);

      if (_temp9 instanceof AbruptCompletion) {
        return _temp9;
      }

      if (_temp9 instanceof Completion) {
        _temp9 = _temp9.Value;
      }

      const next = _temp9;

      if (next === Value.false) {
        let _temp10 = Set$1(A, new Value('length'), new Value(k), Value.true);

        if (_temp10 instanceof AbruptCompletion) {
          return _temp10;
        }

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }
        return A;
      }

      let _temp11 = IteratorValue(next);

      if (_temp11 instanceof AbruptCompletion) {
        return _temp11;
      }

      if (_temp11 instanceof Completion) {
        _temp11 = _temp11.Value;
      }

      const nextValue = _temp11;
      let mappedValue;

      if (mapping) {
        mappedValue = Call(mapfn, thisArg, [nextValue, new Value(k)]);

        if (mappedValue instanceof AbruptCompletion) {
          return IteratorClose(iteratorRecord, mappedValue);
        }

        mappedValue = mappedValue.Value;
      } else {
        mappedValue = nextValue;
      }

      const defineStatus = CreateDataPropertyOrThrow(A, Pk, mappedValue);

      if (defineStatus instanceof AbruptCompletion) {
        return IteratorClose(iteratorRecord, defineStatus);
      }

      k += 1;
    }
  }

  let _temp12 = ToObject(items);

  Assert(!(_temp12 instanceof AbruptCompletion), "ToObject(items)" + ' returned an abrupt completion');

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const arrayLike = _temp12;

  let _temp13 = LengthOfArrayLike(arrayLike);

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  const len = _temp13;

  if (IsConstructor(C) === Value.true) {
    let _temp14 = Construct(C, [len]);

    if (_temp14 instanceof AbruptCompletion) {
      return _temp14;
    }

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    A = _temp14;
  } else {
    let _temp15 = ArrayCreate(len);

    if (_temp15 instanceof AbruptCompletion) {
      return _temp15;
    }

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    A = _temp15;
  }

  let k = 0;

  while (k < len.numberValue()) {
    let _temp16 = ToString(new Value(k));

    Assert(!(_temp16 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }

    const Pk = _temp16;

    let _temp17 = Get(arrayLike, Pk);

    if (_temp17 instanceof AbruptCompletion) {
      return _temp17;
    }

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    const kValue = _temp17;
    let mappedValue;

    if (mapping === true) {
      let _temp18 = Call(mapfn, thisArg, [kValue, new Value(k)]);

      if (_temp18 instanceof AbruptCompletion) {
        return _temp18;
      }

      if (_temp18 instanceof Completion) {
        _temp18 = _temp18.Value;
      }

      mappedValue = _temp18;
    } else {
      mappedValue = kValue;
    }

    let _temp19 = CreateDataPropertyOrThrow(A, Pk, mappedValue);

    if (_temp19 instanceof AbruptCompletion) {
      return _temp19;
    }

    if (_temp19 instanceof Completion) {
      _temp19 = _temp19.Value;
    }
    k += 1;
  }

  let _temp20 = Set$1(A, new Value('length'), len, Value.true);

  if (_temp20 instanceof AbruptCompletion) {
    return _temp20;
  }

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }
  return A;
} // 22.1.2.2 #sec-array.isarray


function Array_isArray([arg = Value.undefined]) {
  return IsArray(arg);
} // 22.1.2.3 #sec-array.of


function Array_of(items, {
  thisValue
}) {
  const len = items.length; // Let items be the List of arguments passed to this function.

  const C = thisValue;
  let A;

  if (IsConstructor(C) === Value.true) {
    let _temp21 = Construct(C, [new Value(len)]);

    if (_temp21 instanceof AbruptCompletion) {
      return _temp21;
    }

    if (_temp21 instanceof Completion) {
      _temp21 = _temp21.Value;
    }

    A = _temp21;
  } else {
    let _temp22 = ArrayCreate(new Value(len));

    if (_temp22 instanceof AbruptCompletion) {
      return _temp22;
    }

    if (_temp22 instanceof Completion) {
      _temp22 = _temp22.Value;
    }

    A = _temp22;
  }

  let k = 0;

  while (k < len) {
    const kValue = items[k];

    let _temp23 = ToString(new Value(k));

    Assert(!(_temp23 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp23 instanceof Completion) {
      _temp23 = _temp23.Value;
    }

    const Pk = _temp23;

    let _temp24 = CreateDataPropertyOrThrow(A, Pk, kValue);

    if (_temp24 instanceof AbruptCompletion) {
      return _temp24;
    }

    if (_temp24 instanceof Completion) {
      _temp24 = _temp24.Value;
    }
    k += 1;
  }

  let _temp25 = Set$1(A, new Value('length'), new Value(len), Value.true);

  if (_temp25 instanceof AbruptCompletion) {
    return _temp25;
  }

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }
  return A;
} // 22.1.2.5 #sec-get-array-@@species


function Array_speciesGetter(args, {
  thisValue
}) {
  return thisValue;
}

function CreateArray(realmRec) {
  const proto = realmRec.Intrinsics['%Array.prototype%'];
  const cons = BootstrapConstructor(realmRec, ArrayConstructor, 'Array', 1, proto, [['from', Array_from, 1], ['isArray', Array_isArray, 1], ['of', Array_of, 0], [wellKnownSymbols.species, [Array_speciesGetter]]]);
  realmRec.Intrinsics['%Array%'] = cons;
}

function BigIntConstructor([value], {
  NewTarget
}) {
  // 1. If NewTarget is not undefined, throw a TypeError exception.
  if (NewTarget !== Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', 'BigInt');
  } // 2. Let prim be ? ToPrimitive(value, hint Number).


  let _temp = ToPrimitive(value, 'Number');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const prim = _temp; // 3. If Type(prim) is Number, return ? NumberToBigInt(prim).
  // 4. Otherwise, return ? ToBigInt(value).

  if (Type(prim) === 'Number') {
    return NumberToBigInt(prim);
  } else {
    return ToBigInt(value);
  }
} // #sec-bigint.asintn


function BigInt_asIntN([bits = Value.undefined, bigint = Value.undefined]) {
  let _temp2 = ToIndex(bits);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  // 1. Set bits to ? ToIndex(bits).
  bits = _temp2; // 2. Set bigint to ? ToBigInt(bigint).

  let _temp3 = ToBigInt(bigint);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  bigint = _temp3; // 3. Let mod be the BigInt value that represents bigint modulo 2bits.
  // 4. If mod  2^bits - 1, return mod - 2^bits; otherwise, return mod.

  return new Value(BigInt.asIntN(bits.numberValue(), bigint.bigintValue()));
} // #sec-bigint.asuintn


function BigInt_asUintN([bits = Value.undefined, bigint = Value.undefined]) {
  let _temp4 = ToIndex(bits);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  // 1. Set bits to ? ToIndex(bits).
  bits = _temp4; // 2. Set bigint to ? ToBigInt(bigint).

  let _temp5 = ToBigInt(bigint);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  bigint = _temp5; // 3. Return the BigInt value that represents bigint modulo 2^bits.

  return new Value(BigInt.asUintN(bits.numberValue(), bigint.bigintValue()));
}

function CreateBigInt(realmRec) {
  const bigintConstructor = BootstrapConstructor(realmRec, BigIntConstructor, 'BigInt', 1, realmRec.Intrinsics['%BigInt.prototype%'], [['asIntN', BigInt_asIntN, 2], ['asUintN', BigInt_asUintN, 2]]);
  realmRec.Intrinsics['%BigInt%'] = bigintConstructor;
}

function thisBigIntValue(value) {
  // 1. If Type(value) is BigInt, return value.
  if (Type(value) === 'BigInt') {
    return value;
  } // 2. If Type(value) is Object and value has a [[BigIntData]] internal slot, then


  if (Type(value) === 'Object' && 'BigIntData' in value) {
    // a. Assert: Type(value.[[BigIntData]]) is BigInt.
    Assert(Type(value.BigIntData) === 'BigInt', "Type(value.BigIntData) === 'BigInt'"); // b. Return value.[[BigIntData]].

    return value.BigIntData;
  } // 3. Throw a TypeError exception.


  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'BigInt', value);
} // #sec-bigint.prototype.tolocalestring


function BigIntProto_toLocalString(args, {
  thisValue
}) {
  return BigIntProto_toString(args, {
    thisValue
  });
} // #sec-bigint.prototype.tostring


function BigIntProto_toString([radix], {
  thisValue
}) {
  let _temp = thisBigIntValue(thisValue);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  // 1. Let x be ? thisBigIntValue(this value).
  const x = _temp; // 2. If radix is not present, let radixNumber be 10.

  let radixNumber;

  if (radix === undefined) {
    radixNumber = 10;
  } else if (radix === Value.undefined) {
    // 3. Else if radix is undefined, let radixNumber be 10.
    radixNumber = 10;
  } else {
    let _temp2 = ToInteger(radix);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    // 4. Else, let radixNumber be ? ToInteger(radix).
    radixNumber = _temp2.numberValue();
  } // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.


  if (radixNumber < 2 || radixNumber > 36) {
    return surroundingAgent.Throw('RangeError', 'InvalidRadix');
  } // 6. If radixNumber = 10, return ! ToString(x).


  if (radixNumber === 10) {
    let _temp3 = ToString(x);

    Assert(!(_temp3 instanceof AbruptCompletion), "ToString(x)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    return _temp3;
  } // 7. Return the String representation of this Number value using the radix specified by
  //    radixNumber. Letters a-z are used for digits with values 10 through 35. The precise
  //    algorithm is implementation-dependent, however the algorithm should be a
  //    generalization of that specified in 6.1.6.2.23.
  // TODO: Implementation stringification


  return new Value(x.bigintValue().toString(radixNumber));
} // #sec-bigint.prototype.tostring


function BigIntProto_valueOf(args, {
  thisValue
}) {
  // Return ? thisBigIntValue(this value).
  return thisBigIntValue(thisValue);
}

function CreateBigIntPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['toLocaleString', BigIntProto_toLocalString, 0], ['toString', BigIntProto_toString, 0], ['valueOf', BigIntProto_valueOf, 0]], realmRec.Intrinsics['%Object.prototype%'], 'BigInt');
  realmRec.Intrinsics['%BigInt.prototype%'] = proto;
}

function thisBooleanValue(value) {
  if (Type(value) === 'Boolean') {
    return value;
  }

  if (Type(value) === 'Object' && 'BooleanData' in value) {
    const b = value.BooleanData;
    Assert(Type(b) === 'Boolean', "Type(b) === 'Boolean'");
    return b;
  }

  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Boolean', value);
}

function BooleanProto_toString(argList, {
  thisValue
}) {
  let _temp = thisBooleanValue(thisValue);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const b = _temp;

  if (b === Value.true) {
    return new Value('true');
  }

  return new Value('false');
}

function BooleanProto_valueOf(argList, {
  thisValue
}) {
  return thisBooleanValue(thisValue);
}

function CreateBooleanPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['toString', BooleanProto_toString, 0], ['valueOf', BooleanProto_valueOf, 0]], realmRec.Intrinsics['%Object.prototype%']);
  proto.BooleanData = Value.false;
  realmRec.Intrinsics['%Boolean.prototype%'] = proto;
}

function BooleanConstructor([value = Value.undefined], {
  NewTarget
}) {
  const b = ToBoolean(value);

  if (Type(NewTarget) === 'Undefined') {
    return b;
  }

  let _temp = OrdinaryCreateFromConstructor(NewTarget, '%Boolean.prototype%', ['BooleanData']);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const O = _temp;
  O.BooleanData = b;
  return O;
}

function CreateBoolean(realmRec) {
  const cons = BootstrapConstructor(realmRec, BooleanConstructor, 'Boolean', 1, realmRec.Intrinsics['%Boolean.prototype%'], []);
  realmRec.Intrinsics['%Boolean%'] = cons;
}

function thisNumberValue(value) {
  if (Type(value) === 'Number') {
    return value;
  }

  if (Type(value) === 'Object' && 'NumberData' in value) {
    const n = value.NumberData;
    Assert(Type(n) === 'Number', "Type(n) === 'Number'");
    return n;
  }

  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Number', value);
} // 20.1.3.2 #sec-number.prototype.toexponential


function NumberProto_toExponential([fractionDigits = Value.undefined], {
  thisValue
}) {
  let _temp = thisNumberValue(thisValue);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let x = _temp.numberValue();

  let _temp2 = ToInteger(fractionDigits);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const f = _temp2.numberValue();

  Assert(fractionDigits !== Value.undefined || f === 0, "fractionDigits !== Value.undefined || f === 0");

  if (Number.isNaN(x)) {
    return new Value('NaN');
  }

  let s = '';

  if (x < 0) {
    s = '-';
    x = -x;
  }

  if (x === Infinity) {
    return new Value(`${s}Infinity`);
  }

  if (f < 0 || f > 100) {
    return surroundingAgent.Throw('RangeError', 'NumberFormatRange', 'toExponential');
  }

  let m;
  let e;

  if (x === 0) {
    m = '0'.repeat(f + 1);
    e = 0;
  } else {
    let n;

    m = String(n);
    return surroundingAgent.Throw('Error', 'Raw', 'Number.prototype.toExponential is not fully implemented');
  }

  if (f !== 0) {
    const a = m[0];
    const b = m.slice(1);
    m = `${a}.${b}`;
  }

  let c;
  let d;

  if (e === 0) {
    c = '+';
    d = '0';
  } else {
    if (e > 0) {
      c = '+';
    } else {
      c = '-';
      e = -e;
    }

    d = String(e);
  }

  m = `${m}e${c}${d}`;
  return new Value(`${s}${m}`);
} // 20.1.3.3 #sec-number.prototype.tofixed


function NumberProto_toFixed([fractionDigits = Value.undefined], {
  thisValue
}) {
  let _temp3 = thisNumberValue(thisValue);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  let x = _temp3.numberValue();

  let _temp4 = ToInteger(fractionDigits);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const f = _temp4.numberValue();

  Assert(fractionDigits !== Value.undefined || f === 0, "fractionDigits !== Value.undefined || f === 0");

  if (f < 0 || f > 100) {
    return surroundingAgent.Throw('RangeError', 'NumberFormatRange', 'toFixed');
  }

  if (Number.isNaN(x)) {
    return new Value('NaN');
  }

  let s = '';

  if (x < 0) {
    s = '-';
    x = -x;
  }

  let m;

  if (x >= 10 ** 21) {
    let _temp5 = ToString(new Value(x));

    Assert(!(_temp5 instanceof AbruptCompletion), "ToString(new Value(x))" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    m = _temp5.stringValue();
  } else {
    // TODO: compute n.
    // if (n === 0) {
    //   m = '0';
    // } else {
    //   m = String(n);
    // }
    // if (f !== 0) {
    //   let k = m.length;
    //   if (k <= f) {
    //     const z = '0'.repeat(f + 1 - k);
    //     m = `${z}${m}`;
    //     k = f + 1;
    //   }
    //   const a = m.slice(0, k - f);
    //   const b = m.slice(k - f);
    //   m = `${a}.${b}`;
    // }
    return surroundingAgent.Throw('Error', 'Raw', 'Number.prototype.toFixed is not fully implemented');
  }

  return new Value(`${s}${m}`);
} // 20.1.3.4 #sec-number.prototype.tolocalestring


function NumberProto_toLocaleString() {
  return surroundingAgent.Throw('Error', 'Raw', 'Number.prototype.toLocaleString is not implemented');
} // 20.1.3.5 #sec-number.prototype.toprecision


function NumberProto_toPrecision([precision = Value.undefined], {
  thisValue
}) {
  let _temp6 = thisNumberValue(thisValue);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  let x = _temp6.numberValue();

  if (precision === Value.undefined) {
    let _temp7 = ToString(new Value(x));

    Assert(!(_temp7 instanceof AbruptCompletion), "ToString(new Value(x))" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    return _temp7;
  }

  let _temp8 = ToInteger(precision);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const p = _temp8.numberValue();

  if (Number.isNaN(x)) {
    return new Value('NaN');
  }

  let s = '';

  if (x < 0) {
    s = '-';
    x = -x;
  }

  if (x === Infinity) {
    return new Value(`${s}Infinity`);
  }

  if (p < 1 || p > 100) {
    return surroundingAgent.Throw('RangeError', 'NumberFormatRange', 'toPrecision');
  }

  let m;
  let e;

  if (x === 0) {
    m = '0'.repeat(p);
    e = 0;
  } else {
    // TODO: compute e and n.
    // m = String(n);
    // if (e < -6 || e >= p) {
    //   Assert(e !== 0);
    //   if (p !== 1) {
    //     const a = m[0];
    //     const b = m.slice(1);
    //     m = `${a}.${b}`;
    //   }
    //   let c;
    //   if (e > 0) {
    //     c = '+';
    //   } else {
    //     c = '-';
    //     e = -e;
    //   }
    //   const d = String(e);
    //   return new Value(`${s}${m}e${c}${d}`);
    // }
    return surroundingAgent.Throw('Error', 'Raw', 'Number.prototype.toPrecision is not fully implemented');
  }

  if (e === p - 1) {
    return new Value(`${s}${m}`);
  }

  if (e >= 0) {
    m = `${m.slice(0, e + 1)}.${m.slice(e + 1)}`;
  } else {
    m = `0.${'0'.repeat(-(e + 1))}${m}`;
  }

  return new Value(`${s}${m}`);
} // 20.1.3.6 #sec-number.prototype.tostring


function NumberProto_toString([radix = Value.undefined], {
  thisValue
}) {
  let _temp9 = thisNumberValue(thisValue);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const x = _temp9;
  let radixNumber;

  if (radix === Value.undefined) {
    radixNumber = 10;
  } else {
    let _temp10 = ToInteger(radix);

    if (_temp10 instanceof AbruptCompletion) {
      return _temp10;
    }

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }

    radixNumber = _temp10.numberValue();
  }

  if (radixNumber < 2 || radixNumber > 36) {
    return surroundingAgent.Throw('TypeError');
  }

  if (radixNumber === 10) {
    let _temp11 = ToString(x);

    Assert(!(_temp11 instanceof AbruptCompletion), "ToString(x)" + ' returned an abrupt completion');

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    return _temp11;
  } // FIXME(devsnek): Return the String representation of this Number
  // value using the radix specified by radixNumber. Letters a-z are
  // used for digits with values 10 through 35. The precise algorithm
  // is implementation-dependent, however the algorithm should be a
  // generalization of that specified in 7.1.12.1.


  return new Value(x.numberValue().toString());
} // 20.1.3.7 #sec-number.prototype.valueof


function NumberProto_valueOf(args, {
  thisValue
}) {
  return thisNumberValue(thisValue);
}

function CreateNumberPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['toExponential', NumberProto_toExponential, 1], ['toFixed', NumberProto_toFixed, 1], ['toLocaleString', NumberProto_toLocaleString, 0], ['toPrecision', NumberProto_toPrecision, 1], ['toString', NumberProto_toString, 0], ['valueOf', NumberProto_valueOf, 0]], realmRec.Intrinsics['%Object.prototype%']);
  proto.NumberData = new Value(0);
  realmRec.Intrinsics['%Number.prototype%'] = proto;
}

function NumberConstructor([value], {
  NewTarget
}) {
  let n;

  if (value !== undefined) {
    let _temp = ToNumeric(value);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const prim = _temp;

    if (Type(prim) === 'BigInt') {
      n = new Value(Number(prim.bigintValue()));
    } else {
      n = prim;
    }
  } else {
    n = new Value(0);
  }

  if (NewTarget === Value.undefined) {
    return n;
  }

  const O = OrdinaryCreateFromConstructor(NewTarget, '%Number.prototype%', ['NumberData']);
  O.NumberData = n;
  return O;
} // 20.1.2.2 #sec-number.isfinite


function Number_isFinite([number = Value.undefined]) {
  if (Type(number) !== 'Number') {
    return Value.false;
  }

  if (number.isNaN() || number.isInfinity()) {
    return Value.false;
  }

  return Value.true;
} // 20.1.2.3 #sec-number.isinteger


function Number_isInteger([number = Value.undefined]) {
  let _temp2 = IsInteger(number);

  Assert(!(_temp2 instanceof AbruptCompletion), "IsInteger(number)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  return _temp2;
} // 20.1.2.4 #sec-number.isnan


function Number_isNaN([number = Value.undefined]) {
  if (Type(number) !== 'Number') {
    return Value.false;
  }

  if (number.isNaN()) {
    return Value.true;
  }

  return Value.false;
} // 20.1.2.5 #sec-number.issafeinteger


function Number_isSafeInteger([number = Value.undefined]) {
  if (Type(number) !== 'Number') {
    return Value.false;
  }

  let _temp3 = IsInteger(number);

  Assert(!(_temp3 instanceof AbruptCompletion), "IsInteger(number)" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  if (_temp3 === Value.true) {
    if (Math.abs(number.numberValue()) <= 2 ** 53 - 1) {
      return Value.true;
    }
  }

  return Value.false;
}

function CreateNumber(realmRec) {
  const override = {
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  };
  const numberConstructor = BootstrapConstructor(realmRec, NumberConstructor, 'Number', 1, realmRec.Intrinsics['%Number.prototype%'], [['EPSILON', new Value(Number.EPSILON), undefined, override], ['MAX_SAFE_INTEGER', new Value(Number.MAX_SAFE_INTEGER), undefined, override], ['MAX_VALUE', new Value(Number.MAX_VALUE), undefined, override], ['MIN_SAFE_INTEGER', new Value(Number.MIN_SAFE_INTEGER), undefined, override], ['MIN_VALUE', new Value(Number.MIN_VALUE), undefined, override], ['NaN', new Value(NaN), undefined, override], ['NEGATIVE_INFINITY', new Value(-Infinity), undefined, override], ['POSITIVE_INFINITY', new Value(Infinity), undefined, override], ['isFinite', Number_isFinite, 1], ['isInteger', Number_isInteger, 1], ['isNaN', Number_isNaN, 1], ['isSafeInteger', Number_isSafeInteger, 1]]); // 20.1.2.12 #sec-number.parsefloat
  // The value of the Number.parseFloat data property is the same built-in function object that is the value of the parseFloat property of the global object defined in 18.2.4.

  let _temp4 = numberConstructor.DefineOwnProperty(new Value('parseFloat'), Descriptor({
    Value: realmRec.Intrinsics['%parseFloat%'],
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp4 instanceof AbruptCompletion), "numberConstructor.DefineOwnProperty(new Value('parseFloat'), Descriptor({\n    Value: realmRec.Intrinsics['%parseFloat%'],\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  // The value of the Number.parseInt data property is the same built-in function object that is the value of the parseInt property of the global object defined in 18.2.5.

  let _temp5 = numberConstructor.DefineOwnProperty(new Value('parseInt'), Descriptor({
    Value: realmRec.Intrinsics['%parseInt%'],
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp5 instanceof AbruptCompletion), "numberConstructor.DefineOwnProperty(new Value('parseInt'), Descriptor({\n    Value: realmRec.Intrinsics['%parseInt%'],\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }
  realmRec.Intrinsics['%Number%'] = numberConstructor;
}

function FunctionProto_apply([thisArg = Value.undefined, argArray = Value.undefined], {
  thisValue: func
}) {
  if (IsCallable(func) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
  }

  if (Type(argArray) === 'Undefined' || Type(argArray) === 'Null') {
    return Call(func, thisArg);
  }

  let _temp = CreateListFromArrayLike(argArray);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const argList = _temp;
  return Call(func, thisArg, argList);
}

function BoundFunctionExoticObjectCall(thisArgument, argumentsList) {
  const F = this;
  const target = F.BoundTargetFunction;
  const boundThis = F.BoundThis;
  const boundArgs = F.BoundArguments;
  const args = [...boundArgs, ...argumentsList];
  return Call(target, boundThis, args);
}

function BoundFunctionExoticObjectConstruct(argumentsList, newTarget) {
  const F = this;
  const target = F.BoundTargetFunction;
  Assert(IsConstructor(target) === Value.true, "IsConstructor(target) === Value.true");
  const boundArgs = F.BoundArguments;
  const args = [...boundArgs, ...argumentsList];

  if (SameValue(F, newTarget) === Value.true) {
    newTarget = target;
  }

  return Construct(target, args, newTarget);
} // 9.4.1.3 #sec-boundfunctioncreate


function BoundFunctionCreate(targetFunction, boundThis, boundArgs) {
  Assert(Type(targetFunction) === 'Object', "Type(targetFunction) === 'Object'");

  let _temp2 = targetFunction.GetPrototypeOf();

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const proto = _temp2;
  const obj = new ObjectValue();
  obj.Call = BoundFunctionExoticObjectCall;

  if (IsConstructor(targetFunction) === Value.true) {
    obj.Construct = BoundFunctionExoticObjectConstruct;
  }

  obj.Prototype = proto;
  obj.Extensible = Value.true;
  obj.BoundTargetFunction = targetFunction;
  obj.BoundThis = boundThis;
  obj.BoundArguments = boundArgs;
  return obj;
}

function FunctionProto_bind([thisArg = Value.undefined, ...args], {
  thisValue
}) {
  const Target = thisValue;

  if (IsCallable(Target) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', Target);
  } // Let args be a new (possibly empty) List consisting of all
  // of the argument values provided after thisArg in order.


  let _temp3 = BoundFunctionCreate(Target, thisArg, args);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const F = _temp3;

  let _temp4 = HasOwnProperty$1(Target, new Value('length'));

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const targetHasLength = _temp4;
  let L;

  if (targetHasLength === Value.true) {
    let _temp5 = Get(Target, new Value('length'));

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    let targetLen = _temp5;

    if (Type(targetLen) !== 'Number') {
      L = 0;
    } else {
      let _temp6 = ToInteger(targetLen);

      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }

      targetLen = _temp6.numberValue();
      L = Math.max(0, targetLen - args.length);
    }
  } else {
    L = 0;
  }

  let _temp7 = SetFunctionLength(F, new Value(L));

  Assert(!(_temp7 instanceof AbruptCompletion), "SetFunctionLength(F, new Value(L))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  let _temp8 = Get(Target, new Value('name'));

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  let targetName = _temp8;

  if (Type(targetName) !== 'String') {
    targetName = new Value('');
  }

  SetFunctionName(F, targetName, new Value('bound'));
  return F;
}

function FunctionProto_call([thisArg = Value.undefined, ...args], {
  thisValue: func
}) {
  if (IsCallable(func) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
  }

  const argList = [];

  for (const arg of args) {
    argList.push(arg);
  }
  return Call(func, thisArg, argList);
}

function FunctionProto_toString(args, {
  thisValue: func
}) {
  if ('BoundTargetFunction' in func || 'nativeFunction' in func) {
    const name = func.properties.get(new Value('name'));

    if (name !== undefined) {
      return new Value(`function ${name.Value.stringValue()}() { [native code] }`);
    }

    return new Value('function() { [native code] }');
  }

  let _temp9 = HostHasSourceTextAvailable(func);

  Assert(!(_temp9 instanceof AbruptCompletion), "HostHasSourceTextAvailable(func)" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  if (Type(func) === 'Object' && 'SourceText' in func && Type(func.SourceText) === 'String' && _temp9 === Value.true) {
    return func.SourceText;
  }

  if (Type(func) === 'Object' && IsCallable(func) === Value.true) {
    return new Value('function() { [native code] }');
  }

  return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
}

function FunctionProto_hasInstance([V = Value.undefined], {
  thisValue
}) {
  const F = thisValue;
  return OrdinaryHasInstance(F, V);
}

function CreateFunctionPrototype(realmRec) {
  const proto = CreateBuiltinFunction(() => Value.undefined, [], realmRec, realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Function.prototype%'] = proto;
  SetFunctionLength(proto, new Value(0));
  SetFunctionName(proto, new Value(''));
  const readonly = {
    Writable: Value.false,
    Configurable: Value.false
  };
  assignProps(realmRec, proto, [['apply', FunctionProto_apply, 2], ['bind', FunctionProto_bind, 1], ['call', FunctionProto_call, 1], ['toString', FunctionProto_toString, 0], [wellKnownSymbols.hasInstance, FunctionProto_hasInstance, 1, readonly]]);
}

function FunctionConstructor(args, {
  NewTarget
}) {
  const C = surroundingAgent.activeFunctionObject;
  return CreateDynamicFunction(C, NewTarget, 'normal', args);
}

function CreateFunction(realmRec) {
  const cons = BootstrapConstructor(realmRec, FunctionConstructor, 'Function', 1, realmRec.Intrinsics['%Function.prototype%'], []);
  realmRec.Intrinsics['%Function%'] = cons;
}

function thisSymbolValue(value) {
  if (Type(value) === 'Symbol') {
    return value;
  }

  if (Type(value) === 'Object' && 'SymbolData' in value) {
    const s = value.SymbolData;
    Assert(Type(s) === 'Symbol', "Type(s) === 'Symbol'");
    return s;
  }

  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Symbol', value);
}

function SymbolProto_toString(argList, {
  thisValue
}) {
  let _temp = thisSymbolValue(thisValue);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const sym = _temp;
  return SymbolDescriptiveString(sym);
}

function SymbolProto_descriptionGetter(argList, {
  thisValue
}) {
  const s = thisValue;

  let _temp2 = thisSymbolValue(s);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const sym = _temp2;
  return sym.Description;
}

function SymbolProto_valueOf(argList, {
  thisValue
}) {
  return thisSymbolValue(thisValue);
}

function SymbolProto_toPrimitive(argList, {
  thisValue
}) {
  return thisSymbolValue(thisValue);
}

function CreateSymbolPrototype(realmRec) {
  const override = {
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  };
  const proto = BootstrapPrototype(realmRec, [['toString', SymbolProto_toString, 0], ['description', [SymbolProto_descriptionGetter]], ['valueOf', SymbolProto_valueOf, 0], [wellKnownSymbols.toPrimitive, SymbolProto_toPrimitive, 1, override], [wellKnownSymbols.toStringTag, new Value('Symbol'), undefined, override]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Symbol.prototype%'] = proto;
}

const GlobalSymbolRegistry = [];

function SymbolConstructor([description = Value.undefined], {
  NewTarget
}) {
  if (NewTarget !== Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', surroundingAgent.activeFunctionObject);
  }

  let descString;

  if (description === Value.undefined) {
    descString = Value.undefined;
  } else {
    let _temp = ToString(description);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    descString = _temp;
  }

  return new SymbolValue(descString);
}

function Symbol_for([key = Value.undefined]) {
  let _temp2 = ToString(key);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const stringKey = _temp2;

  for (const e of GlobalSymbolRegistry) {
    if (SameValue(e.Key, stringKey) === Value.true) {
      return e.Symbol;
    }
  } // Assert: GlobalSymbolRegistry does not currently contain an entry for stringKey.


  const newSymbol = new SymbolValue(stringKey);
  GlobalSymbolRegistry.push({
    Key: stringKey,
    Symbol: newSymbol
  });
  return newSymbol;
}

function Symbol_keyFor([sym = Value.undefined]) {
  if (Type(sym) !== 'Symbol') {
    return surroundingAgent.Throw('TypeError', 'NotASymbol', sym);
  }

  for (const e of GlobalSymbolRegistry) {
    if (SameValue(e.Symbol, sym) === Value.true) {
      return e.Key;
    }
  }

  return Value.undefined;
}

function CreateSymbol(realmRec) {
  const symbolConstructor = BootstrapConstructor(realmRec, SymbolConstructor, 'Symbol', 0, realmRec.Intrinsics['%Symbol.prototype%'], [['for', Symbol_for, 1], ['keyFor', Symbol_keyFor, 1]]);

  for (const [name, sym] of Object.entries(wellKnownSymbols)) {
    symbolConstructor.DefineOwnProperty(new Value(name), Descriptor({
      Value: sym,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
  }

  symbolConstructor.DefineOwnProperty(new Value('prototype'), Descriptor({
    Value: realmRec.Intrinsics['%Symbol.prototype%'],
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  realmRec.Intrinsics['%Symbol%'] = symbolConstructor;
}

function Math_abs([x = Value.undefined]) {
  let _temp = ToNumber(x);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  x = _temp;

  if (x.isNaN()) {
    return x;
  } else if (Object.is(x.numberValue(), -0)) {
    return new Value(0);
  } else if (x.isInfinity()) {
    return new Value(Infinity);
  }

  if (x.numberValue() < 0) {
    return new Value(-x.numberValue());
  }

  return x;
} // 20.2.2.2 #sec-math.acos


function Math_acos([x = Value.undefined]) {
  let _temp2 = ToNumber(x);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  x = _temp2;

  if (x.isNaN()) {
    return x;
  } else if (x.numberValue() > 1) {
    return new Value(NaN);
  } else if (x.numberValue() < -1) {
    return new Value(NaN);
  } else if (x.numberValue() === 1) {
    return new Value(+0);
  }

  return new Value(Math.acos(x.numberValue()));
} // #sec-math.pow


function Math_pow([base = Value.undefined, exponent = Value.undefined]) {
  let _temp3 = ToNumber(base);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  // 1. Set base to ? ToNumber(base).
  base = _temp3; // 2. Set exponent to ? ToNumber(exponent).

  let _temp4 = ToNumber(exponent);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  exponent = _temp4; // 3. Return ! Number::exponentiate(base, exponent).

  let _temp5 = NumberValue.exponentiate(base, exponent);

  Assert(!(_temp5 instanceof AbruptCompletion), "NumberValue.exponentiate(base, exponent)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  return _temp5;
} // 20.2 #sec-math-object


function CreateMath(realmRec) {
  // 20.2.1 #sec-value-properties-of-the-math-object
  const readonly = {
    Writable: Value.false,
    Configurable: Value.false
  };
  const valueProps = [['E', 2.7182818284590452354], ['LN10', 2.302585092994046], ['LN2', 0.6931471805599453], ['LOG10E', 0.4342944819032518], ['LOG2E', 1.4426950408889634], ['PI', 3.1415926535897932], ['SQRT1_2', 0.7071067811865476], ['SQRT2', 1.4142135623730951]].map(([name, value]) => [name, new Value(value), undefined, readonly]); // @@toStringTag is handled in the BootstrapPrototype() call.

  const mathObj = BootstrapPrototype(realmRec, [...valueProps, ['abs', Math_abs, 1], ['acos', Math_acos, 1], ['pow', Math_pow, 2]], realmRec.Intrinsics['%Object.prototype%'], 'Math'); // 20.2.2 #sec-function-properties-of-the-math-object

  [['acosh', 1], ['asin', 1], ['asinh', 1], ['atan', 1], ['atanh', 1], ['atan2', 2], ['cbrt', 1], ['ceil', 1], ['clz32', 1], ['cos', 1], ['cosh', 1], ['exp', 1], ['expm1', 1], ['floor', 1], ['fround', 1], ['hypot', 2], ['imul', 2], ['log', 1], ['log1p', 1], ['log10', 1], ['log2', 1], ['max', 2], ['min', 2], ['random', 0], ['round', 1], ['sign', 1], ['sin', 1], ['sinh', 1], ['sqrt', 1], ['tan', 1], ['tanh', 1], ['trunc', 1]].forEach(([name, length]) => {
    // TODO(18): Math
    const func = CreateBuiltinFunction(args => {
      for (let i = 0; i < args.length; i += 1) {
        let _temp6 = ToNumber(args[i]);

        if (_temp6 instanceof AbruptCompletion) {
          return _temp6;
        }

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        args[i] = _temp6.numberValue();
      }

      return new Value(Math[name](...args));
    }, [], realmRec);

    let _temp7 = SetFunctionName(func, new Value(name));

    Assert(!(_temp7 instanceof AbruptCompletion), "SetFunctionName(func, new Value(name))" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    let _temp8 = SetFunctionLength(func, new Value(length));

    Assert(!(_temp8 instanceof AbruptCompletion), "SetFunctionLength(func, new Value(length))" + ' returned an abrupt completion');

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }
    mathObj.DefineOwnProperty(new Value(name), Descriptor({
      Value: func,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
  });
  realmRec.Intrinsics['%Math%'] = mathObj;
}

function thisTimeValue(value) {
  if (Type(value) === 'Object' && 'DateValue' in value) {
    return value.DateValue;
  }

  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', value);
} // 20.3.4.2 #sec-date.prototype.getdate

function DateProto_getDate(args, {
  thisValue
}) {
  let _temp = thisTimeValue(thisValue);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const t = _temp;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return DateFromTime(LocalTime(t));
} // 20.3.4.3 #sec-date.prototype.getday


function DateProto_getDay(args, {
  thisValue
}) {
  let _temp2 = thisTimeValue(thisValue);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const t = _temp2;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return WeekDay(LocalTime(t));
} // 20.3.4.4 #sec-date.prototype.getfullyear


function DateProto_getFullYear(args, {
  thisValue
}) {
  let _temp3 = thisTimeValue(thisValue);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const t = _temp3;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return YearFromTime(LocalTime(t));
} // 20.3.4.5 #sec-date.prototype.gethours


function DateProto_getHours(args, {
  thisValue
}) {
  let _temp4 = thisTimeValue(thisValue);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const t = _temp4;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return HourFromTime(LocalTime(t));
} // 20.3.4.6 #sec-date.prototype.getmilliseconds


function DateProto_getMilliseconds(args, {
  thisValue
}) {
  let _temp5 = thisTimeValue(thisValue);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const t = _temp5;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return msFromTime(LocalTime(t));
} // 20.3.4.7 #sec-date.prototype.getminutes


function DateProto_getMinutes(args, {
  thisValue
}) {
  let _temp6 = thisTimeValue(thisValue);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const t = _temp6;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return MinFromTime(LocalTime(t));
} // 20.3.4.8 #sec-date.prototype.getmonth


function DateProto_getMonth(args, {
  thisValue
}) {
  let _temp7 = thisTimeValue(thisValue);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const t = _temp7;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return MonthFromTime(LocalTime(t));
} // 20.3.4.9 #sec-date.prototype.getseconds


function DateProto_getSeconds(args, {
  thisValue
}) {
  let _temp8 = thisTimeValue(thisValue);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const t = _temp8;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return SecFromTime(LocalTime(t));
} // 20.3.4.10 #sec-date.prototype.gettime


function DateProto_getTime(args, {
  thisValue
}) {
  return thisTimeValue(thisValue);
} // 20.3.4.11 #sec-date.prototype.gettimezoneoffset


function DateProto_getTimezoneOffset(args, {
  thisValue
}) {
  let _temp9 = thisTimeValue(thisValue);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const t = _temp9;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return new Value(t.numberValue() - LocalTime(t).numberValue() / msPerMinute);
} // 20.3.4.12 #sec-date.prototype.getutcdate


function DateProto_getUTCDate(args, {
  thisValue
}) {
  let _temp10 = thisTimeValue(thisValue);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const t = _temp10;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return DateFromTime(t);
} // 20.3.4.13 #sec-date.prototype.getutcday


function DateProto_getUTCDay(args, {
  thisValue
}) {
  let _temp11 = thisTimeValue(thisValue);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const t = _temp11;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return WeekDay(t);
} // 20.3.4.14 #sec-date.prototype.getutcfullyear


function DateProto_getUTCFullYear(args, {
  thisValue
}) {
  let _temp12 = thisTimeValue(thisValue);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const t = _temp12;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return YearFromTime(t);
} // 20.3.4.15 #sec-date.prototype.getutchours


function DateProto_getUTCHours(args, {
  thisValue
}) {
  let _temp13 = thisTimeValue(thisValue);

  if (_temp13 instanceof AbruptCompletion) {
    return _temp13;
  }

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }

  const t = _temp13;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return HourFromTime(t);
} // 20.3.4.16 #sec-date.prototype.getutcmilliseconds


function DateProto_getUTCMilliseconds(args, {
  thisValue
}) {
  let _temp14 = thisTimeValue(thisValue);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const t = _temp14;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return msFromTime(t);
} // 20.3.4.17 #sec-date.prototype.getutcminutes


function DateProto_getUTCMinutes(args, {
  thisValue
}) {
  let _temp15 = thisTimeValue(thisValue);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const t = _temp15;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return MinFromTime(t);
} // 20.3.4.18 #sec-date.prototype.getutcmonth


function DateProto_getUTCMonth(args, {
  thisValue
}) {
  let _temp16 = thisTimeValue(thisValue);

  if (_temp16 instanceof AbruptCompletion) {
    return _temp16;
  }

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }

  const t = _temp16;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return MonthFromTime(t);
} // 20.3.4.19 #sec-date.prototype.getutcseconds


function DateProto_getUTCSeconds(args, {
  thisValue
}) {
  let _temp17 = thisTimeValue(thisValue);

  if (_temp17 instanceof AbruptCompletion) {
    return _temp17;
  }

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  const t = _temp17;

  if (t.isNaN()) {
    return new Value(NaN);
  }

  return SecFromTime(t);
} // 20.3.4.20 #sec-date.prototype.setdate


function DateProto_setDate([date = Value.undefined], {
  thisValue
}) {
  let _temp18 = thisTimeValue(thisValue);

  if (_temp18 instanceof AbruptCompletion) {
    return _temp18;
  }

  if (_temp18 instanceof Completion) {
    _temp18 = _temp18.Value;
  }

  const t = LocalTime(_temp18);

  let _temp19 = ToNumber(date);

  if (_temp19 instanceof AbruptCompletion) {
    return _temp19;
  }

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  const dt = _temp19;
  const newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t));
  const u = TimeClip(UTC(newDate));
  thisValue.DateValue = u;
  return u;
} // 20.3.4.21 #sec-date.prototype.setfullyear


function DateProto_setFullYear([year = Value.undefined, month, date], {
  thisValue
}) {
  let _temp20 = thisTimeValue(thisValue);

  if (_temp20 instanceof AbruptCompletion) {
    return _temp20;
  }

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }

  let t = _temp20;
  t = t.isNaN() ? new Value(0) : LocalTime(t);

  let _temp21 = ToNumber(year);

  if (_temp21 instanceof AbruptCompletion) {
    return _temp21;
  }

  if (_temp21 instanceof Completion) {
    _temp21 = _temp21.Value;
  }

  const y = _temp21;
  let m;

  if (month !== undefined) {
    let _temp22 = ToNumber(month);

    if (_temp22 instanceof AbruptCompletion) {
      return _temp22;
    }

    if (_temp22 instanceof Completion) {
      _temp22 = _temp22.Value;
    }

    m = _temp22;
  } else {
    m = MonthFromTime(t);
  }

  let dt;

  if (date !== undefined) {
    let _temp23 = ToNumber(date);

    if (_temp23 instanceof AbruptCompletion) {
      return _temp23;
    }

    if (_temp23 instanceof Completion) {
      _temp23 = _temp23.Value;
    }

    dt = _temp23;
  } else {
    dt = DateFromTime(t);
  }

  const newDate = MakeDate(MakeDay(y, m, dt), TimeWithinDay(t));
  const u = TimeClip(UTC(newDate));
  thisValue.DateValue = u;
  return u;
} // 20.3.4.22 #sec-date.prototype.sethours


function DateProto_setHours([hour = Value.undefined, min, sec, ms], {
  thisValue
}) {
  let _temp24 = thisTimeValue(thisValue);

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  const t = LocalTime(_temp24);

  let _temp25 = ToNumber(hour);

  if (_temp25 instanceof AbruptCompletion) {
    return _temp25;
  }

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }

  const h = _temp25;
  let m;

  if (min !== undefined) {
    let _temp26 = ToNumber(min);

    if (_temp26 instanceof AbruptCompletion) {
      return _temp26;
    }

    if (_temp26 instanceof Completion) {
      _temp26 = _temp26.Value;
    }

    m = _temp26;
  } else {
    m = MinFromTime(t);
  }

  let s;

  if (sec !== undefined) {
    let _temp27 = ToNumber(sec);

    if (_temp27 instanceof AbruptCompletion) {
      return _temp27;
    }

    if (_temp27 instanceof Completion) {
      _temp27 = _temp27.Value;
    }

    s = _temp27;
  } else {
    s = SecFromTime(t);
  }

  let milli;

  if (ms !== undefined) {
    let _temp28 = ToNumber(ms);

    if (_temp28 instanceof AbruptCompletion) {
      return _temp28;
    }

    if (_temp28 instanceof Completion) {
      _temp28 = _temp28.Value;
    }

    milli = _temp28;
  } else {
    milli = msFromTime(t);
  }

  const date = MakeDate(Day(t), MakeTime(h, m, s, milli));
  const u = TimeClip(UTC(date));
  thisValue.DateValue = u;
  return u;
} // 20.3.4.23 #sec-date.prototype.setmilliseconds


function DateProto_setMilliseconds([ms = Value.undefined], {
  thisValue
}) {
  let _temp29 = thisTimeValue(thisValue);

  if (_temp29 instanceof AbruptCompletion) {
    return _temp29;
  }

  if (_temp29 instanceof Completion) {
    _temp29 = _temp29.Value;
  }

  const t = LocalTime(_temp29);

  let _temp30 = ToNumber(ms);

  if (_temp30 instanceof AbruptCompletion) {
    return _temp30;
  }

  if (_temp30 instanceof Completion) {
    _temp30 = _temp30.Value;
  }

  ms = _temp30;
  const time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms);
  const u = TimeClip(UTC(MakeDate(Day(t), time)));
  thisValue.DateValue = u;
  return u;
} // 20.3.4.24 #sec-date.prototype.setminutes


function DateProto_setMinutes([min = Value.undefined, sec, ms], {
  thisValue
}) {
  let _temp31 = thisTimeValue(thisValue);

  if (_temp31 instanceof AbruptCompletion) {
    return _temp31;
  }

  if (_temp31 instanceof Completion) {
    _temp31 = _temp31.Value;
  }

  const t = LocalTime(_temp31);

  let _temp32 = ToNumber(min);

  if (_temp32 instanceof AbruptCompletion) {
    return _temp32;
  }

  if (_temp32 instanceof Completion) {
    _temp32 = _temp32.Value;
  }

  const m = _temp32;
  let s;

  if (sec !== undefined) {
    let _temp33 = ToNumber(sec);

    if (_temp33 instanceof AbruptCompletion) {
      return _temp33;
    }

    if (_temp33 instanceof Completion) {
      _temp33 = _temp33.Value;
    }

    s = _temp33;
  } else {
    s = SecFromTime(t);
  }

  let milli;

  if (ms !== undefined) {
    let _temp34 = ToNumber(ms);

    if (_temp34 instanceof AbruptCompletion) {
      return _temp34;
    }

    if (_temp34 instanceof Completion) {
      _temp34 = _temp34.Value;
    }

    milli = _temp34;
  } else {
    milli = msFromTime(t);
  }

  const date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli));
  const u = TimeClip(UTC(date));
  thisValue.DateValue = u;
  return u;
} // 20.3.4.25 #sec-date.prototype.setmonth


function DateProto_setMonth([month = Value.undefined, date], {
  thisValue
}) {
  let _temp35 = thisTimeValue(thisValue);

  if (_temp35 instanceof AbruptCompletion) {
    return _temp35;
  }

  if (_temp35 instanceof Completion) {
    _temp35 = _temp35.Value;
  }

  const t = LocalTime(_temp35);

  let _temp36 = ToNumber(month);

  if (_temp36 instanceof AbruptCompletion) {
    return _temp36;
  }

  if (_temp36 instanceof Completion) {
    _temp36 = _temp36.Value;
  }

  const m = _temp36;
  let dt;

  if (date !== undefined) {
    let _temp37 = ToNumber(date);

    if (_temp37 instanceof AbruptCompletion) {
      return _temp37;
    }

    if (_temp37 instanceof Completion) {
      _temp37 = _temp37.Value;
    }

    dt = _temp37;
  } else {
    dt = DateFromTime(t);
  }

  const newDate = MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t));
  const u = TimeClip(UTC(newDate));
  thisValue.DateValue = u;
  return u;
} // 20.3.4.26 #sec-date.prototype.setseconds


function DateProto_setSeconds([sec = Value.undefined, ms], {
  thisValue
}) {
  let _temp38 = thisTimeValue(thisValue);

  if (_temp38 instanceof AbruptCompletion) {
    return _temp38;
  }

  if (_temp38 instanceof Completion) {
    _temp38 = _temp38.Value;
  }

  const t = LocalTime(_temp38);

  let _temp39 = ToNumber(sec);

  if (_temp39 instanceof AbruptCompletion) {
    return _temp39;
  }

  if (_temp39 instanceof Completion) {
    _temp39 = _temp39.Value;
  }

  const s = _temp39;
  let milli;

  if (ms !== undefined) {
    let _temp40 = ToNumber(ms);

    if (_temp40 instanceof AbruptCompletion) {
      return _temp40;
    }

    if (_temp40 instanceof Completion) {
      _temp40 = _temp40.Value;
    }

    milli = _temp40;
  } else {
    milli = msFromTime(t);
  }

  const date = MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli));
  const u = TimeClip(UTC(date));
  thisValue.DateValue = u;
  return u;
} // 20.3.4.27 #sec-date.prototype.settime


function DateProto_setTime([time = Value.undefined], {
  thisValue
}) {
  let _temp41 = thisTimeValue(thisValue);

  if (_temp41 instanceof AbruptCompletion) {
    return _temp41;
  }

  if (_temp41 instanceof Completion) {
    _temp41 = _temp41.Value;
  }

  let _temp42 = ToNumber(time);

  if (_temp42 instanceof AbruptCompletion) {
    return _temp42;
  }

  if (_temp42 instanceof Completion) {
    _temp42 = _temp42.Value;
  }

  const t = _temp42;
  const v = TimeClip(t);
  thisValue.DateValue = v;
  return v;
} // 20.3.4.28 #sec-date.prototype.setutcdate


function DateProto_setUTCDate([date = Value.undefined], {
  thisValue
}) {
  let _temp43 = thisTimeValue(thisValue);

  if (_temp43 instanceof AbruptCompletion) {
    return _temp43;
  }

  if (_temp43 instanceof Completion) {
    _temp43 = _temp43.Value;
  }

  const t = _temp43;

  let _temp44 = ToNumber(date);

  if (_temp44 instanceof AbruptCompletion) {
    return _temp44;
  }

  if (_temp44 instanceof Completion) {
    _temp44 = _temp44.Value;
  }

  const dt = _temp44;
  const newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t));
  const v = TimeClip(newDate);
  thisValue.DateValue = v;
  return v;
} // 20.3.4.29 #sec-date.prototype.setutcfullyear


function DateProto_setUTCFullYear([year = Value.undefined, month, date], {
  thisValue
}) {
  let _temp45 = thisTimeValue(thisValue);

  if (_temp45 instanceof AbruptCompletion) {
    return _temp45;
  }

  if (_temp45 instanceof Completion) {
    _temp45 = _temp45.Value;
  }

  let t = _temp45;

  if (t.isNaN()) {
    t = new Value(0);
  }

  let _temp46 = ToNumber(year);

  if (_temp46 instanceof AbruptCompletion) {
    return _temp46;
  }

  if (_temp46 instanceof Completion) {
    _temp46 = _temp46.Value;
  }

  const y = _temp46;
  let m;

  if (month !== undefined) {
    let _temp47 = ToNumber(month);

    if (_temp47 instanceof AbruptCompletion) {
      return _temp47;
    }

    if (_temp47 instanceof Completion) {
      _temp47 = _temp47.Value;
    }

    m = _temp47;
  } else {
    m = MonthFromTime(t);
  }

  let dt;

  if (date !== undefined) {
    let _temp48 = ToNumber(date);

    if (_temp48 instanceof AbruptCompletion) {
      return _temp48;
    }

    if (_temp48 instanceof Completion) {
      _temp48 = _temp48.Value;
    }

    dt = _temp48;
  } else {
    dt = DateFromTime(t);
  }

  const newDate = MakeDate(MakeDay(y, m, dt), TimeWithinDay(t));
  const v = TimeClip(newDate);
  thisValue.DateValue = v;
  return v;
} // 20.3.4.30 #sec-date.prototype.setutchours


function DateProto_setUTCHours([hour = Value.undefined, min, sec, ms], {
  thisValue
}) {
  let _temp49 = thisTimeValue(thisValue);

  if (_temp49 instanceof AbruptCompletion) {
    return _temp49;
  }

  if (_temp49 instanceof Completion) {
    _temp49 = _temp49.Value;
  }

  const t = _temp49;

  let _temp50 = ToNumber(hour);

  if (_temp50 instanceof AbruptCompletion) {
    return _temp50;
  }

  if (_temp50 instanceof Completion) {
    _temp50 = _temp50.Value;
  }

  const h = _temp50;
  let m;

  if (min !== undefined) {
    let _temp51 = ToNumber(min);

    if (_temp51 instanceof AbruptCompletion) {
      return _temp51;
    }

    if (_temp51 instanceof Completion) {
      _temp51 = _temp51.Value;
    }

    m = _temp51;
  } else {
    m = MinFromTime(t);
  }

  let s;

  if (sec !== undefined) {
    let _temp52 = ToNumber(sec);

    if (_temp52 instanceof AbruptCompletion) {
      return _temp52;
    }

    if (_temp52 instanceof Completion) {
      _temp52 = _temp52.Value;
    }

    s = _temp52;
  } else {
    s = SecFromTime(t);
  }

  let milli;

  if (ms !== undefined) {
    let _temp53 = ToNumber(ms);

    if (_temp53 instanceof AbruptCompletion) {
      return _temp53;
    }

    if (_temp53 instanceof Completion) {
      _temp53 = _temp53.Value;
    }

    milli = _temp53;
  } else {
    milli = msFromTime(t);
  }

  const newDate = MakeDate(Day(t), MakeTime(h, m, s, milli));
  const v = TimeClip(newDate);
  thisValue.DateValue = v;
  return v;
} // 20.3.4.31 #sec-date.prototype.setutcmilliseconds


function DateProto_setUTCMilliseconds([ms = Value.undefined], {
  thisValue
}) {
  let _temp54 = thisTimeValue(thisValue);

  if (_temp54 instanceof AbruptCompletion) {
    return _temp54;
  }

  if (_temp54 instanceof Completion) {
    _temp54 = _temp54.Value;
  }

  const t = _temp54;

  let _temp55 = ToNumber(ms);

  if (_temp55 instanceof AbruptCompletion) {
    return _temp55;
  }

  if (_temp55 instanceof Completion) {
    _temp55 = _temp55.Value;
  }

  const milli = _temp55;
  const time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli);
  const v = TimeClip(MakeDate(Day(t), time));
  thisValue.DateValue = v;
  return v;
} // 20.3.4.32 #sec-date.prototype.setutcminutes


function DateProto_setUTCMinutes([min = Value.undefined, sec, ms], {
  thisValue
}) {
  let _temp56 = thisTimeValue(thisValue);

  if (_temp56 instanceof AbruptCompletion) {
    return _temp56;
  }

  if (_temp56 instanceof Completion) {
    _temp56 = _temp56.Value;
  }

  const t = _temp56;

  let _temp57 = ToNumber(min);

  if (_temp57 instanceof AbruptCompletion) {
    return _temp57;
  }

  if (_temp57 instanceof Completion) {
    _temp57 = _temp57.Value;
  }

  const m = _temp57;
  let s;

  if (sec !== undefined) {
    let _temp58 = ToNumber(sec);

    if (_temp58 instanceof AbruptCompletion) {
      return _temp58;
    }

    if (_temp58 instanceof Completion) {
      _temp58 = _temp58.Value;
    }

    s = _temp58;
  } else {
    s = SecFromTime(t);
  }

  let milli;

  if (ms !== undefined) {
    let _temp59 = ToNumber(ms);

    if (_temp59 instanceof AbruptCompletion) {
      return _temp59;
    }

    if (_temp59 instanceof Completion) {
      _temp59 = _temp59.Value;
    }

    milli = _temp59;
  } else {
    milli = msFromTime(t);
  }

  const date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli));
  const v = TimeClip(date);
  thisValue.DateValue = v;
  return v;
} // 20.3.4.33 #sec-date.prototype.setutcmonth


function DateProto_setUTCMonth([month = Value.undefined, date], {
  thisValue
}) {
  let _temp60 = thisTimeValue(thisValue);

  if (_temp60 instanceof AbruptCompletion) {
    return _temp60;
  }

  if (_temp60 instanceof Completion) {
    _temp60 = _temp60.Value;
  }

  const t = _temp60;

  let _temp61 = ToNumber(month);

  if (_temp61 instanceof AbruptCompletion) {
    return _temp61;
  }

  if (_temp61 instanceof Completion) {
    _temp61 = _temp61.Value;
  }

  const m = _temp61;
  let dt;

  if (date !== undefined) {
    let _temp62 = ToNumber(date);

    if (_temp62 instanceof AbruptCompletion) {
      return _temp62;
    }

    if (_temp62 instanceof Completion) {
      _temp62 = _temp62.Value;
    }

    dt = _temp62;
  } else {
    dt = DateFromTime(t);
  }

  const newDate = MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t));
  const v = TimeClip(newDate);
  thisValue.DateValue = v;
  return v;
} // 20.3.4.34 #sec-date.prototype.setutcseconds


function DateProto_setUTCSeconds([sec = Value.undefined, ms], {
  thisValue
}) {
  let _temp63 = thisTimeValue(thisValue);

  if (_temp63 instanceof AbruptCompletion) {
    return _temp63;
  }

  if (_temp63 instanceof Completion) {
    _temp63 = _temp63.Value;
  }

  const t = _temp63;

  let _temp64 = ToNumber(sec);

  if (_temp64 instanceof AbruptCompletion) {
    return _temp64;
  }

  if (_temp64 instanceof Completion) {
    _temp64 = _temp64.Value;
  }

  const s = _temp64;
  let milli;

  if (ms !== undefined) {
    let _temp65 = ToNumber(ms);

    if (_temp65 instanceof AbruptCompletion) {
      return _temp65;
    }

    if (_temp65 instanceof Completion) {
      _temp65 = _temp65.Value;
    }

    milli = _temp65;
  } else {
    milli = msFromTime(t);
  }

  const date = MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli));
  const v = TimeClip(date);
  thisValue.DateValue = v;
  return v;
} // 20.3.4.35 #sec-date.prototype.todatestring


function DateProto_toDateString(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', O);
  }

  let _temp66 = thisTimeValue(O);

  if (_temp66 instanceof AbruptCompletion) {
    return _temp66;
  }

  if (_temp66 instanceof Completion) {
    _temp66 = _temp66.Value;
  }

  const tv = _temp66;

  if (tv.isNaN()) {
    return new Value('Invalid Date');
  }

  const t = LocalTime(tv);
  return DateString(t);
} // 20.3.4.36 #sec-date.prototype.toisostring


function DateProto_toISOString(args, {
  thisValue
}) {
  let _temp67 = thisTimeValue(thisValue);

  if (_temp67 instanceof AbruptCompletion) {
    return _temp67;
  }

  if (_temp67 instanceof Completion) {
    _temp67 = _temp67.Value;
  }

  const t = _temp67;

  if (!Number.isFinite(t.numberValue())) {
    return surroundingAgent.Throw('RangeError', 'DateInvalidTime');
  }

  const year = YearFromTime(t).numberValue();
  const month = MonthFromTime(t).numberValue() + 1;
  const date = DateFromTime(t).numberValue();
  const hour = HourFromTime(t).numberValue();
  const min = MinFromTime(t).numberValue();
  const sec = SecFromTime(t).numberValue();
  const ms = msFromTime(t).numberValue(); // TODO: figure out if there can be invalid years.

  let YYYY = String(year);

  if (year < 0 || year > 9999) {
    YYYY = year < 0 ? `-${String(year).padStart(6, '0')}` : `+${String(year).padStart(6, '0')}`;
  }

  const MM = String(month).padStart(2, '0');
  const DD = String(date).padStart(2, '0');
  const HH = String(hour).padStart(2, '0');
  const mm = String(min).padStart(2, '0');
  const ss = String(sec).padStart(2, '0');
  const sss = String(ms).padStart(3, '0');
  const format = `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}.${sss}Z`;
  return new Value(format);
} // 20.3.4.37 #sec-date.prototype.tojson


function DateProto_toJSON(args, {
  thisValue
}) {
  let _temp68 = ToObject(thisValue);

  if (_temp68 instanceof AbruptCompletion) {
    return _temp68;
  }

  if (_temp68 instanceof Completion) {
    _temp68 = _temp68.Value;
  }

  const O = _temp68;

  let _temp69 = ToPrimitive(O, 'Number');

  if (_temp69 instanceof AbruptCompletion) {
    return _temp69;
  }

  if (_temp69 instanceof Completion) {
    _temp69 = _temp69.Value;
  }

  const tv = _temp69;

  if (Type(tv) === 'Number' && !Number.isFinite(tv.numberValue())) {
    return Value.null;
  }

  return Invoke(O, new Value('toISOString'));
} // 20.3.4.38 #sec-date.prototype.tolocaledatestring


function DateProto_toLocaleDateString() {
  // TODO: implement this function.
  return surroundingAgent.Throw('Error', 'Raw', 'Date.prototype.toLocaleDateString is not implemented');
} // 20.3.4.39 #sec-date.prototype.tolocalestring


function DateProto_toLocaleString() {
  // TODO: implement this function.
  return surroundingAgent.Throw('Error', 'Raw', 'Date.prototype.toLocaleString is not implemented');
} // 20.3.4.40 #sec-date.prototype.tolocaletimestring


function DateProto_toLocaleTimeString() {
  // TODO: implement this function.
  return surroundingAgent.Throw('Error', 'Raw', 'Date.prototype.toLocaleTimeString is not implemented');
} // 20.3.4.41 #sec-date.prototype.tostring


function DateProto_toString(args, {
  thisValue
}) {
  let _temp70 = thisTimeValue(thisValue);

  if (_temp70 instanceof AbruptCompletion) {
    return _temp70;
  }

  if (_temp70 instanceof Completion) {
    _temp70 = _temp70.Value;
  }

  const tv = _temp70;
  return ToDateString(tv);
} // 20.3.4.41.1 #sec-timestring


function TimeString(tv) {
  Assert(Type(tv) === 'Number', "Type(tv) === 'Number'");
  Assert(!tv.isNaN(), "!tv.isNaN()");
  const hour = String(HourFromTime(tv).numberValue()).padStart(2, '0');
  const minute = String(MinFromTime(tv).numberValue()).padStart(2, '0');
  const second = String(SecFromTime(tv).numberValue()).padStart(2, '0');
  return new Value(`${hour}:${minute}:${second} GMT`);
} // 20.3.4.41.2 #sec-datestring


function DateString(tv) {
  Assert(Type(tv) === 'Number', "Type(tv) === 'Number'");
  Assert(!tv.isNaN(), "!tv.isNaN()");
  const weekday = daysOfTheWeek[WeekDay(tv).numberValue()];
  const month = monthsOfTheYear[MonthFromTime(tv).numberValue()];
  const day = String(DateFromTime(tv).numberValue()).padStart(2, '0');
  const yv = YearFromTime(tv).numberValue();
  const yearSign = yv >= 0 ? '' : '-';
  const year = new Value(String(Math.abs(yv)));

  let _temp71 = StringPad(year, new Value(4), new Value('0'), 'start');

  Assert(!(_temp71 instanceof AbruptCompletion), "StringPad(year, new Value(4), new Value('0'), 'start')" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp71 instanceof Completion) {
    _temp71 = _temp71.Value;
  }

  const paddedYear = _temp71.stringValue();

  return new Value(`${weekday} ${month} ${day} ${yearSign}${paddedYear}`);
} // Table 46 #sec-todatestring-day-names


const daysOfTheWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']; // Table 47 #sec-todatestring-month-names

const monthsOfTheYear = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 20.3.4.41.3 #sec-timezoneestring

function TimeZoneString(tv) {
  Assert(Type(tv) === 'Number', "Type(tv) === 'Number'");
  Assert(!tv.isNaN(), "!tv.isNaN()");
  const offset = LocalTZA();
  const offsetSign =  '+' ;
  const offsetMin = String(MinFromTime(new Value(Math.abs(offset))).numberValue()).padStart(2, '0');
  const offsetHour = String(HourFromTime(new Value(Math.abs(offset))).numberValue()).padStart(2, '0');
  const tzName = '';
  return new Value(`${offsetSign}${offsetHour}${offsetMin}${tzName}`);
} // 20.3.4.41.4 #sec-todatestring

function ToDateString(tv) {
  Assert(Type(tv) === 'Number', "Type(tv) === 'Number'");

  if (tv.isNaN()) {
    return new Value('Invalid Date');
  }

  const t = LocalTime(tv);
  return new Value(`${DateString(t).stringValue()} ${TimeString(t).stringValue()}${TimeZoneString(t).stringValue()}`);
} // 20.3.4.42 #sec-date.prototype.totimestring

function DateProto_toTimeString(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', O);
  }

  let _temp72 = thisTimeValue(O);

  if (_temp72 instanceof AbruptCompletion) {
    return _temp72;
  }

  if (_temp72 instanceof Completion) {
    _temp72 = _temp72.Value;
  }

  const tv = _temp72;

  if (tv.isNaN()) {
    return new Value('Invalid Date');
  }

  const t = LocalTime(tv);
  return new Value(`${TimeString(t).stringValue()}${TimeZoneString(tv).stringValue()}`);
} // 20.3.4.43 #sec-date.prototype.toutcstring


function DateProto_toUTCString(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', O);
  }

  let _temp73 = thisTimeValue(O);

  if (_temp73 instanceof AbruptCompletion) {
    return _temp73;
  }

  if (_temp73 instanceof Completion) {
    _temp73 = _temp73.Value;
  }

  const tv = _temp73;

  if (tv.isNaN()) {
    return new Value('Invalid Date');
  }

  const weekday = daysOfTheWeek[WeekDay(tv).numberValue()];
  const month = monthsOfTheYear[MonthFromTime(tv).numberValue()];
  const day = String(DateFromTime(tv).numberValue()).padStart(2, '0');
  const yv = YearFromTime(tv).numberValue();
  const yearSign = yv >= 0 ? '' : '-';
  const year = new Value(String(Math.abs(yv)));

  let _temp74 = StringPad(year, new Value(4), new Value('0'), 'start');

  Assert(!(_temp74 instanceof AbruptCompletion), "StringPad(year, new Value(4), new Value('0'), 'start')" + ' returned an abrupt completion');

  if (_temp74 instanceof Completion) {
    _temp74 = _temp74.Value;
  }

  const paddedYear = _temp74.stringValue();

  return new Value(`${weekday}, ${day} ${month} ${yearSign}${paddedYear} ${TimeString(tv).stringValue()}`);
} // 20.3.4.44 #sec-date.prototype.valueof


function DateProto_valueOf(args, {
  thisValue
}) {
  return thisTimeValue(thisValue);
} // 20.3.4.45 #sec-date.prototype-@@toprimitive


function DateProto_toPrimitive([hint = Value.undefined], {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', O);
  }

  let tryFirst;

  if (Type(hint) === 'String' && (hint.stringValue() === 'string' || hint.stringValue() === 'default')) {
    tryFirst = new Value('string');
  } else if (Type(hint) === 'String' && hint.stringValue() === 'number') {
    tryFirst = new Value('number');
  } else {
    return surroundingAgent.Throw('TypeError', 'InvalidHint', hint);
  }

  return OrdinaryToPrimitive(O, tryFirst);
}

function CreateDatePrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['getDate', DateProto_getDate, 0], ['getDay', DateProto_getDay, 0], ['getFullYear', DateProto_getFullYear, 0], ['getHours', DateProto_getHours, 0], ['getMilliseconds', DateProto_getMilliseconds, 0], ['getMinutes', DateProto_getMinutes, 0], ['getMonth', DateProto_getMonth, 0], ['getSeconds', DateProto_getSeconds, 0], ['getTime', DateProto_getTime, 0], ['getTimezoneOffset', DateProto_getTimezoneOffset, 0], ['getUTCDate', DateProto_getUTCDate, 0], ['getUTCDay', DateProto_getUTCDay, 0], ['getUTCFullYear', DateProto_getUTCFullYear, 0], ['getUTCHours', DateProto_getUTCHours, 0], ['getUTCMilliseconds', DateProto_getUTCMilliseconds, 0], ['getUTCMinutes', DateProto_getUTCMinutes, 0], ['getUTCMonth', DateProto_getUTCMonth, 0], ['getUTCSeconds', DateProto_getUTCSeconds, 0], ['setDate', DateProto_setDate, 1], ['setFullYear', DateProto_setFullYear, 3], ['setHours', DateProto_setHours, 4], ['setMilliseconds', DateProto_setMilliseconds, 1], ['setMinutes', DateProto_setMinutes, 3], ['setMonth', DateProto_setMonth, 2], ['setSeconds', DateProto_setSeconds, 2], ['setTime', DateProto_setTime, 1], ['setUTCDate', DateProto_setUTCDate, 1], ['setUTCFullYear', DateProto_setUTCFullYear, 3], ['setUTCHours', DateProto_setUTCHours, 4], ['setUTCMilliseconds', DateProto_setUTCMilliseconds, 1], ['setUTCMinutes', DateProto_setUTCMinutes, 3], ['setUTCMonth', DateProto_setUTCMonth, 2], ['setUTCSeconds', DateProto_setUTCSeconds, 2], ['toDateString', DateProto_toDateString, 0], ['toISOString', DateProto_toISOString, 0], ['toJSON', DateProto_toJSON, 1], ['toLocaleDateString', DateProto_toLocaleDateString, 0], ['toLocaleString', DateProto_toLocaleString, 0], ['toLocaleTimeString', DateProto_toLocaleTimeString, 0], ['toString', DateProto_toString, 0], ['toTimeString', DateProto_toTimeString, 0], ['toUTCString', DateProto_toUTCString, 0], ['valueOf', DateProto_valueOf, 0], [wellKnownSymbols.toPrimitive, DateProto_toPrimitive, 1, {
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Date.prototype%'] = proto;
}

function DateConstructor(args, {
  NewTarget
}) {
  const numberOfArgs = args.length;

  if (numberOfArgs >= 2) {
    // 20.3.2.1 #sec-date-year-month-date-hours-minutes-seconds-ms
    const [year, month, date, hours, minutes, seconds, ms] = args;
    Assert(numberOfArgs >= 2, "numberOfArgs >= 2");

    if (NewTarget === Value.undefined) {
      const now = Date.now();
      return ToDateString(new Value(now));
    } else {
      let _temp = ToNumber(year);
      /* istanbul ignore if */


      if (_temp instanceof AbruptCompletion) {
        return _temp;
      }
      /* istanbul ignore if */


      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      const y = _temp;

      let _temp2 = ToNumber(month);

      if (_temp2 instanceof AbruptCompletion) {
        return _temp2;
      }

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      const m = _temp2;
      let dt;

      if (date !== undefined) {
        let _temp3 = ToNumber(date);

        if (_temp3 instanceof AbruptCompletion) {
          return _temp3;
        }

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }

        dt = _temp3;
      } else {
        dt = new Value(1);
      }

      let h;

      if (hours !== undefined) {
        let _temp4 = ToNumber(hours);

        if (_temp4 instanceof AbruptCompletion) {
          return _temp4;
        }

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }

        h = _temp4;
      } else {
        h = new Value(0);
      }

      let min;

      if (minutes !== undefined) {
        let _temp5 = ToNumber(minutes);

        if (_temp5 instanceof AbruptCompletion) {
          return _temp5;
        }

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }

        min = _temp5;
      } else {
        min = new Value(0);
      }

      let s;

      if (seconds !== undefined) {
        let _temp6 = ToNumber(seconds);

        if (_temp6 instanceof AbruptCompletion) {
          return _temp6;
        }

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        s = _temp6;
      } else {
        s = new Value(0);
      }

      let milli;

      if (ms !== undefined) {
        let _temp7 = ToNumber(ms);

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        milli = _temp7;
      } else {
        milli = new Value(0);
      }

      let yr;

      if (y.isNaN()) {
        yr = new Value(NaN);
      } else {
        let _temp8 = ToInteger(y);

        Assert(!(_temp8 instanceof AbruptCompletion), "ToInteger(y)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }

        const yi = _temp8.numberValue();

        if (yi >= 0 && yi <= 99) {
          yr = new Value(1900 + yi);
        } else {
          yr = y;
        }
      }

      const finalDate = MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli));

      let _temp9 = OrdinaryCreateFromConstructor(NewTarget, '%Date.prototype%', ['DateValue']);

      if (_temp9 instanceof AbruptCompletion) {
        return _temp9;
      }

      if (_temp9 instanceof Completion) {
        _temp9 = _temp9.Value;
      }

      const O = _temp9;
      O.DateValue = TimeClip(UTC(finalDate));
      return O;
    }
  } else if (numberOfArgs === 1) {
    const [value] = args; // 20.3.2.2 #sec-date-value

    Assert(numberOfArgs === 1, "numberOfArgs === 1");

    if (NewTarget === Value.undefined) {
      const now = Date.now();
      return ToDateString(new Value(now));
    } else {
      let tv;

      if (Type(value) === 'Object' && 'DateValue' in value) {
        tv = thisTimeValue(value);
      } else {
        let _temp10 = ToPrimitive(value);

        if (_temp10 instanceof AbruptCompletion) {
          return _temp10;
        }

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }

        const v = _temp10;

        if (Type(v) === 'String') {
          // Assert: The next step never returns an abrupt completion because Type(v) is String.
          tv = parseDate(v);
        } else {
          let _temp11 = ToNumber(v);

          if (_temp11 instanceof AbruptCompletion) {
            return _temp11;
          }

          if (_temp11 instanceof Completion) {
            _temp11 = _temp11.Value;
          }

          tv = _temp11;
        }
      }

      let _temp12 = OrdinaryCreateFromConstructor(NewTarget, '%Date.prototype%', ['DateValue']);

      if (_temp12 instanceof AbruptCompletion) {
        return _temp12;
      }

      if (_temp12 instanceof Completion) {
        _temp12 = _temp12.Value;
      }

      const O = _temp12;
      O.DateValue = TimeClip(tv);
      return O;
    }
  } else {
    // 20.3.2.3 #sec-date-constructor-date
    Assert(numberOfArgs === 0, "numberOfArgs === 0");

    if (NewTarget === Value.undefined) {
      const now = Date.now();
      return ToDateString(new Value(now));
    } else {
      let _temp13 = OrdinaryCreateFromConstructor(NewTarget, '%Date.prototype%', ['DateValue']);

      if (_temp13 instanceof AbruptCompletion) {
        return _temp13;
      }

      if (_temp13 instanceof Completion) {
        _temp13 = _temp13.Value;
      }

      const O = _temp13;
      O.DateValue = new Value(Date.now());
      return O;
    }
  }
} // 20.3.3.1 #sec-date.now


function Date_now() {
  const now = Date.now();
  return new Value(now);
} // 20.3.3.2 #sec-date.parse


function Date_parse([string = Value.undefined]) {
  const str = ToString(string);

  if (str instanceof AbruptCompletion) {
    return str;
  }

  return parseDate(str);
} // 20.3.3.4 #sec-date.utc


function Date_UTC([year = Value.undefined, month, date, hours, minutes, seconds, ms]) {
  let _temp14 = ToNumber(year);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const y = _temp14;
  let m;

  if (month !== undefined) {
    let _temp15 = ToNumber(month);

    if (_temp15 instanceof AbruptCompletion) {
      return _temp15;
    }

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    m = _temp15;
  } else {
    m = new Value(0);
  }

  let dt;

  if (date !== undefined) {
    let _temp16 = ToNumber(date);

    if (_temp16 instanceof AbruptCompletion) {
      return _temp16;
    }

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }

    dt = _temp16;
  } else {
    dt = new Value(1);
  }

  let h;

  if (hours !== undefined) {
    let _temp17 = ToNumber(hours);

    if (_temp17 instanceof AbruptCompletion) {
      return _temp17;
    }

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    h = _temp17;
  } else {
    h = new Value(0);
  }

  let min;

  if (minutes !== undefined) {
    let _temp18 = ToNumber(minutes);

    if (_temp18 instanceof AbruptCompletion) {
      return _temp18;
    }

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }

    min = _temp18;
  } else {
    min = new Value(0);
  }

  let s;

  if (seconds !== undefined) {
    let _temp19 = ToNumber(seconds);

    if (_temp19 instanceof AbruptCompletion) {
      return _temp19;
    }

    if (_temp19 instanceof Completion) {
      _temp19 = _temp19.Value;
    }

    s = _temp19;
  } else {
    s = new Value(0);
  }

  let milli;

  if (ms !== undefined) {
    let _temp20 = ToNumber(ms);

    if (_temp20 instanceof AbruptCompletion) {
      return _temp20;
    }

    if (_temp20 instanceof Completion) {
      _temp20 = _temp20.Value;
    }

    milli = _temp20;
  } else {
    milli = new Value(0);
  }

  let yr;

  if (y.isNaN()) {
    yr = new Value(NaN);
  } else {
    let _temp21 = ToInteger(y);

    Assert(!(_temp21 instanceof AbruptCompletion), "ToInteger(y)" + ' returned an abrupt completion');

    if (_temp21 instanceof Completion) {
      _temp21 = _temp21.Value;
    }

    const yi = _temp21.numberValue();

    if (yi >= 0 && yi <= 99) {
      yr = new Value(1900 + yi);
    } else {
      yr = y;
    }
  }

  return TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)));
}

function parseDate(dateTimeString) {
  // 20.3.1.15 #sec-date-time-string-format
  // TODO: implement parsing without the host.
  const parsed = Date.parse(dateTimeString.stringValue());
  return new Value(parsed);
}

function CreateDate(realmRec) {
  const cons = BootstrapConstructor(realmRec, DateConstructor, 'Date', 7, realmRec.Intrinsics['%Date.prototype%'], [['now', Date_now, 0], ['parse', Date_parse, 1], ['UTC', Date_UTC, 7]]);
  realmRec.Intrinsics['%Date%'] = cons;
}

function CreateRegExpStringIterator(R, S, global, fullUnicode) {
  Assert(Type(S) === 'String', "Type(S) === 'String'");
  Assert(Type(global) === 'Boolean', "Type(global) === 'Boolean'");
  Assert(Type(fullUnicode) === 'Boolean', "Type(fullUnicode) === 'Boolean'");
  const iterator = ObjectCreate(surroundingAgent.intrinsic('%RegExpStringIteratorPrototype%'), ['IteratingRegExp', 'IteratedString', 'Global', 'Unicode', 'Done']);
  iterator.IteratingRegExp = R;
  iterator.IteratedString = S;
  iterator.Global = global;
  iterator.Unicode = fullUnicode;
  iterator.Done = Value.false;
  return iterator;
} // 21.2.7.1.1 #sec-%regexpstringiteratorprototype%.next

function RegExpStringIteratorPrototype_next(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp String Iterator', O);
  }

  if (!('IteratingRegExp' in O && 'IteratedString' in O && 'Global' in O && 'Unicode' in O && 'Done' in O)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp String Iterator', O);
  }

  if (O.Done === Value.true) {
    let _temp = CreateIterResultObject(Value.undefined, Value.true);

    Assert(!(_temp instanceof AbruptCompletion), "CreateIterResultObject(Value.undefined, Value.true)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    return _temp;
  }

  const R = O.IteratingRegExp;
  const S = O.IteratedString;
  const global = O.Global;
  const fullUnicode = O.Unicode;

  let _temp2 = RegExpExec(R, S);
  /* istanbul ignore if */


  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }
  /* istanbul ignore if */


  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const match = _temp2;

  if (match === Value.null) {
    O.Done = Value.true;

    let _temp3 = CreateIterResultObject(Value.undefined, Value.true);

    Assert(!(_temp3 instanceof AbruptCompletion), "CreateIterResultObject(Value.undefined, Value.true)" + ' returned an abrupt completion');

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    return _temp3;
  } else {
    if (global === Value.true) {
      let _temp4 = Get(match, new Value('0'));

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      const matchStrValue = _temp4;

      let _temp5 = ToString(matchStrValue);

      if (_temp5 instanceof AbruptCompletion) {
        return _temp5;
      }

      if (_temp5 instanceof Completion) {
        _temp5 = _temp5.Value;
      }

      const matchStr = _temp5;

      if (matchStr.stringValue() === '') {
        let _temp6 = Get(R, new Value('lastIndex'));

        if (_temp6 instanceof AbruptCompletion) {
          return _temp6;
        }

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        const thisIndexValue = _temp6;

        let _temp7 = ToLength(thisIndexValue);

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        const thisIndex = _temp7;

        let _temp8 = AdvanceStringIndex(S, thisIndex, fullUnicode);

        Assert(!(_temp8 instanceof AbruptCompletion), "AdvanceStringIndex(S, thisIndex, fullUnicode)" + ' returned an abrupt completion');

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }

        const nextIndex = _temp8;

        let _temp9 = Set$1(R, new Value('lastIndex'), nextIndex, Value.true);

        if (_temp9 instanceof AbruptCompletion) {
          return _temp9;
        }

        if (_temp9 instanceof Completion) {
          _temp9 = _temp9.Value;
        }
      }

      return CreateIterResultObject(match, Value.false);
    } else {
      O.Done = Value.true;
      return CreateIterResultObject(match, Value.false);
    }
  }
}

function CreateRegExpStringIteratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['next', RegExpStringIteratorPrototype_next, 0], [wellKnownSymbols.toStringTag, new Value('RegExp String Iterator'), undefined, {
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }]], realmRec.Intrinsics['%IteratorPrototype%']);
  realmRec.Intrinsics['%RegExpStringIteratorPrototype%'] = proto;
}

function RegExpProto_exec([string = Value.undefined], {
  thisValue
}) {
  const R = thisValue;

  let _temp = RequireInternalSlot(R, 'RegExpMatcher');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let _temp2 = ToString(string);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const S = _temp2;
  return RegExpBuiltinExec(R, S);
} // 21.2.5.2.1 #sec-regexpexec


function RegExpExec(R, S) {
  Assert(Type(R) === 'Object', "Type(R) === 'Object'");
  Assert(Type(S) === 'String', "Type(S) === 'String'");

  let _temp3 = Get(R, new Value('exec'));

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const exec = _temp3;

  if (IsCallable(exec) === Value.true) {
    let _temp4 = Call(exec, R, [S]);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const result = _temp4;

    if (Type(result) !== 'Object' && Type(result) !== 'Null') {
      return surroundingAgent.Throw('TypeError', 'RegExpExecNotObject', result);
    }

    return result;
  }

  let _temp5 = RequireInternalSlot(R, 'RegExpMatcher');

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }
  return RegExpBuiltinExec(R, S);
} // 21.2.5.2.2 #sec-regexpbuiltinexec

function RegExpBuiltinExec(R, S) {
  Assert('RegExpMatcher' in R, "'RegExpMatcher' in R");
  Assert(Type(S) === 'String', "Type(S) === 'String'");
  const length = S.stringValue().length;

  let _temp17 = Get(R, new Value('lastIndex'));

  if (_temp17 instanceof AbruptCompletion) {
    return _temp17;
  }

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  let _temp6 = ToLength(_temp17);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  let lastIndex = _temp6;
  const flags = R.OriginalFlags.stringValue();
  const global = flags.includes('g');
  const sticky = flags.includes('y');

  if (!global && !sticky) {
    lastIndex = new Value(0);
  }

  const matcher = R.RegExpMatcher;
  const fullUnicode = flags.includes('u');
  let matchSucceeded = false;
  let r;

  while (matchSucceeded === false) {
    if (lastIndex.numberValue() > length) {
      if (global || sticky) {
        let _temp7 = Set$1(R, new Value('lastIndex'), new Value(0), Value.true);

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }
      }

      return Value.null;
    }

    r = matcher(S, lastIndex);

    if (r === null) {
      if (sticky) {
        let _temp8 = Set$1(R, new Value('lastIndex'), new Value(0), Value.true);

        if (_temp8 instanceof AbruptCompletion) {
          return _temp8;
        }

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }
        return Value.null;
      }

      lastIndex = AdvanceStringIndex(S, lastIndex, fullUnicode ? Value.true : Value.false);
    } else {
      // Assert: r is a state
      matchSucceeded = true;
    }
  }

  const e = r.endIndex;

  if (global || sticky) {
    let _temp9 = Set$1(R, new Value('lastIndex'), e, Value.true);

    if (_temp9 instanceof AbruptCompletion) {
      return _temp9;
    }

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }
  }

  const n = r.captures.length;
  Assert(n < 2 ** 32 - 1, "n < (2 ** 32) - 1");

  let _temp10 = ArrayCreate(new Value(n + 1));

  Assert(!(_temp10 instanceof AbruptCompletion), "ArrayCreate(new Value(n + 1))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const A = _temp10; // Assert: The value of A's "length" property is n + 1.

  let _temp11 = CreateDataProperty(A, new Value('index'), lastIndex);

  Assert(!(_temp11 instanceof AbruptCompletion), "CreateDataProperty(A, new Value('index'), lastIndex)" + ' returned an abrupt completion');

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  let _temp12 = CreateDataProperty(A, new Value('input'), S);

  Assert(!(_temp12 instanceof AbruptCompletion), "CreateDataProperty(A, new Value('input'), S)" + ' returned an abrupt completion');

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }
  const matchedSubstr = S.stringValue().substring(lastIndex.numberValue(), e.numberValue());

  let _temp13 = CreateDataProperty(A, new Value('0'), new Value(matchedSubstr));

  Assert(!(_temp13 instanceof AbruptCompletion), "CreateDataProperty(A, new Value('0'), new Value(matchedSubstr))" + ' returned an abrupt completion');

  if (_temp13 instanceof Completion) {
    _temp13 = _temp13.Value;
  }
  let groups;

  if (R.GroupName) ; else {
    groups = Value.undefined;
  }

  let _temp14 = CreateDataProperty(A, new Value('groups'), groups);

  Assert(!(_temp14 instanceof AbruptCompletion), "CreateDataProperty(A, new Value('groups'), groups)" + ' returned an abrupt completion');

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  for (let i = 1; i <= n; i += 1) {
    const captureI = r.captures[i - 1];
    let captureValue;

    if (captureI === Value.undefined) {
      captureValue = Value.undefined;
    } else if (fullUnicode) {
      // Assert: captureI is a List of code points.
      captureValue = new Value(captureI.reduce((acc, codePoint) => acc + String.fromCodePoint(codePoint), ''));
    } else {
      // Assert: captureI is a List of code units.
      captureValue = new Value(captureI.reduce((acc, charCode) => acc + String.fromCharCode(charCode), ''));
    }

    let _temp16 = ToString(new Value(i));

    Assert(!(_temp16 instanceof AbruptCompletion), "ToString(new Value(i))" + ' returned an abrupt completion');

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }

    let _temp15 = CreateDataProperty(A, _temp16, captureValue);

    Assert(!(_temp15 instanceof AbruptCompletion), "CreateDataProperty(A, X(ToString(new Value(i))), captureValue)" + ' returned an abrupt completion');

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }
  }

  return A;
} // 21.2.5.2.3 #sec-advancestringindex


function AdvanceStringIndex(S, index, unicode) {
  Assert(Type(S) === 'String', "Type(S) === 'String'");
  index = index.numberValue();
  Assert(Number.isInteger(index) && index >= 0 && index <= 2 ** 53 - 1, "Number.isInteger(index) && index >= 0 && index <= (2 ** 53) - 1");
  Assert(Type(unicode) === 'Boolean', "Type(unicode) === 'Boolean'");

  if (unicode === Value.false) {
    return new Value(index + 1);
  }

  const length = S.stringValue().length;

  if (index + 1 >= length) {
    return new Value(index + 1);
  }

  let _temp18 = CodePointAt(S, index);

  Assert(!(_temp18 instanceof AbruptCompletion), "CodePointAt(S, index)" + ' returned an abrupt completion');

  if (_temp18 instanceof Completion) {
    _temp18 = _temp18.Value;
  }

  const cp = _temp18;
  return new Value(index + cp.CodeUnitCount.numberValue());
} // 21.2.5.3 #sec-get-regexp.prototype.dotAll

function RegExpProto_dotAllGetter(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  if (!('OriginalFlags' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value.undefined;
    }

    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  const flags = R.OriginalFlags;

  if (flags.stringValue().includes('s')) {
    return Value.true;
  }

  return Value.false;
} // 21.2.5.4 #sec-get-regexp.prototype.flags


function RegExpProto_flagsGetter(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  let result = '';

  let _temp19 = Get(R, new Value('global'));

  if (_temp19 instanceof AbruptCompletion) {
    return _temp19;
  }

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  const global = ToBoolean(_temp19);

  if (global === Value.true) {
    result += 'g';
  }

  let _temp20 = Get(R, new Value('ignoreCase'));

  if (_temp20 instanceof AbruptCompletion) {
    return _temp20;
  }

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }

  const ignoreCase = ToBoolean(_temp20);

  if (ignoreCase === Value.true) {
    result += 'i';
  }

  let _temp21 = Get(R, new Value('multiline'));

  if (_temp21 instanceof AbruptCompletion) {
    return _temp21;
  }

  if (_temp21 instanceof Completion) {
    _temp21 = _temp21.Value;
  }

  const multiline = ToBoolean(_temp21);

  if (multiline === Value.true) {
    result += 'm';
  }

  let _temp22 = Get(R, new Value('dotAll'));

  if (_temp22 instanceof AbruptCompletion) {
    return _temp22;
  }

  if (_temp22 instanceof Completion) {
    _temp22 = _temp22.Value;
  }

  const dotAll = ToBoolean(_temp22);

  if (dotAll === Value.true) {
    result += 's';
  }

  let _temp23 = Get(R, new Value('unicode'));

  if (_temp23 instanceof AbruptCompletion) {
    return _temp23;
  }

  if (_temp23 instanceof Completion) {
    _temp23 = _temp23.Value;
  }

  const unicode = ToBoolean(_temp23);

  if (unicode === Value.true) {
    result += 'u';
  }

  let _temp24 = Get(R, new Value('sticky'));

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  const sticky = ToBoolean(_temp24);

  if (sticky === Value.true) {
    result += 'y';
  }

  return new Value(result);
} // 21.2.5.5 #sec-get-regexp.prototype.global


function RegExpProto_globalGetter(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  if (!('OriginalFlags' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value.undefined;
    }

    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  const flags = R.OriginalFlags;

  if (flags.stringValue().includes('g')) {
    return Value.true;
  }

  return Value.false;
} // 21.2.5.6 #sec-get-regexp.prototype.ignorecase


function RegExpProto_ignoreCaseGetter(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  if (!('OriginalFlags' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value.undefined;
    }

    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  const flags = R.OriginalFlags;

  if (flags.stringValue().includes('i')) {
    return Value.true;
  }

  return Value.false;
} // 21.2.5.7 #sec-regexp.prototype-@@match


function RegExpProto_match([string = Value.undefined], {
  thisValue
}) {
  const rx = thisValue;

  if (Type(rx) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', rx);
  }

  let _temp25 = ToString(string);

  if (_temp25 instanceof AbruptCompletion) {
    return _temp25;
  }

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }

  const S = _temp25;

  let _temp26 = Get(rx, new Value('global'));

  if (_temp26 instanceof AbruptCompletion) {
    return _temp26;
  }

  if (_temp26 instanceof Completion) {
    _temp26 = _temp26.Value;
  }

  const global = ToBoolean(_temp26);

  if (global === Value.false) {
    return RegExpExec(rx, S);
  } else {
    let _temp27 = Get(rx, new Value('unicode'));

    if (_temp27 instanceof AbruptCompletion) {
      return _temp27;
    }

    if (_temp27 instanceof Completion) {
      _temp27 = _temp27.Value;
    }

    const fullUnicode = ToBoolean(_temp27);

    let _temp28 = Set$1(rx, new Value('lastIndex'), new Value(0), Value.true);

    if (_temp28 instanceof AbruptCompletion) {
      return _temp28;
    }

    if (_temp28 instanceof Completion) {
      _temp28 = _temp28.Value;
    }

    let _temp29 = ArrayCreate(new Value(0));

    Assert(!(_temp29 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');

    if (_temp29 instanceof Completion) {
      _temp29 = _temp29.Value;
    }

    const A = _temp29;
    let n = 0;

    while (true) {
      let _temp30 = RegExpExec(rx, S);

      if (_temp30 instanceof AbruptCompletion) {
        return _temp30;
      }

      if (_temp30 instanceof Completion) {
        _temp30 = _temp30.Value;
      }

      const result = _temp30;

      if (result === Value.null) {
        if (n === 0) {
          return Value.null;
        }

        return A;
      } else {
        let _temp36 = Get(result, new Value('0'));

        if (_temp36 instanceof AbruptCompletion) {
          return _temp36;
        }

        if (_temp36 instanceof Completion) {
          _temp36 = _temp36.Value;
        }

        let _temp31 = ToString(_temp36);

        if (_temp31 instanceof AbruptCompletion) {
          return _temp31;
        }

        if (_temp31 instanceof Completion) {
          _temp31 = _temp31.Value;
        }

        const matchStr = _temp31;

        let _temp32 = ToString(new Value(n));

        Assert(!(_temp32 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

        if (_temp32 instanceof Completion) {
          _temp32 = _temp32.Value;
        }

        const status = CreateDataProperty(A, _temp32, matchStr);
        Assert(status === Value.true, "status === Value.true");

        if (matchStr.stringValue() === '') {
          let _temp35 = Get(rx, new Value('lastIndex'));

          if (_temp35 instanceof AbruptCompletion) {
            return _temp35;
          }

          if (_temp35 instanceof Completion) {
            _temp35 = _temp35.Value;
          }

          let _temp33 = ToLength(_temp35);

          if (_temp33 instanceof AbruptCompletion) {
            return _temp33;
          }

          if (_temp33 instanceof Completion) {
            _temp33 = _temp33.Value;
          }

          const thisIndex = _temp33;
          const nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);

          let _temp34 = Set$1(rx, new Value('lastIndex'), nextIndex, Value.true);

          if (_temp34 instanceof AbruptCompletion) {
            return _temp34;
          }

          if (_temp34 instanceof Completion) {
            _temp34 = _temp34.Value;
          }
        }

        n += 1;
      }
    }
  }
} // 21.2.5.8 #sec-regexp-prototype-matchall


function RegExpProto_matchAll([string = Value.undefined], {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  let _temp37 = ToString(string);

  if (_temp37 instanceof AbruptCompletion) {
    return _temp37;
  }

  if (_temp37 instanceof Completion) {
    _temp37 = _temp37.Value;
  }

  const S = _temp37;

  let _temp38 = SpeciesConstructor(R, surroundingAgent.intrinsic('%RegExp%'));

  if (_temp38 instanceof AbruptCompletion) {
    return _temp38;
  }

  if (_temp38 instanceof Completion) {
    _temp38 = _temp38.Value;
  }

  const C = _temp38;

  let _temp44 = Get(R, new Value('flags'));

  if (_temp44 instanceof AbruptCompletion) {
    return _temp44;
  }

  if (_temp44 instanceof Completion) {
    _temp44 = _temp44.Value;
  }

  let _temp39 = ToString(_temp44);

  if (_temp39 instanceof AbruptCompletion) {
    return _temp39;
  }

  if (_temp39 instanceof Completion) {
    _temp39 = _temp39.Value;
  }

  const flags = _temp39;

  let _temp40 = Construct(C, [R, flags]);

  if (_temp40 instanceof AbruptCompletion) {
    return _temp40;
  }

  if (_temp40 instanceof Completion) {
    _temp40 = _temp40.Value;
  }

  const matcher = _temp40;

  let _temp45 = Get(R, new Value('lastIndex'));

  if (_temp45 instanceof AbruptCompletion) {
    return _temp45;
  }

  if (_temp45 instanceof Completion) {
    _temp45 = _temp45.Value;
  }

  let _temp41 = ToLength(_temp45);

  if (_temp41 instanceof AbruptCompletion) {
    return _temp41;
  }

  if (_temp41 instanceof Completion) {
    _temp41 = _temp41.Value;
  }

  const lastIndex = _temp41;

  let _temp42 = Set$1(matcher, new Value('lastIndex'), lastIndex, Value.true);

  if (_temp42 instanceof AbruptCompletion) {
    return _temp42;
  }

  if (_temp42 instanceof Completion) {
    _temp42 = _temp42.Value;
  }
  let global;

  if (flags.stringValue().includes('g')) {
    global = Value.true;
  } else {
    global = Value.false;
  }

  let fullUnicode;

  if (flags.stringValue().includes('u')) {
    fullUnicode = Value.true;
  } else {
    fullUnicode = Value.false;
  }

  let _temp43 = CreateRegExpStringIterator(matcher, S, global, fullUnicode);

  Assert(!(_temp43 instanceof AbruptCompletion), "CreateRegExpStringIterator(matcher, S, global, fullUnicode)" + ' returned an abrupt completion');

  if (_temp43 instanceof Completion) {
    _temp43 = _temp43.Value;
  }

  return _temp43;
} // 21.2.5.9 #sec-get-regexp.prototype.multiline


function RegExpProto_multilineGetter(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  if (!('OriginalFlags' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value.undefined;
    }

    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  const flags = R.OriginalFlags;

  if (flags.stringValue().includes('m')) {
    return Value.true;
  }

  return Value.false;
} // 21.2.5.10 #sec-regexp.prototype-@@replace


function RegExpProto_replace([string = Value.undefined, replaceValue = Value.undefined], {
  thisValue
}) {
  const rx = thisValue;

  if (Type(rx) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', rx);
  }

  let _temp46 = ToString(string);

  if (_temp46 instanceof AbruptCompletion) {
    return _temp46;
  }

  if (_temp46 instanceof Completion) {
    _temp46 = _temp46.Value;
  }

  const S = _temp46;
  const lengthS = S.stringValue().length;
  const functionalReplace = IsCallable(replaceValue);

  if (functionalReplace === Value.false) {
    let _temp47 = ToString(replaceValue);

    if (_temp47 instanceof AbruptCompletion) {
      return _temp47;
    }

    if (_temp47 instanceof Completion) {
      _temp47 = _temp47.Value;
    }

    replaceValue = _temp47;
  }

  let _temp48 = Get(rx, new Value('global'));

  if (_temp48 instanceof AbruptCompletion) {
    return _temp48;
  }

  if (_temp48 instanceof Completion) {
    _temp48 = _temp48.Value;
  }

  const global = ToBoolean(_temp48);
  let fullUnicode;

  if (global === Value.true) {
    let _temp49 = Get(rx, new Value('unicode'));

    if (_temp49 instanceof AbruptCompletion) {
      return _temp49;
    }

    if (_temp49 instanceof Completion) {
      _temp49 = _temp49.Value;
    }

    fullUnicode = ToBoolean(_temp49);

    let _temp50 = Set$1(rx, new Value('lastIndex'), new Value(0), Value.true);

    if (_temp50 instanceof AbruptCompletion) {
      return _temp50;
    }

    if (_temp50 instanceof Completion) {
      _temp50 = _temp50.Value;
    }
  }

  const results = [];
  let done = false;

  while (!done) {
    let _temp51 = RegExpExec(rx, S);

    if (_temp51 instanceof AbruptCompletion) {
      return _temp51;
    }

    if (_temp51 instanceof Completion) {
      _temp51 = _temp51.Value;
    }

    const result = _temp51;

    if (result === Value.null) {
      done = true;
    } else {
      results.push(result);

      if (global === Value.false) {
        done = true;
      } else {
        let _temp52 = Get(result, new Value('0'));

        if (_temp52 instanceof AbruptCompletion) {
          return _temp52;
        }

        if (_temp52 instanceof Completion) {
          _temp52 = _temp52.Value;
        }

        const firstResult = _temp52;

        let _temp53 = ToString(firstResult);

        if (_temp53 instanceof AbruptCompletion) {
          return _temp53;
        }

        if (_temp53 instanceof Completion) {
          _temp53 = _temp53.Value;
        }

        const matchStr = _temp53;

        if (matchStr.stringValue() === '') {
          let _temp56 = Get(rx, new Value('lastIndex'));

          if (_temp56 instanceof AbruptCompletion) {
            return _temp56;
          }

          if (_temp56 instanceof Completion) {
            _temp56 = _temp56.Value;
          }

          let _temp54 = ToLength(_temp56);

          if (_temp54 instanceof AbruptCompletion) {
            return _temp54;
          }

          if (_temp54 instanceof Completion) {
            _temp54 = _temp54.Value;
          }

          const thisIndex = _temp54;
          const nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);

          let _temp55 = Set$1(rx, new Value('lastIndex'), nextIndex, Value.true);

          if (_temp55 instanceof AbruptCompletion) {
            return _temp55;
          }

          if (_temp55 instanceof Completion) {
            _temp55 = _temp55.Value;
          }
        }
      }
    }
  }

  let accumulatedResult = '';
  let nextSourcePosition = 0;

  for (const result of results) {
    let _temp57 = LengthOfArrayLike(result);

    if (_temp57 instanceof AbruptCompletion) {
      return _temp57;
    }

    if (_temp57 instanceof Completion) {
      _temp57 = _temp57.Value;
    }

    let nCaptures = _temp57.numberValue();

    nCaptures = Math.max(nCaptures - 1, 0);

    let _temp68 = Get(result, new Value('0'));

    if (_temp68 instanceof AbruptCompletion) {
      return _temp68;
    }

    if (_temp68 instanceof Completion) {
      _temp68 = _temp68.Value;
    }

    let _temp58 = ToString(_temp68);

    if (_temp58 instanceof AbruptCompletion) {
      return _temp58;
    }

    if (_temp58 instanceof Completion) {
      _temp58 = _temp58.Value;
    }

    const matched = _temp58;
    const matchLength = matched.stringValue().length;

    let _temp69 = Get(result, new Value('index'));

    if (_temp69 instanceof AbruptCompletion) {
      return _temp69;
    }

    if (_temp69 instanceof Completion) {
      _temp69 = _temp69.Value;
    }

    let _temp59 = ToInteger(_temp69);

    if (_temp59 instanceof AbruptCompletion) {
      return _temp59;
    }

    if (_temp59 instanceof Completion) {
      _temp59 = _temp59.Value;
    }

    let position = _temp59;
    position = new Value(Math.max(Math.min(position.numberValue(), lengthS), 0));
    let n = 1;
    const captures = [];

    while (n <= nCaptures) {
      let _temp62 = ToString(new Value(n));

      Assert(!(_temp62 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

      if (_temp62 instanceof Completion) {
        _temp62 = _temp62.Value;
      }

      let _temp60 = Get(result, _temp62);

      if (_temp60 instanceof AbruptCompletion) {
        return _temp60;
      }

      if (_temp60 instanceof Completion) {
        _temp60 = _temp60.Value;
      }

      let capN = _temp60;

      if (capN !== Value.undefined) {
        let _temp61 = ToString(capN);

        if (_temp61 instanceof AbruptCompletion) {
          return _temp61;
        }

        if (_temp61 instanceof Completion) {
          _temp61 = _temp61.Value;
        }

        capN = _temp61;
      }

      captures.push(capN);
      n += 1;
    }

    let _temp63 = Get(result, new Value('groups'));

    if (_temp63 instanceof AbruptCompletion) {
      return _temp63;
    }

    if (_temp63 instanceof Completion) {
      _temp63 = _temp63.Value;
    }

    let namedCaptures = _temp63;
    let replacement;

    if (functionalReplace === Value.true) {
      const replacerArgs = [matched];
      replacerArgs.push(...captures);
      replacerArgs.push(position, S);

      if (namedCaptures !== Value.undefined) {
        replacerArgs.push(namedCaptures);
      }

      let _temp64 = Call(replaceValue, Value.undefined, replacerArgs);

      if (_temp64 instanceof AbruptCompletion) {
        return _temp64;
      }

      if (_temp64 instanceof Completion) {
        _temp64 = _temp64.Value;
      }

      const replValue = _temp64;

      let _temp65 = ToString(replValue);

      if (_temp65 instanceof AbruptCompletion) {
        return _temp65;
      }

      if (_temp65 instanceof Completion) {
        _temp65 = _temp65.Value;
      }

      replacement = _temp65;
    } else {
      if (namedCaptures !== Value.undefined) {
        let _temp66 = ToObject(namedCaptures);

        if (_temp66 instanceof AbruptCompletion) {
          return _temp66;
        }

        if (_temp66 instanceof Completion) {
          _temp66 = _temp66.Value;
        }

        namedCaptures = _temp66;
      }

      let _temp67 = GetSubstitution(matched, S, position, captures, namedCaptures, replaceValue);

      if (_temp67 instanceof AbruptCompletion) {
        return _temp67;
      }

      if (_temp67 instanceof Completion) {
        _temp67 = _temp67.Value;
      }

      replacement = _temp67;
    }

    if (position.numberValue() >= nextSourcePosition) {
      accumulatedResult = accumulatedResult + S.stringValue().substring(nextSourcePosition, position.numberValue()) + replacement.stringValue();
      nextSourcePosition = position.numberValue() + matchLength;
    }
  }

  if (nextSourcePosition >= lengthS) {
    return new Value(accumulatedResult);
  }

  return new Value(accumulatedResult + S.stringValue().substring(nextSourcePosition));
} // 21.2.5.11 #sec-regexp.prototype-@@search


function RegExpProto_search([string = Value.undefined], {
  thisValue
}) {
  const rx = thisValue;

  if (Type(rx) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', rx);
  }

  let _temp70 = ToString(string);

  if (_temp70 instanceof AbruptCompletion) {
    return _temp70;
  }

  if (_temp70 instanceof Completion) {
    _temp70 = _temp70.Value;
  }

  const S = _temp70;

  let _temp71 = Get(rx, new Value('lastIndex'));

  if (_temp71 instanceof AbruptCompletion) {
    return _temp71;
  }

  if (_temp71 instanceof Completion) {
    _temp71 = _temp71.Value;
  }

  const previousLastIndex = _temp71;

  if (SameValue(previousLastIndex, new Value(0)) === Value.false) {
    let _temp72 = Set$1(rx, new Value('lastIndex'), new Value(0), Value.true);

    if (_temp72 instanceof AbruptCompletion) {
      return _temp72;
    }

    if (_temp72 instanceof Completion) {
      _temp72 = _temp72.Value;
    }
  }

  let _temp73 = RegExpExec(rx, S);

  if (_temp73 instanceof AbruptCompletion) {
    return _temp73;
  }

  if (_temp73 instanceof Completion) {
    _temp73 = _temp73.Value;
  }

  const result = _temp73;

  let _temp74 = Get(rx, new Value('lastIndex'));

  if (_temp74 instanceof AbruptCompletion) {
    return _temp74;
  }

  if (_temp74 instanceof Completion) {
    _temp74 = _temp74.Value;
  }

  const currentLastIndex = _temp74;

  if (SameValue(currentLastIndex, previousLastIndex) === Value.false) {
    let _temp75 = Set$1(rx, new Value('lastIndex'), previousLastIndex, Value.true);

    if (_temp75 instanceof AbruptCompletion) {
      return _temp75;
    }

    if (_temp75 instanceof Completion) {
      _temp75 = _temp75.Value;
    }
  }

  if (result === Value.null) {
    return new Value(-1);
  }

  return Get(result, new Value('index'));
} // 21.2.5.12 #sec-get-regexp.prototype.source


function RegExpProto_sourceGetter(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  if (!('OriginalSource' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return new Value('(?:)');
    }

    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  Assert('OriginalFlags' in R, "'OriginalFlags' in R");
  const src = R.OriginalSource;
  const flags = R.OriginalFlags;
  return EscapeRegExpPattern(src, flags);
} // 21.2.5.13 #sec-regexp.prototype-@@split


function RegExpProto_split([string = Value.undefined, limit = Value.undefined], {
  thisValue
}) {
  const rx = thisValue;

  if (Type(rx) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', rx);
  }

  let _temp76 = ToString(string);

  if (_temp76 instanceof AbruptCompletion) {
    return _temp76;
  }

  if (_temp76 instanceof Completion) {
    _temp76 = _temp76.Value;
  }

  const S = _temp76;

  let _temp77 = SpeciesConstructor(rx, surroundingAgent.intrinsic('%RegExp%'));

  if (_temp77 instanceof AbruptCompletion) {
    return _temp77;
  }

  if (_temp77 instanceof Completion) {
    _temp77 = _temp77.Value;
  }

  const C = _temp77;

  let _temp78 = Get(rx, new Value('flags'));

  if (_temp78 instanceof AbruptCompletion) {
    return _temp78;
  }

  if (_temp78 instanceof Completion) {
    _temp78 = _temp78.Value;
  }

  const flagsValue = _temp78;

  let _temp79 = ToString(flagsValue);

  if (_temp79 instanceof AbruptCompletion) {
    return _temp79;
  }

  if (_temp79 instanceof Completion) {
    _temp79 = _temp79.Value;
  }

  const flags = _temp79.stringValue();

  const unicodeMatching = flags.includes('u') ? Value.true : Value.false;
  const newFlags = flags.includes('y') ? new Value(flags) : new Value(`${flags}y`);

  let _temp80 = Construct(C, [rx, newFlags]);

  if (_temp80 instanceof AbruptCompletion) {
    return _temp80;
  }

  if (_temp80 instanceof Completion) {
    _temp80 = _temp80.Value;
  }

  const splitter = _temp80;

  let _temp81 = ArrayCreate(new Value(0));

  Assert(!(_temp81 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');

  if (_temp81 instanceof Completion) {
    _temp81 = _temp81.Value;
  }

  const A = _temp81;
  let lengthA = 0;
  let lim;

  if (limit === Value.undefined) {
    lim = 2 ** 32 - 1;
  } else {
    let _temp82 = ToUint32(limit);

    if (_temp82 instanceof AbruptCompletion) {
      return _temp82;
    }

    if (_temp82 instanceof Completion) {
      _temp82 = _temp82.Value;
    }

    lim = _temp82.numberValue();
  }

  const size = S.stringValue().length;
  let p = 0;

  if (lim === 0) {
    return A;
  }

  if (size === 0) {
    let _temp83 = RegExpExec(splitter, S);

    if (_temp83 instanceof AbruptCompletion) {
      return _temp83;
    }

    if (_temp83 instanceof Completion) {
      _temp83 = _temp83.Value;
    }

    const z = _temp83;

    if (z !== Value.null) {
      return A;
    }

    let _temp84 = CreateDataProperty(A, new Value('0'), S);

    Assert(!(_temp84 instanceof AbruptCompletion), "CreateDataProperty(A, new Value('0'), S)" + ' returned an abrupt completion');

    if (_temp84 instanceof Completion) {
      _temp84 = _temp84.Value;
    }
    return A;
  }

  let q = new Value(p);

  while (q.numberValue() < size) {
    let _temp85 = Set$1(splitter, new Value('lastIndex'), q, Value.true);

    if (_temp85 instanceof AbruptCompletion) {
      return _temp85;
    }

    if (_temp85 instanceof Completion) {
      _temp85 = _temp85.Value;
    }

    let _temp86 = RegExpExec(splitter, S);

    if (_temp86 instanceof AbruptCompletion) {
      return _temp86;
    }

    if (_temp86 instanceof Completion) {
      _temp86 = _temp86.Value;
    }

    const z = _temp86;

    if (z === Value.null) {
      q = AdvanceStringIndex(S, q, unicodeMatching);
    } else {
      let _temp87 = Get(splitter, new Value('lastIndex'));

      if (_temp87 instanceof AbruptCompletion) {
        return _temp87;
      }

      if (_temp87 instanceof Completion) {
        _temp87 = _temp87.Value;
      }

      const lastIndex = _temp87;

      let _temp88 = ToLength(lastIndex);

      if (_temp88 instanceof AbruptCompletion) {
        return _temp88;
      }

      if (_temp88 instanceof Completion) {
        _temp88 = _temp88.Value;
      }

      let e = _temp88;
      e = new Value(Math.min(e.numberValue(), size));

      if (e.numberValue() === p) {
        q = AdvanceStringIndex(S, q, unicodeMatching);
      } else {
        const T = new Value(S.stringValue().substring(p, q.numberValue()));

        let _temp95 = ToString(new Value(lengthA));

        Assert(!(_temp95 instanceof AbruptCompletion), "ToString(new Value(lengthA))" + ' returned an abrupt completion');

        if (_temp95 instanceof Completion) {
          _temp95 = _temp95.Value;
        }

        let _temp89 = CreateDataProperty(A, _temp95, T);

        Assert(!(_temp89 instanceof AbruptCompletion), "CreateDataProperty(A, X(ToString(new Value(lengthA))), T)" + ' returned an abrupt completion');

        if (_temp89 instanceof Completion) {
          _temp89 = _temp89.Value;
        }
        lengthA += 1;

        if (lengthA === lim) {
          return A;
        }

        p = e.numberValue();

        let _temp90 = LengthOfArrayLike(z);

        if (_temp90 instanceof AbruptCompletion) {
          return _temp90;
        }

        if (_temp90 instanceof Completion) {
          _temp90 = _temp90.Value;
        }

        let numberOfCaptures = _temp90.numberValue();

        numberOfCaptures = Math.max(numberOfCaptures - 1, 0);
        let i = 1;

        while (i <= numberOfCaptures) {
          let _temp93 = ToString(new Value(i));

          Assert(!(_temp93 instanceof AbruptCompletion), "ToString(new Value(i))" + ' returned an abrupt completion');

          if (_temp93 instanceof Completion) {
            _temp93 = _temp93.Value;
          }

          let _temp91 = Get(z, _temp93);

          if (_temp91 instanceof AbruptCompletion) {
            return _temp91;
          }

          if (_temp91 instanceof Completion) {
            _temp91 = _temp91.Value;
          }

          const nextCapture = _temp91;

          let _temp94 = ToString(new Value(lengthA));

          Assert(!(_temp94 instanceof AbruptCompletion), "ToString(new Value(lengthA))" + ' returned an abrupt completion');

          if (_temp94 instanceof Completion) {
            _temp94 = _temp94.Value;
          }

          let _temp92 = CreateDataProperty(A, _temp94, nextCapture);

          Assert(!(_temp92 instanceof AbruptCompletion), "CreateDataProperty(A, X(ToString(new Value(lengthA))), nextCapture)" + ' returned an abrupt completion');

          if (_temp92 instanceof Completion) {
            _temp92 = _temp92.Value;
          }
          i += 1;
          lengthA += 1;

          if (lengthA === lim) {
            return A;
          }
        }

        q = new Value(p);
      }
    }
  }

  const T = new Value(S.stringValue().substring(p, size));

  let _temp97 = ToString(new Value(lengthA));

  Assert(!(_temp97 instanceof AbruptCompletion), "ToString(new Value(lengthA))" + ' returned an abrupt completion');

  if (_temp97 instanceof Completion) {
    _temp97 = _temp97.Value;
  }

  let _temp96 = CreateDataProperty(A, _temp97, T);

  Assert(!(_temp96 instanceof AbruptCompletion), "CreateDataProperty(A, X(ToString(new Value(lengthA))), T)" + ' returned an abrupt completion');

  if (_temp96 instanceof Completion) {
    _temp96 = _temp96.Value;
  }
  return A;
} // 21.2.5.14 #sec-get-regexp.prototype.sticky


function RegExpProto_stickyGetter(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  if (!('OriginalFlags' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value.undefined;
    }

    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  const flags = R.OriginalFlags;

  if (flags.stringValue().includes('y')) {
    return Value.true;
  }

  return Value.false;
} // 21.2.5.15 #sec-regexp.prototype.test


function RegExpProto_test([S = Value.undefined], {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  let _temp98 = ToString(S);

  if (_temp98 instanceof AbruptCompletion) {
    return _temp98;
  }

  if (_temp98 instanceof Completion) {
    _temp98 = _temp98.Value;
  }

  const string = _temp98;

  let _temp99 = RegExpExec(R, string);

  if (_temp99 instanceof AbruptCompletion) {
    return _temp99;
  }

  if (_temp99 instanceof Completion) {
    _temp99 = _temp99.Value;
  }

  const match = _temp99;

  if (match !== Value.null) {
    return Value.true;
  }

  return Value.false;
} // 21.2.5.16 #sec-regexp.prototype.tostring


function RegExpProto_toString(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  let _temp102 = Get(R, new Value('source'));

  if (_temp102 instanceof AbruptCompletion) {
    return _temp102;
  }

  if (_temp102 instanceof Completion) {
    _temp102 = _temp102.Value;
  }

  let _temp100 = ToString(_temp102);

  if (_temp100 instanceof AbruptCompletion) {
    return _temp100;
  }

  if (_temp100 instanceof Completion) {
    _temp100 = _temp100.Value;
  }

  const pattern = _temp100;

  let _temp103 = Get(R, new Value('flags'));

  if (_temp103 instanceof AbruptCompletion) {
    return _temp103;
  }

  if (_temp103 instanceof Completion) {
    _temp103 = _temp103.Value;
  }

  let _temp101 = ToString(_temp103);

  if (_temp101 instanceof AbruptCompletion) {
    return _temp101;
  }

  if (_temp101 instanceof Completion) {
    _temp101 = _temp101.Value;
  }

  const flags = _temp101;
  const result = `/${pattern.stringValue()}/${flags.stringValue()}`;
  return new Value(result);
} // 21.2.5.17 #sec-get-regexp.prototype.unicode


function RegExpProto_unicodeGetter(args, {
  thisValue
}) {
  const R = thisValue;

  if (Type(R) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  if (!('OriginalFlags' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value.undefined;
    }

    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }

  const flags = R.OriginalFlags;

  if (flags.stringValue().includes('u')) {
    return Value.true;
  }

  return Value.false;
}

function CreateRegExpPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['exec', RegExpProto_exec, 1], ['dotAll', [RegExpProto_dotAllGetter]], ['flags', [RegExpProto_flagsGetter]], ['global', [RegExpProto_globalGetter]], ['ignoreCase', [RegExpProto_ignoreCaseGetter]], [wellKnownSymbols.match, RegExpProto_match, 1], [wellKnownSymbols.matchAll, RegExpProto_matchAll, 1], ['multiline', [RegExpProto_multilineGetter]], [wellKnownSymbols.replace, RegExpProto_replace, 2], [wellKnownSymbols.search, RegExpProto_search, 1], ['source', [RegExpProto_sourceGetter]], [wellKnownSymbols.split, RegExpProto_split, 2], ['sticky', [RegExpProto_stickyGetter]], ['test', RegExpProto_test, 1], ['toString', RegExpProto_toString, 0], ['unicode', [RegExpProto_unicodeGetter]]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%RegExp.prototype%'] = proto;
}

function RegExpConstructor([pattern = Value.undefined, flags = Value.undefined], {
  NewTarget
}) {
  let _temp = IsRegExp(pattern);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const patternIsRegExp = _temp;
  let newTarget;

  if (NewTarget === Value.undefined) {
    newTarget = surroundingAgent.activeFunctionObject;

    if (patternIsRegExp === Value.true && flags === Value.undefined) {
      let _temp2 = Get(pattern, new Value('constructor'));

      if (_temp2 instanceof AbruptCompletion) {
        return _temp2;
      }

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      const patternConstructor = _temp2;

      if (SameValue(newTarget, patternConstructor) === Value.true) {
        return pattern;
      }
    }
  } else {
    newTarget = NewTarget;
  }

  let P;
  let F;

  if (Type(pattern) === 'Object' && 'RegExpMatcher' in pattern) {
    P = pattern.OriginalSource;

    if (flags === Value.undefined) {
      F = pattern.OriginalFlags;
    } else {
      F = flags;
    }
  } else if (patternIsRegExp === Value.true) {
    let _temp3 = Get(pattern, new Value('source'));

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    P = _temp3;

    if (flags === Value.undefined) {
      let _temp4 = Get(pattern, new Value('flags'));

      if (_temp4 instanceof AbruptCompletion) {
        return _temp4;
      }

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      F = _temp4;
    } else {
      F = flags;
    }
  } else {
    P = pattern;
    F = flags;
  }

  let _temp5 = RegExpAlloc(newTarget);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const O = _temp5;
  return RegExpInitialize(O, P, F);
} // 21.2.4.2 #sec-get-regexp-@@species


function RegExp_speciesGetter(args, {
  thisValue
}) {
  return thisValue;
}

function CreateRegExp(realmRec) {
  const proto = realmRec.Intrinsics['%RegExp.prototype%'];
  const cons = BootstrapConstructor(realmRec, RegExpConstructor, 'RegExp', 2, proto, [[wellKnownSymbols.species, [RegExp_speciesGetter]]]);
  realmRec.Intrinsics['%RegExp%'] = cons;
}

function PromiseProto_catch([onRejected = Value.undefined], {
  thisValue
}) {
  const promise = thisValue;
  return Invoke(promise, new Value('then'), [Value.undefined, onRejected]);
}

function ThenFinallyFunctions([value = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  const onFinally = F.OnFinally;
  Assert(IsCallable(onFinally) === Value.true, "IsCallable(onFinally) === Value.true");

  let _temp = Call(onFinally, Value.undefined);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const result = _temp;
  const C = F.Constructor;
  Assert(IsConstructor(C) === Value.true, "IsConstructor(C) === Value.true");

  let _temp2 = PromiseResolve(C, result);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const promise = _temp2;
  const valueThunk = CreateBuiltinFunction(() => value, []);
  SetFunctionLength(valueThunk, new Value(0));
  return Invoke(promise, new Value('then'), [valueThunk]);
}

function CatchFinallyFunctions([reason = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  const onFinally = F.OnFinally;
  Assert(IsCallable(onFinally) === Value.true, "IsCallable(onFinally) === Value.true");

  let _temp3 = Call(onFinally, Value.undefined);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const result = _temp3;
  const C = F.Constructor;
  Assert(IsConstructor(C) === Value.true, "IsConstructor(C) === Value.true");

  let _temp4 = PromiseResolve(C, result);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const promise = _temp4;
  const thrower = CreateBuiltinFunction(() => new ThrowCompletion(reason), []);
  SetFunctionLength(thrower, new Value(0));
  return Invoke(promise, new Value('then'), [thrower]);
}

function PromiseProto_finally([onFinally = Value.undefined], {
  thisValue
}) {
  const promise = thisValue;

  if (Type(promise) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Promise', promise);
  }

  const C = SpeciesConstructor(promise, surroundingAgent.intrinsic('%Promise%'));
  Assert(IsConstructor(C) === Value.true, "IsConstructor(C) === Value.true");
  let thenFinally;
  let catchFinally;

  if (IsCallable(onFinally) === Value.false) {
    thenFinally = onFinally;
    catchFinally = onFinally;
  } else {
    const stepsThenFinally = ThenFinallyFunctions;

    let _temp5 = CreateBuiltinFunction(stepsThenFinally, ['Constructor', 'OnFinally']);

    Assert(!(_temp5 instanceof AbruptCompletion), "CreateBuiltinFunction(stepsThenFinally, ['Constructor', 'OnFinally'])" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    thenFinally = _temp5;
    SetFunctionLength(thenFinally, new Value(1));
    thenFinally.Constructor = C;
    thenFinally.OnFinally = onFinally;
    const stepsCatchFinally = CatchFinallyFunctions;

    let _temp6 = CreateBuiltinFunction(stepsCatchFinally, ['Constructor', 'OnFinally']);

    Assert(!(_temp6 instanceof AbruptCompletion), "CreateBuiltinFunction(stepsCatchFinally, ['Constructor', 'OnFinally'])" + ' returned an abrupt completion');

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    catchFinally = _temp6;
    SetFunctionLength(catchFinally, new Value(1));
    catchFinally.Constructor = C;
    catchFinally.OnFinally = onFinally;
  }

  return Invoke(promise, new Value('then'), [thenFinally, catchFinally]);
}

function PromiseProto_then([onFulfilled = Value.undefined, onRejected = Value.undefined], {
  thisValue
}) {
  const promise = thisValue;

  if (IsPromise(promise) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Promise', promise);
  }

  let _temp7 = SpeciesConstructor(promise, surroundingAgent.intrinsic('%Promise%'));

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const C = _temp7;

  let _temp8 = NewPromiseCapability(C);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const resultCapability = _temp8;
  return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability);
}

function CreatePromisePrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['catch', PromiseProto_catch, 1], ['finally', PromiseProto_finally, 1], ['then', PromiseProto_then, 2]], realmRec.Intrinsics['%Object.prototype%'], 'Promise');

  let _temp9 = Get(proto, new Value('then'));

  Assert(!(_temp9 instanceof AbruptCompletion), "Get(proto, new Value('then'))" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  realmRec.Intrinsics['%Promise.prototype.then%'] = _temp9;
  realmRec.Intrinsics['%Promise.prototype%'] = proto;
}

function PromiseConstructor([executor = Value.undefined], {
  NewTarget
}) {
  if (NewTarget === Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', 'Promise');
  }

  if (IsCallable(executor) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', executor);
  }

  let _temp = OrdinaryCreateFromConstructor(NewTarget, '%Promise.prototype%', ['PromiseState', 'PromiseResult', 'PromiseFulfillReactions', 'PromiseRejectReactions', 'PromiseIsHandled']);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const promise = _temp;
  promise.PromiseState = 'pending';
  promise.PromiseFulfillReactions = [];
  promise.PromiseRejectReactions = [];
  promise.PromiseIsHandled = Value.false;
  const resolvingFunctions = CreateResolvingFunctions(promise);
  const completion = Call(executor, Value.undefined, [resolvingFunctions.Resolve, resolvingFunctions.Reject]);

  if (completion instanceof AbruptCompletion) {
    let _temp2 = Call(resolvingFunctions.Reject, Value.undefined, [completion.Value]);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }
  }

  return promise;
} // 25.6.4.1.2 #sec-promise.all-resolve-element-functions


function PromiseAllResolveElementFunctions([x = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  const alreadyCalled = F.AlreadyCalled;

  if (alreadyCalled.Value === true) {
    return Value.undefined;
  }

  alreadyCalled.Value = true;
  const index = F.Index;
  const values = F.Values;
  const promiseCapability = F.Capability;
  const remainingElementsCount = F.RemainingElements;
  values[index] = x;
  remainingElementsCount.Value -= 1;

  if (remainingElementsCount.Value === 0) {
    const valuesArray = CreateArrayFromList(values);
    return Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
  }

  return Value.undefined;
} // 25.6.4.1.1 #sec-performpromiseall


function PerformPromiseAll(iteratorRecord, constructor, resultCapability) {
  Assert(IsConstructor(constructor) === Value.true, "IsConstructor(constructor) === Value.true");
  Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
  const values = [];
  const remainingElementsCount = {
    Value: 1
  };

  let _temp3 = Get(constructor, new Value('resolve'));

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const promiseResolve = _temp3;

  if (IsCallable(promiseResolve) === Value.alse) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', promiseResolve);
  }

  let index = 0;

  while (true) {
    let next = IteratorStep(iteratorRecord);

    if (next instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    /* istanbul ignore if */
    if (next instanceof AbruptCompletion) {
      return next;
    }
    /* istanbul ignore if */


    if (next instanceof Completion) {
      next = next.Value;
    }

    if (next === Value.false) {
      iteratorRecord.Done = Value.true;
      remainingElementsCount.Value -= 1;

      if (remainingElementsCount.Value === 0) {
        const valuesArray = CreateArrayFromList(values);

        let _temp4 = Call(resultCapability.Resolve, Value.undefined, [valuesArray]);

        if (_temp4 instanceof AbruptCompletion) {
          return _temp4;
        }

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }
      }

      return resultCapability.Promise;
    }

    let nextValue = IteratorValue(next);

    if (nextValue instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (nextValue instanceof AbruptCompletion) {
      return nextValue;
    }

    if (nextValue instanceof Completion) {
      nextValue = nextValue.Value;
    }
    values.push(Value.undefined);

    let _temp5 = Call(promiseResolve, constructor, [nextValue]);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const nextPromise = _temp5;
    const steps = PromiseAllResolveElementFunctions;

    let _temp6 = CreateBuiltinFunction(steps, ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);

    Assert(!(_temp6 instanceof AbruptCompletion), "CreateBuiltinFunction(steps, [\n      'AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements',\n    ])" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    const resolveElement = _temp6;

    let _temp7 = SetFunctionLength(resolveElement, new Value(1));

    Assert(!(_temp7 instanceof AbruptCompletion), "SetFunctionLength(resolveElement, new Value(1))" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }
    resolveElement.AlreadyCalled = {
      Value: false
    };
    resolveElement.Index = index;
    resolveElement.Values = values;
    resolveElement.Capability = resultCapability;
    resolveElement.RemainingElements = remainingElementsCount;
    remainingElementsCount.Value += 1;

    let _temp8 = Invoke(nextPromise, new Value('then'), [resolveElement, resultCapability.Reject]);

    if (_temp8 instanceof AbruptCompletion) {
      return _temp8;
    }

    if (_temp8 instanceof Completion) {
      _temp8 = _temp8.Value;
    }
    index += 1;
  }
}

function Promise_all([iterable = Value.undefined], {
  thisValue
}) {
  const C = thisValue;

  let _temp9 = NewPromiseCapability(C);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const promiseCapability = _temp9;
  let iteratorRecord = GetIterator(iterable);

  /* istanbul ignore if */
  if (iteratorRecord instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }
  /* istanbul ignore if */


  if (iteratorRecord instanceof Completion) {
    iteratorRecord = iteratorRecord.Value;
  }

  let result = PerformPromiseAll(iteratorRecord, C, promiseCapability);

  if (result instanceof AbruptCompletion) {
    if (iteratorRecord.Done === Value.false) {
      result = IteratorClose(iteratorRecord, result);
    }

    if (result instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }
  }

  return Completion(result);
}

function PromiseAllSettledResolveElementFunctions([x = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  const alreadyCalled = F.AlreadyCalled;

  if (alreadyCalled.Value === true) {
    return Value.undefined;
  }

  alreadyCalled.Value = true;
  const index = F.Index;
  const values = F.Values;
  const promiseCapability = F.Capability;
  const remainingElementsCount = F.RemainingElements;

  let _temp10 = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  Assert(!(_temp10 instanceof AbruptCompletion), "ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'))" + ' returned an abrupt completion');

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const obj = _temp10;

  let _temp11 = CreateDataProperty(obj, new Value('status'), new Value('fulfilled'));

  Assert(!(_temp11 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('status'), new Value('fulfilled'))" + ' returned an abrupt completion');

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  let _temp12 = CreateDataProperty(obj, new Value('value'), x);

  Assert(!(_temp12 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('value'), x)" + ' returned an abrupt completion');

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }
  values[index] = obj;
  remainingElementsCount.Value -= 1;

  if (remainingElementsCount.Value === 0) {
    let _temp13 = CreateArrayFromList(values);

    Assert(!(_temp13 instanceof AbruptCompletion), "CreateArrayFromList(values)" + ' returned an abrupt completion');

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }

    const valuesArray = _temp13;
    return Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
  }

  return Value.undefined;
}

function PromiseAllSettledRejectElementFunctions([x = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  const alreadyCalled = F.AlreadyCalled;

  if (alreadyCalled.Value === true) {
    return Value.undefined;
  }

  alreadyCalled.Value = true;
  const index = F.Index;
  const values = F.Values;
  const promiseCapability = F.Capability;
  const remainingElementsCount = F.RemainingElements;

  let _temp14 = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  Assert(!(_temp14 instanceof AbruptCompletion), "ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'))" + ' returned an abrupt completion');

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const obj = _temp14;

  let _temp15 = CreateDataProperty(obj, new Value('status'), new Value('rejected'));

  Assert(!(_temp15 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('status'), new Value('rejected'))" + ' returned an abrupt completion');

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  let _temp16 = CreateDataProperty(obj, new Value('reason'), x);

  Assert(!(_temp16 instanceof AbruptCompletion), "CreateDataProperty(obj, new Value('reason'), x)" + ' returned an abrupt completion');

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }
  values[index] = obj;
  remainingElementsCount.Value -= 1;

  if (remainingElementsCount.Value === 0) {
    let _temp17 = CreateArrayFromList(values);

    Assert(!(_temp17 instanceof AbruptCompletion), "CreateArrayFromList(values)" + ' returned an abrupt completion');

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    const valuesArray = _temp17;
    return Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
  }

  return Value.undefined;
}

function PerformPromiseAllSettled(iteratorRecord, constructor, resultCapability) {
  let _temp18 = IsConstructor(constructor) === Value.true;

  Assert(!(_temp18 instanceof AbruptCompletion), "IsConstructor(constructor) === Value.true" + ' returned an abrupt completion');

  if (_temp18 instanceof Completion) {
    _temp18 = _temp18.Value;
  }

  Assert(_temp18, "X(IsConstructor(constructor) === Value.true)");
  Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");

  let _temp19 = Get(constructor, new Value('resolve'));

  if (_temp19 instanceof AbruptCompletion) {
    return _temp19;
  }

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  const promiseResolve = _temp19;
  const values = [];
  const remainingElementsCount = {
    Value: 1
  };
  let index = 0;

  while (true) {
    let next = IteratorStep(iteratorRecord);

    if (next instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (next instanceof AbruptCompletion) {
      return next;
    }

    if (next instanceof Completion) {
      next = next.Value;
    }

    if (next === Value.false) {
      iteratorRecord.Done = Value.true;
      remainingElementsCount.Value -= 1;

      if (remainingElementsCount.Value === 0) {
        let _temp20 = CreateArrayFromList(values);

        Assert(!(_temp20 instanceof AbruptCompletion), "CreateArrayFromList(values)" + ' returned an abrupt completion');

        if (_temp20 instanceof Completion) {
          _temp20 = _temp20.Value;
        }

        const valuesArray = _temp20;

        let _temp21 = Call(resultCapability.Resolve, Value.undefined, [valuesArray]);

        if (_temp21 instanceof AbruptCompletion) {
          return _temp21;
        }

        if (_temp21 instanceof Completion) {
          _temp21 = _temp21.Value;
        }
      }

      return resultCapability.Promise;
    }

    let nextValue = IteratorValue(next);

    if (nextValue instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (nextValue instanceof AbruptCompletion) {
      return nextValue;
    }

    if (nextValue instanceof Completion) {
      nextValue = nextValue.Value;
    }
    values.push(Value.undefined);

    let _temp22 = Call(promiseResolve, constructor, [nextValue]);

    if (_temp22 instanceof AbruptCompletion) {
      return _temp22;
    }

    if (_temp22 instanceof Completion) {
      _temp22 = _temp22.Value;
    }

    const nextPromise = _temp22;
    const steps = PromiseAllSettledResolveElementFunctions;

    let _temp23 = CreateBuiltinFunction(steps, ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);

    Assert(!(_temp23 instanceof AbruptCompletion), "CreateBuiltinFunction(steps, [\n      'AlreadyCalled',\n      'Index',\n      'Values',\n      'Capability',\n      'RemainingElements',\n    ])" + ' returned an abrupt completion');

    if (_temp23 instanceof Completion) {
      _temp23 = _temp23.Value;
    }

    const resolveElement = _temp23;

    let _temp24 = SetFunctionLength(resolveElement, new Value(1));

    Assert(!(_temp24 instanceof AbruptCompletion), "SetFunctionLength(resolveElement, new Value(1))" + ' returned an abrupt completion');

    if (_temp24 instanceof Completion) {
      _temp24 = _temp24.Value;
    }
    const alreadyCalled = {
      Value: false
    };
    resolveElement.AlreadyCalled = alreadyCalled;
    resolveElement.Index = index;
    resolveElement.Values = values;
    resolveElement.Capability = resultCapability;
    resolveElement.RemainingElements = remainingElementsCount;
    const rejectSteps = PromiseAllSettledRejectElementFunctions;

    let _temp25 = CreateBuiltinFunction(rejectSteps, ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);

    Assert(!(_temp25 instanceof AbruptCompletion), "CreateBuiltinFunction(rejectSteps, [\n      'AlreadyCalled',\n      'Index',\n      'Values',\n      'Capability',\n      'RemainingElements',\n    ])" + ' returned an abrupt completion');

    if (_temp25 instanceof Completion) {
      _temp25 = _temp25.Value;
    }

    const rejectElement = _temp25;

    let _temp26 = SetFunctionLength(rejectElement, new Value(1));

    Assert(!(_temp26 instanceof AbruptCompletion), "SetFunctionLength(rejectElement, new Value(1))" + ' returned an abrupt completion');

    if (_temp26 instanceof Completion) {
      _temp26 = _temp26.Value;
    }
    rejectElement.AlreadyCalled = alreadyCalled;
    rejectElement.Index = index;
    rejectElement.Values = values;
    rejectElement.Capability = resultCapability;
    rejectElement.RemainingElements = remainingElementsCount;
    remainingElementsCount.Value += 1;

    let _temp27 = Invoke(nextPromise, new Value('then'), [resolveElement, rejectElement]);

    if (_temp27 instanceof AbruptCompletion) {
      return _temp27;
    }

    if (_temp27 instanceof Completion) {
      _temp27 = _temp27.Value;
    }
    index += 1;
  }
}

function Promise_allSettled([iterable = Value.undefined], {
  thisValue
}) {
  const C = thisValue;

  let _temp28 = NewPromiseCapability(C);

  if (_temp28 instanceof AbruptCompletion) {
    return _temp28;
  }

  if (_temp28 instanceof Completion) {
    _temp28 = _temp28.Value;
  }

  const promiseCapability = _temp28;
  let iteratorRecord = GetIterator(iterable);

  if (iteratorRecord instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }

  if (iteratorRecord instanceof Completion) {
    iteratorRecord = iteratorRecord.Value;
  }

  let result = PerformPromiseAllSettled(iteratorRecord, C, promiseCapability);

  if (result instanceof AbruptCompletion) {
    if (iteratorRecord.Done === Value.false) {
      result = IteratorClose(iteratorRecord, result);
    }

    if (result instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }
  }

  return Completion(result);
}

function PerformPromiseRace(iteratorRecord, constructor, resultCapability) {
  Assert(IsConstructor(constructor) === Value.true, "IsConstructor(constructor) === Value.true");
  Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");

  let _temp29 = Get(constructor, new Value('resolve'));

  if (_temp29 instanceof AbruptCompletion) {
    return _temp29;
  }

  if (_temp29 instanceof Completion) {
    _temp29 = _temp29.Value;
  }

  const promiseResolve = _temp29;

  if (IsCallable(promiseResolve) === Value.alse) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', promiseResolve);
  }

  while (true) {
    let next = IteratorStep(iteratorRecord);

    if (next instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (next instanceof AbruptCompletion) {
      return next;
    }

    if (next instanceof Completion) {
      next = next.Value;
    }

    if (next === Value.false) {
      iteratorRecord.Done = Value.true;
      return resultCapability.Promise;
    }

    let nextValue = IteratorValue(next);

    if (nextValue instanceof AbruptCompletion) {
      iteratorRecord.Done = Value.true;
    }

    if (nextValue instanceof AbruptCompletion) {
      return nextValue;
    }

    if (nextValue instanceof Completion) {
      nextValue = nextValue.Value;
    }

    let _temp30 = Call(promiseResolve, constructor, [nextValue]);

    if (_temp30 instanceof AbruptCompletion) {
      return _temp30;
    }

    if (_temp30 instanceof Completion) {
      _temp30 = _temp30.Value;
    }

    const nextPromise = _temp30;

    let _temp31 = Invoke(nextPromise, new Value('then'), [resultCapability.Resolve, resultCapability.Reject]);

    if (_temp31 instanceof AbruptCompletion) {
      return _temp31;
    }

    if (_temp31 instanceof Completion) {
      _temp31 = _temp31.Value;
    }
  }
}

function Promise_race([iterable = Value.undefined], {
  thisValue
}) {
  const C = thisValue;

  let _temp32 = NewPromiseCapability(C);

  if (_temp32 instanceof AbruptCompletion) {
    return _temp32;
  }

  if (_temp32 instanceof Completion) {
    _temp32 = _temp32.Value;
  }

  const promiseCapability = _temp32;
  let iteratorRecord = GetIterator(iterable);

  if (iteratorRecord instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }

  if (iteratorRecord instanceof Completion) {
    iteratorRecord = iteratorRecord.Value;
  }

  let result = PerformPromiseRace(iteratorRecord, C, promiseCapability);

  if (result instanceof AbruptCompletion) {
    if (iteratorRecord.Done === Value.false) {
      result = IteratorClose(iteratorRecord, result);
    }

    if (result instanceof AbruptCompletion) {
      const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

      if (hygenicTemp2 instanceof AbruptCompletion) {
        return hygenicTemp2;
      }

      return promiseCapability.Promise;
    }

    if (result instanceof Completion) {
      result = result.Value;
    }
  }

  return Completion(result);
}

function Promise_reject([r = Value.undefined], {
  thisValue
}) {
  const C = thisValue;

  let _temp33 = NewPromiseCapability(C);

  if (_temp33 instanceof AbruptCompletion) {
    return _temp33;
  }

  if (_temp33 instanceof Completion) {
    _temp33 = _temp33.Value;
  }

  const promiseCapability = _temp33;

  let _temp34 = Call(promiseCapability.Reject, Value.undefined, [r]);

  if (_temp34 instanceof AbruptCompletion) {
    return _temp34;
  }

  if (_temp34 instanceof Completion) {
    _temp34 = _temp34.Value;
  }
  return promiseCapability.Promise;
}

function Promise_resolve([x = Value.undefined], {
  thisValue
}) {
  const C = thisValue;

  if (Type(C) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'InvalidReceiver', 'Promise.resolve', C);
  }

  return PromiseResolve(C, x);
}

function Promise_symbolSpecies(args, {
  thisValue
}) {
  return thisValue;
}

function CreatePromise(realmRec) {
  const promiseConstructor = BootstrapConstructor(realmRec, PromiseConstructor, 'Promise', 1, realmRec.Intrinsics['%Promise.prototype%'], [['all', Promise_all, 1], ['allSettled', Promise_allSettled, 1], ['race', Promise_race, 1], ['reject', Promise_reject, 1], ['resolve', Promise_resolve, 1], [wellKnownSymbols.species, [Promise_symbolSpecies]]]);
  promiseConstructor.DefineOwnProperty(new Value('prototype'), Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  let _temp35 = Get(promiseConstructor, new Value('all'));

  Assert(!(_temp35 instanceof AbruptCompletion), "Get(promiseConstructor, new Value('all'))" + ' returned an abrupt completion');

  if (_temp35 instanceof Completion) {
    _temp35 = _temp35.Value;
  }

  realmRec.Intrinsics['%Promise.all%'] = _temp35;

  let _temp36 = Get(promiseConstructor, new Value('reject'));

  Assert(!(_temp36 instanceof AbruptCompletion), "Get(promiseConstructor, new Value('reject'))" + ' returned an abrupt completion');

  if (_temp36 instanceof Completion) {
    _temp36 = _temp36.Value;
  }

  realmRec.Intrinsics['%Promise.reject%'] = _temp36;

  let _temp37 = Get(promiseConstructor, new Value('resolve'));

  Assert(!(_temp37 instanceof AbruptCompletion), "Get(promiseConstructor, new Value('resolve'))" + ' returned an abrupt completion');

  if (_temp37 instanceof Completion) {
    _temp37 = _temp37.Value;
  }

  realmRec.Intrinsics['%Promise.resolve%'] = _temp37;
  realmRec.Intrinsics['%Promise%'] = promiseConstructor;
}

function ProxyCallSlot(thisArgument, argumentsList) {
  const O = this;
  const handler = O.ProxyHandler;

  if (handler === Value.null) {
    return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'apply');
  }

  Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
  const target = O.ProxyTarget;

  let _temp = GetMethod(handler, new Value('apply'));
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const trap = _temp;

  if (trap === Value.undefined) {
    return Call(target, thisArgument, argumentsList);
  }

  let _temp2 = CreateArrayFromList(argumentsList);

  Assert(!(_temp2 instanceof AbruptCompletion), "CreateArrayFromList(argumentsList)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const argArray = _temp2;
  return Call(trap, handler, [target, thisArgument, argArray]);
}

function ProxyConstructSlot(argumentsList, newTarget) {
  const O = this;
  const handler = O.ProxyHandler;

  if (handler === Value.null) {
    return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'construct');
  }

  Assert(Type(handler) === 'Object', "Type(handler) === 'Object'");
  const target = O.ProxyTarget;
  Assert(IsConstructor(target) === Value.true, "IsConstructor(target) === Value.true");

  let _temp3 = GetMethod(handler, new Value('construct'));

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const trap = _temp3;

  if (trap === Value.undefined) {
    return Construct(target, argumentsList, newTarget);
  }

  let _temp4 = CreateArrayFromList(argumentsList);

  Assert(!(_temp4 instanceof AbruptCompletion), "CreateArrayFromList(argumentsList)" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const argArray = _temp4;

  let _temp5 = Call(trap, handler, [target, argArray, newTarget]);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const newObj = _temp5;

  if (Type(newObj) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', newObj);
  }

  return newObj;
}

function ProxyCreate(target, handler) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'CannotCreateProxyWith', 'non-object', 'target');
  }

  if (target instanceof ProxyExoticObjectValue && Type(target.ProxyHandler) === 'Null') {
    return surroundingAgent.Throw('TypeError', 'CannotCreateProxyWith', 'revoked proxy', 'target');
  }

  if (Type(handler) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'CannotCreateProxyWith', 'non-object', 'handler');
  }

  if (handler instanceof ProxyExoticObjectValue && Type(handler.ProxyHandler) === 'Null') {
    return surroundingAgent.Throw('TypeError', 'CannotCreateProxyWith', 'revoked proxy', 'handler');
  }

  const P = new ProxyExoticObjectValue();

  if (IsCallable(target) === Value.true) {
    P.Call = ProxyCallSlot;

    if (IsConstructor(target) === Value.true) {
      P.Construct = ProxyConstructSlot;
    }
  }

  P.ProxyTarget = target;
  P.ProxyHandler = handler;
  return P;
}

function ProxyConstructor([target = Value.undefined, handler = Value.undefined], {
  NewTarget
}) {
  if (Type(NewTarget) === 'Undefined') {
    return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', 'Proxy');
  }

  return ProxyCreate(target, handler);
}

function ProxyRevocationFunctions() {
  const F = this;
  const p = F.RevocableProxy;

  if (Type(p) === 'Null') {
    return Value.undefined;
  }

  F.RevocableProxy = Value.null;
  Assert(p instanceof ProxyExoticObjectValue, "p instanceof ProxyExoticObjectValue");
  p.ProxyTarget = Value.null;
  p.ProxyHandler = Value.null;
  return Value.undefined;
}

function Proxy_revocable([target = Value.undefined, handler = Value.undefined]) {
  let _temp6 = ProxyCreate(target, handler);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const p = _temp6;
  const steps = ProxyRevocationFunctions;

  let _temp7 = CreateBuiltinFunction(steps, ['RevocableProxy']);

  Assert(!(_temp7 instanceof AbruptCompletion), "CreateBuiltinFunction(steps, ['RevocableProxy'])" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const revoker = _temp7;
  SetFunctionLength(revoker, new Value(0));
  revoker.RevocableProxy = p;
  const result = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  let _temp8 = CreateDataProperty(result, new Value('proxy'), p);

  Assert(!(_temp8 instanceof AbruptCompletion), "CreateDataProperty(result, new Value('proxy'), p)" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  let _temp9 = CreateDataProperty(result, new Value('revoke'), revoker);

  Assert(!(_temp9 instanceof AbruptCompletion), "CreateDataProperty(result, new Value('revoke'), revoker)" + ' returned an abrupt completion');

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }
  return result;
}

function CreateProxy(realmRec) {
  const proxyConstructor = CreateBuiltinFunction(ProxyConstructor, [], realmRec, undefined, Value.true);
  SetFunctionName(proxyConstructor, new Value('Proxy'));
  SetFunctionLength(proxyConstructor, new Value(2));
  assignProps(realmRec, proxyConstructor, [['revocable', Proxy_revocable, 2]]);
  realmRec.Intrinsics['%Proxy%'] = proxyConstructor;
}

function Reflect_apply([target = Value.undefined, thisArgument = Value.undefined, argumentsList = Value.undefined]) {
  if (IsCallable(target) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', target);
  }

  let _temp = CreateListFromArrayLike(argumentsList);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const args = _temp;
  return Call(target, thisArgument, args);
}

function Reflect_construct([target = Value.undefined, argumentsList = Value.undefined, newTarget]) {
  if (IsConstructor(target) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', target);
  }

  if (newTarget === undefined) {
    newTarget = target;
  } else if (IsConstructor(newTarget) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', newTarget);
  }

  let _temp2 = CreateListFromArrayLike(argumentsList);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const args = _temp2;
  return Construct(target, args, newTarget);
}

function Reflect_defineProperty([target = Value.undefined, propertyKey = Value.undefined, attributes = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  let _temp3 = ToPropertyKey(propertyKey);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const key = _temp3;

  let _temp4 = ToPropertyDescriptor(attributes);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const desc = _temp4;
  return target.DefineOwnProperty(key, desc);
}

function Reflect_deleteProperty([target = Value.undefined, propertyKey = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  let _temp5 = ToPropertyKey(propertyKey);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const key = _temp5;
  return target.Delete(key);
}

function Reflect_get([target = Value.undefined, propertyKey = Value.undefined, receiver]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  let _temp6 = ToPropertyKey(propertyKey);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const key = _temp6;

  if (receiver === undefined) {
    receiver = target;
  }

  return target.Get(key, receiver);
}

function Reflect_getOwnPropertyDescriptor([target = Value.undefined, propertyKey = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  let _temp7 = ToPropertyKey(propertyKey);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const key = _temp7;

  let _temp8 = target.GetOwnProperty(key);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const desc = _temp8;
  return FromPropertyDescriptor(desc);
}

function Reflect_getPrototypeOf([target = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  return target.GetPrototypeOf();
}

function Reflect_has([target = Value.undefined, propertyKey = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  let _temp9 = ToPropertyKey(propertyKey);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const key = _temp9;
  return target.HasProperty(key);
}

function Reflect_isExtensible([target = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  return target.IsExtensible();
}

function Reflect_ownKeys([target = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  let _temp10 = target.OwnPropertyKeys();

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const keys = _temp10;
  return CreateArrayFromList(keys);
}

function Reflect_preventExtensions([target = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  return target.PreventExtensions();
}

function Reflect_set([target = Value.undefined, propertyKey = Value.undefined, V = Value.undefined, receiver]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  let _temp11 = ToPropertyKey(propertyKey);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const key = _temp11;

  if (receiver === undefined) {
    receiver = target;
  }

  return target.Set(key, V, receiver);
}

function Reflect_setPrototypeOf([target = Value.undefined, proto = Value.undefined]) {
  if (Type(target) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }

  if (Type(proto) !== 'Object' && Type(proto) !== 'Null') {
    return surroundingAgent.Throw('TypeError', 'ObjectPrototypeType');
  }

  return target.SetPrototypeOf(proto);
}

function CreateReflect(realmRec) {
  const reflect = BootstrapPrototype(realmRec, [['apply', Reflect_apply, 3], ['construct', Reflect_construct, 2], ['defineProperty', Reflect_defineProperty, 3], ['deleteProperty', Reflect_deleteProperty, 2], ['get', Reflect_get, 2], ['getOwnPropertyDescriptor', Reflect_getOwnPropertyDescriptor, 2], ['getPrototypeOf', Reflect_getPrototypeOf, 1], ['has', Reflect_has, 2], ['isExtensible', Reflect_isExtensible, 1], ['ownKeys', Reflect_ownKeys, 1], ['preventExtensions', Reflect_preventExtensions, 1], ['set', Reflect_set, 3], ['setPrototypeOf', Reflect_setPrototypeOf, 2]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Reflect%'] = reflect;
}

function CreateStringIterator(string) {
  Assert(Type(string) === 'String', "Type(string) === 'String'");
  const iterator = ObjectCreate(surroundingAgent.intrinsic('%StringIteratorPrototype%'), ['IteratedString', 'StringNextIndex']);
  iterator.IteratedString = string;
  iterator.StringNextIndex = 0;
  return iterator;
}

function StringIteratorPrototype_next(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'String Iterator', O);
  }

  if (!('IteratedString' in O && 'StringNextIndex' in O)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'String Iterator', O);
  }

  const s = O.IteratedString;

  if (s === Value.undefined) {
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  const position = O.StringNextIndex;
  const len = s.stringValue().length;

  if (position >= len) {
    O.IteratedString = Value.undefined;
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  let _temp = CodePointAt(s, position);

  Assert(!(_temp instanceof AbruptCompletion), "CodePointAt(s, position)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const cp = _temp;
  const resultString = new Value(s.stringValue().substr(position, cp.CodeUnitCount.numberValue()));
  O.StringNextIndex = position + cp.CodeUnitCount.numberValue();
  return CreateIterResultObject(resultString, Value.false);
}

function CreateStringIteratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['next', StringIteratorPrototype_next, 0]], realmRec.Intrinsics['%IteratorPrototype%'], 'String Iterator');
  realmRec.Intrinsics['%StringIteratorPrototype%'] = proto;
}

function thisStringValue(value) {
  if (Type(value) === 'String') {
    return value;
  }

  if (Type(value) === 'Object' && 'StringData' in value) {
    const s = value.StringData;
    Assert(Type(s) === 'String', "Type(s) === 'String'");
    return s;
  }

  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'String', value);
} // 21.1.3.1 #sec-string.prototype.charat


function StringProto_charAt([pos = Value.undefined], {
  thisValue
}) {
  let _temp = RequireObjectCoercible(thisValue);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const O = _temp;

  let _temp2 = ToString(O);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const S = _temp2;

  let _temp3 = ToInteger(pos);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const position = _temp3.numberValue();

  const size = S.stringValue().length;

  if (position < 0 || position >= size) {
    return new Value('');
  }

  return new Value(S.stringValue()[position]);
} // 21.1.3.2 #sec-string.prototype.charcodeat


function StringProto_charCodeAt([pos = Value.undefined], {
  thisValue
}) {
  let _temp4 = RequireObjectCoercible(thisValue);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const O = _temp4;

  let _temp5 = ToString(O);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const S = _temp5;

  let _temp6 = ToInteger(pos);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const position = _temp6.numberValue();

  const size = S.stringValue().length;

  if (position < 0 || position >= size) {
    return new Value(NaN);
  }

  return new Value(S.stringValue().charCodeAt(position));
} // 21.1.3.3 #sec-string.prototype.codepointat


function StringProto_codePointAt([pos = Value.undefined], {
  thisValue
}) {
  let _temp7 = RequireObjectCoercible(thisValue);

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const O = _temp7;

  let _temp8 = ToString(O);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const S = _temp8;

  let _temp9 = ToInteger(pos);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const position = _temp9.numberValue();

  const size = S.stringValue().length;

  if (position < 0 || position >= size) {
    return Value.undefined;
  }

  let _temp10 = CodePointAt(S, position);

  Assert(!(_temp10 instanceof AbruptCompletion), "CodePointAt(S, position)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const cp = _temp10;
  return cp.CodePoint;
} // 21.1.3.4 #sec-string.prototype.concat


function StringProto_concat(args, {
  thisValue
}) {
  let _temp11 = RequireObjectCoercible(thisValue);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const O = _temp11;

  let _temp12 = ToString(O);

  if (_temp12 instanceof AbruptCompletion) {
    return _temp12;
  }

  if (_temp12 instanceof Completion) {
    _temp12 = _temp12.Value;
  }

  const S = _temp12;
  let R = S.stringValue();

  while (args.length > 0) {
    const next = args.shift();

    let _temp13 = ToString(next);

    if (_temp13 instanceof AbruptCompletion) {
      return _temp13;
    }

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }

    const nextString = _temp13;
    R = `${R}${nextString.stringValue()}`;
  }

  return new Value(R);
} // 21.1.3.6 #sec-string.prototype.endswith


function StringProto_endsWith([searchString = Value.undefined, endPosition = Value.undefined], {
  thisValue
}) {
  let _temp14 = RequireObjectCoercible(thisValue);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const O = _temp14;

  let _temp15 = ToString(O);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  const S = _temp15.stringValue();

  let _temp16 = IsRegExp(searchString);

  if (_temp16 instanceof AbruptCompletion) {
    return _temp16;
  }

  if (_temp16 instanceof Completion) {
    _temp16 = _temp16.Value;
  }

  const isRegExp = _temp16;

  if (isRegExp === Value.true) {
    return surroundingAgent.Throw('TypeError', 'RegExpArgumentNotAllowed', 'String.prototype.endsWith');
  }

  let _temp17 = ToString(searchString);

  if (_temp17 instanceof AbruptCompletion) {
    return _temp17;
  }

  if (_temp17 instanceof Completion) {
    _temp17 = _temp17.Value;
  }

  const searchStr = _temp17.stringValue();

  const len = S.length;
  let pos;

  if (endPosition === Value.undefined) {
    pos = len;
  } else {
    let _temp18 = ToInteger(endPosition);

    if (_temp18 instanceof AbruptCompletion) {
      return _temp18;
    }

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }

    pos = _temp18.numberValue();
  }

  const end = Math.min(Math.max(pos, 0), len);
  const searchLength = searchStr.length;
  const start = end - searchLength;

  if (start < 0) {
    return Value.false;
  }

  for (let i = 0; i < searchLength; i += 1) {
    if (S.charCodeAt(start + i) !== searchStr.charCodeAt(i)) {
      return Value.false;
    }
  }

  return Value.true;
} // 21.1.3.7 #sec-string.prototype.includes


function StringProto_includes([searchString = Value.undefined, position = Value.undefined], {
  thisValue
}) {
  let _temp19 = RequireObjectCoercible(thisValue);

  if (_temp19 instanceof AbruptCompletion) {
    return _temp19;
  }

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  const O = _temp19;

  let _temp20 = ToString(O);

  if (_temp20 instanceof AbruptCompletion) {
    return _temp20;
  }

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }

  const S = _temp20.stringValue();

  let _temp21 = IsRegExp(searchString);

  if (_temp21 instanceof AbruptCompletion) {
    return _temp21;
  }

  if (_temp21 instanceof Completion) {
    _temp21 = _temp21.Value;
  }

  const isRegExp = _temp21;

  if (isRegExp === Value.true) {
    return surroundingAgent.Throw('TypeError', 'RegExpArgumentNotAllowed', 'String.prototype.includes');
  }

  let _temp22 = ToString(searchString);

  if (_temp22 instanceof AbruptCompletion) {
    return _temp22;
  }

  if (_temp22 instanceof Completion) {
    _temp22 = _temp22.Value;
  }

  const searchStr = _temp22.stringValue();

  let _temp23 = ToInteger(position);

  if (_temp23 instanceof AbruptCompletion) {
    return _temp23;
  }

  if (_temp23 instanceof Completion) {
    _temp23 = _temp23.Value;
  }

  const pos = _temp23;
  Assert(!(position === Value.undefined) || pos.numberValue() === 0, "!(position === Value.undefined) || pos.numberValue() === 0");
  const len = S.length;
  const start = Math.min(Math.max(pos.numberValue(), 0), len);
  const searchLen = searchStr.length;
  let k = start;

  while (k + searchLen <= len) {
    let match = true;

    for (let j = 0; j < searchLen; j += 1) {
      if (searchStr[j] !== S[k + j]) {
        match = false;
        break;
      }
    }

    if (match) {
      return Value.true;
    }

    k += 1;
  }

  return Value.false;
} // 21.1.3.8 #sec-string.prototype.indexof


function StringProto_indexOf([searchString = Value.undefined, position = Value.undefined], {
  thisValue
}) {
  let _temp24 = RequireObjectCoercible(thisValue);

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }

  const O = _temp24;

  let _temp25 = ToString(O);

  if (_temp25 instanceof AbruptCompletion) {
    return _temp25;
  }

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }

  const S = _temp25.stringValue();

  let _temp26 = ToString(searchString);

  if (_temp26 instanceof AbruptCompletion) {
    return _temp26;
  }

  if (_temp26 instanceof Completion) {
    _temp26 = _temp26.Value;
  }

  const searchStr = _temp26.stringValue();

  let _temp27 = ToInteger(position);

  if (_temp27 instanceof AbruptCompletion) {
    return _temp27;
  }

  if (_temp27 instanceof Completion) {
    _temp27 = _temp27.Value;
  }

  const pos = _temp27;
  Assert(!(position === Value.undefined) || pos.numberValue() === 0, "!(position === Value.undefined) || pos.numberValue() === 0");
  const len = S.length;
  const start = Math.min(Math.max(pos.numberValue(), 0), len);
  const searchLen = searchStr.length;
  let k = start;

  while (k + searchLen <= len) {
    let match = true;

    for (let j = 0; j < searchLen; j += 1) {
      if (searchStr[j] !== S[k + j]) {
        match = false;
        break;
      }
    }

    if (match) {
      return new Value(k);
    }

    k += 1;
  }

  return new Value(-1);
} // 21.1.3.9 #sec-string.prototype.lastindexof


function StringProto_lastIndexOf([searchString = Value.undefined, position = Value.undefined], {
  thisValue
}) {
  let _temp28 = RequireObjectCoercible(thisValue);

  if (_temp28 instanceof AbruptCompletion) {
    return _temp28;
  }

  if (_temp28 instanceof Completion) {
    _temp28 = _temp28.Value;
  }

  const O = _temp28;

  let _temp29 = ToString(O);

  if (_temp29 instanceof AbruptCompletion) {
    return _temp29;
  }

  if (_temp29 instanceof Completion) {
    _temp29 = _temp29.Value;
  }

  const S = _temp29.stringValue();

  let _temp30 = ToString(searchString);

  if (_temp30 instanceof AbruptCompletion) {
    return _temp30;
  }

  if (_temp30 instanceof Completion) {
    _temp30 = _temp30.Value;
  }

  const searchStr = _temp30.stringValue();

  let _temp31 = ToNumber(position);

  if (_temp31 instanceof AbruptCompletion) {
    return _temp31;
  }

  if (_temp31 instanceof Completion) {
    _temp31 = _temp31.Value;
  }

  const numPos = _temp31;
  Assert(!(position === Value.undefined) || numPos.isNaN(), "!(position === Value.undefined) || numPos.isNaN()");
  let pos;

  if (numPos.isNaN()) {
    pos = new Value(Infinity);
  } else {
    let _temp32 = ToInteger(numPos);

    Assert(!(_temp32 instanceof AbruptCompletion), "ToInteger(numPos)" + ' returned an abrupt completion');

    if (_temp32 instanceof Completion) {
      _temp32 = _temp32.Value;
    }

    pos = _temp32;
  }

  const len = S.length;
  const start = Math.min(Math.max(pos.numberValue(), 0), len);
  const searchLen = searchStr.length;
  let k = start;

  while (k >= 0) {
    if (k + searchLen <= len) {
      let match = true;

      for (let j = 0; j < searchLen; j += 1) {
        if (searchStr[j] !== S[k + j]) {
          match = false;
          break;
        }
      }

      if (match) {
        return new Value(k);
      }
    }

    k -= 1;
  }

  return new Value(-1);
} // 21.1.3.10 #sec-string.prototype.localecompare


function StringProto_localeCompare([that = Value.undefined], {
  thisValue
}) {
  let _temp33 = RequireObjectCoercible(thisValue);

  if (_temp33 instanceof AbruptCompletion) {
    return _temp33;
  }

  if (_temp33 instanceof Completion) {
    _temp33 = _temp33.Value;
  }

  const O = _temp33;

  let _temp34 = ToString(O);

  if (_temp34 instanceof AbruptCompletion) {
    return _temp34;
  }

  if (_temp34 instanceof Completion) {
    _temp34 = _temp34.Value;
  }

  const S = _temp34.stringValue();

  let _temp35 = ToString(that);

  if (_temp35 instanceof AbruptCompletion) {
    return _temp35;
  }

  if (_temp35 instanceof Completion) {
    _temp35 = _temp35.Value;
  }

  const That = _temp35.stringValue();

  if (S === That) {
    return new Value(0);
  } else if (S < That) {
    return new Value(-1);
  } else {
    return new Value(1);
  }
} // 21.1.3.11 #sec-string.prototype.match


function StringProto_match([regexp = Value.undefined], {
  thisValue
}) {
  let _temp36 = RequireObjectCoercible(thisValue);

  if (_temp36 instanceof AbruptCompletion) {
    return _temp36;
  }

  if (_temp36 instanceof Completion) {
    _temp36 = _temp36.Value;
  }

  const O = _temp36;

  if (regexp !== Value.undefined && regexp !== Value.null) {
    let _temp37 = GetMethod(regexp, wellKnownSymbols.match);

    if (_temp37 instanceof AbruptCompletion) {
      return _temp37;
    }

    if (_temp37 instanceof Completion) {
      _temp37 = _temp37.Value;
    }

    const matcher = _temp37;

    if (matcher !== Value.undefined) {
      return Call(matcher, regexp, [O]);
    }
  }

  let _temp38 = ToString(O);

  if (_temp38 instanceof AbruptCompletion) {
    return _temp38;
  }

  if (_temp38 instanceof Completion) {
    _temp38 = _temp38.Value;
  }

  const S = _temp38;

  let _temp39 = RegExpCreate(regexp, Value.undefined);

  if (_temp39 instanceof AbruptCompletion) {
    return _temp39;
  }

  if (_temp39 instanceof Completion) {
    _temp39 = _temp39.Value;
  }

  const rx = _temp39;
  return Invoke(rx, wellKnownSymbols.match, [S]);
} // 21.1.3.12 #sec-string.prototype.matchall


function StringProto_matchAll([regexp = Value.undefined], {
  thisValue
}) {
  let _temp40 = RequireObjectCoercible(thisValue);

  if (_temp40 instanceof AbruptCompletion) {
    return _temp40;
  }

  if (_temp40 instanceof Completion) {
    _temp40 = _temp40.Value;
  }

  const O = _temp40;

  if (regexp !== Value.undefined && regexp !== Value.null) {
    let _temp41 = GetMethod(regexp, wellKnownSymbols.matchAll);

    if (_temp41 instanceof AbruptCompletion) {
      return _temp41;
    }

    if (_temp41 instanceof Completion) {
      _temp41 = _temp41.Value;
    }

    const matcher = _temp41;

    if (matcher !== Value.undefined) {
      return Call(matcher, regexp, [O]);
    }
  }

  let _temp42 = ToString(O);

  if (_temp42 instanceof AbruptCompletion) {
    return _temp42;
  }

  if (_temp42 instanceof Completion) {
    _temp42 = _temp42.Value;
  }

  const S = _temp42;

  let _temp43 = RegExpCreate(regexp, new Value('g'));

  if (_temp43 instanceof AbruptCompletion) {
    return _temp43;
  }

  if (_temp43 instanceof Completion) {
    _temp43 = _temp43.Value;
  }

  const rx = _temp43;
  return Invoke(rx, wellKnownSymbols.matchAll, [S]);
} // 21.1.3.13 #sec-string.prototype.normalize


function StringProto_normalize([form = Value.undefined], {
  thisValue
}) {
  let _temp44 = RequireObjectCoercible(thisValue);

  if (_temp44 instanceof AbruptCompletion) {
    return _temp44;
  }

  if (_temp44 instanceof Completion) {
    _temp44 = _temp44.Value;
  }

  const O = _temp44;

  let _temp45 = ToString(O);

  if (_temp45 instanceof AbruptCompletion) {
    return _temp45;
  }

  if (_temp45 instanceof Completion) {
    _temp45 = _temp45.Value;
  }

  const S = _temp45;

  if (form === Value.undefined) {
    form = new Value('NFC');
  } else {
    let _temp46 = ToString(form);

    if (_temp46 instanceof AbruptCompletion) {
      return _temp46;
    }

    if (_temp46 instanceof Completion) {
      _temp46 = _temp46.Value;
    }

    form = _temp46;
  }

  const f = form.stringValue();

  if (!['NFC', 'NFD', 'NFKC', 'NFKD'].includes(f)) {
    return surroundingAgent.Throw('RangeError', 'NormalizeInvalidForm');
  }

  const ns = S.stringValue().normalize(f);
  return new Value(ns);
} // 21.1.3.14 #sec-string.prototype.padend


function StringProto_padEnd([maxLength = Value.undefined, fillString = Value.undefined], {
  thisValue
}) {
  let _temp47 = RequireObjectCoercible(thisValue);

  if (_temp47 instanceof AbruptCompletion) {
    return _temp47;
  }

  if (_temp47 instanceof Completion) {
    _temp47 = _temp47.Value;
  }

  const O = _temp47;
  return StringPad(O, maxLength, fillString, 'end');
} // 21.1.3.15 #sec-string.prototype.padstart


function StringProto_padStart([maxLength = Value.undefined, fillString = Value.undefined], {
  thisValue
}) {
  let _temp48 = RequireObjectCoercible(thisValue);

  if (_temp48 instanceof AbruptCompletion) {
    return _temp48;
  }

  if (_temp48 instanceof Completion) {
    _temp48 = _temp48.Value;
  }

  const O = _temp48;
  return StringPad(O, maxLength, fillString, 'start');
} // 21.1.3.16 #sec-string.prototype.repeat


function StringProto_repeat([count = Value.undefined], {
  thisValue
}) {
  let _temp49 = RequireObjectCoercible(thisValue);

  if (_temp49 instanceof AbruptCompletion) {
    return _temp49;
  }

  if (_temp49 instanceof Completion) {
    _temp49 = _temp49.Value;
  }

  const O = _temp49;

  let _temp50 = ToString(O);

  if (_temp50 instanceof AbruptCompletion) {
    return _temp50;
  }

  if (_temp50 instanceof Completion) {
    _temp50 = _temp50.Value;
  }

  const S = _temp50;

  let _temp51 = ToInteger(count);

  if (_temp51 instanceof AbruptCompletion) {
    return _temp51;
  }

  if (_temp51 instanceof Completion) {
    _temp51 = _temp51.Value;
  }

  const n = _temp51;

  if (n.numberValue() < 0) {
    return surroundingAgent.Throw('RangeError', 'StringRepeatCount', n);
  }

  if (n.isInfinity()) {
    return surroundingAgent.Throw('RangeError', 'StringRepeatCount', n);
  }

  if (n.numberValue() === 0) {
    return new Value('');
  }

  let T = '';

  for (let i = 0; i < n.numberValue(); i += 1) {
    T += S.stringValue();
  }

  return new Value(T);
} // 21.1.3.17 #sec-string.prototype.replace


function StringProto_replace([searchValue = Value.undefined, replaceValue = Value.undefined], {
  thisValue
}) {
  let _temp52 = RequireObjectCoercible(thisValue);

  if (_temp52 instanceof AbruptCompletion) {
    return _temp52;
  }

  if (_temp52 instanceof Completion) {
    _temp52 = _temp52.Value;
  }

  const O = _temp52;

  if (searchValue !== Value.undefined && searchValue !== Value.null) {
    let _temp53 = GetMethod(searchValue, wellKnownSymbols.replace);

    if (_temp53 instanceof AbruptCompletion) {
      return _temp53;
    }

    if (_temp53 instanceof Completion) {
      _temp53 = _temp53.Value;
    }

    const replacer = _temp53;

    if (replacer !== Value.undefined) {
      return Call(replacer, searchValue, [O, replaceValue]);
    }
  }

  let _temp54 = ToString(O);

  if (_temp54 instanceof AbruptCompletion) {
    return _temp54;
  }

  if (_temp54 instanceof Completion) {
    _temp54 = _temp54.Value;
  }

  const string = _temp54;

  let _temp55 = ToString(searchValue);

  if (_temp55 instanceof AbruptCompletion) {
    return _temp55;
  }

  if (_temp55 instanceof Completion) {
    _temp55 = _temp55.Value;
  }

  const searchString = _temp55;
  const functionalReplace = IsCallable(replaceValue);

  if (functionalReplace === Value.false) {
    let _temp56 = ToString(replaceValue);

    if (_temp56 instanceof AbruptCompletion) {
      return _temp56;
    }

    if (_temp56 instanceof Completion) {
      _temp56 = _temp56.Value;
    }

    replaceValue = _temp56;
  }

  const pos = new Value(string.stringValue().indexOf(searchString.stringValue()));
  const matched = searchString;

  if (pos.numberValue() === -1) {
    return string;
  }

  let replStr;

  if (functionalReplace === Value.true) {
    let _temp57 = Call(replaceValue, Value.undefined, [matched, pos, string]);

    if (_temp57 instanceof AbruptCompletion) {
      return _temp57;
    }

    if (_temp57 instanceof Completion) {
      _temp57 = _temp57.Value;
    }

    const replValue = _temp57;

    let _temp58 = ToString(replValue);

    if (_temp58 instanceof AbruptCompletion) {
      return _temp58;
    }

    if (_temp58 instanceof Completion) {
      _temp58 = _temp58.Value;
    }

    replStr = _temp58;
  } else {
    const captures = [];

    let _temp59 = GetSubstitution(matched, string, pos, captures, Value.undefined, replaceValue);

    Assert(!(_temp59 instanceof AbruptCompletion), "GetSubstitution(matched, string, pos, captures, Value.undefined, replaceValue)" + ' returned an abrupt completion');

    if (_temp59 instanceof Completion) {
      _temp59 = _temp59.Value;
    }

    replStr = _temp59;
  }

  const tailPos = pos.numberValue() + matched.stringValue().length;
  const newString = string.stringValue().slice(0, pos.numberValue()) + replStr.stringValue() + string.stringValue().slice(tailPos);
  return new Value(newString);
} // 21.1.3.19 #sec-string.prototype.slice


function StringProto_search([regexp = Value.undefined], {
  thisValue
}) {
  let _temp60 = RequireObjectCoercible(thisValue);

  if (_temp60 instanceof AbruptCompletion) {
    return _temp60;
  }

  if (_temp60 instanceof Completion) {
    _temp60 = _temp60.Value;
  }

  const O = _temp60;

  if (regexp !== Value.undefined && regexp !== Value.null) {
    let _temp61 = GetMethod(regexp, wellKnownSymbols.search);

    if (_temp61 instanceof AbruptCompletion) {
      return _temp61;
    }

    if (_temp61 instanceof Completion) {
      _temp61 = _temp61.Value;
    }

    const searcher = _temp61;

    if (searcher !== Value.undefined) {
      return Call(searcher, regexp, [O]);
    }
  }

  let _temp62 = ToString(O);

  if (_temp62 instanceof AbruptCompletion) {
    return _temp62;
  }

  if (_temp62 instanceof Completion) {
    _temp62 = _temp62.Value;
  }

  const string = _temp62;

  let _temp63 = RegExpCreate(regexp, Value.undefined);

  if (_temp63 instanceof AbruptCompletion) {
    return _temp63;
  }

  if (_temp63 instanceof Completion) {
    _temp63 = _temp63.Value;
  }

  const rx = _temp63;
  return Invoke(rx, wellKnownSymbols.search, [string]);
} // 21.1.3.19 #sec-string.prototype.slice


function StringProto_slice([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  let _temp64 = RequireObjectCoercible(thisValue);

  if (_temp64 instanceof AbruptCompletion) {
    return _temp64;
  }

  if (_temp64 instanceof Completion) {
    _temp64 = _temp64.Value;
  }

  const O = _temp64;

  let _temp65 = ToString(O);

  if (_temp65 instanceof AbruptCompletion) {
    return _temp65;
  }

  if (_temp65 instanceof Completion) {
    _temp65 = _temp65.Value;
  }

  const S = _temp65.stringValue();

  const len = S.length;

  let _temp66 = ToInteger(start);

  if (_temp66 instanceof AbruptCompletion) {
    return _temp66;
  }

  if (_temp66 instanceof Completion) {
    _temp66 = _temp66.Value;
  }

  const intStart = _temp66.numberValue();

  let intEnd;

  if (end === Value.undefined) {
    intEnd = len;
  } else {
    let _temp67 = ToInteger(end);

    if (_temp67 instanceof AbruptCompletion) {
      return _temp67;
    }

    if (_temp67 instanceof Completion) {
      _temp67 = _temp67.Value;
    }

    intEnd = _temp67.numberValue();
  }

  let from;

  if (intStart < 0) {
    from = Math.max(len + intStart, 0);
  } else {
    from = Math.min(intStart, len);
  }

  let to;

  if (intEnd < 0) {
    to = Math.max(len + intEnd, 0);
  } else {
    to = Math.min(intEnd, len);
  }

  const span = Math.max(to - from, 0);
  return new Value(S.slice(from, from + span));
} // 21.1.3.20 #sec-string.prototype.split


function StringProto_split([separator = Value.undefined, limit = Value.undefined], {
  thisValue
}) {
  let _temp68 = RequireObjectCoercible(thisValue);

  if (_temp68 instanceof AbruptCompletion) {
    return _temp68;
  }

  if (_temp68 instanceof Completion) {
    _temp68 = _temp68.Value;
  }

  const O = _temp68;

  if (separator !== Value.undefined && separator !== Value.null) {
    let _temp69 = GetMethod(separator, wellKnownSymbols.split);

    if (_temp69 instanceof AbruptCompletion) {
      return _temp69;
    }

    if (_temp69 instanceof Completion) {
      _temp69 = _temp69.Value;
    }

    const splitter = _temp69;

    if (splitter !== Value.undefined) {
      return Call(splitter, separator, [O, limit]);
    }
  }

  let _temp70 = ToString(O);

  if (_temp70 instanceof AbruptCompletion) {
    return _temp70;
  }

  if (_temp70 instanceof Completion) {
    _temp70 = _temp70.Value;
  }

  const S = _temp70;

  let _temp71 = ArrayCreate(new Value(0));

  Assert(!(_temp71 instanceof AbruptCompletion), "ArrayCreate(new Value(0))" + ' returned an abrupt completion');

  if (_temp71 instanceof Completion) {
    _temp71 = _temp71.Value;
  }

  const A = _temp71;
  let lengthA = 0;
  let lim;

  if (limit === Value.undefined) {
    lim = new Value(2 ** 32 - 1);
  } else {
    let _temp72 = ToUint32(limit);

    if (_temp72 instanceof AbruptCompletion) {
      return _temp72;
    }

    if (_temp72 instanceof Completion) {
      _temp72 = _temp72.Value;
    }

    lim = _temp72;
  }

  const s = S.stringValue().length;
  let p = 0;

  let _temp73 = ToString(separator);

  if (_temp73 instanceof AbruptCompletion) {
    return _temp73;
  }

  if (_temp73 instanceof Completion) {
    _temp73 = _temp73.Value;
  }

  const R = _temp73;

  if (lim.numberValue() === 0) {
    return A;
  }

  if (separator === Value.undefined) {
    let _temp74 = CreateDataProperty(A, new Value('0'), S);

    Assert(!(_temp74 instanceof AbruptCompletion), "CreateDataProperty(A, new Value('0'), S)" + ' returned an abrupt completion');

    if (_temp74 instanceof Completion) {
      _temp74 = _temp74.Value;
    }
    return A;
  }

  if (s === 0) {
    const z = SplitMatch(S, 0, R);

    if (z !== false) {
      return A;
    }

    let _temp75 = CreateDataProperty(A, new Value('0'), S);

    Assert(!(_temp75 instanceof AbruptCompletion), "CreateDataProperty(A, new Value('0'), S)" + ' returned an abrupt completion');

    if (_temp75 instanceof Completion) {
      _temp75 = _temp75.Value;
    }
    return A;
  }

  let q = p;

  while (q !== s) {
    const e = SplitMatch(S, q, R);

    if (e === false) {
      q += 1;
    } else {
      if (e === p) {
        q += 1;
      } else {
        const T = new Value(S.stringValue().substring(p, q));

        let _temp77 = ToString(new Value(lengthA));

        Assert(!(_temp77 instanceof AbruptCompletion), "ToString(new Value(lengthA))" + ' returned an abrupt completion');

        if (_temp77 instanceof Completion) {
          _temp77 = _temp77.Value;
        }

        let _temp76 = CreateDataProperty(A, _temp77, T);

        Assert(!(_temp76 instanceof AbruptCompletion), "CreateDataProperty(A, X(ToString(new Value(lengthA))), T)" + ' returned an abrupt completion');

        if (_temp76 instanceof Completion) {
          _temp76 = _temp76.Value;
        }
        lengthA += 1;

        if (lengthA === lim.numberValue()) {
          return A;
        }

        p = e;
        q = p;
      }
    }
  }

  const T = new Value(S.stringValue().substring(p, s));

  let _temp79 = ToString(new Value(lengthA));

  Assert(!(_temp79 instanceof AbruptCompletion), "ToString(new Value(lengthA))" + ' returned an abrupt completion');

  if (_temp79 instanceof Completion) {
    _temp79 = _temp79.Value;
  }

  let _temp78 = CreateDataProperty(A, _temp79, T);

  Assert(!(_temp78 instanceof AbruptCompletion), "CreateDataProperty(A, X(ToString(new Value(lengthA))), T)" + ' returned an abrupt completion');

  if (_temp78 instanceof Completion) {
    _temp78 = _temp78.Value;
  }
  return A;
} // 21.1.3.20.1 #sec-splitmatch


function SplitMatch(S, q, R) {
  Assert(Type(R) === 'String', "Type(R) === 'String'");
  const r = R.stringValue().length;
  const s = S.stringValue().length;

  if (q + r > s) {
    return false;
  }

  for (let i = 0; i < r; i += 1) {
    if (S.stringValue().charCodeAt(q + i) !== R.stringValue().charCodeAt(i)) {
      return false;
    }
  }

  return q + r;
} // 21.1.3.21 #sec-string.prototype.startswith


function StringProto_startsWith([searchString = Value.undefined, position = Value.undefined], {
  thisValue
}) {
  let _temp80 = RequireObjectCoercible(thisValue);

  if (_temp80 instanceof AbruptCompletion) {
    return _temp80;
  }

  if (_temp80 instanceof Completion) {
    _temp80 = _temp80.Value;
  }

  const O = _temp80;

  let _temp81 = ToString(O);

  if (_temp81 instanceof AbruptCompletion) {
    return _temp81;
  }

  if (_temp81 instanceof Completion) {
    _temp81 = _temp81.Value;
  }

  const S = _temp81.stringValue();

  let _temp82 = IsRegExp(searchString);

  if (_temp82 instanceof AbruptCompletion) {
    return _temp82;
  }

  if (_temp82 instanceof Completion) {
    _temp82 = _temp82.Value;
  }

  const isRegExp = _temp82;

  if (isRegExp === Value.true) {
    return surroundingAgent.Throw('TypeError', 'RegExpArgumentNotAllowed', 'String.prototype.startsWith');
  }

  let _temp83 = ToString(searchString);

  if (_temp83 instanceof AbruptCompletion) {
    return _temp83;
  }

  if (_temp83 instanceof Completion) {
    _temp83 = _temp83.Value;
  }

  const searchStr = _temp83.stringValue();

  let _temp84 = ToInteger(position);

  if (_temp84 instanceof AbruptCompletion) {
    return _temp84;
  }

  if (_temp84 instanceof Completion) {
    _temp84 = _temp84.Value;
  }

  const pos = _temp84.numberValue();

  Assert(!(position === Value.undefined) || pos === 0, "!(position === Value.undefined) || pos === 0");
  const len = S.length;
  const start = Math.min(Math.max(pos, 0), len);
  const searchLength = searchStr.length;

  if (searchLength + start > len) {
    return Value.false;
  }

  for (let i = 0; i < searchLength; i += 1) {
    if (S.charCodeAt(start + i) !== searchStr.charCodeAt(i)) {
      return Value.false;
    }
  }

  return Value.true;
} // 21.1.3.22 #sec-string.prototype.substring


function StringProto_substring([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  let _temp85 = RequireObjectCoercible(thisValue);

  if (_temp85 instanceof AbruptCompletion) {
    return _temp85;
  }

  if (_temp85 instanceof Completion) {
    _temp85 = _temp85.Value;
  }

  const O = _temp85;

  let _temp86 = ToString(O);

  if (_temp86 instanceof AbruptCompletion) {
    return _temp86;
  }

  if (_temp86 instanceof Completion) {
    _temp86 = _temp86.Value;
  }

  const S = _temp86.stringValue();

  const len = S.length;

  let _temp87 = ToInteger(start);

  if (_temp87 instanceof AbruptCompletion) {
    return _temp87;
  }

  if (_temp87 instanceof Completion) {
    _temp87 = _temp87.Value;
  }

  const intStart = _temp87.numberValue();

  let intEnd;

  if (end === Value.undefined) {
    intEnd = len;
  } else {
    let _temp88 = ToInteger(end);

    if (_temp88 instanceof AbruptCompletion) {
      return _temp88;
    }

    if (_temp88 instanceof Completion) {
      _temp88 = _temp88.Value;
    }

    intEnd = _temp88.numberValue();
  }

  const finalStart = Math.min(Math.max(intStart, 0), len);
  const finalEnd = Math.min(Math.max(intEnd, 0), len);
  const from = Math.min(finalStart, finalEnd);
  const to = Math.max(finalStart, finalEnd);
  return new Value(S.slice(from, to));
} // 21.1.3.23 #sec-string.prototype.tolocalelowercase


function StringProto_toLocaleLowerCase(args, {
  thisValue
}) {
  let _temp89 = RequireObjectCoercible(thisValue);

  if (_temp89 instanceof AbruptCompletion) {
    return _temp89;
  }

  if (_temp89 instanceof Completion) {
    _temp89 = _temp89.Value;
  }

  const O = _temp89;

  let _temp90 = ToString(O);

  if (_temp90 instanceof AbruptCompletion) {
    return _temp90;
  }

  if (_temp90 instanceof Completion) {
    _temp90 = _temp90.Value;
  }

  const S = _temp90;
  const L = S.stringValue().toLocaleLowerCase();
  return new Value(L);
} // 21.1.3.24 #sec-string.prototype.tolocaleuppercase


function StringProto_toLocaleUpperCase(args, {
  thisValue
}) {
  let _temp91 = RequireObjectCoercible(thisValue);

  if (_temp91 instanceof AbruptCompletion) {
    return _temp91;
  }

  if (_temp91 instanceof Completion) {
    _temp91 = _temp91.Value;
  }

  const O = _temp91;

  let _temp92 = ToString(O);

  if (_temp92 instanceof AbruptCompletion) {
    return _temp92;
  }

  if (_temp92 instanceof Completion) {
    _temp92 = _temp92.Value;
  }

  const S = _temp92;
  const L = S.stringValue().toLocaleUpperCase();
  return new Value(L);
} // 21.1.3.25 #sec-string.prototype.tolowercase


function StringProto_toLowerCase(args, {
  thisValue
}) {
  let _temp93 = RequireObjectCoercible(thisValue);

  if (_temp93 instanceof AbruptCompletion) {
    return _temp93;
  }

  if (_temp93 instanceof Completion) {
    _temp93 = _temp93.Value;
  }

  const O = _temp93;

  let _temp94 = ToString(O);

  if (_temp94 instanceof AbruptCompletion) {
    return _temp94;
  }

  if (_temp94 instanceof Completion) {
    _temp94 = _temp94.Value;
  }

  const S = _temp94;
  const L = S.stringValue().toLowerCase();
  return new Value(L);
} // 21.1.3.26 #sec-string.prototype.tostring


function StringProto_toString(args, {
  thisValue
}) {
  return thisStringValue(thisValue);
} // 21.1.3.27 #sec-string.prototype.touppercase


function StringProto_toUpperCase(args, {
  thisValue
}) {
  let _temp95 = RequireObjectCoercible(thisValue);

  if (_temp95 instanceof AbruptCompletion) {
    return _temp95;
  }

  if (_temp95 instanceof Completion) {
    _temp95 = _temp95.Value;
  }

  const O = _temp95;

  let _temp96 = ToString(O);

  if (_temp96 instanceof AbruptCompletion) {
    return _temp96;
  }

  if (_temp96 instanceof Completion) {
    _temp96 = _temp96.Value;
  }

  const S = _temp96;
  const L = S.stringValue().toUpperCase();
  return new Value(L);
} // 21.1.3.28 #sec-string.prototype.trim


function StringProto_trim(args, {
  thisValue
}) {
  const S = thisValue;
  return TrimString(S, 'start+end');
} // 21.1.3.29 #sec-string.prototype.trimend


function StringProto_trimEnd(args, {
  thisValue
}) {
  const S = thisValue;
  return TrimString(S, 'end');
} // 21.1.3.30 #sec-string.prototype.trimstart


function StringProto_trimStart(args, {
  thisValue
}) {
  const S = thisValue;
  return TrimString(S, 'start');
} // 21.1.3.31 #sec-string.prototype.valueof


function StringProto_valueOf(args, {
  thisValue
}) {
  return thisStringValue(thisValue);
} // 21.1.3.32 #sec-string.prototype-@@iterator


function StringProto_iterator(args, {
  thisValue
}) {
  let _temp97 = RequireObjectCoercible(thisValue);

  if (_temp97 instanceof AbruptCompletion) {
    return _temp97;
  }

  if (_temp97 instanceof Completion) {
    _temp97 = _temp97.Value;
  }

  const O = _temp97;

  let _temp98 = ToString(O);

  if (_temp98 instanceof AbruptCompletion) {
    return _temp98;
  }

  if (_temp98 instanceof Completion) {
    _temp98 = _temp98.Value;
  }

  const S = _temp98;
  return CreateStringIterator(S);
}

function CreateStringPrototype(realmRec) {
  const proto = new StringExoticObjectValue();
  proto.Prototype = realmRec.Intrinsics['%Object.prototype%'];
  proto.Extensible = Value.true;
  proto.StringData = new Value('');
  proto.properties.set(new Value('length'), Descriptor({
    Value: new Value(0),
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  assignProps(realmRec, proto, [['charAt', StringProto_charAt, 1], ['charCodeAt', StringProto_charCodeAt, 1], ['codePointAt', StringProto_codePointAt, 1], ['concat', StringProto_concat, 1], ['endsWith', StringProto_endsWith, 1], ['includes', StringProto_includes, 1], ['indexOf', StringProto_indexOf, 1], ['lastIndexOf', StringProto_lastIndexOf, 1], ['localeCompare', StringProto_localeCompare, 1], ['match', StringProto_match, 1], ['matchAll', StringProto_matchAll, 1], ['normalize', StringProto_normalize, 0], ['padEnd', StringProto_padEnd, 1], ['padStart', StringProto_padStart, 1], ['repeat', StringProto_repeat, 1], ['replace', StringProto_replace, 2], ['search', StringProto_search, 1], ['slice', StringProto_slice, 2], ['split', StringProto_split, 2], ['startsWith', StringProto_startsWith, 1], ['substring', StringProto_substring, 2], ['toLocaleLowerCase', StringProto_toLocaleLowerCase, 0], ['toLocaleUpperCase', StringProto_toLocaleUpperCase, 0], ['toLowerCase', StringProto_toLowerCase, 0], ['toString', StringProto_toString, 0], ['toUpperCase', StringProto_toUpperCase, 0], ['trim', StringProto_trim, 0], ['trimEnd', StringProto_trimEnd, 0], ['trimStart', StringProto_trimStart, 0], ['valueOf', StringProto_valueOf, 0], [wellKnownSymbols.iterator, StringProto_iterator, 0]]);
  realmRec.Intrinsics['%String.prototype%'] = proto;
}

function StringConstructor([value], {
  NewTarget
}) {
  let s;

  if (value === undefined) {
    s = new Value('');
  } else {
    if (NewTarget === Value.undefined && Type(value) === 'Symbol') {
      let _temp = SymbolDescriptiveString(value);

      Assert(!(_temp instanceof AbruptCompletion), "SymbolDescriptiveString(value)" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      return _temp;
    }

    let _temp2 = ToString(value);
    /* istanbul ignore if */


    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }
    /* istanbul ignore if */


    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    s = _temp2;
  }

  if (NewTarget === Value.undefined) {
    return s;
  }

  let _temp4 = GetPrototypeFromConstructor(NewTarget, '%String.prototype%');

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  let _temp3 = StringCreate(s, _temp4);

  Assert(!(_temp3 instanceof AbruptCompletion), "StringCreate(s, Q(GetPrototypeFromConstructor(NewTarget, '%String.prototype%')))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  return _temp3;
} // 21.1.2.1 #sec-string.fromcharcode


function String_fromCharCode(codeUnits) {
  const length = codeUnits.length;
  const elements = [];
  let nextIndex = 0;

  while (nextIndex < length) {
    const next = codeUnits[nextIndex];

    let _temp5 = ToUint16(next);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const nextCU = _temp5;
    elements.push(nextCU);
    nextIndex += 1;
  }

  const result = elements.reduce((previous, current) => previous + String.fromCharCode(current.numberValue()), '');
  return new Value(result);
} // 21.1.2.2 #sec-string.fromcodepoint


function String_fromCodePoint(codePoints) {
  const length = codePoints.length;
  const elements = [];
  let nextIndex = 0;

  while (nextIndex < length) {
    const next = codePoints[nextIndex];

    let _temp6 = ToNumber(next);

    if (_temp6 instanceof AbruptCompletion) {
      return _temp6;
    }

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }

    const nextCP = _temp6;

    let _temp7 = IsInteger(nextCP);

    Assert(!(_temp7 instanceof AbruptCompletion), "IsInteger(nextCP)" + ' returned an abrupt completion');

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    if (_temp7 === Value.false) {
      return surroundingAgent.Throw('RangeError', 'StringCodePointInvalid', next);
    }

    if (nextCP.numberValue() < 0 || nextCP.numberValue() > 0x10FFFF) {
      return surroundingAgent.Throw('RangeError', 'StringCodePointInvalid', nextCP);
    }

    elements.push(...UTF16Encoding(nextCP.numberValue()));
    nextIndex += 1;
  }

  const result = elements.reduce((previous, current) => previous + String.fromCharCode(current), '');
  return new Value(result);
} // 21.1.2.4 #sec-string.raw


function String_raw([template = Value.undefined, ...substitutions]) {
  const numberOfSubstitutions = substitutions.length;

  let _temp8 = ToObject(template);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const cooked = _temp8;

  let _temp15 = Get(cooked, new Value('raw'));

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }

  let _temp9 = ToObject(_temp15);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const raw = _temp9;

  let _temp10 = LengthOfArrayLike(raw);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const literalSegments = _temp10.numberValue();

  if (literalSegments <= 0) {
    return new Value('');
  } // Not sure why the spec uses a List, but this is really just a String.


  const stringElements = [];
  let nextIndex = 0;

  while (true) {
    let _temp11 = ToString(new Value(nextIndex));

    Assert(!(_temp11 instanceof AbruptCompletion), "ToString(new Value(nextIndex))" + ' returned an abrupt completion');

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    const nextKey = _temp11;

    let _temp14 = Get(raw, nextKey);

    if (_temp14 instanceof AbruptCompletion) {
      return _temp14;
    }

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }

    let _temp12 = ToString(_temp14);

    if (_temp12 instanceof AbruptCompletion) {
      return _temp12;
    }

    if (_temp12 instanceof Completion) {
      _temp12 = _temp12.Value;
    }

    const nextSeg = _temp12;
    stringElements.push(nextSeg.stringValue());

    if (nextIndex + 1 === literalSegments) {
      return new Value(stringElements.join(''));
    }

    let next;

    if (nextIndex < numberOfSubstitutions) {
      next = substitutions[nextIndex];
    } else {
      next = new Value('');
    }

    let _temp13 = ToString(next);

    if (_temp13 instanceof AbruptCompletion) {
      return _temp13;
    }

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }

    const nextSub = _temp13;
    stringElements.push(nextSub.stringValue());
    nextIndex += 1;
  }
}

function CreateString(realmRec) {
  const stringConstructor = BootstrapConstructor(realmRec, StringConstructor, 'String', 1, realmRec.Intrinsics['%String.prototype%'], [['fromCharCode', String_fromCharCode, 1], ['fromCodePoint', String_fromCodePoint, 1], ['raw', String_raw, 1]]);
  realmRec.Intrinsics['%String%'] = stringConstructor;
}

function ErrorProto_toString(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }

  let _temp = Get(O, new Value('name'));
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let name = _temp;

  if (Type(name) === 'Undefined') {
    name = new Value('Error');
  } else {
    let _temp2 = ToString(name);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    name = _temp2;
  }

  let _temp3 = Get(O, new Value('message'));

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  let msg = _temp3;

  if (Type(msg) === 'Undefined') {
    msg = new Value('');
  } else {
    let _temp4 = ToString(msg);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    msg = _temp4;
  }

  if (name.stringValue() === '') {
    return msg;
  }

  if (msg.stringValue() === '') {
    return name;
  }

  return new Value(`${name.stringValue()}: ${msg.stringValue()}`);
}

function CreateErrorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['toString', ErrorProto_toString, 0], ['message', new Value('')], ['name', new Value('Error')]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Error.prototype%'] = proto;
}

function ErrorConstructor([message = Value.undefined], {
  NewTarget
}) {
  let newTarget;

  if (Type(NewTarget) === 'Undefined') {
    newTarget = surroundingAgent.activeFunctionObject;
  } else {
    newTarget = NewTarget;
  }

  let _temp = OrdinaryCreateFromConstructor(newTarget, '%Error.prototype%', ['ErrorData']);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const O = _temp;

  if (Type(message) !== 'Undefined') {
    let _temp2 = ToString(message);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const msg = _temp2;
    const msgDesc = Descriptor({
      Value: msg,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    });

    let _temp3 = DefinePropertyOrThrow(O, new Value('message'), msgDesc);

    Assert(!(_temp3 instanceof AbruptCompletion), "DefinePropertyOrThrow(O, new Value('message'), msgDesc)" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }
  }

  let _temp4 = captureStack(O);

  Assert(!(_temp4 instanceof AbruptCompletion), "captureStack(O)" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  return O;
}

function CreateError(realmRec) {
  const error = BootstrapConstructor(realmRec, ErrorConstructor, 'Error', 1, realmRec.Intrinsics['%Error.prototype%'], []);
  realmRec.Intrinsics['%Error%'] = error;
}

function CreateNativeError(realmRec) {
  for (const name of ['EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError']) {
    const proto = BootstrapPrototype(realmRec, [['name', new Value(name)], ['message', new Value('')]], realmRec.Intrinsics['%Error.prototype%']);

    const Constructor = ([message = Value.undefined], {
      NewTarget
    }) => {
      let newTarget;

      if (Type(NewTarget) === 'Undefined') {
        newTarget = surroundingAgent.activeFunctionObject;
      } else {
        newTarget = NewTarget;
      }

      let _temp = OrdinaryCreateFromConstructor(newTarget, `%${name}.prototype%`, ['ErrorData']);
      /* istanbul ignore if */


      if (_temp instanceof AbruptCompletion) {
        return _temp;
      }
      /* istanbul ignore if */


      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      const O = _temp;

      if (Type(message) !== 'Undefined') {
        let _temp2 = ToString(message);

        if (_temp2 instanceof AbruptCompletion) {
          return _temp2;
        }

        if (_temp2 instanceof Completion) {
          _temp2 = _temp2.Value;
        }

        const msg = _temp2;
        const msgDesc = Descriptor({
          Value: msg,
          Writable: Value.true,
          Enumerable: Value.false,
          Configurable: Value.true
        });

        let _temp3 = DefinePropertyOrThrow(O, new Value('message'), msgDesc);

        Assert(!(_temp3 instanceof AbruptCompletion), "DefinePropertyOrThrow(O, new Value('message'), msgDesc)" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp3 instanceof Completion) {
          _temp3 = _temp3.Value;
        }
      }

      let _temp4 = captureStack(O);

      Assert(!(_temp4 instanceof AbruptCompletion), "captureStack(O)" + ' returned an abrupt completion');

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      return O;
    };

    Object.defineProperty(Constructor, 'name', {
      value: `${name}Constructor`,
      configurable: true
    });
    const cons = BootstrapConstructor(realmRec, Constructor, name, 1, proto, []);
    cons.Prototype = realmRec.Intrinsics['%Error%'];
    realmRec.Intrinsics[`%${name}.prototype%`] = proto;
    realmRec.Intrinsics[`%${name}%`] = cons;
  }
}

function IteratorPrototype_iterator(args, {
  thisValue
}) {
  return thisValue;
}

function CreateIteratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [[wellKnownSymbols.iterator, IteratorPrototype_iterator, 0]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%IteratorPrototype%'] = proto;
}

function AsyncIteratorPrototype_asyncIterator(args, {
  thisValue
}) {
  return thisValue;
}

function CreateAsyncIteratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [[wellKnownSymbols.asyncIterator, AsyncIteratorPrototype_asyncIterator, 0]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%AsyncIteratorPrototype%'] = proto;
}

function ArrayIteratorPrototype_next(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Array Iterator', O);
  }

  if (!('IteratedArrayLike' in O) || !('ArrayLikeNextIndex' in O) || !('ArrayLikeIterationKind' in O)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Array Iterator', O);
  }

  const a = O.IteratedArrayLike;

  if (Type(a) === 'Undefined') {
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  const index = O.ArrayLikeNextIndex;
  const itemKind = O.ArrayLikeIterationKind;
  let len;

  if ('TypedArrayName' in a) {
    if (IsDetachedBuffer(a.ViewedArrayBuffer)) {
      return surroundingAgent.Throw('TypeError', 'BufferDetached');
    }

    len = a.ArrayLength;
  } else {
    let _temp = LengthOfArrayLike(a);
    /* istanbul ignore if */


    if (_temp instanceof AbruptCompletion) {
      return _temp;
    }
    /* istanbul ignore if */


    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    len = _temp;
  }

  if (index >= len.numberValue()) {
    O.IteratedArrayLike = Value.undefined;
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  O.ArrayLikeNextIndex = index + 1;

  if (itemKind === 'key') {
    return CreateIterResultObject(new Value(index), Value.false);
  }

  let _temp2 = ToString(new Value(index));

  Assert(!(_temp2 instanceof AbruptCompletion), "ToString(new Value(index))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const elementKey = _temp2;

  let _temp3 = Get(a, elementKey);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const elementValue = _temp3;
  let result;

  if (itemKind === 'value') {
    result = elementValue;
  } else {
    Assert(itemKind === 'key+value', "itemKind === 'key+value'");

    let _temp4 = CreateArrayFromList([new Value(index), elementValue]);

    Assert(!(_temp4 instanceof AbruptCompletion), "CreateArrayFromList([new Value(index), elementValue])" + ' returned an abrupt completion');

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    result = _temp4;
  }

  return CreateIterResultObject(result, Value.false);
}

function CreateArrayIteratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['next', ArrayIteratorPrototype_next, 0]], realmRec.Intrinsics['%IteratorPrototype%'], 'Array Iterator');
  realmRec.Intrinsics['%ArrayIterator.prototype%'] = proto;
}

function MapIteratorPrototype_next(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Map Iterator', O);
  }

  if (!('IteratedMap' in O && 'MapNextIndex' in O && 'MapIterationKind' in O)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Map Iterator', O);
  }

  const m = O.IteratedMap;
  let index = O.MapNextIndex;
  const itemKind = O.MapIterationKind;

  if (m === Value.undefined) {
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  Assert('MapData' in m, "'MapData' in m");
  const entries = m.MapData;
  const numEntries = entries.length;

  while (index < numEntries) {
    const e = entries[index];
    index += 1;
    O.MapNextIndex = index;

    if (e.Key !== undefined) {
      let result;

      if (itemKind === 'key') {
        result = e.Key;
      } else if (itemKind === 'value') {
        result = e.Value;
      } else {
        Assert(itemKind === 'key+value', "itemKind === 'key+value'");

        let _temp = CreateArrayFromList([e.Key, e.Value]);

        Assert(!(_temp instanceof AbruptCompletion), "CreateArrayFromList([e.Key, e.Value])" + ' returned an abrupt completion');
        /* istanbul ignore if */

        if (_temp instanceof Completion) {
          _temp = _temp.Value;
        }

        result = _temp;
      }

      return CreateIterResultObject(result, Value.false);
    }
  }

  O.IteratedMap = Value.undefined;
  return CreateIterResultObject(Value.undefined, Value.true);
}

function CreateMapIteratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['next', MapIteratorPrototype_next, 0]], realmRec.Intrinsics['%IteratorPrototype%'], 'Map Iterator');
  realmRec.Intrinsics['%MapIteratorPrototype%'] = proto;
}

function SetIteratorPrototype_next(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object') {
    return surroundingAgent.Throw('TypeError', 'InvalidReceiver', 'Set Iterator.prototype.next', O);
  }

  if (!('IteratedSet' in O && 'SetNextIndex' in O && 'SetIterationKind' in O)) {
    return surroundingAgent.Throw('TypeError', 'InvalidReceiver', 'Set Iterator.prototype.next', O);
  }

  const s = O.IteratedSet;
  let index = O.SetNextIndex;
  const itemKind = O.SetIterationKind;

  if (Type(s) === 'Undefined') {
    return CreateIterResultObject(Value.undefined, Value.true);
  }

  Assert('SetData' in s, "'SetData' in s");
  const entries = s.SetData;
  const numEntries = entries.length;

  while (index < numEntries) {
    const e = entries[index];
    index += 1;
    O.SetNextIndex = index;

    if (e !== undefined) {
      if (itemKind === 'key+value') {
        return CreateIterResultObject(CreateArrayFromList([e, e]), Value.false);
      }

      return CreateIterResultObject(e, Value.false);
    }
  }

  O.IteratedSet = Value.undefined;
  return CreateIterResultObject(Value.undefined, Value.true);
}

function CreateSetIteratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['next', SetIteratorPrototype_next, 0]], realmRec.Intrinsics['%IteratorPrototype%'], 'Set Iterator');
  realmRec.Intrinsics['%SetIteratorPrototype%'] = proto;
}

function CreateMapIterator(map, kind) {
  let _temp = RequireInternalSlot(map, 'MapData');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  const iterator = ObjectCreate(surroundingAgent.intrinsic('%MapIteratorPrototype%'), ['IteratedMap', 'MapNextIndex', 'MapIterationKind']);
  iterator.IteratedMap = map;
  iterator.MapNextIndex = 0;
  iterator.MapIterationKind = kind;
  return iterator;
}

function MapProto_clear(args, {
  thisValue
}) {
  const M = thisValue;

  let _temp2 = RequireInternalSlot(M, 'MapData');

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  const entries = M.MapData;

  for (const p of entries) {
    p.Key = undefined;
    p.Value = undefined;
  }

  return Value.undefined;
}

function MapProto_delete([key = Value.undefined], {
  thisValue
}) {
  const M = thisValue;

  let _temp3 = RequireInternalSlot(M, 'MapData');

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  const entries = M.MapData;

  for (let i = 0; i < entries.length; i += 1) {
    const p = entries[i];

    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      p.Key = undefined;
      p.Value = undefined; // The value empty is used as a specification device to indicate that an
      // entry has been deleted. Actual implementations may take other actions
      // such as physically removing the entry from internal data structures.
      // entries.splice(i, 1);

      return Value.true;
    }
  }

  return Value.false;
}

function MapProto_entries(args, {
  thisValue
}) {
  const M = thisValue;
  return CreateMapIterator(M, 'key+value');
}

function MapProto_forEach([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  const M = thisValue;

  let _temp4 = RequireInternalSlot(M, 'MapData');

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  if (IsCallable(callbackfn) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }

  const entries = M.MapData;

  for (const e of entries) {
    if (e.Key !== undefined) {
      let _temp5 = Call(callbackfn, thisArg, [e.Value, e.Key, M]);

      if (_temp5 instanceof AbruptCompletion) {
        return _temp5;
      }

      if (_temp5 instanceof Completion) {
        _temp5 = _temp5.Value;
      }
    }
  }

  return Value.undefined;
}

function MapProto_get([key = Value.undefined], {
  thisValue
}) {
  const M = thisValue;

  let _temp6 = RequireInternalSlot(M, 'MapData');

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }
  const entries = M.MapData;

  for (const p of entries) {
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      return p.Value;
    }
  }

  return Value.undefined;
}

function MapProto_has([key = Value.undefined], {
  thisValue
}) {
  const M = thisValue;

  let _temp7 = RequireInternalSlot(M, 'MapData');

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }
  const entries = M.MapData;

  for (const p of entries) {
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      return Value.true;
    }
  }

  return Value.false;
}

function MapProto_keys(args, {
  thisValue
}) {
  const M = thisValue;
  return CreateMapIterator(M, 'key');
}

function MapProto_set([key = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  const M = thisValue;

  let _temp8 = RequireInternalSlot(M, 'MapData');

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }
  const entries = M.MapData;

  for (const p of entries) {
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      p.Value = value;
      return M;
    }
  }

  if (Type(key) === 'Number' && Object.is(key.numberValue(), -0)) {
    key = new Value(0);
  }

  const p = {
    Key: key,
    Value: value
  };
  entries.push(p);
  return M;
}

function MapProto_sizeGetter(args, {
  thisValue
}) {
  const M = thisValue;

  let _temp9 = RequireInternalSlot(M, 'MapData');

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }
  const entries = M.MapData;
  let count = 0;

  for (const p of entries) {
    if (p.Key !== undefined) {
      count += 1;
    }
  }

  return new Value(count);
}

function MapProto_values(args, {
  thisValue
}) {
  const M = thisValue;
  return CreateMapIterator(M, 'value');
}

function CreateMapPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['clear', MapProto_clear, 0], ['delete', MapProto_delete, 1], ['entries', MapProto_entries, 0], ['forEach', MapProto_forEach, 1], ['get', MapProto_get, 1], ['has', MapProto_has, 1], ['keys', MapProto_keys, 0], ['set', MapProto_set, 2], ['size', [MapProto_sizeGetter]], ['values', MapProto_values, 0]], realmRec.Intrinsics['%Object.prototype%'], 'Map');

  let _temp10 = proto.GetOwnProperty(new Value('entries'));

  Assert(!(_temp10 instanceof AbruptCompletion), "proto.GetOwnProperty(new Value('entries'))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  const entriesFunc = _temp10;

  let _temp11 = proto.DefineOwnProperty(wellKnownSymbols.iterator, entriesFunc);

  Assert(!(_temp11 instanceof AbruptCompletion), "proto.DefineOwnProperty(wellKnownSymbols.iterator, entriesFunc)" + ' returned an abrupt completion');

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }
  realmRec.Intrinsics['%Map.prototype%'] = proto;
}

function CreateSetIterator(set, kind) {
  let _temp = RequireInternalSlot(set, 'SetData');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  const iterator = ObjectCreate(surroundingAgent.intrinsic('%SetIteratorPrototype%'), ['IteratedSet', 'SetNextIndex', 'SetIterationKind']);
  iterator.IteratedSet = set;
  iterator.SetNextIndex = 0;
  iterator.SetIterationKind = kind;
  return iterator;
}

function SetProto_add([value = Value.undefined], {
  thisValue
}) {
  const S = thisValue;

  let _temp2 = RequireInternalSlot(S, 'SetData');

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  const entries = S.SetData;

  for (const e of entries) {
    if (e !== undefined && SameValueZero(e, value) === Value.true) {
      return S;
    }
  }

  if (Type(value) === 'Number' && Object.is(value.numberValue(), -0)) {
    value = new Value(0);
  }

  entries.push(value);
  return S;
}

function SetProto_clear(args, {
  thisValue
}) {
  const S = thisValue;

  let _temp3 = RequireInternalSlot(S, 'SetData');

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  const entries = S.SetData;

  for (let i = 0; i < entries.length; i += 1) {
    entries[i] = undefined;
  }

  return Value.undefined;
}

function SetProto_delete([value = Value.undefined], {
  thisValue
}) {
  const S = thisValue;

  let _temp4 = RequireInternalSlot(S, 'SetData');

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  const entries = S.SetData;

  for (let i = 0; i < entries.length; i += 1) {
    const e = entries[i];

    if (e !== undefined && SameValueZero(e, value) === Value.true) {
      entries[i] = undefined;
      return Value.true;
    }
  }

  return Value.false;
}

function SetProto_entries(args, {
  thisValue
}) {
  const S = thisValue;
  return CreateSetIterator(S, 'key+value');
}

function SetProto_forEach([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  const S = thisValue;

  let _temp5 = RequireInternalSlot(S, 'SetData');

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  if (IsCallable(callbackfn) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }

  const entries = S.SetData;

  for (const e of entries) {
    if (e !== undefined) {
      let _temp6 = Call(callbackfn, thisArg, [e, e, S]);

      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }
    }
  }

  return Value.undefined;
}

function SetProto_has([value = Value.undefined], {
  thisValue
}) {
  const S = thisValue;

  let _temp7 = RequireInternalSlot(S, 'SetData');

  if (_temp7 instanceof AbruptCompletion) {
    return _temp7;
  }

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }
  const entries = S.SetData;

  for (const e of entries) {
    if (e !== undefined && SameValueZero(e, value) === Value.true) {
      return Value.true;
    }
  }

  return Value.false;
}

function SetProto_values(args, {
  thisValue
}) {
  const S = thisValue;
  return CreateSetIterator(S, 'value');
}

function SetProto_sizeGetter(args, {
  thisValue
}) {
  const S = thisValue;

  let _temp8 = RequireInternalSlot(S, 'SetData');

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }
  const entries = S.SetData;
  let count = 0;

  for (const e of entries) {
    if (e !== undefined) {
      count += 1;
    }
  }

  return new Value(count);
}

function CreateSetPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['add', SetProto_add, 1], ['clear', SetProto_clear, 0], ['delete', SetProto_delete, 1], ['entries', SetProto_entries, 0], ['forEach', SetProto_forEach, 1], ['has', SetProto_has, 1], ['size', [SetProto_sizeGetter]], ['values', SetProto_values, 0]], realmRec.Intrinsics['%Object.prototype%'], 'Set');

  let _temp9 = proto.GetOwnProperty(new Value('values'));

  Assert(!(_temp9 instanceof AbruptCompletion), "proto.GetOwnProperty(new Value('values'))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const valuesFunc = _temp9;

  let _temp10 = proto.DefineOwnProperty(new Value('keys'), valuesFunc);

  Assert(!(_temp10 instanceof AbruptCompletion), "proto.DefineOwnProperty(new Value('keys'), valuesFunc)" + ' returned an abrupt completion');

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  let _temp11 = proto.DefineOwnProperty(wellKnownSymbols.iterator, valuesFunc);

  Assert(!(_temp11 instanceof AbruptCompletion), "proto.DefineOwnProperty(wellKnownSymbols.iterator, valuesFunc)" + ' returned an abrupt completion');

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }
  realmRec.Intrinsics['%Set.prototype%'] = proto;
}

function SetConstructor([iterable = Value.undefined], {
  NewTarget
}) {
  if (NewTarget === Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', 'Set');
  }

  let _temp = OrdinaryCreateFromConstructor(NewTarget, '%Set.prototype%', ['SetData']);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const set = _temp;
  set.SetData = [];

  if (iterable === Value.undefined || iterable === Value.null) {
    return set;
  }

  let _temp2 = Get(set, new Value('add'));

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const adder = _temp2;

  if (IsCallable(adder) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', adder);
  }

  let _temp3 = GetIterator(iterable);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const iteratorRecord = _temp3;

  while (true) {
    let _temp4 = IteratorStep(iteratorRecord);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const next = _temp4;

    if (next === Value.false) {
      return set;
    }

    let _temp5 = IteratorValue(next);

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }

    const nextValue = _temp5;
    const status = Call(adder, set, [nextValue]);

    if (status instanceof AbruptCompletion) {
      return IteratorClose(iteratorRecord, status);
    }
  }
}

function Set_speciesGetter(args, {
  thisValue
}) {
  return thisValue;
}

function CreateSet(realmRec) {
  const setConstructor = BootstrapConstructor(realmRec, SetConstructor, 'Set', 0, realmRec.Intrinsics['%Set.prototype%'], [[wellKnownSymbols.species, [Set_speciesGetter]]]);
  realmRec.Intrinsics['%Set%'] = setConstructor;
}

function CreateGenerator(realmRec) {
  const generatorPrototype = realmRec.Intrinsics['%Generator.prototype%'];
  const generator = BootstrapPrototype(realmRec, [['prototype', generatorPrototype, undefined, {
    Writable: Value.false
  }]], realmRec.Intrinsics['%Function.prototype%'], 'GeneratorFunction');

  let _temp = DefinePropertyOrThrow(generatorPrototype, new Value('constructor'), Descriptor({
    Value: generator,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp instanceof AbruptCompletion), "DefinePropertyOrThrow(generatorPrototype, new Value('constructor'), Descriptor({\n    Value: generator,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  realmRec.Intrinsics['%Generator%'] = generator;
}

function GeneratorFunctionConstructor(args, {
  NewTarget
}) {
  const C = surroundingAgent.activeFunctionObject;
  return CreateDynamicFunction(C, NewTarget, 'generator', args);
}

function CreateGeneratorFunction(realmRec) {
  const generator = realmRec.Intrinsics['%Generator%'];
  const cons = BootstrapConstructor(realmRec, GeneratorFunctionConstructor, 'GeneratorFunction', 1, generator, []);

  let _temp = DefinePropertyOrThrow(cons, new Value('prototype'), Descriptor({
    Writable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp instanceof AbruptCompletion), "DefinePropertyOrThrow(cons, new Value('prototype'), Descriptor({\n    Writable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let _temp2 = DefinePropertyOrThrow(generator, new Value('constructor'), Descriptor({
    Writable: Value.false
  }));

  Assert(!(_temp2 instanceof AbruptCompletion), "DefinePropertyOrThrow(generator, new Value('constructor'), Descriptor({\n    Writable: Value.false,\n  }))" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  realmRec.Intrinsics['%GeneratorFunction%'] = cons;
}

function GeneratorProto_next([value = Value.undefined], {
  thisValue
}) {
  const g = thisValue;
  return GeneratorResume(g, value);
} // 25.4.1.3 #sec-generator.prototype.return


function GeneratorProto_return([value = Value.undefined], {
  thisValue
}) {
  const g = thisValue;
  const C = new ReturnCompletion(value);
  return GeneratorResumeAbrupt(g, C);
} // 25.4.1.4 #sec-generator.prototype.throw


function GeneratorProto_throw([exception = Value.undefined], {
  thisValue
}) {
  const g = thisValue;
  const C = new ThrowCompletion(exception);
  return GeneratorResumeAbrupt(g, C);
}

function CreateGeneratorPrototype(realmRec) {
  const generatorPrototype = BootstrapPrototype(realmRec, [['next', GeneratorProto_next, 1], ['return', GeneratorProto_return, 1], ['throw', GeneratorProto_throw, 1]], realmRec.Intrinsics['%IteratorPrototype%'], 'Generator');
  realmRec.Intrinsics['%Generator.prototype%'] = generatorPrototype;
}

function CreateAsyncFunctionPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [], realmRec.Intrinsics['%Function.prototype%'], 'AsyncFunction');
  realmRec.Intrinsics['%AsyncFunction.prototype%'] = proto;
}

function AsyncFunctionConstructor(args, {
  NewTarget
}) {
  const C = surroundingAgent.activeFunctionObject;
  return CreateDynamicFunction(C, NewTarget, 'async', args);
}

function CreateAsyncFunction(realmRec) {
  const cons = BootstrapConstructor(realmRec, AsyncFunctionConstructor, 'AsyncFunction', 1, realmRec.Intrinsics['%AsyncFunction.prototype%'], []);
  cons.DefineOwnProperty(new Value('prototype'), Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  cons.Prototype = realmRec.Intrinsics['%Function%'];
  realmRec.Intrinsics['%AsyncFunction%'] = cons;
}

function CreateAsyncGenerator(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['prototype', realmRec.Intrinsics['%AsyncGenerator.prototype%'], undefined, {
    Writable: Value.false
  }]], realmRec.Intrinsics['%Function.prototype%'], 'AsyncGeneratorFunction');

  let _temp = realmRec.Intrinsics['%AsyncGenerator.prototype%'].DefineOwnProperty(new Value('constructor'), Descriptor({
    Value: proto,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp instanceof AbruptCompletion), "realmRec.Intrinsics['%AsyncGenerator.prototype%'].DefineOwnProperty(new Value('constructor'), Descriptor({\n    Value: proto,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  realmRec.Intrinsics['%AsyncGeneratorFunction.prototype%'] = proto;
}

function AsyncGeneratorFunctionConstructor(args, {
  NewTarget
}) {
  const C = surroundingAgent.activeFunctionObject;
  return CreateDynamicFunction(C, NewTarget, 'async generator', args);
}

function CreateAsyncGeneratorFunction(realmRec) {
  const cons = BootstrapConstructor(realmRec, AsyncGeneratorFunctionConstructor, 'AsyncGeneratorFunction', 1, realmRec.Intrinsics['%AsyncGeneratorFunction.prototype%'], []);

  let _temp = cons.DefineOwnProperty(new Value('prototype'), Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));

  Assert(!(_temp instanceof AbruptCompletion), "cons.DefineOwnProperty(new Value('prototype'), Descriptor({\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  }))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let _temp2 = realmRec.Intrinsics['%AsyncGeneratorFunction.prototype%'].DefineOwnProperty(new Value('constructor'), Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp2 instanceof AbruptCompletion), "realmRec.Intrinsics['%AsyncGeneratorFunction.prototype%'].DefineOwnProperty(new Value('constructor'), Descriptor({\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  cons.Prototype = realmRec.Intrinsics['%Function%'];
  realmRec.Intrinsics['%AsyncGeneratorFunction%'] = cons;
}

function AsyncGeneratorPrototype_next([value = Value.undefined], {
  thisValue
}) {
  const generator = thisValue;
  const completion = new NormalCompletion(value);

  let _temp = AsyncGeneratorEnqueue(generator, completion);

  Assert(!(_temp instanceof AbruptCompletion), "AsyncGeneratorEnqueue(generator, completion)" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  return _temp;
}

function AsyncGeneratorPrototype_return([value = Value.undefined], {
  thisValue
}) {
  const generator = thisValue;
  const completion = new Completion('return', value, undefined);

  let _temp2 = AsyncGeneratorEnqueue(generator, completion);

  Assert(!(_temp2 instanceof AbruptCompletion), "AsyncGeneratorEnqueue(generator, completion)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  return _temp2;
}

function AsyncGeneratorPrototype_throw([exception = Value.undefined], {
  thisValue
}) {
  const generator = thisValue;
  const completion = new ThrowCompletion(exception);

  let _temp3 = AsyncGeneratorEnqueue(generator, completion);

  Assert(!(_temp3 instanceof AbruptCompletion), "AsyncGeneratorEnqueue(generator, completion)" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  return _temp3;
}

function CreateAsyncGeneratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['next', AsyncGeneratorPrototype_next, 1], ['return', AsyncGeneratorPrototype_return, 1], ['throw', AsyncGeneratorPrototype_throw, 1]], realmRec.Intrinsics['%AsyncIteratorPrototype%'], 'AsyncGenerator');
  realmRec.Intrinsics['%AsyncGenerator.prototype%'] = proto;
}

function AsyncFromSyncIteratorPrototype_next([value = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  Assert(Type(O) === 'Object' && 'SyncIteratorRecord' in O, "Type(O) === 'Object' && 'SyncIteratorRecord' in O");

  let _temp = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

  Assert(!(_temp instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const promiseCapability = _temp;
  const syncIteratorRecord = O.SyncIteratorRecord;
  let result = IteratorNext(syncIteratorRecord, value);

  /* istanbul ignore if */
  if (result instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }
  /* istanbul ignore if */


  if (result instanceof Completion) {
    result = result.Value;
  }

  let _temp2 = AsyncFromSyncIteratorContinuation(result, promiseCapability);

  Assert(!(_temp2 instanceof AbruptCompletion), "AsyncFromSyncIteratorContinuation(result, promiseCapability)" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  return _temp2;
} // 25.1.4.2.2 #sec-%asyncfromsynciteratorprototype%.return


function AsyncFromSyncIteratorPrototype_return([value = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  Assert(Type(O) === 'Object' && 'SyncIteratorRecord' in O, "Type(O) === 'Object' && 'SyncIteratorRecord' in O");

  let _temp3 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

  Assert(!(_temp3 instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const promiseCapability = _temp3;
  const syncIterator = O.SyncIteratorRecord.Iterator;
  let ret = GetMethod(syncIterator, new Value('return'));

  if (ret instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [ret.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }

  if (ret instanceof Completion) {
    ret = ret.Value;
  }

  if (ret === Value.undefined) {
    let _temp4 = CreateIterResultObject(value, Value.true);

    Assert(!(_temp4 instanceof AbruptCompletion), "CreateIterResultObject(value, Value.true)" + ' returned an abrupt completion');

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    const iterResult = _temp4;

    let _temp5 = Call(promiseCapability.Resolve, Value.undefined, [iterResult]);

    Assert(!(_temp5 instanceof AbruptCompletion), "Call(promiseCapability.Resolve, Value.undefined, [iterResult])" + ' returned an abrupt completion');

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }
    return promiseCapability.Promise;
  }

  let result = Call(ret, syncIterator, [value]);

  if (result instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }

  if (result instanceof Completion) {
    result = result.Value;
  }

  if (Type(result) !== 'Object') {
    let _temp6 = Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'NotAnObject', result).Value]);

    Assert(!(_temp6 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [\n      surroundingAgent.Throw('TypeError', 'NotAnObject', result).Value,\n    ])" + ' returned an abrupt completion');

    if (_temp6 instanceof Completion) {
      _temp6 = _temp6.Value;
    }
    return promiseCapability.Promise;
  }

  let _temp7 = AsyncFromSyncIteratorContinuation(result, promiseCapability);

  Assert(!(_temp7 instanceof AbruptCompletion), "AsyncFromSyncIteratorContinuation(result, promiseCapability)" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  return _temp7;
} // 25.1.4.2.3 #sec-%asyncfromsynciteratorprototype%.throw


function AsyncFromSyncIteratorPrototype_throw([value = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  Assert(Type(O) === 'Object' && 'SyncIteratorRecord' in O, "Type(O) === 'Object' && 'SyncIteratorRecord' in O");

  let _temp8 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));

  Assert(!(_temp8 instanceof AbruptCompletion), "NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'))" + ' returned an abrupt completion');

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const promiseCapability = _temp8;
  const syncIterator = O.SyncIteratorRecord.Iterator;
  let thr = GetMethod(syncIterator, new Value('throw'));

  if (thr instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [thr.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }

  if (thr instanceof Completion) {
    thr = thr.Value;
  }

  if (thr === Value.undefined) {
    let _temp9 = Call(promiseCapability.Reject, Value.undefined, [value]);

    Assert(!(_temp9 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [value])" + ' returned an abrupt completion');

    if (_temp9 instanceof Completion) {
      _temp9 = _temp9.Value;
    }
    return promiseCapability.Promise;
  }

  let result = Call(thr, syncIterator, [value]);

  if (result instanceof AbruptCompletion) {
    const hygenicTemp2 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);

    if (hygenicTemp2 instanceof AbruptCompletion) {
      return hygenicTemp2;
    }

    return promiseCapability.Promise;
  }

  if (result instanceof Completion) {
    result = result.Value;
  }

  if (Type(result) !== 'Object') {
    let _temp10 = Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'NotAnObject', result).Value]);

    Assert(!(_temp10 instanceof AbruptCompletion), "Call(promiseCapability.Reject, Value.undefined, [\n      surroundingAgent.Throw('TypeError', 'NotAnObject', result).Value,\n    ])" + ' returned an abrupt completion');

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }
    return promiseCapability.Promise;
  }

  let _temp11 = AsyncFromSyncIteratorContinuation(result, promiseCapability);

  Assert(!(_temp11 instanceof AbruptCompletion), "AsyncFromSyncIteratorContinuation(result, promiseCapability)" + ' returned an abrupt completion');

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  return _temp11;
}

function CreateAsyncFromSyncIteratorPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['next', AsyncFromSyncIteratorPrototype_next, 1], ['return', AsyncFromSyncIteratorPrototype_return, 1], ['throw', AsyncFromSyncIteratorPrototype_throw, 1]], realmRec.Intrinsics['%AsyncIteratorPrototype%']);
  realmRec.Intrinsics['%AsyncFromSyncIteratorPrototype%'] = proto;
}

function ArrayBufferConstructor([length = Value.undefined], {
  NewTarget
}) {
  if (Type(NewTarget) === 'Undefined') {
    return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', 'ArrayBuffer');
  }

  let _temp = ToIndex(length);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const byteLength = _temp;
  return AllocateArrayBuffer(NewTarget, byteLength);
} // 24.1.3.1 #sec-arraybuffer.isview


function ArrayBuffer_isView([arg = Value.undefined]) {
  if (Type(arg) !== 'Object') {
    return Value.false;
  }

  if ('ViewedArrayBuffer' in arg) {
    return Value.true;
  }

  return Value.false;
} // 24.1.3.3 #sec-get-arraybuffer-@@species


function ArrayBuffer_speciesGetter(a, {
  thisValue
}) {
  return thisValue;
}

function CreateArrayBuffer(realmRec) {
  const abConstructor = BootstrapConstructor(realmRec, ArrayBufferConstructor, 'ArrayBuffer', 1, realmRec.Intrinsics['%ArrayBuffer.prototype%'], [['isView', ArrayBuffer_isView, 1], [wellKnownSymbols.species, [ArrayBuffer_speciesGetter]]]);
  realmRec.Intrinsics['%ArrayBuffer%'] = abConstructor;
}

function ArrayBufferProto_byteLengthGetter(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp = RequireInternalSlot(O, 'ArrayBufferData');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  if (IsSharedArrayBuffer(O) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'ArrayBuffer', O);
  }

  if (IsDetachedBuffer(O)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const length = O.ArrayBufferByteLength;
  return length;
} // 24.1.4.3 #sec-arraybuffer.prototype.slice


function ArrayBufferProto_slice([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  const O = thisValue;

  let _temp2 = RequireInternalSlot(O, 'ArrayBufferData');

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  if (IsSharedArrayBuffer(O) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'ArrayBuffer', O);
  }

  if (IsDetachedBuffer(O)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const len = O.ArrayBufferByteLength.numberValue();

  let _temp3 = ToInteger(start);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  const relativeStart = _temp3.numberValue();

  let first;

  if (relativeStart < 0) {
    first = Math.max(len + relativeStart, 0);
  } else {
    first = Math.min(relativeStart, len);
  }

  let relativeEnd;

  if (Type(end) === 'Undefined') {
    relativeEnd = len;
  } else {
    let _temp4 = ToInteger(end);

    if (_temp4 instanceof AbruptCompletion) {
      return _temp4;
    }

    if (_temp4 instanceof Completion) {
      _temp4 = _temp4.Value;
    }

    relativeEnd = _temp4.numberValue();
  }

  let final;

  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }

  const newLen = Math.max(final - first, 0);

  let _temp5 = SpeciesConstructor(O, surroundingAgent.intrinsic('%ArrayBuffer%'));

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const ctor = _temp5;

  let _temp6 = Construct(ctor, [new Value(newLen)]);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const neww = _temp6;

  if (!('ArrayBufferData' in neww) || IsSharedArrayBuffer(neww) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'ArrayBuffer', neww);
  }

  if (IsDetachedBuffer(neww)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  if (SameValue(neww, O) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'SubclassSameValue', neww);
  }

  if (neww.ArrayBufferByteLength.numberValue() < newLen) {
    return surroundingAgent.Throw('TypeError', 'SubclassLengthTooSmall', neww);
  }

  if (IsDetachedBuffer(O)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const fromBuf = O.ArrayBufferData;
  const toBuf = neww.ArrayBufferData;
  CopyDataBlockBytes(toBuf, new Value(0), fromBuf, new Value(first), new Value(newLen));
  return neww;
}

function CreateArrayBufferPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['byteLength', [ArrayBufferProto_byteLengthGetter]], ['slice', ArrayBufferProto_slice, 2]], realmRec.Intrinsics['%Object.prototype%'], 'ArrayBuffer');
  realmRec.Intrinsics['%ArrayBuffer.prototype%'] = proto;
}

const WHITESPACE = [' ', '\t', '\r', '\n'];
const NUMERIC = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
const VALID_HEX = [...NUMERIC, 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'];
const ESCAPABLE = ['"', '\\', '/', 'b', 'f', 'n', 'r', 't'];

class JSONValidator {
  constructor(input) {
    this.input = input;
    this.pos = 0;
    this.char = input.charAt(0);
  }

  validate() {
    let _temp = this.eatWhitespace();

    Assert(!(_temp instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    let _temp2 = this.parseValue();
    /* istanbul ignore if */


    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }
    /* istanbul ignore if */


    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    if (this.pos < this.input.length) {
      return surroundingAgent.Throw('SyntaxError', 'JSONUnexpectedToken');
    }

    return new NormalCompletion(undefined);
  }

  advance() {
    this.pos += 1;

    if (this.pos === this.input.length) {
      this.char = null;
    } else if (this.pos > this.input.length) {
      return surroundingAgent.Throw('SyntaxError', 'JSONUnexpectedToken');
    } else {
      this.char = this.input.charAt(this.pos);
    }

    return this.char;
  }

  eatWhitespace() {
    while (this.eat(WHITESPACE));
  }

  eat(c) {
    if (Array.isArray(c) && c.includes(this.char)) {
      let _temp3 = this.advance();

      Assert(!(_temp3 instanceof AbruptCompletion), "this.advance()" + ' returned an abrupt completion');

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }
      return true;
    } else if (this.char === c) {
      let _temp4 = this.advance();

      Assert(!(_temp4 instanceof AbruptCompletion), "this.advance()" + ' returned an abrupt completion');

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }
      return true;
    }

    return false;
  }

  expect(c) {
    const {
      char
    } = this;

    if (!this.eat(c)) {
      return surroundingAgent.Throw('SyntaxError', 'JSONExpected', c, this.char);
    }

    return char;
  }

  parseValue() {
    switch (this.char) {
      case '"':
        return this.parseString();

      case '{':
        return this.parseObject();

      case '[':
        return this.parseArray();

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        return this.parseNumber();

      case 'f':
        let _temp5 = this.expect('f');

        Assert(!(_temp5 instanceof AbruptCompletion), "this.expect('f')" + ' returned an abrupt completion');

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }

        let _temp6 = this.expect('a');

        if (_temp6 instanceof AbruptCompletion) {
          return _temp6;
        }

        if (_temp6 instanceof Completion) {
          _temp6 = _temp6.Value;
        }

        let _temp7 = this.expect('l');

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        let _temp8 = this.expect('s');

        if (_temp8 instanceof AbruptCompletion) {
          return _temp8;
        }

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }

        let _temp9 = this.expect('e');

        if (_temp9 instanceof AbruptCompletion) {
          return _temp9;
        }

        if (_temp9 instanceof Completion) {
          _temp9 = _temp9.Value;
        }

        let _temp10 = this.eatWhitespace();

        Assert(!(_temp10 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

        if (_temp10 instanceof Completion) {
          _temp10 = _temp10.Value;
        }

        return _temp10;

      case 't':
        let _temp11 = this.expect('t');

        Assert(!(_temp11 instanceof AbruptCompletion), "this.expect('t')" + ' returned an abrupt completion');

        if (_temp11 instanceof Completion) {
          _temp11 = _temp11.Value;
        }

        let _temp12 = this.expect('r');

        if (_temp12 instanceof AbruptCompletion) {
          return _temp12;
        }

        if (_temp12 instanceof Completion) {
          _temp12 = _temp12.Value;
        }

        let _temp13 = this.expect('u');

        if (_temp13 instanceof AbruptCompletion) {
          return _temp13;
        }

        if (_temp13 instanceof Completion) {
          _temp13 = _temp13.Value;
        }

        let _temp14 = this.expect('e');

        if (_temp14 instanceof AbruptCompletion) {
          return _temp14;
        }

        if (_temp14 instanceof Completion) {
          _temp14 = _temp14.Value;
        }

        let _temp15 = this.eatWhitespace();

        Assert(!(_temp15 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

        if (_temp15 instanceof Completion) {
          _temp15 = _temp15.Value;
        }

        return _temp15;

      case 'n':
        let _temp16 = this.expect('n');

        Assert(!(_temp16 instanceof AbruptCompletion), "this.expect('n')" + ' returned an abrupt completion');

        if (_temp16 instanceof Completion) {
          _temp16 = _temp16.Value;
        }

        let _temp17 = this.expect('u');

        if (_temp17 instanceof AbruptCompletion) {
          return _temp17;
        }

        if (_temp17 instanceof Completion) {
          _temp17 = _temp17.Value;
        }

        let _temp18 = this.expect('l');

        if (_temp18 instanceof AbruptCompletion) {
          return _temp18;
        }

        if (_temp18 instanceof Completion) {
          _temp18 = _temp18.Value;
        }

        let _temp19 = this.expect('l');

        if (_temp19 instanceof AbruptCompletion) {
          return _temp19;
        }

        if (_temp19 instanceof Completion) {
          _temp19 = _temp19.Value;
        }

        let _temp20 = this.eatWhitespace();

        Assert(!(_temp20 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

        if (_temp20 instanceof Completion) {
          _temp20 = _temp20.Value;
        }

        return _temp20;

      default:
        return surroundingAgent.Throw('SyntaxError', 'JSONUnexpectedChar', this.char);
    }
  }

  parseString() {
    let _temp21 = this.expect('"');

    if (_temp21 instanceof AbruptCompletion) {
      return _temp21;
    }

    if (_temp21 instanceof Completion) {
      _temp21 = _temp21.Value;
    }

    while (!this.eat('"')) {
      if (this.eat('\\')) {
        if (!this.eat(ESCAPABLE)) {
          let _temp22 = this.expect('u');

          if (_temp22 instanceof AbruptCompletion) {
            return _temp22;
          }

          if (_temp22 instanceof Completion) {
            _temp22 = _temp22.Value;
          }

          let _temp23 = this.expect(VALID_HEX);

          if (_temp23 instanceof AbruptCompletion) {
            return _temp23;
          }

          if (_temp23 instanceof Completion) {
            _temp23 = _temp23.Value;
          }

          let _temp24 = this.expect(VALID_HEX);

          if (_temp24 instanceof AbruptCompletion) {
            return _temp24;
          }

          if (_temp24 instanceof Completion) {
            _temp24 = _temp24.Value;
          }

          let _temp25 = this.expect(VALID_HEX);

          if (_temp25 instanceof AbruptCompletion) {
            return _temp25;
          }

          if (_temp25 instanceof Completion) {
            _temp25 = _temp25.Value;
          }

          let _temp26 = this.expect(VALID_HEX);

          if (_temp26 instanceof AbruptCompletion) {
            return _temp26;
          }

          if (_temp26 instanceof Completion) {
            _temp26 = _temp26.Value;
          }
        }
      } else {
        if (this.char < ' ') {
          return surroundingAgent.Throw('SyntaxError', 'JSONUnexpectedChar', this.char);
        }

        let _temp27 = this.advance();

        if (_temp27 instanceof AbruptCompletion) {
          return _temp27;
        }

        if (_temp27 instanceof Completion) {
          _temp27 = _temp27.Value;
        }
      }
    }

    let _temp28 = this.eatWhitespace();

    Assert(!(_temp28 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

    if (_temp28 instanceof Completion) {
      _temp28 = _temp28.Value;
    }

    return _temp28;
  }

  parseNumber() {
    this.eat('-');

    if (!this.eat('0')) {
      let _temp29 = this.expect(NUMERIC);

      if (_temp29 instanceof AbruptCompletion) {
        return _temp29;
      }

      if (_temp29 instanceof Completion) {
        _temp29 = _temp29.Value;
      }

      while (this.eat(NUMERIC));
    }

    if (this.eat('.')) {
      let _temp30 = this.expect(NUMERIC);

      if (_temp30 instanceof AbruptCompletion) {
        return _temp30;
      }

      if (_temp30 instanceof Completion) {
        _temp30 = _temp30.Value;
      }

      while (this.eat(NUMERIC));
    }

    if (this.eat(['e', 'E'])) {
      this.eat(['-', '+']);

      let _temp31 = this.expect(NUMERIC);

      if (_temp31 instanceof AbruptCompletion) {
        return _temp31;
      }

      if (_temp31 instanceof Completion) {
        _temp31 = _temp31.Value;
      }

      while (this.eat(NUMERIC));
    }

    let _temp32 = this.eatWhitespace();

    Assert(!(_temp32 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

    if (_temp32 instanceof Completion) {
      _temp32 = _temp32.Value;
    }
  }

  parseObject() {
    let _temp33 = this.expect('{');

    if (_temp33 instanceof AbruptCompletion) {
      return _temp33;
    }

    if (_temp33 instanceof Completion) {
      _temp33 = _temp33.Value;
    }

    let _temp34 = this.eatWhitespace();

    Assert(!(_temp34 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

    if (_temp34 instanceof Completion) {
      _temp34 = _temp34.Value;
    }
    let first = true;

    while (!this.eat('}')) {
      if (first) {
        first = false;
      } else {
        let _temp35 = this.expect(',');

        if (_temp35 instanceof AbruptCompletion) {
          return _temp35;
        }

        if (_temp35 instanceof Completion) {
          _temp35 = _temp35.Value;
        }

        let _temp36 = this.eatWhitespace();

        Assert(!(_temp36 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

        if (_temp36 instanceof Completion) {
          _temp36 = _temp36.Value;
        }
      }

      let _temp37 = this.parseString();

      if (_temp37 instanceof AbruptCompletion) {
        return _temp37;
      }

      if (_temp37 instanceof Completion) {
        _temp37 = _temp37.Value;
      }

      let _temp38 = this.eatWhitespace();

      Assert(!(_temp38 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

      if (_temp38 instanceof Completion) {
        _temp38 = _temp38.Value;
      }

      let _temp39 = this.expect(':');

      if (_temp39 instanceof AbruptCompletion) {
        return _temp39;
      }

      if (_temp39 instanceof Completion) {
        _temp39 = _temp39.Value;
      }

      let _temp40 = this.eatWhitespace();

      Assert(!(_temp40 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

      if (_temp40 instanceof Completion) {
        _temp40 = _temp40.Value;
      }

      let _temp41 = this.parseValue();

      if (_temp41 instanceof AbruptCompletion) {
        return _temp41;
      }

      if (_temp41 instanceof Completion) {
        _temp41 = _temp41.Value;
      }

      let _temp42 = this.eatWhitespace();

      Assert(!(_temp42 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

      if (_temp42 instanceof Completion) {
        _temp42 = _temp42.Value;
      }
    }

    let _temp43 = this.eatWhitespace();

    Assert(!(_temp43 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

    if (_temp43 instanceof Completion) {
      _temp43 = _temp43.Value;
    }
  }

  parseArray() {
    let _temp44 = this.expect('[');

    if (_temp44 instanceof AbruptCompletion) {
      return _temp44;
    }

    if (_temp44 instanceof Completion) {
      _temp44 = _temp44.Value;
    }

    let _temp45 = this.eatWhitespace();

    Assert(!(_temp45 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

    if (_temp45 instanceof Completion) {
      _temp45 = _temp45.Value;
    }
    let first = true;

    while (!this.eat(']')) {
      if (first) {
        first = false;
      } else {
        let _temp46 = this.expect(',');

        if (_temp46 instanceof AbruptCompletion) {
          return _temp46;
        }

        if (_temp46 instanceof Completion) {
          _temp46 = _temp46.Value;
        }

        let _temp47 = this.eatWhitespace();

        Assert(!(_temp47 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

        if (_temp47 instanceof Completion) {
          _temp47 = _temp47.Value;
        }
      }

      let _temp48 = this.parseValue();

      if (_temp48 instanceof AbruptCompletion) {
        return _temp48;
      }

      if (_temp48 instanceof Completion) {
        _temp48 = _temp48.Value;
      }

      let _temp49 = this.eatWhitespace();

      Assert(!(_temp49 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

      if (_temp49 instanceof Completion) {
        _temp49 = _temp49.Value;
      }
    }

    let _temp50 = this.eatWhitespace();

    Assert(!(_temp50 instanceof AbruptCompletion), "this.eatWhitespace()" + ' returned an abrupt completion');

    if (_temp50 instanceof Completion) {
      _temp50 = _temp50.Value;
    }
  }

  static validate(input) {
    const v = new JSONValidator(input);
    return v.validate();
  }

}

function JSON_parse([text = Value.undefined, reviver = Value.undefined]) {
  function InternalizeJSONProperty(holder, name) {
    let _temp51 = Get(holder, name);

    if (_temp51 instanceof AbruptCompletion) {
      return _temp51;
    }

    if (_temp51 instanceof Completion) {
      _temp51 = _temp51.Value;
    }

    const val = _temp51;

    if (Type(val) === 'Object') {
      let _temp52 = IsArray(val);

      if (_temp52 instanceof AbruptCompletion) {
        return _temp52;
      }

      if (_temp52 instanceof Completion) {
        _temp52 = _temp52.Value;
      }

      const isArray = _temp52;

      if (isArray === Value.true) {
        let I = 0;

        let _temp53 = LengthOfArrayLike(val);

        if (_temp53 instanceof AbruptCompletion) {
          return _temp53;
        }

        if (_temp53 instanceof Completion) {
          _temp53 = _temp53.Value;
        }

        const len = _temp53.numberValue();

        while (I < len) {
          let _temp54 = ToString(new Value(I));

          Assert(!(_temp54 instanceof AbruptCompletion), "ToString(new Value(I))" + ' returned an abrupt completion');

          if (_temp54 instanceof Completion) {
            _temp54 = _temp54.Value;
          }

          const Istr = _temp54;

          let _temp55 = InternalizeJSONProperty(val, Istr);

          if (_temp55 instanceof AbruptCompletion) {
            return _temp55;
          }

          if (_temp55 instanceof Completion) {
            _temp55 = _temp55.Value;
          }

          const newElement = _temp55;

          if (Type(newElement) === 'Undefined') {
            let _temp56 = val.Delete(Istr);

            if (_temp56 instanceof AbruptCompletion) {
              return _temp56;
            }

            if (_temp56 instanceof Completion) {
              _temp56 = _temp56.Value;
            }
          } else {
            let _temp57 = CreateDataProperty(val, Istr, newElement);

            if (_temp57 instanceof AbruptCompletion) {
              return _temp57;
            }

            if (_temp57 instanceof Completion) {
              _temp57 = _temp57.Value;
            }
          }

          I += 1;
        }
      } else {
        let _temp58 = EnumerableOwnPropertyNames(val, 'key');

        if (_temp58 instanceof AbruptCompletion) {
          return _temp58;
        }

        if (_temp58 instanceof Completion) {
          _temp58 = _temp58.Value;
        }

        const keys = _temp58;

        for (const P of keys) {
          let _temp59 = InternalizeJSONProperty(val, P);

          if (_temp59 instanceof AbruptCompletion) {
            return _temp59;
          }

          if (_temp59 instanceof Completion) {
            _temp59 = _temp59.Value;
          }

          const newElement = _temp59;

          if (Type(newElement) === 'Undefined') {
            let _temp60 = val.Delete(P);

            if (_temp60 instanceof AbruptCompletion) {
              return _temp60;
            }

            if (_temp60 instanceof Completion) {
              _temp60 = _temp60.Value;
            }
          } else {
            let _temp61 = CreateDataProperty(val, P, newElement);

            if (_temp61 instanceof AbruptCompletion) {
              return _temp61;
            }

            if (_temp61 instanceof Completion) {
              _temp61 = _temp61.Value;
            }
          }
        }
      }
    }

    return Call(reviver, holder, [name, val]);
  }

  let _temp62 = ToString(text);

  if (_temp62 instanceof AbruptCompletion) {
    return _temp62;
  }

  if (_temp62 instanceof Completion) {
    _temp62 = _temp62.Value;
  }

  const jText = _temp62; // Parse JText interpreted as UTF-16 encoded Unicode points (6.1.4) as a JSON text as specified in ECMA-404.
  // Throw a SyntaxError exception if JText is not a valid JSON text as defined in that specification.

  let _temp63 = JSONValidator.validate(jText.stringValue());

  if (_temp63 instanceof AbruptCompletion) {
    return _temp63;
  }

  if (_temp63 instanceof Completion) {
    _temp63 = _temp63.Value;
  }
  const scriptText = `(${jText.stringValue()});`;
  const completion = EnsureCompletion(ScriptEvaluationJob(scriptText));
  const unfiltered = completion.Value;
  Assert(unfiltered instanceof StringValue || unfiltered instanceof NumberValue || unfiltered instanceof BooleanValue || unfiltered instanceof NullValue || unfiltered instanceof ObjectValue, "unfiltered instanceof StringValue\n         || unfiltered instanceof NumberValue\n         || unfiltered instanceof BooleanValue\n         || unfiltered instanceof NullValue\n         || unfiltered instanceof ObjectValue");

  if (IsCallable(reviver) === Value.true) {
    const root = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
    const rootName = new Value('');

    let _temp64 = CreateDataProperty(root, rootName, unfiltered);

    Assert(!(_temp64 instanceof AbruptCompletion), "CreateDataProperty(root, rootName, unfiltered)" + ' returned an abrupt completion');

    if (_temp64 instanceof Completion) {
      _temp64 = _temp64.Value;
    }

    const status = _temp64;
    Assert(status === Value.true, "status === Value.true");
    return InternalizeJSONProperty(root, rootName);
  } else {
    return unfiltered;
  }
}

const codeUnitTable = new Map([[0x0008, '\\b'], [0x0009, '\\t'], [0x000A, '\\n'], [0x000C, '\\f'], [0x000D, '\\r'], [0x0022, '\\"'], [0x005C, '\\\\']]);

function JSON_stringify([value = Value.undefined, replacer = Value.undefined, space = Value.undefined]) {
  // 24.5.2.1 #sec-serializejsonproperty
  function SerializeJSONProperty(key, holder) {
    let _temp65 = Get(holder, key);

    if (_temp65 instanceof AbruptCompletion) {
      return _temp65;
    }

    if (_temp65 instanceof Completion) {
      _temp65 = _temp65.Value;
    }

    let value = _temp65; // eslint-disable-line no-shadow

    if (Type(value) === 'Object' || Type(value) === 'BigInt') {
      let _temp66 = GetV(value, new Value('toJSON'));

      if (_temp66 instanceof AbruptCompletion) {
        return _temp66;
      }

      if (_temp66 instanceof Completion) {
        _temp66 = _temp66.Value;
      }

      const toJSON = _temp66;

      if (IsCallable(toJSON) === Value.true) {
        let _temp67 = Call(toJSON, value, [key]);

        if (_temp67 instanceof AbruptCompletion) {
          return _temp67;
        }

        if (_temp67 instanceof Completion) {
          _temp67 = _temp67.Value;
        }

        value = _temp67;
      }
    }

    if (ReplacerFunction !== Value.undefined) {
      let _temp68 = Call(ReplacerFunction, holder, [key, value]);

      if (_temp68 instanceof AbruptCompletion) {
        return _temp68;
      }

      if (_temp68 instanceof Completion) {
        _temp68 = _temp68.Value;
      }

      value = _temp68;
    }

    if (Type(value) === 'Object') {
      if ('NumberData' in value) {
        let _temp69 = ToNumber(value);

        if (_temp69 instanceof AbruptCompletion) {
          return _temp69;
        }

        if (_temp69 instanceof Completion) {
          _temp69 = _temp69.Value;
        }

        value = _temp69;
      } else if ('StringData' in value) {
        let _temp70 = ToString(value);

        if (_temp70 instanceof AbruptCompletion) {
          return _temp70;
        }

        if (_temp70 instanceof Completion) {
          _temp70 = _temp70.Value;
        }

        value = _temp70;
      } else if ('BooleanData' in value) {
        value = value.BooleanData;
      } else if ('BigIntData' in value) {
        value = value.BigIntData;
      }
    }

    if (value === Value.null) {
      return new Value('null');
    }

    if (value === Value.true) {
      return new Value('true');
    }

    if (value === Value.false) {
      return new Value('false');
    }

    if (Type(value) === 'String') {
      return QuoteJSONString(value);
    }

    if (Type(value) === 'Number') {
      if (value.isFinite()) {
        let _temp71 = ToString(value);

        Assert(!(_temp71 instanceof AbruptCompletion), "ToString(value)" + ' returned an abrupt completion');

        if (_temp71 instanceof Completion) {
          _temp71 = _temp71.Value;
        }

        return _temp71;
      }

      return new Value('null');
    }

    if (Type(value) === 'BigInt') {
      return surroundingAgent.Throw('TypeError', 'CannotJSONSerializeBigInt');
    }

    if (Type(value) === 'Object' && IsCallable(value) === Value.false) {
      let _temp72 = IsArray(value);

      if (_temp72 instanceof AbruptCompletion) {
        return _temp72;
      }

      if (_temp72 instanceof Completion) {
        _temp72 = _temp72.Value;
      }

      const isArray = _temp72;

      if (isArray === Value.true) {
        return SerializeJSONArray(value);
      }

      return SerializeJSONObject(value);
    }

    return Value.undefined;
  }

  function QuoteJSONString(value) {
    // eslint-disable-line no-shadow
    let product = '\u0022';
    const cpList = [...value.stringValue()].map(c => c.codePointAt(0));

    for (const C of cpList) {
      if (codeUnitTable.has(C)) {
        product = `${product}${codeUnitTable.get(C)}`;
      } else if (C < 0x0020 || C >= 0xD800 && C <= 0xDBFF || C >= 0xDC00 && C <= 0xDFFF) {
        const unit = String.fromCodePoint(C);
        product = `${product}${UnicodeEscape(unit)}`;
      } else {
        product = `${product}${String.fromCodePoint(...UTF16Encoding(C))}`;
      }
    }

    product = `${product}\u0022`;
    return new Value(product);
  }

  function UnicodeEscape(C) {
    const n = C.charCodeAt(0);
    Assert(n < 0xFFFF, "n < 0xFFFF");
    return `\u005Cu${n.toString(16).padStart(4, '0')}`;
  } // 24.5.2.4 #sec-serializejsonobject


  function SerializeJSONObject(value) {
    // eslint-disable-line no-shadow
    if (stack.includes(value)) {
      return surroundingAgent.Throw('TypeError', 'JSONCircular');
    }

    stack.push(value);
    const stepback = indent;
    indent = `${indent}${gap}`;
    let K;

    if (PropertyList !== Value.undefined) {
      K = PropertyList;
    } else {
      let _temp73 = EnumerableOwnPropertyNames(value, 'key');

      if (_temp73 instanceof AbruptCompletion) {
        return _temp73;
      }

      if (_temp73 instanceof Completion) {
        _temp73 = _temp73.Value;
      }

      K = _temp73;
    }

    const partial = [];

    for (const P of K) {
      let _temp74 = SerializeJSONProperty(P, value);

      if (_temp74 instanceof AbruptCompletion) {
        return _temp74;
      }

      if (_temp74 instanceof Completion) {
        _temp74 = _temp74.Value;
      }

      const strP = _temp74;

      if (strP !== Value.undefined) {
        let member = QuoteJSONString(P).stringValue();
        member = `${member}:`;

        if (gap !== '') {
          member = `${member} `;
        }

        member = `${member}${strP.stringValue()}`;
        partial.push(member);
      }
    }

    let final;

    if (partial.length === 0) {
      final = new Value('{}');
    } else {
      if (gap === '') {
        const properties = partial.join(',');
        final = new Value(`{${properties}}`);
      } else {
        const separator = `,\u000A${indent}`;
        const properties = partial.join(separator);
        final = new Value(`{\u000A${indent}${properties}\u000A${stepback}}`);
      }
    }

    stack.pop();
    indent = stepback;
    return final;
  } // 24.5.2.5 #sec-serializejsonarray


  function SerializeJSONArray(value) {
    // eslint-disable-line no-shadow
    if (stack.includes(value)) {
      return surroundingAgent.Throw('TypeError', 'JSONCircular');
    }

    stack.push(value);
    const stepback = indent;
    indent = `${indent}${gap}`;
    const partial = [];

    let _temp75 = LengthOfArrayLike(value);

    if (_temp75 instanceof AbruptCompletion) {
      return _temp75;
    }

    if (_temp75 instanceof Completion) {
      _temp75 = _temp75.Value;
    }

    const len = _temp75.numberValue();

    let index = 0;

    while (index < len) {
      let _temp76 = ToString(new Value(index));

      Assert(!(_temp76 instanceof AbruptCompletion), "ToString(new Value(index))" + ' returned an abrupt completion');

      if (_temp76 instanceof Completion) {
        _temp76 = _temp76.Value;
      }

      const indexStr = _temp76;

      let _temp77 = SerializeJSONProperty(indexStr, value);

      if (_temp77 instanceof AbruptCompletion) {
        return _temp77;
      }

      if (_temp77 instanceof Completion) {
        _temp77 = _temp77.Value;
      }

      const strP = _temp77;

      if (strP === Value.undefined) {
        partial.push('null');
      } else {
        partial.push(strP.stringValue());
      }

      index += 1;
    }

    let final;

    if (partial.length === 0) {
      final = new Value('[]');
    } else {
      if (gap === '') {
        const properties = partial.join(',');
        final = new Value(`[${properties}]`);
      } else {
        const separator = `,\u000A${indent}`;
        const properties = partial.join(separator);
        final = new Value(`[\u000A${indent}${properties}\u000A${stepback}]`);
      }
    }

    stack.pop();
    indent = stepback;
    return final;
  }

  const stack = [];
  let indent = '';
  let PropertyList = Value.undefined;
  let ReplacerFunction = Value.undefined;

  if (Type(replacer) === 'Object') {
    if (IsCallable(replacer) === Value.true) {
      ReplacerFunction = replacer;
    } else {
      let _temp78 = IsArray(replacer);

      if (_temp78 instanceof AbruptCompletion) {
        return _temp78;
      }

      if (_temp78 instanceof Completion) {
        _temp78 = _temp78.Value;
      }

      const isArray = _temp78;

      if (isArray === Value.true) {
        PropertyList = new ValueSet();

        let _temp79 = LengthOfArrayLike(replacer);

        if (_temp79 instanceof AbruptCompletion) {
          return _temp79;
        }

        if (_temp79 instanceof Completion) {
          _temp79 = _temp79.Value;
        }

        const len = _temp79.numberValue();

        let k = 0;

        while (k < len) {
          let _temp80 = ToString(new Value(k));

          Assert(!(_temp80 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

          if (_temp80 instanceof Completion) {
            _temp80 = _temp80.Value;
          }

          const vStr = _temp80;

          let _temp81 = Get(replacer, vStr);

          if (_temp81 instanceof AbruptCompletion) {
            return _temp81;
          }

          if (_temp81 instanceof Completion) {
            _temp81 = _temp81.Value;
          }

          const v = _temp81;
          let item = Value.undefined;

          if (Type(v) === 'String') {
            item = v;
          } else if (Type(v) === 'Number') {
            let _temp82 = ToString(v);

            Assert(!(_temp82 instanceof AbruptCompletion), "ToString(v)" + ' returned an abrupt completion');

            if (_temp82 instanceof Completion) {
              _temp82 = _temp82.Value;
            }

            item = _temp82;
          } else if (Type(v) === 'Object') {
            if ('StringData' in v || 'NumberData' in v) {
              let _temp83 = ToString(v);

              if (_temp83 instanceof AbruptCompletion) {
                return _temp83;
              }

              if (_temp83 instanceof Completion) {
                _temp83 = _temp83.Value;
              }

              item = _temp83;
            }
          }

          if (item !== Value.undefined && !PropertyList.has(item)) {
            PropertyList.add(item);
          }

          k += 1;
        }
      }
    }
  }

  if (Type(space) === 'Object') {
    if ('NumberData' in space) {
      let _temp84 = ToNumber(space);

      if (_temp84 instanceof AbruptCompletion) {
        return _temp84;
      }

      if (_temp84 instanceof Completion) {
        _temp84 = _temp84.Value;
      }

      space = _temp84;
    } else if ('StringData' in space) {
      let _temp85 = ToString(space);

      if (_temp85 instanceof AbruptCompletion) {
        return _temp85;
      }

      if (_temp85 instanceof Completion) {
        _temp85 = _temp85.Value;
      }

      space = _temp85;
    }
  }

  let gap;

  if (Type(space) === 'Number') {
    let _temp86 = ToInteger(space);

    Assert(!(_temp86 instanceof AbruptCompletion), "ToInteger(space)" + ' returned an abrupt completion');

    if (_temp86 instanceof Completion) {
      _temp86 = _temp86.Value;
    }

    space = Math.min(10, _temp86.numberValue());

    if (space < 1) {
      gap = '';
    } else {
      gap = ' '.repeat(space);
    }
  } else if (Type(space) === 'String') {
    if (space.stringValue().length <= 10) {
      gap = space.stringValue();
    } else {
      gap = space.stringValue().slice(0, 10);
    }
  } else {
    gap = '';
  }

  const wrapper = ObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));

  let _temp87 = CreateDataProperty(wrapper, new Value(''), value);

  Assert(!(_temp87 instanceof AbruptCompletion), "CreateDataProperty(wrapper, new Value(''), value)" + ' returned an abrupt completion');

  if (_temp87 instanceof Completion) {
    _temp87 = _temp87.Value;
  }

  const status = _temp87;
  Assert(status === Value.true, "status === Value.true");
  return SerializeJSONProperty(new Value(''), wrapper);
}

function CreateJSON(realmRec) {
  const json = BootstrapPrototype(realmRec, [['parse', JSON_parse, 2], ['stringify', JSON_stringify, 3]], realmRec.Intrinsics['%Object.prototype%'], 'JSON');
  realmRec.Intrinsics['%JSON%'] = json;

  let _temp88 = json.Get(new Value('parse'));

  Assert(!(_temp88 instanceof AbruptCompletion), "json.Get(new Value('parse'))" + ' returned an abrupt completion');

  if (_temp88 instanceof Completion) {
    _temp88 = _temp88.Value;
  }

  realmRec.Intrinsics['%JSON.parse%'] = _temp88;
}

function TheEval([x = Value.undefined]) {
  Assert(surroundingAgent.executionContextStack.length >= 2, "surroundingAgent.executionContextStack.length >= 2");
  const callerContext = surroundingAgent.executionContextStack[surroundingAgent.executionContextStack.length - 2];
  const callerRealm = callerContext.Realm;
  return PerformEval(x, callerRealm, false, false);
}

function CreateEval(realmRec) {
  const it = CreateBuiltinFunction(TheEval, [], realmRec);
  SetFunctionName(it, new Value('eval'));
  SetFunctionLength(it, new Value(1));
  realmRec.Intrinsics['%eval%'] = it;
}

function IsFinite([number = Value.undefined]) {
  let _temp = ToNumber(number);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const num = _temp;

  if (num.isNaN() || num.isInfinity()) {
    return Value.false;
  }

  return Value.true;
}

function CreateIsFinite(realmRec) {
  const fn = CreateBuiltinFunction(IsFinite, [], realmRec);

  let _temp2 = SetFunctionName(fn, new Value('isFinite'));

  Assert(!(_temp2 instanceof AbruptCompletion), "SetFunctionName(fn, new Value('isFinite'))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  let _temp3 = SetFunctionLength(fn, new Value(1));

  Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionLength(fn, new Value(1))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  realmRec.Intrinsics['%isFinite%'] = fn;
}

function IsNaN([number = Value.undefined]) {
  let _temp = ToNumber(number);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const num = _temp;

  if (num.isNaN()) {
    return Value.true;
  }

  return Value.false;
}

function CreateIsNaN(realmRec) {
  const fn = CreateBuiltinFunction(IsNaN, [], realmRec);

  let _temp2 = SetFunctionName(fn, new Value('isNaN'));

  Assert(!(_temp2 instanceof AbruptCompletion), "SetFunctionName(fn, new Value('isNaN'))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  let _temp3 = SetFunctionLength(fn, new Value(1));

  Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionLength(fn, new Value(1))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  realmRec.Intrinsics['%isNaN%'] = fn;
}

function ParseFloat([string = Value.undefined]) {
  let _temp = ToString(string);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const inputString = _temp;

  let _temp2 = TrimString(inputString, 'start');

  Assert(!(_temp2 instanceof AbruptCompletion), "TrimString(inputString, 'start')" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const trimmedString = _temp2.stringValue();

  const mathFloat = MV_StrDecimalLiteral(trimmedString, true); // MV_StrDecimalLiteral handles -0 automatically.

  return mathFloat;
}

function CreateParseFloat(realmRec) {
  const fn = CreateBuiltinFunction(ParseFloat, [], realmRec);

  let _temp3 = SetFunctionName(fn, new Value('parseFloat'));

  Assert(!(_temp3 instanceof AbruptCompletion), "SetFunctionName(fn, new Value('parseFloat'))" + ' returned an abrupt completion');

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  let _temp4 = SetFunctionLength(fn, new Value(1));

  Assert(!(_temp4 instanceof AbruptCompletion), "SetFunctionLength(fn, new Value(1))" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  realmRec.Intrinsics['%parseFloat%'] = fn;
}

function digitToNumber(digit) {
  digit = digit.charCodeAt(0);

  if (digit < 0x30
  /* 0 */
  ) {
      return NaN;
    }

  if (digit <= 0x39
  /* 9 */
  ) {
      return digit - 0x30;
    } // Convert to lower case.


  digit &= ~0x20; // eslint-disable-line no-bitwise

  if (digit < 0x41
  /* A */
  ) {
      return NaN;
    }

  if (digit <= 0x5a
  /* Z */
  ) {
      return digit - 0x41
      /* A */
      + 10;
    }

  return NaN;
}

function stringToRadixNumber(str, R) {
  let num = 0;

  for (let i = 0; i < str.length; i += 1) {
    const power = str.length - i - 1;
    const multiplier = R ** power;
    const dig = digitToNumber(str[i]);
    Assert(!Number.isNaN(dig) && dig < R, "!Number.isNaN(dig) && dig < R");
    num += dig * multiplier;
  }

  return num;
}

function searchNotRadixDigit(str, R) {
  for (let i = 0; i < str.length; i += 1) {
    const num = digitToNumber(str[i]);

    if (Number.isNaN(num) || num >= R) {
      return i;
    }
  }

  return str.length;
}

function ParseInt([string = Value.undefined, radix = Value.undefined]) {
  let _temp = ToString(string);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const inputString = _temp;

  let _temp2 = TrimString(inputString, 'start');

  Assert(!(_temp2 instanceof AbruptCompletion), "TrimString(inputString, 'start')" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  let S = _temp2.stringValue();

  let sign = 1;

  if (S !== '' && S[0] === '\x2D') {
    sign = -1;
  }

  if (S !== '' && (S[0] === '\x2B' || S[0] === '\x2D')) {
    S = S.slice(1);
  }

  let _temp3 = ToInt32(radix);

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }

  let R = _temp3.numberValue();

  let stripPrefix = true;

  if (R !== 0) {
    if (R < 2 || R > 36) {
      return new Value(NaN);
    }

    if (R !== 16) {
      stripPrefix = false;
    }
  } else {
    R = 10;
  }

  if (stripPrefix === true) {
    if (S.length >= 2 && (S.startsWith('0x') || S.startsWith('0X'))) {
      S = S.slice(2);
      R = 16;
    }
  }

  const Z = S.slice(0, searchNotRadixDigit(S, R));

  if (Z === '') {
    return new Value(NaN);
  }

  const mathInt = stringToRadixNumber(Z, R);

  if (mathInt === 0) {
    if (sign === -1) {
      return new Value(-0);
    }

    return new Value(+0);
  }

  const number = mathInt;
  return new Value(sign * number);
}

function CreateParseInt(realmRec) {
  const fn = CreateBuiltinFunction(ParseInt, [], realmRec);

  let _temp4 = SetFunctionName(fn, new Value('parseInt'));

  Assert(!(_temp4 instanceof AbruptCompletion), "SetFunctionName(fn, new Value('parseInt'))" + ' returned an abrupt completion');

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  let _temp5 = SetFunctionLength(fn, new Value(2));

  Assert(!(_temp5 instanceof AbruptCompletion), "SetFunctionLength(fn, new Value(2))" + ' returned an abrupt completion');

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }
  realmRec.Intrinsics['%parseInt%'] = fn;
}

function CreateThrowTypeError(realmRec) {
  let _temp = CreateBuiltinFunction(() => surroundingAgent.Throw('TypeError', 'StrictPoisonPill'), [], realmRec, Value.null);

  Assert(!(_temp instanceof AbruptCompletion), "CreateBuiltinFunction(\n    () => surroundingAgent.Throw('TypeError', 'StrictPoisonPill'),\n    [], realmRec, Value.null,\n  )" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const ThrowTypeError = _temp;
  ThrowTypeError.Extensible = Value.false;
  ThrowTypeError.properties.set(new Value('length'), Descriptor({
    Value: new Value(0),
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  ThrowTypeError.Prototype = realmRec.Intrinsics['%Function.prototype%'];
  realmRec.Intrinsics['%ThrowTypeError%'] = ThrowTypeError;
}

function TypedArrayConstructor() {
  return surroundingAgent.Throw('TypeError', 'NotAConstructor', surroundingAgent.activeFunctionObject);
} // 22.2.2.1 #sec-%typedarray%.from


function TypedArray_from([source = Value.undefined, mapfn, thisArg = Value.undefined], {
  thisValue
}) {
  const C = thisValue;

  if (IsConstructor(C) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', C);
  }

  let mapping;

  if (mapfn !== undefined && mapfn !== Value.undefined) {
    if (IsCallable(mapfn) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', mapfn);
    }

    mapping = true;
  } else {
    mapping = false;
  }

  let _temp = GetMethod(source, wellKnownSymbols.iterator);
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  const usingIterator = _temp;

  if (usingIterator !== Value.undefined) {
    let _temp2 = IterableToList(source, usingIterator);

    if (_temp2 instanceof AbruptCompletion) {
      return _temp2;
    }

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const values = _temp2;
    const len = values.length;

    let _temp3 = TypedArrayCreate(C, [new Value(len)]);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    const targetObj = _temp3;
    let k = 0;

    while (k < len) {
      let _temp4 = ToString(new Value(k));

      Assert(!(_temp4 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');
      /* istanbul ignore if */

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      const Pk = _temp4;
      const kValue = values.shift();
      let mappedValue;

      if (mapping) {
        let _temp5 = Call(mapfn, thisArg, [kValue, new Value(k)]);

        if (_temp5 instanceof AbruptCompletion) {
          return _temp5;
        }

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }

        mappedValue = _temp5;
      } else {
        mappedValue = kValue;
      }

      let _temp6 = Set$1(targetObj, Pk, mappedValue, Value.true);

      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }
      k += 1;
    }

    Assert(values.length === 0, "values.length === 0");
    return targetObj;
  } // NOTE: source is not an Iterable so assume it is already an array-like
  // object.


  let _temp7 = ToObject(source);

  Assert(!(_temp7 instanceof AbruptCompletion), "ToObject(source)" + ' returned an abrupt completion');

  if (_temp7 instanceof Completion) {
    _temp7 = _temp7.Value;
  }

  const arrayLike = _temp7;

  let _temp8 = LengthOfArrayLike(arrayLike);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }

  const len = _temp8.numberValue();

  let _temp9 = TypedArrayCreate(C, [new Value(len)]);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }

  const targetObj = _temp9;
  let k = 0;

  while (k < len) {
    let _temp10 = ToString(new Value(k));

    Assert(!(_temp10 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp10 instanceof Completion) {
      _temp10 = _temp10.Value;
    }

    const Pk = _temp10;

    let _temp11 = Get(arrayLike, Pk);

    if (_temp11 instanceof AbruptCompletion) {
      return _temp11;
    }

    if (_temp11 instanceof Completion) {
      _temp11 = _temp11.Value;
    }

    const kValue = _temp11;
    let mappedValue;

    if (mapping) {
      let _temp12 = Call(mapfn, thisArg, [kValue, new Value(k)]);

      if (_temp12 instanceof AbruptCompletion) {
        return _temp12;
      }

      if (_temp12 instanceof Completion) {
        _temp12 = _temp12.Value;
      }

      mappedValue = _temp12;
    } else {
      mappedValue = kValue;
    }

    let _temp13 = Set$1(targetObj, Pk, mappedValue, Value.true);

    if (_temp13 instanceof AbruptCompletion) {
      return _temp13;
    }

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }
    k += 1;
  }

  return targetObj;
} // 22.2.2.2 #sec-%typedarray%.of


function TypedArray_of(items, {
  thisValue
}) {
  const len = items.length;
  const C = thisValue;

  if (IsConstructor(C) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', C);
  }

  let _temp14 = TypedArrayCreate(C, [new Value(len)]);

  if (_temp14 instanceof AbruptCompletion) {
    return _temp14;
  }

  if (_temp14 instanceof Completion) {
    _temp14 = _temp14.Value;
  }

  const newObj = _temp14;
  let k = 0;

  while (k < len) {
    const kValue = items[k];

    let _temp15 = ToString(new Value(k));

    Assert(!(_temp15 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp15 instanceof Completion) {
      _temp15 = _temp15.Value;
    }

    const Pk = _temp15;

    let _temp16 = Set$1(newObj, Pk, kValue, Value.true);

    if (_temp16 instanceof AbruptCompletion) {
      return _temp16;
    }

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }
    k += 1;
  }

  return newObj;
} // 22.2.2.4 #sec-get-%typedarray%-@@species


function TypedArray_speciesGetter(args, {
  thisValue
}) {
  return thisValue;
}

function CreateTypedArray(realmRec) {
  const typedArrayConstructor = BootstrapConstructor(realmRec, TypedArrayConstructor, 'TypedArray', 0, realmRec.Intrinsics['%TypedArray.prototype%'], [['from', TypedArray_from, 1], ['of', TypedArray_of, 0], [wellKnownSymbols.species, [TypedArray_speciesGetter]]]);
  realmRec.Intrinsics['%TypedArray%'] = typedArrayConstructor;
}

function TypedArrayProto_bufferGetter(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp = RequireInternalSlot(O, 'TypedArrayName');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;
  return buffer;
} // 22.2.3.2 #sec-get-%typedarray%.prototype.bytelength


function TypedArrayProto_byteLengthGetter(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp2 = RequireInternalSlot(O, 'TypedArrayName');

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return new Value(0);
  }

  const size = O.ByteLength;
  return size;
} // 22.2.3.3 #sec-get-%typedarray%.prototype.byteoffset


function TypedArrayProto_byteOffsetGetter(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp3 = RequireInternalSlot(O, 'TypedArrayName');

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return new Value(0);
  }

  const offset = O.ByteOffset;
  return offset;
} // 22.2.3.5 #sec-%typedarray%.prototype.copywithin


function TypedArrayProto_copyWithin([target = Value.undefined, start = Value.undefined, end], {
  thisValue
}) {
  const O = thisValue;

  let _temp4 = ValidateTypedArray(O);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  const len = O.ArrayLength.numberValue();

  let _temp5 = ToInteger(target);

  if (_temp5 instanceof AbruptCompletion) {
    return _temp5;
  }

  if (_temp5 instanceof Completion) {
    _temp5 = _temp5.Value;
  }

  const relativeTarget = _temp5.numberValue();

  let to;

  if (relativeTarget < 0) {
    to = Math.max(len + relativeTarget, 0);
  } else {
    to = Math.min(relativeTarget, len);
  }

  let _temp6 = ToInteger(start);

  if (_temp6 instanceof AbruptCompletion) {
    return _temp6;
  }

  if (_temp6 instanceof Completion) {
    _temp6 = _temp6.Value;
  }

  const relativeStart = _temp6.numberValue();

  let from;

  if (relativeStart < 0) {
    from = Math.max(len + relativeStart, 0);
  } else {
    from = Math.min(relativeStart, len);
  }

  let relativeEnd;

  if (end === undefined || end === Value.undefined) {
    relativeEnd = len;
  } else {
    let _temp7 = ToInteger(end);

    if (_temp7 instanceof AbruptCompletion) {
      return _temp7;
    }

    if (_temp7 instanceof Completion) {
      _temp7 = _temp7.Value;
    }

    relativeEnd = _temp7.numberValue();
  }

  let final;

  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }

  const count = Math.min(final - from, len - to);

  if (count > 0) {
    // NOTE: The copying must be performed in a manner that preserves the
    // bit-level encoding of the source data.
    const buffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', 'BufferDetached');
    }

    const typedArrayName = O.TypedArrayName.stringValue();
    const elementSize = typedArrayInfo.get(typedArrayName).ElementSize;
    const byteOffset = O.ByteOffset.numberValue();
    let toByteIndex = to * elementSize + byteOffset;
    let fromByteIndex = from * elementSize + byteOffset;
    let countBytes = count * elementSize;
    let direction;

    if (fromByteIndex < toByteIndex && toByteIndex < fromByteIndex + countBytes) {
      direction = -1;
      fromByteIndex = fromByteIndex + countBytes - 1;
      toByteIndex = toByteIndex + countBytes - 1;
    } else {
      direction = 1;
    }

    while (countBytes > 0) {
      const value = GetValueFromBuffer(buffer, new Value(fromByteIndex), 'Uint8');
      SetValueInBuffer(buffer, new Value(toByteIndex), 'Uint8', value);
      fromByteIndex += direction;
      toByteIndex += direction;
      countBytes -= 1;
    }
  }

  return O;
} // 22.2.3.6 #sec-%typedarray%.prototype.entries


function TypedArrayProto_entries(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp8 = ValidateTypedArray(O);

  if (_temp8 instanceof AbruptCompletion) {
    return _temp8;
  }

  if (_temp8 instanceof Completion) {
    _temp8 = _temp8.Value;
  }
  return CreateArrayIterator(O, 'key+value');
} // 22.2.3.8 #sec-%typedarray%.prototype.fill


function TypedArrayProto_fill([value = Value.undefined, start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  const O = thisValue;

  let _temp9 = ValidateTypedArray(O);

  if (_temp9 instanceof AbruptCompletion) {
    return _temp9;
  }

  if (_temp9 instanceof Completion) {
    _temp9 = _temp9.Value;
  }
  const len = O.ArrayLength.numberValue();

  let _temp10 = ToNumber(value);

  if (_temp10 instanceof AbruptCompletion) {
    return _temp10;
  }

  if (_temp10 instanceof Completion) {
    _temp10 = _temp10.Value;
  }

  value = _temp10;

  let _temp11 = ToInteger(start);

  if (_temp11 instanceof AbruptCompletion) {
    return _temp11;
  }

  if (_temp11 instanceof Completion) {
    _temp11 = _temp11.Value;
  }

  const relativeStart = _temp11.numberValue();

  let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
  let relativeEnd;

  if (end === Value.undefined) {
    relativeEnd = len;
  } else {
    let _temp12 = ToInteger(end);

    if (_temp12 instanceof AbruptCompletion) {
      return _temp12;
    }

    if (_temp12 instanceof Completion) {
      _temp12 = _temp12.Value;
    }

    relativeEnd = _temp12.numberValue();
  }

  const final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

  if (IsDetachedBuffer(O.ViewedArrayBuffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  while (k < final) {
    let _temp13 = ToString(new Value(k));

    Assert(!(_temp13 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');
    /* istanbul ignore if */

    if (_temp13 instanceof Completion) {
      _temp13 = _temp13.Value;
    }

    const Pk = _temp13;

    let _temp14 = Set$1(O, Pk, value, Value.true);

    Assert(!(_temp14 instanceof AbruptCompletion), "Set(O, Pk, value, Value.true)" + ' returned an abrupt completion');

    if (_temp14 instanceof Completion) {
      _temp14 = _temp14.Value;
    }
    k += 1;
  }

  return O;
} // 22.2.3.9 #sec-%typedarray%.prototype.filter


function TypedArrayProto_filter([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  const O = thisValue;

  let _temp15 = ValidateTypedArray(O);

  if (_temp15 instanceof AbruptCompletion) {
    return _temp15;
  }

  if (_temp15 instanceof Completion) {
    _temp15 = _temp15.Value;
  }
  const len = O.ArrayLength.numberValue();

  if (IsCallable(callbackfn) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }

  const kept = [];
  let k = 0;
  let captured = 0;

  while (k < len) {
    let _temp16 = ToString(new Value(k));

    Assert(!(_temp16 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp16 instanceof Completion) {
      _temp16 = _temp16.Value;
    }

    const Pk = _temp16;

    let _temp17 = Get(O, Pk);

    if (_temp17 instanceof AbruptCompletion) {
      return _temp17;
    }

    if (_temp17 instanceof Completion) {
      _temp17 = _temp17.Value;
    }

    const kValue = _temp17;

    let _temp18 = Call(callbackfn, thisArg, [kValue, new Value(k), O]);

    if (_temp18 instanceof AbruptCompletion) {
      return _temp18;
    }

    if (_temp18 instanceof Completion) {
      _temp18 = _temp18.Value;
    }

    const selected = ToBoolean(_temp18);

    if (selected === Value.true) {
      kept.push(kValue);
      captured += 1;
    }

    k += 1;
  }

  let _temp19 = TypedArraySpeciesCreate(O, [new Value(captured)]);

  if (_temp19 instanceof AbruptCompletion) {
    return _temp19;
  }

  if (_temp19 instanceof Completion) {
    _temp19 = _temp19.Value;
  }

  const A = _temp19;
  let n = 0;

  for (const e of kept) {
    let _temp20 = ToString(new Value(n));

    Assert(!(_temp20 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

    if (_temp20 instanceof Completion) {
      _temp20 = _temp20.Value;
    }

    const nStr = _temp20;

    let _temp21 = Set$1(A, nStr, e, Value.true);

    Assert(!(_temp21 instanceof AbruptCompletion), "Set(A, nStr, e, Value.true)" + ' returned an abrupt completion');

    if (_temp21 instanceof Completion) {
      _temp21 = _temp21.Value;
    }
    n += 1;
  }

  return A;
} // 22.2.3.16 #sec-%typedarray%.prototype.keys


function TypedArrayProto_keys(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp22 = ValidateTypedArray(O);

  if (_temp22 instanceof AbruptCompletion) {
    return _temp22;
  }

  if (_temp22 instanceof Completion) {
    _temp22 = _temp22.Value;
  }
  return CreateArrayIterator(O, 'key');
} // 22.2.3.18 #sec-get-%typedarray%.prototype.length


function TypedArrayProto_lengthGetter(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp23 = RequireInternalSlot(O, 'TypedArrayName');

  if (_temp23 instanceof AbruptCompletion) {
    return _temp23;
  }

  if (_temp23 instanceof Completion) {
    _temp23 = _temp23.Value;
  }
  Assert('ViewedArrayBuffer' in O && 'ArrayLength' in O, "'ViewedArrayBuffer' in O && 'ArrayLength' in O");
  const buffer = O.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return new Value(0);
  }

  const length = O.ArrayLength;
  return length;
} // 22.2.3.19 #sec-%typedarray%.prototype.map


function TypedArrayProto_map([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  const O = thisValue;

  let _temp24 = ValidateTypedArray(O);

  if (_temp24 instanceof AbruptCompletion) {
    return _temp24;
  }

  if (_temp24 instanceof Completion) {
    _temp24 = _temp24.Value;
  }
  const len = O.ArrayLength;

  if (IsCallable(callbackfn) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }

  let _temp25 = TypedArraySpeciesCreate(O, [len]);

  if (_temp25 instanceof AbruptCompletion) {
    return _temp25;
  }

  if (_temp25 instanceof Completion) {
    _temp25 = _temp25.Value;
  }

  const A = _temp25;
  let k = 0;

  while (k < len.numberValue()) {
    let _temp26 = ToString(new Value(k));

    Assert(!(_temp26 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

    if (_temp26 instanceof Completion) {
      _temp26 = _temp26.Value;
    }

    const Pk = _temp26;

    let _temp27 = Get(O, Pk);

    if (_temp27 instanceof AbruptCompletion) {
      return _temp27;
    }

    if (_temp27 instanceof Completion) {
      _temp27 = _temp27.Value;
    }

    const kValue = _temp27;

    let _temp28 = Call(callbackfn, thisArg, [kValue, new Value(k), O]);

    if (_temp28 instanceof AbruptCompletion) {
      return _temp28;
    }

    if (_temp28 instanceof Completion) {
      _temp28 = _temp28.Value;
    }

    const mappedValue = _temp28;

    let _temp29 = Set$1(A, Pk, mappedValue, Value.true);

    if (_temp29 instanceof AbruptCompletion) {
      return _temp29;
    }

    if (_temp29 instanceof Completion) {
      _temp29 = _temp29.Value;
    }
    k += 1;
  }

  return A;
} // 22.2.3.23 #sec-%typedarray%.prototype.set-overloaded-offset


function TypedArrayProto_set([overloaded = Value.undefined, offset = Value.undefined], {
  thisValue
}) {
  if (Type(overloaded) !== 'Object' || !('TypedArrayName' in overloaded)) {
    // 22.2.3.23.1 #sec-%typedarray%.prototype.set-array-offset
    const array = overloaded;
    const target = thisValue;

    let _temp30 = RequireInternalSlot(target, 'TypedArrayName');

    if (_temp30 instanceof AbruptCompletion) {
      return _temp30;
    }

    if (_temp30 instanceof Completion) {
      _temp30 = _temp30.Value;
    }
    Assert('ViewedArrayBuffer' in target, "'ViewedArrayBuffer' in target");

    let _temp31 = ToInteger(offset);

    if (_temp31 instanceof AbruptCompletion) {
      return _temp31;
    }

    if (_temp31 instanceof Completion) {
      _temp31 = _temp31.Value;
    }

    const targetOffset = _temp31.numberValue();

    if (targetOffset < 0) {
      return surroundingAgent.Throw('RangeError', 'NegativeIndex', 'Offset');
    }

    const targetBuffer = target.ViewedArrayBuffer;

    if (IsDetachedBuffer(targetBuffer)) {
      return surroundingAgent.Throw('TypeError', 'BufferDetached');
    }

    const targetLength = target.ArrayLength.numberValue();
    const targetName = target.TypedArrayName.stringValue();
    const targetInfo = typedArrayInfo.get(targetName);
    const targetElementSize = targetInfo.ElementSize;
    const targetType = targetInfo.ElementType;
    const targetByteOffset = target.ByteOffset.numberValue();

    let _temp32 = ToObject(array);

    if (_temp32 instanceof AbruptCompletion) {
      return _temp32;
    }

    if (_temp32 instanceof Completion) {
      _temp32 = _temp32.Value;
    }

    const src = _temp32;

    let _temp33 = LengthOfArrayLike(src);

    if (_temp33 instanceof AbruptCompletion) {
      return _temp33;
    }

    if (_temp33 instanceof Completion) {
      _temp33 = _temp33.Value;
    }

    const srcLength = _temp33.numberValue();

    if (srcLength + targetOffset > targetLength) {
      return surroundingAgent.Throw('RangeError', 'TypedArrayOOB');
    }

    let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;
    let k = 0;
    const limit = targetByteIndex + targetElementSize * srcLength;

    while (targetByteIndex < limit) {
      let _temp34 = ToString(new Value(k));

      Assert(!(_temp34 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp34 instanceof Completion) {
        _temp34 = _temp34.Value;
      }

      const Pk = _temp34;

      let _temp35 = Get(src, Pk);

      if (_temp35 instanceof AbruptCompletion) {
        return _temp35;
      }

      if (_temp35 instanceof Completion) {
        _temp35 = _temp35.Value;
      }

      const kProp = _temp35;

      let _temp36 = ToNumber(kProp);

      if (_temp36 instanceof AbruptCompletion) {
        return _temp36;
      }

      if (_temp36 instanceof Completion) {
        _temp36 = _temp36.Value;
      }

      const kNumber = _temp36;

      if (IsDetachedBuffer(targetBuffer)) {
        return surroundingAgent.Throw('TypeError', 'BufferDetached');
      }

      SetValueInBuffer(targetBuffer, new Value(targetByteIndex), targetType, kNumber);
      k += 1;
      targetByteIndex += targetElementSize;
    }

    return Value.undefined;
  } else {
    // 22.2.3.23.2 #sec-%typedarray%.prototype.set-typedarray-offset
    const typedArray = overloaded;
    Assert(Type(typedArray) === 'Object' && 'TypedArrayName' in typedArray, "Type(typedArray) === 'Object' && 'TypedArrayName' in typedArray");
    const target = thisValue;

    let _temp37 = RequireInternalSlot(target, 'TypedArrayName');

    if (_temp37 instanceof AbruptCompletion) {
      return _temp37;
    }

    if (_temp37 instanceof Completion) {
      _temp37 = _temp37.Value;
    }
    Assert('ViewedArrayBuffer' in target, "'ViewedArrayBuffer' in target");

    let _temp38 = ToInteger(offset);

    if (_temp38 instanceof AbruptCompletion) {
      return _temp38;
    }

    if (_temp38 instanceof Completion) {
      _temp38 = _temp38.Value;
    }

    const targetOffset = _temp38.numberValue();

    if (targetOffset < 0) {
      return surroundingAgent.Throw('RangeError', 'NegativeIndex', 'Offset');
    }

    const targetBuffer = target.ViewedArrayBuffer;

    if (IsDetachedBuffer(targetBuffer)) {
      return surroundingAgent.Throw('TypeError', 'BufferDetached');
    }

    const targetLength = target.ArrayLength.numberValue();
    let srcBuffer = typedArray.ViewedArrayBuffer;

    if (IsDetachedBuffer(srcBuffer)) {
      return surroundingAgent.Throw('TypeError', 'BufferDetached');
    }

    const targetName = target.TypedArrayName.stringValue();
    const targetInfo = typedArrayInfo.get(targetName);
    const targetType = targetInfo.ElementType;
    const targetElementSize = targetInfo.ElementSize;
    const targetByteOffset = target.ByteOffset.numberValue();
    const srcName = typedArray.TypedArrayName.stringValue();
    const srcInfo = typedArrayInfo.get(srcName);
    const srcType = srcInfo.ElementType;
    const srcElementSize = srcInfo.ElementSize;
    const srcLength = typedArray.ArrayLength.numberValue();
    const srcByteOffset = typedArray.ByteOffset;

    if (srcLength + targetOffset > targetLength) {
      return surroundingAgent.Throw('RangeError', 'TypedArrayOOB');
    } // let same;
    // if (IsSharedArrayBuffer(srcBuffer) && IsSharedArrayBuffer(targetBuffer)) {
    //   same = ...
    // } else {


    const same = SameValue(srcBuffer, targetBuffer); // }

    let srcByteIndex;

    if (same === Value.true) {
      const srcByteLength = typedArray.ByteLength;

      let _temp39 = CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, surroundingAgent.intrinsic('%ArrayBuffer%'));

      if (_temp39 instanceof AbruptCompletion) {
        return _temp39;
      }

      if (_temp39 instanceof Completion) {
        _temp39 = _temp39.Value;
      }

      srcBuffer = _temp39;
      srcByteIndex = new Value(0);
    } else {
      srcByteIndex = srcByteOffset;
    }

    let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;
    const limit = targetByteIndex + targetElementSize * srcLength;

    if (SameValue(new Value(srcType), new Value(targetType)) === Value.true) {
      while (targetByteIndex < limit) {
        const value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'Uint8');
        SetValueInBuffer(targetBuffer, new Value(targetByteIndex), 'Uint8', value);
        srcByteIndex = new Value(srcByteIndex.numberValue() + 1);
        targetByteIndex += 1;
      }
    } else {
      while (targetByteIndex < limit) {
        const value = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType);
        SetValueInBuffer(targetBuffer, new Value(targetByteIndex), targetType, value);
        srcByteIndex = new Value(srcByteIndex.numberValue() + srcElementSize);
        targetByteIndex += targetElementSize;
      }
    }

    return Value.undefined;
  }
} // 22.2.3.24 #sec-%typedarray%.prototype.slice


function TypedArrayProto_slice([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  const O = thisValue;

  let _temp40 = ValidateTypedArray(O);

  if (_temp40 instanceof AbruptCompletion) {
    return _temp40;
  }

  if (_temp40 instanceof Completion) {
    _temp40 = _temp40.Value;
  }
  const len = O.ArrayLength.numberValue();

  let _temp41 = ToInteger(start);

  if (_temp41 instanceof AbruptCompletion) {
    return _temp41;
  }

  if (_temp41 instanceof Completion) {
    _temp41 = _temp41.Value;
  }

  const relativeStart = _temp41.numberValue();

  let k;

  if (relativeStart < 0) {
    k = Math.max(len + relativeStart, 0);
  } else {
    k = Math.min(relativeStart, len);
  }

  let relativeEnd;

  if (end === Value.undefined) {
    relativeEnd = len;
  } else {
    let _temp42 = ToInteger(end);

    if (_temp42 instanceof AbruptCompletion) {
      return _temp42;
    }

    if (_temp42 instanceof Completion) {
      _temp42 = _temp42.Value;
    }

    relativeEnd = _temp42.numberValue();
  }

  let final;

  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }

  const count = Math.max(final - k, 0);

  let _temp43 = TypedArraySpeciesCreate(O, [new Value(count)]);

  if (_temp43 instanceof AbruptCompletion) {
    return _temp43;
  }

  if (_temp43 instanceof Completion) {
    _temp43 = _temp43.Value;
  }

  const A = _temp43;
  const srcName = O.TypedArrayName.stringValue();
  const srcInfo = typedArrayInfo.get(srcName);
  const srcType = srcInfo.ElementType;
  const targetName = A.TypedArrayName.stringValue();
  const targetType = typedArrayInfo.get(targetName).ElementType;

  if (srcType !== targetType) {
    let n = 0;

    while (k < final) {
      let _temp44 = ToString(new Value(k));

      Assert(!(_temp44 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

      if (_temp44 instanceof Completion) {
        _temp44 = _temp44.Value;
      }

      const Pk = _temp44;

      let _temp45 = Get(O, Pk);

      if (_temp45 instanceof AbruptCompletion) {
        return _temp45;
      }

      if (_temp45 instanceof Completion) {
        _temp45 = _temp45.Value;
      }

      const kValue = _temp45;

      let _temp46 = ToString(new Value(n));

      Assert(!(_temp46 instanceof AbruptCompletion), "ToString(new Value(n))" + ' returned an abrupt completion');

      if (_temp46 instanceof Completion) {
        _temp46 = _temp46.Value;
      }

      const nStr = _temp46;

      let _temp47 = Set$1(A, nStr, kValue, Value.true);

      Assert(!(_temp47 instanceof AbruptCompletion), "Set(A, nStr, kValue, Value.true)" + ' returned an abrupt completion');

      if (_temp47 instanceof Completion) {
        _temp47 = _temp47.Value;
      }
      k += 1;
      n += 1;
    }
  } else if (count > 0) {
    const srcBuffer = O.ViewedArrayBuffer;

    if (IsDetachedBuffer(srcBuffer)) {
      return surroundingAgent.Throw('TypeError', 'BufferDetached');
    }

    const targetBuffer = A.ViewedArrayBuffer;
    const elementSize = srcInfo.ElementSize;
    const srcByteOffset = O.ByteOffset.numberValue();
    let targetByteIndex = A.ByteOffset.numberValue();
    let srcByteIndex = k * elementSize + srcByteOffset;
    const limit = targetByteIndex + count * elementSize;

    while (targetByteIndex < limit) {
      const value = GetValueFromBuffer(srcBuffer, new Value(srcByteIndex), 'Uint8');
      SetValueInBuffer(targetBuffer, new Value(targetByteIndex), 'Uint8', value);
      srcByteIndex += 1;
      targetByteIndex += 1;
    }
  }

  return A;
} // 22.2.3.26 #sec-%typedarray%.prototype.sort


function TypedArrayProto_sort([comparefn = Value.undefined], {
  thisValue
}) {
  if (comparefn !== Value.undefined && IsCallable(comparefn) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', comparefn);
  }

  let _temp48 = ToObject(thisValue);

  if (_temp48 instanceof AbruptCompletion) {
    return _temp48;
  }

  if (_temp48 instanceof Completion) {
    _temp48 = _temp48.Value;
  }

  const obj = _temp48;

  let _temp49 = ValidateTypedArray(obj);

  if (_temp49 instanceof AbruptCompletion) {
    return _temp49;
  }

  if (_temp49 instanceof Completion) {
    _temp49 = _temp49.Value;
  }

  const buffer = _temp49;
  const len = obj.ArrayLength;
  return ArrayProto_sortBody(obj, len, (x, y) => TypedArraySortCompare(x, y, comparefn, buffer), true);
}

function TypedArraySortCompare(x, y, comparefn, buffer) {
  Assert(Type(x) === 'Number', "Type(x) === 'Number'");
  Assert(Type(y) === 'Number', "Type(y) === 'Number'");

  if (comparefn !== Value.undefined) {
    let _temp50 = Call(comparefn, Value.undefined, [x, y]);

    if (_temp50 instanceof AbruptCompletion) {
      return _temp50;
    }

    if (_temp50 instanceof Completion) {
      _temp50 = _temp50.Value;
    }

    const callRes = _temp50;

    let _temp51 = ToNumber(callRes);

    if (_temp51 instanceof AbruptCompletion) {
      return _temp51;
    }

    if (_temp51 instanceof Completion) {
      _temp51 = _temp51.Value;
    }

    const v = _temp51;

    if (IsDetachedBuffer(buffer)) {
      return surroundingAgent.Throw('TypeError', 'BufferDetached');
    }

    if (v.isNaN()) {
      return new Value(+0);
    }

    return v;
  }

  if (x.isNaN() && y.isNaN()) {
    return new Value(+0);
  }

  if (x.isNaN()) {
    return new Value(1);
  }

  if (y.isNaN()) {
    return new Value(-1);
  }

  x = x.numberValue();
  y = y.numberValue();

  if (x < y) {
    return new Value(-1);
  }

  if (x > y) {
    return new Value(1);
  }

  if (Object.is(x, -0) && Object.is(y, +0)) {
    return new Value(-1);
  }

  if (Object.is(x, +0) && Object.is(y, -0)) {
    return new Value(1);
  }

  return new Value(+0);
} // 22.2.3.27 #sec-%typedarray%.prototype.subarray


function TypedArrayProto_subarray([begin = Value.undefined, end], {
  thisValue
}) {
  const O = thisValue;

  let _temp52 = RequireInternalSlot(O, 'TypedArrayName');

  if (_temp52 instanceof AbruptCompletion) {
    return _temp52;
  }

  if (_temp52 instanceof Completion) {
    _temp52 = _temp52.Value;
  }
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;
  const srcLength = O.ArrayLength.numberValue();

  let _temp53 = ToInteger(begin);

  if (_temp53 instanceof AbruptCompletion) {
    return _temp53;
  }

  if (_temp53 instanceof Completion) {
    _temp53 = _temp53.Value;
  }

  const relativeBegin = _temp53.numberValue();

  let beginIndex;

  if (relativeBegin < 0) {
    beginIndex = Math.max(srcLength + relativeBegin, 0);
  } else {
    beginIndex = Math.min(relativeBegin, srcLength);
  }

  let relativeEnd;

  if (end === undefined || end === Value.undefined) {
    relativeEnd = srcLength;
  } else {
    let _temp54 = ToInteger(end);

    if (_temp54 instanceof AbruptCompletion) {
      return _temp54;
    }

    if (_temp54 instanceof Completion) {
      _temp54 = _temp54.Value;
    }

    relativeEnd = _temp54.numberValue();
  }

  let endIndex;

  if (relativeEnd < 0) {
    endIndex = Math.max(srcLength + relativeEnd, 0);
  } else {
    endIndex = Math.min(relativeEnd, srcLength);
  }

  const newLength = Math.max(endIndex - beginIndex, 0);
  const constructorName = O.TypedArrayName.stringValue();
  const elementSize = typedArrayInfo.get(constructorName).ElementSize;
  const srcByteOffset = O.ByteOffset.numberValue();
  const beginByteOffset = srcByteOffset + beginIndex * elementSize;
  const argumentsList = [buffer, new Value(beginByteOffset), new Value(newLength)];
  return TypedArraySpeciesCreate(O, argumentsList);
} // 22.2.3.30 #sec-%typedarray%.prototype.values


function TypedArrayProto_values(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp55 = ValidateTypedArray(O);

  if (_temp55 instanceof AbruptCompletion) {
    return _temp55;
  }

  if (_temp55 instanceof Completion) {
    _temp55 = _temp55.Value;
  }
  return CreateArrayIterator(O, 'value');
} // 22.2.3.32 #sec-get-%typedarray%.prototype-@@tostringtag


function TypedArrayProto_toStringTagGetter(args, {
  thisValue
}) {
  const O = thisValue;

  if (Type(O) !== 'Object' || !('TypedArrayName' in O)) {
    return Value.undefined;
  }

  const name = O.TypedArrayName;
  Assert(Type(name) === 'String', "Type(name) === 'String'");
  return name;
}

function CreateTypedArrayPrototype(realmRec) {
  let _temp56 = Get(realmRec.Intrinsics['%Array.prototype%'], new Value('toString'));

  Assert(!(_temp56 instanceof AbruptCompletion), "Get(realmRec.Intrinsics['%Array.prototype%'], new Value('toString'))" + ' returned an abrupt completion');

  if (_temp56 instanceof Completion) {
    _temp56 = _temp56.Value;
  }

  const ArrayProto_toString = _temp56;
  Assert(Type(ArrayProto_toString) === 'Object', "Type(ArrayProto_toString) === 'Object'");
  const proto = BootstrapPrototype(realmRec, [['buffer', [TypedArrayProto_bufferGetter]], ['byteLength', [TypedArrayProto_byteLengthGetter]], ['byteOffset', [TypedArrayProto_byteOffsetGetter]], ['copyWithin', TypedArrayProto_copyWithin, 2], ['entries', TypedArrayProto_entries, 0], ['fill', TypedArrayProto_fill, 1], ['filter', TypedArrayProto_filter, 1], ['keys', TypedArrayProto_keys, 0], ['length', [TypedArrayProto_lengthGetter]], ['map', TypedArrayProto_map, 1], ['set', TypedArrayProto_set, 1], ['slice', TypedArrayProto_slice, 2], ['sort', TypedArrayProto_sort, 1], ['subarray', TypedArrayProto_subarray, 2], ['values', TypedArrayProto_values, 0], ['toString', ArrayProto_toString], [wellKnownSymbols.toStringTag, [TypedArrayProto_toStringTagGetter]]], realmRec.Intrinsics['%Object.prototype%']);
  CreateArrayPrototypeShared(realmRec, proto, thisValue => {
    let _temp57 = ValidateTypedArray(thisValue);

    if (_temp57 instanceof AbruptCompletion) {
      return _temp57;
    }

    if (_temp57 instanceof Completion) {
      _temp57 = _temp57.Value;
    }
  }, O => O.ArrayLength); // 22.2.3.31 #sec-%typedarray%.prototype-@@iterator

  {
    let _temp58 = Get(proto, new Value('values'));

    Assert(!(_temp58 instanceof AbruptCompletion), "Get(proto, new Value('values'))" + ' returned an abrupt completion');

    if (_temp58 instanceof Completion) {
      _temp58 = _temp58.Value;
    }

    const fn = _temp58;

    let _temp59 = proto.DefineOwnProperty(wellKnownSymbols.iterator, Descriptor({
      Value: fn,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));

    Assert(!(_temp59 instanceof AbruptCompletion), "proto.DefineOwnProperty(wellKnownSymbols.iterator, Descriptor({\n      Value: fn,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    }))" + ' returned an abrupt completion');

    if (_temp59 instanceof Completion) {
      _temp59 = _temp59.Value;
    }
  }
  realmRec.Intrinsics['%TypedArray.prototype%'] = proto;
}

function CreateTypedArrayConstructor(realmRec, TypedArray) {
  const info = typedArrayInfo.get(TypedArray);
  Assert(info !== undefined, "info !== undefined");

  function TypedArrayConstructor(args, {
    NewTarget
  }) {
    if (args.length === 0) {
      // 22.2.4.1 #sec-typedarray
      if (NewTarget === Value.undefined) {
        return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', TypedArray);
      }

      const constructorName = new Value(TypedArray);
      return AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}.prototype%`, new Value(0));
    } else if (Type(args[0]) !== 'Object') {
      // 22.2.4.2 #sec-typedarray-length
      const [length] = args;
      Assert(Type(length) !== 'Object', "Type(length) !== 'Object'");

      if (NewTarget === Value.undefined) {
        return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', TypedArray);
      }

      let _temp = ToIndex(length);
      /* istanbul ignore if */


      if (_temp instanceof AbruptCompletion) {
        return _temp;
      }
      /* istanbul ignore if */


      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      const elementLength = _temp;
      const constructorName = new Value(TypedArray);
      return AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}.prototype%`, elementLength);
    } else if ('TypedArrayName' in args[0]) {
      // 22.2.4.3 #sec-typedarray-typedarray
      const [typedArray] = args;
      Assert(Type(typedArray) === 'Object' && 'TypedArrayName' in typedArray, "Type(typedArray) === 'Object' && 'TypedArrayName' in typedArray");

      if (NewTarget === Value.undefined) {
        return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', TypedArray);
      }

      const constructorName = new Value(TypedArray);

      let _temp2 = AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}.prototype%`);

      if (_temp2 instanceof AbruptCompletion) {
        return _temp2;
      }

      if (_temp2 instanceof Completion) {
        _temp2 = _temp2.Value;
      }

      const O = _temp2;
      const srcArray = typedArray;
      const srcData = srcArray.ViewedArrayBuffer;

      if (IsDetachedBuffer(srcData)) {
        return surroundingAgent.Throw('TypeError', 'BufferDetached');
      }

      const elementType = new Value(info.ElementType);
      const elementLength = srcArray.ArrayLength;
      const srcName = srcArray.TypedArrayName.stringValue();
      const srcInfo = typedArrayInfo.get(srcName);
      const srcType = new Value(srcInfo.ElementType);
      const srcElementSize = srcInfo.ElementSize;
      const srcByteOffset = srcArray.ByteOffset;
      const elementSize = info.ElementSize;
      const byteLength = new Value(elementSize * elementLength.numberValue()); // if (!IsSharedArrayBuffer(srcData)) {

      let _temp3 = SpeciesConstructor(srcData, surroundingAgent.intrinsic('%ArrayBuffer%'));

      if (_temp3 instanceof AbruptCompletion) {
        return _temp3;
      }

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      const bufferConstructor = _temp3; // } else {
      //   bufferConstructor = surroundingAgent.intrinsic('%ArrayBuffer%');
      // }

      let data;

      if (SameValue(elementType, srcType) === Value.true) {
        let _temp4 = CloneArrayBuffer(srcData, srcByteOffset, byteLength, bufferConstructor);

        if (_temp4 instanceof AbruptCompletion) {
          return _temp4;
        }

        if (_temp4 instanceof Completion) {
          _temp4 = _temp4.Value;
        }

        data = _temp4;
      } else {
        let _temp5 = AllocateArrayBuffer(bufferConstructor, byteLength);

        if (_temp5 instanceof AbruptCompletion) {
          return _temp5;
        }

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }

        data = _temp5;

        if (IsDetachedBuffer(srcData)) {
          return surroundingAgent.Throw('TypeError', 'BufferDetached');
        }

        let srcByteIndex = srcByteOffset.numberValue();
        let targetByteIndex = 0;
        let count = elementLength.numberValue();

        while (count > 0) {
          const value = GetValueFromBuffer(srcData, new Value(srcByteIndex), srcType.stringValue());
          SetValueInBuffer(data, new Value(targetByteIndex), elementType.stringValue(), value);
          srcByteIndex += srcElementSize;
          targetByteIndex += elementSize;
          count -= 1;
        }
      }

      O.ViewedArrayBuffer = data;
      O.ByteLength = byteLength;
      O.ByteOffset = new Value(0);
      O.ArrayLength = elementLength;
      return O;
    } else if (!('TypedArrayName' in args[0]) && !('ArrayBufferData' in args[0])) {
      // 22.2.4.4 #sec-typedarray-object
      const [object] = args;
      Assert(Type(object) === 'Object' && !('TypedArrayName' in object) && !('ArrayBufferData' in object), "Type(object) === 'Object' && !('TypedArrayName' in object) && !('ArrayBufferData' in object)");

      if (NewTarget === Value.undefined) {
        return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', TypedArray);
      }

      const constructorName = new Value(TypedArray);

      let _temp6 = AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}.prototype%`);

      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }

      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }

      const O = _temp6;

      let _temp7 = GetMethod(object, wellKnownSymbols.iterator);

      if (_temp7 instanceof AbruptCompletion) {
        return _temp7;
      }

      if (_temp7 instanceof Completion) {
        _temp7 = _temp7.Value;
      }

      const usingIterator = _temp7;

      if (usingIterator !== Value.undefined) {
        let _temp8 = IterableToList(object, usingIterator);

        if (_temp8 instanceof AbruptCompletion) {
          return _temp8;
        }

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }

        const values = _temp8;
        const len = values.length;

        let _temp9 = AllocateTypedArrayBuffer(O, new Value(len));

        if (_temp9 instanceof AbruptCompletion) {
          return _temp9;
        }

        if (_temp9 instanceof Completion) {
          _temp9 = _temp9.Value;
        }
        let k = 0;

        while (k < len) {
          let _temp10 = ToString(new Value(k));

          Assert(!(_temp10 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');
          /* istanbul ignore if */

          if (_temp10 instanceof Completion) {
            _temp10 = _temp10.Value;
          }

          const Pk = _temp10;
          const kValue = values.shift();

          let _temp11 = Set$1(O, Pk, kValue, Value.true);

          if (_temp11 instanceof AbruptCompletion) {
            return _temp11;
          }

          if (_temp11 instanceof Completion) {
            _temp11 = _temp11.Value;
          }
          k += 1;
        }

        Assert(values.length === 0, "values.length === 0");
        return O;
      }

      const arrayLike = object;

      let _temp12 = LengthOfArrayLike(arrayLike);

      if (_temp12 instanceof AbruptCompletion) {
        return _temp12;
      }

      if (_temp12 instanceof Completion) {
        _temp12 = _temp12.Value;
      }

      const len = _temp12;

      let _temp13 = AllocateTypedArrayBuffer(O, len);

      if (_temp13 instanceof AbruptCompletion) {
        return _temp13;
      }

      if (_temp13 instanceof Completion) {
        _temp13 = _temp13.Value;
      }
      let k = 0;

      while (k < len.numberValue()) {
        let _temp14 = ToString(new Value(k));

        Assert(!(_temp14 instanceof AbruptCompletion), "ToString(new Value(k))" + ' returned an abrupt completion');

        if (_temp14 instanceof Completion) {
          _temp14 = _temp14.Value;
        }

        const Pk = _temp14;

        let _temp15 = Get(arrayLike, Pk);

        if (_temp15 instanceof AbruptCompletion) {
          return _temp15;
        }

        if (_temp15 instanceof Completion) {
          _temp15 = _temp15.Value;
        }

        const kValue = _temp15;

        let _temp16 = Set$1(O, Pk, kValue, Value.true);

        if (_temp16 instanceof AbruptCompletion) {
          return _temp16;
        }

        if (_temp16 instanceof Completion) {
          _temp16 = _temp16.Value;
        }
        k += 1;
      }

      return O;
    } else {
      // 22.2.4.5 #sec-typedarray-buffer-byteoffset-length
      const [buffer, byteOffset = Value.undefined, length = Value.undefined] = args;
      Assert(Type(buffer) === 'Object' && 'ArrayBufferData' in buffer, "Type(buffer) === 'Object' && 'ArrayBufferData' in buffer");

      if (NewTarget === Value.undefined) {
        return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', TypedArray);
      }

      const constructorName = new Value(TypedArray);

      let _temp17 = AllocateTypedArray(constructorName, NewTarget, `%${TypedArray}.prototype%`);

      if (_temp17 instanceof AbruptCompletion) {
        return _temp17;
      }

      if (_temp17 instanceof Completion) {
        _temp17 = _temp17.Value;
      }

      const O = _temp17;
      const elementSize = info.ElementSize;

      let _temp18 = ToIndex(byteOffset);

      if (_temp18 instanceof AbruptCompletion) {
        return _temp18;
      }

      if (_temp18 instanceof Completion) {
        _temp18 = _temp18.Value;
      }

      const offset = _temp18;

      if (offset.numberValue() % elementSize !== 0) {
        return surroundingAgent.Throw('RangeError', 'TypedArrayOffsetAlignment', TypedArray, elementSize);
      }

      let newLength;

      if (length !== Value.undefined) {
        let _temp19 = ToIndex(length);

        if (_temp19 instanceof AbruptCompletion) {
          return _temp19;
        }

        if (_temp19 instanceof Completion) {
          _temp19 = _temp19.Value;
        }

        newLength = _temp19.numberValue();
      }

      if (IsDetachedBuffer(buffer)) {
        return surroundingAgent.Throw('TypeError', 'BufferDetached');
      }

      const bufferByteLength = buffer.ArrayBufferByteLength.numberValue();
      let newByteLength;

      if (length === Value.undefined) {
        if (bufferByteLength % elementSize !== 0) {
          return surroundingAgent.Throw('RangeError', 'TypedArrayLengthAlignment', TypedArray, elementSize);
        }

        newByteLength = bufferByteLength - offset.numberValue();

        if (newByteLength < 0) {
          return surroundingAgent.Throw('RangeError', 'TypedArrayCreationOOB');
        }
      } else {
        newByteLength = newLength * elementSize;

        if (offset.numberValue() + newByteLength > bufferByteLength) {
          return surroundingAgent.Throw('RangeError', 'TypedArrayCreationOOB');
        }
      }

      O.ViewedArrayBuffer = buffer;
      O.ByteLength = new Value(newByteLength);
      O.ByteOffset = offset;
      Assert(Number.isSafeInteger(newByteLength / elementSize), "Number.isSafeInteger(newByteLength / elementSize)");
      O.ArrayLength = new Value(newByteLength / elementSize);
      return O;
    }
  }

  const readonly = {
    Writable: Value.false,
    Configurable: Value.false
  };
  const taConstructor = BootstrapConstructor(realmRec, TypedArrayConstructor, TypedArray, 3, realmRec.Intrinsics[`%${TypedArray}.prototype%`], [['BYTES_PER_ELEMENT', new Value(info.ElementSize), undefined, readonly]]);

  let _temp20 = taConstructor.SetPrototypeOf(realmRec.Intrinsics['%TypedArray%']);

  Assert(!(_temp20 instanceof AbruptCompletion), "taConstructor.SetPrototypeOf(realmRec.Intrinsics['%TypedArray%'])" + ' returned an abrupt completion');

  if (_temp20 instanceof Completion) {
    _temp20 = _temp20.Value;
  }
  realmRec.Intrinsics[`%${TypedArray}%`] = taConstructor;
}

function CreateTypedArrayConstructors(realmRec) {
  for (const TypedArray of typedArrayInfo.keys()) {
    CreateTypedArrayConstructor(realmRec, TypedArray);
  }
}

function CreateTypedArrayPrototype$1(realmRec, TypedArray) {
  const info = typedArrayInfo.get(TypedArray);
  Assert(info !== undefined, "info !== undefined");
  const readonly = {
    Writable: Value.false,
    Configurable: Value.false
  };
  const proto = BootstrapPrototype(realmRec, [['BYTES_PER_ELEMENT', new Value(info.ElementSize), undefined, readonly]], realmRec.Intrinsics['%TypedArray.prototype%']);
  realmRec.Intrinsics[`%${TypedArray}.prototype%`] = proto;
}

function CreateTypedArrayPrototypes(realmRec) {
  for (const TypedArray of typedArrayInfo.keys()) {
    CreateTypedArrayPrototype$1(realmRec, TypedArray);
  }
}

function DataViewConstructor([buffer = Value.undefined, byteOffset = Value.undefined, byteLength = Value.undefined], {
  NewTarget
}) {
  if (Type(NewTarget) === 'Undefined') {
    return surroundingAgent.Throw('TypeError', 'ConstructorRequiresNew', 'DataView');
  }

  let _temp = RequireInternalSlot(buffer, 'ArrayBufferData');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let _temp2 = ToIndex(byteOffset);

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }

  const offset = _temp2.numberValue();

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const bufferByteLength = buffer.ArrayBufferByteLength.numberValue();

  if (offset > bufferByteLength) {
    return surroundingAgent.Throw('RangeError', 'DataViewOOB');
  }

  let viewByteLength;

  if (byteLength === Value.undefined) {
    viewByteLength = bufferByteLength - offset;
  } else {
    let _temp3 = ToIndex(byteLength);

    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }

    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }

    viewByteLength = _temp3.numberValue();

    if (offset + viewByteLength > bufferByteLength) {
      return surroundingAgent.Throw('RangeError', 'DataViewOOB');
    }
  }

  let _temp4 = OrdinaryCreateFromConstructor(NewTarget, '%DataView.prototype%', ['DataView', 'ViewedArrayBuffer', 'ByteLength', 'ByteOffset']);

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }

  const O = _temp4;

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  O.ViewedArrayBuffer = buffer;
  O.ByteLength = new Value(viewByteLength);
  O.ByteOffset = new Value(offset);
  return O;
}

function CreateDataView(realmRec) {
  const dvConstructor = BootstrapConstructor(realmRec, DataViewConstructor, 'DataView', 1, realmRec.Intrinsics['%DataView.prototype%'], []);
  realmRec.Intrinsics['%DataView%'] = dvConstructor;
}

function DataViewProto_bufferGetter(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp = RequireInternalSlot(O, 'DataView');
  /* istanbul ignore if */


  if (_temp instanceof AbruptCompletion) {
    return _temp;
  }
  /* istanbul ignore if */


  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;
  return buffer;
} // 24.3.4.2 #sec-get-dataview.prototype.bytelength


function DataViewProto_byteLengthGetter(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp2 = RequireInternalSlot(O, 'DataView');

  if (_temp2 instanceof AbruptCompletion) {
    return _temp2;
  }

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const size = O.ByteLength;
  return size;
} // 24.3.4.3 #sec-get-dataview.prototype.byteoffset


function DataViewProto_byteOffsetGetter(args, {
  thisValue
}) {
  const O = thisValue;

  let _temp3 = RequireInternalSlot(O, 'DataView');

  if (_temp3 instanceof AbruptCompletion) {
    return _temp3;
  }

  if (_temp3 instanceof Completion) {
    _temp3 = _temp3.Value;
  }
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;

  if (IsDetachedBuffer(buffer)) {
    return surroundingAgent.Throw('TypeError', 'BufferDetached');
  }

  const offset = O.ByteOffset;
  return offset;
} // 24.3.4.5 #sec-dataview.prototype.getfloat32


function DataViewProto_getFloat32([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return GetViewValue(v, byteOffset, littleEndian, 'Float32');
} // 24.3.4.6 #sec-dataview.prototype.getfloat64


function DataViewProto_getFloat64([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return GetViewValue(v, byteOffset, littleEndian, 'Float64');
} // 24.3.4.7 #sec-dataview.prototype.getint8


function DataViewProto_getInt8([byteOffset = Value.undefined], {
  thisValue
}) {
  const v = thisValue;
  return GetViewValue(v, byteOffset, Value.true, 'Int8');
} // 24.3.4.8 #sec-dataview.prototype.getint16


function DataViewProto_getInt16([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return GetViewValue(v, byteOffset, littleEndian, 'Int16');
} // 24.3.4.9 #sec-dataview.prototype.getint32


function DataViewProto_getInt32([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return GetViewValue(v, byteOffset, littleEndian, 'Int32');
} // 24.3.4.10 #sec-dataview.prototype.getuint8


function DataViewProto_getUint8([byteOffset = Value.undefined], {
  thisValue
}) {
  const v = thisValue;
  return GetViewValue(v, byteOffset, Value.true, 'Uint8');
} // 24.3.4.11 #sec-dataview.prototype.getuint16


function DataViewProto_getUint16([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return GetViewValue(v, byteOffset, littleEndian, 'Uint16');
} // 24.3.4.12 #sec-dataview.prototype.getuint32


function DataViewProto_getUint32([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return GetViewValue(v, byteOffset, littleEndian, 'Uint32');
} // 24.3.4.13 #sec-dataview.prototype.setfloat32


function DataViewProto_setFloat32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return SetViewValue(v, byteOffset, littleEndian, 'Float32', value);
} // 24.3.4.14 #sec-dataview.prototype.setfloat64


function DataViewProto_setFloat64([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return SetViewValue(v, byteOffset, littleEndian, 'Float64', value);
} // 24.3.4.15 #sec-dataview.prototype.setint8


function DataViewProto_setInt8([byteOffset = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  const v = thisValue;
  return SetViewValue(v, byteOffset, Value.true, 'Int8', value);
} // 24.3.4.16 #sec-dataview.prototype.setint16


function DataViewProto_setInt16([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return SetViewValue(v, byteOffset, littleEndian, 'Int16', value);
} // 24.3.4.17 #sec-dataview.prototype.setint32


function DataViewProto_setInt32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return SetViewValue(v, byteOffset, littleEndian, 'Int32', value);
} // 24.3.4.18 #sec-dataview.prototype.setuint8


function DataViewProto_setUint8([byteOffset = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  const v = thisValue;
  return SetViewValue(v, byteOffset, Value.true, 'Uint8', value);
} // 24.3.4.19 #sec-dataview.prototype.setuint16


function DataViewProto_setUint16([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return SetViewValue(v, byteOffset, littleEndian, 'Uint16', value);
} // 24.3.4.20 #sec-dataview.prototype.setuint32


function DataViewProto_setUint32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;

  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }

  return SetViewValue(v, byteOffset, littleEndian, 'Uint32', value);
}

function CreateDataViewPrototype(realmRec) {
  const proto = BootstrapPrototype(realmRec, [['buffer', [DataViewProto_bufferGetter]], ['byteLength', [DataViewProto_byteLengthGetter]], ['byteOffset', [DataViewProto_byteOffsetGetter]], ['getFloat32', DataViewProto_getFloat32, 1], ['getFloat64', DataViewProto_getFloat64, 1], ['getInt8', DataViewProto_getInt8, 1], ['getInt16', DataViewProto_getInt16, 1], ['getInt32', DataViewProto_getInt32, 1], ['getUint8', DataViewProto_getUint8, 1], ['getUint16', DataViewProto_getUint16, 1], ['getUint32', DataViewProto_getUint32, 1], ['setFloat32', DataViewProto_setFloat32, 2], ['setFloat64', DataViewProto_setFloat64, 2], ['setInt8', DataViewProto_setInt8, 2], ['setInt16', DataViewProto_setInt16, 2], ['setInt32', DataViewProto_setInt32, 2], ['setUint8', DataViewProto_setUint8, 2], ['setUint16', DataViewProto_setUint16, 2], ['setUint32', DataViewProto_setUint32, 2]], realmRec.Intrinsics['%Object.prototype%'], 'DataView');
  realmRec.Intrinsics['%DataView.prototype%'] = proto;
}

class Realm {
  constructor() {
    this.Intrinsics = undefined;
    this.GlobalObject = undefined;
    this.GlobalEnv = undefined;
    this.TemplateMap = undefined;
    this.HostDefined = undefined;
  }

} // 8.2.1 #sec-createrealm

function CreateRealm() {
  const realmRec = new Realm();
  CreateIntrinsics(realmRec);
  realmRec.GlobalObject = Value.undefined;
  realmRec.GlobalEnv = Value.undefined;
  realmRec.TemplateMap = [];
  return realmRec;
}

function AddRestrictedFunctionProperties(F, realm) {
  Assert(realm.Intrinsics['%ThrowTypeError%'], "realm.Intrinsics['%ThrowTypeError%']");
  const thrower = realm.Intrinsics['%ThrowTypeError%'];

  let _temp = DefinePropertyOrThrow(F, new Value('caller'), Descriptor({
    Get: thrower,
    Set: thrower,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('caller'), Descriptor({\n    Get: thrower,\n    Set: thrower,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');
  /* istanbul ignore if */

  if (_temp instanceof Completion) {
    _temp = _temp.Value;
  }

  let _temp2 = DefinePropertyOrThrow(F, new Value('arguments'), Descriptor({
    Get: thrower,
    Set: thrower,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  Assert(!(_temp2 instanceof AbruptCompletion), "DefinePropertyOrThrow(F, new Value('arguments'), Descriptor({\n    Get: thrower,\n    Set: thrower,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  }))" + ' returned an abrupt completion');

  if (_temp2 instanceof Completion) {
    _temp2 = _temp2.Value;
  }
} // 8.2.2 #sec-createintrinsics


function CreateIntrinsics(realmRec) {
  const intrinsics = Object.create(null);
  realmRec.Intrinsics = intrinsics;
  intrinsics['%Object.prototype%'] = ObjectCreate(Value.null);
  CreateFunctionPrototype(realmRec);
  CreateObjectPrototype(realmRec);
  CreateThrowTypeError(realmRec);
  CreateEval(realmRec);
  CreateIsFinite(realmRec);
  CreateIsNaN(realmRec);
  CreateParseFloat(realmRec);
  CreateParseInt(realmRec);
  CreateObject(realmRec);
  CreateErrorPrototype(realmRec);
  CreateError(realmRec);
  CreateNativeError(realmRec);
  CreateFunction(realmRec);
  CreateIteratorPrototype(realmRec);
  CreateAsyncIteratorPrototype(realmRec);
  CreateArrayIteratorPrototype(realmRec);
  CreateMapIteratorPrototype(realmRec);
  CreateSetIteratorPrototype(realmRec);
  CreateStringIteratorPrototype(realmRec);
  CreateRegExpStringIteratorPrototype(realmRec);
  CreateStringPrototype(realmRec);
  CreateString(realmRec);
  CreateArrayPrototype(realmRec);
  CreateArray(realmRec);
  CreateBooleanPrototype(realmRec);
  CreateBoolean(realmRec);
  CreateNumberPrototype(realmRec);
  CreateNumber(realmRec);
  CreateBigIntPrototype(realmRec);
  CreateBigInt(realmRec);
  CreateSymbolPrototype(realmRec);
  CreateSymbol(realmRec);
  CreatePromisePrototype(realmRec);
  CreatePromise(realmRec);
  CreateProxy(realmRec);
  CreateReflect(realmRec);
  CreateMath(realmRec);
  CreateDatePrototype(realmRec);
  CreateDate(realmRec);
  CreateRegExpPrototype(realmRec);
  CreateRegExp(realmRec);
  CreateSetPrototype(realmRec);
  CreateSet(realmRec);
  CreateMapPrototype(realmRec);
  CreateMap(realmRec);
  CreateGeneratorPrototype(realmRec);
  CreateGenerator(realmRec);
  CreateGeneratorFunction(realmRec);
  CreateAsyncFunctionPrototype(realmRec);
  CreateAsyncFunction(realmRec);
  CreateAsyncGeneratorPrototype(realmRec);
  CreateAsyncGenerator(realmRec);
  CreateAsyncGeneratorFunction(realmRec);
  CreateAsyncFromSyncIteratorPrototype(realmRec);
  CreateArrayBufferPrototype(realmRec);
  CreateArrayBuffer(realmRec);
  CreateTypedArrayPrototype(realmRec);
  CreateTypedArray(realmRec);
  CreateTypedArrayPrototypes(realmRec);
  CreateTypedArrayConstructors(realmRec);
  CreateDataViewPrototype(realmRec);
  CreateDataView(realmRec);
  CreateJSON(realmRec);
  AddRestrictedFunctionProperties(intrinsics['%Function.prototype%'], realmRec);
  return intrinsics;
} // 8.2.3 #sec-setrealmglobalobject

function SetRealmGlobalObject(realmRec, globalObj, thisValue) {
  const intrinsics = realmRec.Intrinsics;

  if (globalObj === Value.undefined) {
    globalObj = ObjectCreate(intrinsics['%Object.prototype%']);
  }

  if (thisValue === Value.undefined) {
    thisValue = globalObj;
  }

  realmRec.GlobalObject = globalObj;
  const newGlobalEnv = NewGlobalEnvironment(globalObj, thisValue);
  realmRec.GlobalEnv = newGlobalEnv;
  return realmRec;
} // 8.2.4 #sec-setdefaultglobalbindings

function SetDefaultGlobalBindings(realmRec) {
  const global = realmRec.GlobalObject; // Value Properties of the Global Object

  [['Infinity', new Value(Infinity)], ['NaN', new Value(NaN)], ['undefined', Value.undefined]].forEach(([name, value]) => {
    let _temp3 = DefinePropertyOrThrow(global, new Value(name), Descriptor({
      Value: value,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    /* istanbul ignore if */


    if (_temp3 instanceof AbruptCompletion) {
      return _temp3;
    }
    /* istanbul ignore if */


    if (_temp3 instanceof Completion) {
      _temp3 = _temp3.Value;
    }
  });

  let _temp4 = DefinePropertyOrThrow(global, new Value('globalThis'), Descriptor({
    Value: realmRec.GlobalEnv.EnvironmentRecord.GlobalThisValue,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));

  if (_temp4 instanceof AbruptCompletion) {
    return _temp4;
  }

  if (_temp4 instanceof Completion) {
    _temp4 = _temp4.Value;
  }
  [// Function Properties of the Global Object
  'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', // 'decodeURI',
  // 'decodeURIComponent',
  // 'encodeURI',
  // 'encodeURIComponent',
  // Constructor Properties of the Global Object
  'Array', 'ArrayBuffer', 'Boolean', 'BigInt', 'DataView', 'Date', 'Error', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Number', 'Object', 'Promise', 'Proxy', 'RangeError', 'ReferenceError', 'RegExp', 'Set', // 'SharedArrayBuffer',
  'String', 'Symbol', 'SyntaxError', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'URIError', // 'WeakMap',
  // 'WeakSet',
  // Other Properties of the Global Object
  // 'Atomics',
  'JSON', 'Math', 'Reflect'].forEach(name => {
    let _temp5 = DefinePropertyOrThrow(global, new Value(name), Descriptor({
      Value: realmRec.Intrinsics[`%${name}%`],
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));

    if (_temp5 instanceof AbruptCompletion) {
      return _temp5;
    }

    if (_temp5 instanceof Completion) {
      _temp5 = _temp5.Value;
    }
  });
  return global;
}

const bareKeyRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;

const getObjectTag = (value, wrap) => {
  try {
    let _temp = Get(value, wellKnownSymbols.toStringTag);

    Assert(!(_temp instanceof AbruptCompletion), "Get(value, wellKnownSymbols.toStringTag)" + ' returned an abrupt completion', "");
    /* istanbul ignore if */

    if (_temp instanceof Completion) {
      _temp = _temp.Value;
    }

    const s = _temp.stringValue();

    if (wrap) {
      return `[${s}] `;
    }

    return s;
  } catch {
    return '';
  }
};

const compactObject = (realm, value) => {
  try {
    let _temp2 = Get(value, new Value('toString'));

    Assert(!(_temp2 instanceof AbruptCompletion), "Get(value, new Value('toString'))" + ' returned an abrupt completion', "");

    if (_temp2 instanceof Completion) {
      _temp2 = _temp2.Value;
    }

    const toString = _temp2;
    const objectToString = realm.Intrinsics['%Object.prototype.toString%'];

    if (toString.nativeFunction === objectToString.nativeFunction) {
      let _temp3 = Call(toString, value);

      Assert(!(_temp3 instanceof AbruptCompletion), "Call(toString, value)" + ' returned an abrupt completion', "");

      if (_temp3 instanceof Completion) {
        _temp3 = _temp3.Value;
      }

      return _temp3.stringValue();
    } else {
      const tag = getObjectTag(value, false) || 'Unknown';

      let _temp4 = Get(value, new Value('constructor'));

      Assert(!(_temp4 instanceof AbruptCompletion), "Get(value, new Value('constructor'))" + ' returned an abrupt completion', "");

      if (_temp4 instanceof Completion) {
        _temp4 = _temp4.Value;
      }

      const ctor = _temp4;

      if (Type(ctor) === 'Object') {
        let _temp5 = Get(ctor, new Value('name'));

        Assert(!(_temp5 instanceof AbruptCompletion), "Get(ctor, new Value('name'))" + ' returned an abrupt completion', "");

        if (_temp5 instanceof Completion) {
          _temp5 = _temp5.Value;
        }

        const ctorName = _temp5.stringValue();

        if (ctorName !== '') {
          return `#<${ctorName}>`;
        }

        return `[object ${tag}]`;
      }

      return `[object ${tag}]`;
    }
  } catch (e) {
    return '[object Unknown]';
  }
};

const INSPECTORS = {
  Completion: (v, ctx, i) => i(v.Value),
  Null: () => 'null',
  Undefined: () => 'undefined',
  Boolean: v => v.boolean.toString(),
  Number: v => {
    const n = v.numberValue();

    if (n === 0 && Object.is(n, -0)) {
      return '-0';
    }

    return n.toString();
  },
  BigInt: v => `${v.bigintValue()}n`,
  String: (v, ctx) => ctx.quote ? `'${v.stringValue().replace(/\n/g, '\\n')}'` : v.stringValue(),
  Symbol: v => `Symbol(${v.Description === Value.undefined ? '' : v.Description.stringValue()})`,
  Object: (v, ctx, i) => {
    if (ctx.inspected.includes(v)) {
      return '[Circular]';
    }

    if ('PromiseState' in v) {
      ctx.indent += 1;
      const result = v.PromiseState === 'pending' ? 'undefined' : i(v.PromiseResult);
      ctx.indent -= 1;
      return `Promise {
  [[PromiseState]]: ${v.PromiseState}
  [[PromiseResult]]: ${result}
}`;
    }

    if ('Call' in v) {
      const name = v.properties.get(new Value('name'));

      if (name !== undefined) {
        return `[Function: ${name.Value.stringValue()}]`;
      }

      return '[Function]';
    }

    if ('ErrorData' in v) {
      let _temp6 = Get(v, new Value('stack'));
      /* istanbul ignore if */


      if (_temp6 instanceof AbruptCompletion) {
        return _temp6;
      }
      /* istanbul ignore if */


      if (_temp6 instanceof Completion) {
        _temp6 = _temp6.Value;
      }

      let e = _temp6;

      if (!e.stringValue) {
        let _temp7 = Get(v, new Value('toString'));

        if (_temp7 instanceof AbruptCompletion) {
          return _temp7;
        }

        if (_temp7 instanceof Completion) {
          _temp7 = _temp7.Value;
        }

        const toString = _temp7;

        let _temp8 = Call(toString, v);

        Assert(!(_temp8 instanceof AbruptCompletion), "Call(toString, v)" + ' returned an abrupt completion');

        if (_temp8 instanceof Completion) {
          _temp8 = _temp8.Value;
        }

        e = _temp8;
      }

      return e.stringValue();
    }

    if ('BooleanData' in v) {
      return `[Boolean ${i(v.BooleanData)}]`;
    }

    if ('NumberData' in v) {
      return `[Number ${i(v.NumberData)}]`;
    }

    if ('BigIntData' in v) {
      return `[BigInt ${i(v.BigIntData)}]`;
    }

    if ('StringData' in v) {
      return `[String ${i(v.StringData)}]`;
    }

    if ('SymbolData' in v) {
      return `[Symbol ${i(v.SymbolData)}]`;
    }

    ctx.indent += 1;
    ctx.inspected.push(v);

    try {
      const tag = getObjectTag(v);
      const isArray = IsArray(v) === Value.true;
      const isTypedArray = 'TypedArrayName' in v;

      if (isArray || isTypedArray) {
        let _temp9 = LengthOfArrayLike(v);

        Assert(!(_temp9 instanceof AbruptCompletion), "LengthOfArrayLike(v)" + ' returned an abrupt completion', "");

        if (_temp9 instanceof Completion) {
          _temp9 = _temp9.Value;
        }

        const length = _temp9.numberValue();

        let holes = 0;
        const out = [];

        for (let j = 0; j < length; j += 1) {
          let _temp10 = v.GetOwnProperty(new Value(j.toString()));

          Assert(!(_temp10 instanceof AbruptCompletion), "v.GetOwnProperty(new Value(j.toString()))" + ' returned an abrupt completion', "");

          if (_temp10 instanceof Completion) {
            _temp10 = _temp10.Value;
          }

          const elem = _temp10;

          if (elem === Value.undefined) {
            holes += 1;
          } else {
            if (holes > 0) {
              out.push(`<${holes} empty items>`);
              holes = 0;
            }

            if (elem.Value) {
              out.push(i(elem.Value));
            } else {
              out.push('<accessor>');
            }
          }
        }

        return `${isTypedArray ? `${v.TypedArrayName.stringValue()} ` : ''}[${out.join(', ')}]`;
      }

      let _temp11 = v.OwnPropertyKeys();

      Assert(!(_temp11 instanceof AbruptCompletion), "v.OwnPropertyKeys()" + ' returned an abrupt completion', "");

      if (_temp11 instanceof Completion) {
        _temp11 = _temp11.Value;
      }

      const keys = _temp11;
      const cache = [];

      for (const key of keys) {
        let _temp12 = v.GetOwnProperty(key);

        Assert(!(_temp12 instanceof AbruptCompletion), "v.GetOwnProperty(key)" + ' returned an abrupt completion', "");

        if (_temp12 instanceof Completion) {
          _temp12 = _temp12.Value;
        }

        const C = _temp12;

        if (C.Enumerable === Value.true) {
          cache.push([Type(key) === 'String' && bareKeyRe.test(key.stringValue()) ? key.stringValue() : i(key), C.Value ? i(C.Value) : '<accessor>']);
        }
      }

      let out = tag ? `${tag} {` : '{';

      if (cache.length > 5) {
        cache.forEach(c => {
          out = `${out}\n${'  '.repeat(ctx.indent)}${c[0]}: ${c[1]},`;
        });
        return `${out}\n${'  '.repeat(ctx.indent - 1)}}`;
      } else {
        const oc = ctx.compact;
        ctx.compact = true;
        cache.forEach((c, index) => {
          out = `${out}${index === 0 ? '' : ','} ${c[0]}: ${c[1]}`;
        });
        ctx.compact = oc;
        return `${out} }`;
      }
    } catch {
      return compactObject(ctx, v);
    } finally {
      ctx.indent -= 1;
      ctx.inspected.pop();
    }
  }
};
function inspect(value, realm = surroundingAgent.currentRealmRecord) {
  if (realm instanceof APIRealm) {
    realm = realm.realm;
  }

  const context = {
    realm,
    indent: 0,
    quote: true,
    inspected: []
  };

  const inner = v => INSPECTORS[Type(v)](v, context, inner);

  return inner(value);
}

const Abstract = { ...AbstractOps,
  Type
};
const {
  ObjectCreate: ObjectCreate$1,
  CreateBuiltinFunction: CreateBuiltinFunction$1,
  GetModuleNamespace: GetModuleNamespace$1,
  ToPrimitive: ToPrimitive$1
} = Abstract;

function runJobQueue() {
  while (true) {
    // eslint-disable-line no-constant-condition
    const nextQueue = surroundingAgent.jobQueue;

    if (nextQueue.length === 0) {
      break;
    }

    const nextPending = nextQueue.shift();
    const newContext = new ExecutionContext();
    newContext.Function = Value.null;
    newContext.Realm = nextPending.Realm;
    newContext.ScriptOrModule = nextPending.ScriptOrModule;
    surroundingAgent.executionContextStack.push(newContext);
    const result = nextPending.Job(...nextPending.Arguments);
    surroundingAgent.executionContextStack.pop(newContext);

    if (result instanceof AbruptCompletion) {
      HostReportErrors(result.Value);
    }
  }
}

class APIAgent {
  constructor(options = {}) {
    this.agent = new Agent(options);
    this.active = false;
    this.outerAgent = undefined;
  }

  scope(cb) {
    this.enter();

    try {
      return cb();
    } finally {
      this.exit();
    }
  }

  enter() {
    if (this.active) {
      throw new Error('Agent is already entered');
    }

    this.active = true;
    this.outerAgent = surroundingAgent;
    setSurroundingAgent(this.agent);
  }

  exit() {
    if (!this.active) {
      throw new Error('Agent is not entered');
    }

    setSurroundingAgent(this.outerAgent);
    this.outerAgent = undefined;
    this.active = false;
  }

}

class APIRealm {
  constructor(options = {}) {
    const realm = CreateRealm();
    realm.HostDefined = options;
    const newContext = new ExecutionContext();
    newContext.Function = Value.null;
    newContext.Realm = realm;
    newContext.ScriptOrModule = Value.null;
    surroundingAgent.executionContextStack.push(newContext);
    const global = Value.undefined;
    const thisValue = Value.undefined;
    SetRealmGlobalObject(realm, global, thisValue);
    const globalObj = SetDefaultGlobalBindings(realm); // Create any implementation-defined global object properties on globalObj.

    surroundingAgent.executionContextStack.pop(newContext);
    this.global = globalObj;
    this.realm = realm;
    this.context = newContext;
    this.agent = surroundingAgent;
    this.active = false;
  }

  evaluateScript(sourceText, {
    specifier
  } = {}) {
    if (typeof sourceText !== 'string') {
      throw new TypeError('sourceText must be a string');
    }

    return this.scope(() => {
      // BEGIN ScriptEvaluationJob
      const realm = surroundingAgent.currentRealmRecord;
      const s = ParseScript(sourceText, realm, {
        specifier,
        public: {
          specifier
        }
      });

      if (Array.isArray(s)) {
        return new ThrowCompletion(s[0]);
      } // END ScriptEvaluationJob


      let _temp = ScriptEvaluation(s);
      /* istanbul ignore if */


      if (_temp instanceof AbruptCompletion) {
        return _temp;
      }
      /* istanbul ignore if */


      if (_temp instanceof Completion) {
        _temp = _temp.Value;
      }

      const res = _temp;
      runJobQueue();
      return EnsureCompletion(res);
    });
  }

  createSourceTextModule(specifier, sourceText) {
    if (typeof sourceText !== 'string') {
      throw new TypeError('sourceText must be a string');
    }

    if (typeof specifier !== 'string') {
      throw new TypeError('specifier must be a string');
    }

    const module = this.scope(() => ParseModule(sourceText, this.realm, {
      specifier,
      public: {
        specifier,
        Link: () => this.scope(() => module.Link()),
        GetNamespace: () => this.scope(() => GetModuleNamespace$1(module)),
        Evaluate: () => this.scope(() => {
          const result = module.Evaluate();
          runJobQueue();
          return result;
        })
      }
    }));

    if (Array.isArray(module)) {
      return new ThrowCompletion(module[0]);
    }

    module.HostDefined.public.module = module;
    return module.HostDefined.public;
  }

  scope(cb) {
    if (this.active) {
      return cb();
    }

    this.active = true;
    surroundingAgent.executionContextStack.push(this.context);
    const r = cb();
    surroundingAgent.executionContextStack.pop(this.context);
    this.active = false;
    return r;
  }

}

function APIObject(realm, intrinsic = '%Object.prototype%') {
  return ObjectCreate$1(realm.realm.Intrinsics[intrinsic]);
}

class APIValue extends Value {
  constructor(realm, value) {
    if (typeof value === 'function') {
      return CreateBuiltinFunction$1(value, [], realm.realm);
    }

    if (value === undefined) {
      return Value.undefined;
    }

    if (value === null) {
      return Value.null;
    }

    if (value === true) {
      return Value.true;
    }

    if (value === false) {
      return Value.false;
    }

    return new Value(value);
  }

}
function Throw(realm, V, ...args) {
  return realm.scope(() => {
    if (typeof V === 'string') {
      return surroundingAgent.Throw(V, 'Raw', args[0]);
    }

    return new ThrowCompletion(V);
  });
}
function ToString$1(realm, value) {
  return realm.scope(() => {
    while (true) {
      const type = Type(value);

      switch (type) {
        case 'String':
          return value.stringValue();

        case 'Number':
          return value.numberValue().toString();

        case 'Boolean':
          return value === Value.true ? 'true' : 'false';

        case 'Undefined':
          return 'undefined';

        case 'Null':
          return 'null';

        case 'Symbol':
          return surroundingAgent.Throw('TypeError', 'CannotConvertSymbol', 'string');

        default:
          let _temp2 = ToPrimitive$1(value, 'String');

          if (_temp2 instanceof AbruptCompletion) {
            return _temp2;
          }

          if (_temp2 instanceof Completion) {
            _temp2 = _temp2.Value;
          }

          value = _temp2;
          break;
      }
    }
  });
}

export { AbruptCompletion, Abstract, APIAgent as Agent, Completion, Descriptor, FEATURES, NormalCompletion, APIObject as Object, APIRealm as Realm, Throw, ToString$1 as ToString, APIValue as Value, inspect };
//# sourceMappingURL=engine262.mjs.map
