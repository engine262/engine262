/*!
 * engine262 0.0.1 c321b36d986d0d8294de670c3e8ff98dd2622cef
 *
 * Copyright (c) 2018 engine262 Contributors
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-arguments-exotic-objects */

function isArgumentExoticObject(value) {
  return 'ParameterMap' in value;
}
const ArgumentExoticObject = {
  *GetOwnProperty(P) {
    const args = this;
    const desc = OrdinaryGetOwnProperty(args, P);
    if (desc === Value.undefined) {
      return desc;
    }
    const map = args.ParameterMap;
    /* X */
    let _temp = HasOwnProperty(map, P);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! HasOwnProperty(map, P) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const isMapped = _temp;
    if (isMapped === Value.true) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* Get(map, P);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      return _Descriptor({
        ...desc,
        Value: _temp2
      });
    }
    return desc;
  },
  *DefineOwnProperty(P, Desc) {
    const args = this;
    const map = args.ParameterMap;
    /* X */
    let _temp3 = HasOwnProperty(map, P);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! HasOwnProperty(map, P) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const isMapped = _temp3;
    let newArgDesc = Desc;
    if (isMapped === Value.true && IsDataDescriptor(Desc) === true) {
      if (Desc.Value === undefined && Desc.Writable !== undefined && Desc.Writable === Value.false) {
        /* X */
        let _temp4 = Get(map, P);
        /* node:coverage ignore next */
        if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! Get(map, P) returned an abrupt completion", {
          cause: _temp4
        });
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        newArgDesc = _Descriptor({
          ...Desc,
          Value: _temp4
        });
      }
    }
    /* ReturnIfAbrupt */
    let _temp5 = yield* OrdinaryDefineOwnProperty(args, P, newArgDesc);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    const allowed = _temp5;
    if (allowed === Value.false) {
      return Value.false;
    }
    if (isMapped === Value.true) {
      if (IsAccessorDescriptor(Desc) === true) {
        yield* map.Delete(P);
      } else {
        if (Desc.Value !== undefined) {
          const setStatus = yield* Set$1(map, P, Desc.Value, Value.false);
          Assert(setStatus === Value.true, "setStatus === Value.true");
        }
        if (Desc.Writable !== undefined && Desc.Writable === Value.false) {
          yield* map.Delete(P);
        }
      }
    }
    return Value.true;
  },
  *Get(P, Receiver) {
    const args = this;
    const map = args.ParameterMap;
    /* X */
    let _temp6 = HasOwnProperty(map, P);
    /* node:coverage ignore next */
    if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! HasOwnProperty(map, P) returned an abrupt completion", {
      cause: _temp6
    });
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    const isMapped = _temp6;
    if (isMapped === Value.false) {
      return yield* OrdinaryGet(args, P, Receiver);
    } else {
      return yield* Get(map, P);
    }
  },
  *Set(P, V, Receiver) {
    const args = this;
    let isMapped;
    let map;
    if (SameValue(args, Receiver) === Value.false) {
      isMapped = false;
    } else {
      map = args.ParameterMap;
      /* X */
      let _temp7 = HasOwnProperty(map, P);
      /* node:coverage ignore next */
      if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
      /* node:coverage ignore next */
      if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! HasOwnProperty(map, P) returned an abrupt completion", {
        cause: _temp7
      });
      /* node:coverage ignore next */
      if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
      isMapped = _temp7 === Value.true;
    }
    if (isMapped) {
      const setStatus = yield* Set$1(map, P, V, Value.false);
      Assert(setStatus === Value.true, "setStatus === Value.true");
    }
    return yield* OrdinarySet(args, P, V, Receiver);
  },
  *Delete(P) {
    const args = this;
    const map = args.ParameterMap;
    /* X */
    let _temp8 = HasOwnProperty(map, P);
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! HasOwnProperty(map, P) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    const isMapped = _temp8;
    /* ReturnIfAbrupt */
    let _temp9 = yield* OrdinaryDelete(args, P);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    const result = _temp9;
    if (result === Value.true && isMapped === Value.true) {
      yield* map.Delete(P);
    }
    return result;
  }
};

/** https://tc39.es/ecma262/#sec-createunmappedargumentsobject */
function CreateUnmappedArgumentsObject(argumentsList) {
  const len = argumentsList.length;
  const obj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'), ['ParameterMap']);
  obj.ParameterMap = Value.undefined;
  /* X */
  let _temp10 = DefinePropertyOrThrow(obj, Value('length'), _Descriptor({
    Value: F(len),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(obj, Value('length'), Descriptor({\n    Value: F(len),\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  let index = 0;
  while (index < len) {
    const val = argumentsList[index];
    /* X */
    let _temp12 = ToString(F(index));
    /* node:coverage ignore next */
    if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(index)) returned an abrupt completion", {
      cause: _temp12
    });
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    /* X */
    let _temp11 = CreateDataProperty(obj, _temp12, val);
    /* node:coverage ignore next */
    if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, X(ToString(F(index))), val) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    index += 1;
  }
  /* X */
  let _temp13 = DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, _Descriptor({
    Value: surroundingAgent.intrinsic('%Array.prototype.values%'),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, Descriptor({\n    Value: surroundingAgent.intrinsic('%Array.prototype.values%'),\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp13
  });
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  /* X */
  let _temp14 = DefinePropertyOrThrow(obj, Value('callee'), _Descriptor({
    Get: surroundingAgent.intrinsic('%ThrowTypeError%'),
    Set: surroundingAgent.intrinsic('%ThrowTypeError%'),
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(obj, Value('callee'), Descriptor({\n    Get: surroundingAgent.intrinsic('%ThrowTypeError%'),\n    Set: surroundingAgent.intrinsic('%ThrowTypeError%'),\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp14
  });
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  return obj;
}
CreateUnmappedArgumentsObject.section = 'https://tc39.es/ecma262/#sec-createunmappedargumentsobject';
/** https://tc39.es/ecma262/#sec-makearggetter */
function MakeArgGetter(name, env) {
  // 1. Let getterClosure be a new Abstract Closure with no parameters that captures name and env and performs the following steps when called:
  //   a. Return env.GetBindingValue(name, false).
  const getterClosure = () => env.GetBindingValue(name, Value.false);
  // 2. Let getter be ! CreateBuiltinFunction(getterClosure, 0, "", « »).
  /* X */
  let _temp15 = CreateBuiltinFunction(getterClosure, 0, Value(''), ['Name', 'Env']);
  /* node:coverage ignore next */
  if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(getterClosure, 0, Value(''), ['Name', 'Env']) returned an abrupt completion", {
    cause: _temp15
  });
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const getter = _temp15;
  // 3. NOTE: getter is never directly accessible to ECMAScript code.
  // 4. Return getter.
  return getter;
}
MakeArgGetter.section = 'https://tc39.es/ecma262/#sec-makearggetter';
/** https://tc39.es/ecma262/#sec-makeargsetter */
function MakeArgSetter(name, env) {
  // 1. Let setterClosure be a new Abstract Closure with parameters (value) that captures name and env and performs the following steps when called:
  //   a. Return env.SetMutableBinding(name, value, false).
  const setterClosure = ([value = Value.undefined]) => env.SetMutableBinding(name, value, Value.false);
  // 2. Let setter be ! CreateBuiltinFunction(setterClosure, 1, "", « »).
  /* X */
  let _temp16 = CreateBuiltinFunction(setterClosure, 1, Value(''), ['Name', 'Env']);
  /* node:coverage ignore next */
  if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(setterClosure, 1, Value(''), ['Name', 'Env']) returned an abrupt completion", {
    cause: _temp16
  });
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  const setter = _temp16;
  // 3. NOTE: setter is never directly accessible to ECMAScript code.
  // 4. Return setter.
  return setter;
}
MakeArgSetter.section = 'https://tc39.es/ecma262/#sec-makeargsetter';
/** https://tc39.es/ecma262/#sec-createmappedargumentsobject */
function CreateMappedArgumentsObject(func, formals, argumentsList, env) {
  // Assert: formals does not contain a rest parameter, any binding
  // patterns, or any initializers. It may contain duplicate identifiers.
  const len = argumentsList.length;
  /* X */
  let _temp17 = MakeBasicObject(['Prototype', 'Extensible', 'ParameterMap']);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! MakeBasicObject(['Prototype', 'Extensible', 'ParameterMap']) returned an abrupt completion", {
    cause: _temp17
  });
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  const obj = _temp17;
  obj.GetOwnProperty = ArgumentExoticObject.GetOwnProperty;
  obj.DefineOwnProperty = ArgumentExoticObject.DefineOwnProperty;
  obj.Get = ArgumentExoticObject.Get;
  obj.Set = ArgumentExoticObject.Set;
  obj.Delete = ArgumentExoticObject.Delete;
  obj.Prototype = surroundingAgent.intrinsic('%Object.prototype%');
  const map = OrdinaryObjectCreate(Value.null);
  obj.ParameterMap = map;
  const parameterNames = BoundNames(formals);
  const numberOfParameters = parameterNames.length;
  let index = 0;
  while (index < len) {
    const val = argumentsList[index];
    /* X */
    let _temp19 = ToString(F(index));
    /* node:coverage ignore next */
    if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(index)) returned an abrupt completion", {
      cause: _temp19
    });
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    /* X */
    let _temp18 = CreateDataProperty(obj, _temp19, val);
    /* node:coverage ignore next */
    if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, X(ToString(F(index))), val) returned an abrupt completion", {
      cause: _temp18
    });
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    index += 1;
  }
  /* X */
  let _temp20 = DefinePropertyOrThrow(obj, Value('length'), _Descriptor({
    Value: F(len),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) _temp20 = skipDebugger(_temp20);
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(obj, Value('length'), Descriptor({\n    Value: F(len),\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp20
  });
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  const mappedNames = new JSStringSet();
  index = numberOfParameters - 1;
  while (index >= 0) {
    const name = parameterNames[index];
    if (!mappedNames.has(name)) {
      mappedNames.add(name);
      if (index < len) {
        const g = MakeArgGetter(name, env);
        const p = MakeArgSetter(name, env);
        /* X */
        let _temp22 = ToString(F(index));
        /* node:coverage ignore next */
        if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) _temp22 = skipDebugger(_temp22);
        /* node:coverage ignore next */
        if (_temp22 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(index)) returned an abrupt completion", {
          cause: _temp22
        });
        /* node:coverage ignore next */
        if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
        /* X */
        let _temp21 = map.DefineOwnProperty(_temp22, _Descriptor({
          Set: p,
          Get: g,
          Enumerable: Value.false,
          Configurable: Value.true
        }));
        /* node:coverage ignore next */
        if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) _temp21 = skipDebugger(_temp21);
        /* node:coverage ignore next */
        if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! map.DefineOwnProperty(X(ToString(F(index))), Descriptor({\n          Set: p,\n          Get: g,\n          Enumerable: Value.false,\n          Configurable: Value.true,\n        })) returned an abrupt completion", {
          cause: _temp21
        });
        /* node:coverage ignore next */
        if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
      }
    }
    index -= 1;
  }
  /* X */
  let _temp23 = DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, _Descriptor({
    Value: surroundingAgent.intrinsic('%Array.prototype.values%'),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) _temp23 = skipDebugger(_temp23);
  /* node:coverage ignore next */
  if (_temp23 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(obj, wellKnownSymbols.iterator, Descriptor({\n    Value: surroundingAgent.intrinsic('%Array.prototype.values%'),\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp23
  });
  /* node:coverage ignore next */
  if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
  /* X */
  let _temp24 = DefinePropertyOrThrow(obj, Value('callee'), _Descriptor({
    Value: func,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) _temp24 = skipDebugger(_temp24);
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(obj, Value('callee'), Descriptor({\n    Value: func,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp24
  });
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  return obj;
}
CreateMappedArgumentsObject.section = 'https://tc39.es/ecma262/#sec-createmappedargumentsobject';

const InternalMethods$5 = {
  /** https://tc39.es/ecma262/#sec-array-exotic-objects-defineownproperty-p-desc */
  *DefineOwnProperty(P, Desc) {
    const A = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    if (P instanceof JSStringValue && P.stringValue() === 'length') {
      return yield* ArraySetLength(A, Desc);
    } else if (isArrayIndex(P)) {
      let oldLenDesc = OrdinaryGetOwnProperty(A, Value('length'));
      /* X */
      let _temp = IsDataDescriptor(oldLenDesc);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! IsDataDescriptor(oldLenDesc) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      Assert(_temp, "X(IsDataDescriptor(oldLenDesc))");
      Assert(oldLenDesc.Configurable === Value.false, "oldLenDesc.Configurable === Value.false");
      const oldLen = oldLenDesc.Value;
      /* X */
      let _temp2 = ToUint32(P);
      /* node:coverage ignore next */
      if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! ToUint32(P) returned an abrupt completion", {
        cause: _temp2
      });
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      const index = _temp2;
      if (R(index) >= R(oldLen) && oldLenDesc.Writable === Value.false) {
        return Value.false;
      }
      /* X */
      let _temp3 = OrdinaryDefineOwnProperty(A, P, Desc);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryDefineOwnProperty(A, P, Desc) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      const succeeded = _temp3;
      if (succeeded === Value.false) {
        return Value.false;
      }
      if (R(index) >= R(oldLen)) {
        oldLenDesc = _Descriptor({
          ...oldLenDesc,
          Value: F(R(index) + 1)
        });
        const succeeded = yield* OrdinaryDefineOwnProperty(A, Value('length'), oldLenDesc); // eslint-disable-line no-shadow
        Assert(succeeded === Value.true, "succeeded === Value.true");
      }
      return Value.true;
    }
    return yield* OrdinaryDefineOwnProperty(A, P, Desc);
  }
};
function isArrayExoticObject(O) {
  return O instanceof ObjectValue && O.DefineOwnProperty === InternalMethods$5.DefineOwnProperty;
}

/** https://tc39.es/ecma262/#sec-arraycreate */
function ArrayCreate(length, proto) {
  Assert(isNonNegativeInteger(length), "isNonNegativeInteger(length)");
  if (Object.is(length, -0)) {
    length = 0;
  }
  if (length > 2 ** 32 - 1) {
    return surroundingAgent.Throw('RangeError', 'InvalidArrayLength', length);
  }
  if (proto === undefined) {
    proto = surroundingAgent.intrinsic('%Array.prototype%');
  }
  /* X */
  let _temp4 = MakeBasicObject(['Prototype', 'Extensible']);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! MakeBasicObject(['Prototype', 'Extensible']) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const A = _temp4;
  A.Prototype = proto;
  A.DefineOwnProperty = InternalMethods$5.DefineOwnProperty;
  /* X */
  let _temp5 = OrdinaryDefineOwnProperty(A, Value('length'), _Descriptor({
    Value: F(length),
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryDefineOwnProperty(A, Value('length'), Descriptor({\n    Value: F(length),\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  return A;
}
ArrayCreate.section = 'https://tc39.es/ecma262/#sec-arraycreate';
/** https://tc39.es/ecma262/#sec-arrayspeciescreate */
function* ArraySpeciesCreate(originalArray, length) {
  Assert(typeof length === 'number' && Number.isInteger(length) && length >= 0, "typeof length === 'number' && Number.isInteger(length) && length >= 0");
  if (Object.is(length, -0)) {
    length = 0;
  }
  /* ReturnIfAbrupt */
  let _temp6 = IsArray(originalArray);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const isArray = _temp6;
  if (isArray === Value.false) {
    return ArrayCreate(length);
  }
  /* ReturnIfAbrupt */
  let _temp7 = yield* Get(originalArray, Value('constructor'));
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  let C = _temp7;
  if (IsConstructor(C)) {
    const thisRealm = surroundingAgent.currentRealmRecord;
    /* ReturnIfAbrupt */
    let _temp8 = GetFunctionRealm(C);
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    const realmC = _temp8;
    if (thisRealm !== realmC) {
      if (SameValue(C, realmC.Intrinsics['%Array%']) === Value.true) {
        C = Value.undefined;
      }
    }
  }
  if (C instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp9 = yield* Get(C, wellKnownSymbols.species);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    C = _temp9;
    if (C === Value.null) {
      C = Value.undefined;
    }
  }
  if (C === Value.undefined) {
    return ArrayCreate(length);
  }
  if (!IsConstructor(C)) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', C);
  }
  return yield* Construct(C, [F(length)]);
}
ArraySpeciesCreate.section = 'https://tc39.es/ecma262/#sec-arrayspeciescreate';
/** https://tc39.es/ecma262/#sec-arraysetlength */
function* ArraySetLength(A, Desc) {
  if (Desc.Value === undefined) {
    return yield* OrdinaryDefineOwnProperty(A, Value('length'), Desc);
  }
  let newLenDesc = Desc;
  /* ReturnIfAbrupt */
  let _temp10 = yield* ToUint32(Desc.Value);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const newLen = R(_temp10);
  /* ReturnIfAbrupt */
  let _temp11 = yield* ToNumber(Desc.Value);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const numberLen = R(_temp11);
  if (newLen !== numberLen) {
    return surroundingAgent.Throw('RangeError', 'InvalidArrayLength', Desc.Value);
  }
  newLenDesc = _Descriptor({
    ...Desc,
    Value: F(newLen)
  });
  const oldLenDesc = OrdinaryGetOwnProperty(A, Value('length'));
  /* X */
  let _temp12 = IsDataDescriptor(oldLenDesc);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! IsDataDescriptor(oldLenDesc) returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  Assert(_temp12, "X(IsDataDescriptor(oldLenDesc))");
  Assert(oldLenDesc.Configurable === Value.false, "oldLenDesc.Configurable === Value.false");
  const oldLen = R(oldLenDesc.Value);
  if (newLen >= oldLen) {
    return yield* OrdinaryDefineOwnProperty(A, Value('length'), newLenDesc);
  }
  if (oldLenDesc.Writable === Value.false) {
    return Value.false;
  }
  let newWritable;
  if (newLenDesc.Writable === undefined || newLenDesc.Writable === Value.true) {
    newWritable = true;
  } else {
    newWritable = false;
    newLenDesc = _Descriptor({
      ...newLenDesc,
      Writable: Value.true
    });
  }
  /* X */
  let _temp13 = OrdinaryDefineOwnProperty(A, Value('length'), newLenDesc);
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryDefineOwnProperty(A, Value('length'), newLenDesc) returned an abrupt completion", {
    cause: _temp13
  });
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  const succeeded = _temp13;
  if (succeeded === Value.false) {
    return Value.false;
  }
  const keys = [];
  A.properties.forEach((_value, key) => {
    if (isArrayIndex(key) && Number(key.stringValue()) >= newLen) {
      keys.push(key);
    }
  });
  keys.sort((a, b) => Number(b.stringValue()) - Number(a.stringValue()));
  for (const P of keys) {
    /* X */
    let _temp14 = A.Delete(P);
    /* node:coverage ignore next */
    if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! A.Delete(P) returned an abrupt completion", {
      cause: _temp14
    });
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    const deleteSucceeded = _temp14;
    if (deleteSucceeded === Value.false) {
      /* X */
      let _temp15 = ToUint32(P);
      /* node:coverage ignore next */
      if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
      /* node:coverage ignore next */
      if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! ToUint32(P) returned an abrupt completion", {
        cause: _temp15
      });
      /* node:coverage ignore next */
      if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
      newLenDesc = _Descriptor({
        ...newLenDesc,
        Value: F(R(_temp15) + 1)
      });
      if (newWritable === false) {
        newLenDesc = _Descriptor({
          ...newLenDesc,
          Writable: Value.false
        });
      }
      /* X */
      let _temp16 = OrdinaryDefineOwnProperty(A, Value('length'), newLenDesc);
      /* node:coverage ignore next */
      if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
      /* node:coverage ignore next */
      if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryDefineOwnProperty(A, Value('length'), newLenDesc) returned an abrupt completion", {
        cause: _temp16
      });
      /* node:coverage ignore next */
      if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
      return Value.false;
    }
  }
  if (newWritable === false) {
    const s = yield* OrdinaryDefineOwnProperty(A, Value('length'), _Descriptor({
      Writable: Value.false
    }));
    Assert(s === Value.true, "s === Value.true");
  }
  return Value.true;
}
ArraySetLength.section = 'https://tc39.es/ecma262/#sec-arraysetlength';
/** https://tc39.es/ecma262/#sec-isconcatspreadable */
function* IsConcatSpreadable(O) {
  if (!(O instanceof ObjectValue)) {
    return Value.false;
  }
  /* ReturnIfAbrupt */
  let _temp17 = yield* Get(O, wellKnownSymbols.isConcatSpreadable);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  const spreadable = _temp17;
  if (spreadable !== Value.undefined) {
    return ToBoolean(spreadable);
  }
  return IsArray(O);
}
IsConcatSpreadable.section = 'https://tc39.es/ecma262/#sec-isconcatspreadable';
/** https://tc39.es/ecma262/#sec-comparearrayelements */
function* CompareArrayElements(x, y, comparefn) {
  // 1. If x and y are both undefined, return +0𝔽.
  if (x === Value.undefined && y === Value.undefined) {
    return F(0);
  }
  // 2. If x is undefined, return 1𝔽.
  if (x === Value.undefined) {
    return F(1);
  }
  // 3. If y is undefined, return -1𝔽.
  if (y === Value.undefined) {
    return F(-1);
  }
  // 4. If comparefn is not undefined, then
  if (comparefn !== Value.undefined) {
    /* ReturnIfAbrupt */
    let _temp19 = yield* Call(comparefn, Value.undefined, [x, y]);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) return _temp19;
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    /* ReturnIfAbrupt */
    let _temp18 = yield* ToNumber(_temp19);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) return _temp18;
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    // a. Let v be ? ToNumber(? Call(comparefn, undefined, « x, y »)).
    const v = _temp18;
    // b. If v is NaN, return +0𝔽.
    if (v.isNaN()) {
      return F(0);
    }
    // c. Return v.
    return v;
  }
  // 5. Let xString be ? ToString(x).
  /* ReturnIfAbrupt */
  let _temp20 = yield* ToString(x);
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  const xString = _temp20;
  // 6. Let yString be ? ToString(y).
  /* ReturnIfAbrupt */
  let _temp21 = yield* ToString(y);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  const yString = _temp21;
  // 7. Let xSmaller be the result of performing Abstract Relational Comparison xString < yString.
  const xSmaller = yield* AbstractRelationalComparison(xString, yString);
  // 8. If xSmaller is true, return -1𝔽.
  if (xSmaller === Value.true) {
    return F(-1);
  }
  // 9. Let ySmaller be the result of performing Abstract Relational Comparison yString < xString.
  const ySmaller = yield* AbstractRelationalComparison(yString, xString);
  // 10. If ySmaller is true, return 1𝔽.
  if (ySmaller === Value.true) {
    return F(1);
  }
  // 11. Return +0𝔽.
  return F(0);
}
CompareArrayElements.section = 'https://tc39.es/ecma262/#sec-comparearrayelements';
/** https://tc39.es/ecma262/#sec-createarrayiterator */
function CreateArrayIterator(array, kind) {
  // 3. Let closure be a new Abstract Closure with no parameters that captures kind and array and performs the following steps when called:
  const closure = function* closure() {
    // a. Let index be 0.
    let index = 0;
    // b. Repeat,
    while (true) {
      let len;
      let result;
      // i. If array has a [[TypedArrayName]] internal slot, then
      if (isTypedArrayObject(array)) {
        const taRecord = MakeTypedArrayWithBufferWitnessRecord(array);
        if (IsTypedArrayOutOfBounds(taRecord)) {
          return surroundingAgent.Throw('TypeError', 'TypedArrayOutOfBounds');
        }
        // 2. Let len be array.[[ArrayLength]].
        len = TypedArrayLength(taRecord);
      } else {
        /* ReturnIfAbrupt */
        let _temp22 = yield* LengthOfArrayLike(array);
        /* node:coverage ignore next */
        if (_temp22 instanceof AbruptCompletion) return _temp22;
        /* node:coverage ignore next */
        if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
        // ii. Else,
        // 1. Let len be ? LengthOfArrayLike(array).
        len = _temp22;
      }
      // iii. If index ≥ len, return undefined.
      if (index >= len) {
        // NON_SPEC
        generator.HostCapturedValues = undefined;
        return Value.undefined;
      }
      const indexNumber = F(index);
      // iv. If kind is key,
      if (kind === 'key') {
        result = indexNumber;
      } else {
        /* X */
        let _temp23 = ToString(indexNumber);
        /* node:coverage ignore next */
        if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) _temp23 = skipDebugger(_temp23);
        /* node:coverage ignore next */
        if (_temp23 instanceof AbruptCompletion) throw new Assert.Error("! ToString(indexNumber) returned an abrupt completion", {
          cause: _temp23
        });
        /* node:coverage ignore next */
        if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
        // v. Else,
        // 1. Let elementKey be ! ToString(indexNumber).
        const elementKey = _temp23;
        // 2. Let elementValue be ? Get(array, elementKey).
        /* ReturnIfAbrupt */
        let _temp24 = yield* Get(array, elementKey);
        /* node:coverage ignore next */
        if (_temp24 instanceof AbruptCompletion) return _temp24;
        /* node:coverage ignore next */
        if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
        const elementValue = _temp24;
        // 3. If kind is value, perform ? Yield(elementValue).
        if (kind === 'value') {
          result = elementValue;
        } else {
          // 4. Else,
          // a. Assert: kind is key+value.
          Assert(kind === 'key+value', "kind === 'key+value'");
          // b. Perform ? Yield(! CreateArrayFromList(« 𝔽(index), elementValue »)).
          result = CreateArrayFromList([indexNumber, elementValue]);
        }
      }
      /* ReturnIfAbrupt */
      let _temp25 = yield* GeneratorYield(CreateIteratorResultObject(result, Value.false));
      /* node:coverage ignore next */
      if (_temp25 instanceof AbruptCompletion) return _temp25;
      /* node:coverage ignore next */
      if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
      // vi. Set index to index + 1.
      index += 1;
    }
  };
  // 4. Return CreateIteratorFromClosure(closure, "%ArrayIteratorPrototype%", %ArrayIteratorPrototype%).
  const generator = CreateIteratorFromClosure(closure, Value('%ArrayIteratorPrototype%'), surroundingAgent.intrinsic('%ArrayIteratorPrototype%'), ['HostCapturedValues'], [array]);
  return generator;
}
CreateArrayIterator.section = 'https://tc39.es/ecma262/#sec-createarrayiterator';

function _applyDecs2311(e, t, n, r, o, i) {
  var a,
    c,
    u,
    s,
    f,
    l,
    p,
    d = Symbol.metadata || Symbol.for("Symbol.metadata"),
    m = Object.defineProperty,
    h = Object.create,
    y = [h(null), h(null)],
    v = t.length;
  function g(t, n, r) {
    return function (o, i) {
      n && (i = o, o = e);
      for (var a = 0; a < t.length; a++) i = t[a].apply(o, r ? [i] : []);
      return r ? i : o;
    };
  }
  function b(e, t, n, r) {
    if ("function" != typeof e && (r || void 0 !== e)) throw new TypeError(t + " must " + (n || "be") + " a function" + (r ? "" : " or undefined"));
    return e;
  }
  function applyDec(e, t, n, r, o, i, u, s, f, l, p) {
    function d(e) {
      if (!p(e)) throw new TypeError("Attempted to access private element on non-instance");
    }
    var h = [].concat(t[0]),
      v = t[3],
      w = !u,
      D = 1 === o,
      S = 3 === o,
      j = 4 === o,
      E = 2 === o;
    function I(t, n, r) {
      return function (o, i) {
        return n && (i = o, o = e), r && r(o), P[t].call(o, i);
      };
    }
    if (!w) {
      var P = {},
        k = [],
        F = S ? "get" : j || D ? "set" : "value";
      if (f ? (l || D ? P = {
        get: _setFunctionName(function () {
          return v(this);
        }, r, "get"),
        set: function (e) {
          t[4](this, e);
        }
      } : P[F] = v, l || _setFunctionName(P[F], r, E ? "" : F)) : l || (P = Object.getOwnPropertyDescriptor(e, r)), !l && !f) {
        if ((c = y[+s][r]) && 7 != (c ^ o)) throw Error("Decorating two elements with the same name (" + P[F].name + ") is not supported yet");
        y[+s][r] = o < 3 ? 1 : o;
      }
    }
    for (var N = e, O = h.length - 1; O >= 0; O -= n ? 2 : 1) {
      var T = b(h[O], "A decorator", "be", true),
        z = n ? h[O - 1] : void 0,
        A = {},
        H = {
          kind: ["field", "accessor", "method", "getter", "setter", "class"][o],
          name: r,
          metadata: a,
          addInitializer: function (e, t) {
            if (e.v) throw new TypeError("attempted to call addInitializer after decoration was finished");
            b(t, "An initializer", "be", true), i.push(t);
          }.bind(null, A)
        };
      if (w) c = T.call(z, N, H), A.v = 1, b(c, "class decorators", "return") && (N = c);else if (H.static = s, H.private = f, c = H.access = {
        has: f ? p.bind() : function (e) {
          return r in e;
        }
      }, j || (c.get = f ? E ? function (e) {
        return d(e), P.value;
      } : I("get", 0, d) : function (e) {
        return e[r];
      }), E || S || (c.set = f ? I("set", 0, d) : function (e, t) {
        e[r] = t;
      }), N = T.call(z, D ? {
        get: P.get,
        set: P.set
      } : P[F], H), A.v = 1, D) {
        if ("object" == typeof N && N) (c = b(N.get, "accessor.get")) && (P.get = c), (c = b(N.set, "accessor.set")) && (P.set = c), (c = b(N.init, "accessor.init")) && k.unshift(c);else if (void 0 !== N) throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined");
      } else b(N, (l ? "field" : "method") + " decorators", "return") && (l ? k.unshift(N) : P[F] = N);
    }
    return o < 2 && u.push(g(k, s, 1), g(i, s, 0)), l || w || (f ? D ? u.splice(-1, 0, I("get", s), I("set", s)) : u.push(E ? P[F] : b.call.bind(P[F])) : m(e, r, P)), N;
  }
  function w(e) {
    return m(e, d, {
      configurable: true,
      enumerable: true,
      value: a
    });
  }
  return void 0 !== i && (a = i[d]), a = h(null == a ? null : a), f = [], l = function (e) {
    e && f.push(g(e));
  }, p = function (t, r) {
    for (var i = 0; i < n.length; i++) {
      var a = n[i],
        c = a[1],
        l = 7 & c;
      if ((8 & c) == t && !l == r) {
        var p = a[2],
          d = !!a[3],
          m = 16 & c;
        applyDec(t ? e : e.prototype, a, m, d ? "#" + p : _toPropertyKey(p), l, l < 2 ? [] : t ? s = s || [] : u = u || [], f, !!t, d, r, t && d ? function (t) {
          return _checkInRHS(t) === e;
        } : o);
      }
    }
  }, p(8, 0), p(0, 0), p(8, 1), p(0, 1), l(u), l(s), c = f, v || w(e), {
    e: c,
    get c() {
      var n = [];
      return v && [w(e = applyDec(e, [t], r, e.name, 5, n)), g(n, 1)];
    }
  };
}
function _checkInRHS(e) {
  if (Object(e) !== e) throw TypeError("right-hand side of 'in' should be an object, got " + (null !== e ? typeof e : "null"));
  return e;
}
function _identity(t) {
  return t;
}
function _setFunctionName(e, t, n) {
  "symbol" == typeof t && (t = (t = t.description) ? "[" + t + "]" : "");
  try {
    Object.defineProperty(e, "name", {
      configurable: !0,
      value: n ? n + " " + t : t
    });
  } catch (e) {}
  return e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _usingCtx() {
  var r = "function" == typeof SuppressedError ? SuppressedError : function (r, e) {
      var n = Error();
      return n.name = "SuppressedError", n.error = r, n.suppressed = e, n;
    },
    e = {},
    n = [];
  function using(r, e) {
    if (null != e) {
      if (Object(e) !== e) throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");
      if (r) var o = e[Symbol.asyncDispose || Symbol.for("Symbol.asyncDispose")];
      if (void 0 === o && (o = e[Symbol.dispose || Symbol.for("Symbol.dispose")], r)) var t = o;
      if ("function" != typeof o) throw new TypeError("Object is not disposable.");
      t && (o = function () {
        try {
          t.call(e);
        } catch (r) {
          return Promise.reject(r);
        }
      }), n.push({
        v: e,
        d: o,
        a: r
      });
    } else r && n.push({
      d: e,
      a: r
    });
    return e;
  }
  return {
    e: e,
    u: using.bind(null, false),
    a: using.bind(null, true),
    d: function () {
      var o,
        t = this.e,
        s = 0;
      function next() {
        for (; o = n.pop();) try {
          if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);
          if (o.d) {
            var r = o.d.call(o.v);
            if (o.a) return s |= 2, Promise.resolve(r).then(next, err);
          } else s |= 1;
        } catch (r) {
          return err(r);
        }
        if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();
        if (t !== e) throw t;
      }
      function err(n) {
        return t = t !== e ? new r(n, t) : n, next();
      }
      return next();
    }
  };
}

const kInternal = Symbol('kInternal');
class JSStringMap {
  #map = new Map();
  clear() {
    this.#map.clear();
  }
  delete(key) {
    if (key instanceof JSStringValue) {
      key = key.stringValue();
    }
    return this.#map.delete(key);
  }
  forEach(callbackfn, thisArg) {
    this.#map.forEach((value, key) => Reflect.apply(callbackfn, thisArg, [value, typeof key === 'string' ? Value(key) : key, this]));
  }
  get(key) {
    if (key instanceof JSStringValue) {
      key = key.stringValue();
    }
    return this.#map.get(key);
  }
  has(key) {
    if (key instanceof JSStringValue) {
      key = key.stringValue();
    }
    return this.#map.has(key);
  }
  set(key, value) {
    if (key instanceof JSStringValue) {
      key = key.stringValue();
    }
    this.#map.set(key, value);
    return this;
  }
  get size() {
    return this.#map.size;
  }
  *entries() {
    for (const [key, value] of this.#map.entries()) {
      yield [Value(key), value];
    }
    return undefined;
  }
  *keys() {
    for (const key of this.#map.keys()) {
      yield Value(key);
    }
    return undefined;
  }
  values() {
    return this.#map.values();
  }
  static {
    JSStringMap.prototype[Symbol.toStringTag] = 'JSStringMap';
    JSStringMap.prototype[Symbol.iterator] = JSStringMap.prototype.entries;
  }
  mark(m) {
    for (const [k, v] of this.#map.entries()) {
      m(k);
      m(v);
    }
  }
}
class PropertyKeyMap {
  #map = new Map();
  clear() {
    this.#map.clear();
  }
  delete(key) {
    if (key instanceof JSStringValue) {
      key = key.stringValue();
    }
    return this.#map.delete(key);
  }
  forEach(callbackfn, thisArg) {
    this.#map.forEach((value, key) => Reflect.apply(callbackfn, thisArg, [value, typeof key === 'string' ? Value(key) : key, this]));
  }
  get(key) {
    if (key instanceof JSStringValue) {
      key = key.stringValue();
    }
    return this.#map.get(key);
  }
  has(key) {
    if (key instanceof JSStringValue) {
      key = key.stringValue();
    }
    return this.#map.has(key);
  }
  set(key, value) {
    if (key instanceof JSStringValue) {
      key = key.stringValue();
    }
    this.#map.set(key, value);
    return this;
  }
  get size() {
    return this.#map.size;
  }
  *entries() {
    for (const [key, value] of this.#map.entries()) {
      if (typeof key === 'string') {
        yield [Value(key), value];
      } else {
        yield [key, value];
      }
    }
    return undefined;
  }
  *keys() {
    for (const key of this.#map.keys()) {
      if (typeof key === 'string') {
        yield Value(key);
      } else {
        yield key;
      }
    }
    return undefined;
  }
  *values() {
    for (const value of this.#map.values()) {
      yield value;
    }
    return undefined;
  }
  static {
    PropertyKeyMap.prototype[Symbol.toStringTag] = 'PropertyKeyMap';
    PropertyKeyMap.prototype[Symbol.iterator] = PropertyKeyMap.prototype.entries;
  }
  mark(m) {
    for (const [k, v] of this.#map.entries()) {
      m(k);
      m(v);
    }
  }
}
class JSStringSet {
  #set = new Set();
  constructor(value) {
    if (value) {
      for (const item of value) {
        this.add(item);
      }
    }
  }
  add(value) {
    this.#set.add(typeof value === 'string' ? value : value.stringValue());
    return this;
  }
  clear() {
    this.#set.clear();
  }
  delete(value) {
    return this.#set.delete(typeof value === 'string' ? value : value.stringValue());
  }
  forEach(callbackfn, thisArg) {
    for (const value of this.#set) {
      Reflect.apply(callbackfn, thisArg, [Value(value), Value(value), this]);
    }
  }
  has(value) {
    if (value instanceof NullValue) {
      return false;
    }
    return this.#set.has(typeof value === 'string' ? value : value.stringValue());
  }
  get size() {
    return this.#set.size;
  }
  *entries() {
    for (const value of this.#set) {
      yield [Value(value), Value(value)];
    }
    return undefined;
  }
  *values() {
    for (const value of this.#set) {
      yield Value(value);
    }
    return undefined;
  }
  static {
    JSStringSet.prototype[Symbol.toStringTag] = 'JSStringSet';
    JSStringSet.prototype[Symbol.iterator] = JSStringSet.prototype.values;
    JSStringSet.prototype.keys = JSStringSet.prototype.values;
  }
  mark(_m) {}
}
let OutOfRange$1 = class OutOfRange extends RangeError {
  /* node:coverage disable */

  detail;
  constructor(fn, detail) {
    super(`${fn}() argument out of range`, {
      cause: detail
    });
    this.detail = detail;
  }
};
/* node:coverage enable */

function skipDebugger(iterator, maxSteps = Infinity) {
  let steps = 0;
  while (true) {
    const {
      done,
      value
    } = iterator.next({
      type: 'debugger-resume',
      value: undefined
    });
    if (done) {
      return value;
    }
    /* node:coverage ignore next 4 */
    steps += 1;
    if (steps > maxSteps) {
      throw new RangeError('Max steps exceeded');
    }
  }
}
function* resume(context, completion) {
  let result;
  while (true) {
    result = context.codeEvaluationState.next(completion);
    if (result.done) {
      return result.value;
    }
    const {
      value
    } = result;
    if (value.type === 'debugger' || value.type === 'potential-debugger') {
      completion = yield value;
    } else if (value.type === 'await' || value.type === 'async-generator-yield') {
      return Value.undefined;
    } else if (value.type === 'yield') {
      return value.value;
    } else {
      unreachable();
    }
  }
}
class CallSite {
  context;
  lastNode = null;
  nextNode = null;
  lastCallNode = null;
  inheritedLastCallNode = null;
  constructCall = false;
  constructor(context) {
    this.context = context;
  }
  clone(context = this.context) {
    const c = new CallSite(context);
    c.lastNode = this.lastNode;
    c.lastCallNode = this.lastCallNode;
    c.inheritedLastCallNode = this.inheritedLastCallNode;
    c.constructCall = this.constructCall;
    return c;
  }
  isTopLevel() {
    return this.context.Function === Value.null;
  }
  isConstructCall() {
    return this.constructCall;
  }
  isAsync() {
    if (!(this.context.Function instanceof NullValue) && isECMAScriptFunctionObject(this.context.Function) && this.context.Function.ECMAScriptCode) {
      const code = this.context.Function.ECMAScriptCode;
      return code.type === 'AsyncBody' || code.type === 'AsyncGeneratorBody';
    }
    return false;
  }
  isNative() {
    return isBuiltinFunctionObject(this.context.Function);
  }
  getFunctionName() {
    if (isFunctionObject(this.context.Function)) {
      const name = this.context.Function.properties.get('name');
      if (name && name.Value) {
        /* X */
        let _temp = ToString(name.Value);
        /* node:coverage ignore next */
        if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
        /* node:coverage ignore next */
        if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ToString(name.Value) returned an abrupt completion", {
          cause: _temp
        });
        /* node:coverage ignore next */
        if (_temp instanceof Completion) _temp = _temp.Value;
        return _temp.stringValue();
      }
    }
    return null;
  }
  getSpecifier() {
    if (!(this.context.Function instanceof NullValue) && !(this.context.ScriptOrModule instanceof NullValue)) {
      return this.context.ScriptOrModule.HostDefined.specifier;
    }
    return null;
  }
  getScriptId() {
    if (!(this.context.ScriptOrModule instanceof NullValue)) {
      return this.context.ScriptOrModule.HostDefined.scriptId;
    }
    return this.context.HostDefined?.scriptId;
  }
  setLocation(node) {
    this.lastNode = node;
  }
  setNextLocation(node) {
    this.nextNode = node;
  }
  setCallLocation(node) {
    this.lastCallNode = node;
  }
  get lineNumber() {
    if (this.lastNode) {
      return this.lastNode.location.start.line;
    }
    return null;
  }
  get columnNumber() {
    if (this.lastNode) {
      return this.lastNode.location.start.column;
    }
    return null;
  }
  loc() {
    if (this.isNative()) {
      return 'native';
    }
    let out = '';
    const specifier = this.getSpecifier();
    if (specifier) {
      out += specifier;
    } else {
      out += '<anonymous>';
    }
    if (this.lineNumber !== null) {
      out += `:${this.lineNumber}`;
      if (this.columnNumber !== null) {
        out += `:${this.columnNumber}`;
      }
    }
    return out.trim();
  }
  toString() {
    const isAsync = this.isAsync();
    const functionName = this.getFunctionName();
    const isConstructCall = this.isConstructCall();
    const isMethodCall = !isConstructCall && !this.isTopLevel();
    let visualFunctionName;
    if (this.inheritedLastCallNode?.CallExpression.type === 'IdentifierReference') {
      visualFunctionName = this.inheritedLastCallNode.CallExpression.name;
    }
    if (visualFunctionName === functionName) {
      visualFunctionName = undefined;
    }
    let string = isAsync ? 'async ' : '';
    if (isConstructCall) {
      string += 'new ';
    }
    if (isMethodCall || isConstructCall) {
      if (functionName) {
        string += functionName;
      } else {
        string += '<anonymous>';
      }
      if (visualFunctionName) {
        string += ` (as ${visualFunctionName})`;
      }
    } else if (functionName) {
      string += functionName;
      if (visualFunctionName) {
        string += ` (as ${visualFunctionName})`;
      }
    } else {
      return `${string}${this.loc()}`;
    }
    return `${string} (${this.loc()})`;
  }
  toCallFrame() {
    const source = this.getScriptId();
    if (source === undefined || source === null) {
      return undefined;
    }
    return {
      columnNumber: (this.columnNumber || 1) - 1,
      lineNumber: (this.lineNumber || 1) - 1,
      functionName: this.getFunctionName() || '<anonymous>',
      scriptId: source,
      url: this.getSpecifier() || '<anonymous>'
    };
  }
}
const kAsyncContext = Symbol('kAsyncContext');
function captureAsyncStack(stack) {
  let promise = stack[0].context.promiseCapability.Promise;
  for (let i = 0; i < 10; i += 1) {
    if (promise.PromiseFulfillReactions.length !== 1) {
      return;
    }
    const [reaction] = promise.PromiseFulfillReactions;
    if (reaction.Handler && reaction.Handler.Callback[kAsyncContext]) {
      const asyncContext = reaction.Handler.Callback[kAsyncContext];
      stack.push(asyncContext.callSite.clone());
      if ('PromiseState' in asyncContext.promiseCapability.Promise) {
        promise = asyncContext.promiseCapability.Promise;
      } else {
        return;
      }
    } else if (!(reaction.Capability instanceof UndefinedValue)) {
      if ('PromiseState' in reaction.Capability.Promise) {
        promise = reaction.Capability.Promise;
      } else {
        return;
      }
    }
  }
}
function getHostDefinedErrorStack(O) {
  if (O instanceof ObjectValue && 'HostDefinedErrorStack' in O && isArray(O.HostDefinedErrorStack)) {
    return O.HostDefinedErrorStack;
  }
  return undefined;
}
function getCurrentStack(excludeGlobalStack = true) {
  const stack = [];
  for (let i = surroundingAgent.executionContextStack.length - (excludeGlobalStack ? 2 : 1); i >= 0; i -= 1) {
    const e = surroundingAgent.executionContextStack[i];
    if (e.VariableEnvironment === undefined && e.Function === Value.null) {
      break;
    }
    const clone = e.callSite.clone();
    const parent = stack[stack.length - 1];
    if (parent && !parent.context.poppedForTailCall) {
      parent.inheritedLastCallNode = clone.lastCallNode;
    }
    stack.push(clone);
    if (e.callSite.isAsync()) {
      i -= 1; // skip original execution context which has no useful information.
    }
  }
  if (stack.length > 0 && stack[0].context.promiseCapability) {
    captureAsyncStack(stack);
  }
  return stack;
}
function captureStack() {
  const stack = getCurrentStack();
  let nativeStack;
  if (surroundingAgent.hostDefinedOptions.errorStackAttachNativeStack) {
    const origStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 12;
    try {
      nativeStack = new Error().stack;
    } finally {
      Error.stackTraceLimit = origStackTraceLimit;
    }
  }
  return {
    stack,
    nativeStack
  };
}
function* errorStackToString(O, stack, nativeStack = Value.undefined) {
  /* ReturnIfAbrupt */
  let _temp2 = yield* Call(surroundingAgent.intrinsic('%Error.prototype.toString%'), O);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  let errorString = _temp2.stringValue();
  stack.forEach(s => {
    errorString = `${errorString}\n    at ${s.toString()}`;
  });
  if (typeof nativeStack === 'string') {
    errorString = `${errorString}\n    <NATIVE>\n${nativeStack.split('\n').slice(6).join('\n')}`;
  }
  return Value(errorString);
}
function callable(onCalled = (target, _thisArg, args) => Reflect.construct(target, args)) {
  const handler = Object.freeze({
    __proto__: null,
    apply: onCalled
  });
  return function decorator(classValue, _classContext) {
    return new Proxy(classValue, handler);
  };
}
const isArray = Array.isArray;
function unreachable(_) {
  throw new Error('Unreachable');
}

let _initClass2$1;
let createStringValue; // set by static block in StringValue for privileged access to constructor
let createNumberValue; // set by static block in NumberValue for privileged access to constructor
let createBigIntValue; // set by static block in BigIntValue for privileged access to constructor

class BaseValue {}

/** https://tc39.es/ecma262/#sec-ecmascript-language-types */

/** https://tc39.es/ecma262/#sec-ecmascript-language-types */
const Value = (_initClass => {
  let _Value;
  class Value extends BaseValue {
    static {
      [_Value, _initClass] = _applyDecs2311(this, [callable((_target, _thisArg, [value]) => {
        if (value === null) {
          return _Value.null;
        } else if (value === undefined) {
          return _Value.undefined;
        } else if (value === true) {
          return _Value.true;
        } else if (value === false) {
          return _Value.false;
        }
        switch (typeof value) {
          case 'string':
            return createStringValue(value);
          case 'number':
            return createNumberValue(value);
          case 'bigint':
            return createBigIntValue(value);
          /* node:coverage ignore next */default:
            /* node:coverage ignore next */
            throw new OutOfRange$1('new Value', value);
        }
      })], [], 0, void 0, BaseValue).c;
    }
    static {
      _initClass();
    }
  }
  return _Value;
})();

/** https://tc39.es/ecma262/#sec-ecmascript-language-types */

/** https://tc39.es/ecma262/#sec-ecmascript-language-types */

/** https://tc39.es/ecma262/#sec-ecmascript-language-types */
const PrimitiveValue = (() => {
  return (() => {
    // NOTE: Using nested IIFE so that the class does not conflict with the type of the same name
    // NOTE: Only using IIFE because TypeScript errors when `abstract` is used on class expressions
    class PrimitiveValue extends Value {}
    return PrimitiveValue;
  })();
})();

/** https://tc39.es/ecma262/#sec-ecmascript-language-types-undefined-type */
class UndefinedValue extends PrimitiveValue {
  // defined on prototype by static block

  // defined on prototype by static block

  constructor() {
    // eslint-disable-line no-useless-constructor -- Sets privacy for constructor
    super();
  }
  static {
    Object.defineProperty(this.prototype, 'type', {
      value: 'Undefined'
    });
    Object.defineProperty(this.prototype, 'value', {
      value: undefined
    });
    Object.defineProperty(Value, 'undefined', {
      value: new this()
    });
  }
}

/** https://tc39.es/ecma262/#sec-ecmascript-language-types-null-type */
class NullValue extends PrimitiveValue {
  // defined on prototype by static block

  // defined on prototype by static block

  constructor() {
    // eslint-disable-line no-useless-constructor -- Sets privacy for constructor
    super();
  }
  static {
    Object.defineProperty(this.prototype, 'type', {
      value: 'Null'
    });
    Object.defineProperty(this.prototype, 'value', {
      value: null
    });
    Object.defineProperty(Value, 'null', {
      value: new this()
    });
  }
}

/** https://tc39.es/ecma262/#sec-ecmascript-language-types-boolean-type */
class BooleanValue extends PrimitiveValue {
  // defined on prototype by static block

  value;
  constructor(value) {
    super();
    this.value = value;
  }
  booleanValue() {
    return this.value;
  }
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return `Boolean { ${this.value} }`;
  }
  static {
    Object.defineProperty(this.prototype, 'type', {
      value: 'Boolean'
    });
    Object.defineProperty(Value, 'true', {
      value: new this(true)
    });
    Object.defineProperty(Value, 'false', {
      value: new this(false)
    });
  }
}

/** https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type */
class JSStringValue extends PrimitiveValue {
  // defined on prototype by static block

  value;
  constructor(value) {
    super();
    this.value = value;
  }
  stringValue() {
    return this.value;
  }
  static {
    Object.defineProperty(this.prototype, 'type', {
      value: 'String'
    });
    createStringValue = value => new this(value);
  }
}

/** https://tc39.es/ecma262/#sec-ecmascript-language-types-symbol-type */
class SymbolValue extends PrimitiveValue {
  // defined on prototype by static block

  Description;
  constructor(Description) {
    super();
    this.Description = Description;
  }
  static {
    Object.defineProperty(this.prototype, 'type', {
      value: 'Symbol'
    });
  }
}

/** https://tc39.es/ecma262/#sec-ecmascript-language-types-symbol-type */
const wellKnownSymbols = {
  asyncIterator: new SymbolValue(Value('Symbol.asyncIterator')),
  hasInstance: new SymbolValue(Value('Symbol.hasInstance')),
  isConcatSpreadable: new SymbolValue(Value('Symbol.isConcatSpreadable')),
  iterator: new SymbolValue(Value('Symbol.iterator')),
  match: new SymbolValue(Value('Symbol.match')),
  matchAll: new SymbolValue(Value('Symbol.matchAll')),
  replace: new SymbolValue(Value('Symbol.replace')),
  search: new SymbolValue(Value('Symbol.search')),
  species: new SymbolValue(Value('Symbol.species')),
  split: new SymbolValue(Value('Symbol.split')),
  toPrimitive: new SymbolValue(Value('Symbol.toPrimitive')),
  toStringTag: new SymbolValue(Value('Symbol.toStringTag')),
  unscopables: new SymbolValue(Value('Symbol.unscopables'))
};
Object.setPrototypeOf(wellKnownSymbols, null);
Object.freeze(wellKnownSymbols);

/** https://tc39.es/ecma262/#sec-ecmascript-language-types-number-type */
class NumberValue extends PrimitiveValue {
  // defined on prototype by static block

  value;
  constructor(value) {
    super();
    this.value = value;
  }
  numberValue() {
    return this.value;
  }
  isNaN() {
    return Number.isNaN(this.value);
  }
  isInfinity() {
    return !Number.isFinite(this.value) && !this.isNaN();
  }
  isFinite() {
    return Number.isFinite(this.value);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-unaryMinus */
  static unaryMinus(x) {
    if (x.isNaN()) {
      return F(NaN);
    }
    return F(-R(x));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-bitwiseNOT */
  static bitwiseNOT(x) {
    /* X */
    let _temp = ToInt32(x);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ToInt32(x) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // 1. Let oldValue be ! ToInt32(x).
    const oldValue = _temp;
    // 2. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.
    return F(~R(oldValue));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-exponentiate */
  static exponentiate(base, exponent) {
    return F(R(base) ** R(exponent));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-multiply */
  static multiply(x, y) {
    return F(R(x) * R(y));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-divide */
  static divide(x, y) {
    return F(R(x) / R(y));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-remainder */
  static remainder(n, d) {
    return F(R(n) % R(d));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-add */
  static add(x, y) {
    return F(R(x) + R(y));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-subtract */
  static subtract(x, y) {
    // The result of - operator is x + (-y).
    return NumberValue.add(x, F(-R(y)));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-leftShift */
  static leftShift(x, y) {
    /* X */
    let _temp2 = ToInt32(x);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! ToInt32(x) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // 1. Let lnum be ! ToInt32(x).
    const lnum = _temp2;
    // 2. Let rnum be ! ToUint32(y).
    /* X */
    let _temp3 = ToUint32(y);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToUint32(y) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const rnum = _temp3;
    // 3. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
    const shiftCount = R(rnum) & 0x1F; // eslint-disable-line no-bitwise
    // 4. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.
    return F(R(lnum) << shiftCount); // eslint-disable-line no-bitwise
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-signedRightShift */
  static signedRightShift(x, y) {
    /* X */
    let _temp4 = ToInt32(x);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! ToInt32(x) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // 1. Let lnum be ! ToInt32(x).
    const lnum = _temp4;
    // 2. Let rnum be ! ToUint32(y).
    /* X */
    let _temp5 = ToUint32(y);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! ToUint32(y) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    const rnum = _temp5;
    // 3. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
    const shiftCount = R(rnum) & 0x1F; // eslint-disable-line no-bitwise
    // 4. Return the result of performing a sign-extending right shift of lnum by shiftCount bits.
    //    The most significant bit is propagated. The result is a signed 32-bit integer.
    return F(R(lnum) >> shiftCount); // eslint-disable-line no-bitwise
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-unsignedRightShift */
  static unsignedRightShift(x, y) {
    /* X */
    let _temp6 = ToInt32(x);
    /* node:coverage ignore next */
    if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! ToInt32(x) returned an abrupt completion", {
      cause: _temp6
    });
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    // 1. Let lnum be ! ToInt32(x).
    const lnum = _temp6;
    // 2. Let rnum be ! ToUint32(y).
    /* X */
    let _temp7 = ToUint32(y);
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! ToUint32(y) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const rnum = _temp7;
    // 3. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
    const shiftCount = R(rnum) & 0x1F; // eslint-disable-line no-bitwise
    // 4. Return the result of performing a zero-filling right shift of lnum by shiftCount bits.
    //    Vacated bits are filled with zero. The result is an unsigned 32-bit integer.
    return F(R(lnum) >>> shiftCount); // eslint-disable-line no-bitwise
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-lessThan */
  static lessThan(x, y) {
    if (x.isNaN()) {
      return Value.undefined;
    }
    if (y.isNaN()) {
      return Value.undefined;
    }
    // If nx and ny are the same Number value, return false.
    // If nx is +0 and ny is -0, return false.
    // If nx is -0 and ny is +0, return false.
    if (R(x) === R(y)) {
      return Value.false;
    }
    if (R(x) === +Infinity) {
      return Value.false;
    }
    if (R(y) === +Infinity) {
      return Value.true;
    }
    if (R(y) === -Infinity) {
      return Value.false;
    }
    if (R(x) === -Infinity) {
      return Value.true;
    }
    return R(x) < R(y) ? Value.true : Value.false;
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-equal */
  static equal(x, y) {
    if (x.isNaN()) {
      return Value.false;
    }
    if (y.isNaN()) {
      return Value.false;
    }
    const xVal = R(x);
    const yVal = R(y);
    if (xVal === yVal) {
      return Value.true;
    }
    if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
      return Value.true;
    }
    if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
      return Value.true;
    }
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-sameValue */
  static sameValue(x, y) {
    if (x.isNaN() && y.isNaN()) {
      return Value.true;
    }
    const xVal = R(x);
    const yVal = R(y);
    if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
      return Value.false;
    }
    if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
      return Value.false;
    }
    if (xVal === yVal) {
      return Value.true;
    }
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-sameValueZero */
  static sameValueZero(x, y) {
    if (x.isNaN() && y.isNaN()) {
      return Value.true;
    }
    const xVal = R(x);
    const yVal = R(y);
    if (Object.is(xVal, 0) && Object.is(yVal, -0)) {
      return Value.true;
    }
    if (Object.is(xVal, -0) && Object.is(yVal, 0)) {
      return Value.true;
    }
    if (xVal === yVal) {
      return Value.true;
    }
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-bitwiseAND */
  static bitwiseAND(x, y) {
    // 1. Return NumberBitwiseOp(&, x, y).
    return NumberBitwiseOp('&', x, y);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-bitwiseXOR */
  static bitwiseXOR(x, y) {
    // 1. Return NumberBitwiseOp(^, x, y).
    return NumberBitwiseOp('^', x, y);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-bitwiseOR */
  static bitwiseOR(x, y) {
    // 1. Return NumberBitwiseOp(|, x, y).
    return NumberBitwiseOp('|', x, y);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-number-tostring */
  static toString(xV, radix) {
    if (xV.isNaN()) {
      return Value('NaN');
    }
    const x = R(xV);
    if (Object.is(x, -0) || Object.is(x, 0)) {
      return Value('0');
    }
    if (x < 0) {
      return Value(`-${NumberValue.toString(F(-x), radix).stringValue()}`);
    }
    if (xV.isInfinity()) {
      return Value('Infinity');
    }
    // TODO: implement properly, currently depends on host.
    return Value(`${x.toString(radix)}`);
  }
  static unit = new NumberValue(1);
  static {
    Object.defineProperty(this.prototype, 'type', {
      value: 'Number'
    });
    createNumberValue = value => new NumberValue(value);
  }
}

/** https://tc39.es/ecma262/#sec-numberbitwiseop */
function NumberBitwiseOp(op, x, y) {
  /* X */
  let _temp8 = ToInt32(x);
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! ToInt32(x) returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 1. Let lnum be ! ToInt32(x).
  const lnum = _temp8;
  // 2. Let rnum be ! ToUint32(y).
  /* X */
  let _temp9 = ToUint32(y);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! ToUint32(y) returned an abrupt completion", {
    cause: _temp9
  });
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const rnum = _temp9;
  // 3. Return the result of applying the bitwise operator op to lnum and rnum. The result is a signed 32-bit integer.
  switch (op) {
    case '&':
      return F(R(lnum) & R(rnum));
    case '|':
      return F(R(lnum) | R(rnum));
    case '^':
      return F(R(lnum) ^ R(rnum));
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('NumberBitwiseOp', op);
  }
}
NumberBitwiseOp.section = 'https://tc39.es/ecma262/#sec-numberbitwiseop';
/** https://tc39.es/ecma262/#sec-ecmascript-language-types-bigint-type */
class BigIntValue extends PrimitiveValue {
  // defined on prototype by static block

  value;
  constructor(value) {
    super();
    this.value = value;
  }
  bigintValue() {
    return this.value;
  }
  isNaN() {
    return false;
  }
  isFinite() {
    return true;
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-unaryMinus */
  static unaryMinus(x) {
    if (R(x) === 0n) {
      return Z(0n);
    }
    return Z(-R(x));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-bitwiseNOT */
  static bitwiseNOT(x) {
    return Z(-R(x) - 1n);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-exponentiate */
  static exponentiate(base, exponent) {
    // 1. If exponent < 0n, throw a RangeError exception.
    if (R(exponent) < 0n) {
      return surroundingAgent.Throw('RangeError', 'BigIntNegativeExponent');
    }
    // 2. If base is 0n and exponent is 0n, return 1n.
    if (R(base) === 0n && R(exponent) === 0n) {
      return Z(1n);
    }
    // 3. Return the BigInt value that represents the mathematical value of base raised to the power exponent.
    return Z(R(base) ** R(exponent));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-multiply */
  static multiply(x, y) {
    return Z(R(x) * R(y));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-divide */
  static divide(x, y) {
    // 1. If y is 0n, throw a RangeError exception.
    if (R(y) === 0n) {
      return surroundingAgent.Throw('RangeError', 'BigIntDivideByZero');
    }
    // 2. Let quotient be the mathematical value of x divided by y.
    const quotient = R(x) / R(y);
    // 3. Return the BigInt value that represents quotient rounded towards 0 to the next integral value.
    return Z(quotient);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-remainder */
  static remainder(n, d) {
    // 1. If d is 0n, throw a RangeError exception.
    if (R(d) === 0n) {
      return surroundingAgent.Throw('RangeError', 'BigIntDivideByZero');
    }
    // 2. If n is 0n, return 0n.
    if (R(n) === 0n) {
      return Z(0n);
    }
    // 3. Let r be the BigInt defined by the mathematical relation r = n - (d × q)
    //   where q is a BigInt that is negative only if n/d is negative and positive
    //   only if n/d is positive, and whose magnitude is as large as possible without
    //   exceeding the magnitude of the true mathematical quotient of n and d.
    const r = Z(R(n) % R(d));
    // 4. Return r.
    return r;
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-add */
  static add(x, y) {
    return Z(R(x) + R(y));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-subtract */
  static subtract(x, y) {
    return Z(R(x) - R(y));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-leftShift */
  static leftShift(x, y) {
    return Z(R(x) << R(y)); // eslint-disable-line no-bitwise
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-signedRightShift */
  static signedRightShift(x, y) {
    // 1. Return BigInt::leftShift(x, -y).
    return BigIntValue.leftShift(x, Z(-R(y)));
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-unsignedRightShift */
  static unsignedRightShift(_x, _y) {
    return surroundingAgent.Throw('TypeError', 'BigIntUnsignedRightShift');
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-lessThan */
  static lessThan(x, y) {
    return R(x) < R(y) ? Value.true : Value.false;
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-equal */
  static equal(x, y) {
    // Return true if x and y have the same mathematical integer value and false otherwise.
    return R(x) === R(y) ? Value.true : Value.false;
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-sameValue */
  static sameValue(x, y) {
    // 1. Return BigInt::equal(x, y).
    return BigIntValue.equal(x, y);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-sameValueZero */
  static sameValueZero(x, y) {
    // 1. Return BigInt::equal(x, y).
    return BigIntValue.equal(x, y);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-bitwiseAND */
  static bitwiseAND(x, y) {
    // 1. Return BigIntBitwiseOp(&, x, y).
    return BigIntBitwiseOp('&', x, y);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-bitwiseXOR */
  static bitwiseXOR(x, y) {
    // 1. Return BigIntBitwiseOp(^, x, y).
    return BigIntBitwiseOp('^', x, y);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-bitwiseOR */
  static bitwiseOR(x, y) {
    // 1. Return BigIntBitwiseOp(|, x, y);
    return BigIntBitwiseOp('|', x, y);
  }

  /** https://tc39.es/ecma262/#sec-numeric-types-bigint-tostring */
  static toString(x, radix) {
    // 1. If x is less than zero, return the string-concatenation of the String "-" and ! BigInt::toString(-x).
    if (R(x) < 0n) {
      /* X */
      let _temp10 = BigIntValue.toString(Z(-R(x)), radix);
      /* node:coverage ignore next */
      if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
      /* node:coverage ignore next */
      if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! BigIntValue.toString(Z(-R(x)), radix) returned an abrupt completion", {
        cause: _temp10
      });
      /* node:coverage ignore next */
      if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
      const str = _temp10.stringValue();
      return Value(`-${str}`);
    }
    // 2. Return the String value consisting of the code units of the digits of the decimal representation of x.
    return Value(`${R(x).toString(radix)}`);
  }
  static unit = new BigIntValue(1n);
  static {
    Object.defineProperty(this.prototype, 'type', {
      value: 'BigInt'
    });
    createBigIntValue = value => new BigIntValue(value);
  }
}

/** https://tc39.es/ecma262/#sec-bigintbitwiseop */
function BigIntBitwiseOp(op, x, y) {
  // TODO: figure out why this doesn't work, probably the modulo.
  /*
  // 1. Assert: op is "&", "|", or "^".
  Assert(['&', '|', '^'].includes(op));
  // 2. Let result be 0n.
  let result = 0n;
  // 3. Let shift be 0.
  let shift = 0n;
  // 4. Repeat, until (x = 0 or x = -1) and (y = 0 or y = -1),
  while (!((x === 0n || x === -1n) && (y === 0n || y === -1n))) {
    // a. Let xDigit be x modulo 2.
    const xDigit = x % 2n;
    // b. Let yDigit be y modulo 2.
    const yDigit = y % 2n;
    // c. If op is "&", set result to result + 2^shift × BinaryAnd(xDigit, yDigit).
    if (op === '&') {
      result += (2n ** shift) * BinaryAnd(xDigit, yDigit);
    } else if (op === '|') {
      // d. Else if op is "|", set result to result + 2shift × BinaryOr(xDigit, yDigit).
      result += (2n ** shift) * BinaryXor(xDigit, yDigit);
    } else {
      // i. Assert: op is "^".
      Assert(op === '^');
      // ii. Set result to result + 2^shift × BinaryXor(xDigit, yDigit).
      result += (2n ** shift) * BinaryXor(xDigit, yDigit);
    }
    // f. Set shift to shift + 1.
    shift += 1n;
    // g. Set x to (x - xDigit) / 2.
    x = (x - xDigit) / 2n;
    // h. Set y to (y - yDigit) / 2.
    y = (y - yDigit) / 2n;
  }
  let tmp;
  // 5. If op is "&", let tmp be BinaryAnd(x modulo 2, y modulo 2).
  if (op === '&') {
    tmp = BinaryAnd(x % 2n, y % 2n);
  } else if (op === '|') {
    // 6. Else if op is "|", let tmp be BinaryOr(x modulo 2, y modulo 2).
    tmp = BinaryOr(x % 2n, y % 2n);
  } else {
    // a. Assert: op is "^".
    Assert(op === '^');
    // b. Let tmp be BinaryXor(x modulo 2, y modulo 2).
    tmp = BinaryXor(x % 2n, y % 2n);
  }
  // 8. If tmp ≠ 0, then
  if (tmp !== 0n) {
    // a. Set result to result - 2^shift. NOTE: This extends the sign.
    result -= 2n ** shift;
  }
  // 9. Return result.
  return Z(result);
  */
  switch (op) {
    case '&':
      return Z(R(x) & R(y));
    case '|':
      return Z(R(x) | R(y));
    case '^':
      return Z(R(x) ^ R(y));
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('BigIntBitwiseOp', op);
  }
}
BigIntBitwiseOp.section = 'https://tc39.es/ecma262/#sec-bigintbitwiseop';
/** https://tc39.es/ecma262/#sec-object-type */
class ObjectValue extends Value {
  // defined on prototype by static block

  properties;
  internalSlotsList;
  PrivateElements;
  constructor(internalSlotsList) {
    super();
    this.PrivateElements = [];
    this.properties = new PropertyKeyMap();
    this.internalSlotsList = internalSlotsList;
    surroundingAgent.debugger_markObjectCreated(this);
  }

  // UNSAFE casts below. Methods below are expected to be rewritten when the object is not an OrdinaryObject. (an example is ArgumentExoticObject)
  // If those methods aren't rewritten, it is an error.
  // eslint-disable-next-line require-yield
  *GetPrototypeOf() {
    return OrdinaryGetPrototypeOf(this);
  }

  // eslint-disable-next-line require-yield
  *SetPrototypeOf(V) {
    /* ReturnIfAbrupt */
    let _temp11 = surroundingAgent.debugger_tryTouchDuringPreview(this);
    /* node:coverage ignore next */
    if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) return _temp11;
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    return OrdinarySetPrototypeOf(this, V);
  }

  // eslint-disable-next-line require-yield
  *IsExtensible() {
    return OrdinaryIsExtensible(this);
  }

  // eslint-disable-next-line require-yield
  *PreventExtensions() {
    /* ReturnIfAbrupt */
    let _temp12 = surroundingAgent.debugger_tryTouchDuringPreview(this);
    /* node:coverage ignore next */
    if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) return _temp12;
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    return OrdinaryPreventExtensions(this);
  }

  // eslint-disable-next-line require-yield
  *GetOwnProperty(P) {
    return OrdinaryGetOwnProperty(this, P);
  }
  *DefineOwnProperty(P, Desc) {
    /* ReturnIfAbrupt */
    let _temp13 = surroundingAgent.debugger_tryTouchDuringPreview(this);
    /* node:coverage ignore next */
    if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) return _temp13;
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    return yield* OrdinaryDefineOwnProperty(this, P, Desc);
  }
  *HasProperty(P) {
    return yield* OrdinaryHasProperty(this, P);
  }
  *Get(P, Receiver) {
    return yield* OrdinaryGet(this, P, Receiver);
  }
  *Set(P, V, Receiver) {
    /* ReturnIfAbrupt */
    let _temp14 = surroundingAgent.debugger_tryTouchDuringPreview(Receiver);
    /* node:coverage ignore next */
    if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) return _temp14;
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    return yield* OrdinarySet(this, P, V, Receiver);
  }
  *Delete(P) {
    /* ReturnIfAbrupt */
    let _temp15 = surroundingAgent.debugger_tryTouchDuringPreview(this);
    /* node:coverage ignore next */
    if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) return _temp15;
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    return yield* OrdinaryDelete(this, P);
  }

  // eslint-disable-next-line require-yield
  *OwnPropertyKeys() {
    return OrdinaryOwnPropertyKeys(this);
  }

  // NON-SPEC
  mark(m) {
    m(this.properties);
    this.internalSlotsList.forEach(s => {
      // @ts-ignore
      m(this[s]);
      if (s === 'HostCapturedValues' && s in this && Array.isArray(this[s])) {
        this[s].forEach(m);
      }
    });
  }
  static {
    Object.defineProperty(this.prototype, 'type', {
      value: 'Object'
    });
  }
}

/** https://tc39.es/ecma262/#sec-private-names */
class PrivateName {
  // NOTE: The following declaration distinguishes `PrivateName` from `SymbolValue` so that type guards can properly
  //       remove it from unions with `SymbolValue` due to structural overlap.

  Description;
  constructor(description) {
    this.Description = description;
  }
}
class ReferenceRecord {
  Base;
  ReferencedName;
  Strict;
  ThisValue;
  constructor({
    Base,
    ReferencedName,
    Strict,
    ThisValue
  }) {
    this.Base = Base;
    this.ReferencedName = ReferencedName;
    this.Strict = Strict;
    this.ThisValue = ThisValue;
  }

  // NON-SPEC
  mark(m) {
    m(this.Base);
    m(this.ReferencedName);
    m(this.ThisValue);
  }
}

// @ts-expect-error
let _Descriptor;
// @ts-expect-error
class Descriptor {
  static {
    [_Descriptor, _initClass2$1] = _applyDecs2311(this, [callable()], []).c;
  }
  Value;
  Get;
  Set;
  Writable;
  Enumerable;
  Configurable;
  constructor(O) {
    this.Value = O.Value;
    this.Get = O.Get;
    this.Set = O.Set;
    this.Writable = O.Writable;
    this.Enumerable = O.Enumerable;
    this.Configurable = O.Configurable;
  }
  everyFieldIsAbsent() {
    return this.Value === undefined && this.Get === undefined && this.Set === undefined && this.Writable === undefined && this.Enumerable === undefined && this.Configurable === undefined;
  }

  // NON-SPEC
  mark(m) {
    m(this.Value);
    m(this.Get);
    m(this.Set);
  }
  static {
    _initClass2$1();
  }
}
class DataBlock extends Uint8Array {
  constructor(sizeOrBuffer, byteOffset, length) {
    if (sizeOrBuffer instanceof ArrayBuffer) {
      super(sizeOrBuffer, byteOffset, length);
    } else {
      Assert(typeof sizeOrBuffer === 'number', "typeof sizeOrBuffer === 'number'");
      super(sizeOrBuffer);
    }
  }
}

/** https://tc39.es/ecma262/#sec-sametype */
function SameType(x, y) {
  switch (true) {
    case x === Value.undefined && y === Value.undefined:
    case x === Value.null && y === Value.null:
    case x instanceof BooleanValue && y instanceof BooleanValue:
    case x instanceof NumberValue && y instanceof NumberValue:
    case x instanceof BigIntValue && y instanceof BigIntValue:
    case x instanceof SymbolValue && y instanceof SymbolValue:
    case x instanceof JSStringValue && y instanceof JSStringValue:
    case x instanceof ObjectValue && y instanceof ObjectValue:
      return true;
    default:
      return false;
  }
}
SameType.section = 'https://tc39.es/ecma262/#sec-sametype';

function StringValue(node) {
  switch (node.type) {
    case 'IdentifierName':
    case 'BindingIdentifier':
    case 'IdentifierReference':
    case 'LabelIdentifier':
      return Value(node.name);
    case 'PrivateIdentifier':
      return Value(`#${node.name}`);
    case 'StringLiteral':
      return Value(node.value);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('StringValue', node);
  }
}

/** https://tc39.es/ecma262/#sec-static-semantics-isstatic */
// ClassElement :
//   MethodDefinition
//   `static` MethodDefinition
//   `;`
function IsStatic(ClassElement) {
  return ClassElement.static;
}
IsStatic.section = 'https://tc39.es/ecma262/#sec-static-semantics-isstatic';

/** https://tc39.es/ecma262/#sec-static-semantics-nonconstructorelements */
// ClassElementList :
//   ClassElement
//   ClassElementList ClassElement
function NonConstructorElements(ClassElementList) {
  return ClassElementList.filter(ClassElement => {
    if (ClassElement.static === false && PropName(ClassElement) === 'constructor') {
      return false;
    }
    return true;
  });
}
NonConstructorElements.section = 'https://tc39.es/ecma262/#sec-static-semantics-nonconstructorelements';

/** https://tc39.es/ecma262/#sec-static-semantics-constructormethod */
// ClassElementList :
//   ClassElement
//   ClassElementList ClassElement
function ConstructorMethod(ClassElementList) {
  return ClassElementList.find(ClassElement => ClassElement.static === false && PropName(ClassElement) === 'constructor');
}
ConstructorMethod.section = 'https://tc39.es/ecma262/#sec-static-semantics-constructormethod';

function PropName(node) {
  switch (node.type) {
    case 'IdentifierName':
      return node.name;
    case 'StringLiteral':
      return node.value;
    case 'MethodDefinition':
    case 'GeneratorMethod':
    case 'AsyncGeneratorMethod':
    case 'AsyncMethod':
    case 'FieldDefinition':
      return PropName(node.ClassElementName);
    default:
      return undefined;
  }
}

/** https://tc39.es/ecma262/#sec-numericvalue */

function NumericValue(node) {
  return Value(node.value);
}

/** https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition */
function IsAnonymousFunctionDefinition(expr) {
  // 1. If IsFunctionDefinition of expr is false, return false.
  if (!IsFunctionDefinition(expr)) {
    return false;
  }
  // 1. Let hasName be HasName of expr.
  const hasName = HasName(expr);
  // 1. If hasName is true, return false.
  if (hasName) {
    return false;
  }
  // 1. Return true.
  return true;
}
IsAnonymousFunctionDefinition.section = 'https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition';

function IsFunctionDefinition(node) {
  if (node.type === 'ParenthesizedExpression') {
    return IsFunctionDefinition(node.Expression);
  }
  return node.type === 'FunctionExpression' || node.type === 'GeneratorExpression' || node.type === 'AsyncGeneratorExpression' || node.type === 'AsyncFunctionExpression' || node.type === 'ClassExpression' || node.type === 'ArrowFunction' || node.type === 'AsyncArrowFunction';
}

function HasName(node) {
  if (node.type === 'ParenthesizedExpression') {
    return HasName(node.Expression);
  }
  return 'BindingIdentifier' in node && !!node.BindingIdentifier;
}

function IsIdentifierRef(node) {
  return node.type === 'IdentifierReference';
}

function LexicallyDeclaredNames(node) {
  switch (node.type) {
    case 'Script':
      if (node.ScriptBody) {
        return LexicallyDeclaredNames(node.ScriptBody);
      }
      return [];
    case 'ScriptBody':
      return TopLevelLexicallyDeclaredNames(node.StatementList);
    case 'FunctionBody':
    case 'GeneratorBody':
    case 'AsyncBody':
    case 'AsyncGeneratorBody':
      return TopLevelLexicallyDeclaredNames(node.FunctionStatementList);
    case 'ClassStaticBlockBody':
      return TopLevelLexicallyDeclaredNames(node.ClassStaticBlockStatementList);
    default:
      return [];
  }
}

function TopLevelLexicallyDeclaredNames(node) {
  if (isArray(node)) {
    const names = [];
    for (const StatementListItem of node) {
      names.push(...TopLevelLexicallyDeclaredNames(StatementListItem));
    }
    return names;
  }
  switch (node.type) {
    case 'ClassDeclaration':
    case 'LexicalDeclaration':
      return BoundNames(node);
    default:
      return [];
  }
}

function BoundNames(node) {
  if (isArray(node)) {
    const names = [];
    for (const item of node) {
      names.push(...BoundNames(item));
    }
    return names;
  }
  switch (node.type) {
    case 'BindingIdentifier':
      return [StringValue(node)];
    case 'LexicalDeclaration':
      return BoundNames(node.BindingList);
    case 'LexicalBinding':
      if (node.BindingIdentifier) {
        return BoundNames(node.BindingIdentifier);
      }
      return BoundNames(node.BindingPattern);
    case 'VariableStatement':
      return BoundNames(node.VariableDeclarationList);
    case 'VariableDeclaration':
      if (node.BindingIdentifier) {
        return BoundNames(node.BindingIdentifier);
      }
      return BoundNames(node.BindingPattern);
    case 'ForDeclaration':
      return BoundNames(node.ForBinding);
    case 'ForBinding':
      if (node.BindingIdentifier) {
        return BoundNames(node.BindingIdentifier);
      }
      return BoundNames(node.BindingPattern);
    case 'FunctionDeclaration':
    case 'GeneratorDeclaration':
    case 'AsyncFunctionDeclaration':
    case 'AsyncGeneratorDeclaration':
    case 'ClassDeclaration':
      if (node.BindingIdentifier) {
        return BoundNames(node.BindingIdentifier);
      }
      return [Value('*default*')];
    case 'ImportSpecifier':
      return BoundNames(node.ImportedBinding);
    case 'ExportDeclaration':
      if (node.FromClause || node.NamedExports) {
        return [];
      }
      if (node.VariableStatement) {
        return BoundNames(node.VariableStatement);
      }
      if (node.Declaration) {
        return BoundNames(node.Declaration);
      }
      if (node.HoistableDeclaration) {
        const declarationNames = BoundNames(node.HoistableDeclaration);
        return declarationNames;
      }
      if (node.ClassDeclaration) {
        const declarationNames = BoundNames(node.ClassDeclaration);
        return declarationNames;
      }
      if (node.AssignmentExpression) {
        return [Value('*default*')];
      }
      /* node:coverage ignore next */
      throw new OutOfRange$1('BoundNames', node);
    case 'SingleNameBinding':
      return BoundNames(node.BindingIdentifier);
    case 'BindingRestElement':
      if (node.BindingIdentifier) {
        return BoundNames(node.BindingIdentifier);
      }
      return BoundNames(node.BindingPattern);
    case 'BindingRestProperty':
      return BoundNames(node.BindingIdentifier);
    case 'BindingElement':
      return BoundNames(node.BindingPattern);
    case 'BindingProperty':
      return BoundNames(node.BindingElement);
    case 'ObjectBindingPattern':
      {
        const names = BoundNames(node.BindingPropertyList);
        if (node.BindingRestProperty) {
          names.push(...BoundNames(node.BindingRestProperty));
        }
        return names;
      }
    case 'ArrayBindingPattern':
      {
        const names = BoundNames(node.BindingElementList);
        if (node.BindingRestElement) {
          names.push(...BoundNames(node.BindingRestElement));
        }
        return names;
      }
    default:
      return [];
  }
}

function VarDeclaredNames(node) {
  if (isArray(node)) {
    const names = [];
    for (const item of node) {
      names.push(...VarDeclaredNames(item));
    }
    return names;
  }
  switch (node.type) {
    case 'VariableStatement':
      return BoundNames(node.VariableDeclarationList);
    case 'VariableDeclaration':
      return BoundNames(node);
    case 'IfStatement':
      {
        const names = VarDeclaredNames(node.Statement_a);
        if (node.Statement_b) {
          names.push(...VarDeclaredNames(node.Statement_b));
        }
        return names;
      }
    case 'Block':
      return VarDeclaredNames(node.StatementList);
    case 'WhileStatement':
      return VarDeclaredNames(node.Statement);
    case 'DoWhileStatement':
      return VarDeclaredNames(node.Statement);
    case 'ForStatement':
      {
        const names = [];
        if (node.VariableDeclarationList) {
          names.push(...VarDeclaredNames(node.VariableDeclarationList));
        }
        names.push(...VarDeclaredNames(node.Statement));
        return names;
      }
    case 'ForInStatement':
    case 'ForOfStatement':
    case 'ForAwaitStatement':
      {
        const names = [];
        if (node.ForBinding) {
          names.push(...BoundNames(node.ForBinding));
        }
        names.push(...VarDeclaredNames(node.Statement));
        return names;
      }
    case 'WithStatement':
      return VarDeclaredNames(node.Statement);
    case 'SwitchStatement':
      return VarDeclaredNames(node.CaseBlock);
    case 'CaseBlock':
      {
        const names = [];
        if (node.CaseClauses_a) {
          names.push(...VarDeclaredNames(node.CaseClauses_a));
        }
        if (node.DefaultClause) {
          names.push(...VarDeclaredNames(node.DefaultClause));
        }
        if (node.CaseClauses_b) {
          names.push(...VarDeclaredNames(node.CaseClauses_b));
        }
        return names;
      }
    case 'CaseClause':
    case 'DefaultClause':
      if (node.StatementList) {
        return VarDeclaredNames(node.StatementList);
      }
      return [];
    case 'LabelledStatement':
      return VarDeclaredNames(node.LabelledItem);
    case 'TryStatement':
      {
        const names = VarDeclaredNames(node.Block);
        if (node.Catch) {
          names.push(...VarDeclaredNames(node.Catch));
        }
        if (node.Finally) {
          names.push(...VarDeclaredNames(node.Finally));
        }
        return names;
      }
    case 'Catch':
      return VarDeclaredNames(node.Block);
    case 'Script':
      if (node.ScriptBody) {
        return VarDeclaredNames(node.ScriptBody);
      }
      return [];
    case 'ScriptBody':
      return TopLevelVarDeclaredNames(node.StatementList);
    case 'FunctionBody':
    case 'GeneratorBody':
    case 'AsyncBody':
    case 'AsyncGeneratorBody':
      return TopLevelVarDeclaredNames(node.FunctionStatementList);
    case 'ClassStaticBlockBody':
      return TopLevelVarDeclaredNames(node.ClassStaticBlockStatementList);
    case 'ExportDeclaration':
      if (node.VariableStatement) {
        return BoundNames(node);
      }
      return [];
    default:
      return [];
  }
}

function TopLevelVarDeclaredNames(node) {
  if (isArray(node)) {
    const names = [];
    for (const item of node) {
      names.push(...TopLevelVarDeclaredNames(item));
    }
    return names;
  }
  switch (node.type) {
    case 'ClassDeclaration':
    case 'LexicalDeclaration':
      return [];
    case 'FunctionDeclaration':
    case 'GeneratorDeclaration':
    case 'AsyncFunctionDeclaration':
    case 'AsyncGeneratorDeclaration':
      return BoundNames(node);
    default:
      return VarDeclaredNames(node);
  }
}

function VarScopedDeclarations(node) {
  if (isArray(node)) {
    const declarations = [];
    for (const item of node) {
      declarations.push(...VarScopedDeclarations(item));
    }
    return declarations;
  }
  switch (node.type) {
    case 'VariableStatement':
      return VarScopedDeclarations(node.VariableDeclarationList);
    case 'VariableDeclaration':
      return [node];
    case 'Block':
      return VarScopedDeclarations(node.StatementList);
    case 'IfStatement':
      {
        const declarations = VarScopedDeclarations(node.Statement_a);
        if (node.Statement_b) {
          declarations.push(...VarScopedDeclarations(node.Statement_b));
        }
        return declarations;
      }
    case 'WhileStatement':
      return VarScopedDeclarations(node.Statement);
    case 'DoWhileStatement':
      return VarScopedDeclarations(node.Statement);
    case 'ForStatement':
      {
        const names = [];
        if (node.VariableDeclarationList) {
          names.push(...VarScopedDeclarations(node.VariableDeclarationList));
        }
        names.push(...VarScopedDeclarations(node.Statement));
        return names;
      }
    case 'ForInStatement':
    case 'ForOfStatement':
    case 'ForAwaitStatement':
      {
        const declarations = [];
        if (node.ForBinding) {
          declarations.push(node.ForBinding);
        }
        declarations.push(...VarScopedDeclarations(node.Statement));
        return declarations;
      }
    case 'WithStatement':
      return VarScopedDeclarations(node.Statement);
    case 'SwitchStatement':
      return VarScopedDeclarations(node.CaseBlock);
    case 'CaseBlock':
      {
        const names = [];
        if (node.CaseClauses_a) {
          names.push(...VarScopedDeclarations(node.CaseClauses_a));
        }
        if (node.DefaultClause) {
          names.push(...VarScopedDeclarations(node.DefaultClause));
        }
        if (node.CaseClauses_b) {
          names.push(...VarScopedDeclarations(node.CaseClauses_b));
        }
        return names;
      }
    case 'CaseClause':
    case 'DefaultClause':
      if (node.StatementList) {
        return VarScopedDeclarations(node.StatementList);
      }
      return [];
    case 'LabelledStatement':
      return VarScopedDeclarations(node.LabelledItem);
    case 'TryStatement':
      {
        const declarations = VarScopedDeclarations(node.Block);
        if (node.Catch) {
          declarations.push(...VarScopedDeclarations(node.Catch));
        }
        if (node.Finally) {
          declarations.push(...VarScopedDeclarations(node.Finally));
        }
        return declarations;
      }
    case 'Catch':
      return VarScopedDeclarations(node.Block);
    case 'ExportDeclaration':
      if (node.VariableStatement) {
        return VarScopedDeclarations(node.VariableStatement);
      }
      return [];
    case 'Script':
      if (node.ScriptBody) {
        return VarScopedDeclarations(node.ScriptBody);
      }
      return [];
    case 'ScriptBody':
      return TopLevelVarScopedDeclarations(node.StatementList);
    case 'Module':
      if (node.ModuleBody) {
        return VarScopedDeclarations(node.ModuleBody);
      }
      return [];
    case 'ModuleBody':
      return VarScopedDeclarations(node.ModuleItemList);
    case 'FunctionBody':
    case 'GeneratorBody':
    case 'AsyncBody':
    case 'AsyncGeneratorBody':
      return TopLevelVarScopedDeclarations(node.FunctionStatementList);
    case 'ClassStaticBlockBody':
      return TopLevelVarScopedDeclarations(node.ClassStaticBlockStatementList);
    default:
      return [];
  }
}

function TopLevelVarScopedDeclarations(node) {
  if (isArray(node)) {
    const declarations = [];
    for (const item of node) {
      declarations.push(...TopLevelVarScopedDeclarations(item));
    }
    return declarations;
  }
  switch (node.type) {
    case 'ClassDeclaration':
    case 'LexicalDeclaration':
      return [];
    case 'FunctionDeclaration':
    case 'GeneratorDeclaration':
    case 'AsyncFunctionDeclaration':
    case 'AsyncGeneratorDeclaration':
      return [DeclarationPart(node)];
    default:
      return VarScopedDeclarations(node);
  }
}

function DeclarationPart(node) {
  return node;
}

function LexicallyScopedDeclarations(node) {
  if (isArray(node)) {
    const declarations = [];
    for (const item of node) {
      declarations.push(...LexicallyScopedDeclarations(item));
    }
    return declarations;
  }
  switch (node.type) {
    case 'LabelledStatement':
      return LexicallyScopedDeclarations(node.LabelledItem);
    case 'Script':
      if (node.ScriptBody) {
        return LexicallyScopedDeclarations(node.ScriptBody);
      }
      return [];
    case 'ScriptBody':
      return TopLevelLexicallyScopedDeclarations(node.StatementList);
    case 'Module':
      if (node.ModuleBody) {
        return LexicallyScopedDeclarations(node.ModuleBody);
      }
      return [];
    case 'ModuleBody':
      return LexicallyScopedDeclarations(node.ModuleItemList);
    case 'FunctionBody':
    case 'GeneratorBody':
    case 'AsyncBody':
    case 'AsyncGeneratorBody':
      return TopLevelLexicallyScopedDeclarations(node.FunctionStatementList);
    case 'ClassStaticBlockBody':
      return TopLevelLexicallyScopedDeclarations(node.ClassStaticBlockStatementList);
    case 'ImportDeclaration':
      return [];
    case 'ClassDeclaration':
    case 'LexicalDeclaration':
    case 'FunctionDeclaration':
    case 'GeneratorDeclaration':
    case 'AsyncFunctionDeclaration':
    case 'AsyncGeneratorDeclaration':
      return [DeclarationPart(node)];
    case 'CaseBlock':
      {
        const names = [];
        if (node.CaseClauses_a) {
          names.push(...LexicallyScopedDeclarations(node.CaseClauses_a));
        }
        if (node.DefaultClause) {
          names.push(...LexicallyScopedDeclarations(node.DefaultClause));
        }
        if (node.CaseClauses_b) {
          names.push(...LexicallyScopedDeclarations(node.CaseClauses_b));
        }
        return names;
      }
    case 'CaseClause':
    case 'DefaultClause':
      if (node.StatementList) {
        return LexicallyScopedDeclarations(node.StatementList);
      }
      return [];
    case 'ExportDeclaration':
      if (node.Declaration) {
        return [DeclarationPart(node.Declaration)];
      }
      if (node.HoistableDeclaration) {
        return [DeclarationPart(node.HoistableDeclaration)];
      }
      if (node.ClassDeclaration) {
        return [node.ClassDeclaration];
      }
      if (node.AssignmentExpression) {
        return [node];
      }
      return [];
    default:
      return [];
  }
}

function TopLevelLexicallyScopedDeclarations(node) {
  if (isArray(node)) {
    const declarations = [];
    for (const item of node) {
      declarations.push(...TopLevelLexicallyScopedDeclarations(item));
    }
    return declarations;
  }
  switch (node.type) {
    case 'ClassDeclaration':
    case 'LexicalDeclaration':
      return [node];
    default:
      return [];
  }
}

function IsConstantDeclaration(node) {
  return node === 'const' || typeof node === 'object' && 'LetOrConst' in node && node.LetOrConst === 'const';
}

function IsInTailPosition(_node) {
  return false;
}

function ExpectedArgumentCount(FormalParameterList) {
  if (FormalParameterList.length === 0) {
    return 0;
  }
  let count = 0;
  for (const FormalParameter of FormalParameterList.slice(0, -1)) {
    const BindingElement = FormalParameter;
    if (HasInitializer(BindingElement)) {
      return count;
    }
    count += 1;
  }
  const last = FormalParameterList[FormalParameterList.length - 1];
  if (last.type === 'BindingRestElement') {
    return count;
  }
  if (HasInitializer(last)) {
    return count;
  }
  return count + 1;
}

function HasInitializer(node) {
  return 'Initializer' in node && !!node.Initializer;
}

function IsSimpleParameterList(node) {
  if (isArray(node)) {
    for (const n of node) {
      if (!IsSimpleParameterList(n)) {
        return false;
      }
    }
    return true;
  }
  switch (node.type) {
    case 'SingleNameBinding':
      return node.Initializer === null;
    case 'BindingElement':
      return false;
    case 'BindingRestElement':
      return false;
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('IsSimpleParameterList', node);
  }
}

function ContainsExpression(node) {
  if (isArray(node)) {
    for (const n of node) {
      if (ContainsExpression(n)) {
        return true;
      }
    }
    return false;
  }
  switch (node.type) {
    case 'SingleNameBinding':
      return !!node.Initializer;
    case 'BindingElement':
      if (ContainsExpression(node.BindingPattern)) {
        return true;
      }
      return !!node.Initializer;
    case 'ObjectBindingPattern':
      if (ContainsExpression(node.BindingPropertyList)) {
        return true;
      }
      if (node.BindingRestProperty) {
        return ContainsExpression(node.BindingRestProperty);
      }
      return false;
    case 'BindingProperty':
      if (node.PropertyName && 'ComputedPropertyName' in node.PropertyName && node.PropertyName.ComputedPropertyName) {
        return true;
      }
      return ContainsExpression(node.BindingElement);
    case 'BindingRestProperty':
      if (node.BindingIdentifier) {
        return false;
      }
      // TODO(ts): BindingRestProperty and BindingElement is different. Is there missing a case?
      // @ts-expect-error
      return ContainsExpression(node.BindingPattern);
    case 'ArrayBindingPattern':
      if (ContainsExpression(node.BindingElementList)) {
        return true;
      }
      if (node.BindingRestElement) {
        return ContainsExpression(node.BindingRestElement);
      }
      return false;
    case 'BindingRestElement':
      if (node.BindingIdentifier) {
        return false;
      }
      return ContainsExpression(node.BindingPattern);
    case 'Elision':
      return false;
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('ContainsExpression', node);
  }
}

/** https://tc39.es/ecma262/#sec-static-semantics-isstrict */
function IsStrict({
  ScriptBody
}) {
  // 1. If ScriptBody is present and the Directive Prologue of ScriptBody contains a Use Strict Directive, return true; otherwise, return false.
  return ScriptBody.strict;
}
IsStrict.section = 'https://tc39.es/ecma262/#sec-static-semantics-isstrict';

/** https://tc39.es/ecma262/#sec-static-semantics-bodytext */
//  RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags
function BodyText(RegularExpressionLiteral) {
  return RegularExpressionLiteral.RegularExpressionBody;
}
BodyText.section = 'https://tc39.es/ecma262/#sec-static-semantics-bodytext';

/** https://tc39.es/ecma262/#sec-static-semantics-flagtext */
//   RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags
function FlagText(RegularExpressionLiteral) {
  return RegularExpressionLiteral.RegularExpressionFlags;
}
FlagText.section = 'https://tc39.es/ecma262/#sec-static-semantics-flagtext';

// https://tc39.es/ecma262/#modulerequest-record

// https://tc39.es/ecma262/#importattribute-record

function stringsEqual(left, right) {
  return left === right || left.stringValue() === right.stringValue();
}

// https://tc39.es/ecma262/#sec-ModuleRequestsEqual
function ModuleRequestsEqual(left, right) {
  if (!stringsEqual(left.Specifier, right.Specifier)) {
    return false;
  }
  const leftAttrs = left.Attributes;
  const rightAttrs = right.Attributes;
  const leftAttrsCount = leftAttrs.length;
  const rightAttrsCount = rightAttrs.length;
  if (leftAttrsCount !== rightAttrsCount) {
    return false;
  }
  for (const l of leftAttrs) {
    if (!rightAttrs.some(r => stringsEqual(l.Key, r.Key) && stringsEqual(l.Value, r.Value))) {
      return false;
    }
  }
  return true;
}
ModuleRequestsEqual.section = 'https://tc39.es/ecma262/#sec-ModuleRequestsEqual'; // https://tc39.es/ecma262/#sec-withclausetoattributes
function WithClauseToAttributes(node) {
  const attributes = [];
  for (const attribute of node.WithEntries) {
    attributes.push({
      Key: StringValue(attribute.AttributeKey),
      Value: StringValue(attribute.AttributeValue)
    });
  }
  attributes.sort((a, b) => a.Key.value < b.Key.value ? -1 : 1);
  return attributes;
}
WithClauseToAttributes.section = 'https://tc39.es/ecma262/#sec-withclausetoattributes';
function ModuleRequests(node) {
  switch (node.type) {
    case 'Module':
      if (node.ModuleBody) {
        return ModuleRequests(node.ModuleBody);
      }
      return [];
    case 'ModuleBody':
      {
        const requests = [];
        for (const item of node.ModuleItemList) {
          const additionalRequests = ModuleRequests(item);
          for (const mr of additionalRequests) {
            if (!requests.some(r => ModuleRequestsEqual(r, mr))) {
              requests.push(mr);
            }
          }
        }
        return requests;
      }
    case 'ImportDeclaration':
      if (node.FromClause) {
        const specifier = StringValue(node.FromClause);
        const attributes = node.WithClause ? WithClauseToAttributes(node.WithClause) : [];
        return [{
          Specifier: specifier,
          Attributes: attributes
        }];
      }
      if (node.ModuleSpecifier) {
        const specifier = StringValue(node.ModuleSpecifier);
        const attributes = node.WithClause ? WithClauseToAttributes(node.WithClause) : [];
        return [{
          Specifier: specifier,
          Attributes: attributes
        }];
      }
      throw new Error('Unreachable: all imports must have either an ImportClause or a ModuleSpecifier');
    case 'ExportDeclaration':
      if (node.FromClause) {
        const specifier = StringValue(node.FromClause);
        const attributes = node.WithClause ? WithClauseToAttributes(node.WithClause) : [];
        return [{
          Specifier: specifier,
          Attributes: attributes
        }];
      }
      return [];
    default:
      return [];
  }
}

function ImportEntries(node) {
  switch (node.type) {
    case 'Module':
      if (node.ModuleBody) {
        return ImportEntries(node.ModuleBody);
      }
      return [];
    case 'ModuleBody':
      {
        const entries = [];
        for (const item of node.ModuleItemList) {
          entries.push(...ImportEntries(item));
        }
        return entries;
      }
    case 'ImportDeclaration':
      if (node.FromClause) {
        // 1. Let module be the sole element of ModuleRequests of FromClause.
        const module = ModuleRequests(node)[0];
        // 2. Return ImportEntriesForModule of ImportClause with argument module.
        return ImportEntriesForModule(node.ImportClause, module);
      }
      return [];
    default:
      return [];
  }
}

function ExportEntries(node) {
  if (isArray(node)) {
    const entries = [];
    node.forEach(n => {
      entries.push(...ExportEntries(n));
    });
    return entries;
  }
  switch (node.type) {
    case 'Module':
      if (!node.ModuleBody) {
        return [];
      }
      return ExportEntries(node.ModuleBody);
    case 'ModuleBody':
      return ExportEntries(node.ModuleItemList);
    case 'ExportDeclaration':
      switch (true) {
        case !!node.ExportFromClause && !!node.FromClause:
          {
            // `export` ExportFromClause FromClause WithClause? `;`
            // 1. Let module be the sole element of ModuleRequests of FromClause.
            const module = ModuleRequests(node)[0];
            // 2. Return ExportEntriesForModule(ExportFromClause, module).
            return ExportEntriesForModule(node.ExportFromClause, module);
          }
        case !!node.NamedExports:
          {
            // `export` NamedExports `;`
            // 1. Return ExportEntriesForModule(NamedExports, null).
            return ExportEntriesForModule(node.NamedExports, Value.null);
          }
        case !!node.VariableStatement:
          {
            // `export` VariableStatement
            // 1. Let entries be a new empty List.
            const entries = [];
            // 2. Let names be the BoundNames of VariableStatement.
            const names = BoundNames(node.VariableStatement);
            // 3. For each name in names, do
            for (const name of names) {
              // a. Append the ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: name, [[ExportName]]: name } to entries.
              entries.push({
                ModuleRequest: Value.null,
                ImportName: Value.null,
                LocalName: name,
                ExportName: name
              });
            }
            // 4. Return entries.
            return entries;
          }
        case !!node.Declaration:
          {
            // `export` Declaration
            // 1. Let entries be a new empty List.
            const entries = [];
            // 2. Let names be the BoundNames of Declaration.
            const names = BoundNames(node.Declaration);
            // 3. For each name in names, do
            for (const name of names) {
              // a. Append the ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: name, [[ExportName]]: name } to entries.
              entries.push({
                ModuleRequest: Value.null,
                ImportName: Value.null,
                LocalName: name,
                ExportName: name
              });
            }
            // 4. Return entries.
            return entries;
          }
        case node.default && !!node.HoistableDeclaration:
          {
            // `export` `default` HoistableDeclaration
            // 1. Let names be BoundNames of HoistableDeclaration.
            const names = BoundNames(node.HoistableDeclaration);
            // 2. Let localName be the sole element of names.
            const localName = names[0];
            // 3. Return a new List containing the ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: localName, [[ExportName]]: "default" }.
            return [{
              ModuleRequest: Value.null,
              ImportName: Value.null,
              LocalName: localName,
              ExportName: Value('default')
            }];
          }
        case node.default && !!node.ClassDeclaration:
          {
            // `export` `default` ClassDeclaration
            // 1. Let names be BoundNames of ClassDeclaration.
            const names = BoundNames(node.ClassDeclaration);
            // 2. Let localName be the sole element of names.
            const localName = names[0];
            // 3. Return a new List containing the ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: localName, [[ExportName]]: "default" }.
            return [{
              ModuleRequest: Value.null,
              ImportName: Value.null,
              LocalName: localName,
              ExportName: Value('default')
            }];
          }
        case node.default && !!node.AssignmentExpression:
          {
            // `export` `default` AssignmentExpression `;`
            // 1. Let entry be the ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: "*default*", [[ExportName]]: "default" }.
            const entry = {
              ModuleRequest: Value.null,
              ImportName: Value.null,
              LocalName: Value('*default*'),
              ExportName: Value('default')
            };
            // 2. Return a new List containing entry.
            return [entry];
          }
        /* node:coverage ignore next */default:
          /* node:coverage ignore next */
          throw new OutOfRange$1('ExportEntries', node);
      }
    default:
      return [];
  }
}

/** https://tc39.es/ecma262/#sec-importedlocalnames */
function ImportedLocalNames(importEntries) {
  // 1. Let localNames be a new empty List.
  const localNames = [];
  // 2. For each ImportEntry Record i in importEntries, do
  for (const i of importEntries) {
    // a. Append i.[[LocalName]] to localNames.
    localNames.push(i.LocalName);
  }
  // 3. Return localNames.
  return localNames;
}
ImportedLocalNames.section = 'https://tc39.es/ecma262/#sec-importedlocalnames';

function IsDestructuring(node) {
  switch (node.type) {
    case 'ObjectBindingPattern':
    case 'ArrayBindingPattern':
    case 'ObjectLiteral':
    case 'ArrayLiteral':
      return true;
    case 'ForDeclaration':
      return IsDestructuring(node.ForBinding);
    case 'ForBinding':
      if (node.BindingIdentifier) {
        return false;
      }
      return true;
    default:
      return false;
  }
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var regex$2;
var hasRequiredRegex$2;

function requireRegex$2 () {
	if (hasRequiredRegex$2) return regex$2;
	hasRequiredRegex$2 = 1;
	regex$2=/[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]/;
	return regex$2;
}

var regexExports$2 = requireRegex$2();
var isUnicodeIDStartRegex = /*@__PURE__*/getDefaultExportFromCjs(regexExports$2);

var regex$1;
var hasRequiredRegex$1;

function requireRegex$1 () {
	if (hasRequiredRegex$1) return regex$1;
	hasRequiredRegex$1 = 1;
	regex$1=/[0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u0870-\u0887\u0889-\u088E\u0897-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1715\u171F-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B4C\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA827\uA82C\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF65-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDD40-\uDD65\uDD69-\uDD6D\uDD6F-\uDD85\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDEC2-\uDEC4\uDEFC-\uDF1C\uDF27\uDF30-\uDF50\uDF70-\uDF85\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC75\uDC7F-\uDCBA\uDCC2\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDCE-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E-\uDE41\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7-\uDFC0\uDFC2\uDFC5\uDFC7-\uDFCA\uDFCC-\uDFD3\uDFE1\uDFE2]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E-\uDC61\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDED0-\uDEE3\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39\uDF40-\uDF46]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD43\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0\uDFF0-\uDFF9]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDF00-\uDF10\uDF12-\uDF3A\uDF3E-\uDF42\uDF50-\uDF5A\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC40-\uDC55\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD39]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDD70-\uDD79\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFE4\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD833[\uDCF0-\uDCF9\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC30-\uDC6D\uDC8F\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAE\uDEC0-\uDEF9]|\uD839[\uDCD0-\uDCF9\uDDD0-\uDDFA\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]|\uDB40[\uDD00-\uDDEF]/;
	return regex$1;
}

var regexExports$1 = requireRegex$1();
var isUnicodeIDContinueRegex = /*@__PURE__*/getDefaultExportFromCjs(regexExports$1);

var regex;
var hasRequiredRegex;

function requireRegex () {
	if (hasRequiredRegex) return regex;
	hasRequiredRegex = 1;
	regex=/[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
	return regex;
}

var regexExports = requireRegex();
var isSpaceSeparatorRegex = /*@__PURE__*/getDefaultExportFromCjs(regexExports);

/** Coerces a property key into a numeric index */

const MaybeAssignTokens = [
// Logical
['NULLISH', '??', 3], ['OR', '||', 4], ['AND', '&&', 5],
// Binop
['BIT_OR', '|', 6], ['BIT_XOR', '^', 7], ['BIT_AND', '&', 8], ['SHL', '<<', 11], ['SAR', '>>', 11], ['SHR', '>>>', 11], ['MUL', '*', 13], ['DIV', '/', 13], ['MOD', '%', 13], ['EXP', '**', 14],
// Unop
['ADD', '+', 12], ['SUB', '-', 12]];
const RawTokens = [
// BEGIN PropertyOrCall
// BEGIN Member
// BEGIN Template
['TEMPLATE', '`'],
// END Template

// BEGIN Property
['PERIOD', '.'], ['LBRACK', '['],
// END Property
// END Member
['OPTIONAL', '?.'], ['LPAREN', '('],
// END PropertyOrCall
['RPAREN', ')'], ['RBRACK', ']'], ['LBRACE', '{'], ['COLON', ':'], ['ELLIPSIS', '...'], ['CONDITIONAL', '?'],
// BEGIN AutoSemicolon
['SEMICOLON', ';'], ['RBRACE', '}'], ['EOS', 'EOS'],
// END AutoSemicolon

// BEGIN ArrowOrAssign
['ARROW', '=>'],
// BEGIN Assign
['ASSIGN', '=', 2], ...MaybeAssignTokens.map(t => [`ASSIGN_${t[0]}`, `${t[1]}=`, 2]),
// END Assign
// END ArrowOrAssign

// Binary operators by precidence
['COMMA', ',', 1], ...MaybeAssignTokens, ['NOT', '!'], ['BIT_NOT', '~'], ['DELETE', 'delete'], ['TYPEOF', 'typeof'], ['VOID', 'void'],
// BEGIN IsCountOp
['INC', '++'], ['DEC', '--'],
// END IsCountOp
// END IsUnaryOrCountOp

['EQ', '==', 9], ['EQ_STRICT', '===', 9], ['NE', '!=', 9], ['NE_STRICT', '!==', 9], ['LT', '<', 10], ['GT', '>', 10], ['LTE', '<=', 10], ['GTE', '>=', 10], ['INSTANCEOF', 'instanceof', 10], ['IN', 'in', 10], ['BREAK', 'break'], ['CASE', 'case'], ['CATCH', 'catch'], ['CONTINUE', 'continue'], ['DEBUGGER', 'debugger'], ['DEFAULT', 'default'],
// DELETE
['DO', 'do'], ['ELSE', 'else'], ['FINALLY', 'finally'], ['FOR', 'for'], ['FUNCTION', 'function'], ['IF', 'if'],
// IN
// INSTANCEOF
['NEW', 'new'], ['RETURN', 'return'], ['SWITCH', 'switch'], ['THROW', 'throw'], ['TRY', 'try'],
// TYPEOF
['VAR', 'var'],
// VOID
['WHILE', 'while'], ['WITH', 'with'], ['THIS', 'this'], ['NULL', 'null'], ['TRUE', 'true'], ['FALSE', 'false'], ['NUMBER', null], ['STRING', null], ['BIGINT', null],
// BEGIN Callable
['SUPER', 'super'],
// BEGIN AnyIdentifier
['IDENTIFIER', null], ['AWAIT', 'await'], ['YIELD', 'yield'],
// END AnyIdentifier
// END Callable
['CLASS', 'class'], ['CONST', 'const'], ['EXPORT', 'export'], ['EXTENDS', 'extends'], ['IMPORT', 'import'], ['PRIVATE_IDENTIFIER', null], ['ENUM', 'enum'], ['ESCAPED_KEYWORD', null]];
const Token = RawTokens.reduce((obj, [name], i) => {
  obj[name] = i;
  return obj;
}, Object.create(null));
const TokenNames = RawTokens.map(r => r[0]);
const TokenValues = RawTokens.map(r => r[1]);
const TokenPrecedence = RawTokens.map(r => r[2] || 0);
const Keywords = RawTokens.filter(([name, raw]) => name.toLowerCase() === raw).map(([, raw]) => raw);
const KeywordLookup = Keywords.reduce((obj, kw) => {
  obj[kw] = Token[kw.toUpperCase()];
  return obj;
}, Object.create(null));
const KeywordRaw = new Set(Object.keys(KeywordLookup));
const KeywordTokens = new Set(Object.values(KeywordLookup));
const isInRange = (t, l, h) => t >= l && t <= h;
const isAutomaticSemicolon = t => isInRange(t, Token.SEMICOLON, Token.EOS);
const isMember = t => isInRange(t, Token.TEMPLATE, Token.LBRACK);
const isPropertyOrCall = t => isInRange(t, Token.TEMPLATE, Token.LPAREN);
const isKeyword = t => KeywordTokens.has(t);
const isKeywordRaw = s => KeywordRaw.has(s);
const ReservedWordsStrict = new Set(['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield']);
const isReservedWordStrict = s => ReservedWordsStrict.has(s);

const isUnicodeIDStart = c => c && isUnicodeIDStartRegex.test(c);
const isUnicodeIDContinue = c => c && isUnicodeIDContinueRegex.test(c);
const isDecimalDigit$1 = c => c && /\d/u.test(c);
const isHexDigit = c => c && /[\da-f]/ui.test(c);
const isOctalDigit = c => c && /[0-7]/u.test(c);
const isBinaryDigit = c => c === '0' || c === '1';
const isWhitespace = c => c && (/[\u0009\u000B\u000C\u0020\u00A0\uFEFF]/u.test(c) || isSpaceSeparatorRegex.test(c)); // eslint-disable-line no-control-regex
const isLineTerminator = c => {
  // Line Separator (U+2028) and Paragraph Separator (U+2029)
  // Line Feed (U+000A) and Carriage Return (U+000D)
  if (typeof c === 'string') {
    return !!c && /[\r\n\u2028\u2029]/u.test(c);
  }
  return c === 0x2028 || c === 0x2029 || c === 0xa || c === 0xd;
};
const isRegularExpressionFlagPart = c => c && (isUnicodeIDContinue(c) || c === '$');
const isIdentifierStart = c => SingleCharTokens[c] === Token.IDENTIFIER || isUnicodeIDStart(c);
const isIdentifierPart = c => SingleCharTokens[c] === Token.IDENTIFIER || c === '\u{200C}' || c === '\u{200D}' || isUnicodeIDContinue(c);
const SingleCharTokens = {
  '__proto__': null,
  '0': Token.NUMBER,
  '1': Token.NUMBER,
  '2': Token.NUMBER,
  '3': Token.NUMBER,
  '4': Token.NUMBER,
  '5': Token.NUMBER,
  '6': Token.NUMBER,
  '7': Token.NUMBER,
  '8': Token.NUMBER,
  '9': Token.NUMBER,
  'a': Token.IDENTIFIER,
  'b': Token.IDENTIFIER,
  'c': Token.IDENTIFIER,
  'd': Token.IDENTIFIER,
  'e': Token.IDENTIFIER,
  'f': Token.IDENTIFIER,
  'g': Token.IDENTIFIER,
  'h': Token.IDENTIFIER,
  'i': Token.IDENTIFIER,
  'j': Token.IDENTIFIER,
  'k': Token.IDENTIFIER,
  'l': Token.IDENTIFIER,
  'm': Token.IDENTIFIER,
  'n': Token.IDENTIFIER,
  'o': Token.IDENTIFIER,
  'p': Token.IDENTIFIER,
  'q': Token.IDENTIFIER,
  'r': Token.IDENTIFIER,
  's': Token.IDENTIFIER,
  't': Token.IDENTIFIER,
  'u': Token.IDENTIFIER,
  'v': Token.IDENTIFIER,
  'w': Token.IDENTIFIER,
  'x': Token.IDENTIFIER,
  'y': Token.IDENTIFIER,
  'z': Token.IDENTIFIER,
  'A': Token.IDENTIFIER,
  'B': Token.IDENTIFIER,
  'C': Token.IDENTIFIER,
  'D': Token.IDENTIFIER,
  'E': Token.IDENTIFIER,
  'F': Token.IDENTIFIER,
  'G': Token.IDENTIFIER,
  'H': Token.IDENTIFIER,
  'I': Token.IDENTIFIER,
  'J': Token.IDENTIFIER,
  'K': Token.IDENTIFIER,
  'L': Token.IDENTIFIER,
  'M': Token.IDENTIFIER,
  'N': Token.IDENTIFIER,
  'O': Token.IDENTIFIER,
  'P': Token.IDENTIFIER,
  'Q': Token.IDENTIFIER,
  'R': Token.IDENTIFIER,
  'S': Token.IDENTIFIER,
  'T': Token.IDENTIFIER,
  'U': Token.IDENTIFIER,
  'V': Token.IDENTIFIER,
  'W': Token.IDENTIFIER,
  'X': Token.IDENTIFIER,
  'Y': Token.IDENTIFIER,
  'Z': Token.IDENTIFIER,
  '$': Token.IDENTIFIER,
  '_': Token.IDENTIFIER,
  '\\': Token.IDENTIFIER,
  '.': Token.PERIOD,
  ',': Token.COMMA,
  ':': Token.COLON,
  ';': Token.SEMICOLON,
  '%': Token.MOD,
  '~': Token.BIT_NOT,
  '!': Token.NOT,
  '+': Token.ADD,
  '-': Token.SUB,
  '*': Token.MUL,
  '<': Token.LT,
  '>': Token.GT,
  '=': Token.ASSIGN,
  '?': Token.CONDITIONAL,
  '[': Token.LBRACK,
  ']': Token.RBRACK,
  '(': Token.LPAREN,
  ')': Token.RPAREN,
  '/': Token.DIV,
  '^': Token.BIT_XOR,
  '`': Token.TEMPLATE,
  '{': Token.LBRACE,
  '}': Token.RBRACE,
  '&': Token.BIT_AND,
  '|': Token.BIT_OR,
  '"': Token.STRING,
  '\'': Token.STRING,
  '#': Token.PRIVATE_IDENTIFIER
};
class TokenData {
  type;
  startIndex;
  endIndex;
  line;
  column;
  hadLineTerminatorBefore;
  name;
  value;
  escaped;
  constructor({
    type,
    startIndex,
    endIndex,
    line,
    column,
    hadLineTerminatorBefore,
    name,
    value,
    escaped
  }) {
    this.type = type;
    this.startIndex = startIndex;
    this.endIndex = endIndex;
    this.line = line;
    this.column = column;
    this.hadLineTerminatorBefore = hadLineTerminatorBefore;
    this.name = name;
    this.value = value;
    this.escaped = escaped;
  }
  valueAsString() {
    Assert(typeof this.value === 'string', "typeof this.value === 'string'");
    return this.value;
  }
  valueAsNumeric() {
    Assert(typeof this.value === 'number' || typeof this.value === 'bigint', "typeof this.value === 'number' || typeof this.value === 'bigint'");
    return this.value;
  }
  valueAsBoolean() {
    Assert(typeof this.value === 'boolean', "typeof this.value === 'boolean'");
    return this.value;
  }
}
class Lexer {
  currentToken; // NOTE: unsound definite assignment operator (`!`)

  peekToken; // NOTE: unsound definite assignment operator (`!`)

  peekAheadToken;
  position = 0;
  line = 1;
  columnOffset = 0;
  scannedValue; // NOTE: unsound definite assignment operator (`!`)

  lineTerminatorBeforeNextToken = false;
  positionForNextToken = 0;
  lineForNextToken = 0;
  columnForNextToken = 0;
  escapeIndex = -1;
  advance() {
    this.lineTerminatorBeforeNextToken = false;
    this.escapeIndex = -1;
    const type = this.nextToken();
    return new TokenData({
      type,
      startIndex: this.positionForNextToken,
      endIndex: this.position,
      line: this.lineForNextToken,
      column: this.columnForNextToken,
      hadLineTerminatorBefore: this.lineTerminatorBeforeNextToken,
      name: TokenNames[type],
      value: TokenValues[type] ?? this.scannedValue,
      escaped: this.escapeIndex !== -1
    });
  }
  next() {
    this.currentToken = this.peekToken;
    if (this.peekAheadToken !== undefined) {
      this.peekToken = this.peekAheadToken;
      this.peekAheadToken = undefined;
    } else {
      this.peekToken = this.advance();
    }
    return this.currentToken;
  }
  peek() {
    if (this.peekToken === undefined) {
      this.next();
    }
    return this.peekToken;
  }
  peekAhead() {
    if (this.peekAheadToken === undefined) {
      this.peek();
      this.peekAheadToken = this.advance();
    }
    return this.peekAheadToken;
  }
  matches(token, peek) {
    if (typeof token === 'string') {
      if (peek.type === Token.IDENTIFIER && peek.value === token) {
        const escapeIndex = this.source.slice(peek.startIndex, peek.endIndex).indexOf('\\');
        if (escapeIndex !== -1) {
          return false;
        }
        return true;
      } else {
        return false;
      }
    }
    return peek.type === token;
  }
  test(token) {
    return this.matches(token, this.peek());
  }
  testAhead(token) {
    return this.matches(token, this.peekAhead());
  }
  eat(token) {
    if (this.test(token)) {
      this.next();
      return true;
    }
    return false;
  }
  expect(token) {
    if (this.test(token)) {
      return this.next();
    }
    return this.unexpected();
  }
  skipSpace() {
    loop:
    // eslint-disable-line no-labels
    while (this.position < this.source.length) {
      const c = this.source[this.position];
      switch (c) {
        case ' ':
        case '\t':
          this.position += 1;
          break;
        case '/':
          switch (this.source[this.position + 1]) {
            case '/':
              this.skipLineComment();
              break;
            case '*':
              this.skipBlockComment();
              break;
            default:
              break loop;
            // eslint-disable-line no-labels
          }
          break;
        default:
          if (isWhitespace(c)) {
            this.position += 1;
          } else if (isLineTerminator(c)) {
            this.position += 1;
            if (c === '\r' && this.source[this.position] === '\n') {
              this.position += 1;
            }
            this.line += 1;
            this.columnOffset = this.position;
            this.lineTerminatorBeforeNextToken = true;
            break;
          } else {
            break loop; // eslint-disable-line no-labels
          }
          break;
      }
    }
  }
  skipHashbangComment() {
    if (this.position === 0 && this.source[0] === '#' && this.source[1] === '!') {
      this.skipLineComment();
    }
  }
  skipLineComment() {
    while (this.position < this.source.length) {
      const c = this.source[this.position];
      this.position += 1;
      if (isLineTerminator(c)) {
        if (c === '\r' && this.source[this.position] === '\n') {
          this.position += 1;
        }
        this.line += 1;
        this.columnOffset = this.position;
        this.lineTerminatorBeforeNextToken = true;
        break;
      }
    }
  }
  skipBlockComment() {
    const end = this.source.indexOf('*/', this.position + 2);
    if (end === -1) {
      this.raise('UnterminatedComment', this.position);
    }
    this.position += 2;
    for (const match of this.source.slice(this.position, end).matchAll(/\r\n?|[\n\u2028\u2029]/ug)) {
      this.position = match.index;
      this.line += 1;
      this.columnOffset = this.position;
      this.lineTerminatorBeforeNextToken = true;
    }
    this.position = end + 2;
  }
  nextToken() {
    this.skipSpace();

    // set token location info after skipping space
    this.positionForNextToken = this.position;
    this.lineForNextToken = this.line;
    this.columnForNextToken = this.position - this.columnOffset + 1;
    if (this.position >= this.source.length) {
      return Token.EOS;
    }
    const c = this.source[this.position];
    this.position += 1;
    const c1 = this.source[this.position];
    if (c.charCodeAt(0) <= 127) {
      const single = SingleCharTokens[c];
      switch (single) {
        case Token.LPAREN:
        case Token.RPAREN:
        case Token.LBRACE:
        case Token.RBRACE:
        case Token.LBRACK:
        case Token.RBRACK:
        case Token.COLON:
        case Token.SEMICOLON:
        case Token.COMMA:
        case Token.BIT_NOT:
        case Token.TEMPLATE:
          return single;
        case Token.CONDITIONAL:
          // ? ?. ?? ??=
          if (c1 === '.' && !isDecimalDigit$1(this.source[this.position + 1])) {
            this.position += 1;
            return Token.OPTIONAL;
          }
          if (c1 === '?') {
            this.position += 1;
            if (this.source[this.position] === '=') {
              this.position += 1;
              return Token.ASSIGN_NULLISH;
            }
            return Token.NULLISH;
          }
          return Token.CONDITIONAL;
        case Token.LT:
          // < <= << <<=
          if (c1 === '=') {
            this.position += 1;
            return Token.LTE;
          }
          if (c1 === '<') {
            this.position += 1;
            if (this.source[this.position] === '=') {
              this.position += 1;
              return Token.ASSIGN_SHL;
            }
            return Token.SHL;
          }
          return Token.LT;
        case Token.GT:
          // > >= >> >>= >>> >>>=
          if (c1 === '=') {
            this.position += 1;
            return Token.GTE;
          }
          if (c1 === '>') {
            this.position += 1;
            if (this.source[this.position] === '>') {
              this.position += 1;
              if (this.source[this.position] === '=') {
                this.position += 1;
                return Token.ASSIGN_SHR;
              }
              return Token.SHR;
            }
            if (this.source[this.position] === '=') {
              this.position += 1;
              return Token.ASSIGN_SAR;
            }
            return Token.SAR;
          }
          return Token.GT;
        case Token.ASSIGN:
          // = == === =>
          if (c1 === '=') {
            this.position += 1;
            if (this.source[this.position] === '=') {
              this.position += 1;
              return Token.EQ_STRICT;
            }
            return Token.EQ;
          }
          if (c1 === '>') {
            this.position += 1;
            return Token.ARROW;
          }
          return Token.ASSIGN;
        case Token.NOT:
          // ! != !==
          if (c1 === '=') {
            this.position += 1;
            if (this.source[this.position] === '=') {
              this.position += 1;
              return Token.NE_STRICT;
            }
            return Token.NE;
          }
          return Token.NOT;
        case Token.ADD:
          // + ++ +=
          if (c1 === '+') {
            this.position += 1;
            return Token.INC;
          }
          if (c1 === '=') {
            this.position += 1;
            return Token.ASSIGN_ADD;
          }
          return Token.ADD;
        case Token.SUB:
          // - -- -=
          if (c1 === '-') {
            this.position += 1;
            return Token.DEC;
          }
          if (c1 === '=') {
            this.position += 1;
            return Token.ASSIGN_SUB;
          }
          return Token.SUB;
        case Token.MUL:
          // * *= ** **=
          if (c1 === '=') {
            this.position += 1;
            return Token.ASSIGN_MUL;
          }
          if (c1 === '*') {
            this.position += 1;
            if (this.source[this.position] === '=') {
              this.position += 1;
              return Token.ASSIGN_EXP;
            }
            return Token.EXP;
          }
          return Token.MUL;
        case Token.MOD:
          // % %=
          if (c1 === '=') {
            this.position += 1;
            return Token.ASSIGN_MOD;
          }
          return Token.MOD;
        case Token.DIV:
          // / /=
          if (c1 === '=') {
            this.position += 1;
            return Token.ASSIGN_DIV;
          }
          return Token.DIV;
        case Token.BIT_AND:
          // & && &= &&=
          if (c1 === '&') {
            this.position += 1;
            if (this.source[this.position] === '=') {
              this.position += 1;
              return Token.ASSIGN_AND;
            }
            return Token.AND;
          }
          if (c1 === '=') {
            this.position += 1;
            return Token.ASSIGN_BIT_AND;
          }
          return Token.BIT_AND;
        case Token.BIT_OR:
          // | || |= ||=
          if (c1 === '|') {
            this.position += 1;
            if (this.source[this.position] === '=') {
              this.position += 1;
              return Token.ASSIGN_OR;
            }
            return Token.OR;
          }
          if (c1 === '=') {
            this.position += 1;
            return Token.ASSIGN_BIT_OR;
          }
          return Token.BIT_OR;
        case Token.BIT_XOR:
          // ^ ^=
          if (c1 === '=') {
            this.position += 1;
            return Token.ASSIGN_BIT_XOR;
          }
          return Token.BIT_XOR;
        case Token.PERIOD:
          // . ... NUMBER
          if (isDecimalDigit$1(c1)) {
            this.position -= 1;
            return this.scanNumber();
          }
          if (c1 === '.') {
            if (this.source[this.position + 1] === '.') {
              this.position += 2;
              return Token.ELLIPSIS;
            }
          }
          return Token.PERIOD;
        case Token.STRING:
          return this.scanString(c);
        case Token.NUMBER:
          this.position -= 1;
          return this.scanNumber();
        case Token.IDENTIFIER:
          this.position -= 1;
          return this.scanIdentifierOrKeyword();
        case Token.PRIVATE_IDENTIFIER:
          return this.scanIdentifierOrKeyword(true);
        default:
          this.unexpected(single);
      }
    }
    this.position -= 1;
    if (isLeadingSurrogate(c.charCodeAt(0)) || isIdentifierStart(c)) {
      return this.scanIdentifierOrKeyword();
    }
    return this.unexpected(this.position);
  }
  scanNumber() {
    const start = this.position;
    let base = 10;
    let check = isDecimalDigit$1;
    if (this.source[this.position] === '0') {
      this.scannedValue = 0;
      this.position += 1;
      switch (this.source[this.position]) {
        case 'x':
        case 'X':
          base = 16;
          break;
        case 'o':
        case 'O':
          base = 8;
          break;
        case 'b':
        case 'B':
          base = 2;
          break;
        case '.':
        case 'e':
        case 'E':
          break;
        case 'n':
          this.position += 1;
          this.scannedValue = 0n;
          return Token.BIGINT;
        default:
          return Token.NUMBER;
      }
      check = {
        16: isHexDigit,
        10: isDecimalDigit$1,
        8: isOctalDigit,
        2: isBinaryDigit
      }[base];
      if (base !== 10) {
        if (!check(this.source[this.position + 1])) {
          return Token.NUMBER;
        }
        this.position += 1;
      }
    }
    while (this.position < this.source.length) {
      const c = this.source[this.position];
      if (check(c)) {
        this.position += 1;
      } else if (c === '_') {
        if (!check(this.source[this.position + 1])) {
          this.unexpected(this.position + 1);
        }
        this.position += 1;
      } else {
        break;
      }
    }
    if (this.source[this.position] === 'n') {
      const buffer = this.source.slice(start, this.position).replace(/_/g, '');
      this.position += 1;
      this.scannedValue = BigInt(buffer);
      return Token.BIGINT;
    }
    if (base === 10 && this.source[this.position] === '.') {
      this.position += 1;
      if (this.source[this.position] === '_') {
        this.unexpected(this.position);
      }
      while (this.position < this.source.length) {
        const c = this.source[this.position];
        if (isDecimalDigit$1(c)) {
          this.position += 1;
        } else if (c === '_') {
          if (!isDecimalDigit$1(this.source[this.position + 1])) {
            this.unexpected(this.position + 1);
          }
          this.position += 1;
        } else {
          break;
        }
      }
    }
    if (base === 10 && (this.source[this.position] === 'E' || this.source[this.position] === 'e')) {
      this.position += 1;
      if (this.source[this.position] === '_') {
        this.unexpected(this.position);
      }
      if (this.source[this.position] === '-' || this.source[this.position] === '+') {
        this.position += 1;
      }
      if (this.source[this.position] === '_') {
        this.unexpected(this.position);
      }
      while (this.position < this.source.length) {
        const c = this.source[this.position];
        if (isDecimalDigit$1(c)) {
          this.position += 1;
        } else if (c === '_') {
          if (!isDecimalDigit$1(this.source[this.position + 1])) {
            this.unexpected(this.position + 1);
          }
          this.position += 1;
        } else {
          break;
        }
      }
    }
    if (isIdentifierStart(this.source[this.position])) {
      this.unexpected(this.position);
    }
    const buffer = this.source.slice(base === 10 ? start : start + 2, this.position).replace(/_/g, '');
    this.scannedValue = base === 10 ? Number.parseFloat(buffer) : Number.parseInt(buffer, base);
    return Token.NUMBER;
  }
  scanString(char) {
    let buffer = '';
    while (true) {
      if (this.position >= this.source.length) {
        this.raise('UnterminatedString', this.position);
      }
      const c = this.source[this.position];
      if (c === char) {
        this.position += 1;
        break;
      }
      if (c === '\r' || c === '\n') {
        this.raise('UnterminatedString', this.position);
      }
      this.position += 1;
      if (c === '\\') {
        const l = this.source[this.position];
        if (isLineTerminator(l)) {
          this.position += 1;
          if (l === '\r' && this.source[this.position] === '\n') {
            this.position += 1;
          }
          this.line += 1;
          this.columnOffset = this.position;
        } else {
          buffer += this.scanEscapeSequence();
        }
      } else {
        buffer += c;
      }
    }
    this.scannedValue = buffer;
    return Token.STRING;
  }
  scanEscapeSequence() {
    const c = this.source[this.position];
    switch (c) {
      case 'b':
        this.position += 1;
        return '\b';
      case 't':
        this.position += 1;
        return '\t';
      case 'n':
        this.position += 1;
        return '\n';
      case 'v':
        this.position += 1;
        return '\v';
      case 'f':
        this.position += 1;
        return '\f';
      case 'r':
        this.position += 1;
        return '\r';
      case 'x':
        this.position += 1;
        return String.fromCodePoint(this.scanHex(2));
      case 'u':
        this.position += 1;
        return String.fromCodePoint(this.scanCodePoint());
      default:
        if (c === '0' && !isDecimalDigit$1(this.source[this.position + 1])) {
          this.position += 1;
          return '\u{0000}';
        } else if (this.isStrictMode() && isDecimalDigit$1(c)) {
          this.raise('IllegalOctalEscape', this.position);
        }
        this.position += 1;
        return c;
    }
  }
  scanCodePoint() {
    if (this.source[this.position] === '{') {
      const end = this.source.indexOf('}', this.position);
      this.position += 1;
      const code = this.scanHex(end - this.position);
      this.position += 1;
      if (code > 0x10FFFF) {
        this.raise('InvalidCodePoint', this.position);
      }
      return code;
    }
    return this.scanHex(4);
  }
  scanHex(length) {
    if (length === 0) {
      this.raise('InvalidCodePoint', this.position);
    }
    let n = 0;
    for (let i = 0; i < length; i += 1) {
      const c = this.source[this.position];
      if (isHexDigit(c)) {
        this.position += 1;
        n = n << 4 | Number.parseInt(c, 16);
      } else {
        this.unexpected(this.position);
      }
    }
    return n;
  }
  scanIdentifierOrKeyword(isPrivate = false) {
    let buffer = '';
    let escapeIndex = -1;
    let check = isIdentifierStart;
    while (this.position < this.source.length) {
      const c = this.source[this.position];
      const code = c.charCodeAt(0);
      if (c === '\\') {
        if (escapeIndex === -1) {
          escapeIndex = this.position;
        }
        this.position += 1;
        if (this.source[this.position] !== 'u') {
          this.raise('InvalidUnicodeEscape', this.position);
        }
        this.position += 1;
        const raw = String.fromCodePoint(this.scanCodePoint());
        if (!check(raw)) {
          this.raise('InvalidUnicodeEscape', this.position);
        }
        buffer += raw;
      } else if (isLeadingSurrogate(code)) {
        const lowSurrogate = this.source.charCodeAt(this.position + 1);
        if (!isTrailingSurrogate(lowSurrogate)) {
          this.raise('InvalidUnicodeEscape', this.position);
        }
        const codePoint = UTF16SurrogatePairToCodePoint(code, lowSurrogate);
        const raw = String.fromCodePoint(codePoint);
        if (!check(raw)) {
          this.raise('InvalidUnicodeEscape', this.position);
        }
        this.position += 2;
        buffer += raw;
      } else if (check(c)) {
        buffer += c;
        this.position += 1;
      } else {
        break;
      }
      check = isIdentifierPart;
    }
    if (!isPrivate && isKeywordRaw(buffer)) {
      if (escapeIndex !== -1) {
        this.scannedValue = buffer;
        return Token.ESCAPED_KEYWORD;
      }
      return KeywordLookup[buffer];
    } else {
      this.scannedValue = buffer;
      this.escapeIndex = escapeIndex;
      return isPrivate ? Token.PRIVATE_IDENTIFIER : Token.IDENTIFIER;
    }
  }
  scanRegularExpressionBody() {
    let inClass = false;
    let buffer = this.peek().type === Token.ASSIGN_DIV ? '=' : '';
    while (true) {
      if (this.position >= this.source.length) {
        this.raise('UnterminatedRegExp', this.position);
      }
      const c = this.source[this.position];
      switch (c) {
        case '[':
          inClass = true;
          this.position += 1;
          buffer += c;
          break;
        case ']':
          if (inClass) {
            inClass = false;
          }
          buffer += c;
          this.position += 1;
          break;
        case '/':
          this.position += 1;
          if (!inClass) {
            this.scannedValue = buffer;
            return;
          }
          buffer += c;
          break;
        case '\\':
          buffer += c;
          this.position += 1;
          if (isLineTerminator(this.source[this.position])) {
            this.raise('UnterminatedRegExp', this.position);
          }
          buffer += this.source[this.position];
          this.position += 1;
          break;
        default:
          if (isLineTerminator(c)) {
            this.raise('UnterminatedRegExp', this.position);
          }
          this.position += 1;
          buffer += c;
          break;
      }
    }
  }
  scanRegularExpressionFlags() {
    let buffer = '';
    while (true) {
      if (this.position >= this.source.length) {
        this.scannedValue = buffer;
        return;
      }
      const c = this.source[this.position];
      if (isRegularExpressionFlagPart(c) && 'dgimsuyv'.includes(c) && !buffer.includes(c)) {
        this.position += 1;
        buffer += c;
      } else {
        this.scannedValue = buffer;
        return;
      }
    }
  }
}

function TV(s) {
  let buffer = '';
  for (let i = 0; i < s.length; i += 1) {
    if (s[i] === '\\') {
      i += 1;
      switch (s[i]) {
        case '$':
          buffer += '$';
          break;
        case '\\':
          buffer += '\\';
          break;
        case '`':
          buffer += '`';
          break;
        case '\'':
          buffer += '\'';
          break;
        case '"':
          buffer += '"';
          break;
        case 'b':
          buffer += '\b';
          break;
        case 'f':
          buffer += '\f';
          break;
        case 'n':
          buffer += '\n';
          break;
        case 'r':
          buffer += '\r';
          break;
        case 't':
          buffer += '\t';
          break;
        case 'v':
          buffer += '\v';
          break;
        case 'x':
          i += 1;
          if (isHexDigit(s[i]) && isHexDigit(s[i + 1])) {
            const n = Number.parseInt(s.slice(i, i + 2), 16);
            i += 1;
            buffer += String.fromCharCode(n);
          } else {
            return undefined;
          }
          break;
        case 'u':
          i += 1;
          if (s[i] === '{') {
            i += 1;
            const start = i;
            do {
              i += 1;
            } while (isHexDigit(s[i]));
            if (s[i] !== '}') {
              return undefined;
            }
            const n = Number.parseInt(s.slice(start, i), 16);
            if (n > 0x10FFFF) {
              return undefined;
            }
            buffer += String.fromCodePoint(n);
          } else if (isHexDigit(s[i]) && isHexDigit(s[i + 1]) && isHexDigit(s[i + 2]) && isHexDigit(s[i + 3])) {
            const n = Number.parseInt(s.slice(i, i + 4), 16);
            i += 3;
            buffer += String.fromCodePoint(n);
          } else {
            return undefined;
          }
          break;
        case '0':
          if (isDecimalDigit$1(s[i + 1])) {
            return undefined;
          }
          return '\u{0000}';
        default:
          if (isLineTerminator(s)) {
            return '';
          }
          return undefined;
      }
    } else {
      buffer += s[i];
    }
  }
  return buffer;
}
function TemplateStrings(node, raw) {
  if (raw) {
    return node.TemplateSpanList.map(s => Value(s));
  }
  return node.TemplateSpanList.map(v => {
    const tv = TV(v);
    if (tv === undefined) {
      return Value.undefined;
    }
    return Value(tv);
  });
}

function ImportEntriesForModule(node, module) {
  switch (node.type) {
    case 'ImportClause':
      switch (true) {
        case !!node.ImportedDefaultBinding && !!node.NameSpaceImport:
          {
            // 1. Let entries be ImportEntriesForModule of ImportedDefaultBinding with argument module.
            const entries = ImportEntriesForModule(node.ImportedDefaultBinding, module);
            // 2. Append to entries the elements of the ImportEntriesForModule of NameSpaceImport with argument module.
            entries.push(...ImportEntriesForModule(node.NameSpaceImport, module));
            // 3. Return entries.
            return entries;
          }
        case !!node.ImportedDefaultBinding && !!node.NamedImports:
          {
            // 1. Let entries be ImportEntriesForModule of ImportedDefaultBinding with argument module.
            const entries = ImportEntriesForModule(node.ImportedDefaultBinding, module);
            // 2. Append to entries the elements of the ImportEntriesForModule of NamedImports with argument module.
            entries.push(...ImportEntriesForModule(node.NamedImports, module));
            // 3. Return entries.
            return entries;
          }
        case !!node.ImportedDefaultBinding:
          return ImportEntriesForModule(node.ImportedDefaultBinding, module);
        case !!node.NameSpaceImport:
          return ImportEntriesForModule(node.NameSpaceImport, module);
        case !!node.NamedImports:
          return ImportEntriesForModule(node.NamedImports, module);
        /* node:coverage ignore next */default:
          /* node:coverage ignore next */
          throw new OutOfRange$1('ImportEntriesForModule', node);
      }
    case 'ImportedDefaultBinding':
      {
        // 1. Let localName be the sole element of BoundNames of ImportedBinding.
        const localName = BoundNames(node.ImportedBinding)[0];
        // 2. Let defaultEntry be the ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: "default", [[LocalName]]: localName }.
        const defaultEntry = {
          ModuleRequest: module,
          ImportName: Value('default'),
          LocalName: localName
        };
        // 3. Return a new List containing defaultEntry.
        return [defaultEntry];
      }
    case 'NameSpaceImport':
      {
        // 1. Let localName be the StringValue of ImportedBinding.
        const localName = StringValue(node.ImportedBinding);
        // 2. Let entry be the ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: ~namespace-object~, [[LocalName]]: localName }.
        const entry = {
          ModuleRequest: module,
          ImportName: 'namespace-object',
          LocalName: localName
        };
        // 3. Return a new List containing entry.
        return [entry];
      }
    case 'NamedImports':
      {
        const specs = [];
        node.ImportsList.forEach(n => {
          specs.push(...ImportEntriesForModule(n, module));
        });
        return specs;
      }
    case 'ImportSpecifier':
      if (node.ModuleExportName) {
        // 1. Let importName be the StringValue of ModuleExportName.
        const importName = StringValue(node.ModuleExportName);
        // 2. Let localName be the StringValue of ImportedBinding.
        const localName = StringValue(node.ImportedBinding);
        // 3. Let entry be the ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName }.
        const entry = {
          ModuleRequest: module,
          ImportName: importName,
          LocalName: localName
        };
        // 4. Return a new List containing entry.
        return [entry];
      } else {
        // 1. Let localName be the sole element of BoundNames of ImportedBinding.
        const localName = BoundNames(node.ImportedBinding)[0];
        // 2. Let entry be the ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: localName, [[LocalName]]: localName }.
        const entry = {
          ModuleRequest: module,
          ImportName: localName,
          LocalName: localName
        };
        // 3. Return a new List containing entry.
        return [entry];
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('ImportEntriesForModule', node);
  }
}

function ExportEntriesForModule(node, module) {
  if (isArray(node)) {
    const specs = [];
    node.forEach(n => {
      specs.push(...ExportEntriesForModule(n, module));
    });
    return specs;
  }
  switch (node.type) {
    case 'ExportFromClause':
      if (node.ModuleExportName) {
        // 1. Let exportName be the StringValue of ModuleExportName.
        const exportName = StringValue(node.ModuleExportName);
        // 2. Let entry be the ExportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: ~all~, [[LocalName]]: null, [[ExportName]]: exportName }.
        const entry = {
          ModuleRequest: module,
          ImportName: 'all',
          LocalName: Value.null,
          ExportName: exportName
        };
        // 3. Return a new List containing entry.
        return [entry];
      } else {
        // 1. Let entry be the ExportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: ~all-but-default~, [[LocalName]]: null, [[ExportName]]: null }.
        const entry = {
          ModuleRequest: module,
          ImportName: 'all-but-default',
          LocalName: Value.null,
          ExportName: Value.null
        };
        // 2. Return a new List containing entry.
        return [entry];
      }
    case 'ExportSpecifier':
      {
        const sourceName = StringValue(node.localName);
        const exportName = StringValue(node.exportName);
        let localName;
        let importName;
        if (module === Value.null) {
          localName = sourceName;
          importName = Value.null;
        } else {
          // 4. Else,
          localName = Value.null;
          importName = sourceName;
        }
        return [{
          ModuleRequest: module,
          ImportName: importName,
          LocalName: localName,
          ExportName: exportName
        }];
      }
    case 'NamedExports':
      return ExportEntriesForModule(node.ExportsList, module);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('ExportEntriesForModule', node);
  }
}

/** https://tc39.es/ecma262/#sec-patterns-static-semantics-character-value */
function CharacterValue(node) {
  switch (node.type) {
    case 'CharacterEscape':
      switch (node.production) {
        case 'ControlEscape':
          switch (node.ControlEscape) {
            case 't':
              return 0x0009;
            case 'n':
              return 0x000A;
            case 'v':
              return 0x000B;
            case 'f':
              return 0x000C;
            case 'r':
              return 0x000D;
            default:
              unreachable(node.ControlEscape);
          }
        case 'AsciiLetter':
          {
            // 1. Let ch be the code point matched by ControlLetter.
            const ch = node.AsciiLetter;
            // 2. Let i be ch's code point value.
            const i = ch.codePointAt(0);
            // 3. Return the remainder of dividing i by 32.
            return i % 32;
          }
        case 'HexEscapeSequence':
          // 1. Return the numeric value of the code unit that is the SV of HexEscapeSequence.
          return Number.parseInt(`${node.HexEscapeSequence.HexDigit_a}${node.HexEscapeSequence.HexDigit_b}`, 16);
        case 'RegExpUnicodeEscapeSequence':
          return CharacterValue(node.RegExpUnicodeEscapeSequence);
        case '0':
          // 1. Return the code point value of U+0000 (NULL).
          return 0x0000;
        case 'IdentityEscape':
          {
            // 1. Let ch be the code point matched by IdentityEscape.
            const ch = node.IdentityEscape.codePointAt(0);
            // 2. Return the code point value of ch.
            return ch;
          }
        default:
          unreachable();
      }
    case 'RegExpUnicodeEscapeSequence':
      switch (true) {
        case 'Hex4Digits' in node:
          return node.Hex4Digits;
        case 'CodePoint' in node:
          return node.CodePoint;
        case 'HexTrailSurrogate' in node:
          return UTF16SurrogatePairToCodePoint(node.HexLeadSurrogate, node.HexTrailSurrogate);
        case 'HexLeadSurrogate' in node:
          return node.HexLeadSurrogate;
        /* node:coverage ignore next */default:
          /* node:coverage ignore next */
          throw new OutOfRange$1('CharacterValue', node);
      }
    case 'ClassAtom':
      switch (node.production) {
        case '-':
          // 1. Return the code point value of U+002D (HYPHEN-MINUS).
          return 0x002D;
        case 'SourceCharacter':
          {
            // 1. Let ch be the code point matched by SourceCharacter.
            const ch = node.SourceCharacter.codePointAt(0);
            // 2. Return ch.
            return ch;
          }
        case 'ClassEscape':
          return CharacterValue(node.ClassEscape);
        default:
          unreachable();
      }
    case 'ClassEscape':
      switch (node.production) {
        case 'b':
          // 1. Return the code point value of U+0008 (BACKSPACE).
          return 0x0008;
        case '-':
          // 1. Return the code point value of U+002D (HYPHEN-MINUS).
          return 0x002D;
        case 'CharacterEscape':
          return CharacterValue(node.CharacterEscape);
        /* node:coverage ignore next */case 'CharacterClassEscape':
          /* node:coverage ignore next */
          throw new OutOfRange$1('CharacterValue', node);
        default:
          unreachable();
      }
    case 'ClassSetCharacter':
      {
        if (node.production === 'CharacterEscape') {
          return CharacterValue(node.CharacterEscape);
        } else {
          return Unicode.toCodePoint(node.UnicodeCharacter);
        }
      }
    default:
      unreachable();
  }
}
CharacterValue.section = 'https://tc39.es/ecma262/#sec-patterns-static-semantics-character-value';

/** https://tc39.es/ecma262/#sec-utf16decodesurrogatepair */
function UTF16SurrogatePairToCodePoint(lead, trail) {
  // 1. Assert: lead is a leading surrogate and trail is a trailing surrogate.
  Assert(isLeadingSurrogate(lead) && isTrailingSurrogate(trail), "isLeadingSurrogate(lead) && isTrailingSurrogate(trail)");
  // 2. Let cp be (lead - 0xD800) × 0x400 + (trail - 0xDC00) + 0x10000.
  const cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
  // 3. Return the code point cp.
  return cp;
}
UTF16SurrogatePairToCodePoint.section = 'https://tc39.es/ecma262/#sec-utf16decodesurrogatepair';

/** https://tc39.es/ecma262/#sec-codepointat */
function CodePointAt(string, position) {
  // 1 .Let size be the length of string.
  const size = string.length;
  // 2. Assert: position ≥ 0 and position < size.
  Assert(position >= 0 && position < size, "position >= 0 && position < size");
  // 3. Let first be the code unit at index position within string.
  const first = string.charCodeAt(position);
  // 4. Let cp be the code point whose numeric value is that of first.
  let cp = first;
  // 5. If first is not a leading surrogate or trailing surrogate, then
  if (!isLeadingSurrogate(first) && !isTrailingSurrogate(first)) {
    // a. Return the Record { [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: false }.
    return {
      CodePoint: cp,
      CodeUnitCount: 1,
      IsUnpairedSurrogate: false
    };
  }
  // 6. If first is a trailing surrogate or position + 1 = size, then
  if (isTrailingSurrogate(first) || position + 1 === size) {
    // a. Return the Record { [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: true }.
    return {
      CodePoint: cp,
      CodeUnitCount: 1,
      IsUnpairedSurrogate: true
    };
  }
  // 7. Let second be the code unit at index position + 1 within string.
  const second = string.charCodeAt(position + 1);
  // 8. If seconds is not a trailing surrogate, then
  if (!isTrailingSurrogate(second)) {
    // a. Return the Record { [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: true }.
    return {
      CodePoint: cp,
      CodeUnitCount: 1,
      IsUnpairedSurrogate: true
    };
  }
  // 9. Set cp to ! UTF16SurrogatePairToCodePoint(first, second).
  /* X */
  let _temp = UTF16SurrogatePairToCodePoint(first, second);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! UTF16SurrogatePairToCodePoint(first, second) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  cp = _temp;
  // 10. Return the Record { [[CodePoint]]: cp, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: false }.
  return {
    CodePoint: cp,
    CodeUnitCount: 2,
    IsUnpairedSurrogate: false
  };
}
CodePointAt.section = 'https://tc39.es/ecma262/#sec-codepointat';

/** https://tc39.es/ecma262/#sec-stringtocodepoints */
function StringToCodePoints(string) {
  // 1. Let codePoints be a new empty List.
  const codePoints = [];
  // 2. Let size be the length of string.
  const size = string.length;
  // 3. Let position be 0.
  let position = 0;
  // 4. Repeat, while position < size,
  while (position < size) {
    // a. Let cp be ! CodePointAt(string, position).
    const cp = CodePointAt(string, position);
    // b. Append cp.[[CodePoint]] to codePoints.
    codePoints.push(cp.CodePoint);
    // c. Set position to position + cp.[[CodeUnitCount]].
    position += cp.CodeUnitCount;
  }
  // 5. Return codePoints.
  return codePoints;
}
StringToCodePoints.section = 'https://tc39.es/ecma262/#sec-stringtocodepoints';

/** https://tc39.es/ecma262/#sec-codepointstostring */
function CodePointsToString(text) {
  // 1. Let result be the empty String.
  let result = '';
  // 2. For each code point cp in text, do
  for (const cp of text) {
    // a. Set result to the string-concatenation of result and UTF16EncodeCodePoint(cp).
    result += UTF16EncodeCodePoint(cp.codePointAt(0));
  }
  // 3. Return result.
  return result;
}
CodePointsToString.section = 'https://tc39.es/ecma262/#sec-codepointstostring';

function IsStringWellFormedUnicode(string_) {
  const string = string_.stringValue();
  // 1. Let _strLen_ be the number of code units in string.
  const strLen = string.length;
  // 2. Let k be 0.
  let k = 0;
  // 3. Repeat, while k ≠ strLen,
  while (k !== strLen) {
    /* X */
    let _temp = CodePointAt(string, k);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! CodePointAt(string, k) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // a. Let cp be ! CodePointAt(string, k).
    const cp = _temp;
    // b. If cp.[[IsUnpairedSurrogate]] is true, return false.
    if (cp.IsUnpairedSurrogate) {
      return false;
    }
    // c. Set k to k + cp.[[CodeUnitCount]].
    k += cp.CodeUnitCount;
  }
  // 4. Return true.
  return true;
}

function IsComputedPropertyKey(node) {
  return node.type !== 'IdentifierName' && node.type !== 'StringLiteral' && node.type !== 'NumericLiteral';
}

/** https://tc39.es/ecma262/#sec-static-semantics-privateboundidentifiers */
function PrivateBoundIdentifiers(node) {
  if (isArray(node)) {
    return node.flatMap(n => PrivateBoundIdentifiers(n));
  }
  switch (node.type) {
    case 'PrivateIdentifier':
      return [StringValue(node)];
    case 'MethodDefinition':
    case 'GeneratorMethod':
    case 'AsyncMethod':
    case 'AsyncGeneratorMethod':
    case 'FieldDefinition':
      return PrivateBoundIdentifiers(node.ClassElementName);
    default:
      return [];
  }
}
PrivateBoundIdentifiers.section = 'https://tc39.es/ecma262/#sec-static-semantics-privateboundidentifiers';

/** https://tc39.es/ecma262/#sec-static-semantics-containsarguments */
function ContainsArguments(node) {
  switch (node.type) {
    case 'IdentifierReference':
      if (node.name === 'arguments') {
        return node;
      }
      return null;
    case 'FunctionDeclaration':
    case 'FunctionExpression':
    case 'MethodDefinition':
    case 'GeneratorMethod':
    case 'GeneratorDeclaration':
    case 'GeneratorExpression':
    case 'AsyncMethod':
    case 'AsyncFunctionDeclaration':
    case 'AsyncFunctionExpression':
      return null;
    default:
      for (const value of Object.values(node)) {
        // TODO(ts): This function does not accept a ParseNode[], when isArray(value), ContainsArguments should never return a result?
        if (value?.type || Array.isArray(value)) {
          const maybe = ContainsArguments(value);
          if (maybe) {
            return maybe;
          }
        }
      }
      return null;
  }
}
ContainsArguments.section = 'https://tc39.es/ecma262/#sec-static-semantics-containsarguments';

/** https://tc39.es/ecma262/#sec-utf16encodecodepoint */
function UTF16EncodeCodePoint(cp) {
  // 1. Assert: 0 ≤ cp ≤ 0x10FFFF.
  Assert(cp >= 0 && cp <= 0x10FFFF, "cp >= 0 && cp <= 0x10FFFF");
  // 2. If cp ≤ 0xFFFF, return the String value consisting of the code unit whose value is cp.
  if (cp <= 0xFFFF) {
    return String.fromCodePoint(cp);
  }
  // 3. Let cu1 be the code unit whose value is floor((cp - 0x10000) / 0x400) + 0xD800.
  const cu1 = Math.floor((cp - 0x10000) / 0x400) + 0xD800;
  // 4. Let cu2 be the code unit whose value is ((cp - 0x10000) modulo 0x400) + 0xDC00.
  const cu2 = (cp - 0x10000) % 0x400 + 0xDC00;
  // 5. Return the string-concatenation of cu1 and cu2.
  return String.fromCodePoint(cu1, cu2);
}
UTF16EncodeCodePoint.section = 'https://tc39.es/ecma262/#sec-utf16encodecodepoint';

/** https://tc39.es/ecma262/#sec-identifiers-runtime-semantics-evaluation */
// IdentifierReference :
//   Identifier
//   `yield`
//   `await`
function* Evaluate_IdentifierReference(IdentifierReference) {
  // 1. Return ? ResolveBinding(StringValue of Identifier).
  return yield* ResolveBinding(StringValue(IdentifierReference), undefined, IdentifierReference.strict);
}
Evaluate_IdentifierReference.section = 'https://tc39.es/ecma262/#sec-identifiers-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-this-keyword-runtime-semantics-evaluation */
// PrimaryExpression : `this`
function Evaluate_This(_PrimaryExpression) {
  return ResolveThisBinding();
}
Evaluate_This.section = 'https://tc39.es/ecma262/#sec-this-keyword-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-literals-runtime-semantics-evaluation */
// Literal :
//   NullLiteral
//   BooleanLiteral
//   NumericLiteral
//   StringLiteral
function Evaluate_Literal(Literal) {
  switch (Literal.type) {
    case 'NullLiteral':
      // 1. Return null.
      return NormalCompletion(Value.null);
    case 'BooleanLiteral':
      // 1. If BooleanLiteral is the token false, return false.
      if (Literal.value === false) {
        return NormalCompletion(Value.false);
      }
      // 2. If BooleanLiteral is the token true, return true.
      if (Literal.value === true) {
        return NormalCompletion(Value.true);
      }
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_Literal', Literal);
    case 'NumericLiteral':
      // 1. Return the NumericValue of NumericLiteral as defined in 11.8.3.
      return NormalCompletion(NumericValue(Literal));
    case 'StringLiteral':
      return NormalCompletion(StringValue(Literal));
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_Literal', Literal);
  }
}
Evaluate_Literal.section = 'https://tc39.es/ecma262/#sec-literals-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-class-definitions-runtime-semantics-evaluation */
// ClassExpression :
//   `class` ClassTail
//   `class` BindingIdentifier ClassTail
function* Evaluate_ClassExpression(ClassExpression) {
  const {
    BindingIdentifier,
    ClassTail
  } = ClassExpression;
  if (!BindingIdentifier) {
    /* ReturnIfAbrupt */
    let _temp = yield* ClassDefinitionEvaluation(ClassTail, Value.undefined, Value(''));
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // 1. Let value be ? ClassDefinitionEvaluation of ClassTail with arguments undefined and ''
    const value = _temp;
    // 2. Set value.[[SourceText]] to the source text matched by ClassExpression.
    value.SourceText = sourceTextMatchedBy(ClassExpression);
    // 3. Return value.
    return value;
  }
  // 1. Let className be StringValue of BindingIdentifier.
  const className = StringValue(BindingIdentifier);
  // 2. Let value be ? ClassDefinitionEvaluation of ClassTail with arguments className and className.
  /* ReturnIfAbrupt */
  let _temp2 = yield* ClassDefinitionEvaluation(ClassTail, className, className);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const value = _temp2;
  // Set value.[[SourceText]] to the source text matched by ClassExpression.
  value.SourceText = sourceTextMatchedBy(ClassExpression);
  // Return value.
  return value;
}
Evaluate_ClassExpression.section = 'https://tc39.es/ecma262/#sec-class-definitions-runtime-semantics-evaluation';

function* Evaluate(node) {
  surroundingAgent.runningExecutionContext.callSite.setLocation(node);
  if (surroundingAgent.hostDefinedOptions.onNodeEvaluation) {
    surroundingAgent.hostDefinedOptions.onNodeEvaluation(node, surroundingAgent.currentRealmRecord);
  }
  if (surroundingAgent.hostDefinedOptions.onDebugger) {
    const resumption = yield {
      type: 'potential-debugger'
    };
    Assert(resumption.type === 'debugger-resume', "resumption.type === 'debugger-resume'");
  }
  switch (node.type) {
    // Language
    case 'Script':
      return yield* Evaluate_Script(node);
    case 'ScriptBody':
      return yield* Evaluate_ScriptBody(node);
    case 'Module':
      return yield* Evaluate_Module(node);
    case 'ModuleBody':
      return yield* Evaluate_ModuleBody(node);
    // Statements
    case 'Block':
      return yield* Evaluate_Block(node);
    case 'VariableStatement':
      return yield* Evaluate_VariableStatement(node);
    case 'EmptyStatement':
      return Evaluate_EmptyStatement();
    case 'IfStatement':
      return yield* Evaluate_IfStatement(node);
    case 'ExpressionStatement':
      return yield* Evaluate_ExpressionStatement(node);
    case 'WhileStatement':
    case 'DoWhileStatement':
    case 'SwitchStatement':
    case 'ForStatement':
    case 'ForInStatement':
    case 'ForOfStatement':
    case 'ForAwaitStatement':
      return yield* Evaluate_BreakableStatement(node);
    case 'ForBinding':
      return yield* Evaluate_ForBinding(node);
    case 'CaseClause':
    case 'DefaultClause':
      return yield* Evaluate_CaseClause(node);
    case 'BreakStatement':
      return Evaluate_BreakStatement(node);
    case 'ContinueStatement':
      return Evaluate_ContinueStatement(node);
    case 'LabelledStatement':
      return yield* Evaluate_LabelledStatement(node);
    case 'ReturnStatement':
      return yield* Evaluate_ReturnStatement(node);
    case 'ThrowStatement':
      return yield* Evaluate_ThrowStatement(node);
    case 'TryStatement':
      return yield* Evaluate_TryStatement(node);
    case 'DebuggerStatement':
      return yield* Evaluate_DebuggerStatement();
    case 'WithStatement':
      return yield* Evaluate_WithStatement(node);
    // Declarations
    case 'ImportDeclaration':
      return Evaluate_ImportDeclaration();
    case 'ExportDeclaration':
      return yield* Evaluate_ExportDeclaration(node);
    case 'ClassDeclaration':
      return yield* Evaluate_ClassDeclaration(node);
    case 'LexicalDeclaration':
      return yield* Evaluate_LexicalDeclaration(node);
    case 'FunctionDeclaration':
      return Evaluate_FunctionDeclaration();
    case 'GeneratorDeclaration':
    case 'AsyncFunctionDeclaration':
    case 'AsyncGeneratorDeclaration':
      return Evaluate_HoistableDeclaration();
    // Expressions
    case 'CommaOperator':
      return yield* Evaluate_CommaOperator(node);
    case 'ThisExpression':
      return Evaluate_This();
    case 'IdentifierReference':
      return yield* Evaluate_IdentifierReference(node);
    case 'NullLiteral':
    case 'BooleanLiteral':
    case 'NumericLiteral':
    case 'StringLiteral':
      return Evaluate_Literal(node);
    case 'ArrayLiteral':
      return yield* Evaluate_ArrayLiteral(node);
    case 'ObjectLiteral':
      return yield* Evaluate_ObjectLiteral(node);
    case 'FunctionExpression':
      return Evaluate_FunctionExpression(node);
    case 'ClassExpression':
      return yield* Evaluate_ClassExpression(node);
    case 'GeneratorExpression':
      return Evaluate_GeneratorExpression(node);
    case 'AsyncFunctionExpression':
      return Evaluate_AsyncFunctionExpression(node);
    case 'AsyncGeneratorExpression':
      return Evaluate_AsyncGeneratorExpression(node);
    case 'TemplateLiteral':
      return yield* Evaluate_TemplateLiteral(node);
    case 'ParenthesizedExpression':
      return yield* Evaluate_ParenthesizedExpression(node);
    case 'AdditiveExpression':
      return yield* Evaluate_AdditiveExpression(node);
    case 'MultiplicativeExpression':
      return yield* Evaluate_MultiplicativeExpression(node);
    case 'ExponentiationExpression':
      return yield* Evaluate_ExponentiationExpression(node);
    case 'UpdateExpression':
      return yield* Evaluate_UpdateExpression(node);
    case 'ShiftExpression':
      return yield* Evaluate_ShiftExpression(node);
    case 'LogicalORExpression':
      return yield* Evaluate_LogicalORExpression(node);
    case 'LogicalANDExpression':
      return yield* Evaluate_LogicalANDExpression(node);
    case 'BitwiseANDExpression':
    case 'BitwiseXORExpression':
    case 'BitwiseORExpression':
      return yield* Evaluate_BinaryBitwiseExpression(node);
    case 'RelationalExpression':
      return yield* Evaluate_RelationalExpression(node);
    case 'CoalesceExpression':
      return yield* Evaluate_CoalesceExpression(node);
    case 'EqualityExpression':
      return yield* Evaluate_EqualityExpression(node);
    case 'CallExpression':
      {
        surroundingAgent.runningExecutionContext.callSite.setCallLocation(node);
        const r = yield* Evaluate_CallExpression(node);
        const resumption = yield {
          type: 'potential-debugger'
        };
        Assert(resumption.type === 'debugger-resume', "resumption.type === 'debugger-resume'");
        surroundingAgent.runningExecutionContext.callSite.setCallLocation(null);
        return r;
      }
    case 'NewExpression':
      return yield* Evaluate_NewExpression(node);
    case 'MemberExpression':
      return yield* Evaluate_MemberExpression(node);
    case 'OptionalExpression':
      return yield* Evaluate_OptionalExpression(node);
    case 'TaggedTemplateExpression':
      return yield* Evaluate_TaggedTemplateExpression(node);
    case 'SuperProperty':
      return yield* Evaluate_SuperProperty(node);
    case 'SuperCall':
      return yield* Evaluate_SuperCall(node);
    case 'NewTarget':
      return Evaluate_NewTarget();
    case 'ImportMeta':
      return Evaluate_ImportMeta();
    case 'ImportCall':
      return yield* Evaluate_ImportCall(node);
    case 'AssignmentExpression':
      return yield* Evaluate_AssignmentExpression(node);
    case 'YieldExpression':
      return yield* Evaluate_YieldExpression(node);
    case 'AwaitExpression':
      return yield* Evaluate_AwaitExpression(node);
    case 'UnaryExpression':
      return yield* Evaluate_UnaryExpression(node);
    case 'ArrowFunction':
      return Evaluate_ArrowFunction(node);
    case 'AsyncArrowFunction':
      return Evaluate_AsyncArrowFunction(node);
    case 'ConditionalExpression':
      return yield* Evaluate_ConditionalExpression(node);
    case 'RegularExpressionLiteral':
      return yield* Evaluate_RegularExpressionLiteral(node);
    case 'AsyncBody':
    case 'GeneratorBody':
    case 'AsyncGeneratorBody':
      return yield* Evaluate_AnyFunctionBody(node);
    case 'ExpressionBody':
      return yield* Evaluate_ExpressionBody(node);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate', node);
  }
}

// https://tc39.es/ecma262/#loadedmodulerequest-record

// #resolvedbinding-record
class ResolvedBindingRecord {
  Module;
  BindingName;
  constructor({
    Module,
    BindingName
  }) {
    Assert(Module instanceof AbstractModuleRecord, "Module instanceof AbstractModuleRecord");
    Assert(BindingName === 'namespace' || BindingName instanceof JSStringValue, "BindingName === 'namespace' || BindingName instanceof JSStringValue");
    this.Module = Module;
    this.BindingName = BindingName;
  }
  mark(m) {
    m(this.Module);
  }
}
/** https://tc39.es/ecma262/#sec-abstract-module-records */
class AbstractModuleRecord {
  Realm;
  Environment;
  Namespace = Value.undefined;
  HostDefined;
  constructor(init) {
    this.Realm = init.Realm;
    this.Environment = init.Environment;
    this.Namespace = init.Namespace;
    this.HostDefined = init.HostDefined;
  }
  mark(m) {
    m(this.Realm);
    m(this.Environment);
    m(this.Namespace);
  }
}
/** https://tc39.es/ecma262/#sec-cyclic-module-records */
class CyclicModuleRecord extends AbstractModuleRecord {
  Status;
  EvaluationError;
  DFSIndex;
  DFSAncestorIndex;
  RequestedModules;
  LoadedModules;
  HasTLA;
  AsyncEvaluationOrder;
  AsyncParentModules;
  CycleRoot;
  TopLevelCapability;
  PendingAsyncDependencies;
  constructor(init) {
    super(init);
    this.Status = init.Status;
    this.EvaluationError = init.EvaluationError;
    this.DFSIndex = init.DFSIndex;
    this.DFSAncestorIndex = init.DFSAncestorIndex;
    this.RequestedModules = init.RequestedModules;
    this.LoadedModules = init.LoadedModules;
    this.CycleRoot = init.CycleRoot;
    this.HasTLA = init.HasTLA;
    this.AsyncEvaluationOrder = init.AsyncEvaluationOrder;
    this.TopLevelCapability = init.TopLevelCapability;
    this.AsyncParentModules = init.AsyncParentModules;
    this.PendingAsyncDependencies = init.PendingAsyncDependencies;
  }
  /** https://tc39.es/ecma262/#sec-LoadRequestedModules */
  LoadRequestedModules(hostDefined) {
    const module = this;

    // 2. Let pc be ! NewPromiseCapability(%Promise%).
    /* X */
    let _temp = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const pc = _temp;
    // 3. Let state be a new GraphLoadingState Record { [[IsLoading]]: true, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: pc, [[HostDefined]]: hostDefined }.
    const state = new GraphLoadingState({
      PromiseCapability: pc,
      HostDefined: hostDefined
    });
    // 4. Perform InnerModuleLoading(state, module).
    InnerModuleLoading(state, module);
    // 5. Return pc.[[Promise]].
    return pc.Promise;
  }

  /** https://tc39.es/ecma262/#sec-moduledeclarationlinking */
  Link() {
    const module = this;
    // 1. Assert: module.[[Status]] is unlinked, linked, evaluating-async, or evaluated.
    Assert(module.Status === 'unlinked' || module.Status === 'linked' || module.Status === 'evaluating-async' || module.Status === 'evaluated', "module.Status === 'unlinked' || module.Status === 'linked' || module.Status === 'evaluating-async' || module.Status === 'evaluated'");
    // 2. Let stack be a new empty List.
    const stack = [];
    // 3. Let result be Completion(InnerModuleLinking(module, stack, 0)).
    const result = InnerModuleLinking(module, stack, 0);
    // 5. If result is an abrupt completion, then
    if (result instanceof AbruptCompletion) {
      // a. For each Cyclic Module Record m of stack, do
      for (const m of stack) {
        // i. Assert: m.[[Status]] is linking.
        Assert(m.Status === 'linking', "m.Status === 'linking'");
        // ii. Set m.[[Status]] to unlinked.
        m.Status = 'unlinked';
      }
      // b. Assert: module.[[Status]] is unlinked.
      Assert(module.Status === 'unlinked', "module.Status === 'unlinked'");
      // c. Return result.
      return result;
    }
    // 6. Assert: module.[[Status]] is linked, evaluating-async, or evaluated.
    Assert(module.Status === 'linked' || module.Status === 'evaluating-async' || module.Status === 'evaluated', "module.Status === 'linked' || module.Status === 'evaluating-async' || module.Status === 'evaluated'");
    // 7. Assert: stack is empty.
    Assert(stack.length === 0, "stack.length === 0");
    // 8. Return unused.
    return NormalCompletion(undefined);
  }

  /** https://tc39.es/ecma262/#sec-moduleevaluation */
  *Evaluate() {
    // 1. Assert: This call to Evaluate is not happening at the same time as another call to Evaluate within the surrounding agent.
    // 2. Let module be this Cyclic Module Record.
    let module = this;
    // 3. Assert: module.[[Status]] is linked or evaluated.
    Assert(module.Status === 'linked' || module.Status === 'evaluating-async' || module.Status === 'evaluated', "module.Status === 'linked' || module.Status === 'evaluating-async' || module.Status === 'evaluated'");
    // 3. If module.[[Status]] is evaluating-async or evaluated, then
    if (module.Status === 'evaluating-async' || module.Status === 'evaluated') {
      // a. Assert: _module_.[[CycleRoot]] is not ~empty~.
      Assert(module.CycleRoot !== undefined, "module.CycleRoot !== undefined");
      // b. Set _module_ to _module_.[[CycleRoot]].
      module = module.CycleRoot;
    }
    // 4. If module.[[TopLevelCapability]] is not ~empty~, then
    if (module.TopLevelCapability !== undefined) {
      // a. Return module.[[TopLevelCapability]].[[Promise]].
      return module.TopLevelCapability.Promise;
    }
    // 4. Let stack be a new empty List.
    const stack = [];
    // (*TopLevelAwait) 6. Let capability be ! NewPromiseCapability(%Promise%).
    /* X */
    let _temp2 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const capability = _temp2;
    // (*TopLevelAwait) 7. Set module.[[TopLevelCapability]] to capability.
    module.TopLevelCapability = capability;
    // 5. Let result be InnerModuleEvaluation(module, stack, 0).
    const result = yield* InnerModuleEvaluation(module, stack, 0);
    // 6. If result is an abrupt completion, then
    if (result instanceof AbruptCompletion) {
      // a. For each Cyclic Module Record m in stack, do
      for (const m of stack) {
        // i. Assert: m.[[Status]] is evaluating.
        Assert(m.Status === 'evaluating', "m.Status === 'evaluating'");
        // ii. Assert: m.[[AsyncEvaluationOrder]] is unset.
        Assert(m.AsyncEvaluationOrder === 'unset', "m.AsyncEvaluationOrder === 'unset'");
        // iii. Set m.[[Status]] to evaluated.
        m.Status = 'evaluated';
        // iv. Set m.[[EvaluationError]] to result.
        m.EvaluationError = result;
        // v. Set _m_.[[CycleRoot]] to _m_.
        m.CycleRoot = m;
      }
      // b. Assert: module.[[Status]] is evaluated and module.[[EvaluationError]] is result.
      Assert(module.Status === 'evaluated' && module.EvaluationError === result, "module.Status === 'evaluated' && module.EvaluationError === result");
      // c. Return result.
      // c. (*TopLevelAwait) Perform ! Call(capability.[[Reject]], undefined, «result.[[Value]]»).
      /* X */
      let _temp3 = Call(capability.Reject, Value.undefined, [result.Value]);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! Call(capability.Reject, Value.undefined, [result.Value]) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    } else {
      // (*TopLevelAwait) 10. Otherwise,
      // a. Assert: module.[[Status]] is evaluating-async or evaluated.
      Assert(module.Status === 'evaluating-async' || module.Status === 'evaluated', "module.Status === 'evaluating-async' || module.Status === 'evaluated'");
      // b. Assert: module.[[EvaluationError]] is ~empty~.
      Assert(module.EvaluationError === undefined, "module.EvaluationError === undefined");
      // c. If module.[[Status]] is evaluated, then
      if (module.Status === 'evaluated') {
        // i. Assert: module.[[AsyncEvaluationOrder]] is not an integer.
        Assert(typeof module.AsyncEvaluationOrder !== 'number', "typeof module.AsyncEvaluationOrder !== 'number'");
        // ii. Perform ! Call(capability.[[Resolve]], undefined, «undefined»).
        /* X */
        let _temp4 = Call(capability.Resolve, Value.undefined, [Value.undefined]);
        /* node:coverage ignore next */
        if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! Call(capability.Resolve, Value.undefined, [Value.undefined]) returned an abrupt completion", {
          cause: _temp4
        });
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      }
      // d. Assert: stack is empty.
      Assert(stack.length === 0, "stack.length === 0");
    }
    // 9. Return undefined.
    // (*TopLevelAwait) 11. Return capability.[[Promise]].
    return capability.Promise;
  }
  mark(m) {
    super.mark(m);
    m(this.EvaluationError);
    for (const v of this.LoadedModules) {
      m(v.Module);
    }
  }
}
/** https://tc39.es/ecma262/#sec-source-text-module-records */
class SourceTextModuleRecord extends CyclicModuleRecord {
  ImportMeta;
  ECMAScriptCode;
  Context;
  ImportEntries;
  LocalExportEntries;
  IndirectExportEntries;
  StarExportEntries;
  constructor(init) {
    super(init);
    this.ImportMeta = init.ImportMeta;
    this.ECMAScriptCode = init.ECMAScriptCode;
    this.Context = init.Context;
    this.ImportEntries = init.ImportEntries;
    this.LocalExportEntries = init.LocalExportEntries;
    this.IndirectExportEntries = init.IndirectExportEntries;
    this.StarExportEntries = init.StarExportEntries;
  }

  /** https://tc39.es/ecma262/#sec-getexportednames */
  GetExportedNames(exportStarSet) {
    const module = this;
    // 1. Assert: module.[[Status]] is not new.
    Assert(module.Status !== 'new', "module.Status !== 'new'");
    // 2. If exportStarSet is not present, set exportStarSet to a new empty List.
    if (!exportStarSet) {
      exportStarSet = [];
    }
    // 3. If exportStarSet contains module, then
    if (exportStarSet.includes(module)) {
      // a. Assert: We've reached the starting point of an import * circularity.
      // b. Return a new empty List.
      return [];
    }
    // 4. Append module to exportStarSet.
    exportStarSet.push(module);
    // 5. Let exportedNames be a new empty List.
    const exportedNames = [];
    // 6. For each ExportEntry Record e in module.[[LocalExportEntries]], do
    for (const e of module.LocalExportEntries) {
      // a. Assert: module provides the direct binding for this export.
      // b. Assert: e.[[ExportName]] is not null.
      Assert(!(e.ExportName instanceof NullValue), "!(e.ExportName instanceof NullValue)");
      // c. Append e.[[ExportName]] to exportedNames.
      exportedNames.push(e.ExportName);
    }
    // 7. For each ExportEntry Record e in module.[[IndirectExportEntries]], do
    for (const e of module.IndirectExportEntries) {
      // a. Assert: module imports a specific binding for this export.
      // b. Assert: e.[[ExportName]] is not null.
      Assert(!(e.ExportName instanceof NullValue), "!(e.ExportName instanceof NullValue)");
      // c. Append e.[[ExportName]] to exportedNames.
      exportedNames.push(e.ExportName);
    }
    // 8. For each ExportEntry Record e in module.[[StarExportEntries]], do
    for (const e of module.StarExportEntries) {
      // a. Let requestedModule be GetImportedModule(module, e.[[ModuleRequest]]).
      const requestedModule = GetImportedModule(module, e.ModuleRequest);
      // b. Let starNames be requestedModule.GetExportedNames(exportStarSet).
      const starNames = requestedModule.GetExportedNames(exportStarSet);
      // c. For each element n of starNames, do
      for (const n of starNames) {
        // i. If SameValue(n, "default") is false, then
        if (SameValue(n, Value('default')) === Value.false) {
          // 1. If n is not an element of exportedNames, then
          if (!exportedNames.includes(n)) {
            // a. Append n to exportedNames.
            exportedNames.push(n);
          }
        }
      }
    }
    // 9. Return exportedNames.
    return exportedNames;
  }

  /** https://tc39.es/ecma262/#sec-resolveexport */
  ResolveExport(exportName, resolveSet) {
    const module = this;
    // 1. Assert: module.[[Status]] is not new.
    Assert(module.Status !== 'new', "module.Status !== 'new'");
    // 2. If resolveSet is not present, set resolveSet to a new empty List.
    if (!resolveSet) {
      resolveSet = [];
    }
    // 3. For each Record { [[Module]], [[ExportName]] } r in resolveSet, do
    for (const r of resolveSet) {
      // a. If module and r.[[Module]] are the same Module Record and SameValue(exportName, r.[[ExportName]]) is true, then
      if (module === r.Module && SameValue(exportName, r.ExportName) === Value.true) {
        // i. Assert: This is a circular import request.
        // ii. Return null.
        return null;
      }
    }
    // 4. Append the Record { [[Module]]: module, [[ExportName]]: exportName } to resolveSet.
    resolveSet.push({
      Module: module,
      ExportName: exportName
    });
    // 5. For each ExportEntry Record e in module.[[LocalExportEntries]], do
    for (const e of module.LocalExportEntries) {
      // a. If SameValue(exportName, e.[[ExportName]]) is true, then
      if (SameValue(exportName, e.ExportName) === Value.true) {
        // i. Assert: module provides the direct binding for this export.
        // ii. Return ResolvedBinding Record { [[Module]]: module, [[BindingName]]: e.[[LocalName]] }.
        return new ResolvedBindingRecord({
          Module: module,
          BindingName: e.LocalName
        });
      }
    }
    // 6. For each ExportEntry Record e in module.[[IndirectExportEntries]], do
    for (const e of module.IndirectExportEntries) {
      // a. If SameValue(exportName, e.[[ExportName]]) is true, then
      if (SameValue(exportName, e.ExportName) === Value.true) {
        // i. Let importedModule be GetImportedModule(module, e.[[ModuleRequest]]).
        const importedModule = GetImportedModule(module, e.ModuleRequest);
        // ii. If e.[[ImportName]] is ~all~, then
        if (e.ImportName === 'all') {
          // 1. Assert: module does not provide the direct binding for this export
          // 2. Return ResolvedBinding Record { [[Module]]: importedModule, [[BindingName]]: ~namespace~ }.
          return new ResolvedBindingRecord({
            Module: importedModule,
            BindingName: 'namespace'
          });
        } else {
          // iv. Else,
          // 1. Assert: module imports a specific binding for this export.
          // 2. Return importedModule.ResolveExport(e.[[ImportName]], resolveSet).
          return importedModule.ResolveExport(e.ImportName, resolveSet);
        }
      }
    }
    // 7. If SameValue(exportName, "default") is true, then
    if (SameValue(exportName, Value('default')) === Value.true) {
      // a. Assert: A default export was not explicitly defined by this module.
      // b. Return null.
      return null;
      // c. NOTE: A default export cannot be provided by an export * or export * from "mod" declaration.
    }
    // 8. Let starResolution be null.
    let starResolution = null;
    // 9. For each ExportEntry Record e in module.[[StarExportEntries]], do
    for (const e of module.StarExportEntries) {
      // a. Let importedModule be GetImportedModule(module, e.[[ModuleRequest]]).
      const importedModule = GetImportedModule(module, e.ModuleRequest);
      // b. Let resolution be importedModule.ResolveExport(exportName, resolveSet).
      const resolution = importedModule.ResolveExport(exportName, resolveSet);
      // c. If resolution is "ambiguous", return "ambiguous".
      if (resolution === 'ambiguous') {
        return 'ambiguous';
      }
      // d. If resolution is not null, then
      if (resolution !== null) {
        // a. Assert: resolution is a ResolvedBinding Record.
        Assert(resolution instanceof ResolvedBindingRecord, "resolution instanceof ResolvedBindingRecord");
        // b. If starResolution is null, set starResolution to resolution.
        if (starResolution === null) {
          starResolution = resolution;
        } else {
          // c. Else,
          // 1. Assert: There is more than one * import that includes the requested name.
          // 2. If resolution.[[Module]] and starResolution.[[Module]] are not the same Module Record or SameValue(resolution.[[BindingName]], starResolution.[[BindingName]]) is false, return "ambiguous".
          if (resolution.Module !== starResolution.Module || SameValue(resolution.BindingName, starResolution.BindingName) === Value.false) {
            return 'ambiguous';
          }
        }
      }
    }
    // 11. Return starResolution.
    return starResolution;
  }

  /** https://tc39.es/ecma262/#sec-source-text-module-record-initialize-environment */
  InitializeEnvironment() {
    const module = this;
    // 1. For each ExportEntry Record e in module.[[IndirectExportEntries]], do
    for (const e of module.IndirectExportEntries) {
      // a. Let resolution be module.ResolveExport(e.[[ExportName]]).
      const resolution = module.ResolveExport(e.ExportName);
      // b. If resolution is null or "ambiguous", throw a SyntaxError exception.
      if (resolution === null || resolution === 'ambiguous') {
        return surroundingAgent.Throw('SyntaxError', 'ResolutionNullOrAmbiguous', resolution, e.ExportName, module);
      }
      // c. Assert: resolution is a ResolvedBinding Record.
      Assert(resolution instanceof ResolvedBindingRecord, "resolution instanceof ResolvedBindingRecord");
    }
    // 2. Assert: All named exports from module are resolvable.
    // 3. Let realm be module.[[Realm]].
    const realm = module.Realm;
    // 4. Assert: realm is not undefined.
    Assert(!(realm instanceof UndefinedValue), "!(realm instanceof UndefinedValue)");
    // 5. Let env be NewModuleEnvironment(realm.[[GlobalEnv]]).
    const env = new ModuleEnvironmentRecord(realm.GlobalEnv);
    // 6. Set module.[[Environment]] to env.
    module.Environment = env;
    // 7. For each ImportEntry Record in in module.[[ImportEntries]], do
    for (const ie of module.ImportEntries) {
      // a. Let importedModule be GetImportedModule(module, in.[[ModuleRequest]]).
      const importedModule = GetImportedModule(module, ie.ModuleRequest);
      // b. If in.[[ImportName]] is ~namespace-object~, then
      if (ie.ImportName === 'namespace-object') {
        // i. Let namespace be GetModuleNamespace(importedModule).
        const namespace = GetModuleNamespace(importedModule);
        // ii. Perform ! env.CreateImmutableBinding(in.[[LocalName]], true).
        /* X */
        let _temp5 = env.CreateImmutableBinding(ie.LocalName, Value.true);
        /* node:coverage ignore next */
        if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateImmutableBinding(ie.LocalName, Value.true) returned an abrupt completion", {
          cause: _temp5
        });
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        // iii. Call env.InitializeBinding(in.[[LocalName]], namespace).
        /* X */
        let _temp6 = env.InitializeBinding(ie.LocalName, namespace);
        /* node:coverage ignore next */
        if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! env.InitializeBinding(ie.LocalName, namespace) returned an abrupt completion", {
          cause: _temp6
        });
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      } else {
        // c. Else,
        // i. Let resolution be importedModule.ResolveExport(in.[[ImportName]]).
        const resolution = importedModule.ResolveExport(ie.ImportName);
        // ii. If resolution is null or "ambiguous", throw a SyntaxError exception.
        if (resolution === null || resolution === 'ambiguous') {
          return surroundingAgent.Throw('SyntaxError', 'ResolutionNullOrAmbiguous', resolution, ie.ImportName, importedModule);
        }
        // iii. If resolution.[[BindingName]] is ~namespace~, then
        if (resolution.BindingName === 'namespace') {
          // 1. Let namespace be GetModuleNamespace(resolution.[[Module]]).
          const namespace = GetModuleNamespace(resolution.Module);
          // 2. Perform ! env.CreateImmutableBinding(in.[[LocalName]], true).
          /* X */
          let _temp7 = env.CreateImmutableBinding(ie.LocalName, Value.true);
          /* node:coverage ignore next */
          if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
          /* node:coverage ignore next */
          if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateImmutableBinding(ie.LocalName, Value.true) returned an abrupt completion", {
            cause: _temp7
          });
          /* node:coverage ignore next */
          if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
          // 3. Call env.InitializeBinding(in.[[LocalName]], namespace).
          /* X */
          let _temp8 = env.InitializeBinding(ie.LocalName, namespace);
          /* node:coverage ignore next */
          if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
          /* node:coverage ignore next */
          if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! env.InitializeBinding(ie.LocalName, namespace) returned an abrupt completion", {
            cause: _temp8
          });
          /* node:coverage ignore next */
          if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        } else {
          /* X */
          let _temp9 = env.CreateImportBinding(ie.LocalName, resolution.Module, resolution.BindingName);
          /* node:coverage ignore next */
          if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
          /* node:coverage ignore next */
          if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateImportBinding(ie.LocalName, resolution.Module, resolution.BindingName) returned an abrupt completion", {
            cause: _temp9
          });
          /* node:coverage ignore next */
          if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
        }
      }
    }
    // 8. Let moduleContext be a new ECMAScript code execution context.
    const moduleContext = new ExecutionContext();
    // 9. Set the Function of moduleContext to null.
    moduleContext.Function = Value.null;
    // 10. Assert: module.[[Realm]] is not undefined.
    Assert(!(module.Realm instanceof UndefinedValue), "!(module.Realm instanceof UndefinedValue)");
    // 11. Set the Realm of moduleContext to module.[[Realm]].
    moduleContext.Realm = module.Realm;
    // 12. Set the ScriptOrModule of moduleContext to module.
    moduleContext.ScriptOrModule = module;
    // 13. Set the VariableEnvironment of moduleContext to module.[[Environment]].
    moduleContext.VariableEnvironment = module.Environment;
    // 14. Set the LexicalEnvironment of moduleContext to module.[[Environment]].
    moduleContext.LexicalEnvironment = module.Environment;
    // 15. Set the PrivateEnvironment of moduleContext to null.
    moduleContext.PrivateEnvironment = Value.null;
    // 16. Set module.[[Context]] to moduleContext.
    module.Context = moduleContext;
    // 17. Push moduleContext onto the execution context stack; moduleContext is now the running execution context.
    surroundingAgent.executionContextStack.push(moduleContext);
    // 18. Let code be module.[[ECMAScriptCode]].
    const code = module.ECMAScriptCode;
    // 19. Let varDeclarations be the VarScopedDeclarations of code.
    const varDeclarations = VarScopedDeclarations(code);
    // 20. Let declaredVarNames be a new empty List.
    const declaredVarNames = new JSStringSet();
    // 21. For each element d in varDeclarations, do
    for (const d of varDeclarations) {
      // a. For each element dn of the BoundNames of d, do
      for (const dn of BoundNames(d)) {
        // i. If dn is not an element of declaredVarNames, then
        if (!declaredVarNames.has(dn)) {
          /* X */
          let _temp10 = env.CreateMutableBinding(dn, Value.false);
          /* node:coverage ignore next */
          if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
          /* node:coverage ignore next */
          if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateMutableBinding(dn, Value.false) returned an abrupt completion", {
            cause: _temp10
          });
          /* node:coverage ignore next */
          if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
          // 2. Call env.InitializeBinding(dn, undefined).
          /* X */
          let _temp11 = env.InitializeBinding(dn, Value.undefined);
          /* node:coverage ignore next */
          if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
          /* node:coverage ignore next */
          if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! env.InitializeBinding(dn, Value.undefined) returned an abrupt completion", {
            cause: _temp11
          });
          /* node:coverage ignore next */
          if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
          // 3. Append dn to declaredVarNames.
          declaredVarNames.add(dn);
        }
      }
    }
    // 22. Let lexDeclarations be the LexicallyScopedDeclarations of code.
    const lexDeclarations = LexicallyScopedDeclarations(code);
    // 24. For each element d in lexDeclarations, do
    for (const d of lexDeclarations) {
      // a. For each element dn of the BoundNames of d, do
      for (const dn of BoundNames(d)) {
        // i. If IsConstantDeclaration of d is true, then
        if (IsConstantDeclaration(d)) {
          /* X */
          let _temp12 = env.CreateImmutableBinding(dn, Value.true);
          /* node:coverage ignore next */
          if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
          /* node:coverage ignore next */
          if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateImmutableBinding(dn, Value.true) returned an abrupt completion", {
            cause: _temp12
          });
          /* node:coverage ignore next */
          if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
        } else {
          /* X */
          let _temp13 = env.CreateMutableBinding(dn, Value.false);
          /* node:coverage ignore next */
          if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
          /* node:coverage ignore next */
          if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateMutableBinding(dn, Value.false) returned an abrupt completion", {
            cause: _temp13
          });
          /* node:coverage ignore next */
          if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
        }
        // iii. If d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then
        if (d.type === 'FunctionDeclaration' || d.type === 'GeneratorDeclaration' || d.type === 'AsyncFunctionDeclaration' || d.type === 'AsyncGeneratorDeclaration') {
          // 1. Let fo be InstantiateFunctionObject of d with argument env.
          const fo = InstantiateFunctionObject(d, env, Value.null);
          // 2. Call env.InitializeBinding(dn, fo).
          /* X */
          let _temp14 = env.InitializeBinding(dn, fo);
          /* node:coverage ignore next */
          if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
          /* node:coverage ignore next */
          if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! env.InitializeBinding(dn, fo) returned an abrupt completion", {
            cause: _temp14
          });
          /* node:coverage ignore next */
          if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
        }
      }
    }
    // 25. Remove moduleContext from the execution context stack.
    surroundingAgent.executionContextStack.pop(moduleContext);
    // 26. Return unused.
    return NormalCompletion(undefined);
  }

  /** https://tc39.es/ecma262/#sec-source-text-module-record-execute-module */
  *ExecuteModule(capability) {
    // 1. Let module be this Source Text Module Record.
    const module = this;
    // 2. Suspend the currently running execution context.
    // 3. Let moduleContext be module.[[Context]].
    const moduleContext = module.Context;
    if (module.HasTLA === Value.false) {
      Assert(capability === undefined, "capability === undefined");
      // 4. Push moduleContext onto the execution context stack; moduleContext is now the running execution context.
      surroundingAgent.executionContextStack.push(moduleContext);
      // 5. Let result be the result of evaluating module.[[ECMAScriptCode]].
      const result = EnsureCompletion(yield* Evaluate(module.ECMAScriptCode));
      // 6. Suspend moduleContext and remove it from the execution context stack.
      // 7. Resume the context that is now on the top of the execution context stack as the running execution context.
      surroundingAgent.executionContextStack.pop(moduleContext);
      // 8. Return Completion(result).
      return result;
    } else {
      // (*TopLevelAwait)
      // a. Assert: capability is a PromiseCapability Record.
      Assert(capability instanceof PromiseCapabilityRecord, "capability instanceof PromiseCapabilityRecord");
      // b. Perform ! AsyncBlockStart(capability, module.[[ECMAScriptCode]], moduleCxt).
      /* X */
      let _temp15 = yield* AsyncBlockStart(capability, module.ECMAScriptCode, moduleContext);
      /* node:coverage ignore next */
      if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! yield* AsyncBlockStart(capability, module.ECMAScriptCode, moduleContext) returned an abrupt completion", {
        cause: _temp15
      });
      /* node:coverage ignore next */
      if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
      // c. Return.
      return Value.undefined;
    }
  }
  mark(m) {
    super.mark(m);
    m(this.ImportMeta);
    m(this.Context);
  }
}
/** https://tc39.es/ecma262/#sec-synthetic-module-records */
class SyntheticModuleRecord extends AbstractModuleRecord {
  LoadRequestedModules() {
    /* X */
    let _temp16 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    /* node:coverage ignore next */
    if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
      cause: _temp16
    });
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    const promise = _temp16;
    /* X */
    let _temp17 = Call(promise.Resolve, Value.undefined, [Value.undefined]);
    /* node:coverage ignore next */
    if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! Call(promise.Resolve, Value.undefined, [Value.undefined]) returned an abrupt completion", {
      cause: _temp17
    });
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    return promise.Promise;
  }
  ExportNames;
  EvaluationSteps;
  constructor(init) {
    super(init);
    this.ExportNames = init.ExportNames;
    this.EvaluationSteps = init.EvaluationSteps;
  }

  /** https://tc39.es/ecma262/#sec-synthetic-module-record-getexportednames */
  GetExportedNames() {
    const module = this;
    // 1. Return module.[[ExportNames]].
    return module.ExportNames;
  }

  /** https://tc39.es/ecma262/#sec-synthetic-module-record-resolveexport */
  ResolveExport(exportName) {
    const module = this;
    // 1. If module.[[ExportNames]] does not contain exportName, return null.
    // 2. Return ResolvedBinding Record { [[Module]]: module, [[BindingName]]: exportName }.
    for (const e of module.ExportNames) {
      if (SameValue(e, exportName) === Value.true) {
        return new ResolvedBindingRecord({
          Module: module,
          BindingName: exportName
        });
      }
    }
    return null;
  }

  /** https://tc39.es/ecma262/#sec-synthetic-module-record-link */
  Link() {
    const module = this;
    // 1. Let realm be module.[[Realm]].
    const realm = module.Realm;
    // 2. Assert: realm is not undefined.
    Assert(!(realm instanceof UndefinedValue), "!(realm instanceof UndefinedValue)");
    // 3. Let env be NewModuleEnvironment(realm.[[GlobalEnv]]).
    const env = new ModuleEnvironmentRecord(realm.GlobalEnv);
    // 4. Set module.[[Environment]] to env.
    module.Environment = env;
    // 5. For each exportName in module.[[ExportNames]],
    for (const exportName of module.ExportNames) {
      /* X */
      let _temp18 = env.CreateMutableBinding(exportName, Value.false);
      /* node:coverage ignore next */
      if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
      /* node:coverage ignore next */
      if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateMutableBinding(exportName, Value.false) returned an abrupt completion", {
        cause: _temp18
      });
      /* node:coverage ignore next */
      if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
      // b. Perform ! env.InitializeBinding(exportName, undefined).
      /* X */
      let _temp19 = env.InitializeBinding(exportName, Value.undefined);
      /* node:coverage ignore next */
      if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
      /* node:coverage ignore next */
      if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! env.InitializeBinding(exportName, Value.undefined) returned an abrupt completion", {
        cause: _temp19
      });
      /* node:coverage ignore next */
      if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    }
    // 8. Return undefined.
    return undefined;
  }

  /** https://tc39.es/ecma262/#sec-synthetic-module-record-evaluate */
  *Evaluate() {
    const module = this;
    // 1. Suspend the currently running execution context.
    // 2. Let moduleContext be a new ECMAScript code execution context.
    const moduleContext = new ExecutionContext();
    // 3. Set the Function of moduleContext to null.
    moduleContext.Function = Value.null;
    // 4. Set the Realm of moduleContext to module.[[Realm]].
    moduleContext.Realm = module.Realm;
    // 5. Set the ScriptOrModule of moduleContext to module.
    moduleContext.ScriptOrModule = module;
    // 6. Set the VariableEnvironment of moduleContext to module.[[Environment]].
    moduleContext.VariableEnvironment = module.Environment;
    // 7. Set the LexicalEnvironment of moduleContext to module.[[Environment]].
    moduleContext.LexicalEnvironment = module.Environment;
    moduleContext.PrivateEnvironment = Value.null;
    // 8. Push moduleContext on to the execution context stack; moduleContext is now the running execution context.
    surroundingAgent.executionContextStack.push(moduleContext);
    // 9. Let steps be module.[[EvaluationSteps]].
    const steps = module.EvaluationSteps;
    // 10. Let result be Completion(steps(module)).
    let result = steps(module);
    if (result && 'next' in result) {
      result = yield* result;
    }
    // 11. Suspend moduleContext and remove it from the execution context stack.
    // 12. Resume the context that is now on the top of the execution context stack as the running execution context.
    surroundingAgent.executionContextStack.pop(moduleContext);
    // 13. Let pc be ! NewPromiseCapability(%Promise%).
    /* X */
    let _temp20 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
    /* node:coverage ignore next */
    if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) _temp20 = skipDebugger(_temp20);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
      cause: _temp20
    });
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    const pc = _temp20;
    // 14. IfAbruptRejectPromise(result, pc).
    /* IfAbruptRejectPromise */
    /* node:coverage disable */
    if (result instanceof AbruptCompletion) {
      const callRejectCompletion = skipDebugger(Call(pc.Reject, Value.undefined, [result.Value]));
      if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
      return pc.Promise;
    }
    if (result instanceof Completion) result = result.Value;
    /* node:coverage enable */
    /* X */
    let _temp21 = Call(pc.Resolve, Value.undefined, [Value.undefined]);
    /* node:coverage ignore next */
    if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) _temp21 = skipDebugger(_temp21);
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! Call(pc.Resolve, Value.undefined, [Value.undefined]) returned an abrupt completion", {
      cause: _temp21
    });
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    // 16. Return pc.[[Promise]].
    return pc.Promise;
  }
  *SetSyntheticExport(name, value) {
    const module = this;
    // 1. Return module.[[Environment]].SetMutableBinding(name, value, true).
    return yield* module.Environment.SetMutableBinding(name, value, Value.true);
  }
}

/** https://tc39.es/ecma262/#sec-environment-records */
class EnvironmentRecord {
  OuterEnv;
  constructor(outerEnv) {
    this.OuterEnv = outerEnv;
  }
  // NON-SPEC
  mark(m) {
    m(this.OuterEnv);
  }
}
/** https://tc39.es/ecma262/#sec-declarative-environment-records */
class DeclarativeEnvironmentRecord extends EnvironmentRecord {
  bindings = new JSStringMap();

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-hasbinding-n */
  *HasBinding(N) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this;
    // 2. If envRec has a binding for the name that is the value of N, return true.
    if (envRec.bindings.has(N)) {
      return Value.true;
    }
    // 3. Return false.
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-createmutablebinding-n-d */
  *CreateMutableBinding(N, D) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec does not already have a binding for N.
    Assert(!envRec.bindings.has(N), "!envRec.bindings.has(N)");
    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D
    //    is true, record that the newly created binding may be deleted by a subsequent
    //    DeleteBinding call.
    this.bindings.set(N, {
      indirect: false,
      initialized: false,
      mutable: true,
      strict: undefined,
      deletable: D === Value.true,
      value: undefined,
      mark(m) {
        m(this.value);
      }
    });
    //  4. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-createimmutablebinding-n-s */
  CreateImmutableBinding(N, S) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec does not already have a binding for N.
    Assert(!envRec.bindings.has(N), "!envRec.bindings.has(N)");
    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If
    //    S is true, record that the newly created binding is a strict binding.
    this.bindings.set(N, {
      indirect: false,
      initialized: false,
      mutable: false,
      strict: S === Value.true,
      deletable: false,
      value: undefined,
      mark(m) {
        m(this.value);
      }
    });
    // 4. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-initializebinding-n-v */
  *InitializeBinding(N, V) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec must have an uninitialized binding for N.
    const binding = envRec.bindings.get(N);
    Assert(binding !== undefined && binding.initialized === false, "binding !== undefined && binding.initialized === false");
    // 3. Set the bound value for N in envRec to V.
    binding.value = V;
    // 4. Record that the binding for N in envRec has been initialized.
    binding.initialized = true;
    // 5. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-setmutablebinding-n-v-s */
  *SetMutableBinding(N, V, S) {
    Assert(IsPropertyKey(N), "IsPropertyKey(N)");
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this;
    // 2. If envRec does not have a binding for N, then
    if (!envRec.bindings.has(N)) {
      // a. If S is true, throw a ReferenceError exception.
      if (S === Value.true) {
        return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
      }
      // b. Perform envRec.CreateMutableBinding(N, true).
      yield* envRec.CreateMutableBinding(N, Value.true);
      // c. Perform envRec.InitializeBinding(N, V).
      envRec.InitializeBinding(N, V);
      // d. Return NormalCompletion(empty).
      return NormalCompletion(undefined);
    }
    const binding = this.bindings.get(N);
    // 3. If the binding for N in envRec is a strict binding, set S to true.
    if (binding.strict === true) {
      S = Value.true;
    }
    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.
    if (binding.initialized === false) {
      return surroundingAgent.Throw('ReferenceError', 'NotInitialized', N);
    }
    // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.
    if (binding.mutable === true) {
      binding.value = V;
    } else {
      // a. Assert: This is an attempt to change the value of an immutable binding.
      // b. If S is true, throw a TypeError exception.
      if (S === Value.true) {
        return surroundingAgent.Throw('TypeError', 'AssignmentToConstant', N);
      }
    }
    // 7. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-getbindingvalue-n-s */
  *GetBindingValue(N, _S) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec has a binding for N.
    const binding = envRec.bindings.get(N);
    Assert(binding !== undefined, "binding !== undefined");
    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.
    if (binding.initialized === false) {
      return surroundingAgent.Throw('ReferenceError', 'NotInitialized', N);
    }
    // 4. Return the value currently bound to N in envRec.
    return NormalCompletion(binding.value);
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-deletebinding-n */
  *DeleteBinding(N) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec has a binding for the name that is the value of N.
    const binding = envRec.bindings.get(N);
    Assert(binding !== undefined, "binding !== undefined");
    // 3. If the binding for N in envRec cannot be deleted, return false.
    if (binding.deletable === false) {
      return Value.false;
    }
    // 4. Remove the binding for N from envRec.
    envRec.bindings.delete(N);
    // 5. Return true.
    return Value.true;
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-hasthisbinding */
  HasThisBinding() {
    // 1. Return false.
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-hassuperbinding */
  HasSuperBinding() {
    // 1. Return false.
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-declarative-environment-records-withbaseobject */
  WithBaseObject() {
    // 1. Return undefined.
    return Value.undefined;
  }

  // NON-SPEC
  mark(m) {
    // TODO(ts): this function does not call super.mark(). is it a mistake?
    m(this.bindings);
  }
}

/** https://tc39.es/ecma262/#sec-object-environment-records */
class ObjectEnvironmentRecord extends EnvironmentRecord {
  BindingObject;
  IsWithEnvironment;

  /** https://tc39.es/ecma262/#sec-newobjectenvironment */
  constructor(O, W, E) {
    super(E);
    this.BindingObject = O;
    this.IsWithEnvironment = W;
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-hasbinding-n */
  *HasBinding(N) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let bindings be the binding object for envRec.
    const bindings = envRec.BindingObject;
    // 3. Let foundBinding be ? HasProperty(bindings, N).
    /* ReturnIfAbrupt */
    let _temp = yield* HasProperty(bindings, N);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const foundBinding = _temp;
    // 4. If foundBinding is false, return false.
    if (foundBinding === Value.false) {
      return Value.false;
    }
    // 5. If the IsWithEnvironment flag of envRec i s false, return true.
    if (envRec.IsWithEnvironment === Value.false) {
      return Value.true;
    }
    // 6. Let unscopables be ? Get(bindings, @@unscopables).
    /* ReturnIfAbrupt */
    let _temp2 = yield* Get(bindings, wellKnownSymbols.unscopables);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const unscopables = _temp2;
    // 7. If Type(unscopables) is Object, then
    if (unscopables instanceof ObjectValue) {
      /* ReturnIfAbrupt */
      let _temp4 = yield* Get(unscopables, N);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      /* X */
      let _temp3 = ToBoolean(_temp4);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(Q(yield* Get(unscopables, N))) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // a. Let blocked be ! ToBoolean(? Get(unscopables, N)).
      const blocked = _temp3;
      // b. If blocked is true, return false.
      if (blocked === Value.true) {
        return Value.false;
      }
    }
    // 8. Return true.
    return Value.true;
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-createmutablebinding-n-d */
  *CreateMutableBinding(N, D) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let envRec be the object Environment Record for which the method was invoked.
    const bindings = envRec.BindingObject;
    // 3. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }).
    /* ReturnIfAbrupt */
    let _temp5 = yield* DefinePropertyOrThrow(bindings, N, _Descriptor({
      Value: Value.undefined,
      Writable: Value.true,
      Enumerable: Value.true,
      Configurable: D
    }));
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-createimmutablebinding-n-s */
  CreateImmutableBinding(_N, _S) {
    Assert(false, 'CreateImmutableBinding called on an Object Environment Record', "false");
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-initializebinding-n-v */
  *InitializeBinding(N, V) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec must have an uninitialized binding for N.
    // 3. Record that the binding for N in envRec has been initialized.
    // 4. Return ? envRec.SetMutableBinding(N, V, false).
    /* ReturnIfAbrupt */
    let _temp6 = yield* envRec.SetMutableBinding(N, V, Value.false);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-setmutablebinding-n-v-s */
  *SetMutableBinding(N, V, S) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let bindings be the binding object for envRec.
    const bindings = envRec.BindingObject;
    // 3. Let stillExists be ? HasProperty(bindings, N).
    /* ReturnIfAbrupt */
    let _temp7 = yield* HasProperty(bindings, N);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const stillExists = _temp7;
    // 4. If stillExists is false and S is true, throw a ReferenceError exception.
    if (stillExists === Value.false && S === Value.true) {
      return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
    }
    // 5. Return ? Set(bindings, N, V, S).
    /* ReturnIfAbrupt */
    let _temp8 = yield* Set$1(bindings, N, V, S);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    return undefined;
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-getbindingvalue-n-s */
  *GetBindingValue(N, S) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let bindings be the binding object for envRec.
    const bindings = envRec.BindingObject;
    // 3. Let value be ? HasProperty(bindings, N).
    /* ReturnIfAbrupt */
    let _temp9 = yield* HasProperty(bindings, N);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    const value = _temp9;
    // 4. If value is false, then
    if (value === Value.false) {
      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.
      if (S === Value.false) {
        return NormalCompletion(Value.undefined);
      } else {
        return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
      }
    }
    // 5. Return Get(bindings, N).
    return yield* Get(bindings, N);
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-deletebinding-n */
  *DeleteBinding(N) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let bindings be the binding object for envRec.
    const bindings = envRec.BindingObject;
    // 3. Return ? bindings.[[Delete]](N).
    return yield* bindings.Delete(N);
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-hasthisbinding */
  HasThisBinding() {
    // 1. Return false.
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-hassuperbinding */
  HasSuperBinding() {
    // 1. Return falase.
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-object-environment-records-withbaseobject */
  WithBaseObject() {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    const envRec = this;
    // 2. If the IsWithEnvironment flag of envRec is true, return the binding object for envRec.
    if (envRec.IsWithEnvironment === Value.true) {
      return envRec.BindingObject;
    }
    // 3. Otherwise, return undefined.
    return Value.undefined;
  }

  // NON-SPEC
  mark(m) {
    // TODO(ts): this function does not call super.mark(). is it a mistake?
    m(this.BindingObject);
  }
}

/** https://tc39.es/ecma262/#sec-function-environment-records */
class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {
  /** https://tc39.es/ecma262/#sec-newfunctionenvironment */
  constructor(F, newTarget) {
    // 1. Assert: F is an ECMAScript function.
    Assert(isECMAScriptFunctionObject(F), "isECMAScriptFunctionObject(F)");
    // 2. Assert: Type(newTarget) is Undefined or Object.
    Assert(newTarget instanceof UndefinedValue || newTarget instanceof ObjectValue, "newTarget instanceof UndefinedValue || newTarget instanceof ObjectValue");
    // 3. Let env be a new function Environment Record containing no bindings.
    super(F.Environment);
    // 4. Set env.[[FunctionObject]] to F.
    this.FunctionObject = F;
    // 5. If F.[[ThisMode]] is lexical, set env.[[ThisBindingStatus]] to lexical.

    if (F.ThisMode === 'lexical') {
      this.ThisBindingStatus = 'lexical';
    } else {
      // 6. Else, set env.[[ThisBindingStatus]] to uninitialized.
      this.ThisBindingStatus = 'uninitialized';
    }
    // 7. Set env.[[NewTarget]] to newTarget.
    this.NewTarget = newTarget;
    // 8. Set env.[[OuterEnv]] to F.[[Environment]].
    // 9. Return env.
  }
  ThisValue;
  ThisBindingStatus;
  FunctionObject;
  NewTarget;

  /** https://tc39.es/ecma262/#sec-bindthisvalue */
  BindThisValue(V) {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec.[[ThisBindingStatus]] is not lexical.
    Assert(envRec.ThisBindingStatus !== 'lexical', "envRec.ThisBindingStatus !== 'lexical'");
    // 3. If envRec.[[ThisBindingStatus]] is initialized, throw a ReferenceError exception.
    if (envRec.ThisBindingStatus === 'initialized') {
      return surroundingAgent.Throw('ReferenceError', 'InvalidThis');
    }
    // 4. Set envRec.[[ThisValue]] to V.
    envRec.ThisValue = V;
    // 5. Set envRec.[[ThisBindingStatus]] to initialized.
    envRec.ThisBindingStatus = 'initialized';
    // 6. Return V.
    return V;
  }

  /** https://tc39.es/ecma262/#sec-function-environment-records-hasthisbinding */
  HasThisBinding() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    const envRec = this;
    // 2. If envRec.[[ThisBindingStatus]] is lexical, return false; otherwise, return true.
    if (envRec.ThisBindingStatus === 'lexical') {
      return Value.false;
    } else {
      return Value.true;
    }
  }

  /** https://tc39.es/ecma262/#sec-function-environment-records-hassuperbinding */
  HasSuperBinding() {
    const envRec = this;
    // 1. If envRec.[[ThisBindingStatus]] is lexical, return false.
    if (envRec.ThisBindingStatus === 'lexical') {
      return Value.false;
    }
    // 2. If envRec.[[FunctionObject]].[[HomeObject]] has the value undefined, return false; otherwise, return true.
    if (envRec.FunctionObject.HomeObject === Value.undefined) {
      return Value.false;
    } else {
      return Value.true;
    }
  }

  /** https://tc39.es/ecma262/#sec-function-environment-records-getthisbinding */
  GetThisBinding() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec.[[ThisBindingStatus]] is not lexical.
    Assert(envRec.ThisBindingStatus !== 'lexical', "envRec.ThisBindingStatus !== 'lexical'");
    // 3. If envRec.[[ThisBindingStatus]] is uninitialized, throw a ReferenceError exception.
    if (envRec.ThisBindingStatus === 'uninitialized') {
      return surroundingAgent.Throw('ReferenceError', 'InvalidThis');
    }
    // 4. Return envRec.[[ThisValue]].
    return envRec.ThisValue;
  }

  /** https://tc39.es/ecma262/#sec-getsuperbase */
  GetSuperBase() {
    const envRec = this;
    // 1. Let home be envRec.[[FunctionObject]].[[HomeObject]].
    const home = envRec.FunctionObject.HomeObject;
    // 2. If home has the value undefined, return undefined.
    if (home === Value.undefined) {
      return Value.undefined;
    }
    // 3. Assert: Type(home) is Object.
    Assert(home instanceof ObjectValue, "home instanceof ObjectValue");
    // 4. Return ! home.[[GetPrototypeOf]]().
    /* X */
    let _temp10 = home.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! home.GetPrototypeOf() returned an abrupt completion", {
      cause: _temp10
    });
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    return _temp10;
  }
  mark(m) {
    super.mark(m);
    m(this.ThisValue);
    m(this.FunctionObject);
    m(this.NewTarget);
  }
}

/** https://tc39.es/ecma262/#sec-global-environment-records */
class GlobalEnvironmentRecord extends EnvironmentRecord {
  ObjectRecord;
  GlobalThisValue;
  DeclarativeRecord;
  VarNames;

  /** https://tc39.es/ecma262/#sec-newglobalenvironment */
  constructor(G, thisValue) {
    // 1. Let objRec be NewObjectEnvironment(G, false, null).
    const objRec = new ObjectEnvironmentRecord(G, Value.false, Value.null);
    // 2. Let dclRec be a new declarative Environment Record containing no bindings.
    const dclRec = new DeclarativeEnvironmentRecord(Value.null);
    // 3. Let env be a new global Environment Record.
    super(Value.null);
    // 4. Set env.[[ObjectRecord]] to objRec.
    this.ObjectRecord = objRec;
    // 5. Set env.[[GlobalThisValue]] to thisValue.
    this.GlobalThisValue = thisValue;
    // 6. Set env.[[DeclarativeRecord]] to dclRec.
    this.DeclarativeRecord = dclRec;
    // 7. Set env.[[VarNames]] to a new empty List.
    this.VarNames = [];
    // 8. Set env.[[OuterEnv]] to null.
    // 9. Return env.
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-hasbinding-n */
  *HasBinding(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let DclRec be envRec.[[DeclarativeRecord]].
    const DclRec = envRec.DeclarativeRecord;
    // 3. If DclRec.HasBinding(N) is true, return true.
    if ((yield* DclRec.HasBinding(N)) === Value.true) {
      return Value.true;
    }
    // 4. If DclRec.HasBinding(N) is true, return true.
    const ObjRec = envRec.ObjectRecord;
    // 5. Let ObjRec be envRec.[[ObjectRecord]].
    return yield* ObjRec.HasBinding(N);
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-createmutablebinding-n-d */
  *CreateMutableBinding(N, D) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let DclRec be envRec.[[DeclarativeRecord]].
    const DclRec = envRec.DeclarativeRecord;
    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.
    if ((yield* DclRec.HasBinding(N)) === Value.true) {
      return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', N);
    }
    // 4. Return DclRec.CreateMutableBinding(N, D).
    return yield* DclRec.CreateMutableBinding(N, D);
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-createimmutablebinding-n-s */
  CreateImmutableBinding(N, S) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let DclRec be envRec.[[DeclarativeRecord]].
    const DclRec = envRec.DeclarativeRecord;
    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.
    // TODO: remove skipDebugger
    if (skipDebugger(DclRec.HasBinding(N)) === Value.true) {
      return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', N);
    }
    // Return DclRec.CreateImmutableBinding(N, S).
    return DclRec.CreateImmutableBinding(N, S);
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-initializebinding-n-v */
  *InitializeBinding(N, V) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let DclRec be envRec.[[DeclarativeRecord]].
    const DclRec = envRec.DeclarativeRecord;
    // 3. If DclRec.HasBinding(N) is true, then
    // TODO: remove skipDebugger
    if (skipDebugger(DclRec.HasBinding(N)) === Value.true) {
      // a. Return DclRec.InitializeBinding(N, V).
      return yield* DclRec.InitializeBinding(N, V);
    }
    // 4. Assert: If the binding exists, it must be in the object Environment Record.
    // 5. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 6. Return ? ObjRec.InitializeBinding(N, V).
    return yield* ObjRec.InitializeBinding(N, V);
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-setmutablebinding-n-v-s */
  *SetMutableBinding(N, V, S) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let DclRec be envRec.[[DeclarativeRecord]].
    const DclRec = envRec.DeclarativeRecord;
    // 3. If DclRec.HasBinding(N) is true, then
    if ((yield* DclRec.HasBinding(N)) === Value.true) {
      // a. Return DclRec.SetMutableBinding(N, V, S).
      return yield* DclRec.SetMutableBinding(N, V, S);
    }
    // 4. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).
    /* ReturnIfAbrupt */
    let _temp11 = yield* ObjRec.SetMutableBinding(N, V, S);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) return _temp11;
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    return undefined;
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-getbindingvalue-n-s */
  *GetBindingValue(N, S) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let DclRec be envRec.[[DeclarativeRecord]].
    const DclRec = envRec.DeclarativeRecord;
    // 3. If DclRec.HasBinding(N) is true, then
    if ((yield* DclRec.HasBinding(N)) === Value.true) {
      // a. Return DclRec.GetBindingValue(N, S).
      return yield* DclRec.GetBindingValue(N, S);
    }
    // 4. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 5. Return ObjRec.GetBindingValue(N, S).
    return yield* ObjRec.GetBindingValue(N, S);
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-deletebinding-n */
  *DeleteBinding(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let DclRec be envRec.[[DeclarativeRecord]].
    const DclRec = this.DeclarativeRecord;
    // 3. Let DclRec be envRec.[[DeclarativeRecord]].
    if ((yield* DclRec.HasBinding(N)) === Value.true) {
      // a. Return DclRec.DeleteBinding(N).
      return yield* DclRec.DeleteBinding(N);
    }
    // 4. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 5. Let globalObject be the binding object for ObjRec.
    const globalObject = ObjRec.BindingObject;
    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).
    /* ReturnIfAbrupt */
    let _temp12 = yield* HasOwnProperty(globalObject, N);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) return _temp12;
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    const existingProp = _temp12;
    // 7. If existingProp is true, then
    if (existingProp === Value.true) {
      /* ReturnIfAbrupt */
      let _temp13 = yield* ObjRec.DeleteBinding(N);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      // a. Let status be ? ObjRec.DeleteBinding(N).
      const status = _temp13;
      // b. If status is true, then
      if (status === Value.true) {
        // i. Let varNames be envRec.[[VarNames]].
        const varNames = envRec.VarNames;
        // ii. If N is an element of varNames, remove that element from the varNames.
        const i = varNames.findIndex(v => v.stringValue() === N.stringValue());
        if (i >= 0) {
          varNames.splice(i, 1);
        }
      }
      // c. Return status.
      return status;
    }
    // 8. Return true.
    return Value.true;
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-hasthisbinding */
  HasThisBinding() {
    // Return true.
    return Value.true;
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-hassuperbinding */
  HasSuperBinding() {
    // 1. Return false.
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-withbaseobject */
  WithBaseObject() {
    // 1. Return undefined.
    return Value.undefined;
  }

  /** https://tc39.es/ecma262/#sec-global-environment-records-getthisbinding */
  GetThisBinding() {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Return envRec.[[GlobalThisValue]].
    return envRec.GlobalThisValue;
  }

  /** https://tc39.es/ecma262/#sec-hasvardeclaration */
  HasVarDeclaration(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let varDeclaredNames be envRec.[[VarNames]].
    const varDeclaredNames = envRec.VarNames;
    // 3. If varDeclaredNames contains N, return true.
    if (varDeclaredNames.some(v => v.stringValue() === N.stringValue())) {
      return Value.true;
    }
    // 4. Return false.
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-haslexicaldeclaration */
  *HasLexicalDeclaration(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let envRec be the global Environment Record for which the method was invoked.
    const DclRec = envRec.DeclarativeRecord;
    // 3. Let DclRec be envRec.[[DeclarativeRecord]].
    return yield* DclRec.HasBinding(N);
  }

  /** https://tc39.es/ecma262/#sec-hasrestrictedglobalproperty */
  *HasRestrictedGlobalProperty(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 3. Let globalObject be the binding object for ObjRec.
    const globalObject = ObjRec.BindingObject;
    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
    /* ReturnIfAbrupt */
    let _temp14 = yield* globalObject.GetOwnProperty(N);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) return _temp14;
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    const existingProp = _temp14;
    // 5. If existingProp is undefined, return false.
    if (existingProp instanceof UndefinedValue) {
      return Value.false;
    }
    // 6. If existingProp.[[Configurable]] is true, return false.
    if (existingProp.Configurable === Value.true) {
      return Value.false;
    }
    // Return true.
    return Value.true;
  }

  /** https://tc39.es/ecma262/#sec-candeclareglobalvar */
  *CanDeclareGlobalVar(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 3. Let globalObject be the binding object for ObjRec.
    const globalObject = ObjRec.BindingObject;
    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).
    /* ReturnIfAbrupt */
    let _temp15 = yield* HasOwnProperty(globalObject, N);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) return _temp15;
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    const hasProperty = _temp15;
    // 5. If hasProperty is true, return true.
    if (hasProperty === Value.true) {
      return Value.true;
    }
    // 6. Return ? IsExtensible(globalObject).
    return yield* IsExtensible(globalObject);
  }

  /** https://tc39.es/ecma262/#sec-candeclareglobalfunction */
  *CanDeclareGlobalFunction(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 3. Let globalObject be the binding object for ObjRec.
    const globalObject = ObjRec.BindingObject;
    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
    /* ReturnIfAbrupt */
    let _temp16 = yield* globalObject.GetOwnProperty(N);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) return _temp16;
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    const existingProp = _temp16;
    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).
    if (existingProp instanceof UndefinedValue) {
      return yield* IsExtensible(globalObject);
    }
    // 6. If existingProp.[[Configurable]] is true, return true.
    if (existingProp.Configurable === Value.true) {
      return Value.true;
    }
    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values
    //    { [[Writable]]: true, [[Enumerable]]: true }, return true.
    if (IsDataDescriptor(existingProp) === true && existingProp.Writable === Value.true && existingProp.Enumerable === Value.true) {
      return Value.true;
    }
    // 8. Return false.
    return Value.false;
  }

  /** https://tc39.es/ecma262/#sec-createglobalvarbinding */
  *CreateGlobalVarBinding(N, D) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 3. Let globalObject be the binding object for ObjRec.
    const globalObject = ObjRec.BindingObject;
    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).
    /* ReturnIfAbrupt */
    let _temp17 = yield* HasOwnProperty(globalObject, N);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    const hasProperty = _temp17;
    // 5. Let extensible be ? IsExtensible(globalObject).
    /* ReturnIfAbrupt */
    let _temp18 = yield* IsExtensible(globalObject);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) return _temp18;
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    const extensible = _temp18;
    // 6. If hasProperty is false and extensible is true, then
    if (hasProperty === Value.false && extensible === Value.true) {
      /* ReturnIfAbrupt */
      let _temp19 = yield* ObjRec.CreateMutableBinding(N, D);
      /* node:coverage ignore next */
      if (_temp19 instanceof AbruptCompletion) return _temp19;
      /* node:coverage ignore next */
      if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
      // b. Perform ? ObjRec.InitializeBinding(N, undefined).
      /* ReturnIfAbrupt */
      let _temp20 = yield* ObjRec.InitializeBinding(N, Value.undefined);
      /* node:coverage ignore next */
      if (_temp20 instanceof AbruptCompletion) return _temp20;
      /* node:coverage ignore next */
      if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    }
    // 7. Let varDeclaredNames be envRec.[[VarNames]].
    const varDeclaredNames = envRec.VarNames;
    // 8. If varDeclaredNames does not contain N, then
    if (!varDeclaredNames.some(v => v.stringValue() === N.stringValue())) {
      // a. Append N to varDeclaredNames.
      varDeclaredNames.push(N);
    }
    // return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }

  /** https://tc39.es/ecma262/#sec-createglobalfunctionbinding */
  *CreateGlobalFunctionBinding(N, V, D) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Let ObjRec be envRec.[[ObjectRecord]].
    const ObjRec = envRec.ObjectRecord;
    // 3. Let globalObject be the binding object for ObjRec.
    const globalObject = ObjRec.BindingObject;
    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
    /* ReturnIfAbrupt */
    let _temp21 = yield* globalObject.GetOwnProperty(N);
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) return _temp21;
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    const existingProp = _temp21;
    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then
    let desc;
    if (existingProp instanceof UndefinedValue || existingProp.Configurable === Value.true) {
      // a. Let desc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }.
      desc = _Descriptor({
        Value: V,
        Writable: Value.true,
        Enumerable: Value.true,
        Configurable: D
      });
    } else {
      // a. Let desc be the PropertyDescriptor { [[Value]]: V }.
      desc = _Descriptor({
        Value: V
      });
    }
    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).
    /* ReturnIfAbrupt */
    let _temp22 = yield* DefinePropertyOrThrow(globalObject, N, desc);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    // 8. Record that the binding for N in ObjRec has been initialized.
    // 9. Perform ? Set(globalObject, N, V, false).
    /* ReturnIfAbrupt */
    let _temp23 = yield* Set$1(globalObject, N, V, Value.false);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    // 10. Let varDeclaredNames be envRec.[[VarNames]].
    const varDeclaredNames = envRec.VarNames;
    // 11. If varDeclaredNames does not contain N, then
    if (!varDeclaredNames.some(v => v.stringValue() === N.stringValue())) {
      // a. Append N to varDeclaredNames.
      varDeclaredNames.push(N);
    }
    // 1. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
  mark(m) {
    // TODO(ts): this function does not call super.mark(). is it a mistake?
    m(this.ObjectRecord);
    m(this.GlobalThisValue);
    m(this.DeclarativeRecord);
  }
}

/** https://tc39.es/ecma262/#sec-module-environment-records */
class ModuleEnvironmentRecord extends DeclarativeEnvironmentRecord {
  /** https://tc39.es/ecma262/#sec-module-environment-records-getbindingvalue-n-s */
  *GetBindingValue(N, S) {
    // 1. Assert: S is true.
    Assert(S === Value.true, "S === Value.true");
    // 2. Let envRec be the module Environment Record for which the method was invoked.
    const envRec = this;
    // 3. Assert: envRec has a binding for N.
    const binding = envRec.bindings.get(N);
    Assert(binding !== undefined, "binding !== undefined");
    // 4. If the binding for N is an indirect binding, then
    if (binding.indirect === true) {
      // a. Let M and N2 be the indirection values provided when this binding for N was created.
      const [M, N2] = binding.target;
      // b.Let targetEnv be M.[[Environment]].
      const targetEnv = M.Environment;
      // c. If targetEnv is undefined, throw a ReferenceError exception.
      if (!targetEnv) {
        return surroundingAgent.Throw('ReferenceError', 'NotDefined', N);
      }
      // d. Return ? targetEnv.GetBindingValue(N2, true).
      return yield* targetEnv.GetBindingValue(N2, Value.true);
    }
    // 5. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.
    if (binding.initialized === false) {
      return surroundingAgent.Throw('ReferenceError', 'NotInitialized', N);
    }
    // 6. Return the value currently bound to N in envRec.
    return NormalCompletion(binding.value);
  }

  /** https://tc39.es/ecma262/#sec-module-environment-records-deletebinding-n */
  DeleteBinding() {
    Assert(false, 'This method is never invoked. See #sec-delete-operator-static-semantics-early-errors', "false");
  }

  /** https://tc39.es/ecma262/#sec-module-environment-records-hasthisbinding */
  HasThisBinding() {
    // Return true.
    return Value.true;
  }

  /** https://tc39.es/ecma262/#sec-module-environment-records-getthisbinding */
  GetThisBinding() {
    // Return undefined.
    return Value.undefined;
  }

  /** https://tc39.es/ecma262/#sec-createimportbinding */
  CreateImportBinding(N, M, N2) {
    // 1. Let envRec be the module Environment Record for which the method was invoked.
    const envRec = this;
    // 2. Assert: envRec does not already have a binding for N.
    Assert(skipDebugger(envRec.HasBinding(N)) === Value.false, "skipDebugger(envRec.HasBinding(N)) === Value.false");
    // 3. Assert: M is a Module Record.
    Assert(M instanceof AbstractModuleRecord, "M instanceof AbstractModuleRecord");
    // 4. Assert: When M.[[Environment]] is instantiated it will have a direct binding for N2.
    // 5. Create an immutable indirect binding in envRec for N that references M and N2 as its target binding and record that the binding is initialized.
    envRec.bindings.set(N, {
      indirect: true,
      target: [M, N2],
      initialized: true,
      mark(m) {
        m(this.target[0]);
        m(this.target[1]);
      }
    });
    // 6. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
}

/** https://tc39.es/ecma262/#sec-getidentifierreference */
function* GetIdentifierReference(env, name, strict) {
  // 1. If lex is the value null, then
  if (env instanceof NullValue) {
    // a. Return the Reference Record { [[Base]]: unresolvable, [[ReferencedName]]: name, [[Strict]]: strict, [[ThisValue]]: empty }.
    return NormalCompletion(new ReferenceRecord({
      Base: 'unresolvable',
      ReferencedName: name,
      Strict: strict,
      ThisValue: undefined
    }));
  }
  // 2. Let exists be ? envRec.HasBinding(name).
  /* ReturnIfAbrupt */
  let _temp24 = yield* env.HasBinding(name);
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) return _temp24;
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  const exists = _temp24;
  // 3. If exists is true, then
  if (exists === Value.true) {
    // a. Return the Reference Record { [[Base]]: env, [[ReferencedName]]: name, [[Strict]]: strict, [[ThisValue]]: empty }.
    return NormalCompletion(new ReferenceRecord({
      Base: env,
      ReferencedName: name,
      Strict: strict,
      ThisValue: undefined
    }));
  } else {
    // a. Let outer be env.[[OuterEnv]].
    const outer = env.OuterEnv;
    // b. Return ? GetIdentifierReference(outer, name, strict).
    return yield* GetIdentifierReference(outer, name, strict);
  }
}
GetIdentifierReference.section = 'https://tc39.es/ecma262/#sec-getidentifierreference';
class PrivateEnvironmentRecord {
  OuterPrivateEnvironment;
  Names = [];

  /** https://tc39.es/ecma262/#sec-newprivateenvironment */
  constructor(outerEnv) {
    this.OuterPrivateEnvironment = outerEnv;
  }
  mark(m) {
    this.Names.forEach(name => {
      m(name);
    });
  }
}

function* ClassElementEvaluation(node, object, enumerable) {
  switch (node.type) {
    case 'MethodDefinition':
    case 'GeneratorMethod':
    case 'AsyncMethod':
    case 'AsyncGeneratorMethod':
      return yield* MethodDefinitionEvaluation(node, object, enumerable);
    case 'FieldDefinition':
      return yield* ClassFieldDefinitionEvaluation(node, object);
    case 'ClassStaticBlock':
      return ClassStaticBlockDefinitionEvaluation(node, object);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('ClassElementEvaluation', node);
  }
}

// ClassTail : ClassHeritage? `{` ClassBody? `}`
function* ClassDefinitionEvaluation(ClassTail, classBinding, className) {
  const {
    ClassHeritage,
    ClassBody
  } = ClassTail;
  // 1. Let env be the LexicalEnvironment of the running execution context.
  const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 2. Let classScope be NewDeclarativeEnvironment(env).
  const classScope = new DeclarativeEnvironmentRecord(env);
  // 3. If classBinding is not undefined, then
  if (!(classBinding instanceof UndefinedValue)) {
    // a. Perform classScopeEnv.CreateImmutableBinding(classBinding, true).
    classScope.CreateImmutableBinding(classBinding, Value.true);
  }
  // 4. Let outerPrivateEnvironment be the running execution context's PrivateEnvironment.
  const outerPrivateEnvironment = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 5. Let classPrivateEnvironment be NewPrivateEnvironment(outerPrivateEnvironment).
  const classPrivateEnvironment = new PrivateEnvironmentRecord(outerPrivateEnvironment);
  // 6. If ClassBody is present, then
  if (ClassBody) {
    // a. For each String dn of the PrivateBoundIdentifiers of ClassBody, do
    for (const dn of PrivateBoundIdentifiers(ClassBody)) {
      // i. If classPrivateEnvironment.[[Names]] contains a Private Name whose [[Description]] is dn, then
      const existing = classPrivateEnvironment.Names.find(n => n.Description.stringValue() === dn.stringValue());
      if (existing) ; else {
        // ii. Else,
        // 1. Let name be a new Private Name whose [[Description]] value is dn.
        const name = new PrivateName(dn);
        // 2. Append name to classPrivateEnvironment.[[Names]].
        classPrivateEnvironment.Names.push(name);
      }
    }
  }
  let protoParent;
  let constructorParent;
  // 7. If ClassHeritage is not present, then
  if (!ClassHeritage) {
    // a. Let protoParent be %Object.prototype%.
    protoParent = surroundingAgent.intrinsic('%Object.prototype%');
    // b. Let constructorParent be %Function.prototype%.
    constructorParent = surroundingAgent.intrinsic('%Function.prototype%');
  } else {
    // 8. Else,
    // a. Set the running execution context's LexicalEnvironment to classScope.
    surroundingAgent.runningExecutionContext.LexicalEnvironment = classScope;
    // b. Let superclassRef be the result of evaluating ClassHeritage.
    /* ReturnIfAbrupt */
    let _temp = yield* Evaluate(ClassHeritage);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const superclassRef = _temp;
    // c. Set the running execution context's LexicalEnvironment to env.
    surroundingAgent.runningExecutionContext.LexicalEnvironment = env;
    // d. Let superclass be ? GetValue(superclassRef).
    /* ReturnIfAbrupt */
    let _temp2 = yield* GetValue(superclassRef);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const superclass = _temp2;
    // e. If superclass is null, then
    if (superclass instanceof NullValue) {
      // i. Let protoParent be null.
      protoParent = Value.null;
      // ii. Let constructorParent be %Function.prototype%.
      constructorParent = surroundingAgent.intrinsic('%Function.prototype%');
    } else if (!IsConstructor(superclass)) {
      // f. Else if IsConstructor(superclass) is false, throw a TypeError exception.
      return surroundingAgent.Throw('TypeError', 'NotAConstructor', superclass);
    } else {
      /* ReturnIfAbrupt */
      let _temp3 = yield* Get(superclass, Value('prototype'));
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // g. Else,
      // i. Let protoParent be ? Get(superclass, "prototype").
      protoParent = _temp3;
      // ii. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.
      if (!(protoParent instanceof ObjectValue) && !(protoParent instanceof NullValue)) {
        return surroundingAgent.Throw('TypeError', 'ObjectPrototypeType');
      }
      // iii. Let constructorParent be superclass.
      constructorParent = superclass;
    }
  }
  // 9. Let proto be OrdinaryObjectCreate(protoParent).
  const proto = OrdinaryObjectCreate(protoParent);
  let constructor;
  // 10. If ClassBody is not present, let constructor be empty.
  if (!ClassBody) {
    constructor = undefined;
  } else {
    // 11. Else, let constructor be ConstructorMethod of ClassBody.
    constructor = ConstructorMethod(ClassBody);
  }
  // 12. Set the running execution context's LexicalEnvironment to classScope.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = classScope;
  // 13. Set the running execution context's PrivateEnvironment to classPrivateEnvironment.
  surroundingAgent.runningExecutionContext.PrivateEnvironment = classPrivateEnvironment;
  let F;
  // 14. If constructor is empty, then
  if (constructor === undefined) {
    // a. Let defaultConstructor be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
    const defaultConstructor = function* defaultConstructor(args, {
      NewTarget
    }) {
      // i. Let args be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
      // ii. If NewTarget is undefined, throw a TypeError exception.
      if (NewTarget instanceof UndefinedValue) {
        return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', surroundingAgent.activeFunctionObject);
      }
      // iii. Let F be the active function object.
      const F = surroundingAgent.activeFunctionObject; // eslint-disable-line no-shadow
      let result;
      // iv. If F.[[ConstructorKind]] is derived, then
      if (F.ConstructorKind === 'derived') {
        /* X */
        let _temp4 = yield* F.GetPrototypeOf();
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! yield* F.GetPrototypeOf() returned an abrupt completion", {
          cause: _temp4
        });
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        // 1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most
        //    notable distinction is that while the aforementioned ECMAScript source text observably calls
        //    the @@iterator method on `%Array.prototype%`, a Default Constructor Function does not.
        // 2. Let func be ! F.[[GetPrototypeOf]]().
        const func = _temp4;
        // 3. If IsConstructor(func) is false, throw a TypeError exception.
        if (!IsConstructor(func)) {
          return surroundingAgent.Throw('TypeError', 'NotAConstructor', func);
        }
        // 4. Let result be ? Construct(func, args, NewTarget).
        /* ReturnIfAbrupt */
        let _temp5 = yield* Construct(func, args, NewTarget);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) return _temp5;
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        result = _temp5;
      } else {
        /* ReturnIfAbrupt */
        let _temp6 = yield* OrdinaryCreateFromConstructor(NewTarget, '%Object.prototype%');
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        // v. Else,
        // 1. NOTE: This branch behaves similarly to `constructor() {}`.
        // 2. Let result be ? OrdinaryCreateFromConstructor(NewTarget, "%Object.prototype%").
        result = _temp6;
      }
      /* ReturnIfAbrupt */
      let _temp7 = yield* InitializeInstanceElements(result, F);
      /* node:coverage ignore next */
      if (_temp7 instanceof AbruptCompletion) return _temp7;
      /* node:coverage ignore next */
      if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
      return result;
    };
    // b. ! CreateBuiltinFunction(defaultConstructor, 0, className, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, constructorParent).
    /* X */
    let _temp8 = CreateBuiltinFunction(defaultConstructor, 0, className, ['ConstructorKind', 'SourceText'], undefined, constructorParent, undefined, Value.true);
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(defaultConstructor, 0, className, ['ConstructorKind', 'SourceText'], undefined, constructorParent, undefined, Value.true) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    F = _temp8;
  } else {
    /* X */
    let _temp9 = yield* DefineMethod(constructor, proto, constructorParent);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! yield* DefineMethod(constructor, proto, constructorParent) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    // 15. Else,
    // a. Let constructorInfo be ! DefineMethod of constructor with arguments proto and constructorParent.
    const constructorInfo = _temp9;
    // b. Let F be constructorInfo.[[Closure]].
    F = constructorInfo.Closure;
    // c. Perform MakeClassConstructor(F).
    MakeClassConstructor(F);
    // d. Perform SetFunctionName(F, className).
    SetFunctionName(F, className);
  }
  // 16. Perform MakeConstructor(F, false, proto).
  MakeConstructor(F, Value.false, proto);
  // 17. If ClassHeritage is present, set F.[[ConstructorKind]] to derived.
  if (ClassHeritage) {
    F.ConstructorKind = 'derived';
  }
  // 18. Perform CreateMethodProperty(proto, "constructor", F).
  /* X */
  let _temp10 = CreateMethodProperty(proto, Value('constructor'), F);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! CreateMethodProperty(proto, Value('constructor'), F) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  // 19. If ClassBody is not present, let elements be a new empty List.
  let elements;
  if (!ClassBody) {
    elements = [];
  } else {
    // 20. Else, let elements be NonConstructorElements of ClassBody.
    elements = NonConstructorElements(ClassBody);
  }
  // 21. Let instancePrivateMethods be a new empty List.
  const instancePrivateMethods = [];
  // 22. Let staticPrivateMethods be a new empty List.
  const staticPrivateMethods = [];
  // 23. Let instanceFields be a new empty List.
  const instanceFields = [];
  // 24. Let staticElements be a new empty List.
  const staticElements = [];
  // 25. For each ClassElement e of elements, do
  for (const e of elements) {
    let field;
    // a. If IsStatic of e is false, then
    if (IsStatic(e) === false) {
      // i. Let field be ClassElementEvaluation of e with arguments proto and false.
      field = yield* ClassElementEvaluation(e, proto, Value.false);
    } else {
      // b. Else,
      // i. Let field be ClassElementEvaluation of e with arguments F and false.
      field = yield* ClassElementEvaluation(e, F, Value.false);
    }
    // c. If field is an abrupt completion, then
    if (field instanceof AbruptCompletion) {
      // i. Set the running execution context's LexicalEnvironment to env.
      surroundingAgent.runningExecutionContext.LexicalEnvironment = env;
      // ii. Set the running execution context's PrivateEnvironment to outerPrivateEnvironment.
      surroundingAgent.runningExecutionContext.PrivateEnvironment = outerPrivateEnvironment;
      // iii. Return Completion(field).
      return field;
    }
    // d. Set field to field.[[Value]].
    /* ReturnIfAbrupt */
    /* node:coverage ignore next */
    if (field && typeof field === 'object' && 'next' in field) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (field instanceof AbruptCompletion) return field;
    /* node:coverage ignore next */
    if (field instanceof Completion) field = field.Value;
    // e. If field is a PrivateElement, then
    if (field instanceof PrivateElementRecord) {
      // i. Assert: field.[[Kind]] is either method or accessor.
      Assert(field.Kind === 'method' || field.Kind === 'accessor', "field.Kind === 'method' || field.Kind === 'accessor'");
      // ii. If IsStatic of e is false, let container be instancePrivateMethods.
      let container;
      if (IsStatic(e) === false) {
        container = instancePrivateMethods;
      } else {
        // iii. Else, let container be staticPrivateMethods.
        container = staticPrivateMethods;
      }
      // iv. If container contains a PrivateElement whose [[Key]] is field.[[Key]], then
      const index = container.findIndex(el => el.Key === field.Key);
      if (index >= 0) {
        // 1. Let existing be that PrivateElement.
        const existing = container[index];
        // 2. Assert: field.[[Kind]] and existing.[[Kind]] are both accessor.
        Assert(field.Kind === 'accessor' && existing.Kind === 'accessor', "field.Kind === 'accessor' && existing.Kind === 'accessor'");
        // 3. If field.[[Get]] is undefined, then
        let combined;
        if (field.Get === Value.undefined) {
          combined = new PrivateElementRecord({
            Key: field.Key,
            Kind: 'accessor',
            Get: existing.Get,
            Set: field.Set
          });
        } else {
          // 4. Else
          combined = new PrivateElementRecord({
            Key: field.Key,
            Kind: 'accessor',
            Get: field.Get,
            Set: existing.Set
          });
        }
        // 5. Replace existing in container with combined.
        container[index] = combined;
      } else {
        // v. Else,
        // 1. Append field to container.
        container.push(field);
      }
    } else if (field instanceof ClassFieldDefinitionRecord) {
      // f. Else if field is a ClassFieldDefinition Record, then
      // i. If IsStatic of e is false, append field to instanceFields.
      if (IsStatic(e) === false) {
        instanceFields.push(field);
      } else {
        // ii. Else, append field to staticElements.
        staticElements.push(field);
      }
    } else if (field instanceof ClassStaticBlockDefinitionRecord) {
      // g. Else if element is a ClassStaticBlockDefinition Record, then
      // i. Append element to staticElements.
      staticElements.push(field);
    }
  }
  // 26. Set the running execution context's LexicalEnvironment to env.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = env;
  // 27. If classBinding is not undefined, then
  if (!(classBinding instanceof UndefinedValue)) {
    // a. Perform classScope.InitializeBinding(classBinding, F).
    yield* classScope.InitializeBinding(classBinding, F);
  }
  // 28. Set F.[[PrivateMethods]] to instancePrivateMethods.
  F.PrivateMethods = instancePrivateMethods;
  // 29. Set F.[[Fields]] to instanceFields.
  F.Fields = instanceFields;
  // 30. For each PrivateElement method of staticPrivateMethods, do
  for (const method of staticPrivateMethods) {
    /* X */
    let _temp11 = PrivateMethodOrAccessorAdd(method, F);
    /* node:coverage ignore next */
    if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! PrivateMethodOrAccessorAdd(method, F) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  }
  // 31. For each element elementRecord of staticElements, do
  for (const elementRecord of staticElements) {
    let result;
    // a. If elementRecord is a ClassFieldDefinition Record, then
    if (elementRecord instanceof ClassFieldDefinitionRecord) {
      // a. Let result be DefineField(F, elementRecord).
      result = yield* DefineField(F, elementRecord);
    } else {
      // b. Else,
      // i. Assert: elementRecord is a ClassStaticBlockDefinition Record.
      Assert(elementRecord instanceof ClassStaticBlockDefinitionRecord, "elementRecord instanceof ClassStaticBlockDefinitionRecord");
      // ii. Let result be Completion(Call(elementRecord.[[BodyFunction]], F)).
      result = yield* Call(elementRecord.BodyFunction, F);
    }
    // c. If result is an abrupt completion, then
    if (result instanceof AbruptCompletion) {
      // i. Set the running execution context's PrivateEnvironment to outerPrivateEnvironment.
      surroundingAgent.runningExecutionContext.PrivateEnvironment = outerPrivateEnvironment;
      // ii. Return result.
      return result;
    }
  }
  // 32. Set the running execution context's PrivateEnvironment to outerPrivateEnvironment.
  surroundingAgent.runningExecutionContext.PrivateEnvironment = outerPrivateEnvironment;
  // 33. Return F.
  return F;
}

/** https://tc39.es/ecma262/#sec-runtime-semantics-definemethod */
function* DefineMethod(MethodDefinition, object, functionPrototype) {
  const {
    ClassElementName,
    UniqueFormalParameters,
    FunctionBody
  } = MethodDefinition;
  // 1. Let propKey be the result of evaluating ClassElementName.
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate_PropertyName(ClassElementName);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const propKey = _temp;
  // 2. ReturnIfAbrupt(propKey).
  // 3. Let scope be the running execution context's LexicalEnvironment.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 4. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  let prototype;
  // 5. If functionPrototype is present as a parameter, then
  if (functionPrototype !== undefined) {
    // a. Let prototype be functionPrototype.
    prototype = functionPrototype;
  } else {
    // 6. Else,
    // a. Let prototype be %Function.prototype%.
    prototype = surroundingAgent.intrinsic('%Function.prototype%');
  }
  // 7. Let sourceText be the source text matched by MethodDefinition.
  const sourceText = sourceTextMatchedBy(MethodDefinition);
  // 8. Let closure be OrdinaryFunctionCreate(prototype, sourceText, UniqueFormalParameters, FunctionBody, non-lexical-this, scope, privateScope).
  const closure = OrdinaryFunctionCreate(prototype, sourceText, UniqueFormalParameters, FunctionBody, 'non-lexical-this', scope, privateScope);
  // 9. Perform MakeMethod(closure, object).
  MakeMethod(closure, object);
  // 10. Return the Record { [[Key]]: propKey, [[Closure]]: closure }.
  return {
    Key: propKey,
    Closure: closure
  };
}
DefineMethod.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-definemethod';

/** https://tc39.es/ecma262/#sec-object-initializer-runtime-semantics-evaluation */
// PropertyName :
//   LiteralPropertyName
//   ComputedPropertyName
// LiteralPropertyName :
//   IdentifierName
//   StringLiteral
//   NumericLiteral
// ComputedPropertyName :
//   `[` AssignmentExpression `]`
function* Evaluate_PropertyName(PropertyName) {
  switch (PropertyName.type) {
    case 'IdentifierName':
      return StringValue(PropertyName);
    case 'StringLiteral':
      return Value(PropertyName.value);
    case 'NumericLiteral':
      {
        // 1. Let nbr be the NumericValue of NumericLiteral.
        const nbr = NumericValue(PropertyName);
        // 2. Return ! ToString(nbr).
        /* X */
        let _temp = ToString(nbr);
        /* node:coverage ignore next */
        if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
        /* node:coverage ignore next */
        if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ToString(nbr) returned an abrupt completion", {
          cause: _temp
        });
        /* node:coverage ignore next */
        if (_temp instanceof Completion) _temp = _temp.Value;
        return _temp;
      }
    case 'PrivateIdentifier':
      {
        // 1. Let privateIdentifier be StringValue of PrivateIdentifier.
        const privateIdentifier = StringValue(PropertyName);
        // 2. Let privateEnvRec be the running execution context's PrivateEnvironment.
        const privateEnvRec = surroundingAgent.runningExecutionContext.PrivateEnvironment;
        // 3. Let names be privateEnvRec.[[Names]].
        const names = privateEnvRec.Names;
        // 4. Assert: Exactly one element of names is a Private Name whose [[Description]] is privateIdentifier.
        // 5. Let privateName be the Private Name in names whose [[Description]] is privateIdentifier.
        const privateName = names.find(n => n.Description.stringValue() === privateIdentifier.stringValue());
        Assert(!!privateName, "!!privateName");
        // 6. Return privateName.
        return privateName;
      }
    default:
      {
        /* ReturnIfAbrupt */
        let _temp2 = yield* Evaluate(PropertyName.ComputedPropertyName);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        // 1. Let exprValue be the result of evaluating AssignmentExpression.
        const exprValue = _temp2;
        // 2. Let propName be ? GetValue(exprValue).
        /* ReturnIfAbrupt */
        let _temp3 = yield* GetValue(exprValue);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) return _temp3;
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        const propName = _temp3;
        // 3. Return ? ToPropertyKey(propName).
        return yield* ToPropertyKey(propName);
      }
  }
}
Evaluate_PropertyName.section = 'https://tc39.es/ecma262/#sec-object-initializer-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-addition-operator-plus-runtime-semantics-evaluation */
//   AdditiveExpression : AdditiveExpression + MultiplicativeExpression
function* Evaluate_AdditiveExpression_Plus({
  AdditiveExpression,
  MultiplicativeExpression
}) {
  // 1. Return ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +, MultiplicativeExpression).
  return yield* EvaluateStringOrNumericBinaryExpression(AdditiveExpression, '+', MultiplicativeExpression);
}
Evaluate_AdditiveExpression_Plus.section = 'https://tc39.es/ecma262/#sec-addition-operator-plus-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-subtraction-operator-minus-runtime-semantics-evaluation */
function* Evaluate_AdditiveExpression_Minus({
  AdditiveExpression,
  MultiplicativeExpression
}) {
  // 1. Return ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, -, MultiplicativeExpression).
  return yield* EvaluateStringOrNumericBinaryExpression(AdditiveExpression, '-', MultiplicativeExpression);
}
Evaluate_AdditiveExpression_Minus.section = 'https://tc39.es/ecma262/#sec-subtraction-operator-minus-runtime-semantics-evaluation';
function* Evaluate_AdditiveExpression(AdditiveExpression) {
  switch (AdditiveExpression.operator) {
    case '+':
      return yield* Evaluate_AdditiveExpression_Plus(AdditiveExpression);
    case '-':
      return yield* Evaluate_AdditiveExpression_Minus(AdditiveExpression);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_AdditiveExpression', AdditiveExpression);
  }
}

/** https://tc39.es/ecma262/#sec-destructuring-assignment */
function refineLeftHandSideExpression(node, type) {
  switch (node.type) {
    case 'ArrayLiteral':
      {
        const refinement = {
          type: 'ArrayAssignmentPattern',
          AssignmentElementList: [],
          AssignmentRestElement: undefined
        };
        node.ElementList.forEach(n => {
          switch (n.type) {
            case 'SpreadElement':
              refinement.AssignmentRestElement = {
                ...n,
                type: 'AssignmentRestElement',
                AssignmentExpression: n.AssignmentExpression
              };
              break;
            case 'ArrayLiteral':
            case 'ObjectLiteral':
              refinement.AssignmentElementList.push({
                type: 'AssignmentElement',
                DestructuringAssignmentTarget: n,
                Initializer: null
              });
              break;
            default:
              refinement.AssignmentElementList.push(refineLeftHandSideExpression(n, 'array'));
              break;
          }
        });
        return refinement;
      }
    case 'ObjectLiteral':
      {
        const refined = {
          type: 'ObjectAssignmentPattern',
          AssignmentPropertyList: [],
          AssignmentRestProperty: undefined
        };
        node.PropertyDefinitionList.forEach(p => {
          if (p.PropertyName === null && p.AssignmentExpression) {
            refined.AssignmentRestProperty = {
              type: 'AssignmentRestProperty',
              DestructuringAssignmentTarget: p.AssignmentExpression
            };
          } else {
            refined.AssignmentPropertyList.push(refineLeftHandSideExpression(p, 'object'));
          }
        });
        return refined;
      }
    case 'PropertyDefinition':
      return {
        type: 'AssignmentProperty',
        PropertyName: node.PropertyName,
        AssignmentElement: node.AssignmentExpression.type === 'AssignmentExpression' ? {
          type: 'AssignmentElement',
          DestructuringAssignmentTarget: node.AssignmentExpression.LeftHandSideExpression,
          Initializer: node.AssignmentExpression.AssignmentExpression
        } : {
          type: 'AssignmentElement',
          DestructuringAssignmentTarget: node.AssignmentExpression,
          Initializer: undefined
        }
      };
    case 'IdentifierReference':
      if (type === 'array') {
        return {
          type: 'AssignmentElement',
          DestructuringAssignmentTarget: node,
          Initializer: undefined
        };
      } else {
        return {
          type: 'AssignmentProperty',
          IdentifierReference: node,
          Initializer: undefined
        };
      }
    case 'MemberExpression':
      return {
        type: 'AssignmentElement',
        DestructuringAssignmentTarget: node,
        Initializer: undefined
      };
    case 'CoverInitializedName':
      return {
        type: 'AssignmentProperty',
        IdentifierReference: node.IdentifierReference,
        Initializer: node.Initializer
      };
    case 'AssignmentExpression':
      return {
        type: 'AssignmentElement',
        DestructuringAssignmentTarget: node.LeftHandSideExpression,
        Initializer: node.AssignmentExpression
      };
    case 'Elision':
      return node;
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('refineLeftHandSideExpression', node.type);
  }
}
refineLeftHandSideExpression.section = 'https://tc39.es/ecma262/#sec-destructuring-assignment';
/** https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation */
//   AssignmentExpression :
//     LeftHandSideExpression `=` AssignmentExpression
//     LeftHandSideExpression AssignmentOperator AssignmentExpression
//     LeftHandSideExpression `&&=` AssignmentExpression
//     LeftHandSideExpression `||=` AssignmentExpression
//     LeftHandSideExpression `??=` AssignmentExpression
function* Evaluate_AssignmentExpression({
  LeftHandSideExpression,
  AssignmentOperator,
  AssignmentExpression
}) {
  if (AssignmentOperator === '=') {
    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    if (LeftHandSideExpression.type !== 'ObjectLiteral' && LeftHandSideExpression.type !== 'ArrayLiteral') {
      /* ReturnIfAbrupt */
      let _temp = yield* Evaluate(LeftHandSideExpression);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) return _temp;
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      // a. Let lref be the result of evaluating LeftHandSideExpression.
      let lref = _temp;
      // b. ReturnIfAbrupt(lref).
      /* ReturnIfAbrupt */
      /* node:coverage ignore next */
      if (lref && typeof lref === 'object' && 'next' in lref) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (lref instanceof AbruptCompletion) return lref;
      /* node:coverage ignore next */
      if (lref instanceof Completion) lref = lref.Value;
      // c. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then
      let rval;
      if (IsAnonymousFunctionDefinition(AssignmentExpression) && IsIdentifierRef(LeftHandSideExpression)) {
        /* ReturnIfAbrupt */
        let _temp2 = yield* NamedEvaluation(AssignmentExpression, lref.ReferencedName);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        // i. Let rval be NamedEvaluation of AssignmentExpression with argument GetReferencedName(lref).
        rval = _temp2;
      } else {
        /* ReturnIfAbrupt */
        let _temp3 = yield* Evaluate(AssignmentExpression);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) return _temp3;
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        // d. Else,
        // i. Let rref be the result of evaluating AssignmentExpression.
        const rref = _temp3;
        // ii. Let rval be ? GetValue(rref).
        /* ReturnIfAbrupt */
        let _temp4 = yield* GetValue(rref);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        rval = _temp4;
      }
      // e. Perform ? PutValue(lref, rval).
      /* ReturnIfAbrupt */
      let _temp5 = yield* PutValue(lref, rval);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) return _temp5;
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      // f. Return rval.
      return rval;
    }
    // 2. Let assignmentPattern be the AssignmentPattern that is covered by LeftHandSideExpression.
    const assignmentPattern = refineLeftHandSideExpression(LeftHandSideExpression);
    // 3. Let rref be the result of evaluating AssignmentExpression.
    /* ReturnIfAbrupt */
    let _temp6 = yield* Evaluate(AssignmentExpression);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    const rref = _temp6;
    // 3. Let rval be ? GetValue(rref).
    /* ReturnIfAbrupt */
    let _temp7 = yield* GetValue(rref);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const rval = _temp7;
    // 4. Perform ? DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.
    /* ReturnIfAbrupt */
    let _temp8 = yield* DestructuringAssignmentEvaluation(assignmentPattern, rval);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    // 5. Return rval.
    return rval;
  } else if (AssignmentOperator === '&&=') {
    /* ReturnIfAbrupt */
    let _temp9 = yield* Evaluate(LeftHandSideExpression);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    // 1. Let lref be the result of evaluating LeftHandSideExpression.
    const lref = _temp9;
    // 2. Let lval be ? GetValue(lref).
    /* ReturnIfAbrupt */
    let _temp10 = yield* GetValue(lref);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) return _temp10;
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    const lval = _temp10;
    // 3. Let lbool be ! ToBoolean(lval).
    /* X */
    let _temp11 = ToBoolean(lval);
    /* node:coverage ignore next */
    if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(lval) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    const lbool = _temp11;
    // 4. If lbool is false, return lval.
    if (lbool === Value.false) {
      return lval;
    }
    let rval;
    // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    if (IsAnonymousFunctionDefinition(AssignmentExpression) && IsIdentifierRef(LeftHandSideExpression)) {
      /* ReturnIfAbrupt */
      let _temp12 = yield* NamedEvaluation(AssignmentExpression, lref.ReferencedName);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      // a. Let rval be NamedEvaluation of AssignmentExpression with argument GetReferencedName(lref).
      rval = _temp12;
    } else {
      /* ReturnIfAbrupt */
      let _temp13 = yield* Evaluate(AssignmentExpression);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      // 6. Else,
      // a. Let rref be the result of evaluating AssignmentExpression.
      const rref = _temp13;
      // b. Let rval be ? GetValue(rref).
      /* ReturnIfAbrupt */
      let _temp14 = yield* GetValue(rref);
      /* node:coverage ignore next */
      if (_temp14 instanceof AbruptCompletion) return _temp14;
      /* node:coverage ignore next */
      if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
      rval = _temp14;
    }
    // 7. Perform ? PutValue(lref, rval).
    /* ReturnIfAbrupt */
    let _temp15 = yield* PutValue(lref, rval);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) return _temp15;
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    // 8. Return rval.
    return rval;
  } else if (AssignmentOperator === '||=') {
    /* ReturnIfAbrupt */
    let _temp16 = yield* Evaluate(LeftHandSideExpression);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) return _temp16;
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    // 1. Let lref be the result of evaluating LeftHandSideExpression.
    const lref = _temp16;
    // 2. Let lval be ? GetValue(lref).
    /* ReturnIfAbrupt */
    let _temp17 = yield* GetValue(lref);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    const lval = _temp17;
    // 3. Let lbool be ! ToBoolean(lval).
    /* X */
    let _temp18 = ToBoolean(lval);
    /* node:coverage ignore next */
    if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(lval) returned an abrupt completion", {
      cause: _temp18
    });
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    const lbool = _temp18;
    // 4. If lbool is true, return lval.
    if (lbool === Value.true) {
      return lval;
    }
    let rval;
    // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    if (IsAnonymousFunctionDefinition(AssignmentExpression) && IsIdentifierRef(LeftHandSideExpression)) {
      /* ReturnIfAbrupt */
      let _temp19 = yield* NamedEvaluation(AssignmentExpression, lref.ReferencedName);
      /* node:coverage ignore next */
      if (_temp19 instanceof AbruptCompletion) return _temp19;
      /* node:coverage ignore next */
      if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
      // a. Let rval be NamedEvaluation of AssignmentExpression with argument GetReferencedName(lref).
      rval = _temp19;
    } else {
      /* ReturnIfAbrupt */
      let _temp20 = yield* Evaluate(AssignmentExpression);
      /* node:coverage ignore next */
      if (_temp20 instanceof AbruptCompletion) return _temp20;
      /* node:coverage ignore next */
      if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
      // 6. Else,
      // a. Let rref be the result of evaluating AssignmentExpression.
      const rref = _temp20;
      // b. Let rval be ? GetValue(rref).
      /* ReturnIfAbrupt */
      let _temp21 = yield* GetValue(rref);
      /* node:coverage ignore next */
      if (_temp21 instanceof AbruptCompletion) return _temp21;
      /* node:coverage ignore next */
      if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
      rval = _temp21;
    }
    // 7. Perform ? PutValue(lref, rval).
    /* ReturnIfAbrupt */
    let _temp22 = yield* PutValue(lref, rval);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    // 8. Return rval.
    return rval;
  } else if (AssignmentOperator === '??=') {
    /* ReturnIfAbrupt */
    let _temp23 = yield* Evaluate(LeftHandSideExpression);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    // 1.Let lref be the result of evaluating LeftHandSideExpression.
    const lref = _temp23;
    // 2. Let lval be ? GetValue(lref).
    /* ReturnIfAbrupt */
    let _temp24 = yield* GetValue(lref);
    /* node:coverage ignore next */
    if (_temp24 instanceof AbruptCompletion) return _temp24;
    /* node:coverage ignore next */
    if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
    const lval = _temp24;
    // 3. If lval is not undefined nor null, return lval.
    if (lval !== Value.undefined && lval !== Value.null) {
      return lval;
    }
    let rval;
    // 4. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    if (IsAnonymousFunctionDefinition(AssignmentExpression) && IsIdentifierRef(LeftHandSideExpression)) {
      /* ReturnIfAbrupt */
      let _temp25 = yield* NamedEvaluation(AssignmentExpression, lref.ReferencedName);
      /* node:coverage ignore next */
      if (_temp25 instanceof AbruptCompletion) return _temp25;
      /* node:coverage ignore next */
      if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
      // a. Let rval be NamedEvaluation of AssignmentExpression with argument GetReferencedName(lref).
      rval = _temp25;
    } else {
      /* ReturnIfAbrupt */
      let _temp26 = yield* Evaluate(AssignmentExpression);
      /* node:coverage ignore next */
      if (_temp26 instanceof AbruptCompletion) return _temp26;
      /* node:coverage ignore next */
      if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
      // 5. Else,
      // a. Let rref be the result of evaluating AssignmentExpression.
      const rref = _temp26;
      // b. Let rval be ? GetValue(rref).
      /* ReturnIfAbrupt */
      let _temp27 = yield* GetValue(rref);
      /* node:coverage ignore next */
      if (_temp27 instanceof AbruptCompletion) return _temp27;
      /* node:coverage ignore next */
      if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
      rval = _temp27;
    }
    // 6. Perform ? PutValue(lref, rval).
    /* ReturnIfAbrupt */
    let _temp28 = yield* PutValue(lref, rval);
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) return _temp28;
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    // 7. Return rval.
    return rval;
  } else {
    /* ReturnIfAbrupt */
    let _temp29 = yield* Evaluate(LeftHandSideExpression);
    /* node:coverage ignore next */
    if (_temp29 instanceof AbruptCompletion) return _temp29;
    /* node:coverage ignore next */
    if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
    // 1. Let lref be the result of evaluating LeftHandSideExpression.
    const lref = _temp29;
    // 2. Let lval be ? GetValue(lref).
    /* ReturnIfAbrupt */
    let _temp30 = yield* GetValue(lref);
    /* node:coverage ignore next */
    if (_temp30 instanceof AbruptCompletion) return _temp30;
    /* node:coverage ignore next */
    if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
    const lval = _temp30;
    // 3. Let rref be the result of evaluating AssignmentExpression.
    /* ReturnIfAbrupt */
    let _temp31 = yield* Evaluate(AssignmentExpression);
    /* node:coverage ignore next */
    if (_temp31 instanceof AbruptCompletion) return _temp31;
    /* node:coverage ignore next */
    if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
    const rref = _temp31;
    // 4. Let rval be ? GetValue(rref).
    /* ReturnIfAbrupt */
    let _temp32 = yield* GetValue(rref);
    /* node:coverage ignore next */
    if (_temp32 instanceof AbruptCompletion) return _temp32;
    /* node:coverage ignore next */
    if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
    const rval = _temp32;
    // 5. Let assignmentOpText be the source text matched by AssignmentOperator.
    const assignmentOpText = AssignmentOperator;
    // 6. Let opText be the sequence of Unicode code points associated with assignmentOpText in the following table:
    const opText = {
      '**=': '**',
      '*=': '*',
      '/=': '/',
      '%=': '%',
      '+=': '+',
      '-=': '-',
      '<<=': '<<',
      '>>=': '>>',
      '>>>=': '>>>',
      '&=': '&',
      '^=': '^',
      '|=': '|'
    }[assignmentOpText];
    // 7. Let r be ApplyStringOrNumericBinaryOperator(lval, opText, rval).
    /* ReturnIfAbrupt */
    let _temp33 = yield* ApplyStringOrNumericBinaryOperator(lval, opText, rval);
    /* node:coverage ignore next */
    if (_temp33 instanceof AbruptCompletion) return _temp33;
    /* node:coverage ignore next */
    if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
    const r = _temp33;
    // 8. Perform ? PutValue(lref, r).
    /* ReturnIfAbrupt */
    let _temp34 = yield* PutValue(lref, r);
    /* node:coverage ignore next */
    if (_temp34 instanceof AbruptCompletion) return _temp34;
    /* node:coverage ignore next */
    if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
    // 9. Return r.
    return r;
  }
}
Evaluate_AssignmentExpression.section = 'https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-binary-bitwise-operators-runtime-semantics-evaluation */
//   BitwiseANDExpression : BitwiseANDExpression `&` EqualityExpression
//   BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression
//   BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression
// The production A : A @ B, where @ is one of the bitwise operators in the
// productions above, is evaluated as follows:
function* Evaluate_BinaryBitwiseExpression({
  A,
  operator,
  B
}) {
  return yield* EvaluateStringOrNumericBinaryExpression(A, operator, B);
}
Evaluate_BinaryBitwiseExpression.section = 'https://tc39.es/ecma262/#sec-binary-bitwise-operators-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-binary-logical-operators-runtime-semantics-evaluation */
//   CoalesceExpression :
//     CoalesceExpressionHead `??` BitwiseORExpression
function* Evaluate_CoalesceExpression({
  CoalesceExpressionHead,
  BitwiseORExpression
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(CoalesceExpressionHead);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let lref be the result of evaluating |CoalesceExpressionHead|.
  const lref = _temp;
  // 2. Let lval be ? GetValue(lref).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(lref);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const lval = _temp2;
  // 3. If lval is *undefined* or *null*,
  if (lval === Value.undefined || lval === Value.null) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* Evaluate(BitwiseORExpression);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // a. Let rref be the result of evaluating |BitwiseORExpression|.
    const rref = _temp3;
    // b. Return ? GetValue(rref).
    return yield* GetValue(rref);
  }
  // 4. Otherwise, return lval.
  return lval;
}
Evaluate_CoalesceExpression.section = 'https://tc39.es/ecma262/#sec-binary-logical-operators-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-empty-statement-runtime-semantics-evaluation */
//   EmptyStatement : `;`
function Evaluate_EmptyStatement(_EmptyStatement) {
  // 1. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
Evaluate_EmptyStatement.section = 'https://tc39.es/ecma262/#sec-empty-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-exp-operator-runtime-semantics-evaluation */
// ExponentiationExpression : UpdateExpression ** ExponentiationExpression
function* Evaluate_ExponentiationExpression({
  UpdateExpression,
  ExponentiationExpression
}) {
  // 1. Return ? EvaluateStringOrNumericBinaryExpression(UpdateExpression, **, ExponentiationExpression).
  return yield* EvaluateStringOrNumericBinaryExpression(UpdateExpression, '**', ExponentiationExpression);
}
Evaluate_ExponentiationExpression.section = 'https://tc39.es/ecma262/#sec-exp-operator-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-if-statement-runtime-semantics-evaluation */
// IfStatement :
//   `if` `(` Expression `)` Statement `else` Statement
//   `if` `(` Expression `)` Statement
function* Evaluate_IfStatement({
  Expression,
  Statement_a,
  Statement_b
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(Expression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let exprRef be the result of evaluating Expression.
  const exprRef = _temp;
  // 2. Let exprValue be ! ToBoolean(? GetValue(exprRef)).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(exprRef);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const exprValue = ToBoolean(_temp2);
  if (Statement_b) {
    let stmtCompletion;
    // 3. If exprValue is true, then
    if (exprValue === Value.true) {
      // a. Let stmtCompletion be the result of evaluating the first Statement.
      stmtCompletion = yield* Evaluate(Statement_a);
    } else {
      // 4. Else,
      // a. Let stmtCompletion be the result of evaluating the second Statement.
      stmtCompletion = yield* Evaluate(Statement_b);
    }
    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)).
    return Completion(UpdateEmpty(EnsureCompletion(stmtCompletion), Value.undefined));
  } else {
    // 3. If exprValue is false, then
    if (exprValue === Value.false) {
      // a. Return NormalCompletion(undefined).
      return NormalCompletion(Value.undefined);
    } else {
      // 4. Else,
      // a. Let stmtCompletion be the result of evaluating Statement.
      const stmtCompletion = yield* Evaluate(Statement_a);
      // b. Return Completion(UpdateEmpty(stmtCompletion, undefined)).
      return Completion(UpdateEmpty(EnsureCompletion(stmtCompletion), Value.undefined));
    }
  }
}
Evaluate_IfStatement.section = 'https://tc39.es/ecma262/#sec-if-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-import-calls */
// ImportCall : `import` `(` AssignmentExpression `)`
function* Evaluate_ImportCall(ImportCall) {
  /* ReturnIfAbrupt */
  let _temp = surroundingAgent.debugger_cannotPreview;
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  if (ImportCall.OptionsExpression) {
    return yield* EvaluateImportCall(ImportCall.AssignmentExpression, ImportCall.OptionsExpression);
  }
  return yield* EvaluateImportCall(ImportCall.AssignmentExpression);
}
Evaluate_ImportCall.section = 'https://tc39.es/ecma262/#sec-import-calls';
/** https://tc39.es/ecma262/#sec-evaluate-import-call */
function* EvaluateImportCall(specifiersExpression, optionsExpression) {
  /* X */
  let _temp2 = GetActiveScriptOrModule();
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! GetActiveScriptOrModule() returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Let referrer be ! GetActiveScriptOrModule().
  let referrer = _temp2;
  // 2. If referrer is null, set referrer to the current Realm Record.
  if (referrer instanceof NullValue) {
    referrer = surroundingAgent.currentRealmRecord;
  }
  // 3. Let specifierRef be ? Evaluation of AssignmentExpression.
  /* ReturnIfAbrupt */
  let _temp3 = yield* Evaluate(specifiersExpression);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const specifierRef = _temp3;
  // 4. Let specifier be ? GetValue(specifierRef).
  /* ReturnIfAbrupt */
  let _temp4 = yield* GetValue(specifierRef);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const specifier = _temp4;
  let options;
  // 5. If optionsExpression is present, then
  if (optionsExpression) {
    /* ReturnIfAbrupt */
    let _temp5 = yield* Evaluate(optionsExpression);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // a. Let optionsRef be ? Evaluation of optionsExpression.
    const optionsRef = _temp5;
    // b. Let options be ? GetValue(optionsRef).
    /* ReturnIfAbrupt */
    let _temp6 = yield* GetValue(optionsRef);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    options = _temp6;
  } else {
    // 6. Else,
    // a. Let options be undefined.
    options = Value.undefined;
  }
  // 7. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  /* X */
  let _temp7 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const promiseCapability = _temp7;
  // 8. Let specifierString be ToString(specifier).
  let specifierString = yield* ToString(specifier);
  // 9. IfAbruptRejectPromise(specifierString, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (specifierString instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [specifierString.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (specifierString instanceof Completion) specifierString = specifierString.Value;
  // 10. Let attributes nw a new empty List.
  const attributes = [];
  // 11. If options is not undefined, then
  if (options !== Value.undefined) {
    // a. If options is not an Object, then
    if (!(options instanceof ObjectValue)) {
      /* X */
      let _temp8 = Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'NotAnObject', options).Value]);
      /* node:coverage ignore next */
      if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [\n        surroundingAgent.Throw('TypeError', 'NotAnObject', options).Value,\n      ]) returned an abrupt completion", {
        cause: _temp8
      });
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
      // ii. Return promiseCapability.[[Promise]].
      return promiseCapability.Promise;
    }
    // b. Let attributesObj be Completion(Get(options, "with")).
    let attributesObj = yield* Get(options, Value('with'));
    // c. IfAbruptRejectPromise(attributesObj, promiseCapability).
    /* IfAbruptRejectPromise */
    /* node:coverage disable */
    if (attributesObj instanceof AbruptCompletion) {
      const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [attributesObj.Value]));
      if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
      return promiseCapability.Promise;
    }
    if (attributesObj instanceof Completion) attributesObj = attributesObj.Value;
    // d. If attributesObj is not undefined, then
    if (attributesObj !== Value.undefined) {
      // i. If attributesObj is not an Object, then
      if (!(attributesObj instanceof ObjectValue)) {
        /* X */
        let _temp9 = Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'NotAnObject', attributesObj).Value]);
        /* node:coverage ignore next */
        if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
        /* node:coverage ignore next */
        if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [\n          surroundingAgent.Throw('TypeError', 'NotAnObject', attributesObj).Value,\n        ]) returned an abrupt completion", {
          cause: _temp9
        });
        /* node:coverage ignore next */
        if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
        // 2. Return promiseCapability.[[Promise]].
        return promiseCapability.Promise;
      }
      // ii. Let entries be Completion(EnumerableOwnProperties(attributesObj, key+value)).
      let entries = yield* EnumerableOwnPropertyNames(attributesObj, 'key+value');
      // iii. IfAbruptRejectPromise(entries, promiseCapability).
      /* IfAbruptRejectPromise */
      /* node:coverage disable */
      if (entries instanceof AbruptCompletion) {
        const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [entries.Value]));
        if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
        return promiseCapability.Promise;
      }
      if (entries instanceof Completion) entries = entries.Value;
      // iv. For each element entry of entries, do
      for (const entry of entries) {
        /* ReturnIfAbrupt */
        let _temp10 = yield* Get(entry, Value('0'));
        /* node:coverage ignore next */
        if (_temp10 instanceof AbruptCompletion) return _temp10;
        /* node:coverage ignore next */
        if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
        // 1. Let key be ! Get(entry, "0").
        const key = _temp10;
        // 2. Let value be ! Get(entry, "1").
        /* ReturnIfAbrupt */
        let _temp11 = yield* Get(entry, Value('1'));
        /* node:coverage ignore next */
        if (_temp11 instanceof AbruptCompletion) return _temp11;
        /* node:coverage ignore next */
        if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
        const value = _temp11;
        // 3. If key is a String, then
        if (key instanceof JSStringValue) {
          // a. If value is not a String, then
          if (!(value instanceof JSStringValue)) {
            /* X */
            let _temp12 = Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'NotAString', value).Value]);
            /* node:coverage ignore next */
            if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
            /* node:coverage ignore next */
            if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [\n              surroundingAgent.Throw('TypeError', 'NotAString', value).Value,\n            ]) returned an abrupt completion", {
              cause: _temp12
            });
            /* node:coverage ignore next */
            if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
            // ii. Return promiseCapability.[[Promise]].
            return promiseCapability.Promise;
          }
          // b. Append the ImportAttribute Record { [[Key]]: key, [[Value]]: value } to attributes.
          attributes.push({
            Key: key,
            Value: value
          });
        }
      }
      // e. If AllImportAttributesSupported(attributes) is false, then
      const unsupportedAttributeKey = AllImportAttributesSupported(attributes);
      if (unsupportedAttributeKey) {
        /* X */
        let _temp13 = Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'UnsupportedImportAttribute', unsupportedAttributeKey).Value]);
        /* node:coverage ignore next */
        if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
        /* node:coverage ignore next */
        if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [\n          surroundingAgent.Throw('TypeError', 'UnsupportedImportAttribute', unsupportedAttributeKey).Value,\n        ]) returned an abrupt completion", {
          cause: _temp13
        });
        /* node:coverage ignore next */
        if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
        // ii. Return promiseCapability.[[Promise]].
        return promiseCapability.Promise;
      }
      // f. Sort attributes according to the lexicographic order of their [[Key]] field, treating the value of each such field as a sequence of UTF-16 code unit values.
      attributes.sort((a, b) => a.Key.value < b.Key.value ? -1 : 1);
    }
  }
  // 12. Let moduleRequest be a new ModuleRequest Record { [[Specifier]]: specifierString, [[Attributes]]: attributes }.
  const moduleRequest = {
    Specifier: specifierString,
    Attributes: attributes
  };
  // 10. Perform HostLoadImportedModule(referrer, specifierString, ~empty~, promiseCapability).
  HostLoadImportedModule(referrer, moduleRequest, undefined, promiseCapability);
  // 9. Return promiseCapability.[[Promise]].
  return promiseCapability.Promise;
}
EvaluateImportCall.section = 'https://tc39.es/ecma262/#sec-evaluate-import-call';

/** https://tc39.es/ecma262/#sec-multiplicative-operators-runtime-semantics-evaluation */
//   MultiplicativeExpression :
//     MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
function* Evaluate_MultiplicativeExpression({
  MultiplicativeExpression,
  MultiplicativeOperator,
  ExponentiationExpression
}) {
  // 1. Let opText be the source text matched by MultiplicativeOperator.
  const opText = MultiplicativeOperator;
  // 2. Return ? EvaluateStringOrNumericBinaryExpression(MultiplicativeExpression, opText, ExponentiationExpression).
  return yield* EvaluateStringOrNumericBinaryExpression(MultiplicativeExpression, opText, ExponentiationExpression);
}
Evaluate_MultiplicativeExpression.section = 'https://tc39.es/ecma262/#sec-multiplicative-operators-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-throw-statement-runtime-semantics-evaluation */
// ThrowStatement : `throw` Expression `;`
function* Evaluate_ThrowStatement({
  Expression
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(Expression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let exprRef be the result of evaluating Expression.
  const exprRef = _temp;
  // 2. Let exprValue be ? GetValue(exprRef).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(exprRef);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const exprValue = _temp2;
  // 3. Return ThrowCompletion(exprValue).
  return ThrowCompletion(exprValue);
}
Evaluate_ThrowStatement.section = 'https://tc39.es/ecma262/#sec-throw-statement-runtime-semantics-evaluation';

// UpdateExpression :
//   LeftHandSideExpression `++`
//   LeftHandSideExpression `--`
//   `++` UnaryExpression
//   `--` UnaryExpression
function* Evaluate_UpdateExpression({
  LeftHandSideExpression,
  operator,
  UnaryExpression
}) {
  switch (true) {
    // UpdateExpression : LeftHandSideExpression `++`
    // https://tc39.es/ecma262/#sec-postfix-increment-operator-runtime-semantics-evaluation
    case operator === '++' && !!LeftHandSideExpression:
      {
        /* ReturnIfAbrupt */
        let _temp = yield* Evaluate(LeftHandSideExpression);
        /* node:coverage ignore next */
        if (_temp instanceof AbruptCompletion) return _temp;
        /* node:coverage ignore next */
        if (_temp instanceof Completion) _temp = _temp.Value;
        // 1. Let lhs be the result of evaluating LeftHandSideExpression.
        const lhs = _temp;
        // 2. Let oldValue be ? ToNumeric(? GetValue(lhs)).
        /* ReturnIfAbrupt */
        let _temp4 = yield* GetValue(lhs);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        /* ReturnIfAbrupt */
        let _temp2 = yield* ToNumeric(_temp4);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        const oldValue = _temp2;
        // 3. If oldValue is a Number, then
        //  a. Let newValue be Number::add(oldValue, 1𝔽).
        //  4. Else,
        //         a. Assert: oldValue is a BigInt.
        //         b. Let newValue be BigInt::add(oldValue, 1ℤ).
        let newValue;
        if (oldValue instanceof NumberValue) {
          newValue = NumberValue.add(oldValue, F(1));
        } else {
          Assert(oldValue instanceof BigIntValue, "oldValue instanceof BigIntValue");
          newValue = BigIntValue.add(oldValue, Z(1n));
        }
        // 4. Perform ? PutValue(lhs, newValue).
        /* ReturnIfAbrupt */
        let _temp3 = yield* PutValue(lhs, newValue);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) return _temp3;
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        // 5. Return oldValue.
        return oldValue;
      }

    // UpdateExpression : LeftHandSideExpression `--`
    // https://tc39.es/ecma262/#sec-postfix-decrement-operator-runtime-semantics-evaluation
    case operator === '--' && !!LeftHandSideExpression:
      {
        /* ReturnIfAbrupt */
        let _temp5 = yield* Evaluate(LeftHandSideExpression);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) return _temp5;
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        // 1. Let lhs be the result of evaluating LeftHandSideExpression.
        const lhs = _temp5;
        // 2. Let oldValue be ? ToNumeric(? GetValue(lhs)).
        /* ReturnIfAbrupt */
        let _temp8 = yield* GetValue(lhs);
        /* node:coverage ignore next */
        if (_temp8 instanceof AbruptCompletion) return _temp8;
        /* node:coverage ignore next */
        if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        /* ReturnIfAbrupt */
        let _temp6 = yield* ToNumeric(_temp8);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        const oldValue = _temp6;
        // 3. If oldValue is a Number, then
        //  a. Let newValue be Number::subtract(oldValue, 1𝔽).
        //  4. Else,
        //         a. Assert: oldValue is a BigInt.
        //         b. Let newValue be BigInt::subtract(oldValue, 1ℤ).
        let newValue;
        if (oldValue instanceof NumberValue) {
          newValue = NumberValue.subtract(oldValue, F(1));
        } else {
          Assert(oldValue instanceof BigIntValue, "oldValue instanceof BigIntValue");
          newValue = BigIntValue.subtract(oldValue, Z(1n));
        }
        // 4. Perform ? PutValue(lhs, newValue).
        /* ReturnIfAbrupt */
        let _temp7 = yield* PutValue(lhs, newValue);
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) return _temp7;
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        // 5. Return oldValue.
        return oldValue;
      }

    // UpdateExpression : `++` UnaryExpression
    // https://tc39.es/ecma262/#sec-prefix-increment-operator-runtime-semantics-evaluation
    case operator === '++' && !!UnaryExpression:
      {
        /* ReturnIfAbrupt */
        let _temp9 = yield* Evaluate(UnaryExpression);
        /* node:coverage ignore next */
        if (_temp9 instanceof AbruptCompletion) return _temp9;
        /* node:coverage ignore next */
        if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
        // 1. Let expr be the result of evaluating UnaryExpression.
        const expr = _temp9;
        // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).
        /* ReturnIfAbrupt */
        let _temp12 = yield* GetValue(expr);
        /* node:coverage ignore next */
        if (_temp12 instanceof AbruptCompletion) return _temp12;
        /* node:coverage ignore next */
        if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
        /* ReturnIfAbrupt */
        let _temp10 = yield* ToNumeric(_temp12);
        /* node:coverage ignore next */
        if (_temp10 instanceof AbruptCompletion) return _temp10;
        /* node:coverage ignore next */
        if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
        const oldValue = _temp10;
        // 3. If oldValue is a Number, then
        //  a. Let newValue be Number::add(oldValue, 1𝔽).
        //  4. Else,
        //         a. Assert: oldValue is a BigInt.
        //         b. Let newValue be BigInt::add(oldValue, 1ℤ).
        let newValue;
        if (oldValue instanceof NumberValue) {
          newValue = NumberValue.add(oldValue, F(1));
        } else {
          Assert(oldValue instanceof BigIntValue, "oldValue instanceof BigIntValue");
          newValue = BigIntValue.add(oldValue, Z(1n));
        }
        // 4. Perform ? PutValue(expr, newValue).
        /* ReturnIfAbrupt */
        let _temp11 = yield* PutValue(expr, newValue);
        /* node:coverage ignore next */
        if (_temp11 instanceof AbruptCompletion) return _temp11;
        /* node:coverage ignore next */
        if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
        // 5. Return newValue.
        return newValue;
      }

    // UpdateExpression : `--` UnaryExpression
    // https://tc39.es/ecma262/#sec-prefix-decrement-operator-runtime-semantics-evaluation
    case operator === '--' && !!UnaryExpression:
      {
        /* ReturnIfAbrupt */
        let _temp13 = yield* Evaluate(UnaryExpression);
        /* node:coverage ignore next */
        if (_temp13 instanceof AbruptCompletion) return _temp13;
        /* node:coverage ignore next */
        if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
        // 1. Let expr be the result of evaluating UnaryExpression.
        const expr = _temp13;
        // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).
        /* ReturnIfAbrupt */
        let _temp16 = yield* GetValue(expr);
        /* node:coverage ignore next */
        if (_temp16 instanceof AbruptCompletion) return _temp16;
        /* node:coverage ignore next */
        if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
        /* ReturnIfAbrupt */
        let _temp14 = yield* ToNumeric(_temp16);
        /* node:coverage ignore next */
        if (_temp14 instanceof AbruptCompletion) return _temp14;
        /* node:coverage ignore next */
        if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
        const oldValue = _temp14;
        // 3. If oldValue is a Number, then
        //   a. Let newValue be Number::subtract(oldValue, 1𝔽).
        // 4. Else,
        //   a. Assert: oldValue is a BigInt.
        //   b. Let newValue be BigInt::subtract(oldValue, 1ℤ).
        let newValue;
        if (oldValue instanceof NumberValue) {
          newValue = NumberValue.subtract(oldValue, F(1));
        } else {
          Assert(oldValue instanceof BigIntValue, "oldValue instanceof BigIntValue");
          newValue = BigIntValue.subtract(oldValue, Z(1n));
        }
        // 4. Perform ? PutValue(expr, newValue).
        /* ReturnIfAbrupt */
        let _temp15 = yield* PutValue(expr, newValue);
        /* node:coverage ignore next */
        if (_temp15 instanceof AbruptCompletion) return _temp15;
        /* node:coverage ignore next */
        if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
        // 5. Return newValue.
        return newValue;
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_UpdateExpression', operator);
  }
}

function* GlobalDeclarationInstantiation(script, env) {
  // 2. Let lexNames be the LexicallyDeclaredNames of script.
  const lexNames = LexicallyDeclaredNames(script);
  // 3. Let varNames be the VarDeclaredNames of script.
  const varNames = VarDeclaredNames(script);
  // 4. For each name in lexNames, do
  for (const name of lexNames) {
    // 1. If env.HasVarDeclaration(name) is true, throw a SyntaxError exception.
    if (env.HasVarDeclaration(name) === Value.true) {
      return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
    }
    // 1. If env.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
    if ((yield* env.HasLexicalDeclaration(name)) === Value.true) {
      return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
    }
    // 1. Let hasRestrictedGlobal be ? env.HasRestrictedGlobalProperty(name).
    /* ReturnIfAbrupt */
    let _temp = yield* env.HasRestrictedGlobalProperty(name);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const hasRestrictedGlobal = _temp;
    // 1. If hasRestrictedGlobal is true, throw a SyntaxError exception.
    if (hasRestrictedGlobal === Value.true) {
      return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
    }
  }
  // 5. For each name in varNames, do
  for (const name of varNames) {
    // 1. If env.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
    if ((yield* env.HasLexicalDeclaration(name)) === Value.true) {
      return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
    }
  }
  // 6. Let varDeclarations be the VarScopedDeclarations of script.
  const varDeclarations = VarScopedDeclarations(script);
  // 7. Let functionsToInitialize be a new empty List.
  const functionsToInitialize = [];
  // 8. Let declaredFunctionNames be a new empty List.
  const declaredFunctionNames = new JSStringSet();
  // 9. For each d in varDeclarations, in reverse list order, do
  for (const d of [...varDeclarations].reverse()) {
    // a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
    if (d.type !== 'VariableDeclaration' && d.type !== 'ForBinding' && d.type !== 'BindingIdentifier') {
      // i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.
      Assert(d.type === 'FunctionDeclaration' || d.type === 'GeneratorDeclaration' || d.type === 'AsyncFunctionDeclaration' || d.type === 'AsyncGeneratorDeclaration', "d.type === 'FunctionDeclaration'\n             || d.type === 'GeneratorDeclaration'\n             || d.type === 'AsyncFunctionDeclaration'\n             || d.type === 'AsyncGeneratorDeclaration'");
      // ii. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
      // iii. Let fn be the sole element of the BoundNames of d.
      const fn = BoundNames(d)[0];
      // iv. If fn is not an element of declaredFunctionNames, then
      if (!declaredFunctionNames.has(fn)) {
        /* ReturnIfAbrupt */
        let _temp2 = yield* env.CanDeclareGlobalFunction(fn);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        // 1. Let fnDefinable be ? env.CanDeclareGlobalFunction(fn).
        const fnDefinable = _temp2;
        // 2. If fnDefinable is false, throw a TypeError exception.
        if (fnDefinable === Value.false) {
          return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', fn);
        }
        // 3. Append fn to declaredFunctionNames.
        declaredFunctionNames.add(fn);
        // 4. Insert d as the first element of functionsToInitialize.
        functionsToInitialize.unshift(d);
      }
    }
  }
  // 10. Let declaredVarNames be a new empty List.
  const declaredVarNames = new JSStringSet();
  // 11. For each d in varDeclarations, do
  for (const d of varDeclarations) {
    // a. If d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, then
    if (d.type === 'VariableDeclaration' || d.type === 'ForBinding' || d.type === 'BindingIdentifier') {
      // i. For each String vn in the BoundNames of d, do
      for (const vn of BoundNames(d)) {
        // 1. If vn is not an element of declaredFunctionNames, then
        if (!declaredFunctionNames.has(vn)) {
          /* ReturnIfAbrupt */
          let _temp3 = yield* env.CanDeclareGlobalVar(vn);
          /* node:coverage ignore next */
          if (_temp3 instanceof AbruptCompletion) return _temp3;
          /* node:coverage ignore next */
          if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
          // a. Let vnDefinable be ? env.CanDeclareGlobalVar(vn).
          const vnDefinable = _temp3;
          // b. If vnDefinable is false, throw a TypeError exception.
          if (vnDefinable === Value.false) {
            return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', vn);
          }
          // c. If vn is not an element of declaredVarNames, then
          if (!declaredVarNames.has(vn)) {
            // i. Append vn to declaredVarNames.
            declaredVarNames.add(vn);
          }
        }
      }
    }
  }
  // 12. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.
  // 13. NOTE: Annex B.3.3.2 adds additional steps at this point.
  // 14. Let lexDeclarations be the LexicallyScopedDeclarations of script.
  const lexDeclarations = LexicallyScopedDeclarations(script);
  // 15. Let privateEnv be null.
  const privateEnv = Value.null;
  // 16. For each element d in lexDeclarations, do
  for (const d of lexDeclarations) {
    // a. NOTE: Lexically declared names are only instantiated here but not initialized.
    // b. For each element dn of the BoundNames of d, do
    for (const dn of BoundNames(d)) {
      // 1. If IsConstantDeclaration of d is true, then
      if (IsConstantDeclaration(d)) {
        /* ReturnIfAbrupt */
        let _temp4 = env.CreateImmutableBinding(dn, Value.true);
        /* node:coverage ignore next */
        if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      } else {
        /* ReturnIfAbrupt */
        let _temp5 = yield* env.CreateMutableBinding(dn, Value.false);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) return _temp5;
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      }
    }
  }
  // 17. For each Parse Node f in functionsToInitialize, do
  for (const f of functionsToInitialize) {
    // a. Let fn be the sole element of the BoundNames of f.
    const fn = BoundNames(f)[0];
    // b. Let fo be InstantiateFunctionObject of f with argument env and privateEnv.
    const fo = InstantiateFunctionObject(f, env, privateEnv);
    // c. Perform ? env.CreateGlobalFunctionBinding(fn, fo, false).
    /* ReturnIfAbrupt */
    let _temp6 = yield* env.CreateGlobalFunctionBinding(fn, fo, Value.false);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  }
  // 18. For each String vn in declaredVarNames, in list order, do
  for (const vn of declaredVarNames) {
    /* ReturnIfAbrupt */
    let _temp7 = yield* env.CreateGlobalVarBinding(vn, Value.false);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  }
  // 19. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}

/** https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-instantiatefunctionobject */
//   FunctionDeclaration :
//     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
//     `function` `(` FormalParameters `)` `{` FunctionBody `}`
function InstantiateFunctionObject_FunctionDeclaration(FunctionDeclaration, env, privateEnv) {
  const {
    BindingIdentifier,
    FormalParameters,
    FunctionBody
  } = FunctionDeclaration;
  // 1. Let name be StringValue of BindingIdentifier.
  const name = BindingIdentifier ? StringValue(BindingIdentifier) : Value('default');
  // 2. Let sourceText be the source text matched by FunctionDeclaration.
  const sourceText = sourceTextMatchedBy(FunctionDeclaration);
  // 3. Let F be OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, FormalParameters, FunctionBody, 'non-lexical-this', env, privateEnv);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, FormalParameters, FunctionBody, 'non-lexical-this', env, privateEnv) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const F = _temp;
  // 4. Perform SetFunctionName(F, name).
  SetFunctionName(F, name);
  // 5. Perform MakeConstructor(F).
  MakeConstructor(F);
  // 6. Return F.
  return F;
}
InstantiateFunctionObject_FunctionDeclaration.section = 'https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-instantiatefunctionobject';
/** https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject */
//   GeneratorDeclaration :
//     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
//     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
function InstantiateFunctionObject_GeneratorDeclaration(GeneratorDeclaration, env, privateEnv) {
  const {
    BindingIdentifier,
    FormalParameters,
    GeneratorBody
  } = GeneratorDeclaration;
  // 1. Let name be StringValue of BindingIdentifier.
  const name = BindingIdentifier ? StringValue(BindingIdentifier) : Value('default');
  // 2. Let sourceText be the source text matched by GeneratorDeclaration.
  const sourceText = sourceTextMatchedBy(GeneratorDeclaration);
  // 3. Let F be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, FormalParameters, GeneratorBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp2 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype%'), sourceText, FormalParameters, GeneratorBody, 'non-lexical-this', env, privateEnv);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype%'), sourceText, FormalParameters, GeneratorBody, 'non-lexical-this', env, privateEnv) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const F = _temp2;
  // 4. Perform SetFunctionName(F, name).
  SetFunctionName(F, name);
  // 5. Let prototype be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
  /* X */
  let _temp3 = OrdinaryObjectCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype%'));
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype%')) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const prototype = _temp3;
  // 6. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
  /* X */
  let _temp4 = DefinePropertyOrThrow(F, Value('prototype'), _Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 7. Return F.
  return F;
}
InstantiateFunctionObject_GeneratorDeclaration.section = 'https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject';
/** https://tc39.es/ecma262/#sec-async-function-definitions-InstantiateFunctionObject */
//  AsyncFunctionDeclaration :
//    `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncBody `}`
//    `async` `function` `(` FormalParameters `)` `{` AsyncBody `}`
function InstantiateFunctionObject_AsyncFunctionDeclaration(AsyncFunctionDeclaration, env, privateEnv) {
  const {
    BindingIdentifier,
    FormalParameters,
    AsyncBody
  } = AsyncFunctionDeclaration;
  // 1. Let name be StringValue of BindingIdentifier.
  const name = BindingIdentifier ? StringValue(BindingIdentifier) : Value('default');
  // 2. Let sourceText be the source text matched by AsyncFunctionDeclaration.
  const sourceText = sourceTextMatchedBy(AsyncFunctionDeclaration);
  // 3. Let F be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, FormalParameters, AsyncBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp5 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), sourceText, FormalParameters, AsyncBody, 'non-lexical-this', env, privateEnv);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), sourceText, FormalParameters, AsyncBody, 'non-lexical-this', env, privateEnv) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const F = _temp5;
  // 4. Perform ! SetFunctionName(F, name).
  SetFunctionName(F, name);
  // 5. Return F.
  return F;
}
InstantiateFunctionObject_AsyncFunctionDeclaration.section = 'https://tc39.es/ecma262/#sec-async-function-definitions-InstantiateFunctionObject';
/** https://tc39.es/ecma262/#sec-asyncgenerator-definitions-evaluatebody */
//  AsyncGeneratorDeclaration :
//    `async` `function` `*` BindingIdentifier `(` FormalParameters`)` `{` AsyncGeneratorBody `}`
//    `async` `function` `*` `(` FormalParameters`)` `{` AsyncGeneratorBody `}`
function InstantiateFunctionObject_AsyncGeneratorDeclaration(AsyncGeneratorDeclaration, env, privateEnv) {
  const {
    BindingIdentifier,
    FormalParameters,
    AsyncGeneratorBody
  } = AsyncGeneratorDeclaration;
  // 1. Let name be StringValue of BindingIdentifier.
  const name = BindingIdentifier ? StringValue(BindingIdentifier) : Value('default');
  // 2. Let sourceText be the source text matched by AsyncGeneratorDeclaration.
  const sourceText = sourceTextMatchedBy(AsyncGeneratorDeclaration);
  // 3. Let F be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, FormalParameters, AsyncGeneratorBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp6 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), sourceText, FormalParameters, AsyncGeneratorBody, 'non-lexical-this', env, privateEnv);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), sourceText, FormalParameters, AsyncGeneratorBody, 'non-lexical-this', env, privateEnv) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const F = _temp6;
  // 4. Perform ! SetFunctionName(F, name).
  SetFunctionName(F, name);
  // 5. Let prototype be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
  /* X */
  let _temp7 = OrdinaryObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype.prototype%'));
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype.prototype%')) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const prototype = _temp7;
  // 6. Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
  /* X */
  let _temp8 = DefinePropertyOrThrow(F, Value('prototype'), _Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 7. Return F.
  return F;
}
InstantiateFunctionObject_AsyncGeneratorDeclaration.section = 'https://tc39.es/ecma262/#sec-asyncgenerator-definitions-evaluatebody';
function InstantiateFunctionObject(AnyFunctionDeclaration, env, privateEnv) {
  switch (AnyFunctionDeclaration.type) {
    case 'FunctionDeclaration':
      return InstantiateFunctionObject_FunctionDeclaration(AnyFunctionDeclaration, env, privateEnv);
    case 'GeneratorDeclaration':
      return InstantiateFunctionObject_GeneratorDeclaration(AnyFunctionDeclaration, env, privateEnv);
    case 'AsyncFunctionDeclaration':
      return InstantiateFunctionObject_AsyncFunctionDeclaration(AnyFunctionDeclaration, env, privateEnv);
    case 'AsyncGeneratorDeclaration':
      return InstantiateFunctionObject_AsyncGeneratorDeclaration(AnyFunctionDeclaration, env, privateEnv);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('InstantiateFunctionObject', AnyFunctionDeclaration);
  }
}

/** https://tc39.es/ecma262/#sec-script-semantics-runtime-semantics-evaluation */
// Script :
//   [empty]
//   ScriptBody
function* Evaluate_Script({
  ScriptBody
}) {
  if (!ScriptBody) {
    return NormalCompletion(Value.undefined);
  }
  return yield* Evaluate(ScriptBody);
}
Evaluate_Script.section = 'https://tc39.es/ecma262/#sec-script-semantics-runtime-semantics-evaluation';

// ScriptBody : StatementList
function Evaluate_ScriptBody(ScriptBody) {
  return Evaluate_StatementList(ScriptBody.StatementList);
}

/** https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation */
function* Evaluate_StatementList(StatementList) {
  if (StatementList.length === 0) {
    return NormalCompletion(undefined);
  }
  let blockCompletion = NormalCompletion(undefined);
  for (let index = 0; index < StatementList.length; index += 1) {
    const StatementListItem = StatementList[index];
    if (surroundingAgent.hostDefinedOptions.onDebugger) {
      const NextStatementListItem = StatementList[index + 1];
      surroundingAgent.runningExecutionContext.callSite.setNextLocation(NextStatementListItem);
    }
    /* ReturnIfAbrupt */
    /* node:coverage ignore next */
    if (blockCompletion && typeof blockCompletion === 'object' && 'next' in blockCompletion) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (blockCompletion instanceof AbruptCompletion) return blockCompletion;
    /* node:coverage ignore next */
    if (blockCompletion instanceof Completion) blockCompletion = blockCompletion.Value;
    const itemCompletion = EnsureCompletion(yield* Evaluate(StatementListItem));
    blockCompletion = UpdateEmpty(itemCompletion, blockCompletion);
  }
  return blockCompletion;
}
Evaluate_StatementList.section = 'https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-expression-statement-runtime-semantics-evaluation */
//   ExpressionStatement :
//     Expression `;`
function* Evaluate_ExpressionStatement({
  Expression
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(Expression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let exprRef be the result of evaluating Expression.
  const exprRef = _temp;
  // 2. Return ? GetValue(exprRef).
  return yield* GetValue(exprRef);
}
Evaluate_ExpressionStatement.section = 'https://tc39.es/ecma262/#sec-expression-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-variable-statement-runtime-semantics-evaluation */
//   VariableDeclaration :
//     BindingIdentifier
//     BindingIdentifier Initializer
//     BindingPattern Initializer
function* Evaluate_VariableDeclaration({
  BindingIdentifier,
  Initializer,
  BindingPattern
}) {
  if (BindingIdentifier) {
    if (!Initializer) {
      // 1. Return NormalCompletion(empty).
      return NormalCompletion(undefined);
    }
    // 1. Let bindingId be StringValue of BindingIdentifier.
    const bindingId = StringValue(BindingIdentifier);
    // 2. Let lhs be ? ResolveBinding(bindingId).
    /* ReturnIfAbrupt */
    let _temp = yield* ResolveBinding(bindingId, undefined, BindingIdentifier.strict);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const lhs = _temp;
    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
    let value;
    if (IsAnonymousFunctionDefinition(Initializer)) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* NamedEvaluation(Initializer, bindingId);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      // a. Let value be NamedEvaluation of Initializer with argument bindingId.
      value = _temp2;
    } else {
      /* ReturnIfAbrupt */
      let _temp3 = yield* Evaluate(Initializer);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // 4. Else,
      // a. Let rhs be the result of evaluating Initializer.
      const rhs = _temp3;
      // b. Let value be ? GetValue(rhs).
      /* ReturnIfAbrupt */
      let _temp4 = yield* GetValue(rhs);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      value = _temp4;
    }
    // 5. Return ? PutValue(lhs, value).
    return yield* PutValue(lhs, value);
  }
  // 1. Let rhs be the result of evaluating Initializer.
  /* ReturnIfAbrupt */
  let _temp5 = yield* Evaluate(Initializer);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const rhs = _temp5;
  // 2. Let rval be ? GetValue(rhs).
  /* ReturnIfAbrupt */
  let _temp6 = yield* GetValue(rhs);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const rval = _temp6;
  // 3. Return the result of performing BindingInitialization for BindingPattern passing rval and undefined as arguments.
  return yield* BindingInitialization(BindingPattern, rval, Value.undefined);
}
Evaluate_VariableDeclaration.section = 'https://tc39.es/ecma262/#sec-variable-statement-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-variable-statement-runtime-semantics-evaluation */
//   VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration
//
// (implicit)
//   VariableDeclarationList : VariableDeclaration
function* Evaluate_VariableDeclarationList(VariableDeclarationList) {
  let next;
  for (const VariableDeclaration of VariableDeclarationList) {
    next = yield* Evaluate_VariableDeclaration(VariableDeclaration);
    /* ReturnIfAbrupt */
    /* node:coverage ignore next */
    if (next && typeof next === 'object' && 'next' in next) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (next instanceof AbruptCompletion) return next;
    /* node:coverage ignore next */
    if (next instanceof Completion) next = next.Value;
  }
  return next;
}
Evaluate_VariableDeclarationList.section = 'https://tc39.es/ecma262/#sec-variable-statement-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-variable-statement-runtime-semantics-evaluation */
//   VariableStatement : `var` VariableDeclarationList `;`
function* Evaluate_VariableStatement({
  VariableDeclarationList
}) {
  let next = yield* Evaluate_VariableDeclarationList(VariableDeclarationList);
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (next && typeof next === 'object' && 'next' in next) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (next instanceof AbruptCompletion) return next;
  /* node:coverage ignore next */
  if (next instanceof Completion) next = next.Value;
  return NormalCompletion(undefined);
}
Evaluate_VariableStatement.section = 'https://tc39.es/ecma262/#sec-variable-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluation */
// FunctionDeclaration :
//   function BindingIdentifier ( FormalParameters ) { FunctionBody }
//   function ( FormalParameters ) { FunctionBody }
function Evaluate_FunctionDeclaration(_FunctionDeclaration) {
  // 1. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
Evaluate_FunctionDeclaration.section = 'https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation */
// CallExpression :
//   CoverCallExpressionAndAsyncArrowHead
//   CallExpression Arguments
function* Evaluate_CallExpression(CallExpression) {
  // 1. Let expr be CoveredCallExpression of CoverCallExpressionAndAsyncArrowHead.
  const expr = CallExpression;
  // 2. Let memberExpr be the MemberExpression of expr.
  const memberExpr = expr.CallExpression;
  // 3. Let arguments be the Arguments of expr.
  const args = expr.Arguments;
  // 4. Let ref be the result of evaluating memberExpr.
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(memberExpr);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const ref = _temp;
  // 5. Let func be ? GetValue(ref).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(ref);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const func = _temp2;
  // 6. If Type(ref) is Reference, IsPropertyReference(ref) is false, and GetReferencedName(ref) is "eval", then
  if (ref instanceof ReferenceRecord && IsPropertyReference(ref) === Value.false && ref.ReferencedName instanceof JSStringValue && ref.ReferencedName.stringValue() === 'eval') {
    // a. If SameValue(func, %eval%) is true, then
    if (SameValue(func, surroundingAgent.intrinsic('%eval%')) === Value.true) {
      /* ReturnIfAbrupt */
      let _temp3 = yield* ArgumentListEvaluation(args);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // i. Let argList be ? ArgumentListEvaluation of arguments.
      const argList = _temp3;
      // ii. If argList has no elements, return undefined.
      if (argList.length === 0) {
        return Value.undefined;
      }
      // iii. Let evalText be the first element of argList.
      const evalText = argList[0];
      // iv. If the source code matching this CallExpression is strict mode code, let strictCaller be true. Otherwise let strictCaller be false.
      const strictCaller = CallExpression.strict;
      // v. Let evalRealm be the current Realm Record.
      const evalRealm = surroundingAgent.currentRealmRecord;
      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).
      return yield* PerformEval(evalText, evalRealm, strictCaller, true);
    }
  }
  // 8. Let tailCall be IsInTailPosition(thisCall).
  const tailCall = IsInTailPosition();
  // 9. Return ? EvaluateCall(func, ref, arguments, tailCall).
  return yield* EvaluateCall(func, ref, args, tailCall);
}
Evaluate_CallExpression.section = 'https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-evaluatecall */
function* EvaluateCall(func, ref, args, tailPosition) {
  // 1. If Type(ref) is Reference, then
  let thisValue;
  if (ref instanceof ReferenceRecord) {
    // a. If IsPropertyReference(ref) is true, then
    if (IsPropertyReference(ref) === Value.true) {
      // i. Let thisValue be GetThisValue(ref).
      thisValue = GetThisValue(ref);
    } else {
      // i. Let refEnv be ref.[[Base]].
      const refEnv = ref.Base;
      // ii. Assert: refEnv is an Environment Record.
      Assert(refEnv instanceof EnvironmentRecord, "refEnv instanceof EnvironmentRecord");
      // iii. Let thisValue be refEnv.WithBaseObject().
      thisValue = refEnv.WithBaseObject();
    }
  } else {
    // a. Let thisValue be undefined.
    thisValue = Value.undefined;
  }
  // 3. Let argList be ? ArgumentListEvaluation of arguments.
  /* ReturnIfAbrupt */
  let _temp = yield* ArgumentListEvaluation(args);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const argList = _temp;
  // 4. If Type(func) is not Object, throw a TypeError exception.
  if (!(func instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
  }
  // 5. If IsCallable(func) is false, throw a TypeError exception.
  if (!IsCallable(func)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
  }
  // 6. If tailPosition is true, perform PrepareForTailCall().
  if (tailPosition) {
    PrepareForTailCall();
  }
  // 7. Let result be Call(func, thisValue, argList).
  const result = yield* Call(func, thisValue, argList);
  // 8. Assert: If tailPosition is true, the above call will not return here but instead
  //    evaluation will continue as if the following return has already occurred.
  // 9. Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.
  if (!(result instanceof AbruptCompletion)) {
    Assert(result instanceof Value || result instanceof Completion, "result instanceof Value || result instanceof Completion");
  }
  // 10. Return result.
  return result;
}
EvaluateCall.section = 'https://tc39.es/ecma262/#sec-evaluatecall';

/** https://tc39.es/ecma262/#sec-gettemplateobjec */
function GetTemplateObject(templateLiteral) {
  // 1. Let realm be the current Realm Record.
  const realm = surroundingAgent.currentRealmRecord;
  // 2. Let templateRegistry be realm.[[TemplateMap]].
  const templateRegistry = realm.TemplateMap;
  // 3. For each element e of templateRegistry, do
  for (const e of templateRegistry) {
    // a. If e.[[Site]] is the same Parse Node as templateLiteral, then
    if (e.Site === templateLiteral) {
      // b. Return e.[[Array]].
      return e.Array;
    }
  }
  // 4. Let rawStrings be TemplateStrings of templateLiteral with argument true.
  const rawStrings = TemplateStrings(templateLiteral, true);
  // 5. Let cookedStrings be TemplateStrings of templateLiteral with argument false.
  const cookedStrings = TemplateStrings(templateLiteral, false);
  // 6. Let count be the number of elements in the List cookedStrings.
  const count = cookedStrings.length;
  // 7. Assert: count ≤ 232 - 1.
  Assert(count < 2 ** 32 - 1, "count < (2 ** 32) - 1");
  // 8. Let template be ! ArrayCreate(count).
  /* X */
  let _temp = ArrayCreate(count);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(count) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const template = _temp;
  // 9. Let template be ! ArrayCreate(count).
  /* X */
  let _temp2 = ArrayCreate(count);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(count) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const rawObj = _temp2;
  // 10. Let index be 0.
  let index = 0;
  // 11. Repeat, while index < count
  while (index < count) {
    /* X */
    let _temp3 = ToString(F(index));
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(index)) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // a. Let prop be ! ToString(𝔽(index)).
    const prop = _temp3;
    // b. Let cookedValue be the String value cookedStrings[index].
    const cookedValue = cookedStrings[index];
    // c. Call template.[[DefineOwnProperty]](prop, PropertyDescriptor { [[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }).
    /* X */
    let _temp4 = template.DefineOwnProperty(prop, _Descriptor({
      Value: cookedValue,
      Writable: Value.false,
      Enumerable: Value.true,
      Configurable: Value.false
    }));
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! template.DefineOwnProperty(prop, Descriptor({\n      Value: cookedValue,\n      Writable: Value.false,\n      Enumerable: Value.true,\n      Configurable: Value.false,\n    })) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // d. Let rawValue be the String value rawStrings[index].
    const rawValue = rawStrings[index];
    // e. Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor { [[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }).
    /* X */
    let _temp5 = rawObj.DefineOwnProperty(prop, _Descriptor({
      Value: rawValue,
      Writable: Value.false,
      Enumerable: Value.true,
      Configurable: Value.false
    }));
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! rawObj.DefineOwnProperty(prop, Descriptor({\n      Value: rawValue,\n      Writable: Value.false,\n      Enumerable: Value.true,\n      Configurable: Value.false,\n    })) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // f. Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor { [[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }).
    index += 1;
  }
  // 12. Perform SetIntegrityLevel(rawObj, frozen).
  /* X */
  let _temp6 = SetIntegrityLevel(rawObj, 'frozen');
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! SetIntegrityLevel(rawObj, 'frozen') returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  // 13. Perform SetIntegrityLevel(rawObj, frozen).
  /* X */
  let _temp7 = template.DefineOwnProperty(Value('raw'), _Descriptor({
    Value: rawObj,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! template.DefineOwnProperty(Value('raw'), Descriptor({\n    Value: rawObj,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 14. Perform SetIntegrityLevel(template, frozen).
  /* X */
  let _temp8 = SetIntegrityLevel(template, 'frozen');
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! SetIntegrityLevel(template, 'frozen') returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 15. Append the Record { [[Site]]: templateLiteral, [[Array]]: template } to templateRegistry.
  templateRegistry.push({
    Site: templateLiteral,
    Array: template
  });
  // 16. Return template.
  return template;
}
GetTemplateObject.section = 'https://tc39.es/ecma262/#sec-gettemplateobjec';
/** https://tc39.es/ecma262/#sec-template-literals-runtime-semantics-argumentlistevaluation */
//   TemplateLiteral : NoSubstitutionTemplate
//
// https://github.com/tc39/ecma262/pull/1402
//   TemplateLiteral : SubstitutionTemplate
function* ArgumentListEvaluation_TemplateLiteral(TemplateLiteral) {
  switch (true) {
    case TemplateLiteral.TemplateSpanList.length === 1:
      {
        const templateLiteral = TemplateLiteral;
        const siteObj = GetTemplateObject(templateLiteral);
        return [siteObj];
      }
    case TemplateLiteral.TemplateSpanList.length > 1:
      {
        const templateLiteral = TemplateLiteral;
        const siteObj = GetTemplateObject(templateLiteral);
        const restSub = [];
        for (const Expression of TemplateLiteral.ExpressionList) {
          /* ReturnIfAbrupt */
          let _temp9 = yield* Evaluate(Expression);
          /* node:coverage ignore next */
          if (_temp9 instanceof AbruptCompletion) return _temp9;
          /* node:coverage ignore next */
          if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
          const subRef = _temp9;
          /* ReturnIfAbrupt */
          let _temp10 = yield* GetValue(subRef);
          /* node:coverage ignore next */
          if (_temp10 instanceof AbruptCompletion) return _temp10;
          /* node:coverage ignore next */
          if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
          const subValue = _temp10;
          restSub.push(subValue);
        }
        return [siteObj, ...restSub];
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('ArgumentListEvaluation_TemplateLiteral', TemplateLiteral);
  }
}
ArgumentListEvaluation_TemplateLiteral.section = 'https://tc39.es/ecma262/#sec-template-literals-runtime-semantics-argumentlistevaluation';
/** https://tc39.es/ecma262/#sec-argument-lists-runtime-semantics-argumentlistevaluation */
//   Arguments : `(` `)`
//   ArgumentList :
//     AssignmentExpression
//     `...` AssignmentExpression
//     ArgumentList `,` AssignmentExpression
//     ArgumentList `,` `...` AssignmentExpression
//
// (implicit)
//   Arguments :
//     `(` ArgumentList `)`
//     `(` ArgumentList `,` `)`
function* ArgumentListEvaluation_Arguments(Arguments) {
  const precedingArgs = [];
  for (const element of Arguments) {
    if (element.type === 'AssignmentRestElement') {
      const {
        AssignmentExpression
      } = element;
      // 2. Let spreadRef be the result of evaluating AssignmentExpression.
      /* ReturnIfAbrupt */
      let _temp11 = yield* Evaluate(AssignmentExpression);
      /* node:coverage ignore next */
      if (_temp11 instanceof AbruptCompletion) return _temp11;
      /* node:coverage ignore next */
      if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
      const spreadRef = _temp11;
      // 3. Let spreadObj be ? GetValue(spreadRef).
      /* ReturnIfAbrupt */
      let _temp12 = yield* GetValue(spreadRef);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      const spreadObj = _temp12;
      // 4. Let iteratorRecord be ? GetIterator(spreadObj).
      /* ReturnIfAbrupt */
      let _temp13 = yield* GetIterator(spreadObj, 'sync');
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      const iteratorRecord = _temp13;
      // 5. Repeat,
      while (true) {
        /* ReturnIfAbrupt */
        let _temp14 = yield* IteratorStepValue(iteratorRecord);
        /* node:coverage ignore next */
        if (_temp14 instanceof AbruptCompletion) return _temp14;
        /* node:coverage ignore next */
        if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
        // a. Let next be ? IteratorStepValue(iteratorRecord).
        const next = _temp14;
        // b. If next is false, return list.
        if (next === 'done') {
          break;
        }
        // d. Append next as the last element of list.
        precedingArgs.push(next);
      }
    } else {
      const AssignmentExpression = element;
      // 2. Let ref be the result of evaluating AssignmentExpression.
      /* ReturnIfAbrupt */
      let _temp15 = yield* Evaluate(AssignmentExpression);
      /* node:coverage ignore next */
      if (_temp15 instanceof AbruptCompletion) return _temp15;
      /* node:coverage ignore next */
      if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
      const ref = _temp15;
      // 3. Let arg be ? GetValue(ref).
      /* ReturnIfAbrupt */
      let _temp16 = yield* GetValue(ref);
      /* node:coverage ignore next */
      if (_temp16 instanceof AbruptCompletion) return _temp16;
      /* node:coverage ignore next */
      if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
      const arg = _temp16;
      // 4. Append arg to the end of precedingArgs.
      precedingArgs.push(arg);
      // 5. Return precedingArgs.
    }
  }
  return precedingArgs;
}
ArgumentListEvaluation_Arguments.section = 'https://tc39.es/ecma262/#sec-argument-lists-runtime-semantics-argumentlistevaluation';
function ArgumentListEvaluation(ArgumentsOrTemplateLiteral) {
  switch (true) {
    case isArray(ArgumentsOrTemplateLiteral):
      return ArgumentListEvaluation_Arguments(ArgumentsOrTemplateLiteral);
    case 'type' in ArgumentsOrTemplateLiteral && ArgumentsOrTemplateLiteral.type === 'TemplateLiteral':
      return ArgumentListEvaluation_TemplateLiteral(ArgumentsOrTemplateLiteral);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('ArgumentListEvaluation', ArgumentsOrTemplateLiteral);
  }
}

function Evaluate_AnyFunctionBody({
  FunctionStatementList
}) {
  return Evaluate_FunctionStatementList(FunctionStatementList);
}

/** https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluatebody */
// FunctionBody : FunctionStatementList
function* EvaluateBody_FunctionBody({
  FunctionStatementList
}, functionObject, argumentsList) {
  /* ReturnIfAbrupt */
  let _temp = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 2. Return the result of evaluating FunctionStatementList.
  return yield* Evaluate_FunctionStatementList(FunctionStatementList);
}
EvaluateBody_FunctionBody.section = 'https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluatebody';
/** https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-evaluation */
// ExpressionBody : AssignmentExpression
function* Evaluate_ExpressionBody({
  AssignmentExpression
}) {
  /* ReturnIfAbrupt */
  let _temp2 = yield* Evaluate(AssignmentExpression);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Let exprRef be the result of evaluating AssignmentExpression.
  const exprRef = _temp2;
  // 2. Let exprValue be ? GetValue(exprRef).
  /* ReturnIfAbrupt */
  let _temp3 = yield* GetValue(exprRef);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const exprValue = _temp3;
  // 3. Return Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }.
  return new Completion({
    Type: 'return',
    Value: exprValue,
    Target: undefined
  });
}
Evaluate_ExpressionBody.section = 'https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-evaluatebody */
// ConciseBody : ExpressionBody
function* EvaluateBody_ConciseBody({
  ExpressionBody
}, functionObject, argumentsList) {
  /* ReturnIfAbrupt */
  let _temp4 = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 2. Return the result of evaluating ExpressionBody.
  return yield* Evaluate(ExpressionBody);
}
EvaluateBody_ConciseBody.section = 'https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-evaluatebody';
/** https://tc39.es/ecma262/#sec-async-arrow-function-definitions-EvaluateBody */
// AsyncConciseBody : ExpressionBody
function* EvaluateBody_AsyncConciseBody({
  ExpressionBody
}, functionObject, argumentsList) {
  /* X */
  let _temp5 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 1. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  const promiseCapability = _temp5;
  // 2. Let declResult be FunctionDeclarationInstantiation(functionObject, argumentsList).
  const declResult = EnsureCompletion(yield* FunctionDeclarationInstantiation(functionObject, argumentsList));
  // 3. If declResult is not an abrupt completion, then
  if (declResult.Type === 'normal') {
    /* X */
    let _temp6 = yield* AsyncFunctionStart(promiseCapability, ExpressionBody);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! yield* AsyncFunctionStart(promiseCapability, ExpressionBody) returned an abrupt completion", {
      cause: _temp6
    });
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  } else {
    /* X */
    let _temp7 = yield* Call(promiseCapability.Reject, Value.undefined, [declResult.Value]);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! yield* Call(promiseCapability.Reject, Value.undefined, [declResult.Value!]) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  }
  // 5. Return Completion { [[Type]]: return, [[Value]]: promiseCapability.[[Promise]], [[Target]]: empty }.
  return new Completion({
    Type: 'return',
    Value: promiseCapability.Promise,
    Target: undefined
  });
}
EvaluateBody_AsyncConciseBody.section = 'https://tc39.es/ecma262/#sec-async-arrow-function-definitions-EvaluateBody';
/** https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluatebody */
// GeneratorBody : FunctionBody
function* EvaluateBody_GeneratorBody(GeneratorBody, functionObject, argumentsList) {
  /* ReturnIfAbrupt */
  let _temp8 = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 2. Let G be ? OrdinaryCreateFromConstructor(functionObject, "%GeneratorPrototype%", « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »).
  /* ReturnIfAbrupt */
  let _temp9 = yield* OrdinaryCreateFromConstructor(functionObject, '%GeneratorFunction.prototype.prototype%', ['GeneratorState', 'GeneratorContext', 'GeneratorBrand']);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const G = _temp9;
  // 3. Set G.[[GeneratorBrand]] to empty.
  G.GeneratorBrand = undefined;
  // 4. Set G.[[GeneratorState]] to suspended-start.
  G.GeneratorState = 'suspendedStart';
  // 5. Perform GeneratorStart(G, FunctionBody).
  GeneratorStart(G, GeneratorBody);
  // 6. Return ReturnCompletion(G).
  return ReturnCompletion(G);
}
EvaluateBody_GeneratorBody.section = 'https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluatebody';
/** https://tc39.es/ecma262/#sec-asyncgenerator-definitions-evaluatebody */
// AsyncGeneratorBody : FunctionBody
function* EvaluateBody_AsyncGeneratorBody(FunctionBody, functionObject, argumentsList) {
  /* ReturnIfAbrupt */
  let _temp10 = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  // 2. Let generator be ? OrdinaryCreateFromConstructor(functionObject, "%AsyncGeneratorFunction.prototype.prototype%", « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »).
  /* ReturnIfAbrupt */
  let _temp11 = yield* OrdinaryCreateFromConstructor(functionObject, '%AsyncGeneratorFunction.prototype.prototype%', ['AsyncGeneratorState', 'AsyncGeneratorContext', 'AsyncGeneratorQueue', 'GeneratorBrand']);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const generator = _temp11;
  // 3. Set generator.[[GeneratorBrand]] to empty.
  generator.GeneratorBrand = undefined;
  // 4. Perform ! AsyncGeneratorStart(generator, FunctionBody).
  /* X */
  let _temp12 = AsyncGeneratorStart(generator, FunctionBody);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorStart(generator, FunctionBody) returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  // 5. Return Completion { [[Type]]: return, [[Value]]: generator, [[Target]]: empty }.
  return new Completion({
    Type: 'return',
    Value: generator,
    Target: undefined
  });
}
EvaluateBody_AsyncGeneratorBody.section = 'https://tc39.es/ecma262/#sec-asyncgenerator-definitions-evaluatebody';
/** https://tc39.es/ecma262/#sec-async-function-definitions-EvaluateBody */
// AsyncBody : FunctionBody
function* EvaluateBody_AsyncFunctionBody(FunctionBody, functionObject, argumentsList) {
  /* X */
  let _temp13 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp13
  });
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  // 1. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  const promiseCapability = _temp13;
  // 2. Let declResult be FunctionDeclarationInstantiation(functionObject, argumentsList).
  const declResult = yield* FunctionDeclarationInstantiation(functionObject, argumentsList);
  // 3. If declResult is not an abrupt completion, then
  if (!(declResult instanceof AbruptCompletion)) {
    /* X */
    let _temp14 = yield* AsyncFunctionStart(promiseCapability, FunctionBody);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! yield* AsyncFunctionStart(promiseCapability, FunctionBody) returned an abrupt completion", {
      cause: _temp14
    });
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  } else {
    /* X */
    let _temp15 = yield* Call(promiseCapability.Reject, Value.undefined, [declResult.Value]);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! yield* Call(promiseCapability.Reject, Value.undefined, [declResult.Value!]) returned an abrupt completion", {
      cause: _temp15
    });
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  }
  // 5. Return Completion { [[Type]]: return, [[Value]]: promiseCapability.[[Promise]], [[Target]]: empty }.
  return new Completion({
    Type: 'return',
    Value: promiseCapability.Promise,
    Target: undefined
  });
}
EvaluateBody_AsyncFunctionBody.section = 'https://tc39.es/ecma262/#sec-async-function-definitions-EvaluateBody'; // Initializer :
//   `=` AssignmentExpression
function* EvaluateBody_AssignmentExpression(AssignmentExpression, functionObject, argumentsList) {
  // 1. Assert: argumentsList is empty.
  Assert(argumentsList.length === 0, "argumentsList.length === 0");
  // 2. Assert: functionObject.[[ClassFieldInitializerName]] is not empty.
  Assert(functionObject.ClassFieldInitializerName !== undefined, "functionObject.ClassFieldInitializerName !== undefined");
  let value;
  // 3. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then
  if (IsAnonymousFunctionDefinition(AssignmentExpression)) {
    // a. Let value be NamedEvaluation of Initializer with argument functionObject.[[ClassFieldInitializerName]].
    value = yield* NamedEvaluation(AssignmentExpression, functionObject.ClassFieldInitializerName);
  } else {
    /* ReturnIfAbrupt */
    let _temp16 = yield* Evaluate(AssignmentExpression);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) return _temp16;
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    // 4. Else,
    // a. Let rhs be the result of evaluating AssignmentExpression.
    const rhs = _temp16;
    // b. Let value be ? GetValue(rhs).
    /* ReturnIfAbrupt */
    let _temp17 = yield* GetValue(rhs);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    value = _temp17;
  }
  // 5. Return Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
  /* X */
  let _temp18 = value;
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! value returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  return new Completion({
    Type: 'return',
    Value: _temp18,
    Target: undefined
  });
}

/** https://tc39.es/ecma262/#sec-runtime-semantics-evaluateclassstaticblockbody */
//    ClassStaticBlockBody : ClassStaticBlockStatementList
function* EvaluateClassStaticBlockBody({
  ClassStaticBlockStatementList
}, functionObject) {
  /* ReturnIfAbrupt */
  let _temp19 = yield* FunctionDeclarationInstantiation(functionObject, []);
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) return _temp19;
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  // 2. Return the result of evaluating ClassStaticBlockStatementList.
  return yield* Evaluate_FunctionStatementList(ClassStaticBlockStatementList);
}
EvaluateClassStaticBlockBody.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-evaluateclassstaticblockbody'; // FunctionBody : FunctionStatementList
// ConciseBody : ExpressionBody
// GeneratorBody : FunctionBody
// AsyncGeneratorBody : FunctionBody
// AsyncBody : FunctionBody
// AsyncConciseBody : ExpressionBody
// ClassStaticBlockBody : ClassStaticBlockStatementList
function EvaluateBody(Body, functionObject, argumentsList) {
  switch (Body.type) {
    case 'FunctionBody':
      return EvaluateBody_FunctionBody(Body, functionObject, argumentsList);
    case 'ConciseBody':
      return EvaluateBody_ConciseBody(Body, functionObject, argumentsList);
    case 'GeneratorBody':
      return EvaluateBody_GeneratorBody(Body, functionObject, argumentsList);
    case 'AsyncGeneratorBody':
      return EvaluateBody_AsyncGeneratorBody(Body, functionObject, argumentsList);
    case 'AsyncBody':
      return EvaluateBody_AsyncFunctionBody(Body, functionObject, argumentsList);
    case 'AsyncConciseBody':
      return EvaluateBody_AsyncConciseBody(Body, functionObject, argumentsList);
    case 'ClassStaticBlockBody':
      return EvaluateClassStaticBlockBody(Body, functionObject);
    default:
      return EvaluateBody_AssignmentExpression(Body, functionObject, argumentsList);
  }
}

/** https://tc39.es/ecma262/#sec-functiondeclarationinstantiation */
function* FunctionDeclarationInstantiation(func, argumentsList) {
  // 1. Let calleeContext be the running execution context.
  const calleeContext = surroundingAgent.runningExecutionContext;
  // 2. Let code be func.[[ECMAScriptCode]].
  const code = func.ECMAScriptCode;
  // 3. Let strict be func.[[Strict]].
  const strict = func.Strict;
  // 4. Let formals be func.[[FormalParameters]].
  const formals = func.FormalParameters;
  // 5. Let parameterNames be BoundNames of formals.
  const parameterNames = BoundNames(formals);
  // 6. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.
  const hasDuplicates = new JSStringSet(parameterNames).size !== parameterNames.length;
  // 7. Let simpleParameterList be IsSimpleParameterList of formals.
  const simpleParameterList = IsSimpleParameterList(formals);
  // 8. Let hasParameterExpressions be ContainsExpression of formals.
  const hasParameterExpressions = ContainsExpression(formals);
  // 9. Let varNames be the VarDeclaredNames of code.
  const varNames = VarDeclaredNames(code);
  // 10. Let varDeclarations be the VarScopedDeclarations of code.
  const varDeclarations = VarScopedDeclarations(code);
  // 11. Let lexicalNames be the LexicallyDeclaredNames of code.
  const lexicalNames = new JSStringSet(LexicallyDeclaredNames(code));
  // 12. Let functionNames be a new empty List.
  const functionNames = new JSStringSet();
  // 13. Let functionNames be a new empty List.
  const functionsToInitialize = [];
  // 14. For each d in varDeclarations, in reverse list order, do
  for (const d of [...varDeclarations].reverse()) {
    // a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
    if (d.type !== 'VariableDeclaration' && d.type !== 'ForBinding' && d.type !== 'BindingIdentifier') {
      // i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.
      Assert(d.type === 'FunctionDeclaration' || d.type === 'GeneratorDeclaration' || d.type === 'AsyncFunctionDeclaration' || d.type === 'AsyncGeneratorDeclaration', "d.type === 'FunctionDeclaration'\n             || d.type === 'GeneratorDeclaration'\n             || d.type === 'AsyncFunctionDeclaration'\n             || d.type === 'AsyncGeneratorDeclaration'");
      // ii. Let fn be the sole element of the BoundNames of d.
      const fn = BoundNames(d)[0];
      // iii. If fn is not an element of functionNames, then
      if (!functionNames.has(fn)) {
        // 1. Insert fn as the first element of functionNames.
        functionNames.add(fn);
        // 2. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
        // 3. Insert d as the first element of functionsToInitialize.
        functionsToInitialize.unshift(d);
      }
    }
  }
  // 15. Let argumentsObjectNeeded be true.
  let argumentsObjectNeeded = true;
  // If func.[[ThisMode]] is lexical, then
  if (func.ThisMode === 'lexical') {
    // a. NOTE: Arrow functions never have an arguments objects.
    // b. Set argumentsObjectNeeded to false.
    argumentsObjectNeeded = false;
  } else if (new JSStringSet(parameterNames).has('arguments')) {
    // a. Set argumentsObjectNeeded to false.
    argumentsObjectNeeded = false;
  } else if (hasParameterExpressions === false) {
    // a. If "arguments" is an element of functionNames or if "arguments" is an element of lexicalNames, then
    if (functionNames.has('arguments') || lexicalNames.has('arguments')) {
      // i. Set argumentsObjectNeeded to false.
      argumentsObjectNeeded = false;
    }
  }
  let env;
  // 19. If strict is true or if hasParameterExpressions is false, then
  if (strict || hasParameterExpressions === false) {
    // a. NOTE: Only a single lexical environment is needed for the parameters and top-level vars.
    // b. Let env be the LexicalEnvironment of calleeContext.
    env = calleeContext.LexicalEnvironment;
  } else {
    // a. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval
    //    calls in the formal parameter list are outside the environment where parameters are declared.
    // b. Let calleeEnv be the LexicalEnvironment of calleeContext.
    const calleeEnv = calleeContext.LexicalEnvironment;
    // c. Let env be NewDeclarativeEnvironment(calleeEnv).
    env = new DeclarativeEnvironmentRecord(calleeEnv);
    // d. Assert: The VariableEnvironment of calleeContext is calleeEnv.
    Assert(calleeContext.VariableEnvironment === calleeEnv, "calleeContext.VariableEnvironment === calleeEnv");
    // e. Set the LexicalEnvironment of calleeContext to env.
    calleeContext.LexicalEnvironment = env;
  }
  // 21. For each String paramName in parameterNames, do
  for (const paramName of parameterNames) {
    // a. Let alreadyDeclared be env.HasBinding(paramName).
    const alreadyDeclared = yield* env.HasBinding(paramName);
    // b. NOTE: Early errors ensure that duplicate parameter names can only occur in
    //    non-strict functions that do not have parameter default values or rest parameters.
    // c. If alreadyDeclared is false, then
    if (alreadyDeclared === Value.false) {
      /* X */
      let _temp = env.CreateMutableBinding(paramName, Value.false);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! env.CreateMutableBinding(paramName, Value.false) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      // ii. If hasDuplicates is true, then
      if (hasDuplicates === true) {
        /* X */
        let _temp2 = env.InitializeBinding(paramName, Value.undefined);
        /* node:coverage ignore next */
        if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! env.InitializeBinding(paramName, Value.undefined) returned an abrupt completion", {
          cause: _temp2
        });
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      }
    }
  }
  // 22. If argumentsObjectNeeded is true, then
  let parameterBindings;
  if (argumentsObjectNeeded === true) {
    let ao;
    // a. If strict is true or if simpleParameterList is false, then
    if (strict || simpleParameterList === false) {
      // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).
      ao = CreateUnmappedArgumentsObject(argumentsList);
    } else {
      // i. NOTE: mapped argument object is only provided for non-strict functions
      //    that don't have a rest parameter, any parameter default value initializers,
      //    or any destructured parameters.
      // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, env).
      ao = CreateMappedArgumentsObject(func, formals, argumentsList, env);
    }
    // c. If strict is true, then
    if (strict) {
      /* X */
      let _temp3 = env.CreateImmutableBinding(Value('arguments'), Value.false);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateImmutableBinding(Value('arguments'), Value.false) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    } else {
      /* X */
      let _temp4 = env.CreateMutableBinding(Value('arguments'), Value.false);
      /* node:coverage ignore next */
      if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateMutableBinding(Value('arguments'), Value.false) returned an abrupt completion", {
        cause: _temp4
      });
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    }
    // e. Call env.InitializeBinding("arguments", ao).
    yield* env.InitializeBinding(Value('arguments'), ao);
    // f. Let parameterBindings be a new List of parameterNames with "arguments" appended.
    parameterBindings = new JSStringSet(parameterNames);
    parameterBindings.add('arguments');
  } else {
    // a. Let parameterBindings be parameterNames.
    parameterBindings = new JSStringSet(parameterNames);
  }
  // 24. Let iteratorRecord be CreateListIteratorRecord(argumentsList).
  const iteratorRecord = CreateListIteratorRecord(argumentsList);
  // 25. If hasDuplicates is true, then
  if (hasDuplicates) {
    /* ReturnIfAbrupt */
    let _temp5 = yield* IteratorBindingInitialization_FormalParameters(formals, iteratorRecord, Value.undefined);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  } else {
    /* ReturnIfAbrupt */
    let _temp6 = yield* IteratorBindingInitialization_FormalParameters(formals, iteratorRecord, env);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  }
  let varEnv;
  // 27. If hasParameterExpressions is false, then
  if (hasParameterExpressions === false) {
    // a. NOTE: Only a single lexical environment is needed for the parameters and top-level vars.
    // b. Let instantiatedVarNames be a copy of the List parameterBindings.
    const instantiatedVarNames = new JSStringSet(parameterBindings);
    // c. For each n in varNames, do
    for (const n of varNames) {
      // i. If n is not an element of instantiatedVarNames, then
      if (!instantiatedVarNames.has(n)) {
        // 1. Append n to instantiatedVarNames.
        instantiatedVarNames.add(n);
        // 2. Perform ! env.CreateMutableBinding(n, false).
        /* X */
        let _temp7 = env.CreateMutableBinding(n, Value.false);
        /* node:coverage ignore next */
        if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateMutableBinding(n, Value.false) returned an abrupt completion", {
          cause: _temp7
        });
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        // 3. Call env.InitializeBinding(n, undefined).
        yield* env.InitializeBinding(n, Value.undefined);
      }
    }
    // d. Let varEnv be env.
    varEnv = env;
  } else {
    // a. NOTE: A separate Environment Record is needed to ensure that closures created by expressions
    //    in the formal parameter list do not have visibility of declarations in the function body.
    // b. Let varEnv be NewDeclarativeEnvironment(env).
    varEnv = new DeclarativeEnvironmentRecord(env);
    // c. Set the VariableEnvironment of calleeContext to varEnv.
    calleeContext.VariableEnvironment = varEnv;
    // d. Let instantiatedVarNames be a new empty List.
    const instantiatedVarNames = new JSStringSet();
    // e. For each n in varNames, do
    for (const n of varNames) {
      // If n is not an element of instantiatedVarNames, then
      if (!instantiatedVarNames.has(n)) {
        // 1. Append n to instantiatedVarNames.
        instantiatedVarNames.add(n);
        // 2. Perform ! varEnv.CreateMutableBinding(n, false).
        /* X */
        let _temp8 = varEnv.CreateMutableBinding(n, Value.false);
        /* node:coverage ignore next */
        if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
        /* node:coverage ignore next */
        if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! varEnv.CreateMutableBinding(n, Value.false) returned an abrupt completion", {
          cause: _temp8
        });
        /* node:coverage ignore next */
        if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        let initialValue;
        // 3. If n is not an element of parameterBindings or if n is an element of functionNames, let initialValue be undefined.
        if (!parameterBindings.has(n) || functionNames.has(n)) {
          initialValue = Value.undefined;
        } else {
          /* X */
          let _temp9 = env.GetBindingValue(n, Value.false);
          /* node:coverage ignore next */
          if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
          /* node:coverage ignore next */
          if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! env.GetBindingValue(n, Value.false) returned an abrupt completion", {
            cause: _temp9
          });
          /* node:coverage ignore next */
          if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
          // a. Let initialValue be ! env.GetBindingValue(n, false).
          initialValue = _temp9;
        }
        // 5. Call varEnv.InitializeBinding(n, initialValue).
        yield* varEnv.InitializeBinding(n, initialValue);
        // 6. NOTE: vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.
      }
    }
  }
  // 29. NOTE: Annex B.3.3.1 adds additional steps at this point.
  let lexEnv;
  // 30. If strict is false, then
  if (strict === false) {
    // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).
    lexEnv = new DeclarativeEnvironmentRecord(varEnv);
    // b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations
    //    so that a direct eval can determine whether any var scoped declarations introduced by the eval code
    //    conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions
    //    because a strict direct eval always places all declarations into a new Environment Record.
  } else {
    // a. Else, let lexEnv be varEnv.
    lexEnv = varEnv;
  }
  // 32. Set the LexicalEnvironment of calleeContext to lexEnv.
  calleeContext.LexicalEnvironment = lexEnv;
  // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.
  const lexDeclarations = LexicallyScopedDeclarations(code);
  // 34. For each element d in lexDeclarations, do
  for (const d of lexDeclarations) {
    // a. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal
    //    parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
    // b. For each element dn of the BoundNames of d, do
    for (const dn of BoundNames(d)) {
      // i. If IsConstantDeclaration of d is true, then
      if (IsConstantDeclaration(d)) {
        /* X */
        let _temp10 = lexEnv.CreateImmutableBinding(dn, Value.true);
        /* node:coverage ignore next */
        if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
        /* node:coverage ignore next */
        if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! lexEnv.CreateImmutableBinding(dn, Value.true) returned an abrupt completion", {
          cause: _temp10
        });
        /* node:coverage ignore next */
        if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
      } else {
        /* X */
        let _temp11 = lexEnv.CreateMutableBinding(dn, Value.false);
        /* node:coverage ignore next */
        if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
        /* node:coverage ignore next */
        if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! lexEnv.CreateMutableBinding(dn, Value.false) returned an abrupt completion", {
          cause: _temp11
        });
        /* node:coverage ignore next */
        if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
      }
    }
  }
  // 35. Let privateEnv be the PrivateEnvironment of calleeContext.
  const privateEnv = calleeContext.PrivateEnvironment;
  // 36. For each Parse Node f in functionsToInitialize, do
  for (const f of functionsToInitialize) {
    // a. Let fn be the sole element of the BoundNames of f.
    const fn = BoundNames(f)[0];
    // b. Let fo be InstantiateFunctionObject of f with argument lexEnv and privateEnv.
    const fo = InstantiateFunctionObject(f, lexEnv, privateEnv);
    // c. Perform ! varEnv.SetMutableBinding(fn, fo, false).
    /* X */
    let _temp12 = varEnv.SetMutableBinding(fn, fo, Value.false);
    /* node:coverage ignore next */
    if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! varEnv.SetMutableBinding(fn, fo, Value.false) returned an abrupt completion", {
      cause: _temp12
    });
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  }
  // 37. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
FunctionDeclarationInstantiation.section = 'https://tc39.es/ecma262/#sec-functiondeclarationinstantiation';

/** https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluation */
//   FunctionStatementList : [empty]
//
// (implicit)
//   FunctionStatementList : StatementList
function Evaluate_FunctionStatementList(FunctionStatementList) {
  return Evaluate_StatementList(FunctionStatementList);
}
Evaluate_FunctionStatementList.section = 'https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-iteratorbindinginitialization */
// FormalParameters :
//   [empty]
//   FormalParameterList `,` FunctionRestParameter
function* IteratorBindingInitialization_FormalParameters(FormalParameters, iteratorRecord, environment) {
  if (FormalParameters.length === 0) {
    // 1. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
  for (const FormalParameter of FormalParameters.slice(0, -1)) {
    /* ReturnIfAbrupt */
    let _temp = yield* IteratorBindingInitialization_FormalParameter(FormalParameter, iteratorRecord, environment);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
  }
  const last = FormalParameters[FormalParameters.length - 1];
  if (last.type === 'BindingRestElement') {
    return yield* IteratorBindingInitialization_FunctionRestParameter(last, iteratorRecord, environment);
  }
  return yield* IteratorBindingInitialization_FormalParameter(last, iteratorRecord, environment);
}
IteratorBindingInitialization_FormalParameters.section = 'https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-iteratorbindinginitialization'; // FormalParameter : BindingElement
function IteratorBindingInitialization_FormalParameter(BindingElement, iteratorRecord, environment) {
  // TODO
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment);
}

// FunctionRestParameter : BindingRestElement
function IteratorBindingInitialization_FunctionRestParameter(FunctionRestParameter, iteratorRecord, environment) {
  return IteratorBindingInitialization_BindingRestElement(FunctionRestParameter, iteratorRecord, environment);
}

// BindingElement :
//   SingleNameBinding
//   BindingPattern
function IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment) {
  if ('BindingPattern' in BindingElement) {
    return IteratorBindingInitialization_BindingPattern(BindingElement, iteratorRecord, environment);
  }
  return IteratorBindingInitialization_SingleNameBinding(BindingElement, iteratorRecord, environment);
}

// SingleNameBinding : BindingIdentifier Initializer?
function* IteratorBindingInitialization_SingleNameBinding({
  BindingIdentifier,
  Initializer
}, iteratorRecord, environment) {
  // 1. Let bindingId be StringValue of BindingIdentifier.
  const bindingId = StringValue(BindingIdentifier);
  // 2. Let lhs be ? ResolveBinding(bindingId, environment).
  /* ReturnIfAbrupt */
  let _temp2 = yield* ResolveBinding(bindingId, environment, BindingIdentifier.strict);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const lhs = _temp2;
  let v = Value.undefined;
  // 3. If iteratorRecord.[[Done]] is false, then
  if (iteratorRecord.Done === Value.false) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // a. Let next be ? IteratorStepValue(iteratorRecord).
    const next = _temp3;
    // d. If next is not DONE,
    if (next !== 'done') {
      v = next;
    }
  }
  // 5. If Initializer is present and v is undefined, then
  if (Initializer && v === Value.undefined) {
    if (IsAnonymousFunctionDefinition(Initializer)) {
      /* ReturnIfAbrupt */
      let _temp4 = yield* NamedEvaluation(Initializer, bindingId);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      v = _temp4;
    } else {
      /* ReturnIfAbrupt */
      let _temp5 = yield* Evaluate(Initializer);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) return _temp5;
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      const defaultValue = _temp5;
      /* ReturnIfAbrupt */
      let _temp6 = yield* GetValue(defaultValue);
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) return _temp6;
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      v = _temp6;
    }
  }
  // 6. If environment is undefined, return ? PutValue(lhs, v).
  if (environment === Value.undefined) {
    return yield* PutValue(lhs, v);
  }
  // 7. Return InitializeReferencedBinding(lhs, v).
  /* X */
  let _temp7 = v;
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! v returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  return yield* InitializeReferencedBinding(lhs, _temp7);
}

// BindingRestElement :
//   `...` BindingIdentifier
//   `...` BindingPattern
function* IteratorBindingInitialization_BindingRestElement({
  BindingIdentifier,
  BindingPattern
}, iteratorRecord, environment) {
  if (BindingIdentifier) {
    /* ReturnIfAbrupt */
    let _temp8 = yield* ResolveBinding(StringValue(BindingIdentifier), environment, BindingIdentifier.strict);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    // 1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).
    const lhs = _temp8;
    // 2. Let A be ! ArrayCreate(0).
    /* X */
    let _temp9 = ArrayCreate(0);
    /* node:coverage ignore next */
    if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    const A = _temp9;
    // 3. Let n be 0.
    let n = 0;
    // 4. Repeat,
    while (true) {
      let next = 'done';
      // a. If iteratorRecord.[[Done]] is false, then
      if (iteratorRecord.Done === Value.false) {
        /* ReturnIfAbrupt */
        let _temp10 = yield* IteratorStepValue(iteratorRecord);
        /* node:coverage ignore next */
        if (_temp10 instanceof AbruptCompletion) return _temp10;
        /* node:coverage ignore next */
        if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
        // i. Let next be ? IteratorStepValue(iteratorRecord).
        next = _temp10;
      }
      if (next === 'done') {
        // i. If environment is undefined, return ? PutValue(lhs, A).
        if (environment === Value.undefined) {
          return yield* PutValue(lhs, A);
        }
        // ii. Return InitializeReferencedBinding(lhs, A).
        return yield* InitializeReferencedBinding(lhs, A);
      }
      // f. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), next).
      /* X */
      let _temp12 = ToString(F(n));
      /* node:coverage ignore next */
      if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
        cause: _temp12
      });
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      /* X */
      let _temp11 = CreateDataPropertyOrThrow(A, _temp12, next);
      /* node:coverage ignore next */
      if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
      /* node:coverage ignore next */
      if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(F(n))), next) returned an abrupt completion", {
        cause: _temp11
      });
      /* node:coverage ignore next */
      if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
      // g. Set n to n + 1.
      n += 1;
    }
  } else {
    /* X */
    let _temp13 = ArrayCreate(0);
    /* node:coverage ignore next */
    if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
      cause: _temp13
    });
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    // 1. Let A be ! ArrayCreate(0).
    const A = _temp13;
    // 2. Let n be 0.
    let n = 0;
    // 3. Repeat,
    while (true) {
      let next = 'done';
      // a. If iteratorRecord.[[Done]] is false, then
      if (iteratorRecord.Done === Value.false) {
        /* ReturnIfAbrupt */
        let _temp14 = yield* IteratorStepValue(iteratorRecord);
        /* node:coverage ignore next */
        if (_temp14 instanceof AbruptCompletion) return _temp14;
        /* node:coverage ignore next */
        if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
        // i. Let next be ? IteratorStepValue(iteratorRecord).
        next = _temp14;
      }
      // b. If next is done, then
      if (next === 'done') {
        // i. Return the result of performing BindingInitialization of BindingPattern with A and environment as the arguments.
        return yield* BindingInitialization(BindingPattern, A, environment);
      }
      // f. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), next).
      /* X */
      let _temp16 = ToString(F(n));
      /* node:coverage ignore next */
      if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
      /* node:coverage ignore next */
      if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
        cause: _temp16
      });
      /* node:coverage ignore next */
      if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
      /* ReturnIfAbrupt */
      /* node:coverage ignore next */
      if (next && typeof next === 'object' && 'next' in next) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (next instanceof AbruptCompletion) return next;
      /* node:coverage ignore next */
      if (next instanceof Completion) next = next.Value;
      /* X */
      let _temp15 = CreateDataPropertyOrThrow(A, _temp16, next);
      /* node:coverage ignore next */
      if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
      /* node:coverage ignore next */
      if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(F(n))), Q(next)) returned an abrupt completion", {
        cause: _temp15
      });
      /* node:coverage ignore next */
      if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
      // g. Set n to n + 1.
      n += 1;
    }
  }
}
function* IteratorBindingInitialization_BindingPattern({
  BindingPattern,
  Initializer
}, iteratorRecord, environment) {
  let v = Value.undefined;
  // 1. If iteratorRecord.[[Done]] is false, then
  if (iteratorRecord.Done === Value.false) {
    /* ReturnIfAbrupt */
    let _temp17 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    // a. Let next be ? IteratorStepValue(iteratorRecord).
    const next = _temp17;
    if (next !== 'done') {
      v = next;
    }
  }
  // 3. If Initializer is present and v is undefined, then
  if (Initializer && v instanceof UndefinedValue) {
    /* ReturnIfAbrupt */
    let _temp18 = yield* Evaluate(Initializer);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) return _temp18;
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    // a. Let defaultValue be the result of evaluating Initializer.
    const defaultValue = _temp18;
    // b. Set v to ? GetValue(defaultValue).
    /* ReturnIfAbrupt */
    let _temp19 = yield* GetValue(defaultValue);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) return _temp19;
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    v = _temp19;
  }
  // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.
  /* X */
  let _temp20 = v;
  /* node:coverage ignore next */
  if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) _temp20 = skipDebugger(_temp20);
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) throw new Assert.Error("! v returned an abrupt completion", {
    cause: _temp20
  });
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  return yield* BindingInitialization(BindingPattern, _temp20, environment);
}
function* IteratorDestructuringAssignmentEvaluation$1(node, iteratorRecord) {
  Assert(node.type === 'Elision', "node.type === 'Elision'");
  // 1. If iteratorRecord.[[Done]] is false, then
  if (iteratorRecord.Done === Value.false) {
    /* ReturnIfAbrupt */
    let _temp21 = yield* IteratorStep(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) return _temp21;
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  }
  // 2. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
function* IteratorBindingInitialization_ArrayBindingPattern({
  BindingElementList,
  BindingRestElement
}, iteratorRecord, environment) {
  for (const BindingElement of BindingElementList) {
    if (BindingElement.type === 'Elision') {
      /* ReturnIfAbrupt */
      let _temp22 = yield* IteratorDestructuringAssignmentEvaluation$1(BindingElement, iteratorRecord);
      /* node:coverage ignore next */
      if (_temp22 instanceof AbruptCompletion) return _temp22;
      /* node:coverage ignore next */
      if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    } else {
      /* ReturnIfAbrupt */
      let _temp23 = yield* IteratorBindingInitialization_BindingElement(BindingElement, iteratorRecord, environment);
      /* node:coverage ignore next */
      if (_temp23 instanceof AbruptCompletion) return _temp23;
      /* node:coverage ignore next */
      if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    }
  }
  if (BindingRestElement) {
    return yield* IteratorBindingInitialization_BindingRestElement(BindingRestElement, iteratorRecord, environment);
  }
  return NormalCompletion(undefined);
}

/** https://tc39.es/ecma262/#sec-return-statement-runtime-semantics-evaluation */
//  ReturnStatement :
//    `return` `;`
//    `return` Expression `;`
function* Evaluate_ReturnStatement({
  Expression
}) {
  if (!Expression) {
    // 1. Return Completion { [[Type]]: return, [[Value]]: undefined, [[Target]]: empty }.
    return new Completion({
      Type: 'return',
      Value: Value.undefined,
      Target: undefined
    });
  }
  // 1. Let exprRef be the result of evaluating Expression.
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(Expression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const exprRef = _temp;
  // 1. Let exprValue be ? GetValue(exprRef).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(exprRef);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  let exprValue = _temp2;
  // 1. If ! GetGeneratorKind() is async, set exprValue to ? Await(exprValue).
  /* X */
  let _temp3 = GetGeneratorKind();
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! GetGeneratorKind() returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  if (_temp3 === 'async') {
    /* ReturnIfAbrupt */
    let _temp4 = yield* Await(exprValue);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    exprValue = _temp4;
  }
  // 1. Return Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }.
  return new Completion({
    Type: 'return',
    Value: exprValue,
    Target: undefined
  });
}
Evaluate_ReturnStatement.section = 'https://tc39.es/ecma262/#sec-return-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-grouping-operator-runtime-semantics-evaluation */
function* Evaluate_ParenthesizedExpression({
  Expression
}) {
  // 1. Return the result of evaluating Expression. This may be of type Reference.
  return yield* Evaluate(Expression);
}
Evaluate_ParenthesizedExpression.section = 'https://tc39.es/ecma262/#sec-grouping-operator-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation */
//   MemberExpression : MemberExpression `[` Expression `]`
//   CallExpression : CallExpression `[` Expression `]`
function* Evaluate_MemberExpression_Expression({
  strict,
  MemberExpression,
  Expression
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(MemberExpression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let baseReference be the result of evaluating |MemberExpression|.
  const baseReference = _temp;
  // 2. Let baseValue be ? GetValue(baseReference).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(baseReference);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const baseValue = _temp2;
  // 3. If the code matched by this |MemberExpression| is strict mode code, let strict be true; else let strict be false.
  // 4. Return ? EvaluatePropertyAccessWithExpressionKey(baseValue, |Expression|, strict).
  return yield* EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict);
}
Evaluate_MemberExpression_Expression.section = 'https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation */
//   MemberExpression : MemberExpression `.` IdentifierName
//   CallExpression : CallExpression `.` IdentifierName
function* Evaluate_MemberExpression_IdentifierName({
  strict,
  MemberExpression,
  IdentifierName
}) {
  /* ReturnIfAbrupt */
  let _temp3 = yield* Evaluate(MemberExpression);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 1. Let baseReference be the result of evaluating |MemberExpression|.
  const baseReference = _temp3;
  // 2. Let baseValue be ? GetValue(baseReference).
  /* ReturnIfAbrupt */
  let _temp4 = yield* GetValue(baseReference);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const baseValue = _temp4;
  // 3. If the code matched by this |MemberExpression| is strict mode code, let strict be true; else let strict be false.
  // 4. Return ! EvaluatePropertyAccessWithIdentifierKey(baseValue, |IdentifierName|, strict).
  /* X */
  let _temp5 = EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName!, strict) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  return _temp5;
}
Evaluate_MemberExpression_IdentifierName.section = 'https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation */
//   MemberExpression : MemberExpression `.` PrivateIdentifier
//   CallExpression : CallExpression `.` PrivateIdentifier
function* Evaluate_MemberExpression_PrivateIdentifier({
  MemberExpression,
  PrivateIdentifier
}) {
  /* ReturnIfAbrupt */
  let _temp6 = yield* Evaluate(MemberExpression);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  // 1. Let baseReference be the result of evaluating MemberExpression.
  const baseReference = _temp6;
  // 2. Let baseValue be ? GetValue(baseReference).
  /* ReturnIfAbrupt */
  let _temp7 = yield* GetValue(baseReference);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const baseValue = _temp7;
  // 3. Let fieldNameString be the StringValue of PrivateIdentifier.
  const fieldNameString = StringValue(PrivateIdentifier);
  // 4. Return ! MakePrivateReference(bv, fieldNameString).
  /* X */
  let _temp8 = MakePrivateReference(baseValue, fieldNameString);
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! MakePrivateReference(baseValue, fieldNameString) returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  return _temp8;
}
Evaluate_MemberExpression_PrivateIdentifier.section = 'https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation */
//   MemberExpression :
//     MemberExpression `[` Expression `]`
//     MemberExpression `.` IdentifierName
//   CallExpression :
//     CallExpression `[` Expression `]`
//     CallExpression `.` IdentifierName
function Evaluate_MemberExpression(MemberExpression) {
  switch (true) {
    case !!MemberExpression.Expression:
      return Evaluate_MemberExpression_Expression(MemberExpression);
    case !!MemberExpression.IdentifierName:
      return Evaluate_MemberExpression_IdentifierName(MemberExpression);
    case !!MemberExpression.PrivateIdentifier:
      return Evaluate_MemberExpression_PrivateIdentifier(MemberExpression);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_MemberExpression', MemberExpression);
  }
}
Evaluate_MemberExpression.section = 'https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-evaluate-expression-key-property-access */
function* EvaluatePropertyAccessWithExpressionKey(baseValue, expression, strict) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(expression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let propertyNameReference be the result of evaluating expression.
  const propertyNameReference = _temp;
  // 2. Let propertyNameValue be ? GetValue(propertyNameReference).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(propertyNameReference);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const propertyNameValue = _temp2;
  // 3. Return the Reference Record { [[Base]]: bv, [[ReferencedName]]: propertyKey, [[Strict]]: strict, [[ThisValue]]: empty }.
  return new ReferenceRecord({
    Base: baseValue,
    ReferencedName: propertyNameValue,
    Strict: strict ? Value.true : Value.false,
    ThisValue: undefined
  });
}
EvaluatePropertyAccessWithExpressionKey.section = 'https://tc39.es/ecma262/#sec-evaluate-expression-key-property-access';
/** https://tc39.es/ecma262/#sec-evaluate-identifier-key-property-access */
function EvaluatePropertyAccessWithIdentifierKey(baseValue, identifierName, strict) {
  // 1. Assert: identifierName is an IdentifierName.
  Assert(identifierName.type === 'IdentifierName', "identifierName.type === 'IdentifierName'");
  // 3. Let propertyNameString be StringValue of IdentifierName
  const propertyNameString = StringValue(identifierName);
  // 4. Return the Reference Record { [[Base]]: bv, [[ReferencedName]]: propertyNameString, [[Strict]]: strict, [[ThisValue]]: empty }.
  return new ReferenceRecord({
    Base: baseValue,
    ReferencedName: propertyNameString,
    Strict: strict ? Value.true : Value.false,
    ThisValue: undefined
  });
}
EvaluatePropertyAccessWithIdentifierKey.section = 'https://tc39.es/ecma262/#sec-evaluate-identifier-key-property-access';

/** https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation */
//   LexicalBinding :
//     BindingIdentifier
//     BindingIdentifier Initializer
function* Evaluate_LexicalBinding_BindingIdentifier({
  BindingIdentifier,
  Initializer,
  strict
}) {
  if (Initializer) {
    // 1. Let bindingId be StringValue of BindingIdentifier.
    const bindingId = StringValue(BindingIdentifier);
    // 2. Let lhs be ResolveBinding(bindingId).
    /* X */
    let _temp = ResolveBinding(bindingId, undefined, strict);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ResolveBinding(bindingId, undefined, strict) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const lhs = _temp;
    let value;
    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
    if (IsAnonymousFunctionDefinition(Initializer)) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* NamedEvaluation(Initializer, bindingId);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      // a. Let value be NamedEvaluation of Initializer with argument bindingId.
      value = _temp2;
    } else {
      /* ReturnIfAbrupt */
      let _temp3 = yield* Evaluate(Initializer);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // 4. Else,
      // a. Let rhs be the result of evaluating Initializer.
      const rhs = _temp3;
      // b. Let value be ? GetValue(rhs).
      /* ReturnIfAbrupt */
      let _temp4 = yield* GetValue(rhs);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      value = _temp4;
    }
    // 5. Return InitializeReferencedBinding(lhs, value).
    return yield* InitializeReferencedBinding(lhs, value);
  } else {
    // 1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).
    const lhs = yield* ResolveBinding(StringValue(BindingIdentifier), undefined, strict);
    // 2. Return InitializeReferencedBinding(lhs, undefined).
    return yield* InitializeReferencedBinding(lhs, Value.undefined);
  }
}
Evaluate_LexicalBinding_BindingIdentifier.section = 'https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation */
//   LexicalBinding : BindingPattern Initializer
function* Evaluate_LexicalBinding_BindingPattern(LexicalBinding) {
  const {
    BindingPattern,
    Initializer
  } = LexicalBinding;
  /* ReturnIfAbrupt */
  let _temp5 = yield* Evaluate(Initializer);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const rhs = _temp5;
  /* ReturnIfAbrupt */
  let _temp6 = yield* GetValue(rhs);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const value = _temp6;
  const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  return yield* BindingInitialization(BindingPattern, value, env);
}
Evaluate_LexicalBinding_BindingPattern.section = 'https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation';
function* Evaluate_LexicalBinding(LexicalBinding) {
  switch (true) {
    case !!LexicalBinding.BindingIdentifier:
      return yield* Evaluate_LexicalBinding_BindingIdentifier(LexicalBinding);
    case !!LexicalBinding.BindingPattern:
      return yield* Evaluate_LexicalBinding_BindingPattern(LexicalBinding);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_LexicalBinding', LexicalBinding);
  }
}

/** https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation */
//   BindingList : BindingList `,` LexicalBinding
//
// (implicit)
//   BindingList : LexicalBinding
function* Evaluate_BindingList(BindingList) {
  // 1. Let next be the result of evaluating BindingList.
  // 2. ReturnIfAbrupt(next).
  // 3. Return the result of evaluating LexicalBinding.
  let next;
  for (const LexicalBinding of BindingList) {
    next = yield* Evaluate_LexicalBinding(LexicalBinding);
    /* ReturnIfAbrupt */
    /* node:coverage ignore next */
    if (next && typeof next === 'object' && 'next' in next) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (next instanceof AbruptCompletion) return next;
    /* node:coverage ignore next */
    if (next instanceof Completion) next = next.Value;
  }
  return next;
}
Evaluate_BindingList.section = 'https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation */
//   LexicalDeclaration : LetOrConst BindingList `;`
function* Evaluate_LexicalDeclaration({
  BindingList
}) {
  /* ReturnIfAbrupt */
  let _temp7 = yield* Evaluate_BindingList(BindingList);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 3. Return NormalCompletion(empty).
  return undefined;
}
Evaluate_LexicalDeclaration.section = 'https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-object-initializer-runtime-semantics-evaluation */
//   ObjectLiteral :
//     `{` `}`
//     `{` PropertyDefinitionList `}`
//     `{` PropertyDefinitionList `,` `}`
function* Evaluate_ObjectLiteral({
  PropertyDefinitionList
}) {
  // 1. Let obj be OrdinaryObjectCreate(%Object.prototype%).
  const obj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  if (PropertyDefinitionList.length === 0) {
    return obj;
  }
  // 2. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.
  /* ReturnIfAbrupt */
  let _temp = yield* PropertyDefinitionEvaluation_PropertyDefinitionList(PropertyDefinitionList, obj, Value.true);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Return obj.
  return obj;
}
Evaluate_ObjectLiteral.section = 'https://tc39.es/ecma262/#sec-object-initializer-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation */
//   PropertyDefinitionList :
//     PropertyDefinitionList `,` PropertyDefinition
function* PropertyDefinitionEvaluation_PropertyDefinitionList(PropertyDefinitionList, object, enumerable) {
  for (const PropertyDefinition of PropertyDefinitionList) {
    /* ReturnIfAbrupt */
    let _temp = yield* PropertyDefinitionEvaluation_PropertyDefinition(PropertyDefinition, object, enumerable);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
  }
}
PropertyDefinitionEvaluation_PropertyDefinitionList.section = 'https://tc39.es/ecma262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation'; // PropertyDefinition :
//   `...` AssignmentExpression
//   IdentifierReference
//   PropertyName `:` AssignmentExpression
function* PropertyDefinitionEvaluation_PropertyDefinition(PropertyDefinition, object, enumerable) {
  switch (PropertyDefinition.type) {
    case 'IdentifierReference':
      return yield* PropertyDefinitionEvaluation_PropertyDefinition_IdentifierReference(PropertyDefinition, object, enumerable);
    case 'PropertyDefinition':
      break;
    case 'MethodDefinition':
    case 'GeneratorMethod':
    case 'AsyncMethod':
    case 'AsyncGeneratorMethod':
      return yield* MethodDefinitionEvaluation(PropertyDefinition, object, enumerable);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('PropertyDefinitionEvaluation_PropertyDefinition', PropertyDefinition);
  }
  // PropertyDefinition :
  //   PropertyName `:` AssignmentExpression
  //   `...` AssignmentExpression
  const {
    PropertyName,
    AssignmentExpression
  } = PropertyDefinition;
  if (!PropertyName) {
    /* ReturnIfAbrupt */
    let _temp2 = yield* Evaluate(AssignmentExpression);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // 1. Let exprValue be the result of evaluating AssignmentExpression.
    const exprValue = _temp2;
    // 2. Let fromValue be ? GetValue(exprValue).
    /* ReturnIfAbrupt */
    let _temp3 = yield* GetValue(exprValue);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const fromValue = _temp3;
    // 3. Let excludedNames be a new empty List.
    const excludedNames = [];
    // 4. Return ? CopyDataProperties(object, fromValue, excludedNames).
    return yield* CopyDataProperties(object, fromValue, excludedNames);
  }
  // 1. Let propKey be the result of evaluating PropertyName.
  /* ReturnIfAbrupt */
  let _temp4 = yield* Evaluate_PropertyName(PropertyName);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const propKey = _temp4;
  // 2. ReturnIfAbrupt(propKey).
  // 3. If this PropertyDefinition is contained within a Script which is being evaluated for JSON.parse, then
  let isProtoSetter;
  if (surroundingAgent.runningExecutionContext?.HostDefined?.[kInternal]?.json) {
    isProtoSetter = false;
  } else if (!IsComputedPropertyKey(PropertyName) && propKey.stringValue() === '__proto__') {
    // 3. Else, If _propKey_ is the String value *"__proto__"* and if IsComputedPropertyKey(|PropertyName|) is *false*,
    // a. Let isProtoSetter be true.
    isProtoSetter = true;
  } else {
    // 4. Else,
    // a. Let isProtoSetter be false.
    isProtoSetter = false;
  }
  let propValue;
  // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and isProtoSetter is false, then
  if (IsAnonymousFunctionDefinition(AssignmentExpression) && !isProtoSetter) {
    // a. Let propValue be NamedEvaluation of AssignmentExpression with argument propKey.
    propValue = yield* NamedEvaluation(AssignmentExpression, propKey);
  } else {
    /* ReturnIfAbrupt */
    let _temp5 = yield* Evaluate(AssignmentExpression);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // 6. Else,
    // a. Let exprValueRef be the result of evaluating AssignmentExpression.
    const exprValueRef = _temp5;
    // b. Let propValue be ? GetValue(exprValueRef).
    /* ReturnIfAbrupt */
    let _temp6 = yield* GetValue(exprValueRef);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    propValue = _temp6;
  }
  // 7. If isProtoSetter is true, then
  if (isProtoSetter) {
    // a. If Type(propValue) is either Object or Null, then
    if (propValue instanceof ObjectValue || propValue instanceof NullValue) {
      // i. Return object.[[SetPrototypeOf]](propValue).
      return yield* object.SetPrototypeOf(propValue);
    }
    // b. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
  // 8. Assert: enumerable is true.
  Assert(enumerable === Value.true, "enumerable === Value.true");
  // 9. Assert: object is an ordinary, extensible object with no non-configurable properties.
  // 10. Return ! CreateDataPropertyOrThrow(object, propKey, propValue).
  /* X */
  let _temp8 = propValue;
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! propValue returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  /* X */
  let _temp7 = CreateDataPropertyOrThrow(object, propKey, _temp8);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(object, propKey as PropertyKeyValue, X(propValue)) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  return _temp7;
}

// PropertyDefinition : IdentifierReference
function* PropertyDefinitionEvaluation_PropertyDefinition_IdentifierReference(IdentifierReference, object, enumerable) {
  // 1. Let propName be StringValue of IdentifierReference.
  const propName = StringValue(IdentifierReference);
  // 2. Let exprValue be the result of evaluating IdentifierReference.
  /* ReturnIfAbrupt */
  let _temp9 = yield* Evaluate(IdentifierReference);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const exprValue = _temp9;
  // 3. Let propValue be ? GetValue(exprValue).
  /* ReturnIfAbrupt */
  let _temp10 = yield* GetValue(exprValue);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const propValue = _temp10;
  // 4. Assert: enumerable is true.
  Assert(enumerable === Value.true, "enumerable === Value.true");
  // 5. Assert: object is an ordinary, extensible object with no non-configurable properties.
  // 6. Return ! CreateDataPropertyOrThrow(object, propName, propValue).
  /* X */
  let _temp11 = CreateDataPropertyOrThrow(object, propName, propValue);
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(object, propName, propValue) returned an abrupt completion", {
    cause: _temp11
  });
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  return _temp11;
}

/** https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluation */
//   FunctionExpression :
//     `function` `(` FormalParameters `)` `{` FunctionBody `}`
//     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
function Evaluate_FunctionExpression(FunctionExpression) {
  // 1. Return InstantiateOrdinaryFunctionExpression of FunctionExpression.
  return InstantiateOrdinaryFunctionExpression(FunctionExpression);
}
Evaluate_FunctionExpression.section = 'https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-namedevaluation */
//   FunctionExpression :
//     `function` `(` FormalParameters `)` `{` FunctionBody `}`
function NamedEvaluation_FunctionExpression(FunctionExpression, name) {
  return InstantiateOrdinaryFunctionExpression(FunctionExpression, name);
}
NamedEvaluation_FunctionExpression.section = 'https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-namedevaluation';
/** https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-namedevaluation */
//   GeneratorExpression :
//     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
function NamedEvaluation_GeneratorExpression(GeneratorExpression, name) {
  return InstantiateGeneratorFunctionExpression(GeneratorExpression, name);
}
NamedEvaluation_GeneratorExpression.section = 'https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-namedevaluation';
/** https://tc39.es/ecma262/#sec-async-function-definitions-runtime-semantics-namedevaluation */
//   AsyncFunctionExpression :
//     `async` `function` `(` FormalParameters `)` `{` AsyncBody `}`
function NamedEvaluation_AsyncFunctionExpression(AsyncFunctionExpression, name) {
  return InstantiateAsyncFunctionExpression(AsyncFunctionExpression, name);
}
NamedEvaluation_AsyncFunctionExpression.section = 'https://tc39.es/ecma262/#sec-async-function-definitions-runtime-semantics-namedevaluation';
/** https://tc39.es/ecma262/#sec-asyncgenerator-definitions-namedevaluation */
//   AsyncGeneratorExpression :
//     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
function NamedEvaluation_AsyncGeneratorExpression(AsyncGeneratorExpression, name) {
  return InstantiateAsyncGeneratorFunctionExpression(AsyncGeneratorExpression, name);
}
NamedEvaluation_AsyncGeneratorExpression.section = 'https://tc39.es/ecma262/#sec-asyncgenerator-definitions-namedevaluation';
/** https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-namedevaluation */
//   ArrowFunction :
//     ArrowParameters `=>` ConciseBody
function NamedEvaluation_ArrowFunction(ArrowFunction, name) {
  return InstantiateArrowFunctionExpression(ArrowFunction, name);
}
NamedEvaluation_ArrowFunction.section = 'https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-namedevaluation';
/** https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-namedevaluation */
//   AsyncArrowFunction :
//     ArrowParameters `=>` AsyncConciseBody
function NamedEvaluation_AsyncArrowFunction(AsyncArrowFunction, name) {
  return InstantiateAsyncArrowFunctionExpression(AsyncArrowFunction, name);
}
NamedEvaluation_AsyncArrowFunction.section = 'https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-namedevaluation';
/** https://tc39.es/ecma262/#sec-class-definitions-runtime-semantics-namedevaluation */
//   ClassExpression : `class` ClassTail
function* NamedEvaluation_ClassExpression(ClassExpression, name) {
  const {
    ClassTail
  } = ClassExpression;
  // 1. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and name.
  let value = yield* ClassDefinitionEvaluation(ClassTail, Value.undefined, name);
  // 2. ReturnIfAbrupt(value).
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (value && typeof value === 'object' && 'next' in value) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (value instanceof AbruptCompletion) return value;
  /* node:coverage ignore next */
  if (value instanceof Completion) value = value.Value;
  // 3. Set value.[[SourceText]] to the source text matched by ClassExpression.
  value.SourceText = sourceTextMatchedBy(ClassExpression);
  // 4. Return value.
  return value;
}
NamedEvaluation_ClassExpression.section = 'https://tc39.es/ecma262/#sec-class-definitions-runtime-semantics-namedevaluation';
function* NamedEvaluation(F, name) {
  switch (F.type) {
    case 'FunctionExpression':
      return NamedEvaluation_FunctionExpression(F, name);
    case 'GeneratorExpression':
      return NamedEvaluation_GeneratorExpression(F, name);
    case 'AsyncFunctionExpression':
      return NamedEvaluation_AsyncFunctionExpression(F, name);
    case 'AsyncGeneratorExpression':
      return NamedEvaluation_AsyncGeneratorExpression(F, name);
    case 'ArrowFunction':
      return NamedEvaluation_ArrowFunction(F, name);
    case 'AsyncArrowFunction':
      return NamedEvaluation_AsyncArrowFunction(F, name);
    case 'ClassExpression':
      return yield* NamedEvaluation_ClassExpression(F, name);
    case 'ParenthesizedExpression':
      return yield* NamedEvaluation(F.Expression, name);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('NamedEvaluation', F);
  }
}

/** https://tc39.es/ecma262/#sec-try-statement-runtime-semantics-evaluation */
//   TryStatement :
//     `try` Block Catch
//     `try` Block Finally
//     `try` Block Catch Finally
function Evaluate_TryStatement(TryStatement) {
  switch (true) {
    case !!TryStatement.Catch && !TryStatement.Finally:
      return Evaluate_TryStatement_BlockCatch(TryStatement);
    case !TryStatement.Catch && !!TryStatement.Finally:
      return Evaluate_TryStatement_BlockFinally(TryStatement);
    case !!TryStatement.Catch && !!TryStatement.Finally:
      return Evaluate_TryStatement_BlockCatchFinally(TryStatement);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_TryStatement', TryStatement);
  }
}
Evaluate_TryStatement.section = 'https://tc39.es/ecma262/#sec-try-statement-runtime-semantics-evaluation'; // TryStatement : `try` Block Catch
function* Evaluate_TryStatement_BlockCatch({
  Block,
  Catch
}) {
  // 1. Let B be the result of evaluating Block.
  const B = EnsureCompletion(yield* Evaluate(Block));
  // 2. If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with argument B.[[Value]].
  let C;
  if (B.Type === 'throw') {
    C = EnsureCompletion(yield* CatchClauseEvaluation(Catch, B.Value));
  } else {
    // 3. Else, let C be B.
    C = B;
  }
  // 3. Return Completion(UpdateEmpty(C, undefined)).
  return Completion(UpdateEmpty(C, Value.undefined));
}

// TryStatement : `try` Block Finally
function* Evaluate_TryStatement_BlockFinally({
  Block,
  Finally
}) {
  // 1. Let B be the result of evaluating Block.
  const B = EnsureCompletion(yield* Evaluate(Block));
  // 1. Let F be the result of evaluating Finally.
  let F = EnsureCompletion(yield* Evaluate(Finally));
  // 1. If F.[[Type]] is normal, set F to B.
  if (F.Type === 'normal') {
    F = B;
  }
  // 1. Return Completion(UpdateEmpty(F, undefined)).
  return Completion(UpdateEmpty(F, Value.undefined));
}

// TryStatement : `try` Block Catch Finally
function* Evaluate_TryStatement_BlockCatchFinally({
  Block,
  Catch,
  Finally
}) {
  // 1. Let B be the result of evaluating Block.
  const B = EnsureCompletion(yield* Evaluate(Block));
  // 2. If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with argument B.[[Value]].
  let C;
  if (B.Type === 'throw') {
    C = EnsureCompletion(yield* CatchClauseEvaluation(Catch, B.Value));
  } else {
    // 3. Else, let C be B.
    C = B;
  }
  // 4. Let F be the result of evaluating Finally.
  let F = EnsureCompletion(yield* Evaluate(Finally));
  // 5. If F.[[Type]] is normal, set F to C.
  if (F.Type === 'normal') {
    F = C;
  }
  // 6. Return Completion(UpdateEmpty(F, undefined)).
  return Completion(UpdateEmpty(F, Value.undefined));
}

/** https://tc39.es/ecma262/#sec-runtime-semantics-catchclauseevaluation */
//  Catch :
//    `catch` Block
//    `catch` `(` CatchParameter `)` Block
function* CatchClauseEvaluation({
  CatchParameter,
  Block
}, thrownValue) {
  if (!CatchParameter) {
    // 1. Return the result of evaluating Block.
    return yield* Evaluate(Block);
  }
  // 1. Let oldEnv be the running execution context's LexicalEnvironment.
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).
  const catchEnv = new DeclarativeEnvironmentRecord(oldEnv);
  // 3. For each element argName of the BoundNames of CatchParameter, do
  for (const argName of BoundNames(CatchParameter)) {
    /* X */
    let _temp = catchEnv.CreateMutableBinding(argName, Value.false);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! catchEnv.CreateMutableBinding(argName, Value.false) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
  }
  // 4. Set the running execution context's LexicalEnvironment to catchEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = catchEnv;
  // 5. Let status be BindingInitialization of CatchParameter with arguments thrownValue and catchEnv.
  const status = yield* BindingInitialization(CatchParameter, thrownValue, catchEnv);
  // 6. If status is an abrupt completion, then
  if (status instanceof AbruptCompletion) {
    // a. Set the running execution context's LexicalEnvironment to oldEnv.
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
    // b. Return Completion(status).
    return Completion(status);
  }
  // 7. Let B be the result of evaluating Block.
  const B = EnsureCompletion(yield* Evaluate(Block));
  // 8. Set the running execution context's LexicalEnvironment to oldEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  // 9. Return Completion(B).
  return Completion(B);
}
CatchClauseEvaluation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-catchclauseevaluation';

/** https://tc39.es/ecma262/#sec-blockdeclarationinstantiation */
function* BlockDeclarationInstantiation(code, env) {
  // 1. Assert: env is a declarative Environment Record.
  Assert(env instanceof DeclarativeEnvironmentRecord, "env instanceof DeclarativeEnvironmentRecord");
  // 2. Let declarations be the LexicallyScopedDeclarations of code.
  const declarations = LexicallyScopedDeclarations(code);
  // 3. Let privateEnv be the running execution context's PrivateEnvironment.
  const privateEnv = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 4. For each element d in declarations, do
  for (const d of declarations) {
    // a. For each element dn of the BoundNames of d, do
    for (const dn of BoundNames(d)) {
      // i. If IsConstantDeclaration of d is true, then
      if (IsConstantDeclaration(d)) {
        /* X */
        let _temp = env.CreateImmutableBinding(dn, Value.true);
        /* node:coverage ignore next */
        if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
        /* node:coverage ignore next */
        if (_temp instanceof AbruptCompletion) throw new Assert.Error("! env.CreateImmutableBinding(dn, Value.true) returned an abrupt completion", {
          cause: _temp
        });
        /* node:coverage ignore next */
        if (_temp instanceof Completion) _temp = _temp.Value;
      } else {
        /* X */
        let _temp2 = env.CreateMutableBinding(dn, Value.false);
        /* node:coverage ignore next */
        if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! env.CreateMutableBinding(dn, Value.false) returned an abrupt completion", {
          cause: _temp2
        });
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      }
      // b. If d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then
      if (d.type === 'FunctionDeclaration' || d.type === 'GeneratorDeclaration' || d.type === 'AsyncFunctionDeclaration' || d.type === 'AsyncGeneratorDeclaration') {
        // i. Let fn be the sole element of the BoundNames of d.
        const fn = BoundNames(d)[0];
        // ii. Let fo be InstantiateFunctionObject of d with argument env.
        const fo = InstantiateFunctionObject(d, env, privateEnv);
        // iii. Perform env.InitializeBinding(fn, fo).
        yield* env.InitializeBinding(fn, fo);
      }
    }
  }
}
BlockDeclarationInstantiation.section = 'https://tc39.es/ecma262/#sec-blockdeclarationinstantiation';
/** https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation */
//  Block :
//    `{` `}`
//    `{` StatementList `}`
function* Evaluate_Block({
  StatementList
}) {
  if (StatementList.length === 0) {
    // 1. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
  // 1. Let oldEnv be the running execution context's LexicalEnvironment.
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
  const blockEnv = new DeclarativeEnvironmentRecord(oldEnv);
  // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).
  yield* BlockDeclarationInstantiation(StatementList, blockEnv);
  // 4. Set the running execution context's LexicalEnvironment to blockEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = blockEnv;
  // 5. Let blockValue be the result of evaluating StatementList.
  const blockValue = yield* Evaluate_StatementList(StatementList);
  // 6. Set the running execution context's LexicalEnvironment to oldEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  // 7. Return blockValue.
  return blockValue;
}
Evaluate_Block.section = 'https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-runtime-semantics-arrayaccumulation */
//  Elision :
//    `,`
//    Elision `,`
//  ElementList :
//    Elision? AssignmentExpression
//    Elision? SpreadElement
//    ElementList `,` Elision? AssignmentExpression
//    ElementList : ElementList `,` Elision SpreadElement
//  SpreadElement :
//    `...` AssignmentExpression
function* ArrayAccumulation(ElementList, array, nextIndex) {
  let postIndex = nextIndex;
  for (const element of ElementList) {
    switch (element.type) {
      case 'Elision':
        postIndex += 1;
        /* ReturnIfAbrupt */
        let _temp = yield* Set$1(array, Value('length'), F(postIndex), Value.true);
        /* node:coverage ignore next */
        if (_temp instanceof AbruptCompletion) return _temp;
        /* node:coverage ignore next */
        if (_temp instanceof Completion) _temp = _temp.Value;
        break;
      case 'SpreadElement':
        /* ReturnIfAbrupt */
        let _temp2 = yield* ArrayAccumulation_SpreadElement(element, array, postIndex);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        postIndex = _temp2;
        break;
      default:
        /* ReturnIfAbrupt */
        let _temp3 = yield* ArrayAccumulation_AssignmentExpression(element, array, postIndex);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) return _temp3;
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        postIndex = _temp3;
        break;
    }
  }
  return postIndex;
}
ArrayAccumulation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-arrayaccumulation'; // SpreadElement : `...` AssignmentExpression
function* ArrayAccumulation_SpreadElement({
  AssignmentExpression
}, array, nextIndex) {
  /* ReturnIfAbrupt */
  let _temp4 = yield* Evaluate(AssignmentExpression);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 1. Let spreadRef be the result of evaluating AssignmentExpression.
  const spreadRef = _temp4;
  // 2. Let spreadObj be ? GetValue(spreadRef).
  /* ReturnIfAbrupt */
  let _temp5 = yield* GetValue(spreadRef);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const spreadObj = _temp5;
  // 3. Let iteratorRecord be ? GetIterator(spreadObj).
  /* ReturnIfAbrupt */
  let _temp6 = yield* GetIterator(spreadObj, 'sync');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const iteratorRecord = _temp6;
  // 4. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp7 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    // a. Let next be ? IteratorStep(iteratorRecord).
    const next = _temp7;
    // b. If next is done, return nextIndex.
    if (next === 'done') {
      return nextIndex;
    }
    // d. Perform ! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), next).
    /* X */
    let _temp9 = ToString(F(nextIndex));
    /* node:coverage ignore next */
    if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(nextIndex)) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    /* X */
    let _temp8 = CreateDataPropertyOrThrow(array, _temp9, next);
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(array, X(ToString(F(nextIndex))), next) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    // e. Set nextIndex to nextIndex + 1.
    nextIndex += 1;
  }
}
function* ArrayAccumulation_AssignmentExpression(AssignmentExpression, array, nextIndex) {
  /* ReturnIfAbrupt */
  let _temp10 = yield* Evaluate(AssignmentExpression);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  // 2. Let initResult be the result of evaluating AssignmentExpression.
  const initResult = _temp10;
  // 3. Let initValue be ? GetValue(initResult).
  /* ReturnIfAbrupt */
  let _temp11 = yield* GetValue(initResult);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const initValue = _temp11;
  // 4. Let created be ! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), initValue).
  /* X */
  let _temp13 = ToString(F(nextIndex));
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(nextIndex)) returned an abrupt completion", {
    cause: _temp13
  });
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  /* X */
  let _temp12 = CreateDataPropertyOrThrow(array, _temp13, initValue);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(array, X(ToString(F(nextIndex))), initValue) returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  // 5. Return nextIndex + 1.
  return nextIndex + 1;
}

/** https://tc39.es/ecma262/#sec-array-initializer-runtime-semantics-evaluation */
//  ArrayLiteral :
//    `[` Elision `]`
//    `[` ElementList `]`
//    `[` ElementList `,` Elision `]`
function* Evaluate_ArrayLiteral({
  ElementList
}) {
  /* X */
  let _temp14 = ArrayCreate(0);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
    cause: _temp14
  });
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  // 1. Let array be ! ArrayCreate(0).
  const array = _temp14;
  // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
  let len = yield* ArrayAccumulation(ElementList, array, 0);
  // 3. ReturnIfAbrupt(len).
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (len && typeof len === 'object' && 'next' in len) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (len instanceof AbruptCompletion) return len;
  /* node:coverage ignore next */
  if (len instanceof Completion) len = len.Value;
  // 4. Return array.
  return array;
}
Evaluate_ArrayLiteral.section = 'https://tc39.es/ecma262/#sec-array-initializer-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-delete-operator-runtime-semantics-evaluation */
//   UnaryExpression : `delete` UnaryExpression
function* Evaluate_UnaryExpression_Delete({
  UnaryExpression
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(UnaryExpression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let ref be the result of evaluating UnaryExpression.
  let ref = _temp;
  // 2. ReturnIfAbrupt(ref).
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (ref && typeof ref === 'object' && 'next' in ref) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (ref instanceof AbruptCompletion) return ref;
  /* node:coverage ignore next */
  if (ref instanceof Completion) ref = ref.Value;
  // 3. If ref is not a Reference Record, return true.
  if (!(ref instanceof ReferenceRecord)) {
    return Value.true;
  }
  // 4. If IsUnresolvableReference(ref) is true, then
  if (IsUnresolvableReference(ref) === Value.true) {
    // a. Assert: ref.[[Strict]] is false.
    Assert(ref.Strict === Value.false, "ref.Strict === Value.false");
    // b. Return true.
    return Value.true;
  }
  // 5. If IsPropertyReference(ref) is true, then
  if (IsPropertyReference(ref) === Value.true) {
    // a. Assert: IsPrivateReference(ref) is false.
    Assert(!IsPrivateReference(ref), "!IsPrivateReference(ref)");
    // b. If IsSuperReference(ref) is true, throw a ReferenceError exception.
    if (IsSuperReference(ref) === Value.true) {
      return surroundingAgent.Throw('ReferenceError', 'CannotDeleteSuper');
    }
    // c. Let baseObj be ? ToObject(ref.[[Base]]).
    /* ReturnIfAbrupt */
    let _temp2 = ToObject(ref.Base);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const baseObj = _temp2;
    // d. If ref.[[ReferencedName]] is not a property key, then
    if (!IsPropertyKey(ref.ReferencedName)) {
      /* ReturnIfAbrupt */
      let _temp3 = yield* ToPropertyKey(ref.ReferencedName);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // Set ref.[[ReferencedName]] to ? ToPropertyKey(ref.[[ReferencedName]]).
      ref.ReferencedName = _temp3;
    }
    // e. Let deleteStatus be ? baseObj.[[Delete]](ref.[[ReferencedName]]).
    /* ReturnIfAbrupt */
    let _temp4 = yield* baseObj.Delete(ref.ReferencedName);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    const deleteStatus = _temp4;
    // f. If deleteStatus is false and ref.[[Strict]] is true, throw a TypeError exception.
    if (deleteStatus === Value.false && ref.Strict === Value.true) {
      return surroundingAgent.Throw('TypeError', 'StrictModeDelete', ref.ReferencedName);
    }
    // g. Return deleteStatus.
    return deleteStatus;
  } else {
    // 6. Else,
    // a. Let base be ref.[[Base]].
    const base = ref.Base;
    // b. Assert: base is an Environment Record.
    Assert(base instanceof EnvironmentRecord, "base instanceof EnvironmentRecord");
    // c. Return ? bindings.DeleteBinding(GetReferencedName(ref)).
    return yield* base.DeleteBinding(ref.ReferencedName);
  }
}
Evaluate_UnaryExpression_Delete.section = 'https://tc39.es/ecma262/#sec-delete-operator-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-void-operator-runtime-semantics-evaluation */
//   UnaryExpression : `void` UnaryExpression
function* Evaluate_UnaryExpression_Void({
  UnaryExpression
}) {
  /* ReturnIfAbrupt */
  let _temp5 = yield* Evaluate(UnaryExpression);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 1. Let expr be the result of evaluating UnaryExpression.
  const expr = _temp5;
  // 2. Perform ? GetValue(expr).
  /* ReturnIfAbrupt */
  let _temp6 = yield* GetValue(expr);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  // 3. Return undefined.
  return Value.undefined;
}
Evaluate_UnaryExpression_Void.section = 'https://tc39.es/ecma262/#sec-void-operator-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-typeof-operator-runtime-semantics-evaluation */
// UnaryExpression : `typeof` UnaryExpression
function* Evaluate_UnaryExpression_Typeof({
  UnaryExpression
}) {
  /* ReturnIfAbrupt */
  let _temp7 = yield* Evaluate(UnaryExpression);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 1. Let val be the result of evaluating UnaryExpression.
  const _val = _temp7;
  // 2. If Type(val) is Reference, then
  if (_val instanceof ReferenceRecord) {
    // a. If IsUnresolvableReference(val) is true, return "undefined".
    if (IsUnresolvableReference(_val) === Value.true) {
      return Value('undefined');
    }
  }
  // 3. Set val to ? GetValue(val).
  /* ReturnIfAbrupt */
  let _temp8 = yield* GetValue(_val);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const val = _temp8;
  // 4. Return a String according to Table 37.
  if (val instanceof UndefinedValue) {
    return Value('undefined');
  } else if (val instanceof NullValue) {
    return Value('object');
  } else if (val instanceof BooleanValue) {
    return Value('boolean');
  } else if (val instanceof NumberValue) {
    return Value('number');
  } else if (val instanceof JSStringValue) {
    return Value('string');
  } else if (val instanceof BigIntValue) {
    return Value('bigint');
  } else if (val instanceof SymbolValue) {
    return Value('symbol');
  } else if (val instanceof ObjectValue) {
    if (IsCallable(val)) {
      return Value('function');
    }
    return Value('object');
  }
  /* node:coverage ignore next */
  throw new OutOfRange$1('Evaluate_UnaryExpression_Typeof', val);
}
Evaluate_UnaryExpression_Typeof.section = 'https://tc39.es/ecma262/#sec-typeof-operator-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-unary-plus-operator-runtime-semantics-evaluation */
//   UnaryExpression : `+` UnaryExpression
function* Evaluate_UnaryExpression_Plus({
  UnaryExpression
}) {
  /* ReturnIfAbrupt */
  let _temp9 = yield* Evaluate(UnaryExpression);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  // 1. Let expr be the result of evaluating UnaryExpression.
  const expr = _temp9;
  // 2. Return ? ToNumber(? GetValue(expr)).
  /* ReturnIfAbrupt */
  let _temp10 = yield* GetValue(expr);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  return yield* ToNumber(_temp10);
}
Evaluate_UnaryExpression_Plus.section = 'https://tc39.es/ecma262/#sec-unary-plus-operator-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-unary-minus-operator-runtime-semantics-evaluation */
//   UnaryExpression : `-` UnaryExpression
function* Evaluate_UnaryExpression_Minus({
  UnaryExpression
}) {
  /* ReturnIfAbrupt */
  let _temp11 = yield* Evaluate(UnaryExpression);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  // 1. Let expr be the result of evaluating UnaryExpression.
  const expr = _temp11;
  // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).
  /* ReturnIfAbrupt */
  let _temp13 = yield* GetValue(expr);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  /* ReturnIfAbrupt */
  let _temp12 = yield* ToNumeric(_temp13);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  const oldValue = _temp12;
  // 3. If oldValue is a Number, then
  if (oldValue instanceof NumberValue) {
    // a. Return Number::unaryMinus(oldValue).
    return NumberValue.unaryMinus(oldValue);
  } else {
    // a. Assert: oldValue is a BigInt.
    // b. Return BigInt::unaryMinus(oldValue).
    Assert(oldValue instanceof BigIntValue, "oldValue instanceof BigIntValue");
    return BigIntValue.unaryMinus(oldValue);
  }
}
Evaluate_UnaryExpression_Minus.section = 'https://tc39.es/ecma262/#sec-unary-minus-operator-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-bitwise-not-operator-runtime-semantics-evaluation */
//   UnaryExpression : `~` UnaryExpression
function* Evaluate_UnaryExpression_Tilde({
  UnaryExpression
}) {
  /* ReturnIfAbrupt */
  let _temp14 = yield* Evaluate(UnaryExpression);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  // 1. Let expr be the result of evaluating UnaryExpression.
  const expr = _temp14;
  // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).
  /* ReturnIfAbrupt */
  let _temp16 = yield* GetValue(expr);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  /* ReturnIfAbrupt */
  let _temp15 = yield* ToNumeric(_temp16);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const oldValue = _temp15;
  // 3. If oldValue is a Number, then
  if (oldValue instanceof NumberValue) {
    // a. Return Number::bitwiseNOT(oldValue).
    return NumberValue.bitwiseNOT(oldValue);
  } else {
    // a. Assert: oldValue is a BigInt.
    // b. Return BigInt::bitwiseNOT(oldValue).
    Assert(oldValue instanceof BigIntValue, "oldValue instanceof BigIntValue");
    return BigIntValue.bitwiseNOT(oldValue);
  }
}
Evaluate_UnaryExpression_Tilde.section = 'https://tc39.es/ecma262/#sec-bitwise-not-operator-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-logical-not-operator-runtime-semantics-evaluation */
//   UnaryExpression : `!` UnaryExpression
function* Evaluate_UnaryExpression_Bang({
  UnaryExpression
}) {
  /* ReturnIfAbrupt */
  let _temp17 = yield* Evaluate(UnaryExpression);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  // 1. Let expr be the result of evaluating UnaryExpression.
  const expr = _temp17;
  // 2. Let oldValue be ! ToBoolean(? GetValue(expr)).
  /* ReturnIfAbrupt */
  let _temp18 = yield* GetValue(expr);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) return _temp18;
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  const oldValue = ToBoolean(_temp18);
  // 3. If oldValue is true, return false.
  if (oldValue === Value.true) {
    return Value.false;
  }
  // 4. Return true.
  return Value.true;
}
Evaluate_UnaryExpression_Bang.section = 'https://tc39.es/ecma262/#sec-logical-not-operator-runtime-semantics-evaluation'; // UnaryExpression :
//  `delete` UnaryExpression
//  `void` UnaryExpression
//  `typeof` UnaryExpression
//  `+` UnaryExpression
//  `-` UnaryExpression
//  `~` UnaryExpression
//  `!` UnaryExpression
function* Evaluate_UnaryExpression(UnaryExpression) {
  switch (UnaryExpression.operator) {
    case 'delete':
      /* ReturnIfAbrupt */
      let _temp19 = surroundingAgent.debugger_cannotPreview;
      /* node:coverage ignore next */
      if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp19 instanceof AbruptCompletion) return _temp19;
      /* node:coverage ignore next */
      if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
      return yield* Evaluate_UnaryExpression_Delete(UnaryExpression);
    case 'void':
      return yield* Evaluate_UnaryExpression_Void(UnaryExpression);
    case 'typeof':
      return yield* Evaluate_UnaryExpression_Typeof(UnaryExpression);
    case '+':
      return yield* Evaluate_UnaryExpression_Plus(UnaryExpression);
    case '-':
      return yield* Evaluate_UnaryExpression_Minus(UnaryExpression);
    case '~':
      return yield* Evaluate_UnaryExpression_Tilde(UnaryExpression);
    case '!':
      return yield* Evaluate_UnaryExpression_Bang(UnaryExpression);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_UnaryExpression', UnaryExpression);
  }
}

/** https://tc39.es/ecma262/#sec-equality-operators-runtime-semantics-evaluation */
//   EqualityExpression :
//     EqualityExpression `==` RelationalExpression
//     EqualityExpression `!=` RelationalExpression
//     EqualityExpression `===` RelationalExpression
//     EqualityExpression `!==` RelationalExpression
function* Evaluate_EqualityExpression({
  EqualityExpression,
  operator,
  RelationalExpression
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(EqualityExpression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let lref be the result of evaluating EqualityExpression.
  const lref = _temp;
  // 2. Let lval be ? GetValue(lref).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(lref);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const lval = _temp2;
  // 3. Let rref be the result of evaluating RelationalExpression.
  /* ReturnIfAbrupt */
  let _temp3 = yield* Evaluate(RelationalExpression);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const rref = _temp3;
  // 4. Let rval be ? GetValue(rref).
  /* ReturnIfAbrupt */
  let _temp4 = yield* GetValue(rref);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const rval = _temp4;
  switch (operator) {
    case '==':
      // 5. Return the result of performing Abstract Equality Comparison rval == lval.
      return yield* IsLooselyEqual(rval, lval);
    case '!=':
      {
        // 5. Let r be the result of performing Abstract Equality Comparison rval == lval.
        let r = yield* IsLooselyEqual(rval, lval);
        // 6. ReturnIfAbrupt(r).
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (r && typeof r === 'object' && 'next' in r) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (r instanceof AbruptCompletion) return r;
        /* node:coverage ignore next */
        if (r instanceof Completion) r = r.Value;
        // 7. If r is true, return false. Otherwise, return true.
        if (r === Value.true) {
          return Value.false;
        } else {
          return Value.true;
        }
      }
    case '===':
      // 5. Return the result of performing Strict Equality Comparison rval === lval.
      return IsStrictlyEqual(rval, lval);
    case '!==':
      {
        /* X */
        let _temp5 = IsStrictlyEqual(rval, lval);
        /* node:coverage ignore next */
        if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! IsStrictlyEqual(rval, lval) returned an abrupt completion", {
          cause: _temp5
        });
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        // 5. Let r be the result of performing Strict Equality Comparison rval === lval.
        // 6. Assert: r is a normal completion.
        const r = _temp5;
        // 7. If r.[[Value]] is true, return false. Otherwise, return true.
        if (r === Value.true) {
          return Value.false;
        } else {
          return Value.true;
        }
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_EqualityExpression', operator);
  }
}
Evaluate_EqualityExpression.section = 'https://tc39.es/ecma262/#sec-equality-operators-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-binary-logical-operators-runtime-semantics-evaluation */
//   LogicalANDExpression :
//     LogicalANDExpression `&&` BitwiseORExpression
function* Evaluate_LogicalANDExpression({
  LogicalANDExpression,
  BitwiseORExpression
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(LogicalANDExpression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let lref be the result of evaluating LogicalANDExpression.
  const lref = _temp;
  // 2. Let lval be ? GetValue(lref).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(lref);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const lval = _temp2;
  // 3. Let lbool be ! ToBoolean(lval).
  /* X */
  let _temp3 = ToBoolean(lval);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(lval) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const lbool = _temp3;
  // 4. If lbool is false, return lval.
  if (lbool === Value.false) {
    return lval;
  }
  // 5. Let rref be the result of evaluating BitwiseORExpression.
  /* ReturnIfAbrupt */
  let _temp4 = yield* Evaluate(BitwiseORExpression);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const rref = _temp4;
  // 6. Return ? GetValue(rref).
  return yield* GetValue(rref);
}
Evaluate_LogicalANDExpression.section = 'https://tc39.es/ecma262/#sec-binary-logical-operators-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-binary-logical-operators-runtime-semantics-evaluation */
//   LogicalORExpression :
//     LogicalORExpression `||` LogicalANDExpression
function* Evaluate_LogicalORExpression({
  LogicalORExpression,
  LogicalANDExpression
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(LogicalORExpression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let lref be the result of evaluating LogicalORExpression.
  const lref = _temp;
  // 2. Let lval be ? GetValue(lref).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(lref);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const lval = _temp2;
  // 3. Let lbool be ! ToBoolean(lval).
  /* X */
  let _temp3 = ToBoolean(lval);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(lval) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const lbool = _temp3;
  // 4. If lbool is false, return lval.
  if (lbool === Value.true) {
    return lval;
  }
  // 5. Let rref be the result of evaluating LogicalANDExpression.
  /* ReturnIfAbrupt */
  let _temp4 = yield* Evaluate(LogicalANDExpression);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const rref = _temp4;
  // 6. Return ? GetValue(rref).
  return yield* GetValue(rref);
}
Evaluate_LogicalORExpression.section = 'https://tc39.es/ecma262/#sec-binary-logical-operators-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-evaluatenew */
function* EvaluateNew(constructExpr, args) {
  // 1. Assert: constructExpr is either a NewExpression or a MemberExpression.
  // 2. Assert: arguments is either empty or an Arguments.
  Assert(args === undefined || Array.isArray(args), "args === undefined || Array.isArray(args)");
  // 3. Let ref be the result of evaluating constructExpr.
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(constructExpr);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const ref = _temp;
  // 4. Let constructor be ? GetValue(ref).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(ref);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const constructor = _temp2;
  let argList;
  // 5. If arguments is empty, let argList be a new empty List.
  if (args === undefined) {
    argList = [];
  } else {
    /* ReturnIfAbrupt */
    let _temp3 = yield* ArgumentListEvaluation(args);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // 6. Else,
    // a. Let argList be ? ArgumentListEvaluation of arguments.
    argList = _temp3;
  }
  // 7. If IsConstructor(constructor) is false, throw a TypeError exception.
  if (!IsConstructor(constructor)) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', constructor);
  }
  // 8. Return ? Construct(constructor, argList).
  return yield* Construct(constructor, argList);
}
EvaluateNew.section = 'https://tc39.es/ecma262/#sec-evaluatenew';
/** https://tc39.es/ecma262/#sec-new-operator-runtime-semantics-evaluation */
//   NewExpression :
//     `new` NewExpression
//     `new` MemberExpression Arguments
function* Evaluate_NewExpression({
  MemberExpression,
  Arguments
}) {
  if (!Arguments) {
    // 1. Return ? EvaluateNew(NewExpression, empty).
    return yield* EvaluateNew(MemberExpression, undefined);
  } else {
    // 1. Return ? EvaluateNew(MemberExpression, Arguments).
    return yield* EvaluateNew(MemberExpression, Arguments);
  }
}
Evaluate_NewExpression.section = 'https://tc39.es/ecma262/#sec-new-operator-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-left-shift-operator-runtime-semantics-evaluation */
//  ShiftExpression :
//    ShiftExpression `<<` AdditiveExpression
/** https://tc39.es/ecma262/#sec-signed-right-shift-operator-runtime-semantics-evaluation */
//  ShiftExpression :
//    ShiftExpression `>>` AdditiveExpression
/** https://tc39.es/ecma262/#sec-unsigned-right-shift-operator-runtime-semantics-evaluation */
//  ShiftExpression :
//    ShiftExpression `>>>` AdditiveExpression
function* Evaluate_ShiftExpression({
  ShiftExpression,
  operator,
  AdditiveExpression
}) {
  return yield* EvaluateStringOrNumericBinaryExpression(ShiftExpression, operator, AdditiveExpression);
}
Evaluate_ShiftExpression.section = 'https://tc39.es/ecma262/#sec-left-shift-operator-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-super-keyword-runtime-semantics-evaluation */
// SuperCall : `super` Arguments
function* Evaluate_SuperCall({
  Arguments
}) {
  // 1. Let newTarget be GetNewTarget().
  const newTarget = GetNewTarget();
  // 2. Assert: Type(newTarget) is Object.
  Assert(newTarget instanceof ObjectValue, "newTarget instanceof ObjectValue");
  // 3. Let func be ! GetSuperConstructor().
  /* X */
  let _temp = GetSuperConstructor();
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! GetSuperConstructor() returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const func = _temp;
  // 4. Let argList be ? ArgumentListEvaluation of Arguments.
  /* ReturnIfAbrupt */
  let _temp2 = yield* ArgumentListEvaluation(Arguments);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const argList = _temp2;
  // 5. If IsConstructor(func) is false, throw a TypeError exception.
  if (!IsConstructor(func)) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', func);
  }
  // 6. Let result be ? Construct(func, argList, newTarget).
  /* ReturnIfAbrupt */
  let _temp3 = yield* Construct(func, argList, newTarget);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const result = _temp3;
  // 7. Let thisER be GetThisEnvironment().
  const thisER = GetThisEnvironment();
  // 8. Assert: thisER is a Function Environment Record.
  Assert(thisER instanceof FunctionEnvironmentRecord, "thisER instanceof FunctionEnvironmentRecord");
  // 8. Perform ? thisER.BindThisValue(result).
  /* ReturnIfAbrupt */
  let _temp4 = thisER.BindThisValue(result);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 9. Let F be thisER.[[FunctionObject]].
  const F = thisER.FunctionObject;
  // 10. Assert: F is an ECMAScript function object.
  Assert(isECMAScriptFunctionObject(F), "isECMAScriptFunctionObject(F)");
  // 11. Perform ? InitializeInstanceElements(result, F).
  /* ReturnIfAbrupt */
  let _temp5 = yield* InitializeInstanceElements(result, F);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 12. Return result.
  return result;
}
Evaluate_SuperCall.section = 'https://tc39.es/ecma262/#sec-super-keyword-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-getsuperconstructor */
function GetSuperConstructor() {
  // 1. Let envRec be GetThisEnvironment().
  const envRec = GetThisEnvironment();
  // 2. Assert: envRec is a function Environment Record.
  Assert(envRec instanceof FunctionEnvironmentRecord, "envRec instanceof FunctionEnvironmentRecord");
  // 3. Let activeFunction be envRec.[[FunctionObject]].
  const activeFunction = envRec.FunctionObject;
  // 4. Assert: activeFunction is an ECMAScript function object.
  Assert(isECMAScriptFunctionObject(activeFunction), "isECMAScriptFunctionObject(activeFunction)");
  // 5. Let superConstructor be ! activeFunction.[[GetPrototypeOf]]().
  /* X */
  let _temp6 = activeFunction.GetPrototypeOf();
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! activeFunction.GetPrototypeOf() returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const superConstructor = _temp6;
  // 6. Return superConstructor.
  return superConstructor;
}
GetSuperConstructor.section = 'https://tc39.es/ecma262/#sec-getsuperconstructor';

/** https://tc39.es/ecma262/#sec-makesuperpropertyreference */
function MakeSuperPropertyReference(actualThis, propertyKey, strict) {
  // 1. Let env be GetThisEnvironment().
  const env = GetThisEnvironment();
  // 2. Assert: env.HasSuperBinding() is true.
  Assert(env.HasSuperBinding() === Value.true, "env.HasSuperBinding() === Value.true");
  // 3. Assert: env is a Function Environment Record.
  Assert(env instanceof FunctionEnvironmentRecord, "env instanceof FunctionEnvironmentRecord");
  // 4. Let baseValue be ? env.GetSuperBase().
  /* ReturnIfAbrupt */
  let _temp = env.GetSuperBase();
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const baseValue = _temp;
  // 5. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: propertyKey, [[Strict]]: strict, [[ThisValue]]: actualThis }.
  return new ReferenceRecord({
    Base: baseValue,
    ReferencedName: propertyKey,
    Strict: strict ? Value.true : Value.false,
    ThisValue: actualThis
  });
}
MakeSuperPropertyReference.section = 'https://tc39.es/ecma262/#sec-makesuperpropertyreference';
/** https://tc39.es/ecma262/#sec-super-keyword-runtime-semantics-evaluation */
//  SuperProperty :
//    `super` `[` Expression `]`
//    `super` `.` IdentifierName
function* Evaluate_SuperProperty({
  Expression,
  IdentifierName,
  strict
}) {
  // 1. Let env be GetThisEnvironment().
  const env = GetThisEnvironment();
  // 2. Let actualThis be ? env.GetThisBinding().
  /* ReturnIfAbrupt */
  let _temp2 = env.GetThisBinding();
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const actualThis = _temp2;
  if (Expression) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* Evaluate(Expression);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // 3. Let propertyNameReference be the result of evaluating Expression.
    const propertyNameReference = _temp3;
    // 4. Let propertyNameReference be the result of evaluating Expression.
    /* ReturnIfAbrupt */
    let _temp4 = yield* GetValue(propertyNameReference);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    const propertyNameValue = _temp4;
    // 5. Let propertyNameValue be ? GetValue(propertyNameReference).
    /* ReturnIfAbrupt */
    let _temp5 = yield* ToPropertyKey(propertyNameValue);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    const propertyKey = _temp5;
    // 6. If the code matched by this SuperProperty is strict mode code, let strict be true; else let strict be false.
    // 7. Return ? MakeSuperPropertyReference(actualThis, propertyKey, strict).
    return MakeSuperPropertyReference(actualThis, propertyKey, strict);
  } else {
    // 3. Let propertyKey be StringValue of IdentifierName.
    const propertyKey = StringValue(IdentifierName);
    // 4. const strict = SuperProperty.strict;
    // 5. Return ? MakeSuperPropertyReference(actualThis, propertyKey, strict).
    return MakeSuperPropertyReference(actualThis, propertyKey, strict);
  }
}
Evaluate_SuperProperty.section = 'https://tc39.es/ecma262/#sec-super-keyword-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-initializeboundname */
function* InitializeBoundName(name, value, environment) {
  // 1. Assert: Type(name) is String.
  Assert(name instanceof JSStringValue, "name instanceof JSStringValue");
  // 2. If environment is not undefined, then
  if (!(environment instanceof UndefinedValue)) {
    // a. Perform environment.InitializeBinding(name, value).
    yield* environment.InitializeBinding(name, value);
    // b. Return NormalCompletion(undefined).
    return NormalCompletion(undefined);
  } else {
    /* ReturnIfAbrupt */
    let _temp = yield* ResolveBinding(name, undefined, false);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // a. Let lhs be ResolveBinding(name).
    const lhs = _temp;
    // b. Return ? PutValue(lhs, value).
    return yield* PutValue(lhs, value);
  }
}
InitializeBoundName.section = 'https://tc39.es/ecma262/#sec-initializeboundname'; // ObjectBindingPattern :
//   `{` `}`
//   `{` BindingPropertyList `}`
//   `{` BindingRestProperty `}`
//   `{` BindingPropertyList `,` BindingRestProperty `}`
function* BindingInitialization_ObjectBindingPattern({
  BindingPropertyList,
  BindingRestProperty
}, value, environment) {
  /* ReturnIfAbrupt */
  let _temp2 = yield* PropertyBindingInitialization(BindingPropertyList, value, environment);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Perform ? PropertyBindingInitialization for BindingPropertyList using value and environment as the arguments.
  const excludedNames = _temp2;
  if (BindingRestProperty) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* RestBindingInitialization(BindingRestProperty, value, environment, excludedNames);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }
  // 2. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
function* BindingInitialization(node, value, environment) {
  switch (node.type) {
    case 'ForBinding':
      if (node.BindingIdentifier) {
        return yield* BindingInitialization(node.BindingIdentifier, value, environment);
      }
      return yield* BindingInitialization(node.BindingPattern, value, environment);
    case 'ForDeclaration':
      return yield* BindingInitialization(node.ForBinding, value, environment);
    case 'BindingIdentifier':
      {
        // 1. Let name be StringValue of Identifier.
        const name = StringValue(node);
        // 2. Return ? InitializeBoundName(name, value, environment).
        return yield* InitializeBoundName(name, value, environment);
      }
    case 'ObjectBindingPattern':
      {
        /* ReturnIfAbrupt */
        let _temp4 = RequireObjectCoercible(value);
        /* node:coverage ignore next */
        if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        // 2. Return the result of performing BindingInitialization for ObjectBindingPattern using value and environment as arguments.
        return yield* BindingInitialization_ObjectBindingPattern(node, value, environment);
      }
    case 'ArrayBindingPattern':
      {
        /* ReturnIfAbrupt */
        let _temp5 = yield* GetIterator(value, 'sync');
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) return _temp5;
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        // 1. Let iteratorRecord be ? GetIterator(value).
        const iteratorRecord = _temp5;
        // 2. Let result be IteratorBindingInitialization of ArrayBindingPattern with arguments iteratorRecord and environment.
        const result = EnsureCompletion(yield* IteratorBindingInitialization_ArrayBindingPattern(node, iteratorRecord, environment));
        // 3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
        if (iteratorRecord.Done === Value.false) {
          return yield* IteratorClose(iteratorRecord, result);
        }
        // 4. Return ? result.
        return result;
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('BindingInitialization', node);
  }
}

/** https://tc39.es/ecma262/#sec-async-function-definitions-runtime-semantics-evaluation */
//   AsyncFunctionExpression :
//     `async` `function` `(` FormalParameters `)` `{` AsyncBody `}`
//     `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncBody `}`
function Evaluate_AsyncFunctionExpression(AsyncFunctionExpression) {
  // 1. Return InstantiateAsyncFunctionExpression of AsyncFunctionExpression.
  return InstantiateAsyncFunctionExpression(AsyncFunctionExpression);
}
Evaluate_AsyncFunctionExpression.section = 'https://tc39.es/ecma262/#sec-async-function-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-instanceofoperator */
function* InstanceofOperator(V, target) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Let instOfHandler be ? GetMethod(target, @@hasInstance).
  /* ReturnIfAbrupt */
  let _temp = yield* GetMethod(target, wellKnownSymbols.hasInstance);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const instOfHandler = _temp;
  // 3. If instOfHandler is not undefined, then
  if (instOfHandler !== Value.undefined) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* Call(instOfHandler, target, [V]);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    /* X */
    let _temp2 = ToBoolean(_temp3);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(Q(yield* Call(instOfHandler, target, [V]))) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // a. Return ! ToBoolean(? Call(instOfHandler, target, « V »)).
    return _temp2;
  }
  // 4. If IsCallable(target) is false, throw a TypeError exception.
  if (!IsCallable(target)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', target);
  }
  // 5. Return ? OrdinaryHasInstance(target, V).
  return yield* OrdinaryHasInstance(target, V);
}
InstanceofOperator.section = 'https://tc39.es/ecma262/#sec-instanceofoperator'; // RelationalExpression : PrivateIdentifier `in` ShiftExpression
function* Evaluate_RelationalExpression_PrivateIdentifier({
  PrivateIdentifier,
  ShiftExpression
}) {
  // 1. Let privateIdentifier be the StringValue of PrivateIdentifier.
  const privateIdentifier = StringValue(PrivateIdentifier);
  // 2. Let rref be the result of evaluating ShiftExpression.
  /* ReturnIfAbrupt */
  let _temp4 = yield* Evaluate(ShiftExpression);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const rref = _temp4;
  // 3. Let rval be ? GetValue(rref).
  /* ReturnIfAbrupt */
  let _temp5 = yield* GetValue(rref);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const rval = _temp5;
  // 4. If Type(rval) is not Object, throw a TypeError exception.
  if (!(rval instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', rval);
  }
  // 5. Let privateEnv be the running execution context's PrivateEnvironment.
  const privateEnv = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 6. Let privateName be ! ResolvePrivateIdentifier(privateEnv, privateIdentifier).
  /* X */
  let _temp6 = ResolvePrivateIdentifier(privateEnv, privateIdentifier);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! ResolvePrivateIdentifier(privateEnv, privateIdentifier) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const privateName = _temp6;
  // 7. If ! PrivateElementFind(privateName, rval) is not empty, return true.
  /* X */
  let _temp7 = PrivateElementFind(privateName, rval);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! PrivateElementFind(privateName, rval) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  if (_temp7 !== undefined) {
    return Value.true;
  }
  // 8. Return false.
  return Value.false;
}

/** https://tc39.es/ecma262/#sec-relational-operators-runtime-semantics-evaluation */
//   RelationalExpression :
//     RelationalExpression `<` ShiftExpression
//     RelationalExpression `>` ShiftExpression
//     RelationalExpression `<=` ShiftExpression
//     RelationalExpression `>=` ShiftExpression
//     RelationalExpression `instanceof` ShiftExpression
//     RelationalExpression `in` ShiftExpression
//     PrivateIdentifier `in` ShiftExpression
function* Evaluate_RelationalExpression(expr) {
  if (expr.PrivateIdentifier) {
    return yield* Evaluate_RelationalExpression_PrivateIdentifier(expr);
  }
  const {
    RelationalExpression,
    operator,
    ShiftExpression
  } = expr;

  // 1. Let lref be the result of evaluating RelationalExpression.
  /* ReturnIfAbrupt */
  let _temp8 = yield* Evaluate(RelationalExpression);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const lref = _temp8;
  // 2. Let lval be ? GetValue(lref).
  /* ReturnIfAbrupt */
  let _temp9 = yield* GetValue(lref);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const lval = _temp9;
  // 3. Let rref be the result of evaluating ShiftExpression.
  /* ReturnIfAbrupt */
  let _temp10 = yield* Evaluate(ShiftExpression);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const rref = _temp10;
  // 4. Let rval be ? GetValue(rref).
  /* ReturnIfAbrupt */
  let _temp11 = yield* GetValue(rref);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const rval = _temp11;
  switch (operator) {
    case '<':
      {
        // 5. Let r be the result of performing Abstract Relational Comparison lval < rval.
        let r = yield* AbstractRelationalComparison(lval, rval);
        // 6. ReturnIfAbrupt(r).
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (r && typeof r === 'object' && 'next' in r) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (r instanceof AbruptCompletion) return r;
        /* node:coverage ignore next */
        if (r instanceof Completion) r = r.Value;
        // 7. If r is undefined, return false. Otherwise, return r.
        if (r === Value.undefined) {
          return Value.false;
        }
        return r;
      }
    case '>':
      {
        // 5. Let r be the result of performing Abstract Relational Comparison rval < lval with LeftFirst equal to false.
        let r = yield* AbstractRelationalComparison(rval, lval, false);
        // 6. ReturnIfAbrupt(r).
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (r && typeof r === 'object' && 'next' in r) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (r instanceof AbruptCompletion) return r;
        /* node:coverage ignore next */
        if (r instanceof Completion) r = r.Value;
        // 7. If r is undefined, return false. Otherwise, return r.
        if (r === Value.undefined) {
          return Value.false;
        }
        return r;
      }
    case '<=':
      {
        // 5. Let r be the result of performing Abstract Relational Comparison rval < lval with LeftFirst equal to false.
        let r = yield* AbstractRelationalComparison(rval, lval, false);
        // 6. ReturnIfAbrupt(r).
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (r && typeof r === 'object' && 'next' in r) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (r instanceof AbruptCompletion) return r;
        /* node:coverage ignore next */
        if (r instanceof Completion) r = r.Value;
        // 7. If r is true or undefined, return false. Otherwise, return true.
        if (r === Value.true || r === Value.undefined) {
          return Value.false;
        }
        return Value.true;
      }
    case '>=':
      {
        // 5. Let r be the result of performing Abstract Relational Comparison lval < rval.
        let r = yield* AbstractRelationalComparison(lval, rval);
        // 6. ReturnIfAbrupt(r).
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (r && typeof r === 'object' && 'next' in r) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (r instanceof AbruptCompletion) return r;
        /* node:coverage ignore next */
        if (r instanceof Completion) r = r.Value;
        // 7. If r is true or undefined, return false. Otherwise, return true.
        if (r === Value.true || r === Value.undefined) {
          return Value.false;
        }
        return Value.true;
      }
    case 'instanceof':
      // 5. Return ? InstanceofOperator(lval, rval).
      return yield* InstanceofOperator(lval, rval);
    case 'in':
      // 5. Return ? InstanceofOperator(lval, rval).
      if (!(rval instanceof ObjectValue)) {
        return surroundingAgent.Throw('TypeError', 'NotAnObject', rval);
      }
      // 6. Return ? HasProperty(rval, ? ToPropertyKey(lval)).
      /* ReturnIfAbrupt */
      let _temp12 = yield* ToPropertyKey(lval);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      return yield* HasProperty(rval, _temp12);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('Evaluate_RelationalExpression', operator);
  }
}
Evaluate_RelationalExpression.section = 'https://tc39.es/ecma262/#sec-relational-operators-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-statement-semantics-runtime-semantics-evaluation */
//   BreakableStatement :
//     IterationStatement
//     SwitchStatement
//
//   IterationStatement :
//     (DoStatement)
//     (WhileStatement)
function Evaluate_BreakableStatement(BreakableStatement) {
  // 1. Let newLabelSet be a new empty List.
  const newLabelSet = new JSStringSet();
  // 2. Return the result of performing LabelledEvaluation of this BreakableStatement with argument newLabelSet.
  return LabelledEvaluation(BreakableStatement, newLabelSet);
}
Evaluate_BreakableStatement.section = 'https://tc39.es/ecma262/#sec-statement-semantics-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-ecmascript-standard-built-in-objects */
function assignProps(realmRec, obj, props) {
  for (const item of props) {
    if (item === undefined) {
      continue;
    }
    const [n, v, len, descriptor] = item;
    const name = n instanceof Value ? n : Value(n);
    if (Array.isArray(v)) {
      // Every accessor property described in clauses 18 through 26 and in
      // Annex B.2 has the attributes { [[Enumerable]]: false,
      // [[Configurable]]: true } unless otherwise specified. If only a get
      // accessor function is described, the set accessor function is the
      // default value, undefined. If only a set accessor is described the get
      // accessor is the default value, undefined.
      let [getter = Value.undefined, setter = Value.undefined] = v;
      if (typeof getter === 'function') {
        getter = CreateBuiltinFunction(getter, 0, name, [], realmRec, undefined, Value('get'));
      }
      if (typeof setter === 'function') {
        setter = CreateBuiltinFunction(setter, 1, name, [], realmRec, undefined, Value('set'));
      }
      /* X */
      let _temp = obj.DefineOwnProperty(name, _Descriptor({
        Get: getter,
        Set: setter,
        Enumerable: Value.false,
        Configurable: Value.true,
        ...descriptor
      }));
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! obj.DefineOwnProperty(name, Descriptor({\n        Get: getter,\n        Set: setter,\n        Enumerable: Value.false,\n        Configurable: Value.true,\n        ...descriptor,\n      })) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
    } else {
      // Every other data property described in clauses 18 through 26 and in
      // Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]:
      // false, [[Configurable]]: true } unless otherwise specified.
      let value;
      if (typeof v === 'function') {
        Assert(typeof len === 'number', "typeof len === 'number'");
        value = CreateBuiltinFunction(v, len, name, [], realmRec);
      } else {
        value = v;
      }
      obj.properties.set(name, _Descriptor({
        Value: value,
        Writable: Value.true,
        Enumerable: Value.false,
        Configurable: Value.true,
        ...descriptor
      }));
    }
  }
}
assignProps.section = 'https://tc39.es/ecma262/#sec-ecmascript-standard-built-in-objects';
function bootstrapPrototype(realmRec, props, Prototype, stringTag) {
  Assert(Prototype !== undefined, "Prototype !== undefined");
  const proto = OrdinaryObjectCreate(Prototype);
  assignProps(realmRec, proto, props);
  if (stringTag !== undefined) {
    /* X */
    let _temp2 = proto.DefineOwnProperty(wellKnownSymbols.toStringTag, _Descriptor({
      Value: Value(stringTag),
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! proto.DefineOwnProperty(wellKnownSymbols.toStringTag, Descriptor({\n      Value: Value(stringTag),\n      Writable: Value.false,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    })) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  }
  return proto;
}
function bootstrapConstructor(realmRec, Constructor, name, length, Prototype, props = []) {
  const cons = CreateBuiltinFunction(Constructor, length, Value(name), [], realmRec, undefined, undefined, Value.true);
  /* X */
  let _temp3 = cons.DefineOwnProperty(Value('prototype'), _Descriptor({
    Value: Prototype,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! cons.DefineOwnProperty(Value('prototype'), Descriptor({\n    Value: Prototype,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  if (!Prototype.properties.has('constructor')) {
    /* X */
    let _temp4 = Prototype.DefineOwnProperty(Value('constructor'), _Descriptor({
      Value: cons,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! Prototype.DefineOwnProperty(Value('constructor'), Descriptor({\n      Value: cons,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    })) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  }
  assignProps(realmRec, cons, props);
  return cons;
}

/** https://tc39.es/ecma262/#sec-createforiniterator */
function CreateForInIterator(object) {
  // 1. Assert: Type(object) is Object.
  Assert(object instanceof ObjectValue, "object instanceof ObjectValue");
  // 2. Let iterator be ObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »).
  const iterator = OrdinaryObjectCreate(surroundingAgent.intrinsic('%ForInIteratorPrototype%'), ['Object', 'ObjectWasVisited', 'VisitedKeys', 'RemainingKeys']);
  // 3. Set iterator.[[Object]] to object.
  iterator.Object = object;
  // 4. Set iterator.[[ObjectWasVisited]] to false.
  iterator.ObjectWasVisited = Value.false;
  // 5. Set iterator.[[VisitedKeys]] to a new empty List.
  iterator.VisitedKeys = [];
  // 6. Set iterator.[[RemainingKeys]] to a new empty List.
  iterator.RemainingKeys = [];
  // 7. Return iterator.
  return iterator;
}
CreateForInIterator.section = 'https://tc39.es/ecma262/#sec-createforiniterator';
/** https://tc39.es/ecma262/#sec-%foriniteratorprototype%.next */
function* ForInIteratorPrototype_next(_args, {
  thisValue
}) {
  // 1. Let O be this value.
  const O = thisValue;
  // 2. Assert: Type(O) is Object.
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  // 3. Assert: O has all the internal slot sof a For-In Iterator Instance.
  Assert('Object' in O && 'ObjectWasVisited' in O && 'VisitedKeys' in O && 'RemainingKeys' in O, "'Object' in O && 'ObjectWasVisited' in O && 'VisitedKeys' in O && 'RemainingKeys' in O");
  // 4. Let object be O.[[Object]].
  let object = O.Object;
  // 5. Let visited be O.[[VisitedKeys]].
  const visited = O.VisitedKeys;
  // 6. Let remaining be O.[[RemainingKeys]].
  const remaining = O.RemainingKeys;
  // 7. Repeat,
  while (true) {
    // a. If O.[[ObjectWasVisited]] is false, then
    if (O.ObjectWasVisited === Value.false) {
      /* ReturnIfAbrupt */
      let _temp = yield* object.OwnPropertyKeys();
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) return _temp;
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      // i. Let keys be ? object.[[OwnPropertyKeys]]().
      const keys = _temp;
      // ii. for each key of keys in List order, do
      for (const key of keys) {
        // 1. If Type(key) is String, then
        if (key instanceof JSStringValue) {
          // a. Append key to remaining.
          remaining.push(key);
        }
      }
      // iii. Set O.ObjectWasVisited to true.
      O.ObjectWasVisited = Value.true;
    }
    // b. Repeat, while remaining is not empty,
    while (remaining.length > 0) {
      // i. Remove the first element from remaining and let r be the value of the element.
      const r = remaining.shift();
      // ii. If there does not exist an element v of visisted such that SameValue(r, v) is true, then
      if (!visited.find(v => SameValue(r, v) === Value.true)) {
        /* ReturnIfAbrupt */
        let _temp2 = yield* object.GetOwnProperty(r);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        // 1. Let desc be ? object.[[GetOwnProperty]](r).
        const desc = _temp2;
        // 2. If desc is not undefined, then,
        if (!(desc instanceof UndefinedValue)) {
          // a. Append r to visited.
          visited.push(r);
          // b. If desc.[[Enumerable]] is true, return CreateIteratorResultObject(r, false).
          if (desc.Enumerable === Value.true) {
            return CreateIteratorResultObject(r, Value.false);
          }
        }
      }
    }
    // c. Set object to ? object.[[GetPrototypeOf]]().
    /* ReturnIfAbrupt */
    let _temp3 = yield* object.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    object = _temp3;
    // d. Set O.Object to object.
    O.Object = object;
    // e. Set O.ObjectWasVisited to false.
    O.ObjectWasVisited = Value.false;
    // f. If object is null, return CreateIteratorResultObject(undefined, true).
    if (object === Value.null) {
      return CreateIteratorResultObject(Value.undefined, Value.true);
    }
  }
}
ForInIteratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-%foriniteratorprototype%.next';
function bootstrapForInIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', ForInIteratorPrototype_next, 0]], realmRec.Intrinsics['%Iterator.prototype%']);
  realmRec.Intrinsics['%ForInIteratorPrototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-loopcontinues */
function LoopContinues(completion, labelSet) {
  // 1. If completion.[[Type]] is normal, return true.
  if (completion.Type === 'normal') {
    return Value.true;
  }
  // 2. If completion.[[Type]] is not continue, return false.
  if (completion.Type !== 'continue') {
    return Value.false;
  }
  // 3. If completion.[[Target]] is empty, return true.
  if (completion.Target === undefined) {
    return Value.true;
  }
  // 4. If completion.[[Target]] is an element of labelSet, return true.
  if (labelSet.has(completion.Target)) {
    return Value.true;
  }
  // 5. Return false.
  return Value.false;
}
LoopContinues.section = 'https://tc39.es/ecma262/#sec-loopcontinues';
function LabelledEvaluation(node, labelSet) {
  switch (node.type) {
    case 'DoWhileStatement':
    case 'WhileStatement':
    case 'ForStatement':
    case 'ForInStatement':
    case 'ForOfStatement':
    case 'ForAwaitStatement':
    case 'SwitchStatement':
      return LabelledEvaluation_BreakableStatement(node, labelSet);
    case 'LabelledStatement':
      return LabelledEvaluation_LabelledStatement(node, labelSet);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('LabelledEvaluation', node);
  }
}

/** https://tc39.es/ecma262/#sec-labelled-statements-runtime-semantics-labelledevaluation */
//   LabelledStatement : LabelIdentifier `:` LabelledItem
function* LabelledEvaluation_LabelledStatement({
  LabelIdentifier,
  LabelledItem
}, labelSet) {
  // 1. Let label be the StringValue of LabelIdentifier.
  const label = StringValue(LabelIdentifier);
  // 2. Append label as an element of labelSet.
  labelSet.add(label);
  // 3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.
  let stmtResult = EnsureCompletion(yield* LabelledEvaluation_LabelledItem(LabelledItem, labelSet));
  // 4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then
  if (stmtResult.Type === 'break' && SameValue(stmtResult.Target, label) === Value.true) {
    // a. Set stmtResult to NormalCompletion(stmtResult.[[Value]]).
    stmtResult = NormalCompletion(stmtResult.Value);
  }
  // 5. Return Completion(stmtResult).
  return Completion(stmtResult);
}
LabelledEvaluation_LabelledStatement.section = 'https://tc39.es/ecma262/#sec-labelled-statements-runtime-semantics-labelledevaluation'; // LabelledItem :
//   Statement
//   FunctionDeclaration
function LabelledEvaluation_LabelledItem(LabelledItem, labelSet) {
  switch (LabelledItem.type) {
    case 'DoWhileStatement':
    case 'WhileStatement':
    case 'ForStatement':
    case 'ForInStatement':
    case 'ForOfStatement':
    case 'SwitchStatement':
    case 'LabelledStatement':
      return LabelledEvaluation(LabelledItem, labelSet);
    default:
      return Evaluate(LabelledItem);
  }
}

/** https://tc39.es/ecma262/#sec-statement-semantics-runtime-semantics-labelledevaluation */
//  BreakableStatement :
//    IterationStatement
//    SwitchStatement
//
//  IterationStatement :
//    (DoWhileStatement)
//    (WhileStatement)
function* LabelledEvaluation_BreakableStatement(BreakableStatement, labelSet) {
  switch (BreakableStatement.type) {
    case 'DoWhileStatement':
    case 'WhileStatement':
    case 'ForStatement':
    case 'ForInStatement':
    case 'ForOfStatement':
    case 'ForAwaitStatement':
      {
        // 1. Let stmtResult be LabelledEvaluation of IterationStatement with argument labelSet.
        let stmtResult = EnsureCompletion(yield* LabelledEvaluation_IterationStatement(BreakableStatement, labelSet));
        // 2. If stmtResult.[[Type]] is break, then
        if (stmtResult.Type === 'break') {
          // a. If stmtResult.[[Target]] is empty, then
          if (stmtResult.Target === undefined) {
            // i. If stmtResult.[[Value]] is empty, set stmtResult to NormalCompletion(undefined).
            if (stmtResult.Value === undefined) {
              stmtResult = NormalCompletion(Value.undefined);
            } else {
              // ii. Else, set stmtResult to NormalCompletion(stmtResult.[[Value]]).
              stmtResult = NormalCompletion(stmtResult.Value);
            }
          }
        }
        // 3. Return Completion(stmtResult).
        return Completion(stmtResult);
      }
    case 'SwitchStatement':
      {
        // 1. Let stmtResult be LabelledEvaluation of SwitchStatement.
        let stmtResult = EnsureCompletion(yield* Evaluate_SwitchStatement(BreakableStatement));
        // 2. If stmtResult.[[Type]] is break, then
        if (stmtResult.Type === 'break') {
          // a. If stmtResult.[[Target]] is empty, then
          if (stmtResult.Target === undefined) {
            // i. If stmtResult.[[Value]] is empty, set stmtResult to NormalCompletion(undefined).
            if (stmtResult.Value === undefined) {
              stmtResult = NormalCompletion(Value.undefined);
            } else {
              // ii. Else, set stmtResult to NormalCompletion(stmtResult.[[Value]]).
              stmtResult = NormalCompletion(stmtResult.Value);
            }
          }
        }
        // 3. Return Completion(stmtResult).
        return Completion(stmtResult);
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('LabelledEvaluation_BreakableStatement', BreakableStatement);
  }
}
LabelledEvaluation_BreakableStatement.section = 'https://tc39.es/ecma262/#sec-statement-semantics-runtime-semantics-labelledevaluation';
function LabelledEvaluation_IterationStatement(IterationStatement, labelSet) {
  switch (IterationStatement.type) {
    case 'DoWhileStatement':
      return LabelledEvaluation_IterationStatement_DoWhileStatement(IterationStatement, labelSet);
    case 'WhileStatement':
      return LabelledEvaluation_IterationStatement_WhileStatement(IterationStatement, labelSet);
    case 'ForStatement':
      return LabelledEvaluation_BreakableStatement_ForStatement(IterationStatement, labelSet);
    case 'ForInStatement':
      return LabelledEvaluation_IterationStatement_ForInStatement(IterationStatement, labelSet);
    case 'ForOfStatement':
      return LabelledEvaluation_IterationStatement_ForOfStatement(IterationStatement, labelSet);
    case 'ForAwaitStatement':
      return LabelledEvaluation_IterationStatement_ForAwaitStatement(IterationStatement, labelSet);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('LabelledEvaluation_IterationStatement', IterationStatement);
  }
}

/** https://tc39.es/ecma262/#sec-do-while-statement-runtime-semantics-labelledevaluation */
//   IterationStatement :
//     `do` Statement `while` `(` Expression `)` `;`
function* LabelledEvaluation_IterationStatement_DoWhileStatement({
  Statement,
  Expression
}, labelSet) {
  // 1. Let V be undefined.
  let V = Value.undefined;
  // 2. Repeat,
  while (true) {
    // a. Let stmtResult be the result of evaluating Statement.
    const stmtResult = EnsureCompletion(yield* Evaluate(Statement));
    // b. If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).
    if (LoopContinues(stmtResult, labelSet) === Value.false) {
      return Completion(UpdateEmpty(stmtResult, V));
    }
    // c. If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].
    if (stmtResult.Value !== undefined) {
      V = stmtResult.Value;
    }
    // d. Let exprRef be the result of evaluating Expression.
    /* ReturnIfAbrupt */
    let _temp = yield* Evaluate(Expression);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const exprRef = _temp;
    // e. Let exprValue be ? GetValue(exprRef).
    /* ReturnIfAbrupt */
    let _temp2 = yield* GetValue(exprRef);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const exprValue = _temp2;
    // f. If ! ToBoolean(exprValue) is false, return NormalCompletion(V).
    /* X */
    let _temp3 = ToBoolean(exprValue);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(exprValue) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    if (_temp3 === Value.false) {
      return NormalCompletion(V);
    }
  }
}
LabelledEvaluation_IterationStatement_DoWhileStatement.section = 'https://tc39.es/ecma262/#sec-do-while-statement-runtime-semantics-labelledevaluation';
/** https://tc39.es/ecma262/#sec-while-statement-runtime-semantics-labelledevaluation */
//   IterationStatement :
//     `while` `(` Expression `)` Statement
function* LabelledEvaluation_IterationStatement_WhileStatement({
  Expression,
  Statement
}, labelSet) {
  // 1. Let V be undefined.
  let V = Value.undefined;
  // 2. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp4 = yield* Evaluate(Expression);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // a. Let exprRef be the result of evaluating Expression.
    const exprRef = _temp4;
    // b. Let exprValue be ? GetValue(exprRef).
    /* ReturnIfAbrupt */
    let _temp5 = yield* GetValue(exprRef);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    const exprValue = _temp5;
    // c. If ! ToBoolean(exprValue) is false, return NormalCompletion(V).
    /* X */
    let _temp6 = ToBoolean(exprValue);
    /* node:coverage ignore next */
    if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(exprValue) returned an abrupt completion", {
      cause: _temp6
    });
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    if (_temp6 === Value.false) {
      return NormalCompletion(V);
    }
    // d. Let stmtResult be the result of evaluating Statement.
    const stmtResult = EnsureCompletion(yield* Evaluate(Statement));
    // e. If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).
    if (LoopContinues(stmtResult, labelSet) === Value.false) {
      return Completion(UpdateEmpty(stmtResult, V));
    }
    // f. If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].
    if (stmtResult.Value !== undefined) {
      V = stmtResult.Value;
    }
  }
}
LabelledEvaluation_IterationStatement_WhileStatement.section = 'https://tc39.es/ecma262/#sec-while-statement-runtime-semantics-labelledevaluation';
/** https://tc39.es/ecma262/#sec-for-statement-runtime-semantics-labelledevaluation */
//   IterationStatement :
//     `for` `(` Expression? `;` Expression? `;` Expresssion? `)` Statement
//     `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
//     `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
function* LabelledEvaluation_BreakableStatement_ForStatement(ForStatement, labelSet) {
  const {
    VariableDeclarationList,
    LexicalDeclaration,
    Expression_a,
    Expression_b,
    Expression_c,
    Statement
  } = ForStatement;
  switch (true) {
    case !!LexicalDeclaration:
      {
        // 1. Let oldEnv be the running execution context's LexicalEnvironment.
        const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
        // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).
        const loopEnv = new DeclarativeEnvironmentRecord(oldEnv);
        // 3. Let isConst be IsConstantDeclaration of LexicalDeclaration.
        const isConst = IsConstantDeclaration(LexicalDeclaration);
        // 4. Let boundNames be the BoundNames of LexicalDeclaration.
        const boundNames = BoundNames(LexicalDeclaration);
        // 5. For each element dn of boundNames, do
        for (const dn of boundNames) {
          // a. If isConst is true, then
          if (isConst) {
            /* X */
            let _temp7 = loopEnv.CreateImmutableBinding(dn, Value.true);
            /* node:coverage ignore next */
            if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
            /* node:coverage ignore next */
            if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! loopEnv.CreateImmutableBinding(dn, Value.true) returned an abrupt completion", {
              cause: _temp7
            });
            /* node:coverage ignore next */
            if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
          } else {
            /* X */
            let _temp8 = loopEnv.CreateMutableBinding(dn, Value.false);
            /* node:coverage ignore next */
            if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
            /* node:coverage ignore next */
            if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! loopEnv.CreateMutableBinding(dn, Value.false) returned an abrupt completion", {
              cause: _temp8
            });
            /* node:coverage ignore next */
            if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
          }
        }
        // 6. Set the running execution context's LexicalEnvironment to loopEnv.
        surroundingAgent.runningExecutionContext.LexicalEnvironment = loopEnv;
        // 7. Let forDcl be the result of evaluating LexicalDeclaration.
        const forDcl = yield* Evaluate(LexicalDeclaration);
        // 8. If forDcl is an abrupt completion, then
        if (forDcl instanceof AbruptCompletion) {
          // a. Set the running execution context's LexicalEnvironment to oldEnv.
          surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
          // b. Return Completion(forDcl).
          return Completion(forDcl);
        }
        // 9. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».
        let perIterationLets;
        if (isConst === false) {
          perIterationLets = boundNames;
        } else {
          perIterationLets = [];
        }
        // 10. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).
        const bodyResult = yield* ForBodyEvaluation(Expression_a, Expression_b, Statement, perIterationLets, labelSet);
        // 11. Set the running execution context's LexicalEnvironment to oldEnv.
        surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
        // 12. Return Completion(bodyResult).
        return Completion(bodyResult);
      }
    case !!VariableDeclarationList:
      {
        // 1. Let varDcl be the result of evaluating VariableDeclarationList.
        let varDcl = yield* Evaluate_VariableDeclarationList(VariableDeclarationList);
        // 2. ReturnIfAbrupt(varDcl).
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (varDcl && typeof varDcl === 'object' && 'next' in varDcl) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (varDcl instanceof AbruptCompletion) return varDcl;
        /* node:coverage ignore next */
        if (varDcl instanceof Completion) varDcl = varDcl.Value;
        // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).
        return yield* ForBodyEvaluation(Expression_a, Expression_b, Statement, [], labelSet);
      }
    default:
      {
        // 1. If the first Expression is present, then
        if (Expression_a) {
          /* ReturnIfAbrupt */
          let _temp9 = yield* Evaluate(Expression_a);
          /* node:coverage ignore next */
          if (_temp9 instanceof AbruptCompletion) return _temp9;
          /* node:coverage ignore next */
          if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
          // a. Let exprRef be the result of evaluating the first Expression.
          const exprRef = _temp9;
          // b. Perform ? GetValue(exprRef).
          /* ReturnIfAbrupt */
          let _temp10 = yield* GetValue(exprRef);
          /* node:coverage ignore next */
          if (_temp10 instanceof AbruptCompletion) return _temp10;
          /* node:coverage ignore next */
          if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
        }
        // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).
        return yield* ForBodyEvaluation(Expression_b, Expression_c, Statement, [], labelSet);
      }
  }
}
LabelledEvaluation_BreakableStatement_ForStatement.section = 'https://tc39.es/ecma262/#sec-for-statement-runtime-semantics-labelledevaluation';
function* LabelledEvaluation_IterationStatement_ForInStatement(ForInStatement, labelSet) {
  const {
    LeftHandSideExpression,
    ForBinding,
    ForDeclaration,
    Expression,
    Statement
  } = ForInStatement;
  switch (true) {
    case !!LeftHandSideExpression && !!Expression:
      {
        /* ReturnIfAbrupt */
        let _temp11 = yield* ForInOfHeadEvaluation([], Expression, 'enumerate');
        /* node:coverage ignore next */
        if (_temp11 instanceof AbruptCompletion) return _temp11;
        /* node:coverage ignore next */
        if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
        // IterationStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        const keyResult = _temp11;
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate, assignment, labelSet).
        return yield* ForInOfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, 'enumerate', 'assignment', labelSet);
      }
    case !!ForBinding && !!Expression:
      {
        /* ReturnIfAbrupt */
        let _temp12 = yield* ForInOfHeadEvaluation([], Expression, 'enumerate');
        /* node:coverage ignore next */
        if (_temp12 instanceof AbruptCompletion) return _temp12;
        /* node:coverage ignore next */
        if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
        // IterationStatement :`for` `(` `var` ForBinding `in` Expression `)` Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        const keyResult = _temp12;
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate, varBinding, labelSet).
        return yield* ForInOfBodyEvaluation(ForBinding, Statement, keyResult, 'enumerate', 'varBinding', labelSet);
      }
    case !!ForDeclaration && !!Expression:
      {
        /* ReturnIfAbrupt */
        let _temp13 = yield* ForInOfHeadEvaluation(BoundNames(ForDeclaration), Expression, 'enumerate');
        /* node:coverage ignore next */
        if (_temp13 instanceof AbruptCompletion) return _temp13;
        /* node:coverage ignore next */
        if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
        // IterationStatement : `for` `(` ForDeclaration `in` Expression `)` Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).
        const keyResult = _temp13;
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate, lexicalBinding, labelSet).
        return yield* ForInOfBodyEvaluation(ForDeclaration, Statement, keyResult, 'enumerate', 'lexicalBinding', labelSet);
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('LabelledEvaluation_IterationStatement_ForInStatement', ForInStatement);
  }
}

// IterationStatement :
//   `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
//   `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
//   `for` `await` `(` ForDeclaration`of` AssignmentExpression `)` Statement
function* LabelledEvaluation_IterationStatement_ForAwaitStatement(ForAwaitStatement, labelSet) {
  const {
    LeftHandSideExpression,
    ForBinding,
    ForDeclaration,
    AssignmentExpression,
    Statement
  } = ForAwaitStatement;
  switch (true) {
    case !!LeftHandSideExpression:
      {
        /* ReturnIfAbrupt */
        let _temp14 = yield* ForInOfHeadEvaluation([], AssignmentExpression, 'async-iterate');
        /* node:coverage ignore next */
        if (_temp14 instanceof AbruptCompletion) return _temp14;
        /* node:coverage ignore next */
        if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).
        const keyResult = _temp14;
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet, async).
        return yield* ForInOfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, 'iterate', 'assignment', labelSet, 'async');
      }
    case !!ForBinding:
      {
        /* ReturnIfAbrupt */
        let _temp15 = yield* ForInOfHeadEvaluation([], AssignmentExpression, 'async-iterate');
        /* node:coverage ignore next */
        if (_temp15 instanceof AbruptCompletion) return _temp15;
        /* node:coverage ignore next */
        if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).
        const keyResult = _temp15;
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet, async).
        return yield* ForInOfBodyEvaluation(ForBinding, Statement, keyResult, 'iterate', 'varBinding', labelSet, 'async');
      }
    case !!ForDeclaration:
      {
        /* ReturnIfAbrupt */
        let _temp16 = yield* ForInOfHeadEvaluation(BoundNames(ForDeclaration), AssignmentExpression, 'async-iterate');
        /* node:coverage ignore next */
        if (_temp16 instanceof AbruptCompletion) return _temp16;
        /* node:coverage ignore next */
        if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, async-iterate).
        const keyResult = _temp16;
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet, async).
        return yield* ForInOfBodyEvaluation(ForDeclaration, Statement, keyResult, 'iterate', 'lexicalBinding', labelSet, 'async');
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('LabelledEvaluation_IterationStatement_ForAwaitStatement', ForAwaitStatement);
  }
}

/** https://tc39.es/ecma262/#sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation */
// IterationStatement :
//   `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
//   `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
//   `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
function* LabelledEvaluation_IterationStatement_ForOfStatement(ForOfStatement, labelSet) {
  const {
    LeftHandSideExpression,
    ForBinding,
    ForDeclaration,
    AssignmentExpression,
    Statement
  } = ForOfStatement;
  switch (true) {
    case !!LeftHandSideExpression:
      {
        /* ReturnIfAbrupt */
        let _temp17 = yield* ForInOfHeadEvaluation([], AssignmentExpression, 'iterate');
        /* node:coverage ignore next */
        if (_temp17 instanceof AbruptCompletion) return _temp17;
        /* node:coverage ignore next */
        if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).
        const keyResult = _temp17;
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet).
        return yield* ForInOfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, 'iterate', 'assignment', labelSet);
      }
    case !!ForBinding:
      {
        /* ReturnIfAbrupt */
        let _temp18 = yield* ForInOfHeadEvaluation([], AssignmentExpression, 'iterate');
        /* node:coverage ignore next */
        if (_temp18 instanceof AbruptCompletion) return _temp18;
        /* node:coverage ignore next */
        if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).
        const keyResult = _temp18;
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet).
        return yield* ForInOfBodyEvaluation(ForBinding, Statement, keyResult, 'iterate', 'varBinding', labelSet);
      }
    case !!ForDeclaration:
      {
        /* ReturnIfAbrupt */
        let _temp19 = yield* ForInOfHeadEvaluation(BoundNames(ForDeclaration), AssignmentExpression, 'iterate');
        /* node:coverage ignore next */
        if (_temp19 instanceof AbruptCompletion) return _temp19;
        /* node:coverage ignore next */
        if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).
        const keyResult = _temp19;
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet).
        return yield* ForInOfBodyEvaluation(ForDeclaration, Statement, keyResult, 'iterate', 'lexicalBinding', labelSet);
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('LabelledEvaluation_BreakableStatement_ForOfStatement', ForOfStatement);
  }
}
LabelledEvaluation_IterationStatement_ForOfStatement.section = 'https://tc39.es/ecma262/#sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation';
/** https://tc39.es/ecma262/#sec-forbodyevaluation */
function* ForBodyEvaluation(test, increment, stmt, perIterationBindings, labelSet) {
  // 1. Let V be undefined.
  let V = Value.undefined;
  // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).
  /* ReturnIfAbrupt */
  let _temp20 = yield* CreatePerIterationEnvironment(perIterationBindings);
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  // 3. Repeat,
  while (true) {
    // a. If test is not [empty], then
    if (test) {
      /* ReturnIfAbrupt */
      let _temp21 = yield* Evaluate(test);
      /* node:coverage ignore next */
      if (_temp21 instanceof AbruptCompletion) return _temp21;
      /* node:coverage ignore next */
      if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
      // i. Let testRef be the result of evaluating test.
      const testRef = _temp21;
      // ii. Let testValue be ? GetValue(testRef).
      /* ReturnIfAbrupt */
      let _temp22 = yield* GetValue(testRef);
      /* node:coverage ignore next */
      if (_temp22 instanceof AbruptCompletion) return _temp22;
      /* node:coverage ignore next */
      if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
      const testValue = _temp22;
      // iii. If ! ToBoolean(testValue) is false, return NormalCompletion(V).
      /* X */
      let _temp23 = ToBoolean(testValue);
      /* node:coverage ignore next */
      if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) _temp23 = skipDebugger(_temp23);
      /* node:coverage ignore next */
      if (_temp23 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(testValue) returned an abrupt completion", {
        cause: _temp23
      });
      /* node:coverage ignore next */
      if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
      if (_temp23 === Value.false) {
        return NormalCompletion(V);
      }
    }
    // b. Let result be the result of evaluating stmt.
    const result = EnsureCompletion(yield* Evaluate(stmt));
    // c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).
    if (LoopContinues(result, labelSet) === Value.false) {
      return Completion(UpdateEmpty(result, V));
    }
    // d. If result.[[Value]] is not empty, set V to result.[[Value]].
    if (result.Value !== undefined) {
      V = result.Value;
    }
    // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).
    /* ReturnIfAbrupt */
    let _temp24 = yield* CreatePerIterationEnvironment(perIterationBindings);
    /* node:coverage ignore next */
    if (_temp24 instanceof AbruptCompletion) return _temp24;
    /* node:coverage ignore next */
    if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
    // f. If increment is not [empty], then
    if (increment) {
      /* ReturnIfAbrupt */
      let _temp25 = yield* Evaluate(increment);
      /* node:coverage ignore next */
      if (_temp25 instanceof AbruptCompletion) return _temp25;
      /* node:coverage ignore next */
      if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
      // i. Let incRef be the result of evaluating increment.
      const incRef = _temp25;
      // ii. Perform ? GetValue(incRef).
      /* ReturnIfAbrupt */
      let _temp26 = yield* GetValue(incRef);
      /* node:coverage ignore next */
      if (_temp26 instanceof AbruptCompletion) return _temp26;
      /* node:coverage ignore next */
      if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
    }
  }
}
ForBodyEvaluation.section = 'https://tc39.es/ecma262/#sec-forbodyevaluation';
/** https://tc39.es/ecma262/#sec-createperiterationenvironment */
function* CreatePerIterationEnvironment(perIterationBindings) {
  // 1. If perIterationBindings has any elements, then
  if (perIterationBindings.length > 0) {
    // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.
    const lastIterationEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    // b. Let outer be lastIterationEnv.[[OuterEnv]].
    const outer = lastIterationEnv.OuterEnv;
    // c. Assert: outer is not null.
    Assert(outer !== Value.null, "outer !== Value.null");
    // d. Let thisIterationEnv be NewDeclarativeEnvironment(outer).
    const thisIterationEnv = new DeclarativeEnvironmentRecord(outer);
    // e. For each element bn of perIterationBindings, do
    for (const bn of perIterationBindings) {
      /* X */
      let _temp27 = thisIterationEnv.CreateMutableBinding(bn, Value.false);
      /* node:coverage ignore next */
      if (_temp27 && typeof _temp27 === 'object' && 'next' in _temp27) _temp27 = skipDebugger(_temp27);
      /* node:coverage ignore next */
      if (_temp27 instanceof AbruptCompletion) throw new Assert.Error("! thisIterationEnv.CreateMutableBinding(bn, Value.false) returned an abrupt completion", {
        cause: _temp27
      });
      /* node:coverage ignore next */
      if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
      // ii. Let lastValue be ? lastIterationEnv.GetBindingValue(bn, true).
      /* ReturnIfAbrupt */
      let _temp28 = yield* lastIterationEnv.GetBindingValue(bn, Value.true);
      /* node:coverage ignore next */
      if (_temp28 instanceof AbruptCompletion) return _temp28;
      /* node:coverage ignore next */
      if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
      const lastValue = _temp28;
      // iii. Perform thisIterationEnv.InitializeBinding(bn, lastValue).
      yield* thisIterationEnv.InitializeBinding(bn, lastValue);
    }
    // f. Set the running execution context's LexicalEnvironment to thisIterationEnv.
    surroundingAgent.runningExecutionContext.LexicalEnvironment = thisIterationEnv;
  }
  // 2. Return undefined.
  return undefined;
}
CreatePerIterationEnvironment.section = 'https://tc39.es/ecma262/#sec-createperiterationenvironment';
/** https://tc39.es/ecma262/#sec-runtime-semantics-forinofheadevaluation */
function* ForInOfHeadEvaluation(uninitializedBoundNames, expr, iterationKind) {
  // 1. Let oldEnv be the running execution context's LexicalEnvironment.
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 2. If uninitializedBoundNames is not an empty List, then
  if (uninitializedBoundNames.length > 0) {
    // a. Assert: uninitializedBoundNames has no duplicate entries.
    // b. Let newEnv be NewDeclarativeEnvironment(oldEnv).
    const newEnv = new DeclarativeEnvironmentRecord(oldEnv);
    // c. For each string name in uninitializedBoundNames, do
    for (const name of uninitializedBoundNames) {
      /* X */
      let _temp29 = newEnv.CreateMutableBinding(name, Value.false);
      /* node:coverage ignore next */
      if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) _temp29 = skipDebugger(_temp29);
      /* node:coverage ignore next */
      if (_temp29 instanceof AbruptCompletion) throw new Assert.Error("! newEnv.CreateMutableBinding(name, Value.false) returned an abrupt completion", {
        cause: _temp29
      });
      /* node:coverage ignore next */
      if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
    }
    // d. Set the running execution context's LexicalEnvironment to newEnv.
    surroundingAgent.runningExecutionContext.LexicalEnvironment = newEnv;
  }
  // 3. Let exprRef be the result of evaluating expr.
  /* ReturnIfAbrupt */
  let _temp30 = yield* Evaluate(expr);
  /* node:coverage ignore next */
  if (_temp30 instanceof AbruptCompletion) return _temp30;
  /* node:coverage ignore next */
  if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
  const exprRef = _temp30;
  // 4. Set the running execution context's LexicalEnvironment to oldEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  // 5. Let exprValue be ? GetValue(exprRef).
  /* ReturnIfAbrupt */
  let _temp31 = yield* GetValue(exprRef);
  /* node:coverage ignore next */
  if (_temp31 instanceof AbruptCompletion) return _temp31;
  /* node:coverage ignore next */
  if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
  const exprValue = _temp31;
  // 6. If iterationKind is enumerate, then
  if (iterationKind === 'enumerate') {
    // a. If exprValue is undefined or null, then
    if (exprValue === Value.undefined || exprValue === Value.null) {
      // i. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.
      return new Completion({
        Type: 'break',
        Value: undefined,
        Target: undefined
      });
    }
    // b. Let obj be ! ToObject(exprValue).
    /* X */
    let _temp32 = ToObject(exprValue);
    /* node:coverage ignore next */
    if (_temp32 && typeof _temp32 === 'object' && 'next' in _temp32) _temp32 = skipDebugger(_temp32);
    /* node:coverage ignore next */
    if (_temp32 instanceof AbruptCompletion) throw new Assert.Error("! ToObject(exprValue) returned an abrupt completion", {
      cause: _temp32
    });
    /* node:coverage ignore next */
    if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
    const obj = _temp32;
    // c. Let iterator be ? EnumerateObjectProperties(obj).
    /* ReturnIfAbrupt */
    let _temp33 = EnumerateObjectProperties(obj);
    /* node:coverage ignore next */
    if (_temp33 && typeof _temp33 === 'object' && 'next' in _temp33) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp33 instanceof AbruptCompletion) return _temp33;
    /* node:coverage ignore next */
    if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
    const iterator = _temp33;
    // d. Let nextMethod be ! GetV(iterator, "next").
    /* X */
    let _temp34 = GetV(iterator, Value('next'));
    /* node:coverage ignore next */
    if (_temp34 && typeof _temp34 === 'object' && 'next' in _temp34) _temp34 = skipDebugger(_temp34);
    /* node:coverage ignore next */
    if (_temp34 instanceof AbruptCompletion) throw new Assert.Error("! GetV(iterator, Value('next')) returned an abrupt completion", {
      cause: _temp34
    });
    /* node:coverage ignore next */
    if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
    const nextMethod = _temp34;
    // e. Return the Record { [[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false }.
    return {
      Iterator: iterator,
      NextMethod: nextMethod,
      Done: Value.false
    };
  } else {
    // 7. Else,
    // a. Assert: iterationKind is iterate or async-iterate.
    Assert(iterationKind === 'iterate' || iterationKind === 'async-iterate', "iterationKind === 'iterate' || iterationKind === 'async-iterate'");
    // b. If iterationKind is async-iterate, let iteratorHint be async.
    // c. Else, let iteratorHint be sync.
    const iteratorHint = iterationKind === 'async-iterate' ? 'async' : 'sync';
    // d. Return ? GetIterator(exprValue, iteratorHint).
    return yield* GetIterator(exprValue, iteratorHint);
  }
}
ForInOfHeadEvaluation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-forinofheadevaluation';
/** https://tc39.es/ecma262/#sec-enumerate-object-properties */
function EnumerateObjectProperties(O) {
  return CreateForInIterator(O);
}
EnumerateObjectProperties.section = 'https://tc39.es/ecma262/#sec-enumerate-object-properties';
/** https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset */
function* ForInOfBodyEvaluation(lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet, iteratorKind) {
  // 1. If iteratorKind is not present, set iteratorKind to sync.
  if (iteratorKind === undefined) {
    iteratorKind = 'sync';
  }
  // 2. Let oldEnv be the running execution context's LexicalEnvironment.
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 3. Let V be undefined.
  let V = Value.undefined;
  // 4. Let destructuring be IsDestructuring of lhs.
  const destructuring = IsDestructuring(lhs);
  // 5. If destructuring is true and if lhsKind is assignment, then
  let assignmentPattern;
  if (destructuring && lhsKind === 'assignment') {
    // a. Assert: lhs is a LeftHandSideExpression.
    // b. Let assignmentPattern be the AssignmentPattern that is covered by lhs.
    assignmentPattern = refineLeftHandSideExpression(lhs);
  }
  // 6. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp35 = yield* Call(iteratorRecord.NextMethod, iteratorRecord.Iterator);
    /* node:coverage ignore next */
    if (_temp35 instanceof AbruptCompletion) return _temp35;
    /* node:coverage ignore next */
    if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
    // a. Let nextResult be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]]).
    let nextResult = _temp35;
    // b. If iteratorKind is async, then set nextResult to ? Await(nextResult).
    if (iteratorKind === 'async') {
      /* ReturnIfAbrupt */
      let _temp36 = yield* Await(nextResult);
      /* node:coverage ignore next */
      if (_temp36 instanceof AbruptCompletion) return _temp36;
      /* node:coverage ignore next */
      if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
      nextResult = _temp36;
    }
    // c. If Type(nextResult) is not Object, throw a TypeError exception.
    if (!(nextResult instanceof ObjectValue)) {
      return surroundingAgent.Throw('TypeError', 'NotAnObject', nextResult);
    }
    // d. Let done be ? IteratorComplete(nextResult).
    /* ReturnIfAbrupt */
    let _temp37 = yield* IteratorComplete(nextResult);
    /* node:coverage ignore next */
    if (_temp37 instanceof AbruptCompletion) return _temp37;
    /* node:coverage ignore next */
    if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
    const done = _temp37;
    // e. If done is true, return NormalCompletion(V).
    if (done === Value.true) {
      return NormalCompletion(V);
    }
    // f. Let nextValue be ? IteratorValue(nextResult).
    /* ReturnIfAbrupt */
    let _temp38 = yield* IteratorValue(nextResult);
    /* node:coverage ignore next */
    if (_temp38 instanceof AbruptCompletion) return _temp38;
    /* node:coverage ignore next */
    if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
    const nextValue = _temp38;
    // g. If lhsKind is either assignment or varBinding, then
    let lhsRef;
    let iterationEnv;
    if (lhsKind === 'assignment' || lhsKind === 'varBinding') {
      // i. If destructuring is false, then
      if (destructuring === false) {
        // 1. Let lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)
        lhsRef = yield* Evaluate(lhs);
      }
    } else {
      // h. Else,
      // i. Assert: lhsKind is lexicalBinding.
      Assert(lhsKind === 'lexicalBinding', "lhsKind === 'lexicalBinding'");
      // ii. Assert: lhs is a ForDeclaration.
      Assert(lhs.type === 'ForDeclaration', "lhs.type === 'ForDeclaration'");
      // iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).
      iterationEnv = new DeclarativeEnvironmentRecord(oldEnv);
      // iv. Perform BindingInstantiation for lhs passing iterationEnv as the argument.
      BindingInstantiation(lhs, iterationEnv);
      // v. Set the running execution context's LexicalEnvironment to iterationEnv.
      surroundingAgent.runningExecutionContext.LexicalEnvironment = iterationEnv;
      // vi. If destructuring is false, then
      if (destructuring === false) {
        // 1. Assert: lhs binds a single name.
        // 2. Let lhsName be the sole element of BoundNames of lhs.
        const lhsName = BoundNames(lhs)[0];
        // 3. Let lhsRef be ! ResolveBinding(lhsName).
        /* X */
        let _temp39 = ResolveBinding(lhsName, undefined, lhs.strict);
        /* node:coverage ignore next */
        if (_temp39 && typeof _temp39 === 'object' && 'next' in _temp39) _temp39 = skipDebugger(_temp39);
        /* node:coverage ignore next */
        if (_temp39 instanceof AbruptCompletion) throw new Assert.Error("! ResolveBinding(lhsName, undefined, lhs.strict) returned an abrupt completion", {
          cause: _temp39
        });
        /* node:coverage ignore next */
        if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
        lhsRef = _temp39;
      }
    }
    let status;
    // i. If destructuring is false, then
    if (destructuring === false) {
      // i. If lhsRef is an abrupt completion, then
      if (lhsRef instanceof AbruptCompletion) {
        // 1. Let status be lhsRef.
        status = lhsRef;
      } else if (lhsKind === 'lexicalBinding') {
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (lhsRef && typeof lhsRef === 'object' && 'next' in lhsRef) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (lhsRef instanceof AbruptCompletion) return lhsRef;
        /* node:coverage ignore next */
        if (lhsRef instanceof Completion) lhsRef = lhsRef.Value;
        // ii. Else is lhsKind is lexicalBinding, then
        // 1. Let status be InitializeReferencedBinding(lhsRef, nextValue).
        status = yield* InitializeReferencedBinding(lhsRef, nextValue);
      } else {
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (lhsRef && typeof lhsRef === 'object' && 'next' in lhsRef) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (lhsRef instanceof AbruptCompletion) return lhsRef;
        /* node:coverage ignore next */
        if (lhsRef instanceof Completion) lhsRef = lhsRef.Value;
        // iii. Else,
        status = yield* PutValue(lhsRef, nextValue);
      }
    } else {
      // j. Else,
      // i. If lhsKind is assignment, then
      if (lhsKind === 'assignment') {
        // 1. Let status be DestructuringAssignmentEvaluation of assignmentPattern with argument nextValue.
        status = yield* DestructuringAssignmentEvaluation(assignmentPattern, nextValue);
      } else if (lhsKind === 'varBinding') {
        // ii. Else if lhsKind is varBinding, then
        // 1. Assert: lhs is a ForBinding.
        Assert(lhs.type === 'ForBinding', "lhs.type === 'ForBinding'");
        // 2. Let status be BindingInitialization of lhs with arguments nextValue and undefined.
        status = yield* BindingInitialization(lhs, nextValue, Value.undefined);
      } else {
        // iii. Else,
        // 1. Assert: lhsKind is lexicalBinding.
        Assert(lhsKind === 'lexicalBinding', "lhsKind === 'lexicalBinding'");
        // 2. Assert: lhs is a ForDeclaration.
        Assert(lhs.type === 'ForDeclaration', "lhs.type === 'ForDeclaration'");
        // 3. Let status be BindingInitialization of lhs with arguments nextValue and iterationEnv.
        status = yield* BindingInitialization(lhs, nextValue, iterationEnv);
      }
    }
    // k. If status is an abrupt completion, then
    if (status instanceof AbruptCompletion) {
      // i. Set the running execution context's LexicalEnvironment to oldEnv.
      surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
      // ii. If iteratorKind is async, return ? AsyncIteratorClose(iteratorRecord, status).
      if (iteratorKind === 'async') {
        return yield* AsyncIteratorClose(iteratorRecord, status);
      }
      // iii. if iterationKind is enumerate, then
      if (iterationKind === 'enumerate') {
        // 1. Return status.
        return status;
      } else {
        // iv. Else,
        // 1. Assert: iterationKind is iterate.
        Assert(iterationKind === 'iterate', "iterationKind === 'iterate'");
        // 2 .Return ? IteratorClose(iteratorRecord, status).
        return yield* IteratorClose(iteratorRecord, EnsureCompletion(status));
      }
    }
    // l. Let result be the result of evaluating stmt.
    const result = EnsureCompletion(yield* Evaluate(stmt));
    // m. Set the running execution context's LexicalEnvironment to oldEnv.
    surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
    // n. If LoopContinues(result, labelSet) is false, then
    if (LoopContinues(result, labelSet) === Value.false) {
      // i. If iterationKind is enumerate, then
      if (iterationKind === 'enumerate') {
        // 1. Return Completion(UpdateEmpty(result, V)).
        return Completion(UpdateEmpty(result, V));
      } else {
        // ii. Else,
        // 1. Assert: iterationKind is iterate.
        Assert(iterationKind === 'iterate', "iterationKind === 'iterate'");
        // 2. Set status to UpdateEmpty(result, V).
        status = UpdateEmpty(result, V);
        // 3. If iteratorKind is async, return ? AsyncIteratorClose(iteratorRecord, status).
        if (iteratorKind === 'async') {
          return yield* AsyncIteratorClose(iteratorRecord, status);
        }
        // 4. Return ? IteratorClose(iteratorRecord, status).
        return yield* IteratorClose(iteratorRecord, EnsureCompletion(status));
      }
    }
    // o. If result.[[Value]] is not empty, set V to result.[[Value]].
    if (result.Value !== undefined) {
      V = result.Value;
    }
  }
}
ForInOfBodyEvaluation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset';
/** https://tc39.es/ecma262/#sec-runtime-semantics-bindinginstantiation */
//   ForDeclaration : LetOrConst ForBinding
function BindingInstantiation({
  LetOrConst,
  ForBinding
}, environment) {
  // 1. Assert: environment is a declarative Environment Record.
  Assert(environment instanceof DeclarativeEnvironmentRecord, "environment instanceof DeclarativeEnvironmentRecord");
  // 2. For each element name of the BoundNames of ForBinding, do
  for (const name of BoundNames(ForBinding)) {
    // a. If IsConstantDeclaration of LetOrConst is true, then
    if (IsConstantDeclaration(LetOrConst)) {
      /* X */
      let _temp40 = environment.CreateImmutableBinding(name, Value.true);
      /* node:coverage ignore next */
      if (_temp40 && typeof _temp40 === 'object' && 'next' in _temp40) _temp40 = skipDebugger(_temp40);
      /* node:coverage ignore next */
      if (_temp40 instanceof AbruptCompletion) throw new Assert.Error("! environment.CreateImmutableBinding(name, Value.true) returned an abrupt completion", {
        cause: _temp40
      });
      /* node:coverage ignore next */
      if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
    } else {
      /* X */
      let _temp41 = environment.CreateMutableBinding(name, Value.false);
      /* node:coverage ignore next */
      if (_temp41 && typeof _temp41 === 'object' && 'next' in _temp41) _temp41 = skipDebugger(_temp41);
      /* node:coverage ignore next */
      if (_temp41 instanceof AbruptCompletion) throw new Assert.Error("! environment.CreateMutableBinding(name, Value.false) returned an abrupt completion", {
        cause: _temp41
      });
      /* node:coverage ignore next */
      if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
    }
  }
}
BindingInstantiation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-bindinginstantiation';
/** https://tc39.es/ecma262/#sec-for-in-and-for-of-statements-runtime-semantics-evaluation */
//   ForBinding : BindingIdentifier
function Evaluate_ForBinding({
  BindingIdentifier,
  strict
}) {
  // 1. Let bindingId be StringValue of BindingIdentifier.
  const bindingId = StringValue(BindingIdentifier);
  // 2. Return ? ResolveBinding(bindingId).
  return ResolveBinding(bindingId, undefined, strict);
}
Evaluate_ForBinding.section = 'https://tc39.es/ecma262/#sec-for-in-and-for-of-statements-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-template-literals-runtime-semantics-evaluation */
//   TemplateLiteral : NoSubstitutionTemplate
//   SubstitutionTemplate : TemplateHead Expression TemplateSpans
//   TemplateSpans : TemplateTail
//   TemplateSpans : TemplateMiddleList TemplateTail
//   TemplateMiddleList : TemplateMiddle Expression
//   TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
//
// (implicit)
//   TemplateLiteral : SubstitutionTemplate
function* Evaluate_TemplateLiteral({
  TemplateSpanList,
  ExpressionList
}) {
  let str = '';
  for (let i = 0; i < TemplateSpanList.length - 1; i += 1) {
    const Expression = ExpressionList[i];
    const head = TV(TemplateSpanList[i]);
    // 2. Let subRef be the result of evaluating Expression.
    /* ReturnIfAbrupt */
    let _temp = yield* Evaluate(Expression);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const subRef = _temp;
    // 3. Let sub be ? GetValue(subRef).
    /* ReturnIfAbrupt */
    let _temp2 = yield* GetValue(subRef);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const sub = _temp2;
    // 4. Let middle be ? ToString(sub).
    /* ReturnIfAbrupt */
    let _temp3 = yield* ToString(sub);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const middle = _temp3;
    str += head;
    str += middle.stringValue();
  }
  const tail = TV(TemplateSpanList[TemplateSpanList.length - 1]);
  return Value(str + tail);
}
Evaluate_TemplateLiteral.section = 'https://tc39.es/ecma262/#sec-template-literals-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected */
function* CaseClauseIsSelected(C, input) {
  // 1. Assert: C is an instance of the production  CaseClause : `case` Expression `:` StatementList?.
  Assert(C.type === 'CaseClause', "C.type === 'CaseClause'");
  // 2. Let exprRef be the result of evaluating the Expression of C.
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(C.Expression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const exprRef = _temp;
  // 3. Let clauseSelector be ? GetValue(exprRef).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(exprRef);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const clauseSelector = _temp2;
  // 4. Return the result of performing Strict Equality Comparison input === clauseSelector.
  return IsStrictlyEqual(input, clauseSelector);
}
CaseClauseIsSelected.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected';
/** https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation */
//   CaseBlock :
//     `{` `}`
//     `{` CaseClauses `}`
//     `{` CaseClauses? DefaultClause CaseClauses? `}`
function* CaseBlockEvaluation({
  CaseClauses_a,
  DefaultClause,
  CaseClauses_b
}, input) {
  switch (true) {
    case !CaseClauses_a && !DefaultClause && !CaseClauses_b:
      {
        // 1. Return NormalCompletion(undefined).
        return NormalCompletion(Value.undefined);
      }
    case !!CaseClauses_a && !DefaultClause && !CaseClauses_b:
      {
        // 1. Let V be undefined.
        let V = Value.undefined;
        // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.
        const A = CaseClauses_a;
        // 3. Let found be false.
        let found = Value.false;
        // 4. For each CaseClause C in A, do
        for (const C of A) {
          // a. If found is false, then
          if (found === Value.false) {
            /* ReturnIfAbrupt */
            let _temp3 = yield* CaseClauseIsSelected(C, input);
            /* node:coverage ignore next */
            if (_temp3 instanceof AbruptCompletion) return _temp3;
            /* node:coverage ignore next */
            if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
            // i. Set found to ? CaseClauseIsSelected(C, input).
            found = _temp3;
          }
          // b. If found is true, them
          if (found === Value.true) {
            // i. Let R be the result of evaluating C.
            const R = EnsureCompletion(yield* Evaluate(C));
            // ii. If R.[[Value]] is not empty, set V to R.[[Value]].
            if (R.Value !== undefined) {
              V = R.Value;
            }
            // iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
            if (R instanceof AbruptCompletion) {
              return Completion(UpdateEmpty(R, V));
            }
          }
        }
        // 5. Return NormalCompletion(V).
        return NormalCompletion(V);
      }
    case !!DefaultClause:
      {
        // 1. Let V be undefined.
        let V = Value.undefined;
        // 2. If the first CaseClauses is present, then
        let A;
        if (CaseClauses_a) {
          // a. Let A be the List of CaseClause items in the first CaseClauses, in source text order.
          A = CaseClauses_a;
        } else {
          // 3. Else,
          // a. Let A be « ».
          A = [];
        }
        let found = Value.false;
        // 4. For each CaseClause C in A, do
        for (const C of A) {
          // a. If found is false, then
          if (found === Value.false) {
            /* ReturnIfAbrupt */
            let _temp4 = yield* CaseClauseIsSelected(C, input);
            /* node:coverage ignore next */
            if (_temp4 instanceof AbruptCompletion) return _temp4;
            /* node:coverage ignore next */
            if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
            // i. Set found to ? CaseClauseIsSelected(C, input).
            found = _temp4;
          }
          // b. If found is true, them
          if (found === Value.true) {
            // i. Let R be the result of evaluating C.
            const R = EnsureCompletion(yield* Evaluate(C));
            // ii. If R.[[Value]] is not empty, set V to R.[[Value]].
            if (R.Value !== undefined) {
              V = R.Value;
            }
            // iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
            if (R instanceof AbruptCompletion) {
              return Completion(UpdateEmpty(R, V));
            }
          }
        }
        // 6. Let foundInB be false.
        let foundInB = Value.false;
        // 7. If the second CaseClauses is present, then
        let B;
        if (CaseClauses_b) {
          // a. Let B be the List of CaseClause items in the second CaseClauses, in source text order.
          B = CaseClauses_b;
        } else {
          // 8. Else,
          // a. Let B be « ».
          B = [];
        }
        // 9. If found is false, then
        if (found === Value.false) {
          // a. For each CaseClause C in B, do
          for (const C of B) {
            // a. If foundInB is false, then
            if (foundInB === Value.false) {
              /* ReturnIfAbrupt */
              let _temp5 = yield* CaseClauseIsSelected(C, input);
              /* node:coverage ignore next */
              if (_temp5 instanceof AbruptCompletion) return _temp5;
              /* node:coverage ignore next */
              if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
              // i. Set foundInB to ? CaseClauseIsSelected(C, input).
              foundInB = _temp5;
            }
            // b. If foundInB is true, them
            if (foundInB === Value.true) {
              // i. Let R be the result of evaluating C.
              const R = EnsureCompletion(yield* Evaluate(C));
              // ii. If R.[[Value]] is not empty, set V to R.[[Value]].
              if (R.Value !== undefined) {
                V = R.Value;
              }
              // iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
              if (R instanceof AbruptCompletion) {
                return Completion(UpdateEmpty(R, V));
              }
            }
          }
        }
        // 10. If foundInB is true, return NormalCompletion(V).
        if (foundInB === Value.true) {
          return NormalCompletion(V);
        }
        // 11. Let R be the result of evaluating DefaultClause.
        const R = EnsureCompletion(yield* Evaluate(DefaultClause));
        // 12. If R.[[Value]] is not empty, set V to R.[[Value]].
        if (R.Value !== undefined) {
          V = R.Value;
        }
        // 13. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        if (R instanceof AbruptCompletion) {
          return Completion(UpdateEmpty(R, V));
        }
        // 14. NOTE: The following is another complete iteration of the second CaseClauses.
        // 15. For each CaseClause C in B, do
        for (const C of B) {
          // a. Let R be the result of evaluating CaseClause C.
          const innerR = EnsureCompletion(yield* Evaluate(C));
          // b. If R.[[Value]] is not empty, set V to R.[[Value]].
          if (innerR.Value !== undefined) {
            V = innerR.Value;
          }
          // c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
          if (innerR instanceof AbruptCompletion) {
            return Completion(UpdateEmpty(innerR, V));
          }
        }
        // 16. Return NormalCompletion(V).
        //
        return NormalCompletion(V);
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('CaseBlockEvaluation', '');
  }
}
CaseBlockEvaluation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation';
/** https://tc39.es/ecma262/#sec-switch-statement-runtime-semantics-evaluation */
//   SwitchStatement :
//     `switch` `(` Expression `)` CaseBlock
function* Evaluate_SwitchStatement({
  Expression,
  CaseBlock
}) {
  /* ReturnIfAbrupt */
  let _temp6 = yield* Evaluate(Expression);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  // 1. Let exprRef be the result of evaluating Expression.
  const exprRef = _temp6;
  // 2. Let switchValue be ? GetValue(exprRef).
  /* ReturnIfAbrupt */
  let _temp7 = yield* GetValue(exprRef);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const switchValue = _temp7;
  // 3. Let oldEnv be the running execution context's LexicalEnvironment.
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
  const blockEnv = new DeclarativeEnvironmentRecord(oldEnv);
  // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).
  yield* BlockDeclarationInstantiation(CaseBlock, blockEnv);
  // 6. Set the running execution context's LexicalEnvironment to blockEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = blockEnv;
  // 7. Let R be CaseBlockEvaluation of CaseBlock with argument switchValue.
  const R = yield* CaseBlockEvaluation(CaseBlock, switchValue);
  // 8. Set the running execution context's LexicalEnvironment to oldEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  // 9. return R.
  return R;
}
Evaluate_SwitchStatement.section = 'https://tc39.es/ecma262/#sec-switch-statement-runtime-semantics-evaluation';
/** https://tc39.es/ecma262/#sec-switch-statement-runtime-semantics-evaluation */
//   CaseClause :
//     `case` Expression `:`
//     `case` Expression `:` StatementList
//   DefaultClause :
//     `case` `default` `:`
//     `case` `default` `:` StatementList
function* Evaluate_CaseClause({
  StatementList
}) {
  if (!StatementList) {
    // 1. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
  // 1. Return the result of evaluating StatementList.
  return yield* Evaluate_StatementList(StatementList);
}
Evaluate_CaseClause.section = 'https://tc39.es/ecma262/#sec-switch-statement-runtime-semantics-evaluation';

function i(V) {
  if (V instanceof Value) {
    return inspect(V);
  }
  if (V instanceof PrivateName) {
    return `#${V.Description.stringValue()}`;
  }
  return `${V}`;
}
const Raw = s => s;
const AlreadyDeclared = n => `${i(n)} is already declared`;
const ArrayBufferDetached = () => 'Attempt to access detached ArrayBuffer';
const ArrayBufferShared = () => 'Attempt to access shared ArrayBuffer';
const ArrayPastSafeLength = () => 'Cannot make length of array-like object surpass the bounds of an integer index';
const ArrayEmptyReduce = () => 'Cannot reduce an empty array with no initial value';
const AssignmentToConstant = n => `Assignment to constant variable ${i(n)}`;
const AwaitInFormalParameters = () => 'await is not allowed in function parameters';
const AwaitInClassStaticBlock = () => 'await is not allowed in class static blocks';
const AwaitNotInAsyncFunction = () => 'await is only valid in async functions';
const BigIntDivideByZero = () => 'Division by zero';
const BigIntNegativeExponent = () => 'Exponent must be positive';
const BigIntUnsignedRightShift = () => 'BigInt has no unsigned right shift, use >> instead';
const BufferContentTypeMismatch = () => 'Newly created TypedArray did not match exemplar\'s content type';
const BufferDetachKeyMismatch = (k, b) => `${i(k)} is not the [[ArrayBufferDetachKey]] of ${i(b)}`;
const CannotAllocateDataBlock = () => 'Cannot allocate memory';
const CannotCreateProxyWith = (x, y) => `Cannot create a proxy with a ${x} as ${y}`;
const CannotConstructAbstractFunction = c => `Cannot construct abstract ${i(c)}`;
const CannotConvertDecimalToBigInt = n => `Cannot convert ${i(n)} to a BigInt because it is not an integer`;
const CannotConvertSymbol = t => `Cannot convert a Symbol value to a ${t}`;
const CannotConvertToBigInt = v => `Cannot convert ${i(v)} to a BigInt`;
const CannotConvertToObject = t => `Cannot convert ${t} to object`;
const CannotDefineProperty = p => `Cannot define property ${i(p)}`;
const CannotDeleteProperty = p => `Cannot delete property ${i(p)}`;
const CannotDeleteSuper = () => 'Cannot delete a super property';
const CannotJSONSerializeBigInt = () => 'Cannot serialize a BigInt to JSON';
const CannotMixBigInts = () => 'Cannot mix BigInt and other types, use explicit conversions';
const CannotResolvePromiseWithItself = () => 'Cannot resolve a promise with itself';
const CannotSetProperty = (p, o) => `Cannot set property ${i(p)} on ${i(o)}`;
const ClassMissingBindingIdentifier = () => 'Class declaration missing binding identifier';
const ConstDeclarationMissingInitializer = () => 'Missing initialization of const declaration';
const ConstructorNonCallable = f => `${i(f)} cannot be invoked without new`;
const CouldNotResolveModule = s => `Could not resolve module ${i(s)}`;
const DataViewOOB = () => 'Offset is outside the bounds of the DataView';
const DeleteIdentifier = () => 'Delete of identifier in strict mode';
const DeletePrivateName = () => 'Private fields cannot be deleted';
const DateInvalidTime = () => 'Invalid time';
const DerivedConstructorReturnedNonObject = () => 'Derived constructors may only return object or undefined';
const DuplicateConstructor = () => 'A class may only have one constructor';
const DuplicateExports = () => 'Module cannot contain duplicate exports';
const DuplicateImportAttribute = a => `Duplicate import attribute ${i(a)}`;
const DuplicateProto = () => 'An object literal may only have one __proto__ property';
const FunctionDeclarationStatement = () => 'Functions can only be declared at top level or inside a block';
const GeneratorRunning = () => 'Cannot manipulate a running generator';
const IllegalBreakContinue = isBreak => `Illegal ${isBreak ? 'break' : 'continue'} statement`;
const IllegalOctalEscape = () => 'Illegal octal escape';
const InternalSlotMissing = (_o, s) => `Internal slot ${s} is missing`;
const InvalidArrayLength = l => `Invalid array length: ${i(l)}`;
const InvalidAssignmentTarget = () => 'Invalid assignment target';
const InvalidCodePoint = () => 'Not a valid code point';
const InvalidHint = v => `Invalid hint: ${i(v)}`;
const InvalidMethodName = name => `Method cannot be named '${i(name)}'`;
const InvalidPropertyDescriptor = () => 'Invalid property descriptor. Cannot both specify accessors and a value or writable attribute';
const InvalidRadix = () => 'Radix must be between 2 and 36, inclusive';
const InvalidReceiver = (f, v) => `${f} called on invalid receiver: ${i(v)}`;
const InvalidRegExpFlags = f => `Invalid RegExp flags: ${f}`;
const RegExpFlagsCannotUseTogether = (f1, f2) => `Cannot use RegExp flags ${f1} and ${f2} together`;
const InvalidSuperCall = () => '`super` not expected here';
const InvalidSuperProperty = () => '`super` not expected here';
const InvalidTemplateEscape = () => 'Invalid escapes are only allowed in tagged templates';
const InvalidThis = () => 'Invalid `this` access';
const InvalidUnicodeEscape = () => 'Invalid unicode escape';
const InvalidAlphabet = () => 'Invalid alphabet';
const InvalidLastChunkHandling = () => 'Invalid lastChunkHandling';
const InvalidBase64String = () => 'Invalid base64 string';
const InvalidHexString = () => 'Invalid hex string';
const IteratorCompleted = () => 'The iterator is already complete.';
const IteratorThrowMissing = () => 'The iterator does not provide a throw method';
const JSONCircular = () => 'Cannot JSON stringify a circular structure';
const JSONUnexpectedToken = () => 'Unexpected token in JSON';
const JSONUnexpectedChar = c => `Unexpected character ${c} in JSON`;
const JSONExpected = (e, a) => `Expected character ${e} but got ${a} in JSON`;
const LetInLexicalBinding = () => '\'let\' is not allowed to be used as a name in lexical declarations';
const ModuleExportNameInvalidUnicode = () => 'Export name is not valid unicode';
const ModuleUndefinedExport = n => `Export '${i(n)}' is not defined in module`;
const NegativeIndex = n => `${n} cannot be negative`;
const NewlineAfterThrow = () => 'Illegal newline after throw';
const NormalizeInvalidForm = () => 'Invalid normalization form';
const NotAConstructor = v => `${i(v)} is not a constructor`;
const NotAFunction = v => `${i(v)} is not a function`;
const NotATypeObject = (t, v) => `${i(v)} is not a ${t} object`;
const NotAnObject = v => `${i(v)} is not an object`;
const NotASymbol = v => `${i(v)} is not a symbol`;
const NotAWeakKey = v => `${i(v)} is not an object or a symbol`;
const NotAString = v => `${i(v)} is not a string`;
const NotDefined = n => `${i(n)} is not defined`;
const NotEnoughArguments = (numArgs, minArgs) => `${minArgs} argument${minArgs !== 1 ? 's' : ''} required, but only ${numArgs} present`;
const NotInitialized = n => `${i(n)} cannot be used before initialization`;
const NotIterable = n => `${i(n)} is not iterable`;
const NotPropertyName = p => `${i(p)} is not a valid property name`;
const NotUint8Array = () => 'Not a Uint8Array';
const NumberFormatRange = m => `Invalid format range for ${m}`;
const ObjectToPrimitive = () => 'Cannot convert object to primitive value';
const ObjectPrototypeType = () => 'Object prototype must be an Object or null';
const ObjectSetPrototype = () => 'Could not set prototype of object';
const OutOfRange = n => `${i(n)} is out of range`;
const PrivateNameNoGetter = p => `${i(p)} was defined without a getter`;
const PrivateNameNoSetter = p => `${i(p)} was defined without a setter`;
const PrivateNameIsMethod = p => `Private method ${i(p)} is not writable`;
const PromiseAnyRejected = () => 'No promises passed to Promise.any were fulfilled';
const PromiseCapabilityFunctionAlreadySet = f => `Promise ${f} function already set`;
const PromiseRejectFunction = v => `Promise reject function ${i(v)} is not callable`;
const PromiseResolveFunction = v => `Promise resolve function ${i(v)} is not callable`;
const ProxyRevoked = n => `Cannot perform '${n}' on a proxy that has been revoked`;
const ProxyDefinePropertyNonConfigurable = p => `'defineProperty' on proxy: trap returned truthy for defining non-configurable property ${i(p)} which is either non-existent or configurable in the proxy target`;
const ProxyDefinePropertyNonConfigurableWritable = p => `'defineProperty' on proxy: trap returned truthy for defining non-configurable property ${i(p)} which cannot be non-writable, unless there exists a corresponding non-configurable, non-writable own property of the target object`;
const ProxyDefinePropertyNonExtensible = p => `'defineProperty' on proxy: trap returned truthy for adding property ${i(p)} to the non-extensible proxy target`;
const ProxyDefinePropertyIncompatible = p => `'defineProperty' on proxy: trap returned truthy for adding property ${i(p)} that is incompatible with the existing property in the proxy target`;
const ProxyDeletePropertyNonConfigurable = p => `'deleteProperty' on proxy: trap returned truthy for property ${i(p)} which is non-configurable in the proxy target`;
const ProxyDeletePropertyNonExtensible = p => `'deleteProperty' on proxy: trap returned truthy for property ${i(p)} but the proxy target is non-extensible`;
const ProxyGetNonConfigurableData = p => `'get' on proxy: property ${i(p)} is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value`;
const ProxyGetNonConfigurableAccessor = p => `'get' on proxy: property ${i(p)} is a non-configurable accessor property on the proxy target and does not have a getter function, but the trap did not return 'undefined'`;
const ProxyGetPrototypeOfInvalid = () => '\'getPrototypeOf\' on proxy: trap returned neither object nor null';
const ProxyGetPrototypeOfNonExtensible = () => '\'getPrototypeOf\' on proxy: proxy target is non-extensible but the trap did not return its actual prototype';
const ProxyGetOwnPropertyDescriptorIncompatible = p => `'getOwnPropertyDescriptor' on proxy: trap returned descriptor for property ${i(p)} that is incompatible with the existing property in the proxy target`;
const ProxyGetOwnPropertyDescriptorInvalid = p => `'getOwnPropertyDescriptor' on proxy: trap returned neither object nor undefined for property ${i(p)}`;
const ProxyGetOwnPropertyDescriptorUndefined = p => `'getOwnPropertyDescriptor' on proxy: trap returned undefined for property ${i(p)} which is non-configurable in the proxy target`;
const ProxyGetOwnPropertyDescriptorNonExtensible = p => `'getOwnPropertyDescriptor' on proxy: trap returned undefined for property ${i(p)} which exists in the non-extensible target`;
const ProxyGetOwnPropertyDescriptorNonConfigurable = p => `'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property ${i(p)} which is either non-existent or configurable in the proxy target`;
const ProxyGetOwnPropertyDescriptorNonConfigurableWritable = p => `'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property ${i(p)} which is writable or configurable in the proxy target`;
const ProxyHasNonConfigurable = p => `'has' on proxy: trap returned falsy for property ${i(p)} which exists in the proxy target as non-configurable`;
const ProxyHasNonExtensible = p => `'has' on proxy: trap returned falsy for property ${i(p)} but the proxy target is not extensible`;
const ProxyIsExtensibleInconsistent = e => `'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is ${i(e)})`;
const ProxyOwnKeysMissing = p => `'ownKeys' on proxy: trap result did not include ${i(p)}`;
const ProxyOwnKeysNonExtensible = () => '\'ownKeys\' on proxy: trap result returned extra keys but proxy target is non-extensible';
const ProxyOwnKeysDuplicateEntries = () => '\'ownKeys\' on proxy: trap returned duplicate entries';
const ProxyPreventExtensionsExtensible = () => '\'preventExtensions\' on proxy: trap returned truthy but the proxy target is extensible';
const ProxySetPrototypeOfNonExtensible = () => '\'setPrototypeOf\' on proxy: trap returned truthy for setting a new prototype on the non-extensible proxy target';
const ProxySetFrozenData = p => `'set' on proxy: trap returned truthy for property ${i(p)} which exists in the proxy target as a non-configurable and non-writable data property with a different value`;
const ProxySetFrozenAccessor = p => `'set' on proxy: trap returned truthy for property ${i(p)} which exists in the proxy target as a non-configurable and non-writable accessor property without a setter`;
const RegExpArgumentNotAllowed = m => `First argument to ${m} must not be a regular expression`;
const RegExpExecNotObject = o => `${i(o)} is not object or null`;
const ResizableBufferInvalidMaxByteLength = () => 'Invalid maxByteLength for resizable ArrayBuffer';
const ResolutionNullOrAmbiguous = (r, n, m) => r === null ? `Could not resolve import ${i(n)} from ${m.HostDefined.specifier}` : `Star export ${i(n)} from ${m.HostDefined.specifier} is ambiguous`;
const SizeIsNaN = () => 'size property must not be undefined, as it will be NaN';
const SpeciesNotConstructor = () => 'object.constructor[Symbol.species] is not a constructor';
const StrictModeDelete = n => `Cannot not delete property ${i(n)}`;
const StrictPoisonPill = () => 'The caller, callee, and arguments properties may not be accessed on functions or the arguments objects for calls to them';
const StringRepeatCount = v => `Count ${i(v)} is invalid`;
const StringCodePointInvalid = n => `Invalid code point ${i(n)}`;
const StringPrototypeMethodGlobalRegExp = m => `The RegExp passed to String.prototype.${m} must have the global flag`;
const SubclassLengthTooSmall = v => `Subclass constructor returned a smaller-than-requested object ${i(v)}`;
const SubclassSameValue = v => `Subclass constructor returned the same object ${i(v)}`;
const TargetMatchesHeldValue = v => `heldValue ${i(v)} matches target`;
const TemplateInOptionalChain = () => 'Templates are not allowed in optional chains';
const ThisNotAFunction = v => `Expected 'this' value to be a function but got ${i(v)}`;
const TryMissingCatchOrFinally = () => 'Missing catch or finally after try';
const TypedArrayCreationOOB = () => 'Sum of start offset and byte length should be less than the size of underlying buffer';
const TypedArrayLengthAlignment = (n, m) => `Size of ${n} should be a multiple of ${m}`;
const TypedArrayOOB = () => 'Sum of start offset and byte length should be less than the size of the TypedArray';
const TypedArrayOutOfBounds = () => 'TypedArray index out of bounds';
const TypedArrayOffsetAlignment = (n, m) => `Start offset of ${n} should be a multiple of ${m}`;
const TypedArrayTooSmall = () => 'Derived TypedArray constructor created an array which was too small';
const UnableToSeal = o => `Unable to seal object ${i(o)}`;
const UnableToFreeze = o => `Unable to freeze object ${i(o)}`;
const UnableToPreventExtensions = o => `Unable to prevent extensions on object ${i(o)}`;
const UnknownPrivateName = (o, p) => `${i(p)} does not exist on object ${i(o)}`;
const UnsupportedImportAttribute = key => `Unsupported import attribute ${i(key)}`;
const UnsupportedModuleType = type => `Unsupported module type ${i(type)} (only "json" is supported)`;
const UnterminatedComment = () => 'Missing */ after comment';
const UnterminatedRegExp = () => 'Missing / after RegExp literal';
const UnterminatedString = () => 'Missing \' or " after string literal';
const UnterminatedTemplate = () => 'Missing ` after template literal';
const UnexpectedEOS = () => 'Unexpected end of source';
const UnexpectedEvalOrArguments = () => '`arguments` and `eval` are not valid in this context';
const UnexpectedToken = () => 'Unexpected token';
const UnexpectedReservedWordStrict = () => 'Unexpected reserved word in strict mode';
const UseStrictNonSimpleParameter = () => 'Function with \'use strict\' directive has non-simple parameter list';
const URIMalformed = () => 'URI malformed';
const WeakCollectionNotObject = v => `${i(v)} is not a valid weak collection entry object`;
const YieldInFormalParameters = () => 'yield is not allowed in function parameters';
const YieldNotInGenerator = () => 'yield is only valid in generators';

var messages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AlreadyDeclared: AlreadyDeclared,
  ArrayBufferDetached: ArrayBufferDetached,
  ArrayBufferShared: ArrayBufferShared,
  ArrayEmptyReduce: ArrayEmptyReduce,
  ArrayPastSafeLength: ArrayPastSafeLength,
  AssignmentToConstant: AssignmentToConstant,
  AwaitInClassStaticBlock: AwaitInClassStaticBlock,
  AwaitInFormalParameters: AwaitInFormalParameters,
  AwaitNotInAsyncFunction: AwaitNotInAsyncFunction,
  BigIntDivideByZero: BigIntDivideByZero,
  BigIntNegativeExponent: BigIntNegativeExponent,
  BigIntUnsignedRightShift: BigIntUnsignedRightShift,
  BufferContentTypeMismatch: BufferContentTypeMismatch,
  BufferDetachKeyMismatch: BufferDetachKeyMismatch,
  CannotAllocateDataBlock: CannotAllocateDataBlock,
  CannotConstructAbstractFunction: CannotConstructAbstractFunction,
  CannotConvertDecimalToBigInt: CannotConvertDecimalToBigInt,
  CannotConvertSymbol: CannotConvertSymbol,
  CannotConvertToBigInt: CannotConvertToBigInt,
  CannotConvertToObject: CannotConvertToObject,
  CannotCreateProxyWith: CannotCreateProxyWith,
  CannotDefineProperty: CannotDefineProperty,
  CannotDeleteProperty: CannotDeleteProperty,
  CannotDeleteSuper: CannotDeleteSuper,
  CannotJSONSerializeBigInt: CannotJSONSerializeBigInt,
  CannotMixBigInts: CannotMixBigInts,
  CannotResolvePromiseWithItself: CannotResolvePromiseWithItself,
  CannotSetProperty: CannotSetProperty,
  ClassMissingBindingIdentifier: ClassMissingBindingIdentifier,
  ConstDeclarationMissingInitializer: ConstDeclarationMissingInitializer,
  ConstructorNonCallable: ConstructorNonCallable,
  CouldNotResolveModule: CouldNotResolveModule,
  DataViewOOB: DataViewOOB,
  DateInvalidTime: DateInvalidTime,
  DeleteIdentifier: DeleteIdentifier,
  DeletePrivateName: DeletePrivateName,
  DerivedConstructorReturnedNonObject: DerivedConstructorReturnedNonObject,
  DuplicateConstructor: DuplicateConstructor,
  DuplicateExports: DuplicateExports,
  DuplicateImportAttribute: DuplicateImportAttribute,
  DuplicateProto: DuplicateProto,
  FunctionDeclarationStatement: FunctionDeclarationStatement,
  GeneratorRunning: GeneratorRunning,
  IllegalBreakContinue: IllegalBreakContinue,
  IllegalOctalEscape: IllegalOctalEscape,
  InternalSlotMissing: InternalSlotMissing,
  InvalidAlphabet: InvalidAlphabet,
  InvalidArrayLength: InvalidArrayLength,
  InvalidAssignmentTarget: InvalidAssignmentTarget,
  InvalidBase64String: InvalidBase64String,
  InvalidCodePoint: InvalidCodePoint,
  InvalidHexString: InvalidHexString,
  InvalidHint: InvalidHint,
  InvalidLastChunkHandling: InvalidLastChunkHandling,
  InvalidMethodName: InvalidMethodName,
  InvalidPropertyDescriptor: InvalidPropertyDescriptor,
  InvalidRadix: InvalidRadix,
  InvalidReceiver: InvalidReceiver,
  InvalidRegExpFlags: InvalidRegExpFlags,
  InvalidSuperCall: InvalidSuperCall,
  InvalidSuperProperty: InvalidSuperProperty,
  InvalidTemplateEscape: InvalidTemplateEscape,
  InvalidThis: InvalidThis,
  InvalidUnicodeEscape: InvalidUnicodeEscape,
  IteratorCompleted: IteratorCompleted,
  IteratorThrowMissing: IteratorThrowMissing,
  JSONCircular: JSONCircular,
  JSONExpected: JSONExpected,
  JSONUnexpectedChar: JSONUnexpectedChar,
  JSONUnexpectedToken: JSONUnexpectedToken,
  LetInLexicalBinding: LetInLexicalBinding,
  ModuleExportNameInvalidUnicode: ModuleExportNameInvalidUnicode,
  ModuleUndefinedExport: ModuleUndefinedExport,
  NegativeIndex: NegativeIndex,
  NewlineAfterThrow: NewlineAfterThrow,
  NormalizeInvalidForm: NormalizeInvalidForm,
  NotAConstructor: NotAConstructor,
  NotAFunction: NotAFunction,
  NotAString: NotAString,
  NotASymbol: NotASymbol,
  NotATypeObject: NotATypeObject,
  NotAWeakKey: NotAWeakKey,
  NotAnObject: NotAnObject,
  NotDefined: NotDefined,
  NotEnoughArguments: NotEnoughArguments,
  NotInitialized: NotInitialized,
  NotIterable: NotIterable,
  NotPropertyName: NotPropertyName,
  NotUint8Array: NotUint8Array,
  NumberFormatRange: NumberFormatRange,
  ObjectPrototypeType: ObjectPrototypeType,
  ObjectSetPrototype: ObjectSetPrototype,
  ObjectToPrimitive: ObjectToPrimitive,
  OutOfRange: OutOfRange,
  PrivateNameIsMethod: PrivateNameIsMethod,
  PrivateNameNoGetter: PrivateNameNoGetter,
  PrivateNameNoSetter: PrivateNameNoSetter,
  PromiseAnyRejected: PromiseAnyRejected,
  PromiseCapabilityFunctionAlreadySet: PromiseCapabilityFunctionAlreadySet,
  PromiseRejectFunction: PromiseRejectFunction,
  PromiseResolveFunction: PromiseResolveFunction,
  ProxyDefinePropertyIncompatible: ProxyDefinePropertyIncompatible,
  ProxyDefinePropertyNonConfigurable: ProxyDefinePropertyNonConfigurable,
  ProxyDefinePropertyNonConfigurableWritable: ProxyDefinePropertyNonConfigurableWritable,
  ProxyDefinePropertyNonExtensible: ProxyDefinePropertyNonExtensible,
  ProxyDeletePropertyNonConfigurable: ProxyDeletePropertyNonConfigurable,
  ProxyDeletePropertyNonExtensible: ProxyDeletePropertyNonExtensible,
  ProxyGetNonConfigurableAccessor: ProxyGetNonConfigurableAccessor,
  ProxyGetNonConfigurableData: ProxyGetNonConfigurableData,
  ProxyGetOwnPropertyDescriptorIncompatible: ProxyGetOwnPropertyDescriptorIncompatible,
  ProxyGetOwnPropertyDescriptorInvalid: ProxyGetOwnPropertyDescriptorInvalid,
  ProxyGetOwnPropertyDescriptorNonConfigurable: ProxyGetOwnPropertyDescriptorNonConfigurable,
  ProxyGetOwnPropertyDescriptorNonConfigurableWritable: ProxyGetOwnPropertyDescriptorNonConfigurableWritable,
  ProxyGetOwnPropertyDescriptorNonExtensible: ProxyGetOwnPropertyDescriptorNonExtensible,
  ProxyGetOwnPropertyDescriptorUndefined: ProxyGetOwnPropertyDescriptorUndefined,
  ProxyGetPrototypeOfInvalid: ProxyGetPrototypeOfInvalid,
  ProxyGetPrototypeOfNonExtensible: ProxyGetPrototypeOfNonExtensible,
  ProxyHasNonConfigurable: ProxyHasNonConfigurable,
  ProxyHasNonExtensible: ProxyHasNonExtensible,
  ProxyIsExtensibleInconsistent: ProxyIsExtensibleInconsistent,
  ProxyOwnKeysDuplicateEntries: ProxyOwnKeysDuplicateEntries,
  ProxyOwnKeysMissing: ProxyOwnKeysMissing,
  ProxyOwnKeysNonExtensible: ProxyOwnKeysNonExtensible,
  ProxyPreventExtensionsExtensible: ProxyPreventExtensionsExtensible,
  ProxyRevoked: ProxyRevoked,
  ProxySetFrozenAccessor: ProxySetFrozenAccessor,
  ProxySetFrozenData: ProxySetFrozenData,
  ProxySetPrototypeOfNonExtensible: ProxySetPrototypeOfNonExtensible,
  Raw: Raw,
  RegExpArgumentNotAllowed: RegExpArgumentNotAllowed,
  RegExpExecNotObject: RegExpExecNotObject,
  RegExpFlagsCannotUseTogether: RegExpFlagsCannotUseTogether,
  ResizableBufferInvalidMaxByteLength: ResizableBufferInvalidMaxByteLength,
  ResolutionNullOrAmbiguous: ResolutionNullOrAmbiguous,
  SizeIsNaN: SizeIsNaN,
  SpeciesNotConstructor: SpeciesNotConstructor,
  StrictModeDelete: StrictModeDelete,
  StrictPoisonPill: StrictPoisonPill,
  StringCodePointInvalid: StringCodePointInvalid,
  StringPrototypeMethodGlobalRegExp: StringPrototypeMethodGlobalRegExp,
  StringRepeatCount: StringRepeatCount,
  SubclassLengthTooSmall: SubclassLengthTooSmall,
  SubclassSameValue: SubclassSameValue,
  TargetMatchesHeldValue: TargetMatchesHeldValue,
  TemplateInOptionalChain: TemplateInOptionalChain,
  ThisNotAFunction: ThisNotAFunction,
  TryMissingCatchOrFinally: TryMissingCatchOrFinally,
  TypedArrayCreationOOB: TypedArrayCreationOOB,
  TypedArrayLengthAlignment: TypedArrayLengthAlignment,
  TypedArrayOOB: TypedArrayOOB,
  TypedArrayOffsetAlignment: TypedArrayOffsetAlignment,
  TypedArrayOutOfBounds: TypedArrayOutOfBounds,
  TypedArrayTooSmall: TypedArrayTooSmall,
  URIMalformed: URIMalformed,
  UnableToFreeze: UnableToFreeze,
  UnableToPreventExtensions: UnableToPreventExtensions,
  UnableToSeal: UnableToSeal,
  UnexpectedEOS: UnexpectedEOS,
  UnexpectedEvalOrArguments: UnexpectedEvalOrArguments,
  UnexpectedReservedWordStrict: UnexpectedReservedWordStrict,
  UnexpectedToken: UnexpectedToken,
  UnknownPrivateName: UnknownPrivateName,
  UnsupportedImportAttribute: UnsupportedImportAttribute,
  UnsupportedModuleType: UnsupportedModuleType,
  UnterminatedComment: UnterminatedComment,
  UnterminatedRegExp: UnterminatedRegExp,
  UnterminatedString: UnterminatedString,
  UnterminatedTemplate: UnterminatedTemplate,
  UseStrictNonSimpleParameter: UseStrictNonSimpleParameter,
  WeakCollectionNotObject: WeakCollectionNotObject,
  YieldInFormalParameters: YieldInFormalParameters,
  YieldNotInGenerator: YieldNotInGenerator
});

let Flag = /*#__PURE__*/function (Flag) {
  Flag[Flag["return"] = 1] = "return";
  Flag[Flag["await"] = 2] = "await";
  Flag[Flag["yield"] = 4] = "yield";
  Flag[Flag["parameters"] = 8] = "parameters";
  Flag[Flag["newTarget"] = 16] = "newTarget";
  Flag[Flag["importMeta"] = 32] = "importMeta";
  Flag[Flag["superCall"] = 64] = "superCall";
  Flag[Flag["superProperty"] = 128] = "superProperty";
  Flag[Flag["in"] = 256] = "in";
  Flag[Flag["default"] = 512] = "default";
  Flag[Flag["module"] = 1024] = "module";
  Flag[Flag["classStaticBlock"] = 2048] = "classStaticBlock";
  return Flag;
}({});
function getDeclarations(node) {
  if (isArray(node)) {
    return node.flatMap(n => getDeclarations(n));
  }
  switch (node.type) {
    case 'LexicalBinding':
    case 'VariableDeclaration':
    case 'BindingRestElement':
    case 'ForBinding':
      if (node.BindingIdentifier) {
        return getDeclarations(node.BindingIdentifier);
      }
      if (node.BindingPattern) {
        return getDeclarations(node.BindingPattern);
      }
      return [];
    case 'BindingRestProperty':
      if (node.BindingIdentifier) {
        return getDeclarations(node.BindingIdentifier);
      }
      return [];
    case 'SingleNameBinding':
      return getDeclarations(node.BindingIdentifier);
    case 'ImportClause':
      {
        const d = [];
        if (node.ImportedDefaultBinding) {
          d.push(...getDeclarations(node.ImportedDefaultBinding));
        }
        if (node.NameSpaceImport) {
          d.push(...getDeclarations(node.NameSpaceImport));
        }
        if (node.NamedImports) {
          d.push(...getDeclarations(node.NamedImports));
        }
        return d;
      }
    case 'ImportSpecifier':
      return getDeclarations(node.ImportedBinding);
    case 'ImportedDefaultBinding':
    case 'NameSpaceImport':
      return getDeclarations(node.ImportedBinding);
    case 'NamedImports':
      return getDeclarations(node.ImportsList);
    case 'ObjectBindingPattern':
      {
        const declarations = getDeclarations(node.BindingPropertyList);
        if (node.BindingRestProperty) {
          declarations.push(...getDeclarations(node.BindingRestProperty));
        }
        return declarations;
      }
    case 'ArrayBindingPattern':
      {
        const declarations = getDeclarations(node.BindingElementList);
        if (node.BindingRestElement) {
          declarations.push(...getDeclarations(node.BindingRestElement));
        }
        return declarations;
      }
    case 'BindingElement':
      return getDeclarations(node.BindingPattern);
    case 'BindingProperty':
      return getDeclarations(node.BindingElement);
    case 'BindingIdentifier':
    case 'IdentifierName':
    case 'LabelIdentifier':
      return [{
        name: node.name,
        node
      }];
    case 'PrivateIdentifier':
      return [{
        name: `#${node.name}`,
        node
      }];
    case 'StringLiteral':
      return [{
        name: node.value,
        node
      }];
    case 'Elision':
      return [];
    case 'ForDeclaration':
      return getDeclarations(node.ForBinding);
    case 'ExportSpecifier':
      return getDeclarations(node.exportName);
    case 'FunctionDeclaration':
    case 'GeneratorDeclaration':
    case 'AsyncFunctionDeclaration':
    case 'AsyncGeneratorDeclaration':
      Assert(!!node.BindingIdentifier, "!!node.BindingIdentifier");
      return getDeclarations(node.BindingIdentifier);
    case 'LexicalDeclaration':
      return getDeclarations(node.BindingList);
    case 'VariableStatement':
      return getDeclarations(node.VariableDeclarationList);
    case 'ClassDeclaration':
      Assert(!!node.BindingIdentifier, "!!node.BindingIdentifier");
      return getDeclarations(node.BindingIdentifier);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('getDeclarations', node);
  }
}
class Scope {
  parser;
  scopeStack = [];
  labels = [];
  arrowInfoStack = [];
  assignmentInfoStack = [];
  exports = new Set();
  undefinedExports = new Map();
  privateScope;
  undefinedPrivateAccesses = [];
  flags = 0;
  constructor(parser) {
    this.parser = parser;
  }
  hasReturn() {
    return (this.flags & Flag.return) !== 0;
  }
  hasAwait() {
    return (this.flags & Flag.await) !== 0;
  }
  hasYield() {
    return (this.flags & Flag.yield) !== 0;
  }
  hasNewTarget() {
    return (this.flags & Flag.newTarget) !== 0;
  }
  hasSuperCall() {
    return (this.flags & Flag.superCall) !== 0;
  }
  hasSuperProperty() {
    return (this.flags & Flag.superProperty) !== 0;
  }
  hasImportMeta() {
    return (this.flags & Flag.importMeta) !== 0;
  }
  hasIn() {
    return (this.flags & Flag.in) !== 0;
  }
  inParameters() {
    return (this.flags & Flag.parameters) !== 0;
  }
  inClassStaticBlock() {
    return (this.flags & Flag.classStaticBlock) !== 0;
  }
  isDefault() {
    return (this.flags & Flag.default) !== 0;
  }
  isModule() {
    return (this.flags & Flag.module) !== 0;
  }
  with(flags, f) {
    const oldFlags = this.flags;
    Object.entries(flags).forEach(([k, v]) => {
      if (k in Flag && typeof Flag[k] === 'number') {
        if (v === true) {
          this.flags |= Flag[k];
        } else if (v === false) {
          this.flags &= ~Flag[k];
        }
      }
    });
    if (flags.lexical || flags.variable) {
      this.scopeStack.push({
        flags,
        lexicals: new Set(),
        variables: new Set(),
        functions: new Set(),
        parameters: new Set()
      });
    }
    if (flags.private) {
      this.privateScope = {
        outer: this.privateScope,
        names: new Map()
      };
    }
    const oldLabels = this.labels;
    if (flags.label === 'boundary') {
      this.labels = [];
    } else if (flags.label) {
      this.labels.push({
        type: flags.label
      });
    }
    const oldStrict = this.parser.state.strict;
    if (flags.strict === true) {
      this.parser.state.strict = true;
    } else if (flags.strict === false) {
      this.parser.state.strict = false;
    }
    const r = f();
    if (flags.label === 'boundary') {
      this.labels = oldLabels;
    } else if (flags.label) {
      this.labels.pop();
    }
    if (flags.private) {
      this.privateScope = this.privateScope.outer;
      if (this.privateScope === undefined) {
        this.undefinedPrivateAccesses.forEach(({
          node,
          name,
          scope
        }) => {
          while (scope) {
            if (scope.names.has(name)) {
              return;
            }
            scope = scope.outer;
          }
          this.parser.raiseEarly('NotDefined', node, name);
        });
      }
    }
    if (flags.lexical || flags.variable) {
      this.scopeStack.pop();
    }
    this.parser.state.strict = oldStrict;
    this.flags = oldFlags;
    return r;
  }
  pushArrowInfo(isAsync = false) {
    this.arrowInfoStack.push({
      isAsync,
      hasTrailingComma: false,
      yieldExpressions: [],
      awaitExpressions: [],
      awaitIdentifiers: [],
      merge(other) {
        this.yieldExpressions.push(...other.yieldExpressions);
        this.awaitExpressions.push(...other.awaitExpressions);
        this.awaitIdentifiers.push(...other.awaitIdentifiers);
      }
    });
  }
  popArrowInfo() {
    const arrowInfo = this.arrowInfoStack.pop();
    Assert(!!arrowInfo, "!!arrowInfo");
    return arrowInfo;
  }
  get arrowInfo() {
    if (this.arrowInfoStack.length > 0) {
      return this.arrowInfoStack[this.arrowInfoStack.length - 1];
    }
    return undefined;
  }
  pushAssignmentInfo(type) {
    const parser = this.parser;
    this.assignmentInfoStack.push({
      type,
      earlyErrors: [],
      clear() {
        this.earlyErrors.forEach(e => {
          parser.earlyErrors.delete(e);
        });
      }
    });
  }
  popAssignmentInfo() {
    const assignmentInfo = this.assignmentInfoStack.pop();
    Assert(!!assignmentInfo, "!!assignmentInfo");
    return assignmentInfo;
  }
  registerObjectLiteralEarlyError(error) {
    for (let i = this.assignmentInfoStack.length - 1; i >= 0; i -= 1) {
      const info = this.assignmentInfoStack[i];
      info.earlyErrors.push(error);
      if (info.type !== 'assign') {
        break;
      }
    }
  }
  lexicalScope() {
    for (let i = this.scopeStack.length - 1; i >= 0; i -= 1) {
      const scope = this.scopeStack[i];
      if (scope.flags.lexical) {
        return scope;
      }
    }
    /* node:coverage ignore next */
    throw new RangeError();
  }
  variableScope() {
    for (let i = this.scopeStack.length - 1; i >= 0; i -= 1) {
      const scope = this.scopeStack[i];
      if (scope.flags.variable) {
        return scope;
      }
    }
    /* node:coverage ignore next */
    throw new RangeError();
  }
  declare(node, type, extraType) {
    const declarations = getDeclarations(node);
    declarations.forEach(d => {
      switch (type) {
        case 'lexical':
        case 'import':
          {
            if (type === 'lexical' && d.name === 'let') {
              this.parser.raiseEarly('LetInLexicalBinding', d.node);
            }
            const scope = this.lexicalScope();
            if (scope.lexicals.has(d.name) || scope.variables.has(d.name) || scope.functions.has(d.name) || scope.parameters.has(d.name)) {
              this.parser.raiseEarly('AlreadyDeclared', d.node, d.name);
            }
            scope.lexicals.add(d.name);
            if (scope === this.scopeStack[0] && this.undefinedExports.has(d.name)) {
              this.undefinedExports.delete(d.name);
            }
            break;
          }
        case 'function':
          {
            const scope = this.lexicalScope();
            if (scope.lexicals.has(d.name)) {
              this.parser.raiseEarly('AlreadyDeclared', d.node, d.name);
            }
            if (scope.flags.variableFunctions) {
              scope.functions.add(d.name);
            } else {
              if (scope.variables.has(d.name)) {
                this.parser.raiseEarly('AlreadyDeclared', d.node, d.name);
              }
              scope.lexicals.add(d.name);
            }
            if (scope === this.scopeStack[0] && this.undefinedExports.has(d.name)) {
              this.undefinedExports.delete(d.name);
            }
            break;
          }
        case 'parameter':
          this.variableScope().parameters.add(d.name);
          break;
        case 'variable':
          for (let i = this.scopeStack.length - 1; i >= 0; i -= 1) {
            const scope = this.scopeStack[i];
            scope.variables.add(d.name);
            if (scope.lexicals.has(d.name) || !scope.flags.variableFunctions && scope.functions.has(d.name)) {
              this.parser.raiseEarly('AlreadyDeclared', d.node, d.name);
            }
            if (i === 0 && this.undefinedExports.has(d.name)) {
              this.undefinedExports.delete(d.name);
            }
            if (scope.flags.variable) {
              break;
            }
          }
          break;
        case 'export':
          if (this.exports.has(d.name)) {
            this.parser.raiseEarly('AlreadyDeclared', d.node, d.name);
          } else {
            this.exports.add(d.name);
          }
          break;
        case 'private':
          {
            const types = this.privateScope.names.get(d.name);
            if (types) {
              let duplicate = true;
              switch (extraType) {
                case 'field':
                case 'method':
                  break;
                case 'set':
                case 'get':
                  duplicate = types.has(extraType) || types.has('field') || types.has('method');
                  types.add(extraType);
                  break;
              }
              if (duplicate) {
                this.parser.raiseEarly('AlreadyDeclared', d.node, d.name);
              }
            } else if (extraType) {
              this.privateScope.names.set(d.name, new Set([extraType]));
            }
            break;
          }
        /* node:coverage ignore next 2 */
        default:
          throw new RangeError(type);
      }
    });
  }
  checkUndefinedExports(NamedExports) {
    const scope = this.variableScope();
    NamedExports.ExportsList.forEach(n => {
      const name = n.localName.type === 'IdentifierName' ? n.localName.name : n.localName.value;
      if (!scope.lexicals.has(name) && !scope.variables.has(name)) {
        this.undefinedExports.set(name, n.localName);
      }
    });
  }
  checkUndefinedPrivate(PrivateIdentifier) {
    if (this.parser.state.allowAllPrivateNames) {
      return;
    }
    const [{
      node,
      name
    }] = getDeclarations(PrivateIdentifier);
    if (!this.privateScope) {
      this.parser.raiseEarly('NotDefined', node, name);
      return;
    }
    let scope = this.privateScope;
    while (scope) {
      if (scope.names.has(name)) {
        return;
      }
      scope = scope.outer;
    }
    this.undefinedPrivateAccesses.push({
      node,
      name,
      scope: this.privateScope
    });
  }
}

class BaseParser extends Lexer {
  /**
   * Repurpose a {@link ParseNode} of one type as a {@link ParseNode} of another type.
   * @param node The node to repurpose.
   * @param type The name of the new node type.
   * @param update an optional callback that can be used to mutate {@link node} to match the new node type.
   */
  repurpose(node, type, update) {
    // NOTE: must down-cast to `ParseNode` before up-casting to `Unfinished<T>` due to the incompatbile `type` discriminant.
    const unfinished = node;
    unfinished.type = type;
    update?.(unfinished, node, node);
    return unfinished;
  }
}

class IdentifierParser extends BaseParser {
  // IdentifierName
  parseIdentifierName() {
    const node = this.startNode();
    const p = this.peek();
    if (p.type === Token.IDENTIFIER || p.type === Token.ESCAPED_KEYWORD || isKeyword(p.type)) {
      node.name = this.next().valueAsString();
    } else {
      this.unexpected();
    }
    return this.finishNode(node, 'IdentifierName');
  }

  // BindingIdentifier :
  //   Identifier
  //   `yield`
  //   `await`
  parseBindingIdentifier() {
    const node = this.startNode();
    const token = this.next();
    switch (token.type) {
      case Token.IDENTIFIER:
        node.name = token.valueAsString();
        break;
      case Token.ESCAPED_KEYWORD:
        node.name = token.valueAsString();
        break;
      case Token.YIELD:
        node.name = 'yield';
        break;
      case Token.AWAIT:
        node.name = 'await';
        for (let i = 0; i < this.scope.arrowInfoStack.length; i += 1) {
          const arrowInfo = this.scope.arrowInfoStack[i];
          if (!arrowInfo) {
            break;
          }
          if (arrowInfo.isAsync) {
            arrowInfo.awaitIdentifiers.push(node);
            break;
          }
        }
        break;
      default:
        this.unexpected(token);
    }
    if (this.isStrictMode() && (node.name === 'eval' || node.name === 'arguments')) {
      this.raiseEarly('UnexpectedEvalOrArguments', token);
    }
    this.validateIdentifierReference(node.name, token);
    return this.finishNode(node, 'BindingIdentifier');
  }

  // IdentifierReference :
  //   Identifier
  //   [~Yield] `yield`
  //   [~Await] `await`
  parseIdentifierReference() {
    const node = this.startNode();
    const token = this.next();
    node.escaped = token.escaped;
    switch (token.type) {
      case Token.IDENTIFIER:
        node.name = token.valueAsString();
        break;
      case Token.ESCAPED_KEYWORD:
        node.name = token.valueAsString();
        break;
      case Token.YIELD:
        if (this.scope.hasYield()) {
          this.unexpected(token);
        }
        node.name = 'yield';
        break;
      case Token.AWAIT:
        if (this.scope.hasAwait()) {
          this.unexpected(token);
        }
        for (let i = 0; i < this.scope.arrowInfoStack.length; i += 1) {
          const arrowInfo = this.scope.arrowInfoStack[i];
          if (!arrowInfo) {
            break;
          }
          if (arrowInfo.isAsync) {
            arrowInfo.awaitIdentifiers.push(node);
            break;
          }
        }
        node.name = 'await';
        break;
      default:
        this.unexpected(token);
    }
    this.validateIdentifierReference(node.name, token);
    return this.finishNode(node, 'IdentifierReference');
  }
  validateIdentifierReference(name, token) {
    if (name === 'yield' && (this.scope.hasYield() || this.scope.isModule())) {
      this.raiseEarly('UnexpectedReservedWordStrict', token);
    }
    if (name === 'await' && (this.scope.hasAwait() || this.scope.isModule())) {
      this.raiseEarly('UnexpectedReservedWordStrict', token);
    }
    if (this.isStrictMode() && isReservedWordStrict(name)) {
      this.raiseEarly('UnexpectedReservedWordStrict', token);
    }
    if (this.scope.inClassStaticBlock() && name === 'arguments') {
      this.raiseEarly('UnexpectedEvalOrArguments', token);
    }
    if (name !== 'yield' && name !== 'await' && isKeywordRaw(name)) {
      this.raiseEarly('UnexpectedToken', token);
    }
  }

  // LabelIdentifier :
  //   Identifier
  //   [~Yield] `yield`
  //   [~Await] `await`
  parseLabelIdentifier() {
    const node = this.parseIdentifierReference();
    return this.repurpose(node, 'LabelIdentifier');
  }

  // PrivateIdentifier ::
  //   `#` IdentifierName
  parsePrivateIdentifier() {
    const node = this.startNode();
    node.name = this.expect(Token.PRIVATE_IDENTIFIER).valueAsString();
    return this.finishNode(node, 'PrivateIdentifier');
  }
}

let FunctionKind = /*#__PURE__*/function (FunctionKind) {
  FunctionKind[FunctionKind["NORMAL"] = 0] = "NORMAL";
  FunctionKind[FunctionKind["ASYNC"] = 1] = "ASYNC";
  return FunctionKind;
}({});
class FunctionParser extends IdentifierParser {
  // FunctionDeclaration :
  //   `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
  //   [+Default] `function` `(` FormalParameters `)` `{` FunctionBody `}`
  // FunctionExpression :
  //   `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
  // GeneratorDeclaration :
  //   `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
  //   [+Default] `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
  // GeneratorExpression :
  //   `function` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
  // AsyncGeneratorDeclaration :
  //   `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  //   [+Default] `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  // AsyncGeneratorExpression :
  //   `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  // AsyncFunctionDeclaration :
  //   `async` `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
  //   [+Default] `async` `function` `(` FormalParameters `)` `{` AsyncBody `}`
  // Async`FunctionExpression :
  //   `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncBody `}`
  parseFunction(isExpression, kind) {
    const isAsync = kind === FunctionKind.ASYNC;
    const node = this.startNode();
    if (isAsync) {
      this.expect('async');
    }
    this.expect(Token.FUNCTION);
    const isGenerator = this.eat(Token.MUL);
    if (!this.test(Token.LPAREN)) {
      node.BindingIdentifier = this.scope.with({
        await: isExpression ? false : undefined,
        yield: isExpression ? false : undefined
      }, () => this.parseBindingIdentifier());
      if (!isExpression) {
        this.scope.declare(node.BindingIdentifier, 'function');
      }
    } else if (isExpression === false && !this.scope.isDefault()) {
      this.unexpected();
    } else {
      node.BindingIdentifier = null;
    }
    this.scope.with({
      default: false,
      await: isAsync,
      yield: isGenerator,
      lexical: true,
      variable: true,
      variableFunctions: true,
      parameters: false,
      classStaticBlock: false
    }, () => {
      this.scope.arrowInfoStack.push(null);
      node.FormalParameters = this.parseFormalParameters();
      const body = this.parseFunctionBody(isAsync, isGenerator, false);
      this.setFunctionBodyGeneric(node, body.type, body);
      if (node.BindingIdentifier) {
        if (body.strict && (node.BindingIdentifier.name === 'eval' || node.BindingIdentifier.name === 'arguments')) {
          this.raiseEarly('UnexpectedToken', node.BindingIdentifier);
        }
        if (isExpression) {
          if (this.scope.hasYield() && node.BindingIdentifier.name === 'yield') {
            this.raiseEarly('UnexpectedToken', node.BindingIdentifier);
          }
          if (this.scope.hasAwait() && node.BindingIdentifier.name === 'await') {
            this.raiseEarly('UnexpectedToken', node.BindingIdentifier);
          }
        }
      }
      this.validateFormalParameters(node.FormalParameters, body);
      this.scope.arrowInfoStack.pop();
    });
    const name = `${isAsync ? 'Async' : ''}${isGenerator ? 'Generator' : 'Function'}${isExpression ? 'Expression' : 'Declaration'}`;
    return this.finishNode(node, name);
  }
  setFunctionBodyGeneric(node, type, body) {
    node[type] = body;
  }
  validateFormalParameters(parameters, body, wantsUnique = false) {
    const isStrict = body.strict;
    const hasStrictDirective = body.directives && body.directives.includes('use strict');
    if (wantsUnique === false && !IsSimpleParameterList(parameters)) {
      wantsUnique = true;
    }
    if (hasStrictDirective) {
      parameters.forEach(p => {
        if (p.type !== 'SingleNameBinding' || p.Initializer) {
          this.raiseEarly('UseStrictNonSimpleParameter', p);
        }
      });
    }
    const names = new Set();
    getDeclarations(parameters).forEach(d => {
      if (isStrict) {
        if (d.name === 'arguments' || d.name === 'eval') {
          this.raiseEarly('UnexpectedToken', d.node);
        }
      }
      if (isStrict || wantsUnique) {
        if (names.has(d.name)) {
          this.raiseEarly('AlreadyDeclared', d.node, d.name);
        } else {
          names.add(d.name);
        }
      }
    });
  }
  convertArrowParameter(node) {
    switch (node.type) {
      case 'IdentifierReference':
        {
          const BindingIdentifier = this.repurpose(node, 'BindingIdentifier');
          const SingleNameBinding = this.startNode(node);
          SingleNameBinding.BindingIdentifier = BindingIdentifier;
          SingleNameBinding.Initializer = null;
          this.scope.declare(node, 'parameter');
          return this.finishNode(SingleNameBinding, 'SingleNameBinding');
        }
      case 'BindingRestElement':
        this.scope.declare(node, 'parameter');
        return node;
      case 'Elision':
        return node;
      case 'ArrayLiteral':
        {
          const BindingPattern = this.repurpose(node, 'ArrayBindingPattern', (asNew, asOld, asPartial) => {
            const BindingElementList = [];
            asNew.BindingElementList = BindingElementList;
            for (const [i, p] of asOld.ElementList.entries()) {
              const c = this.convertArrowParameter(p);
              if (c.type === 'BindingRestElement') {
                if (i !== asOld.ElementList.length - 1) {
                  this.raiseEarly('UnexpectedToken', c);
                }
                asNew.BindingRestElement = c;
              } else {
                BindingElementList.push(c);
              }
            }
            delete asPartial.ElementList;
          });
          const BindingElement = this.startNode(node);
          BindingElement.BindingPattern = BindingPattern;
          BindingElement.Initializer = null;
          return this.finishNode(BindingElement, 'BindingElement');
        }
      case 'ObjectLiteral':
        {
          const BindingPattern = this.repurpose(node, 'ObjectBindingPattern', (asNew, asOld, asPartial) => {
            const BindingPropertyList = [];
            asNew.BindingPropertyList = BindingPropertyList;
            for (const p of asOld.PropertyDefinitionList) {
              const c = this.convertArrowParameter(p);
              if (c.type === 'BindingRestProperty') {
                asNew.BindingRestProperty = c;
              } else {
                BindingPropertyList.push(c);
              }
            }
            delete asPartial.PropertyDefinitionList;
          });
          const BindingElement = this.startNode(node);
          BindingElement.BindingPattern = BindingPattern;
          BindingElement.Initializer = null;
          return this.finishNode(BindingElement, 'BindingElement');
        }
      case 'AssignmentExpression':
        {
          const result = this.convertArrowParameter(node.LeftHandSideExpression);
          result.Initializer = node.AssignmentExpression;
          return result;
        }
      case 'CoverInitializedName':
        {
          const SingleNameBinding = this.repurpose(node, 'SingleNameBinding', (asNew, asOld, asPartial) => {
            asNew.BindingIdentifier = this.repurpose(asOld.IdentifierReference, 'BindingIdentifier');
            delete asPartial.IdentifierReference;
          });
          this.scope.declare(SingleNameBinding, 'parameter');
          return SingleNameBinding;
        }
      case 'PropertyDefinition':
        {
          let BindingProperty;
          if (node.PropertyName === null) {
            BindingProperty = this.repurpose(node, 'BindingRestProperty', (asNew, asOld, asPartial) => {
              asNew.BindingIdentifier = this.repurpose(asOld.AssignmentExpression, 'BindingIdentifier');
              delete asPartial.AssignmentExpression;
            });
          } else {
            BindingProperty = this.repurpose(node, 'BindingProperty', (asNew, asOld, asPartial) => {
              asNew.BindingElement = this.convertArrowParameter(asOld.AssignmentExpression);
              delete asPartial.AssignmentExpression;
            });
          }
          this.scope.declare(node, 'parameter');
          return BindingProperty;
        }
      case 'SpreadElement':
      case 'AssignmentRestElement':
        {
          const BindingRestElement = this.repurpose(node, 'BindingRestElement', (asNew, asOld, asPartial) => {
            const {
              AssignmentExpression
            } = asOld;
            if (AssignmentExpression.type === 'AssignmentExpression') {
              this.raiseEarly('UnexpectedToken', node);
            } else if (AssignmentExpression.type === 'IdentifierReference') {
              asNew.BindingIdentifier = this.repurpose(AssignmentExpression, 'BindingIdentifier');
            } else {
              asNew.BindingPattern = this.convertArrowParameter(AssignmentExpression).BindingPattern;
            }
            delete asPartial.AssignmentExpression;
          });
          this.scope.declare(BindingRestElement, 'parameter');
          return BindingRestElement;
        }
      default:
        this.raiseEarly('UnexpectedToken', node);
        return node;
    }
  }
  parseArrowFunction(node, {
    arrowInfo,
    Arguments
  }, kind) {
    const isAsync = kind === FunctionKind.ASYNC;
    this.expect(Token.ARROW);
    if (arrowInfo) {
      arrowInfo.awaitExpressions.forEach(e => {
        this.raiseEarly('AwaitInFormalParameters', e);
      });
      arrowInfo.yieldExpressions.forEach(e => {
        this.raiseEarly('YieldInFormalParameters', e);
      });
      if (isAsync) {
        arrowInfo.awaitIdentifiers.forEach(e => {
          this.raiseEarly('AwaitInFormalParameters', e);
        });
      }
    }
    this.scope.with({
      default: false,
      lexical: true,
      variable: true
    }, () => {
      node.ArrowParameters = this.scope.with({
        parameters: true
      }, () => Arguments.map(p => this.convertArrowParameter(p)));
      const body = this.parseConciseBody(isAsync);
      this.validateFormalParameters(node.ArrowParameters, body, true);
      let bodyType;
      if (body.type === 'FunctionBody') {
        bodyType = 'ConciseBody';
      } else if (body.type === 'AsyncBody') {
        bodyType = 'AsyncConciseBody';
      } else {
        bodyType = body.type;
      }
      this.setConciseBodyGeneric(node, bodyType, body);
    });
    return this.finishNode(node, `${isAsync ? 'Async' : ''}ArrowFunction`);
  }
  setConciseBodyGeneric(node, type, body) {
    node[type] = body;
  }
  parseConciseBody(isAsync) {
    if (this.test(Token.LBRACE)) {
      return this.parseFunctionBody(isAsync, false, true);
    }
    const asyncBody = this.startNode();
    const exprBody = this.startNode();
    this.scope.with({
      await: isAsync
    }, () => {
      exprBody.AssignmentExpression = this.parseAssignmentExpression();
    });
    asyncBody.ExpressionBody = this.finishNode(exprBody, 'ExpressionBody');
    return this.finishNode(asyncBody, `${isAsync ? 'Async' : ''}ConciseBody`);
  }

  // FormalParameter : BindingElement
  parseFormalParameter() {
    return this.parseBindingElement();
  }
  parseFormalParameters() {
    this.expect(Token.LPAREN);
    if (this.eat(Token.RPAREN)) {
      return [];
    }
    const params = [];
    this.scope.with({
      parameters: true
    }, () => {
      while (true) {
        if (this.test(Token.ELLIPSIS)) {
          const element = this.parseBindingRestElement();
          this.scope.declare(element, 'parameter');
          params.push(element);
          this.expect(Token.RPAREN);
          break;
        } else {
          const formal = this.parseFormalParameter();
          this.scope.declare(formal, 'parameter');
          params.push(formal);
        }
        if (this.eat(Token.RPAREN)) {
          break;
        }
        this.expect(Token.COMMA);
        if (this.eat(Token.RPAREN)) {
          break;
        }
      }
    });
    return params;
  }
  parseUniqueFormalParameters() {
    return this.parseFormalParameters();
  }
  parseFunctionBody(isAsync, isGenerator, isArrow) {
    const node = this.startNode();
    this.expect(Token.LBRACE);
    this.scope.with({
      newTarget: isArrow ? undefined : true,
      return: true,
      await: isAsync,
      yield: isGenerator,
      label: 'boundary'
    }, () => {
      node.directives = [];
      node.FunctionStatementList = this.parseStatementList(Token.RBRACE, node.directives);
      node.strict = node.strict || node.directives.includes('use strict');
    });
    let name;
    if (isAsync) {
      name = isGenerator ? 'AsyncGeneratorBody' : 'AsyncBody';
    } else {
      name = isGenerator ? 'GeneratorBody' : 'FunctionBody';
    }
    return this.finishNode(node, name);
  }
}

var description="Unicode Property Value Aliases, generated from https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt";var General_Category={C:"Other",Other:"Other",Cc:"Control",Control:"Control",cntrl:"Control",Cf:"Format",Format:"Format",Cn:"Unassigned",Unassigned:"Unassigned",Co:"Private_Use",Private_Use:"Private_Use",Cs:"Surrogate",Surrogate:"Surrogate",L:"Letter",Letter:"Letter",LC:"Cased_Letter",Cased_Letter:"Cased_Letter",Ll:"Lowercase_Letter",Lowercase_Letter:"Lowercase_Letter",Lm:"Modifier_Letter",Modifier_Letter:"Modifier_Letter",Lo:"Other_Letter",Other_Letter:"Other_Letter",Lt:"Titlecase_Letter",Titlecase_Letter:"Titlecase_Letter",Lu:"Uppercase_Letter",Uppercase_Letter:"Uppercase_Letter",M:"Mark",Mark:"Mark",Combining_Mark:"Mark",Mc:"Spacing_Mark",Spacing_Mark:"Spacing_Mark",Me:"Enclosing_Mark",Enclosing_Mark:"Enclosing_Mark",Mn:"Nonspacing_Mark",Nonspacing_Mark:"Nonspacing_Mark",N:"Number","Number":"Number",Nd:"Decimal_Number",Decimal_Number:"Decimal_Number",digit:"Decimal_Number",Nl:"Letter_Number",Letter_Number:"Letter_Number",No:"Other_Number",Other_Number:"Other_Number",P:"Punctuation",Punctuation:"Punctuation",punct:"Punctuation",Pc:"Connector_Punctuation",Connector_Punctuation:"Connector_Punctuation",Pd:"Dash_Punctuation",Dash_Punctuation:"Dash_Punctuation",Pe:"Close_Punctuation",Close_Punctuation:"Close_Punctuation",Pf:"Final_Punctuation",Final_Punctuation:"Final_Punctuation",Pi:"Initial_Punctuation",Initial_Punctuation:"Initial_Punctuation",Po:"Other_Punctuation",Other_Punctuation:"Other_Punctuation",Ps:"Open_Punctuation",Open_Punctuation:"Open_Punctuation",S:"Symbol","Symbol":"Symbol",Sc:"Currency_Symbol",Currency_Symbol:"Currency_Symbol",Sk:"Modifier_Symbol",Modifier_Symbol:"Modifier_Symbol",Sm:"Math_Symbol",Math_Symbol:"Math_Symbol",So:"Other_Symbol",Other_Symbol:"Other_Symbol",Z:"Separator",Separator:"Separator",Zl:"Line_Separator",Line_Separator:"Line_Separator",Zp:"Paragraph_Separator",Paragraph_Separator:"Paragraph_Separator",Zs:"Space_Separator",Space_Separator:"Space_Separator"};var Script={Adlm:"Adlam",Adlam:"Adlam",Aghb:"Caucasian_Albanian",Caucasian_Albanian:"Caucasian_Albanian",Ahom:"Ahom",Arab:"Arabic",Arabic:"Arabic",Armi:"Imperial_Aramaic",Imperial_Aramaic:"Imperial_Aramaic",Armn:"Armenian",Armenian:"Armenian",Avst:"Avestan",Avestan:"Avestan",Bali:"Balinese",Balinese:"Balinese",Bamu:"Bamum",Bamum:"Bamum",Bass:"Bassa_Vah",Bassa_Vah:"Bassa_Vah",Batk:"Batak",Batak:"Batak",Beng:"Bengali",Bengali:"Bengali",Bhks:"Bhaiksuki",Bhaiksuki:"Bhaiksuki",Bopo:"Bopomofo",Bopomofo:"Bopomofo",Brah:"Brahmi",Brahmi:"Brahmi",Brai:"Braille",Braille:"Braille",Bugi:"Buginese",Buginese:"Buginese",Buhd:"Buhid",Buhid:"Buhid",Cakm:"Chakma",Chakma:"Chakma",Cans:"Canadian_Aboriginal",Canadian_Aboriginal:"Canadian_Aboriginal",Cari:"Carian",Carian:"Carian",Cham:"Cham",Cher:"Cherokee",Cherokee:"Cherokee",Chrs:"Chorasmian",Chorasmian:"Chorasmian",Copt:"Coptic",Coptic:"Coptic",Qaac:"Coptic",Cpmn:"Cypro_Minoan",Cypro_Minoan:"Cypro_Minoan",Cprt:"Cypriot",Cypriot:"Cypriot",Cyrl:"Cyrillic",Cyrillic:"Cyrillic",Deva:"Devanagari",Devanagari:"Devanagari",Diak:"Dives_Akuru",Dives_Akuru:"Dives_Akuru",Dogr:"Dogra",Dogra:"Dogra",Dsrt:"Deseret",Deseret:"Deseret",Dupl:"Duployan",Duployan:"Duployan",Egyp:"Egyptian_Hieroglyphs",Egyptian_Hieroglyphs:"Egyptian_Hieroglyphs",Elba:"Elbasan",Elbasan:"Elbasan",Elym:"Elymaic",Elymaic:"Elymaic",Ethi:"Ethiopic",Ethiopic:"Ethiopic",Gara:"Garay",Garay:"Garay",Geor:"Georgian",Georgian:"Georgian",Glag:"Glagolitic",Glagolitic:"Glagolitic",Gong:"Gunjala_Gondi",Gunjala_Gondi:"Gunjala_Gondi",Gonm:"Masaram_Gondi",Masaram_Gondi:"Masaram_Gondi",Goth:"Gothic",Gothic:"Gothic",Gran:"Grantha",Grantha:"Grantha",Grek:"Greek",Greek:"Greek",Gujr:"Gujarati",Gujarati:"Gujarati",Gukh:"Gurung_Khema",Gurung_Khema:"Gurung_Khema",Guru:"Gurmukhi",Gurmukhi:"Gurmukhi",Hang:"Hangul",Hangul:"Hangul",Hani:"Han",Han:"Han",Hano:"Hanunoo",Hanunoo:"Hanunoo",Hatr:"Hatran",Hatran:"Hatran",Hebr:"Hebrew",Hebrew:"Hebrew",Hira:"Hiragana",Hiragana:"Hiragana",Hluw:"Anatolian_Hieroglyphs",Anatolian_Hieroglyphs:"Anatolian_Hieroglyphs",Hmng:"Pahawh_Hmong",Pahawh_Hmong:"Pahawh_Hmong",Hmnp:"Nyiakeng_Puachue_Hmong",Nyiakeng_Puachue_Hmong:"Nyiakeng_Puachue_Hmong",Hrkt:"Katakana_Or_Hiragana",Katakana_Or_Hiragana:"Katakana_Or_Hiragana",Hung:"Old_Hungarian",Old_Hungarian:"Old_Hungarian",Ital:"Old_Italic",Old_Italic:"Old_Italic",Java:"Javanese",Javanese:"Javanese",Kali:"Kayah_Li",Kayah_Li:"Kayah_Li",Kana:"Katakana",Katakana:"Katakana",Kawi:"Kawi",Khar:"Kharoshthi",Kharoshthi:"Kharoshthi",Khmr:"Khmer",Khmer:"Khmer",Khoj:"Khojki",Khojki:"Khojki",Kits:"Khitan_Small_Script",Khitan_Small_Script:"Khitan_Small_Script",Knda:"Kannada",Kannada:"Kannada",Krai:"Kirat_Rai",Kirat_Rai:"Kirat_Rai",Kthi:"Kaithi",Kaithi:"Kaithi",Lana:"Tai_Tham",Tai_Tham:"Tai_Tham",Laoo:"Lao",Lao:"Lao",Latn:"Latin",Latin:"Latin",Lepc:"Lepcha",Lepcha:"Lepcha",Limb:"Limbu",Limbu:"Limbu",Lina:"Linear_A",Linear_A:"Linear_A",Linb:"Linear_B",Linear_B:"Linear_B",Lisu:"Lisu",Lyci:"Lycian",Lycian:"Lycian",Lydi:"Lydian",Lydian:"Lydian",Mahj:"Mahajani",Mahajani:"Mahajani",Maka:"Makasar",Makasar:"Makasar",Mand:"Mandaic",Mandaic:"Mandaic",Mani:"Manichaean",Manichaean:"Manichaean",Marc:"Marchen",Marchen:"Marchen",Medf:"Medefaidrin",Medefaidrin:"Medefaidrin",Mend:"Mende_Kikakui",Mende_Kikakui:"Mende_Kikakui",Merc:"Meroitic_Cursive",Meroitic_Cursive:"Meroitic_Cursive",Mero:"Meroitic_Hieroglyphs",Meroitic_Hieroglyphs:"Meroitic_Hieroglyphs",Mlym:"Malayalam",Malayalam:"Malayalam",Modi:"Modi",Mong:"Mongolian",Mongolian:"Mongolian",Mroo:"Mro",Mro:"Mro",Mtei:"Meetei_Mayek",Meetei_Mayek:"Meetei_Mayek",Mult:"Multani",Multani:"Multani",Mymr:"Myanmar",Myanmar:"Myanmar",Nagm:"Nag_Mundari",Nag_Mundari:"Nag_Mundari",Nand:"Nandinagari",Nandinagari:"Nandinagari",Narb:"Old_North_Arabian",Old_North_Arabian:"Old_North_Arabian",Nbat:"Nabataean",Nabataean:"Nabataean",Newa:"Newa",Nkoo:"Nko",Nko:"Nko",Nshu:"Nushu",Nushu:"Nushu",Ogam:"Ogham",Ogham:"Ogham",Olck:"Ol_Chiki",Ol_Chiki:"Ol_Chiki",Onao:"Ol_Onal",Ol_Onal:"Ol_Onal",Orkh:"Old_Turkic",Old_Turkic:"Old_Turkic",Orya:"Oriya",Oriya:"Oriya",Osge:"Osage",Osage:"Osage",Osma:"Osmanya",Osmanya:"Osmanya",Ougr:"Old_Uyghur",Old_Uyghur:"Old_Uyghur",Palm:"Palmyrene",Palmyrene:"Palmyrene",Pauc:"Pau_Cin_Hau",Pau_Cin_Hau:"Pau_Cin_Hau",Perm:"Old_Permic",Old_Permic:"Old_Permic",Phag:"Phags_Pa",Phags_Pa:"Phags_Pa",Phli:"Inscriptional_Pahlavi",Inscriptional_Pahlavi:"Inscriptional_Pahlavi",Phlp:"Psalter_Pahlavi",Psalter_Pahlavi:"Psalter_Pahlavi",Phnx:"Phoenician",Phoenician:"Phoenician",Plrd:"Miao",Miao:"Miao",Prti:"Inscriptional_Parthian",Inscriptional_Parthian:"Inscriptional_Parthian",Rjng:"Rejang",Rejang:"Rejang",Rohg:"Hanifi_Rohingya",Hanifi_Rohingya:"Hanifi_Rohingya",Runr:"Runic",Runic:"Runic",Samr:"Samaritan",Samaritan:"Samaritan",Sarb:"Old_South_Arabian",Old_South_Arabian:"Old_South_Arabian",Saur:"Saurashtra",Saurashtra:"Saurashtra",Sgnw:"SignWriting",SignWriting:"SignWriting",Shaw:"Shavian",Shavian:"Shavian",Shrd:"Sharada",Sharada:"Sharada",Sidd:"Siddham",Siddham:"Siddham",Sind:"Khudawadi",Khudawadi:"Khudawadi",Sinh:"Sinhala",Sinhala:"Sinhala",Sogd:"Sogdian",Sogdian:"Sogdian",Sogo:"Old_Sogdian",Old_Sogdian:"Old_Sogdian",Sora:"Sora_Sompeng",Sora_Sompeng:"Sora_Sompeng",Soyo:"Soyombo",Soyombo:"Soyombo",Sund:"Sundanese",Sundanese:"Sundanese",Sunu:"Sunuwar",Sunuwar:"Sunuwar",Sylo:"Syloti_Nagri",Syloti_Nagri:"Syloti_Nagri",Syrc:"Syriac",Syriac:"Syriac",Tagb:"Tagbanwa",Tagbanwa:"Tagbanwa",Takr:"Takri",Takri:"Takri",Tale:"Tai_Le",Tai_Le:"Tai_Le",Talu:"New_Tai_Lue",New_Tai_Lue:"New_Tai_Lue",Taml:"Tamil",Tamil:"Tamil",Tang:"Tangut",Tangut:"Tangut",Tavt:"Tai_Viet",Tai_Viet:"Tai_Viet",Telu:"Telugu",Telugu:"Telugu",Tfng:"Tifinagh",Tifinagh:"Tifinagh",Tglg:"Tagalog",Tagalog:"Tagalog",Thaa:"Thaana",Thaana:"Thaana",Thai:"Thai",Tibt:"Tibetan",Tibetan:"Tibetan",Tirh:"Tirhuta",Tirhuta:"Tirhuta",Tnsa:"Tangsa",Tangsa:"Tangsa",Todr:"Todhri",Todhri:"Todhri",Toto:"Toto",Tutg:"Tulu_Tigalari",Tulu_Tigalari:"Tulu_Tigalari",Ugar:"Ugaritic",Ugaritic:"Ugaritic",Vaii:"Vai",Vai:"Vai",Vith:"Vithkuqi",Vithkuqi:"Vithkuqi",Wara:"Warang_Citi",Warang_Citi:"Warang_Citi",Wcho:"Wancho",Wancho:"Wancho",Xpeo:"Old_Persian",Old_Persian:"Old_Persian",Xsux:"Cuneiform",Cuneiform:"Cuneiform",Yezi:"Yezidi",Yezidi:"Yezidi",Yiii:"Yi",Yi:"Yi",Zanb:"Zanabazar_Square",Zanabazar_Square:"Zanabazar_Square",Zinh:"Inherited",Inherited:"Inherited",Qaai:"Inherited",Zyyy:"Common",Common:"Common",Zzzz:"Unknown",Unknown:"Unknown"};var Script_Extensions={};var PropertyValueAliases = {description:description,General_Category:General_Category,Script:Script,Script_Extensions:Script_Extensions};

const isSyntaxCharacter = c => '^$\\.*+?()[]{}|'.includes(c);
const isClosingSyntaxCharacter = c => ')]}|'.includes(c);
const isDecimalDigit = c => /[0123456789]/u.test(c);
const isControlLetter = c => /[a-zA-Z]/u.test(c);
const isIdentifierContinue = c => c && /\p{ID_Continue}/u.test(c);
/** https://tc39.es/ecma262/#table-controlescape-code-point-values */
const isControlEscape = c => c >= 9 && c <= 13;
const isAsciiLetter = c => c >= 65 && c <= 90 || c >= 97 && c <= 122;
var ParserContext = /*#__PURE__*/function (ParserContext) {
  ParserContext[ParserContext["None"] = 0] = "None";
  ParserContext[ParserContext["UnicodeMode"] = 1] = "UnicodeMode";
  ParserContext[ParserContext["NamedCaptureGroups"] = 2] = "NamedCaptureGroups";
  ParserContext[ParserContext["UnicodeSetMode"] = 4] = "UnicodeSetMode";
  return ParserContext;
}(ParserContext || {});
class RegExpParser {
  source;
  position = 0;
  get debug() {
    return `${this.source.slice(0, this.position)}👀${this.source.slice(this.position)}`;
  }
  capturingGroups = [];
  leftCapturingParenthesesBefore = 0;
  decimalEscapes = [];
  groupNameRefs = [];
  groupNameThatMatches = Object.create(null);
  getAllGroupsWithName(name) {
    this.groupNameThatMatches[name] ??= [];
    return this.groupNameThatMatches[name];
  }
  state = ParserContext.None;
  constructor(source) {
    this.source = source;
  }
  scope(flags, f) {
    const oldState = this.state;
    if (flags.UnicodeMode === true) {
      this.state |= ParserContext.UnicodeMode;
    } else if (flags.UnicodeMode === false) {
      this.state &= ~ParserContext.UnicodeMode;
    }
    if (flags.NamedCaptureGroups === true) {
      this.state |= ParserContext.NamedCaptureGroups;
    } else if (flags.NamedCaptureGroups === false) {
      this.state &= ~ParserContext.NamedCaptureGroups;
    }
    if (flags.UnicodeSetsMode === true) {
      this.state |= ParserContext.UnicodeSetMode;
    } else if (flags.UnicodeSetsMode === false) {
      this.state &= ~ParserContext.UnicodeSetMode;
    }
    const r = f();
    this.state = oldState;
    return r;
  }
  get inUnicodeMode() {
    return (this.state & ParserContext.UnicodeMode) === ParserContext.UnicodeMode;
  }
  get inNamedCaptureGroups() {
    return (this.state & ParserContext.NamedCaptureGroups) === ParserContext.NamedCaptureGroups;
  }
  get inUnicodeSetMode() {
    return (this.state & ParserContext.UnicodeSetMode) === ParserContext.UnicodeSetMode;
  }
  raise(message, position = this.position) {
    const e = new SyntaxError(message);
    e.position = position;
    throw e;
  }
  peek(length = 1) {
    return this.source.slice(this.position, this.position + length);
  }
  test(c) {
    return this.source.slice(this.position, this.position + c.length) === c;
  }
  eat(c) {
    if (this.source.slice(this.position, this.position + c.length) === c) {
      this.position += c.length;
      return true;
    }
    return false;
  }
  next() {
    const c = this.source[this.position];
    if (!c) {
      this.raise('Unexpected end of input', this.position - 1);
    }
    this.position += 1;
    return c;
  }
  expect(c) {
    if (!this.eat(c)) {
      this.raise(`Expected ${c} but got ${this.peek()}`);
    }
  }

  // Pattern ::
  //   Disjunction
  parsePattern() {
    const node = {
      type: 'Pattern',
      capturingGroups: this.capturingGroups,
      Disjunction: this.parseDisjunction()
    };
    if (this.position < this.source.length) {
      this.raise('Unexpected token');
    }
    // AtomEscape :: DecimalEscape
    // EE: It is a Syntax Error if the CapturingGroupNumber of DecimalEscape is strictly greater than CountLeftCapturingParensWithin(the Pattern containing AtomEscape).
    this.decimalEscapes.forEach(d => {
      if (d.value > node.capturingGroups.length) {
        this.raise(`There is no ${d.value} capture groups`, d.position);
      }
    });
    // AtomEscape :: k GroupName
    // EE: It is a Syntax Error if GroupSpecifiersThatMatch(GroupName) is empty.
    this.groupNameRefs.forEach(g => {
      if (!node.capturingGroups.find(x => g.production === 'CaptureGroupName' && x.GroupName === g.GroupName)) {
        this.raise(`There is no capture group called ${JSON.stringify(g.GroupName)}`, g.position);
      }
    });
    // EE: It is a Syntax Error if CountLeftCapturingParensWithin(Pattern) ≥ 2**32 - 1.
    if (CountLeftCapturingParensWithin(node) >= 2 ** 32 - 1) {
      this.raise('Too many capturing groups');
    }
    return node;
  }

  // in case ((?<a>x)|(?<a>y))|b, after we check the inner Disjunction, we need to mark them as safe,
  // so when checking the outer Disjunction, we don't make a false positive
  disjunctionCheckedCaptureGroups = new Set();

  // Disjunction ::
  //   Alternative
  //   Alternative `|` Disjunction
  parseDisjunction() {
    const beforeCaptureGroups = this.capturingGroups.length;
    const Alternative = this.parseAlternative();
    const node = {
      type: 'Disjunction',
      Alternative,
      Disjunction: undefined
    };
    const afterAlternativeCaptureGroups = this.capturingGroups.length;
    if (this.eat('|')) {
      node.Disjunction = this.parseDisjunction();
    }
    // EE: It is a Syntax Error if Pattern contains two distinct GroupSpecifiers x and y such that the CapturingGroupName of x is the CapturingGroupName of y and such that MightBothParticipate(x, y) is true.
    const alternativeSeenNameGroups = new Set();
    this.capturingGroups.slice(beforeCaptureGroups, afterAlternativeCaptureGroups).forEach(x => {
      if (this.disjunctionCheckedCaptureGroups.has(x)) {
        return;
      }
      if (x.GroupName) {
        if (alternativeSeenNameGroups.has(x.GroupName)) {
          this.raise(`Duplicated capture group ${JSON.stringify(x.GroupName)}`, x.position);
        }
        alternativeSeenNameGroups.add(x.GroupName);
      }
      this.disjunctionCheckedCaptureGroups.add(x);
    });
    const disjunctionSeenNameGroups = new Set();
    this.capturingGroups.slice(afterAlternativeCaptureGroups).forEach(x => {
      if (this.disjunctionCheckedCaptureGroups.has(x)) {
        return;
      }
      if (x.GroupName) {
        if (disjunctionSeenNameGroups.has(x.GroupName)) {
          this.raise(`Duplicated capture group ${JSON.stringify(x.GroupName)}`, x.position);
        }
        disjunctionSeenNameGroups.add(x.GroupName);
      }
      this.disjunctionCheckedCaptureGroups.add(x);
    });
    return node;
  }

  // Alternative ::
  //   [empty]
  //   Term Alternative
  parseAlternative() {
    const Term = [];
    const node = {
      type: 'Alternative',
      Term
    };
    while (this.position < this.source.length && !isClosingSyntaxCharacter(this.peek())) {
      Term.push(this.parseTerm());
    }
    return node;
  }

  // Term ::
  //   Assertion
  //   Atom
  //   Atom Quantifier
  parseTerm() {
    const assertion = this.maybeParseAssertion();
    if (assertion) {
      return {
        type: 'Term',
        production: 'Assertion',
        Assertion: assertion
      };
    }
    const capturingParenthesesBefore = this.capturingGroups.length;
    return {
      type: 'Term',
      production: 'Atom',
      leftCapturingParenthesesBefore: this.leftCapturingParenthesesBefore,
      Atom: this.parseAtom(),
      Quantifier: this.maybeParseQuantifier(),
      capturingParenthesesWithin: this.capturingGroups.length - capturingParenthesesBefore
    };
  }

  // Assertion ::
  //   `^`
  //   `$`
  //   `\` `b`
  //   `\` `B`
  //   `(` `?` `=` Disjunction `)`
  //   `(` `?` `!` Disjunction `)`
  //   `(` `?` `<=` Disjunction `)`
  //   `(` `?` `<!` Disjunction `)`
  maybeParseAssertion() {
    if (this.eat('^')) {
      return {
        type: 'Assertion',
        production: '^'
      };
    }
    if (this.eat('$')) {
      return {
        type: 'Assertion',
        production: '$'
      };
    }
    const peek2 = this.peek(2);
    if (peek2 === '\\b') {
      this.position += 2;
      return {
        type: 'Assertion',
        production: 'b'
      };
    }
    if (peek2 === '\\B') {
      this.position += 2;
      return {
        type: 'Assertion',
        production: 'B'
      };
    }
    const peek3 = this.peek(3);
    if (peek3 === '(?=') {
      this.position += 3;
      const d = this.parseDisjunction();
      this.expect(')');
      return {
        type: 'Assertion',
        production: '?=',
        Disjunction: d
      };
    }
    if (peek3 === '(?!') {
      this.position += 3;
      const d = this.parseDisjunction();
      this.expect(')');
      return {
        type: 'Assertion',
        production: '?!',
        Disjunction: d
      };
    }
    const peek4 = this.peek(4);
    if (peek4 === '(?<=') {
      this.position += 4;
      const d = this.parseDisjunction();
      this.expect(')');
      return {
        type: 'Assertion',
        production: '?<=',
        Disjunction: d
      };
    }
    if (peek4 === '(?<!') {
      this.position += 4;
      const d = this.parseDisjunction();
      this.expect(')');
      return {
        type: 'Assertion',
        production: '?<!',
        Disjunction: d
      };
    }
    return undefined;
  }

  // Quantifier ::
  //   QuantifierPrefix
  //   QuantifierPrefix `?`
  // QuantifierPrefix ::
  //   `*`
  //   `+`
  //   `?`
  //   `{` DecimalDigits `}`
  //   `{` DecimalDigits `,` `}`
  //   `{` DecimalDigits `,` DecimalDigits `}`
  maybeParseQuantifier() {
    let QuantifierPrefix;
    if (this.eat('*')) {
      QuantifierPrefix = {
        type: 'QuantifierPrefix',
        production: '*'
      };
    } else if (this.eat('+')) {
      QuantifierPrefix = {
        type: 'QuantifierPrefix',
        production: '+'
      };
    } else if (this.eat('?')) {
      QuantifierPrefix = {
        type: 'QuantifierPrefix',
        production: '?'
      };
    } else if (this.eat('{')) {
      const quantifierPos = this.position;
      const DecimalDigits_a = Number.parseInt(this.parseDecimalDigits(), 10);
      let DecimalDigits_b;
      if (this.eat(',')) {
        if (this.test('}')) {
          DecimalDigits_b = Infinity;
        } else {
          DecimalDigits_b = Number.parseInt(this.parseDecimalDigits(), 10);
        }
        // EE: It is a Syntax Error if the MV of the first DecimalDigits is strictly greater than the MV of the second DecimalDigits.
        if (DecimalDigits_a > DecimalDigits_b) {
          this.raise('Numbers out of order in quantifier', quantifierPos);
        }
      }
      QuantifierPrefix = {
        type: 'QuantifierPrefix',
        production: '{}',
        DecimalDigits_a,
        DecimalDigits_b
      };
      this.expect('}');
    }
    if (QuantifierPrefix) {
      return {
        type: 'Quantifier',
        QuantifierPrefix,
        QuestionMark: this.eat('?')
      };
    }
    return undefined;
  }

  // Atom ::
  //   PatternCharacter
  //   `.`
  //   `\` AtomEscape
  //   CharacterClass
  //   `(` GroupSpecifier Disjunction `)`
  //   (? RegularExpressionModifiers : Disjunction )
  //   (? RegularExpressionModifiers - RegularExpressionModifiers : Disjunction )
  parseAtom() {
    if (this.eat('.')) {
      return {
        type: 'Atom',
        production: '.'
      };
    }
    if (this.eat('\\')) {
      return {
        type: 'Atom',
        production: 'AtomEscape',
        AtomEscape: this.parseAtomEscape()
      };
    }
    if (this.eat('(')) {
      let node;
      if (this.eat('?')) {
        if (this.peek() === '<') {
          this.leftCapturingParenthesesBefore += 1;
          const groupNamePos = this.position + 1;
          const name = this.parseGroupName();
          node = {
            type: 'Atom',
            production: 'Group',
            leftCapturingParenthesesBefore: this.leftCapturingParenthesesBefore - 1,
            GroupSpecifier: name,
            Disjunction: this.parseDisjunction()
          };
          this.getAllGroupsWithName(name).push(node);
          this.capturingGroups.push({
            GroupName: name,
            position: groupNamePos
          });
        } else {
          const {
            PlusModifiers,
            MinusModifiers
          } = this.parseAtomModifiers();
          node = {
            type: 'Atom',
            production: 'Modifier',
            leftCapturingParenthesesBefore: this.leftCapturingParenthesesBefore,
            AddModifiers: PlusModifiers,
            RemoveModifiers: MinusModifiers,
            Disjunction: this.parseDisjunction()
          };
        }
      } else {
        this.leftCapturingParenthesesBefore += 1;
        node = {
          type: 'Atom',
          production: 'Group',
          leftCapturingParenthesesBefore: this.leftCapturingParenthesesBefore - 1,
          GroupSpecifier: undefined,
          Disjunction: this.parseDisjunction()
        };
        this.capturingGroups.push({
          GroupName: undefined,
          position: this.position
        });
      }
      this.expect(')');
      return node;
    }
    if (this.test('[')) {
      return {
        type: 'Atom',
        production: 'CharacterClass',
        CharacterClass: this.parseCharacterClass()
      };
    }
    if (isSyntaxCharacter(this.peek())) {
      this.raise(`Expected a character but got ${this.peek()}`);
    }
    return {
      type: 'Atom',
      production: 'PatternCharacter',
      PatternCharacter: this.parseSourceCharacter()
    };
  }

  // WhatWeAreParsingHere :: (used in Atom, `<` is for named capture groups)
  //   [empty] [lookahead = `:` or `<`]
  //   RegularExpressionModifiers [lookahead = `:` or `<`]
  //   RegularExpressionModifiers `-` RegularExpressionModifiers [lookahead = `:` or `<`]
  //
  // RegularExpressionModifiers ::
  //   [empty]
  //   RegularExpressionModifiers RegularExpressionModifier
  //
  // RegularExpressionModifier :: one of `i` `m` `s`
  parseAtomModifiers() {
    const modifierPos = this.position;
    let modifiers;
    const result = {
      PlusModifiers: modifiers,
      MinusModifiers: modifiers
    };
    let seenMinus = false;
    while (this.position < this.source.length) {
      if (this.eat(':')) {
        break;
      } else if (this.test('<')) {
        break;
      } else if (this.eat('i')) {
        modifiers ??= [];
        modifiers.push('i');
      } else if (this.eat('m')) {
        modifiers ??= [];
        modifiers.push('m');
      } else if (this.eat('s')) {
        modifiers ??= [];
        modifiers.push('s');
      } else if (this.eat('-')) {
        modifiers ??= [];
        if (seenMinus) {
          this.raise('Unexpected - in modifiers', this.position - 1);
        }
        seenMinus = true;
        result.PlusModifiers = modifiers;
        modifiers = [];
        result.MinusModifiers = modifiers;
      } else {
        this.raise(`${JSON.stringify(this.peek())} is not a valid modifier`);
      }
    }
    if (!seenMinus) {
      result.PlusModifiers = modifiers;
    }
    const allModifiers = result.PlusModifiers?.concat(result.MinusModifiers || []);
    // EE: It is a Syntax Error if the source text matched by the first RegularExpressionModifiers and the source text matched by the second RegularExpressionModifiers are both empty.
    if (result.PlusModifiers && result.MinusModifiers && result.PlusModifiers.length + result.MinusModifiers.length === 0) {
      this.raise('PlusModifiers and MinusModifiers cannot be both empty.', this.position - 2);
    }
    // EE: It is a Syntax Error if the source text matched by RegularExpressionModifiers contains the same code point more than once.
    // EE: It is a Syntax Error if the source text matched by the first RegularExpressionModifiers contains the same code point more than once.
    // EE: It is a Syntax Error if the source text matched by the second RegularExpressionModifiers contains the same code point more than once.
    // EE: It is a Syntax Error if any code point in the source text matched by the first RegularExpressionModifiers is also contained in the source text matched by the second RegularExpressionModifiers.
    if (allModifiers?.length && allModifiers.length !== new Set(allModifiers).size) {
      this.raise('Repeated modifiers in modifier group', modifierPos);
    }
    return result;
  }

  // AtomEscape ::
  //   DecimalEscape
  //   CharacterClassEscape
  //   CharacterEscape
  //   [+N] `k` GroupName
  parseAtomEscape() {
    if (this.inNamedCaptureGroups && this.eat('k')) {
      const groupNamePos = this.position + 1;
      const GroupName = this.parseGroupName();
      const node = {
        type: 'AtomEscape',
        position: groupNamePos,
        production: 'CaptureGroupName',
        GroupName,
        groupSpecifiersThatMatchSelf: this.getAllGroupsWithName(GroupName)
      };
      this.groupNameRefs.push(node);
      return node;
    }
    const CharacterClassEscape = this.maybeParseCharacterClassEscape();
    if (CharacterClassEscape) {
      return {
        type: 'AtomEscape',
        production: 'CharacterClassEscape',
        CharacterClassEscape
      };
    }
    const DecimalEscape = this.maybeParseDecimalEscape();
    if (DecimalEscape) {
      return {
        type: 'AtomEscape',
        production: 'DecimalEscape',
        DecimalEscape
      };
    }
    return {
      type: 'AtomEscape',
      production: 'CharacterEscape',
      CharacterEscape: this.parseCharacterEscape()
    };
  }

  // CharacterEscape ::
  //   ControlEscape
  //   `c` AsciiLetter
  //   `0` [lookahead ∉ DecimalDigit]
  //   HexEscapeSequence
  //   RegExpUnicodeEscapeSequence
  //   IdentityEscape
  //
  // IdentityEscape ::
  //   [+U] SyntaxCharacter
  //   [+U] `/`
  //   [~U] SourceCharacter but not UnicodeIDContinue
  parseCharacterEscape() {
    switch (this.peek()) {
      case 'f':
      case 'n':
      case 'r':
      case 't':
      case 'v':
        return {
          type: 'CharacterEscape',
          production: 'ControlEscape',
          ControlEscape: this.next()
        };
      case 'c':
        {
          this.next();
          const c = this.next();
          if (c === undefined) {
            if (this.inUnicodeMode) {
              this.raise('Invalid identity escape');
            }
            return {
              type: 'CharacterEscape',
              production: 'IdentityEscape',
              IdentityEscape: 'c'
            };
          }
          const p = c.codePointAt(0);
          if (p >= 65 && p <= 90 || p >= 97 && p <= 122) {
            return {
              type: 'CharacterEscape',
              production: 'AsciiLetter',
              AsciiLetter: c
            };
          }
          if (this.inUnicodeMode) {
            this.raise('Invalid identity escape', this.position - 2);
          }
          return {
            type: 'CharacterEscape',
            production: 'IdentityEscape',
            IdentityEscape: c
          };
        }
      case 'x':
        if (isHexDigit(this.source[this.position + 1]) && isHexDigit(this.source[this.position + 2])) {
          return {
            type: 'CharacterEscape',
            production: 'HexEscapeSequence',
            HexEscapeSequence: this.parseHexEscapeSequence()
          };
        }
        if (this.inUnicodeMode) {
          this.raise('Invalid identity escape');
        }
        this.next();
        return {
          type: 'CharacterEscape',
          production: 'IdentityEscape',
          IdentityEscape: 'x'
        };
      case 'u':
        {
          const RegExpUnicodeEscapeSequence = this.maybeParseRegExpUnicodeEscapeSequence();
          if (RegExpUnicodeEscapeSequence) {
            return {
              type: 'CharacterEscape',
              production: 'RegExpUnicodeEscapeSequence',
              RegExpUnicodeEscapeSequence
            };
          }
          if (this.inUnicodeMode) {
            this.raise('Invalid identity escape');
          }
          this.next();
          return {
            type: 'CharacterEscape',
            production: 'IdentityEscape',
            IdentityEscape: 'u'
          };
        }
      default:
        {
          const c = this.peek();
          if (c === '') {
            this.raise('Unexpected escape');
          }
          if (c === '0' && !isDecimalDigit(this.source[this.position + 1])) {
            this.position += 1;
            return {
              type: 'CharacterEscape',
              production: c
            };
          }
          if (this.inUnicodeMode) {
            if (c !== '/' && !isSyntaxCharacter(c)) {
              this.raise('Invalid identity escape');
            }
          } else {
            if (isIdentifierContinue(c)) {
              this.raise('Invalid identity escape');
            }
          }
          return {
            type: 'CharacterEscape',
            production: 'IdentityEscape',
            IdentityEscape: this.next()
          };
        }
    }
  }

  // DecimalEscape ::
  //   NonZeroDigit DecimalDigits? [lookahead != DecimalDigit]
  maybeParseDecimalEscape() {
    if (isDecimalDigit(this.source[this.position]) && this.source[this.position] !== '0') {
      const start = this.position;
      let buffer = this.source[this.position];
      this.position += 1;
      while (isDecimalDigit(this.source[this.position])) {
        buffer += this.source[this.position];
        this.position += 1;
      }
      const node = {
        type: 'DecimalEscape',
        position: start,
        value: Number.parseInt(buffer, 10)
      };
      this.decimalEscapes.push(node);
      return node;
    }
    return undefined;
  }

  // CharacterClassEscape ::
  //   `d`
  //   `D`
  //   `s`
  //   `S`
  //   `w`
  //   `W`
  //   [+U] `p{` UnicodePropertyValueExpression `}`
  //   [+U] `P{` UnicodePropertyValueExpression `}`
  maybeParseCharacterClassEscape() {
    const peek = this.peek();
    switch (peek) {
      case 'd':
      case 'D':
      case 's':
      case 'S':
      case 'w':
      case 'W':
        this.next();
        return {
          type: 'CharacterClassEscape',
          production: peek
        };
      case 'p':
      case 'P':
        {
          if (!this.inUnicodeMode) {
            return undefined;
          }
          this.next();
          this.expect('{');
          let LoneUnicodePropertyNameOrValue = '';
          const namePos = this.position;
          while (true) {
            if (this.position >= this.source.length) {
              this.raise('Invalid unicode property name or value');
            }
            const c = this.source[this.position];
            if (c === '_' || isDecimalDigit(c)) {
              this.position += 1;
              LoneUnicodePropertyNameOrValue += c;
              continue;
            }
            if (!isControlLetter(c)) {
              break;
            }
            this.position += 1;
            LoneUnicodePropertyNameOrValue += c;
          }
          if (LoneUnicodePropertyNameOrValue.length === 0) {
            this.raise('Invalid unicode property name or value');
          }
          let UnicodePropertyValue;
          let valuePos;
          if (this.source[this.position] === '=') {
            this.position += 1;
            valuePos = this.position;
            UnicodePropertyValue = '';
            while (true) {
              if (this.position >= this.source.length) {
                this.raise('Invalid unicode property value', valuePos);
              }
              const c = this.source[this.position];
              if (!isControlLetter(c) && !isDecimalDigit(c) && c !== '_') {
                break;
              }
              this.position += 1;
              UnicodePropertyValue += c;
            }
            if (UnicodePropertyValue.length === 0) {
              this.raise('Invalid unicode property value', valuePos);
            }
          }
          this.expect('}');
          if (UnicodePropertyValue) {
            const UnicodePropertyName = LoneUnicodePropertyNameOrValue;
            // EE: It is a Syntax Error if the source text matched by UnicodePropertyName is not a Unicode property name or property alias listed in the “Property name and aliases” column of Table 69.
            if (!(UnicodePropertyName in Table69_NonbinaryUnicodeProperties)) {
              this.raise('Invalid unicode property name', namePos);
            }
            if (UnicodePropertyName !== 'Script_Extensions' && UnicodePropertyName !== 'scx') {
              // EE: It is a Syntax Error if the source text matched by UnicodePropertyName is neither Script_Extensions nor scx and the source text matched by UnicodePropertyValue is not a property value or property value alias for the Unicode property or property alias given by the source text matched by UnicodePropertyName listed in PropertyValueAliases.txt.
              if (!(UnicodePropertyValue in PropertyValueAliases[Table69_NonbinaryUnicodeProperties[UnicodePropertyName]])) {
                this.raise('Invalid unicode property value', valuePos);
              }
            } else if (!(UnicodePropertyValue in PropertyValueAliases.Script)) {
              // EE: It is a Syntax Error if the source text matched by UnicodePropertyName is either Script_Extensions or scx and the source text matched by UnicodePropertyValue is not a property value or property value alias for the Unicode property Script (sc) listed in PropertyValueAliases.txt.
              this.raise('Invalid unicode property value', valuePos);
            }
            return {
              type: 'CharacterClassEscape',
              production: peek,
              UnicodePropertyValueExpression: {
                type: 'UnicodePropertyValueExpression',
                production: '=',
                UnicodePropertyName,
                UnicodePropertyValue
              }
            };
          }
          // UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue
          // EE: It is a Syntax Error if the source text matched by LoneUnicodePropertyNameOrValue is not a Unicode property value or property value alias for the General_Category (gc) property listed in PropertyValueAliases.txt, nor a binary property or binary property alias listed in the “Property name and aliases” column of Table 70, nor a binary property of strings listed in the “Property name” column of Table 71.
          if (!(LoneUnicodePropertyNameOrValue in PropertyValueAliases.General_Category) && !(LoneUnicodePropertyNameOrValue in Table70_BinaryUnicodeProperties) && !(LoneUnicodePropertyNameOrValue in Table71_BinaryPropertyOfStrings)) {
            this.raise('Invalid unicode property', namePos);
          }
          // EE: It is a Syntax Error if the enclosing Pattern does not have a [UnicodeSetsMode] parameter and the source text matched by LoneUnicodePropertyNameOrValue is a binary property of strings listed in the “Property name” column of Table 71.
          if (LoneUnicodePropertyNameOrValue in Table71_BinaryPropertyOfStrings && !this.inUnicodeSetMode) {
            this.raise(`${LoneUnicodePropertyNameOrValue} can only be used with v flag`, namePos);
          }
          // EE: It is a Syntax Error if MayContainStrings of the UnicodePropertyValueExpression is true.
          if (peek === 'P' && LoneUnicodePropertyNameOrValue in Table71_BinaryPropertyOfStrings) {
            this.raise(`${LoneUnicodePropertyNameOrValue} cannot be inverted`, namePos - 2);
          }
          return {
            type: 'CharacterClassEscape',
            production: peek,
            UnicodePropertyValueExpression: {
              type: 'UnicodePropertyValueExpression',
              production: 'Lone',
              LoneUnicodePropertyNameOrValue
            }
          };
        }
      default:
        return undefined;
    }
  }

  // CharacterClass ::
  //   `[` ClassContents `]`
  //   `[` `^` ClassContents `]`
  parseCharacterClass() {
    this.expect('[');
    const invertPos = this.position;
    const invert = this.eat('^');
    const node = {
      type: 'CharacterClass',
      invert,
      ClassContents: this.parseClassContents()
    };
    // CharacterClass :: [^ ClassContents ]
    // EE: It is a Syntax Error if MayContainStrings of the ClassContents is true.
    if (invert && MayContainStrings(node.ClassContents)) {
      this.raise('This class cannot be inverted', invertPos);
    }
    this.expect(']');
    return node;
  }

  // ClassContents
  //   [empty]
  //   [~UnicodeSetMode] NonemptyClassRanges
  //   [+UnicodeSetMode] ClassSetExpression
  parseClassContents() {
    // [empty]
    if (this.test(']')) {
      return {
        type: 'ClassContents',
        production: 'Empty'
      };
    }
    if (this.inUnicodeSetMode) {
      return {
        type: 'ClassContents',
        production: 'ClassSetExpression',
        ClassSetExpression: this.parseClassSetExpression()
      };
    } else {
      return {
        type: 'ClassContents',
        production: 'NonEmptyClassRanges',
        NonemptyClassRanges: this.parseNonemptyClassRanges()
      };
    }
  }

  // NonemptyClassRanges ::
  //   ClassAtom
  //   ClassAtom NonemptyClassRangesNoDash
  //   ClassAtom `-` ClassAtom [empty]
  //   ClassAtom `-` ClassAtom NonemptyClassRanges
  parseNonemptyClassRanges() {
    Assert(!this.inUnicodeSetMode, "!this.inUnicodeSetMode");
    const ranges = [];
    while (!this.test(']')) {
      if (this.position >= this.source.length) {
        this.raise('Unexpected end of CharacterClass');
      }
      const atomPos = this.position;
      const atom = this.parseClassAtom();
      if (this.eat('-')) {
        // EE: It is a Syntax Error if IsCharacterClass of the first ClassAtom is true or IsCharacterClass of the second ClassAtom is true.
        if (atom.production === 'ClassEscape' && atom.ClassEscape.production === 'CharacterClassEscape') {
          this.raise('Invalid class range', atomPos);
        }
        if (this.test(']')) {
          ranges.push(atom);
          ranges.push({
            type: 'ClassAtom',
            production: '-'
          });
        } else {
          const atom2Pos = this.position;
          const atom2 = this.parseClassAtom();
          // EE: It is a Syntax Error if IsCharacterClass of the first ClassAtom is false, IsCharacterClass of the second ClassAtom is false, and the CharacterValue of the first ClassAtom is strictly greater than the CharacterValue of the second ClassAtom.
          // EE: It is a Syntax Error if IsCharacterClass of ClassAtomNoDash is false, IsCharacterClass of ClassAtom is false, and the CharacterValue of ClassAtomNoDash is strictly greater than the CharacterValue of ClassAtom.
          if (!IsCharacterClass(atom) && !IsCharacterClass(atom2) && CharacterValue(atom) > CharacterValue(atom2)) {
            this.raise('Invalid class range', atomPos);
          }
          // EE: It is a Syntax Error if IsCharacterClass of ClassAtomNoDash is true or IsCharacterClass of ClassAtom is true.
          if (IsCharacterClass(atom)) {
            this.raise('Invalid class range', atomPos);
          }
          if (IsCharacterClass(atom2)) {
            this.raise('Invalid class range', atom2Pos);
          }
          ranges.push([atom, atom2]);
        }
      } else {
        ranges.push(atom);
      }
    }
    return ranges;
  }

  // ClassAtom ::
  //   `-`
  //   ClassAtomNoDash
  // ClassAtomNoDash ::
  //   SourceCharacter but not one of `\` or `]` or `-`
  //   `\` ClassEscape
  // ClassEscape :
  //   `b`
  //   [+U] `-`
  //   CharacterClassEscape
  //   CharacterEscape
  parseClassAtom() {
    if (this.eat('\\')) {
      if (this.eat('b')) {
        return {
          type: 'ClassAtom',
          production: 'ClassEscape',
          ClassEscape: {
            type: 'ClassEscape',
            production: 'b'
          }
        };
      }
      if (this.inUnicodeMode && this.eat('-')) {
        return {
          type: 'ClassAtom',
          production: '-'
        };
      }
      const CharacterClassEscape = this.maybeParseCharacterClassEscape();
      if (CharacterClassEscape) {
        return {
          type: 'ClassAtom',
          production: 'ClassEscape',
          ClassEscape: {
            type: 'ClassEscape',
            production: 'CharacterClassEscape',
            CharacterClassEscape
          }
        };
      }
      return {
        type: 'ClassAtom',
        production: 'ClassEscape',
        ClassEscape: {
          type: 'ClassEscape',
          production: 'CharacterEscape',
          CharacterEscape: this.parseCharacterEscape()
        }
      };
    }
    return {
      type: 'ClassAtom',
      production: 'SourceCharacter',
      SourceCharacter: this.parseSourceCharacter()
    };
  }
  parseSourceCharacter() {
    if (this.inUnicodeMode || this.inUnicodeSetMode) {
      const lead = this.source.charCodeAt(this.position);
      const trail = this.source.charCodeAt(this.position + 1);
      if (trail && isLeadingSurrogate(lead) && isTrailingSurrogate(trail)) {
        return this.next() + this.next();
      }
    }
    return this.next();
  }
  parseGroupName() {
    this.expect('<');
    const RegExpIdentifierName = this.parseRegExpIdentifierName();
    this.expect('>');
    return RegExpIdentifierName;
  }

  // RegExpIdentifierName ::
  //   RegExpIdentifierStart
  //   RegExpIdentifierName RegExpIdentifierPart
  parseRegExpIdentifierName() {
    let buffer = '';
    let check = isIdentifierStart;
    while (this.position < this.source.length) {
      const c = this.source[this.position];
      const code = c.charCodeAt(0);
      if (c === '\\') {
        this.position += 1;
        const RegExpUnicodeEscapeSequence = this.scope({
          UnicodeMode: true
        }, () => this.maybeParseRegExpUnicodeEscapeSequence());
        if (!RegExpUnicodeEscapeSequence) {
          this.raise('Invalid unicode escape');
        }
        const raw = String.fromCodePoint(CharacterValue(RegExpUnicodeEscapeSequence));
        // EE: It is a Syntax Error if the CharacterValue of RegExpUnicodeEscapeSequence is not the numeric value of some code point matched by the IdentifierStartChar lexical grammar production.
        // EE: It is a Syntax Error if the CharacterValue of RegExpUnicodeEscapeSequence is not the numeric value of some code point matched by the IdentifierPartChar lexical grammar production.
        // EE: It is a Syntax Error if the RegExpIdentifierCodePoint of RegExpIdentifierPart is not matched by the UnicodeIDContinue lexical grammar production.
        if (!check(raw)) {
          this.raise('Invalid identifier escape');
        }
        buffer += raw;
      } else if (isLeadingSurrogate(code)) {
        // EE: It is a Syntax Error if the RegExpIdentifierCodePoint of RegExpIdentifierStart is not matched by the UnicodeIDStart lexical grammar production.
        const lowSurrogate = this.source.charCodeAt(this.position + 1);
        if (!isTrailingSurrogate(lowSurrogate)) {
          this.raise('Invalid trailing surrogate');
        }
        const codePoint = UTF16SurrogatePairToCodePoint(code, lowSurrogate);
        const raw = String.fromCodePoint(codePoint);
        if (!check(raw)) {
          this.raise('Invalid surrogate pair');
        }
        this.position += 2;
        buffer += raw;
      } else if (check(c)) {
        buffer += c;
        this.position += 1;
      } else {
        break;
      }
      check = isIdentifierPart;
    }
    if (buffer.length === 0) {
      this.raise('Invalid empty identifier');
    }
    return buffer;
  }

  // DecimalDigits ::
  //   DecimalDigit
  //   DecimalDigits DecimalDigit
  parseDecimalDigits() {
    let n = '';
    if (!isDecimalDigit(this.peek())) {
      this.raise('Invalid decimal digits');
    }
    while (isDecimalDigit(this.peek())) {
      n += this.next();
    }
    return n;
  }

  // HexEscapeSequence ::
  //   `x` HexDigit HexDigit
  parseHexEscapeSequence() {
    this.expect('x');
    const HexDigit_a = this.next();
    if (!isHexDigit(HexDigit_a)) {
      this.raise('Not a hex digit');
    }
    const HexDigit_b = this.next();
    if (!isHexDigit(HexDigit_b)) {
      this.raise('Not a hex digit');
    }
    return {
      type: 'HexEscapeSequence',
      HexDigit_a,
      HexDigit_b
    };
  }
  scanHex(length) {
    if (length === 0) {
      this.raise('Invalid code point');
    }
    let n = 0;
    let oldN = 0;
    for (let i = 0; i < length; i += 1) {
      const c = this.source[this.position];
      if (isHexDigit(c)) {
        this.position += 1;
        oldN = n;
        n = n << 4 | Number.parseInt(c, 16);
        if (oldN > n) {
          // overflow
          this.raise('Invalid hex digit');
        }
      } else {
        this.raise('Invalid hex digit');
      }
    }
    return n;
  }

  // RegExpUnicodeEscapeSequence ::
  //   [+U] `u` HexLeadSurrogate `\u` HexTrailSurrogate
  //   [+U] `u` HexLeadSurrogate
  //   [+U] `u` HexTrailSurrogate
  //   [+U] `u` HexNonSurrogate
  //   [~U] `u` Hex4Digits
  //   [+U] `u{` CodePoint `}`
  maybeParseRegExpUnicodeEscapeSequence() {
    const start = this.position;
    if (!this.eat('u')) {
      this.position = start;
      return undefined;
    }
    if (this.inUnicodeMode && this.eat('{')) {
      const end = this.source.indexOf('}', this.position);
      if (end === -1) {
        this.raise('Invalid code point');
      }
      const code = this.scanHex(end - this.position);
      if (code > 0x10FFFF) {
        this.raise('Invalid code point');
      }
      this.position += 1;
      return {
        type: 'RegExpUnicodeEscapeSequence',
        CodePoint: code
      };
    }
    let lead;
    try {
      lead = this.scanHex(4);
    } catch {
      this.position = start;
      return undefined;
    }
    if (this.inUnicodeMode && isLeadingSurrogate(lead)) {
      const back = this.position;
      if (this.eat('\\u')) {
        let trail;
        try {
          trail = this.scanHex(4);
          if (isTrailingSurrogate(trail)) {
            return {
              type: 'RegExpUnicodeEscapeSequence',
              HexLeadSurrogate: lead,
              HexTrailSurrogate: trail
            };
          }
        } catch {}
        this.position = back;
      }
      return {
        type: 'RegExpUnicodeEscapeSequence',
        HexLeadSurrogate: lead
      };
    }
    return {
      type: 'RegExpUnicodeEscapeSequence',
      Hex4Digits: lead
    };
  }

  //  ClassSetExpression ::
  //    ClassUnion
  //    ClassIntersection
  //    ClassSubtraction
  parseClassSetExpression() {
    Assert(this.inUnicodeSetMode, "this.inUnicodeSetMode");
    const oldPos = this.position;
    const left = this.maybeParseClassSetCharacter();
    const peek2 = this.peek(2);
    // ClassUnion :: ClassSetRange
    if (left !== undefined && peek2 !== '--' && peek2[0] === '-') {
      this.position = oldPos;
      return this.parseClassUnion();
    }
    // ClassUnion :: ClassSetOperand ...
    // ClassIntersection :: ClassSetOperand ...
    // ClassSubtraction :: ClassSetOperand ...
    const leftReparsed = this.parseClassSetOperand(left);
    if (this.eat('&&')) {
      return this.parseClassIntersectionOrSubtraction('&&', leftReparsed);
    }
    if (this.eat('--')) {
      return this.parseClassIntersectionOrSubtraction('--', leftReparsed);
    }
    return this.parseClassUnion(leftReparsed);
  }
  parseClassUnion(operand) {
    const union = operand ? [operand] : [];
    while (true) {
      const charPos = this.position;
      const char = this.maybeParseClassSetCharacter();
      if (char !== undefined) {
        // ClassSetRange
        if (this.eat('-')) {
          const char2 = this.maybeParseClassSetCharacter();
          if (char2 === undefined) {
            this.raise('Unterminated range');
          }
          // EE: It is a Syntax Error if the CharacterValue of the first ClassSetCharacter is strictly greater than the CharacterValue of the second ClassSetCharacter.
          if (CharacterValue(char) > CharacterValue(char2)) {
            this.raise(`Invalid range: ${String.fromCodePoint(CharacterValue(char))} is bigger than ${String.fromCodePoint(CharacterValue(char2))}`, charPos);
          }
          union.push({
            type: 'ClassSetRange',
            left: char,
            right: char2
          });
          continue;
        }
        // ClassSetCharacter
        union.push({
          type: 'ClassSetOperand',
          production: 'ClassSetCharacter',
          ClassSetCharacter: char
        });
      } else if (this.peek() === '\\' || this.peek() === '[') {
        // NestedClass or ClassStringDisjunction
        union.push(this.parseClassSetOperand());
      } else {
        break;
      }
    }
    return {
      type: 'ClassUnion',
      union
    };
  }
  parseClassIntersectionOrSubtraction(type, operand) {
    const tokens = operand ? [operand] : [];
    while (true) {
      tokens.push(this.parseClassSetOperand());
      if (this.eat(type)) {
        continue;
      }
      break;
    }
    Assert(tokens.length >= 2, "tokens.length >= 2");
    return {
      type: type === '&&' ? 'ClassIntersection' : 'ClassSubtraction',
      operands: tokens
    };
  }
  parseClassSetOperand(left) {
    Assert(this.inUnicodeSetMode, "this.inUnicodeSetMode");
    if (left !== undefined) {
      return {
        type: 'ClassSetOperand',
        production: 'ClassSetCharacter',
        ClassSetCharacter: left
      };
    }
    // ClassSetOperand :: NestedClass :: [ [lookahead ≠ ^] ClassContents[+UnicodeMode, +UnicodeSetsMode] ]
    // ClassSetOperand :: NestedClass :: [^ ClassContents[+UnicodeMode, +UnicodeSetsMode] ]
    if (this.eat('[')) {
      const invertPos = this.position;
      const invert = this.eat('^');
      const ClassContents = this.scope({
        UnicodeMode: true,
        UnicodeSetsMode: true
      }, () => this.parseClassContents());
      // NestedClass :: [^ ClassContents ]
      // EE: It is a Syntax Error if MayContainStrings of the ClassContents is true.
      if (invert && MayContainStrings(ClassContents)) {
        this.raise('This class cannot be inverted', invertPos);
      }
      this.expect(']');
      return {
        type: 'ClassSetOperand',
        production: 'NestedClass',
        NestedClass: {
          type: 'NestedClass',
          production: 'ClassContents',
          invert,
          ClassContents
        }
      };
    }
    if (this.eat('\\')) {
      // ClassSetOperand :: ClassStringDisjunction :: \q{ ClassStringDisjunctionContents }
      if (this.eat('q')) {
        this.expect('{');
        const ClassStringDisjunction = this.parseClassStringDisjunctionContents();
        this.expect('}');
        return {
          type: 'ClassSetOperand',
          production: 'ClassStringDisjunction',
          ClassStringDisjunction
        };
      }
      // ClassSetOperand :: NestedClass :: \ CharacterClassEscape[+UnicodeMode]
      const escape = this.scope({
        UnicodeMode: true
      }, () => this.maybeParseCharacterClassEscape());
      if (!escape) {
        this.raise(`Expect a CharacterClassEscape but ${this.peek()}`);
      }
      return {
        type: 'ClassSetOperand',
        production: 'NestedClass',
        NestedClass: {
          type: 'NestedClass',
          production: 'CharacterClassEscape',
          CharacterClassEscape: escape
        }
      };
    }
    const ClassSetCharacter = this.maybeParseClassSetCharacter();
    if (!ClassSetCharacter) {
      this.raise(`Unexpected ${this.peek()}`);
    }
    return {
      type: 'ClassSetOperand',
      production: 'ClassSetCharacter',
      ClassSetCharacter
    };
  }

  //  ClassSetCharacter ::
  //    [lookahead ∉ ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
  //    \ CharacterEscape[+UnicodeMode]
  //    \ ClassSetReservedPunctuator
  //    \b
  maybeParseClassSetCharacter() {
    Assert(this.inUnicodeSetMode, "this.inUnicodeSetMode");
    const nextTwo = this.peek(2);
    // ClassSetCharacter :: \b
    if (nextTwo === '\\b') {
      this.position += 2;
      return {
        type: 'ClassSetCharacter',
        production: 'UnicodeCharacter',
        UnicodeCharacter: '\\b'
      };
    }

    // ClassSetCharacter :: [lookahead ∉ ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
    if (
    // [lookahead ∉ ClassSetReservedDoublePunctuator]
    !'&& !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~'.split(' ').includes(nextTwo)
    // and not ClassSetSyntaxCharacter
    && !'( ) [ ] { } / - \\ |'.split(' ').includes(nextTwo[0])) {
      // parse SourceCharacter
      return {
        type: 'ClassSetCharacter',
        production: 'UnicodeCharacter',
        UnicodeCharacter: this.parseSourceCharacter()
      };
    }

    // all production left requires a \ at the beginning
    if (nextTwo[0] !== '\\') {
      return undefined;
    }

    // \ ClassSetReservedPunctuator
    if ('& - ! # % , : ; < = > @ ` ~'.split(' ').includes(nextTwo[1])) {
      this.position += 2;
      return {
        type: 'ClassSetCharacter',
        production: 'UnicodeCharacter',
        UnicodeCharacter: nextTwo[1]
      };
    }

    // anything that can start a Character Escape
    if ('fnrtvc0xu/^$\\.*+?()[]{}|'.includes(nextTwo[1])) {
      this.position += 1;
      return {
        type: 'ClassSetCharacter',
        production: 'CharacterEscape',
        CharacterEscape: this.scope({
          UnicodeMode: true
        }, () => this.parseCharacterEscape())
      };
    }
    return undefined;
  }

  // ClassStringDisjunctionContents is a list of ClassString that separated by |.
  parseClassStringDisjunctionContents() {
    const parsed = [];
    let current = [];
    while (true) {
      const parse = this.maybeParseClassSetCharacter();
      if (parse) {
        current.push(parse);
      } else if (this.eat('|')) {
        parsed.push(current);
        current = [];
      } else {
        parsed.push(current);
        break;
      }
    }
    return {
      type: 'ClassStringDisjunction',
      ClassString: parsed
    };
  }
}

/** https://tc39.es/ecma262/#sec-static-semantics-maycontainstrings */
function MayContainStrings(node) {
  switch (node.type) {
    case 'ClassContents':
      if (node.production === 'ClassSetExpression') {
        return MayContainStrings(node.ClassSetExpression);
      }
      return false;
    case 'UnicodePropertyValueExpression':
      if (node.production === 'Lone') {
        if (node.LoneUnicodePropertyNameOrValue in Table71_BinaryPropertyOfStrings) {
          return true;
        }
      }
      return false;
    case 'ClassUnion':
      return node.union.some(MayContainStrings);
    case 'ClassIntersection':
      return node.operands.some(MayContainStrings);
    case 'ClassSubtraction':
      return node.operands.some(MayContainStrings);
    case 'ClassSetRange':
      return false;
    case 'ClassSetOperand':
      if (node.production === 'ClassSetCharacter') {
        return false;
      } else if (node.production === 'NestedClass') {
        return MayContainStrings(node.NestedClass);
      } else if (node.production === 'ClassStringDisjunction') {
        return node.ClassStringDisjunction.ClassString.some(x => x.length !== 1);
      }
      unreachable();
    case 'NestedClass':
      if (node.production === 'CharacterClassEscape') {
        if (node.CharacterClassEscape.production !== 'p') {
          return false;
        }
        return MayContainStrings(node.CharacterClassEscape.UnicodePropertyValueExpression);
      } else if (node.production === 'ClassContents') {
        return MayContainStrings(node.ClassContents);
      }
      unreachable();
    default:
      unreachable();
  }
}
MayContainStrings.section = 'https://tc39.es/ecma262/#sec-static-semantics-maycontainstrings';

class ExpressionParser extends FunctionParser {
  // Expression :
  //   AssignmentExpression
  //   Expression `,` AssignmentExpression
  parseExpression() {
    const AssignmentExpression = this.parseAssignmentExpression();
    if (this.eat(Token.COMMA)) {
      const CommaOperator = this.startNode(AssignmentExpression);
      const ExpressionList = [AssignmentExpression];
      do {
        ExpressionList.push(this.parseAssignmentExpression());
      } while (this.eat(Token.COMMA));
      CommaOperator.ExpressionList = ExpressionList;
      return this.finishNode(CommaOperator, 'CommaOperator');
    }
    return AssignmentExpression;
  }

  // AssignmentExpression :
  //   ConditionalExpression
  //   [+Yield] YieldExpression
  //   ArrowFunction
  //   AsyncArrowFunction
  //   LeftHandSideExpression `=` AssignmentExpression
  //   LeftHandSideExpression AssignmentOperator AssignmentExpression
  //   LeftHandSideExpression LogicalAssignmentOperator AssignmentExpression
  //
  // AssignmentOperator : one of
  //   *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  //
  // LogicalAssignmentOperator : one of
  //   &&= ||= ??=
  parseAssignmentExpression() {
    if (this.test(Token.YIELD) && this.scope.hasYield()) {
      return this.parseYieldExpression();
    }
    this.scope.pushAssignmentInfo('assign');
    const left = this.parseConditionalExpression();
    const assignmentInfo = this.scope.popAssignmentInfo();
    if (left.type === 'IdentifierReference') {
      // `async` [no LineTerminator here] IdentifierReference [no LineTerminator here] `=>`
      if (left.name === 'async' && this.test(Token.IDENTIFIER) && !this.peek().hadLineTerminatorBefore && this.testAhead(Token.ARROW) && !this.peekAhead().hadLineTerminatorBefore) {
        assignmentInfo.clear();
        const node = this.startNode(left);
        return this.parseArrowFunction(node, {
          Arguments: [this.parseIdentifierReference()]
        }, FunctionKind.ASYNC);
      }
      // IdentifierReference [no LineTerminator here] `=>`
      if (this.test(Token.ARROW) && !this.peek().hadLineTerminatorBefore) {
        assignmentInfo.clear();
        const node = this.startNode(left);
        return this.parseArrowFunction(node, {
          Arguments: [left]
        }, FunctionKind.NORMAL);
      }
    }

    // `async` [no LineTerminator here] Arguments [no LineTerminator here] `=>`
    if (left.type === 'CallExpression' && left.arrowInfo && this.test(Token.ARROW) && !this.peek().hadLineTerminatorBefore) {
      const last = left.Arguments[left.Arguments.length - 1];
      if (!left.arrowInfo.hasTrailingComma || last && last.type !== 'AssignmentRestElement') {
        assignmentInfo.clear();
        const node = this.startNode(left);
        return this.parseArrowFunction(node, left, FunctionKind.ASYNC);
      }
    }
    if (left.type === 'CoverParenthesizedExpressionAndArrowParameterList') {
      assignmentInfo.clear();
      const node = this.startNode(left);
      return this.parseArrowFunction(node, left, FunctionKind.NORMAL);
    }
    switch (this.peek().type) {
      case Token.ASSIGN:
      case Token.ASSIGN_MUL:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_SHL:
      case Token.ASSIGN_SAR:
      case Token.ASSIGN_SHR:
      case Token.ASSIGN_BIT_AND:
      case Token.ASSIGN_BIT_XOR:
      case Token.ASSIGN_BIT_OR:
      case Token.ASSIGN_EXP:
      case Token.ASSIGN_AND:
      case Token.ASSIGN_OR:
      case Token.ASSIGN_NULLISH:
        {
          assignmentInfo.clear();
          const node = this.startNode(left);
          this.validateAssignmentTarget(left);
          node.LeftHandSideExpression = left;
          // NOTE: This cast isn't strictly sound as it depends on an expectation that `this.next.value` is correlated
          //       to `this.peek().type` which cannot be verified by the type system.
          node.AssignmentOperator = this.next().value;
          node.AssignmentExpression = this.parseAssignmentExpression();
          return this.finishNode(node, 'AssignmentExpression');
        }
      default:
        return left;
    }
  }
  validateAssignmentTarget(node) {
    switch (node.type) {
      case 'IdentifierReference':
        if (this.isStrictMode() && (node.name === 'eval' || node.name === 'arguments')) {
          break;
        }
        return;
      case 'CoverInitializedName':
        this.validateAssignmentTarget(node.IdentifierReference);
        return;
      case 'MemberExpression':
        return;
      case 'SuperProperty':
        return;
      case 'ParenthesizedExpression':
        if (node.Expression.type === 'ObjectLiteral' || node.Expression.type === 'ArrayLiteral') {
          break;
        }
        this.validateAssignmentTarget(node.Expression);
        return;
      case 'ArrayLiteral':
        node.ElementList.forEach((p, i) => {
          if (p.type === 'SpreadElement' && (i !== node.ElementList.length - 1 || node.hasTrailingComma)) {
            this.raiseEarly('InvalidAssignmentTarget', p);
          }
          if (p.type === 'AssignmentExpression') {
            this.validateAssignmentTarget(p.LeftHandSideExpression);
          } else {
            this.validateAssignmentTarget(p);
          }
        });
        return;
      case 'ObjectLiteral':
        node.PropertyDefinitionList.forEach((p, i) => {
          if (p.type === 'PropertyDefinition' && !p.PropertyName && i !== node.PropertyDefinitionList.length - 1) {
            this.raiseEarly('InvalidAssignmentTarget', p);
          }
          this.validateAssignmentTarget(p);
        });
        return;
      case 'PropertyDefinition':
        if (node.AssignmentExpression.type === 'AssignmentExpression') {
          this.validateAssignmentTarget(node.AssignmentExpression.LeftHandSideExpression);
        } else {
          this.validateAssignmentTarget(node.AssignmentExpression);
        }
        return;
      case 'Elision':
        return;
      case 'SpreadElement':
        if (node.AssignmentExpression.type === 'AssignmentExpression') {
          break;
        }
        this.validateAssignmentTarget(node.AssignmentExpression);
        return;
    }
    this.raiseEarly('InvalidAssignmentTarget', node);
  }

  // YieldExpression :
  //   `yield`
  //   `yield` [no LineTerminator here] AssignmentExpression
  //   `yield` [no LineTerminator here] `*` AssignmentExpression
  parseYieldExpression() {
    if (this.scope.inParameters()) {
      this.raiseEarly('YieldInFormalParameters');
    }
    const node = this.startNode();
    this.expect(Token.YIELD);
    if (this.peek().hadLineTerminatorBefore) {
      node.hasStar = false;
      node.AssignmentExpression = null;
    } else {
      node.hasStar = this.eat(Token.MUL);
      if (node.hasStar) {
        node.AssignmentExpression = this.parseAssignmentExpression();
      } else {
        switch (this.peek().type) {
          case Token.EOS:
          case Token.SEMICOLON:
          case Token.RBRACE:
          case Token.RBRACK:
          case Token.RPAREN:
          case Token.COLON:
          case Token.COMMA:
          case Token.IN:
            node.AssignmentExpression = null;
            break;
          default:
            node.AssignmentExpression = this.parseAssignmentExpression();
        }
      }
    }
    this.scope.arrowInfo?.yieldExpressions.push(node);
    return this.finishNode(node, 'YieldExpression');
  }

  // ConditionalExpression :
  //   ShortCircuitExpression
  //   ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression
  parseConditionalExpression() {
    const ShortCircuitExpression = this.parseShortCircuitExpression();
    if (this.eat(Token.CONDITIONAL)) {
      const node = this.startNode(ShortCircuitExpression);
      node.ShortCircuitExpression = ShortCircuitExpression;
      this.scope.with({
        in: true
      }, () => {
        node.AssignmentExpression_a = this.parseAssignmentExpression();
      });
      this.expect(Token.COLON);
      node.AssignmentExpression_b = this.parseAssignmentExpression();
      return this.finishNode(node, 'ConditionalExpression');
    }
    return ShortCircuitExpression;
  }

  // ShortCircuitExpression :
  //   LogicalORExpression
  //   CoalesceExpression
  //
  // CoalesceExpression :
  //   CoalesceExpressionHead `??` BitwiseORExpression
  //
  // CoalesceExpressionHead :
  //   CoalesceExpression
  //   BitwiseORExpression
  parseShortCircuitExpression() {
    // Start parse at BIT_OR, right above AND/OR/NULLISH
    const expression = this.parseBinaryExpression(TokenPrecedence[Token.BIT_OR]);
    switch (this.peek().type) {
      case Token.AND:
      case Token.OR:
        // Drop into normal binary chain starting at OR
        return this.parseBinaryExpression(TokenPrecedence[Token.OR], expression);
      case Token.NULLISH:
        {
          let x = expression;
          while (this.eat(Token.NULLISH)) {
            const node = this.startNode();
            node.CoalesceExpressionHead = x;
            node.BitwiseORExpression = this.parseBinaryExpression(TokenPrecedence[Token.BIT_OR]);
            x = this.finishNode(node, 'CoalesceExpression');
          }
          return x;
        }
      default:
        return expression;
    }
  }
  parseBinaryExpression(precedence, x) {
    if (!x) {
      if (this.test(Token.PRIVATE_IDENTIFIER)) {
        x = this.parsePrivateIdentifier();
        const p = TokenPrecedence[this.peek().type];
        if (!this.test(Token.IN) || p < precedence) {
          this.raise('UnexpectedToken');
        }
        this.scope.checkUndefinedPrivate(x);
        return this.parseBinaryExpression(p, x);
      } else {
        x = this.parseUnaryExpression();
      }
    }

    // NOTE: While the algorithm may be efficient, many casts below are inherently unsound as they depend on assumptions
    //       that cannot be proven in the type system without runtime assertions.
    let p = TokenPrecedence[this.peek().type];
    if (p >= precedence) {
      do {
        while (TokenPrecedence[this.peek().type] === p) {
          const left = x;
          if (p === TokenPrecedence[Token.EXP] && (left.type === 'UnaryExpression' || left.type === 'AwaitExpression')) {
            return left;
          }
          let node;
          if (this.peek().type === Token.IN && !this.scope.hasIn()) {
            return left;
          }
          const op = this.next();
          const right = this.parseBinaryExpression(op.type === Token.EXP ? p : p + 1);
          let name;
          switch (op.type) {
            case Token.EXP:
              name = 'ExponentiationExpression';
              node = this.startNode(left);
              node.UpdateExpression = left; // NOTE: unsound cast
              node.ExponentiationExpression = right; // NOTE: unsound cast
              break;
            case Token.MUL:
            case Token.DIV:
            case Token.MOD:
              name = 'MultiplicativeExpression';
              node = this.startNode(left);
              node.MultiplicativeExpression = left; // NOTE: unsound cast
              node.MultiplicativeOperator = op.value; // NOTE: unsound cast
              node.ExponentiationExpression = right; // NOTE: unsound cast
              break;
            case Token.ADD:
            case Token.SUB:
              name = 'AdditiveExpression';
              node = this.startNode(left);
              node.AdditiveExpression = left; // NOTE: unsound cast
              node.MultiplicativeExpression = right; // NOTE: unsound cast
              node.operator = op.value; // NOTE: unsound cast
              break;
            case Token.SHL:
            case Token.SAR:
            case Token.SHR:
              name = 'ShiftExpression';
              node = this.startNode(left);
              node.ShiftExpression = left; // NOTE: unsound cast
              node.AdditiveExpression = right; // NOTE: unsound cast
              node.operator = op.value; // NOTE: unsound cast
              break;
            case Token.LT:
            case Token.GT:
            case Token.LTE:
            case Token.GTE:
            case Token.INSTANCEOF:
            case Token.IN:
              name = 'RelationalExpression';
              node = this.startNode(left);
              if (left.type === 'PrivateIdentifier') {
                node.PrivateIdentifier = left;
              } else {
                node.RelationalExpression = left; // NOTE: unsound cast
              }
              node.ShiftExpression = right; // NOTE: unsound cast
              node.operator = op.value; // NOTE: unsound cast
              break;
            case Token.EQ:
            case Token.NE:
            case Token.EQ_STRICT:
            case Token.NE_STRICT:
              name = 'EqualityExpression';
              node = this.startNode(left);
              node.EqualityExpression = left; // NOTE: unsound cast
              node.RelationalExpression = right; // NOTE: unsound cast
              node.operator = op.value; // NOTE: unsound cast
              break;
            case Token.BIT_AND:
              name = 'BitwiseANDExpression';
              node = this.startNode(left);
              node.A = left; // NOTE: unsound cast
              node.operator = op.value; // NOTE: unsound cast
              node.B = right; // NOTE: unsound cast
              break;
            case Token.BIT_XOR:
              name = 'BitwiseXORExpression';
              node = this.startNode(left);
              node.A = left; // NOTE: unsound cast
              node.operator = op.value; // NOTE: unsound cast
              node.B = right; // NOTE: unsound cast
              break;
            case Token.BIT_OR:
              name = 'BitwiseORExpression';
              node = this.startNode(left);
              node.A = left; // NOTE: unsound cast
              node.operator = op.value; // NOTE: unsound cast
              node.B = right; // NOTE: unsound cast
              break;
            case Token.AND:
              name = 'LogicalANDExpression';
              node = this.startNode(left);
              node.LogicalANDExpression = left; // NOTE: unsound cast
              node.BitwiseORExpression = right; // NOTE: unsound cast
              break;
            case Token.OR:
              name = 'LogicalORExpression';
              node = this.startNode(left);
              node.LogicalORExpression = left; // NOTE: unsound cast
              node.LogicalANDExpression = right; // NOTE: unsound cast
              break;
            default:
              this.unexpected(op);
          }
          x = this.finishNode(node, name);
        }
        p -= 1;
      } while (p >= precedence);
    }
    return x;
  }

  // UnaryExpression :
  //   UpdateExpression
  //   `delete` UnaryExpression
  //   `void` UnaryExpression
  //   `typeof` UnaryExpression
  //   `+` UnaryExpression
  //   `-` UnaryExpression
  //   `~` UnaryExpression
  //   `!` UnaryExpression
  //   [+Await] AwaitExpression
  parseUnaryExpression() {
    return this.scope.with({
      in: true
    }, () => {
      if (this.test(Token.AWAIT) && this.scope.hasAwait()) {
        return this.parseAwaitExpression();
      }
      switch (this.peek().type) {
        case Token.DELETE:
        case Token.VOID:
        case Token.TYPEOF:
        case Token.ADD:
        case Token.SUB:
        case Token.BIT_NOT:
        case Token.NOT:
          {
            const node = this.startNode();
            node.operator = this.next().value; // NOTE: unsound cast
            node.UnaryExpression = this.parseUnaryExpression();
            if (node.operator === 'delete') {
              let target = node.UnaryExpression;
              while (target.type === 'ParenthesizedExpression') {
                target = target.Expression;
              }
              if (this.isStrictMode() && target.type === 'IdentifierReference') {
                this.raiseEarly('DeleteIdentifier', target);
              }
              if (target.type === 'MemberExpression' && target.PrivateIdentifier) {
                this.raiseEarly('DeletePrivateName', target);
              }
            }
            return this.finishNode(node, 'UnaryExpression');
          }
        default:
          return this.parseUpdateExpression();
      }
    });
  }

  // AwaitExpression : `await` UnaryExpression
  parseAwaitExpression() {
    if (this.scope.inParameters()) {
      this.raiseEarly('AwaitInFormalParameters');
    } else if (this.scope.inClassStaticBlock()) {
      this.raiseEarly('AwaitInClassStaticBlock');
    }
    const node = this.startNode();
    this.expect(Token.AWAIT);
    node.UnaryExpression = this.parseUnaryExpression();
    this.scope.arrowInfo?.awaitExpressions.push(node);
    if (!this.scope.hasReturn()) {
      this.state.hasTopLevelAwait = true;
    }
    return this.finishNode(node, 'AwaitExpression');
  }

  // UpdateExpression :
  //   LeftHandSideExpression
  //   LeftHandSideExpression [no LineTerminator here] `++`
  //   LeftHandSideExpression [no LineTerminator here] `--`
  //   `++` UnaryExpression
  //   `--` UnaryExpression
  parseUpdateExpression() {
    if (this.test(Token.INC) || this.test(Token.DEC)) {
      const node = this.startNode();
      node.operator = this.next().value; // NOTE: unsound cast
      node.LeftHandSideExpression = null;
      node.UnaryExpression = this.parseUnaryExpression();
      this.validateAssignmentTarget(node.UnaryExpression);
      return this.finishNode(node, 'UpdateExpression');
    }
    const argument = this.parseLeftHandSideExpression();
    if (!this.peek().hadLineTerminatorBefore) {
      if (this.test(Token.INC) || this.test(Token.DEC)) {
        this.validateAssignmentTarget(argument);
        const node = this.startNode(argument);
        node.operator = this.next().value; // NOTE: unsound cast
        node.LeftHandSideExpression = argument;
        node.UnaryExpression = null;
        return this.finishNode(node, 'UpdateExpression');
      }
    }
    return argument;
  }

  // LeftHandSideExpression
  parseLeftHandSideExpression(allowCalls = true) {
    let result;
    switch (this.peek().type) {
      case Token.NEW:
        result = this.parseNewExpression();
        break;
      case Token.SUPER:
        {
          const node = this.startNode();
          this.next();
          if (this.test(Token.LPAREN)) {
            if (!this.scope.hasSuperCall()) {
              this.raiseEarly('InvalidSuperCall');
            }
            node.Arguments = this.parseArguments().Arguments;
            result = this.finishNode(node, 'SuperCall');
          } else {
            if (!this.scope.hasSuperProperty()) {
              this.raiseEarly('InvalidSuperProperty');
            }
            if (this.eat(Token.LBRACK)) {
              node.Expression = this.parseExpression();
              this.expect(Token.RBRACK);
              node.IdentifierName = null;
            } else {
              this.expect(Token.PERIOD);
              node.Expression = null;
              node.IdentifierName = this.parseIdentifierName();
            }
            result = this.finishNode(node, 'SuperProperty');
          }
          break;
        }
      case Token.IMPORT:
        {
          const node = this.startNode();
          this.next();
          if (this.scope.hasImportMeta() && this.eat(Token.PERIOD)) {
            this.expect('meta');
            result = this.finishNode(node, 'ImportMeta');
          } else {
            if (!allowCalls) {
              this.unexpected();
            }
            this.expect(Token.LPAREN);
            node.AssignmentExpression = this.parseAssignmentExpression();
            if (this.eat(Token.COMMA) && !this.test(Token.RPAREN)) {
              node.OptionsExpression = this.parseAssignmentExpression();
              this.eat(Token.COMMA);
            }
            this.expect(Token.RPAREN);
            result = this.finishNode(node, 'ImportCall');
          }
          break;
        }
      default:
        result = this.parsePrimaryExpression();
        break;
    }
    const check = allowCalls ? isPropertyOrCall : isMember;
    while (check(this.peek().type)) {
      let finished;
      switch (this.peek().type) {
        case Token.LBRACK:
          {
            const node = this.startNode(result);
            this.next();
            node.MemberExpression = result;
            node.IdentifierName = null;
            node.Expression = this.parseExpression();
            this.expect(Token.RBRACK);
            finished = this.finishNode(node, 'MemberExpression');
            break;
          }
        case Token.PERIOD:
          {
            const node = this.startNode(result);
            this.next();
            node.MemberExpression = result;
            if (this.test(Token.PRIVATE_IDENTIFIER)) {
              node.PrivateIdentifier = this.parsePrivateIdentifier();
              this.scope.checkUndefinedPrivate(node.PrivateIdentifier);
              node.IdentifierName = null;
            } else {
              node.IdentifierName = this.parseIdentifierName();
              node.PrivateIdentifier = null;
            }
            node.Expression = null;
            finished = this.finishNode(node, 'MemberExpression');
            break;
          }
        case Token.LPAREN:
          {
            const node = this.startNode(result);
            // `async` [no LineTerminator here] `(`
            const couldBeArrow = this.matches('async', this.currentToken) && result.type === 'IdentifierReference' && !this.peek().hadLineTerminatorBefore;
            if (couldBeArrow) {
              this.scope.pushArrowInfo(true);
            }
            const {
              Arguments,
              trailingComma
            } = this.parseArguments();
            node.CallExpression = result;
            node.Arguments = Arguments;
            if (couldBeArrow) {
              node.arrowInfo = this.scope.popArrowInfo();
              node.arrowInfo.hasTrailingComma = trailingComma;
            }
            finished = this.finishNode(node, 'CallExpression');
            break;
          }
        case Token.OPTIONAL:
          {
            const node = this.startNode(result);
            node.MemberExpression = result;
            node.OptionalChain = this.parseOptionalChain();
            finished = this.finishNode(node, 'OptionalExpression');
            break;
          }
        case Token.TEMPLATE:
          {
            const node = this.startNode(result);
            node.MemberExpression = result;
            node.TemplateLiteral = this.parseTemplateLiteral(true);
            finished = this.finishNode(node, 'TaggedTemplateExpression');
            break;
          }
        default:
          this.unexpected();
      }
      // NOTE: unwinds ParseNode.Finish type alias to avoid circularity issues in type checker
      result = finished;
    }
    return result;
  }

  // OptionalChain
  parseOptionalChain() {
    this.expect(Token.OPTIONAL);
    const base = this.startNode();
    base.OptionalChain = null;
    if (this.test(Token.LPAREN)) {
      base.Arguments = this.parseArguments().Arguments;
    } else if (this.eat(Token.LBRACK)) {
      base.Expression = this.parseExpression();
      this.expect(Token.RBRACK);
    } else if (this.test(Token.TEMPLATE)) {
      this.raise('TemplateInOptionalChain');
    } else if (this.test(Token.PRIVATE_IDENTIFIER)) {
      base.PrivateIdentifier = this.parsePrivateIdentifier();
      this.scope.checkUndefinedPrivate(base.PrivateIdentifier);
    } else {
      base.IdentifierName = this.parseIdentifierName();
    }
    let chain = this.finishNode(base, 'OptionalChain');
    while (true) {
      const node = this.startNode();
      if (this.test(Token.LPAREN)) {
        node.OptionalChain = chain;
        node.Arguments = this.parseArguments().Arguments;
        chain = this.finishNode(node, 'OptionalChain');
      } else if (this.eat(Token.LBRACK)) {
        node.OptionalChain = chain;
        node.Expression = this.parseExpression();
        this.expect(Token.RBRACK);
        chain = this.finishNode(node, 'OptionalChain');
      } else if (this.test(Token.TEMPLATE)) {
        this.raise('TemplateInOptionalChain');
      } else if (this.eat(Token.PERIOD)) {
        node.OptionalChain = chain;
        if (this.test(Token.PRIVATE_IDENTIFIER)) {
          node.PrivateIdentifier = this.parsePrivateIdentifier();
          this.scope.checkUndefinedPrivate(node.PrivateIdentifier);
        } else {
          node.IdentifierName = this.parseIdentifierName();
        }
        chain = this.finishNode(node, 'OptionalChain');
      } else {
        return chain;
      }
    }
  }

  // NewExpression
  parseNewExpression() {
    const node = this.startNode();
    this.expect(Token.NEW);
    if (this.scope.hasNewTarget() && this.eat(Token.PERIOD)) {
      this.expect('target');
      return this.finishNode(node, 'NewTarget');
    }
    node.MemberExpression = this.parseLeftHandSideExpression(false);
    if (this.test(Token.LPAREN)) {
      node.Arguments = this.parseArguments().Arguments;
    } else {
      node.Arguments = null;
    }
    return this.finishNode(node, 'NewExpression');
  }

  // PrimaryExpression :
  //   ...
  parsePrimaryExpression() {
    switch (this.peek().type) {
      case Token.IDENTIFIER:
      case Token.ESCAPED_KEYWORD:
      case Token.YIELD:
      case Token.AWAIT:
        // `async` [no LineTerminator here] `function`
        if (this.test('async') && this.testAhead(Token.FUNCTION) && !this.peekAhead().hadLineTerminatorBefore) {
          return this.parseFunctionExpression(FunctionKind.ASYNC);
        }
        return this.parseIdentifierReference();
      case Token.THIS:
        {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, 'ThisExpression');
        }
      case Token.NUMBER:
      case Token.BIGINT:
        return this.parseNumericLiteral();
      case Token.STRING:
        return this.parseStringLiteral();
      case Token.NULL:
        {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, 'NullLiteral');
        }
      case Token.TRUE:
      case Token.FALSE:
        return this.parseBooleanLiteral();
      case Token.LBRACK:
        return this.parseArrayLiteral();
      case Token.LBRACE:
        return this.parseObjectLiteral();
      case Token.FUNCTION:
        return this.parseFunctionExpression(FunctionKind.NORMAL);
      case Token.CLASS:
        return this.parseClassExpression();
      case Token.TEMPLATE:
        return this.parseTemplateLiteral();
      case Token.DIV:
      case Token.ASSIGN_DIV:
        return this.parseRegularExpressionLiteral();
      case Token.LPAREN:
        return this.parseCoverParenthesizedExpressionAndArrowParameterList();
      default:
        return this.unexpected();
    }
  }

  // NumericLiteral
  parseNumericLiteral() {
    const node = this.startNode();
    if (!this.test(Token.NUMBER) && !this.test(Token.BIGINT)) {
      this.unexpected();
    }
    node.value = this.next().valueAsNumeric();
    return this.finishNode(node, 'NumericLiteral');
  }

  // StringLiteral
  parseStringLiteral() {
    const node = this.startNode();
    if (!this.test(Token.STRING)) {
      this.unexpected();
    }
    node.value = this.next().valueAsString();
    return this.finishNode(node, 'StringLiteral');
  }

  // BooleanLiteral :
  //   `true`
  //   `false`
  parseBooleanLiteral() {
    const node = this.startNode();
    switch (this.peek().type) {
      case Token.TRUE:
        this.next();
        node.value = true;
        break;
      case Token.FALSE:
        this.next();
        node.value = false;
        break;
      default:
        this.unexpected();
    }
    return this.finishNode(node, 'BooleanLiteral');
  }

  // ArrayLiteral :
  //   `[` `]`
  //   `[` Elision `]`
  //   `[` ElementList `]`
  //   `[` ElementList `,` `]`
  //   `[` ElementList `,` Elision `]`
  parseArrayLiteral() {
    const node = this.startNode();
    this.expect(Token.LBRACK);
    const ElementList = [];
    node.ElementList = ElementList;
    node.hasTrailingComma = false;
    while (true) {
      while (this.test(Token.COMMA)) {
        const elision = this.startNode();
        this.next();
        ElementList.push(this.finishNode(elision, 'Elision'));
      }
      if (this.eat(Token.RBRACK)) {
        break;
      }
      if (this.test(Token.ELLIPSIS)) {
        const spread = this.startNode();
        this.next();
        spread.AssignmentExpression = this.parseAssignmentExpression();
        ElementList.push(this.finishNode(spread, 'SpreadElement'));
      } else {
        ElementList.push(this.parseAssignmentExpression());
      }
      if (this.eat(Token.RBRACK)) {
        node.hasTrailingComma = false;
        break;
      }
      node.hasTrailingComma = true;
      this.expect(Token.COMMA);
    }
    return this.finishNode(node, 'ArrayLiteral');
  }

  // ObjectLiteral :
  //   `{` `}`
  //   `{` PropertyDefinitionList `}`
  //   `{` PropertyDefinitionList `,` `}`
  parseObjectLiteral() {
    const node = this.startNode();
    this.expect(Token.LBRACE);
    const PropertyDefinitionList = [];
    node.PropertyDefinitionList = PropertyDefinitionList;
    let hasProto = false;
    while (true) {
      if (this.eat(Token.RBRACE)) {
        break;
      }
      const PropertyDefinition = this.parsePropertyDefinition();
      if (!this.state.json && PropertyDefinition.type === 'PropertyDefinition' && PropertyDefinition.PropertyName && !IsComputedPropertyKey(PropertyDefinition.PropertyName) && PropertyDefinition.PropertyName.type !== 'NumericLiteral' && StringValue(PropertyDefinition.PropertyName).stringValue() === '__proto__') {
        if (hasProto) {
          this.scope.registerObjectLiteralEarlyError(this.raiseEarly('DuplicateProto', PropertyDefinition.PropertyName));
        } else {
          hasProto = true;
        }
      }
      PropertyDefinitionList.push(PropertyDefinition);
      if (this.eat(Token.RBRACE)) {
        break;
      }
      this.expect(Token.COMMA);
    }
    return this.finishNode(node, 'ObjectLiteral');
  }
  parsePropertyDefinition() {
    return this.parseBracketedDefinition('property');
  }
  parseFunctionExpression(kind) {
    return this.parseFunction(true, kind);
  }
  parseArguments() {
    this.expect(Token.LPAREN);
    if (this.eat(Token.RPAREN)) {
      return {
        Arguments: [],
        trailingComma: false
      };
    }
    const Arguments = [];
    let trailingComma = false;
    while (true) {
      const node = this.startNode();
      if (this.eat(Token.ELLIPSIS)) {
        node.AssignmentExpression = this.parseAssignmentExpression();
        Arguments.push(this.finishNode(node, 'AssignmentRestElement'));
      } else {
        Arguments.push(this.parseAssignmentExpression());
      }
      if (this.eat(Token.RPAREN)) {
        break;
      }
      this.expect(Token.COMMA);
      if (this.eat(Token.RPAREN)) {
        trailingComma = true;
        break;
      }
    }
    return {
      Arguments,
      trailingComma
    };
  }

  /** https://tc39.es/ecma262/#sec-class-definitions */
  // ClassDeclaration :
  //   `class` BindingIdentifier ClassTail
  //   [+Default] `class` ClassTail
  //
  // ClassExpression :
  //   `class` BindingIdentifier? ClassTail
  parseClass(isExpression) {
    const node = this.startNode();
    this.expect(Token.CLASS);
    this.scope.with({
      strict: true
    }, () => {
      if (!this.test(Token.LBRACE) && !this.test(Token.EXTENDS)) {
        node.BindingIdentifier = this.parseBindingIdentifier();
        if (!isExpression) {
          this.scope.declare(node.BindingIdentifier, 'lexical');
        }
      } else if (isExpression === false && !this.scope.isDefault()) {
        this.raise('ClassMissingBindingIdentifier');
      } else {
        node.BindingIdentifier = null;
      }
      node.ClassTail = this.scope.with({
        default: false
      }, () => this.parseClassTail());
    });
    return this.finishNode(node, isExpression ? 'ClassExpression' : 'ClassDeclaration');
  }

  // ClassTail : ClassHeritage? `{` ClassBody? `}`
  // ClassHeritage : `extends` LeftHandSideExpression
  // ClassBody : ClassElementList
  parseClassTail() {
    const node = this.startNode();
    if (this.eat(Token.EXTENDS)) {
      node.ClassHeritage = this.parseLeftHandSideExpression();
    } else {
      node.ClassHeritage = null;
    }
    this.expect(Token.LBRACE);
    if (this.eat(Token.RBRACE)) {
      node.ClassBody = null;
    } else {
      node.ClassBody = this.scope.with({
        superCall: !!node.ClassHeritage,
        private: true
      }, () => {
        const ClassBody = [];
        let hasConstructor = false;
        while (this.eat(Token.SEMICOLON)) {
          // nothing
        }
        const staticPrivates = new Set();
        const instancePrivates = new Set();
        while (!this.eat(Token.RBRACE)) {
          const m = this.parseClassElement();
          ClassBody.push(m);
          while (this.eat(Token.SEMICOLON)) {
            // nothing
          }
          if (m.type === 'ClassStaticBlock') {
            continue;
          }
          if (m.ClassElementName?.type === 'PrivateIdentifier') {
            let type;
            if (m.type === 'FieldDefinition') {
              type = 'field';
            } else if (m.UniqueFormalParameters) {
              type = 'method';
            } else if (m.PropertySetParameterList) {
              type = 'set';
            } else {
              type = 'get';
            }
            if (type === 'get' || type === 'set') {
              if (m.static) {
                if (instancePrivates.has(m.ClassElementName.name)) {
                  this.raiseEarly('InvalidMethodName', m, m.ClassElementName.name);
                } else {
                  staticPrivates.add(m.ClassElementName.name);
                }
              } else {
                if (staticPrivates.has(m.ClassElementName.name)) {
                  this.raiseEarly('InvalidMethodName', m, m.ClassElementName.name);
                } else {
                  instancePrivates.add(m.ClassElementName.name);
                }
              }
            }
            this.scope.declare(m.ClassElementName, 'private', type);
            if (m.ClassElementName.name === 'constructor') {
              this.raiseEarly('InvalidMethodName', m, m.ClassElementName.name);
            }
          }
          const name = PropName(m);
          const isActualConstructor = !m.static && m.type === 'MethodDefinition' && !!m.UniqueFormalParameters && name === 'constructor';
          if (isActualConstructor) {
            if (hasConstructor) {
              this.raiseEarly('DuplicateConstructor', m);
            } else {
              hasConstructor = true;
            }
          }
          if (m.static && name === 'prototype' || !m.static && !isActualConstructor && name === 'constructor') {
            this.raiseEarly('InvalidMethodName', m, name);
          }
          if (m.static && m.type === 'FieldDefinition' && name === 'constructor') {
            this.raiseEarly('InvalidMethodName', m, name);
          }
        }
        return ClassBody;
      });
    }
    return this.finishNode(node, 'ClassTail');
  }
  parseClassElement() {
    let element;
    if (this.test('static') && this.testAhead(Token.LBRACE)) {
      const node = this.startNode();
      this.expect('static');
      node.static = true;
      this.expect(Token.LBRACE);
      const ClassStaticBlockBody = this.startNode();
      ClassStaticBlockBody.ClassStaticBlockStatementList = this.scope.with({
        lexical: true,
        yield: false,
        await: true,
        return: false,
        superProperty: true,
        superCall: false,
        newTarget: true,
        label: 'boundary',
        classStaticBlock: true
      }, () => this.parseStatementList(Token.RBRACE));
      node.ClassStaticBlockBody = this.finishNode(ClassStaticBlockBody, 'ClassStaticBlockBody');
      element = this.finishNode(node, 'ClassStaticBlock');
    } else {
      element = this.parseBracketedDefinition('class element');
    }
    return element;
  }
  parseClassExpression() {
    return this.parseClass(true);
  }
  parseTemplateLiteral(tagged = false) {
    const node = this.startNode();
    const TemplateSpanList = [];
    const ExpressionList = [];
    let buffer = '';
    while (true) {
      if (this.position >= this.source.length) {
        this.raise('UnterminatedTemplate', this.position);
      }
      const c = this.source[this.position];
      switch (c) {
        case '`':
          this.position += 1;
          TemplateSpanList.push(buffer);
          this.next();
          if (!tagged) {
            TemplateSpanList.forEach(s => {
              if (TV(s) === undefined) {
                this.raise('InvalidTemplateEscape');
              }
            });
          }
          node.TemplateSpanList = TemplateSpanList;
          node.ExpressionList = ExpressionList;
          return this.finishNode(node, 'TemplateLiteral');
        case '$':
          this.position += 1;
          if (this.source[this.position] === '{') {
            this.position += 1;
            TemplateSpanList.push(buffer);
            buffer = '';
            this.next();
            ExpressionList.push(this.parseExpression());
            break;
          }
          buffer += c;
          break;
        default:
          {
            if (c === '\\') {
              buffer += c;
              this.position += 1;
            }
            const l = this.source[this.position];
            this.position += 1;
            if (isLineTerminator(l)) {
              if (l === '\r' && this.source[this.position] === '\n') {
                this.position += 1;
              }
              if (l === '\u{2028}' || l === '\u{2029}') {
                buffer += l;
              } else {
                buffer += '\n';
              }
              this.line += 1;
              this.columnOffset = this.position;
            } else {
              buffer += l;
            }
            break;
          }
      }
    }
  }

  // RegularExpressionLiteral :
  //   `/` RegularExpressionBody `/` RegularExpressionFlags
  parseRegularExpressionLiteral() {
    const node = this.startNode();
    this.scanRegularExpressionBody();
    const body = this.scannedValue; // NOTE: unsound cast
    node.RegularExpressionBody = body;
    const flagPosition = this.position;
    this.scanRegularExpressionFlags();
    node.RegularExpressionFlags = this.scannedValue; // NOTE: unsound cast
    if (node.RegularExpressionFlags.includes('v') && node.RegularExpressionFlags.includes('u')) {
      this.raise('InvalidRegExpFlags', flagPosition, 'u and v cannot be used together');
    }
    try {
      const parse = flags => {
        const p = new RegExpParser(body);
        return p.scope(flags, () => p.parsePattern());
      };
      if (node.RegularExpressionFlags.includes('u')) {
        parse({
          UnicodeMode: true,
          NamedCaptureGroups: true
        });
      } else if (node.RegularExpressionFlags.includes('v')) {
        parse({
          UnicodeMode: true,
          UnicodeSetsMode: true,
          NamedCaptureGroups: true
        });
      } else {
        // NOTE: this part is modified by Annex B (but we're not applying it for now)
        //       NamedCaptureGroups: false breaks for RegExp /\k<a>(?<a>b)/
        parse({
          NamedCaptureGroups: true
        });
      }
    } catch (e) {
      if (e instanceof SyntaxError) {
        this.raise('Raw', node.location.startIndex + e.position + 1, e.message);
      } else {
        throw e;
      }
    }
    const fakeToken = {
      endIndex: this.position - 1,
      line: this.line - 1,
      column: this.position - this.columnOffset
    }; // NOTE: unsound cast
    this.next();
    this.currentToken = fakeToken;
    return this.finishNode(node, 'RegularExpressionLiteral');
  }

  // CoverParenthesizedExpressionAndArrowParameterList :
  //   `(` Expression `)`
  //   `(` Expression `,` `)`
  //   `(` `)`
  //   `(` `...` BindingIdentifier `)`
  //   `(` `...` BindingPattern `)`
  //   `(` Expression `,` `...` BindingIdentifier `)`
  //   `(` Expression `.` `...` BindingPattern `)`
  parseCoverParenthesizedExpressionAndArrowParameterList() {
    const node = this.startNode();
    const commaOp = this.startNode();
    this.expect(Token.LPAREN);
    if (this.test(Token.RPAREN)) {
      if (!this.testAhead(Token.ARROW) || this.peekAhead().hadLineTerminatorBefore) {
        this.unexpected();
      }
      this.next();
      node.Arguments = [];
      return this.finishNode(node, 'CoverParenthesizedExpressionAndArrowParameterList');
    }
    this.scope.pushArrowInfo();
    this.scope.pushAssignmentInfo('arrow');
    const expressions = [];
    let rparenAfterComma;
    while (true) {
      if (this.test(Token.ELLIPSIS)) {
        const inner = this.startNode();
        this.next();
        switch (this.peek().type) {
          case Token.LBRACE:
          case Token.LBRACK:
            inner.BindingPattern = this.parseBindingPattern();
            break;
          default:
            inner.BindingIdentifier = this.parseBindingIdentifier();
            break;
        }
        expressions.push(this.finishNode(inner, 'BindingRestElement'));
        this.expect(Token.RPAREN);
        break;
      }
      expressions.push(this.parseAssignmentExpression());
      if (this.eat(Token.COMMA)) {
        if (this.eat(Token.RPAREN)) {
          rparenAfterComma = this.currentToken;
          break;
        }
      } else {
        this.expect(Token.RPAREN);
        break;
      }
    }
    const arrowInfo = this.scope.popArrowInfo();
    const assignmentInfo = this.scope.popAssignmentInfo();

    // ArrowParameters :
    //   CoverParenthesizedExpressionAndArrowParameterList
    if (this.test(Token.ARROW) && !this.peek().hadLineTerminatorBefore) {
      node.Arguments = expressions;
      node.arrowInfo = arrowInfo;
      assignmentInfo.clear();
      return this.finishNode(node, 'CoverParenthesizedExpressionAndArrowParameterList');
    } else {
      this.scope.arrowInfo?.merge(arrowInfo);
    }

    // ParenthesizedExpression :
    //   `(` Expression `)`
    if (expressions[expressions.length - 1].type === 'BindingRestElement') {
      this.unexpected(expressions[expressions.length - 1]);
    }
    if (rparenAfterComma) {
      this.unexpected(rparenAfterComma);
    }
    if (expressions.length === 1) {
      node.Expression = expressions[0]; // NOTE: unsound cast due to potential BindingRestElement
    } else {
      commaOp.ExpressionList = expressions; // NOTE: unsound cast
      node.Expression = this.finishNode(commaOp, 'CommaOperator');
    }
    return this.finishNode(node, 'ParenthesizedExpression');
  }

  // PropertyName :
  //   LiteralPropertyName
  //   ComputedPropertyName
  // LiteralPropertyName :
  //   IdentifierName
  //   StringLiteral
  //   NumericLiteral
  // ComputedPropertyName :
  //   `[` AssignmentExpression `]`
  parsePropertyName() {
    if (this.test(Token.LBRACK)) {
      const node = this.startNode();
      this.next();
      node.ComputedPropertyName = this.parseAssignmentExpression();
      this.expect(Token.RBRACK);
      return this.finishNode(node, 'PropertyName');
    }
    if (this.test(Token.STRING)) {
      return this.parseStringLiteral();
    }
    if (this.test(Token.NUMBER) || this.test(Token.BIGINT)) {
      return this.parseNumericLiteral();
    }
    return this.parseIdentifierName();
  }

  // ClassElementName :
  //   PropertyName
  //   PrivateIdentifier
  parseClassElementName() {
    if (this.test(Token.PRIVATE_IDENTIFIER)) {
      return this.parsePrivateIdentifier();
    }
    return this.parsePropertyName();
  }

  // PropertyDefinition :
  //   IdentifierReference
  //   CoverInitializedName
  //   PropertyName `:` AssignmentExpression
  //   MethodDefinition
  //   `...` AssignmentExpression
  // MethodDefinition :
  //   ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
  //   GeneratorMethod
  //   AsyncMethod
  //   AsyncGeneratorMethod
  //   `get` ClassElementName `(` `)` `{` FunctionBody `}`
  //   `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
  // GeneratorMethod :
  //   `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`
  // AsyncMethod :
  //   `async` [no LineTerminator here] ClassElementName `(` UniqueFormalParameters `)` `{` AsyncBody `}`
  // AsyncGeneratorMethod :
  //   `async` [no LineTerminator here] `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

  parseBracketedDefinition(type) {
    const node = this.startNode();
    if (type === 'property' && this.eat(Token.ELLIPSIS)) {
      node.PropertyName = null;
      node.AssignmentExpression = this.parseAssignmentExpression();
      return this.finishNode(node, 'PropertyDefinition');
    }
    let firstFirstName;
    if (type === 'class element') {
      if (this.test('static') && (this.testAhead(Token.ASSIGN) || this.testAhead(Token.SEMICOLON) || this.peekAhead().hadLineTerminatorBefore || isAutomaticSemicolon(this.peekAhead().type))) {
        node.static = false;
        firstFirstName = this.parseIdentifierName();
      } else {
        node.static = this.eat('static');
        this.markNodeStart(node);
      }
    }
    let isGenerator = this.eat(Token.MUL);
    let isGetter = false;
    let isSetter = false;
    let isAsync = false;
    if (!isGenerator) {
      if (this.test('get')) {
        isGetter = true;
      } else if (this.test('set')) {
        isSetter = true;
      } else if (this.test('async') && !this.peekAhead().hadLineTerminatorBefore) {
        isAsync = true;
      }
    }
    const firstName = firstFirstName || (type === 'property' ? this.parsePropertyName() : this.parseClassElementName());
    if (!isGenerator && isAsync) {
      isGenerator = this.eat(Token.MUL);
    }
    const isSpecialMethod = isGenerator || (isSetter || isGetter || isAsync) && !this.test(Token.LPAREN);
    if (!isGenerator) {
      if (type === 'property' && this.eat(Token.COLON)) {
        node.PropertyName = firstName; // NOTE: unsound cast
        node.AssignmentExpression = this.parseAssignmentExpression();
        return this.finishNode(node, 'PropertyDefinition');
      }
      if (type === 'class element' && (this.test(Token.ASSIGN) || this.test(Token.SEMICOLON) || this.peek().hadLineTerminatorBefore || isAutomaticSemicolon(this.peek().type))) {
        node.ClassElementName = firstName;
        node.Initializer = this.scope.with({
          superProperty: true
        }, () => this.parseInitializerOpt());
        const argumentNode = node.Initializer && ContainsArguments(node.Initializer);
        if (argumentNode) {
          this.raiseEarly('UnexpectedToken', argumentNode);
        }
        const finished = this.finishNode(node, 'FieldDefinition');
        this.semicolon();
        return finished;
      }
      if (type === 'property' && this.scope.assignmentInfoStack.length > 0 && this.test(Token.ASSIGN)) {
        // NOTE: The next line is unsafe because firstName could be something other than IdentifierName
        node.IdentifierReference = this.repurpose(firstName, 'IdentifierReference');
        node.Initializer = this.parseInitializerOpt();
        const finished = this.finishNode(node, 'CoverInitializedName');
        this.scope.registerObjectLiteralEarlyError(this.raiseEarly('UnexpectedToken', finished));
        return finished;
      }
      if (type === 'property' && !isSpecialMethod && firstName.type === 'IdentifierName' && !this.test(Token.LPAREN) && (!isKeywordRaw(firstName.name) || firstName.name === 'yield' && !this.scope.hasYield() || firstName.name === 'await' && !this.scope.hasAwait())) {
        const IdentifierReference = this.repurpose(firstName, 'IdentifierReference');
        this.validateIdentifierReference(firstName.name, firstName);
        return IdentifierReference;
      }
    }
    if (isSpecialMethod && (!isGenerator || isAsync)) {
      if (type === 'property') {
        node.ClassElementName = this.parsePropertyName();
      } else {
        node.ClassElementName = this.parseClassElementName();
      }
    } else {
      node.ClassElementName = firstName;
    }
    this.scope.with({
      lexical: true,
      variable: true,
      superProperty: true,
      await: isAsync,
      yield: isGenerator,
      classStaticBlock: false
    }, () => {
      if (isSpecialMethod && isGetter) {
        this.expect(Token.LPAREN);
        this.expect(Token.RPAREN);
        node.PropertySetParameterList = null;
        node.UniqueFormalParameters = null;
      } else if (isSpecialMethod && isSetter) {
        this.expect(Token.LPAREN);
        node.PropertySetParameterList = [this.parseFormalParameter()];
        this.expect(Token.RPAREN);
        node.UniqueFormalParameters = null;
      } else {
        node.PropertySetParameterList = null;
        node.UniqueFormalParameters = this.parseUniqueFormalParameters();
      }
      this.scope.with({
        superCall: !isSpecialMethod && !node.static && node.ClassElementName && (node.ClassElementName.type === 'IdentifierName' && node.ClassElementName.name === 'constructor' || node.ClassElementName.type === 'StringLiteral' && node.ClassElementName.value === 'constructor') && this.scope.hasSuperCall()
      }, () => {
        const body = this.parseFunctionBody(isAsync, isGenerator, false);
        // Unsafe cast below
        if (!isAsync && !isGenerator) {
          node.FunctionBody = body;
        } else if (isAsync && !isGenerator) {
          node.AsyncBody = body;
        } else if (!isAsync && isGenerator) {
          node.GeneratorBody = body;
        } else if (isAsync && isGenerator) {
          node.AsyncGeneratorBody = body;
        }
        if (node.UniqueFormalParameters || node.PropertySetParameterList) {
          this.validateFormalParameters(node.UniqueFormalParameters || node.PropertySetParameterList, body, true);
        }
      });
    });
    let name;
    if (isAsync) {
      name = isGenerator ? 'AsyncGeneratorMethod' : 'AsyncMethod';
    } else {
      name = isGenerator ? 'GeneratorMethod' : 'MethodDefinition';
    }
    return this.finishNode(node, name);
  }
}

class StatementParser extends ExpressionParser {
  eatSemicolonWithASI() {
    if (this.eat(Token.SEMICOLON)) {
      return true;
    }
    if (this.peek().hadLineTerminatorBefore || isAutomaticSemicolon(this.peek().type)) {
      return true;
    }
    return false;
  }
  semicolon() {
    if (!this.eatSemicolonWithASI()) {
      this.unexpected();
    }
  }

  // StatementList :
  //   StatementListItem
  //   StatementList StatementListItem
  /**
   * @param endToken endToken
   * @param directives directives, this array will be mutated.
   */
  parseStatementList(endToken, directives) {
    const statementList = [];
    const oldStrict = this.state.strict;
    const directiveData = [];
    while (!this.eat(endToken)) {
      if (directives !== undefined && this.test(Token.STRING)) {
        const token = this.peek();
        const directive = this.source.slice(token.startIndex + 1, token.endIndex - 1);
        if (directive === 'use strict') {
          this.state.strict = true;
          directiveData.forEach(d => {
            if (/\\([1-9]|0\d)/.test(d.directive)) {
              this.raiseEarly('IllegalOctalEscape', d.token);
            }
          });
        }
        directives.push(directive);
        directiveData.push({
          directive,
          token
        });
      } else {
        directives = undefined;
      }
      const stmt = this.parseStatementListItem();
      statementList.push(stmt);
    }
    this.state.strict = oldStrict;
    return statementList;
  }

  // StatementListItem :
  //   Statement
  //   Declaration
  //
  // Declaration :
  //   HoistableDeclaration
  //   ClassDeclaration
  //   LexicalDeclaration
  parseStatementListItem() {
    switch (this.peek().type) {
      case Token.FUNCTION:
        return this.parseHoistableDeclaration();
      case Token.CLASS:
        return this.parseClassDeclaration();
      case Token.CONST:
        return this.parseLexicalDeclaration();
      default:
        if (this.test('let')) {
          switch (this.peekAhead().type) {
            case Token.LBRACE:
            case Token.LBRACK:
            case Token.IDENTIFIER:
            case Token.YIELD:
            case Token.AWAIT:
              return this.parseLexicalDeclaration();
          }
        }
        if (this.test('async') && this.testAhead(Token.FUNCTION) && !this.peekAhead().hadLineTerminatorBefore) {
          return this.parseHoistableDeclaration();
        }
        return this.parseStatement();
    }
  }

  // HoistableDeclaration :
  //   FunctionDeclaration
  //   GeneratorDeclaration
  //   AsyncFunctionDeclaration
  //   AsyncGeneratorDeclaration
  parseHoistableDeclaration() {
    switch (this.peek().type) {
      case Token.FUNCTION:
        return this.parseFunctionDeclaration(FunctionKind.NORMAL);
      default:
        if (this.test('async') && this.testAhead(Token.FUNCTION) && !this.peekAhead().hadLineTerminatorBefore) {
          return this.parseFunctionDeclaration(FunctionKind.ASYNC);
        }
        throw new Error('unreachable');
    }
  }

  // ClassDeclaration :
  //   `class` BindingIdentifier ClassTail
  //   [+Default] `class` ClassTail
  parseClassDeclaration() {
    return this.parseClass(false);
  }

  // LexicalDeclaration : LetOrConst BindingList `;`
  parseLexicalDeclaration() {
    const node = this.startNode();
    const letOrConst = this.eat('let') ? 'let' : this.expect(Token.CONST) && 'const';
    node.LetOrConst = letOrConst;
    node.BindingList = this.parseBindingList();
    this.semicolon();
    this.scope.declare(node.BindingList, 'lexical');
    node.BindingList.forEach(b => {
      if (node.LetOrConst === 'const' && !b.Initializer) {
        this.raiseEarly('ConstDeclarationMissingInitializer', b);
      }
    });
    return this.finishNode(node, 'LexicalDeclaration');
  }

  // BindingList :
  //   LexicalBinding
  //   BindingList `,` LexicalBinding
  //
  // LexicalBinding :
  //   BindingIdentifier Initializer?
  //   BindingPattern Initializer
  parseBindingList() {
    const bindingList = [];
    do {
      const node = this.parseBindingElement();
      bindingList.push(this.repurpose(node, 'LexicalBinding'));
    } while (this.eat(Token.COMMA));
    return bindingList;
  }

  // BindingElement :
  //   SingleNameBinding
  //   BindingPattern Initializer?
  // SingleNameBinding :
  //   BindingIdentifier Initializer?
  parseBindingElement() {
    const node = this.startNode();
    if (this.test(Token.LBRACE) || this.test(Token.LBRACK)) {
      node.BindingPattern = this.parseBindingPattern();
    } else {
      node.BindingIdentifier = this.parseBindingIdentifier();
    }
    node.Initializer = this.parseInitializerOpt();
    return this.finishNode(node, node.BindingPattern ? 'BindingElement' : 'SingleNameBinding');
  }

  // BindingPattern:
  //   ObjectBindingPattern
  //   ArrayBindingPattern
  parseBindingPattern() {
    switch (this.peek().type) {
      case Token.LBRACE:
        return this.parseObjectBindingPattern();
      case Token.LBRACK:
        return this.parseArrayBindingPattern();
      default:
        return this.unexpected();
    }
  }

  // ObjectBindingPattern :
  //   `{` `}`
  //   `{` BindingRestProperty `}`
  //   `{` BindingPropertyList `}`
  //   `{` BindingPropertyList `,` BindingRestProperty? `}`
  parseObjectBindingPattern() {
    const node = this.startNode();
    this.expect(Token.LBRACE);
    const BindingPropertyList = [];
    node.BindingPropertyList = BindingPropertyList;
    while (!this.eat(Token.RBRACE)) {
      if (this.test(Token.ELLIPSIS)) {
        node.BindingRestProperty = this.parseBindingRestProperty();
        this.expect(Token.RBRACE);
        break;
      } else {
        BindingPropertyList.push(this.parseBindingProperty());
        if (!this.eat(Token.COMMA)) {
          this.expect(Token.RBRACE);
          break;
        }
      }
    }
    return this.finishNode(node, 'ObjectBindingPattern');
  }

  // BindingProperty :
  //   SingleNameBinding
  //   PropertyName : BindingElement
  parseBindingProperty() {
    const node = this.startNode();
    const name = this.parsePropertyName();
    if (this.eat(Token.COLON)) {
      node.PropertyName = name;
      node.BindingElement = this.parseBindingElement();
      return this.finishNode(node, 'BindingProperty');
    } else {
      if (name.type !== 'IdentifierName') {
        this.unexpected(name);
      }
      this.validateIdentifierReference(name.name, node);
    }
    node.BindingIdentifier = this.repurpose(name, 'BindingIdentifier');
    node.Initializer = this.parseInitializerOpt();
    return this.finishNode(node, 'SingleNameBinding');
  }

  // BindingRestProperty :
  //  `...` BindingIdentifier
  parseBindingRestProperty() {
    const node = this.startNode();
    this.expect(Token.ELLIPSIS);
    node.BindingIdentifier = this.parseBindingIdentifier();
    return this.finishNode(node, 'BindingRestProperty');
  }

  // ArrayBindingPattern :
  //   `[` Elision? BindingRestElement `]`
  //   `[` BindingElementList `]`
  //   `[` BindingElementList `,` Elision? BindingRestElement `]`
  parseArrayBindingPattern() {
    const node = this.startNode();
    this.expect(Token.LBRACK);
    const BindingElementList = [];
    node.BindingElementList = BindingElementList;
    while (true) {
      while (this.test(Token.COMMA)) {
        const elision = this.startNode();
        this.next();
        BindingElementList.push(this.finishNode(elision, 'Elision'));
      }
      if (this.eat(Token.RBRACK)) {
        break;
      }
      if (this.test(Token.ELLIPSIS)) {
        node.BindingRestElement = this.parseBindingRestElement();
        this.expect(Token.RBRACK);
        break;
      } else {
        BindingElementList.push(this.parseBindingElement());
      }
      if (this.eat(Token.RBRACK)) {
        break;
      }
      this.expect(Token.COMMA);
    }
    return this.finishNode(node, 'ArrayBindingPattern');
  }

  // BindingRestElement :
  //   `...` BindingIdentifier
  //   `...` BindingPattern
  parseBindingRestElement() {
    const node = this.startNode();
    this.expect(Token.ELLIPSIS);
    switch (this.peek().type) {
      case Token.LBRACE:
      case Token.LBRACK:
        node.BindingPattern = this.parseBindingPattern();
        break;
      default:
        node.BindingIdentifier = this.parseBindingIdentifier();
        break;
    }
    return this.finishNode(node, 'BindingRestElement');
  }

  // Initializer : `=` AssignmentExpression
  parseInitializerOpt() {
    if (this.eat(Token.ASSIGN)) {
      return this.parseAssignmentExpression();
    }
    return null;
  }

  // FunctionDeclaration
  parseFunctionDeclaration(kind) {
    return this.parseFunction(false, kind);
  }

  // Statement :
  //   ...
  parseStatement() {
    switch (this.peek().type) {
      case Token.LBRACE:
        return this.parseBlockStatement();
      case Token.VAR:
        return this.parseVariableStatement();
      case Token.SEMICOLON:
        {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, 'EmptyStatement');
        }
      case Token.IF:
        return this.parseIfStatement();
      case Token.DO:
        return this.parseDoWhileStatement();
      case Token.WHILE:
        return this.parseWhileStatement();
      case Token.FOR:
        return this.parseForStatement();
      case Token.SWITCH:
        return this.parseSwitchStatement();
      case Token.CONTINUE:
      case Token.BREAK:
        return this.parseBreakContinueStatement();
      case Token.RETURN:
        return this.parseReturnStatement();
      case Token.WITH:
        return this.parseWithStatement();
      case Token.THROW:
        return this.parseThrowStatement();
      case Token.TRY:
        return this.parseTryStatement();
      case Token.DEBUGGER:
        return this.parseDebuggerStatement();
      default:
        return this.parseExpressionStatement();
    }
  }

  // BlockStatement : Block
  parseBlockStatement() {
    return this.parseBlock();
  }

  // Block : `{` StatementList `}`
  parseBlock(lexical = true) {
    const node = this.startNode();
    this.expect(Token.LBRACE);
    node.StatementList = this.scope.with({
      lexical
    }, () => this.parseStatementList(Token.RBRACE));
    return this.finishNode(node, 'Block');
  }

  // VariableStatement : `var` VariableDeclarationList `;`
  parseVariableStatement() {
    const node = this.startNode();
    this.expect(Token.VAR);
    node.VariableDeclarationList = this.parseVariableDeclarationList();
    this.semicolon();
    this.scope.declare(node.VariableDeclarationList, 'variable');
    return this.finishNode(node, 'VariableStatement');
  }

  // VariableDeclarationList :
  //   VariableDeclaration
  //   VariableDeclarationList `,` VariableDeclaration
  parseVariableDeclarationList(firstDeclarationRequiresInit = true) {
    const declarationList = [];
    do {
      const node = this.parseVariableDeclaration(firstDeclarationRequiresInit);
      declarationList.push(node);
    } while (this.eat(Token.COMMA));
    return declarationList;
  }

  // VariableDeclaration :
  //   BindingIdentifier Initializer?
  //   BindingPattern Initializer
  parseVariableDeclaration(firstDeclarationRequiresInit) {
    const node = this.startNode();
    switch (this.peek().type) {
      case Token.LBRACE:
      case Token.LBRACK:
        node.BindingPattern = this.parseBindingPattern();
        if (firstDeclarationRequiresInit) {
          this.expect(Token.ASSIGN);
          node.Initializer = this.parseAssignmentExpression();
        } else {
          node.Initializer = this.parseInitializerOpt();
        }
        break;
      default:
        node.BindingIdentifier = this.parseBindingIdentifier();
        node.Initializer = this.parseInitializerOpt();
        break;
    }
    return this.finishNode(node, 'VariableDeclaration');
  }

  // IfStatement :
  //  `if` `(` Expression `)` Statement `else` Statement
  //  `if` `(` Expression `)` Statement [lookahead != `else`]
  parseIfStatement() {
    const node = this.startNode();
    this.expect(Token.IF);
    this.expect(Token.LPAREN);
    node.Expression = this.parseExpression();
    this.expect(Token.RPAREN);
    node.Statement_a = this.parseStatement();
    if (this.eat(Token.ELSE)) {
      node.Statement_b = this.parseStatement();
    }
    return this.finishNode(node, 'IfStatement');
  }

  // `while` `(` Expression `)` Statement
  parseWhileStatement() {
    const node = this.startNode();
    this.expect(Token.WHILE);
    this.expect(Token.LPAREN);
    node.Expression = this.parseExpression();
    this.expect(Token.RPAREN);
    this.scope.with({
      label: 'loop'
    }, () => {
      node.Statement = this.parseStatement();
    });
    return this.finishNode(node, 'WhileStatement');
  }

  // `do` Statement `while` `(` Expression `)` `;`
  parseDoWhileStatement() {
    const node = this.startNode();
    this.expect(Token.DO);
    node.Statement = this.scope.with({
      label: 'loop'
    }, () => this.parseStatement());
    this.expect(Token.WHILE);
    this.expect(Token.LPAREN);
    node.Expression = this.parseExpression();
    this.expect(Token.RPAREN);
    // Semicolons are completely optional after a do-while, even without a newline
    this.eat(Token.SEMICOLON);
    return this.finishNode(node, 'DoWhileStatement');
  }

  // `for` `(` [lookahead != `let` `[`] Expression? `;` Expression? `;` Expression? `)` Statement
  // `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
  // `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
  // `for` `(` [lookahead != `let` `[`] LeftHandSideExpression `in` Expression `)` Statement
  // `for` `(` `var` ForBinding `in` Expression `)` Statement
  // `for` `(` ForDeclaration `in` Expression `)` Statement
  // `for` `(` [lookahead != { `let`, `async` `of` }] LeftHandSideExpression `of` AssignmentExpression `)` Statement
  // `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  // `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
  // `for` `await` `(` [lookahead != `let`] LeftHandSideExpression `of` AssignmentExpression `)` Statement
  // `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  // `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
  //
  // ForDeclaration : LetOrConst ForBinding
  parseForStatement() {
    return this.scope.with({
      lexical: true,
      label: 'loop'
    }, () => {
      const node = this.startNode();
      this.expect(Token.FOR);
      const isAwait = this.scope.hasAwait() && this.eat(Token.AWAIT);
      if (isAwait && !this.scope.hasReturn()) {
        this.state.hasTopLevelAwait = true;
      }
      this.expect(Token.LPAREN);
      if (isAwait && this.test(Token.SEMICOLON)) {
        this.unexpected();
      }
      if (this.eat(Token.SEMICOLON)) {
        if (!this.test(Token.SEMICOLON)) {
          node.Expression_b = this.parseExpression();
        }
        this.expect(Token.SEMICOLON);
        if (!this.test(Token.RPAREN)) {
          node.Expression_c = this.parseExpression();
        }
        this.expect(Token.RPAREN);
        node.Statement = this.parseStatement();
        return this.finishNode(node, 'ForStatement');
      }
      const isLexicalStart = () => {
        switch (this.peekAhead().type) {
          case Token.LBRACE:
          case Token.LBRACK:
          case Token.IDENTIFIER:
          case Token.YIELD:
          case Token.AWAIT:
            return true;
          default:
            return false;
        }
      };
      if ((this.test('let') || this.test(Token.CONST)) && isLexicalStart()) {
        const inner = this.startNode();
        if (this.eat('let')) {
          inner.LetOrConst = 'let';
        } else {
          this.expect(Token.CONST);
          inner.LetOrConst = 'const';
        }
        const list = this.parseBindingList();
        this.scope.declare(list, 'lexical');
        if (list.length > 1 || this.test(Token.SEMICOLON)) {
          inner.BindingList = list;
          node.LexicalDeclaration = this.finishNode(inner, 'LexicalDeclaration');
          this.expect(Token.SEMICOLON);
          if (!this.test(Token.SEMICOLON)) {
            node.Expression_a = this.parseExpression();
          }
          this.expect(Token.SEMICOLON);
          if (!this.test(Token.RPAREN)) {
            node.Expression_b = this.parseExpression();
          }
          this.expect(Token.RPAREN);
          node.Statement = this.parseStatement();
          return this.finishNode(node, 'ForStatement');
        }
        inner.ForBinding = this.repurpose(list[0], 'ForBinding', (_, oldNode) => {
          if (oldNode.Initializer) {
            this.unexpected(oldNode.Initializer);
          }
        });
        node.ForDeclaration = this.finishNode(inner, 'ForDeclaration');
        getDeclarations(node.ForDeclaration).forEach(d => {
          if (d.name === 'let') {
            this.raiseEarly('UnexpectedToken', d.node);
          }
        });
        if (!isAwait && this.eat(Token.IN)) {
          node.Expression = this.parseExpression();
          this.expect(Token.RPAREN);
          node.Statement = this.parseStatement();
          return this.finishNode(node, 'ForInStatement');
        }
        this.expect('of');
        node.AssignmentExpression = this.parseAssignmentExpression();
        this.expect(Token.RPAREN);
        node.Statement = this.parseStatement();
        return this.finishNode(node, isAwait ? 'ForAwaitStatement' : 'ForOfStatement');
      }
      if (this.eat(Token.VAR)) {
        if (isAwait) {
          node.ForBinding = this.parseForBinding();
          this.expect('of');
          node.AssignmentExpression = this.parseAssignmentExpression();
          this.expect(Token.RPAREN);
          node.Statement = this.parseStatement();
          return this.finishNode(node, 'ForAwaitStatement');
        }
        const list = this.parseVariableDeclarationList(false);
        if (list.length > 1 || this.test(Token.SEMICOLON)) {
          node.VariableDeclarationList = list;
          this.expect(Token.SEMICOLON);
          if (!this.test(Token.SEMICOLON)) {
            node.Expression_a = this.parseExpression();
          }
          this.expect(Token.SEMICOLON);
          if (!this.test(Token.RPAREN)) {
            node.Expression_b = this.parseExpression();
          }
          this.expect(Token.RPAREN);
          node.Statement = this.parseStatement();
          return this.finishNode(node, 'ForStatement');
        }
        node.ForBinding = this.repurpose(list[0], 'ForBinding', (_, oldNode) => {
          if (oldNode.Initializer) {
            this.unexpected(oldNode.Initializer);
          }
        });
        if (this.eat('of')) {
          node.AssignmentExpression = this.parseAssignmentExpression();
        } else {
          this.expect(Token.IN);
          node.Expression = this.parseExpression();
        }
        this.expect(Token.RPAREN);
        node.Statement = this.parseStatement();
        return this.finishNode(node, node.AssignmentExpression ? 'ForOfStatement' : 'ForInStatement');
      }
      this.scope.pushAssignmentInfo('for');
      const expression = this.scope.with({
        in: false
      }, () => this.parseExpression());
      const validateLHS = n => {
        if (n.type === 'AssignmentExpression') {
          this.raiseEarly('UnexpectedToken', n);
        } else {
          this.validateAssignmentTarget(n);
        }
      };
      const assignmentInfo = this.scope.popAssignmentInfo();
      if (!isAwait && this.eat(Token.IN)) {
        assignmentInfo.clear();
        validateLHS(expression);
        node.LeftHandSideExpression = expression; // NOTE: unsound cast
        node.Expression = this.parseExpression();
        this.expect(Token.RPAREN);
        node.Statement = this.parseStatement();
        return this.finishNode(node, 'ForInStatement');
      }
      const isExactlyAsync = expression.type === 'IdentifierReference' && !expression.escaped && expression.name === 'async';
      if ((!isExactlyAsync || isAwait) && this.eat('of')) {
        assignmentInfo.clear();
        validateLHS(expression);
        node.LeftHandSideExpression = expression; // NOTE: unsound cast
        node.AssignmentExpression = this.parseAssignmentExpression();
        this.expect(Token.RPAREN);
        node.Statement = this.parseStatement();
        return this.finishNode(node, isAwait ? 'ForAwaitStatement' : 'ForOfStatement');
      }
      node.Expression_a = expression;
      this.expect(Token.SEMICOLON);
      if (!this.test(Token.SEMICOLON)) {
        node.Expression_b = this.parseExpression();
      }
      this.expect(Token.SEMICOLON);
      if (!this.test(Token.RPAREN)) {
        node.Expression_c = this.parseExpression();
      }
      this.expect(Token.RPAREN);
      node.Statement = this.parseStatement();
      return this.finishNode(node, 'ForStatement');
    });
  }

  // ForBinding :
  //   BindingIdentifier
  //   BindingPattern
  parseForBinding() {
    const node = this.startNode();
    switch (this.peek().type) {
      case Token.LBRACE:
      case Token.LBRACK:
        node.BindingPattern = this.parseBindingPattern();
        break;
      default:
        node.BindingIdentifier = this.parseBindingIdentifier();
        break;
    }
    return this.finishNode(node, 'ForBinding');
  }

  // SwitchStatement :
  //   `switch` `(` Expression `)` CaseBlock
  parseSwitchStatement() {
    const node = this.startNode();
    this.expect(Token.SWITCH);
    this.expect(Token.LPAREN);
    node.Expression = this.parseExpression();
    this.expect(Token.RPAREN);
    this.scope.with({
      lexical: true,
      label: 'switch'
    }, () => {
      node.CaseBlock = this.parseCaseBlock();
    });
    return this.finishNode(node, 'SwitchStatement');
  }

  // CaseBlock :
  //   `{` CaseClauses? `}`
  //   `{` CaseClauses? DefaultClause CaseClauses? `}`
  // CaseClauses :
  //   CaseClause
  //   CaseClauses CauseClause
  // CaseClause :
  //   `case` Expression `:` StatementList?
  // DefaultClause :
  //   `default` `:` StatementList?
  parseCaseBlock() {
    const node = this.startNode();
    let CaseClauses_a;
    let CaseClauses_b;
    this.expect(Token.LBRACE);
    while (!this.eat(Token.RBRACE)) {
      switch (this.peek().type) {
        case Token.CASE:
        case Token.DEFAULT:
          {
            const inner = this.startNode();
            const t = this.next().type;
            if (t === Token.DEFAULT && node.DefaultClause) {
              this.unexpected();
            }
            if (t === Token.CASE) {
              inner.Expression = this.parseExpression();
            }
            this.expect(Token.COLON);
            let StatementList;
            while (!(this.test(Token.CASE) || this.test(Token.DEFAULT) || this.test(Token.RBRACE))) {
              if (!StatementList) {
                StatementList = [];
                inner.StatementList = StatementList;
              }
              StatementList.push(this.parseStatementListItem());
            }
            if (t === Token.DEFAULT) {
              node.DefaultClause = this.finishNode(inner, 'DefaultClause');
            } else {
              if (node.DefaultClause) {
                if (!CaseClauses_b) {
                  CaseClauses_b = [];
                  node.CaseClauses_b = CaseClauses_b;
                }
                CaseClauses_b.push(this.finishNode(inner, 'CaseClause'));
              } else {
                if (!CaseClauses_a) {
                  CaseClauses_a = [];
                  node.CaseClauses_a = CaseClauses_a;
                }
                CaseClauses_a.push(this.finishNode(inner, 'CaseClause'));
              }
            }
            break;
          }
        default:
          this.unexpected();
      }
    }
    return this.finishNode(node, 'CaseBlock');
  }

  // BreakStatement :
  //   `break` `;`
  //   `break` [no LineTerminator here] LabelIdentifier `;`
  //
  // ContinueStatement :
  //   `continue` `;`
  //   `continue` [no LineTerminator here] LabelIdentifier `;`
  parseBreakContinueStatement() {
    const node = this.startNode();
    const isBreak = this.eat(Token.BREAK);
    if (!isBreak) {
      this.expect(Token.CONTINUE);
    }
    if (this.eat(Token.SEMICOLON)) {
      node.LabelIdentifier = null;
    } else if (this.peek().hadLineTerminatorBefore) {
      node.LabelIdentifier = null;
      this.semicolon();
    } else {
      if (this.test(Token.IDENTIFIER)) {
        node.LabelIdentifier = this.parseLabelIdentifier();
      } else {
        node.LabelIdentifier = null;
      }
      this.semicolon();
    }
    this.verifyBreakContinue(node, isBreak);
    return this.finishNode(node, isBreak ? 'BreakStatement' : 'ContinueStatement');
  }
  verifyBreakContinue(node, isBreak) {
    let i = 0;
    for (; i < this.scope.labels.length; i += 1) {
      const label = this.scope.labels[i];
      if (!node.LabelIdentifier || node.LabelIdentifier.name === label.name) {
        if (label.type && (isBreak || label.type === 'loop')) {
          break;
        }
        if (node.LabelIdentifier && isBreak) {
          break;
        }
      }
    }
    if (i === this.scope.labels.length) {
      this.raiseEarly('IllegalBreakContinue', node, isBreak);
    }
  }

  // ReturnStatement :
  //   `return` `;`
  //   `return` [no LineTerminator here] Expression `;`
  parseReturnStatement() {
    if (!this.scope.hasReturn()) {
      this.unexpected();
    }
    const node = this.startNode();
    this.expect(Token.RETURN);
    if (this.eatSemicolonWithASI()) {
      node.Expression = null;
    } else {
      node.Expression = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node, 'ReturnStatement');
  }

  // WithStatement :
  //   `with` `(` Expression `)` Statement
  parseWithStatement() {
    if (this.isStrictMode()) {
      this.raiseEarly('UnexpectedToken');
    }
    const node = this.startNode();
    this.expect(Token.WITH);
    this.expect(Token.LPAREN);
    node.Expression = this.parseExpression();
    this.expect(Token.RPAREN);
    node.Statement = this.parseStatement();
    return this.finishNode(node, 'WithStatement');
  }

  // ThrowStatement :
  //   `throw` [no LineTerminator here] Expression `;`
  parseThrowStatement() {
    const node = this.startNode();
    this.expect(Token.THROW);
    if (this.peek().hadLineTerminatorBefore) {
      this.raise('NewlineAfterThrow', node);
    }
    node.Expression = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, 'ThrowStatement');
  }

  // TryStatement :
  //   `try` Block Catch
  //   `try` Block Finally
  //   `try` Block Catch Finally
  //
  // Catch :
  //   `catch` `(` CatchParameter `)` Block
  //   `catch` Block
  //
  // Finally :
  //   `finally` Block
  //
  // CatchParameter :
  //   BindingIdentifier
  //   BindingPattern
  parseTryStatement() {
    const node = this.startNode();
    this.expect(Token.TRY);
    node.Block = this.parseBlock();
    if (this.eat(Token.CATCH)) {
      this.scope.with({
        lexical: true
      }, () => {
        const clause = this.startNode();
        if (this.eat(Token.LPAREN)) {
          switch (this.peek().type) {
            case Token.LBRACE:
            case Token.LBRACK:
              clause.CatchParameter = this.parseBindingPattern();
              break;
            default:
              clause.CatchParameter = this.parseBindingIdentifier();
              break;
          }
          this.scope.declare(clause.CatchParameter, 'lexical');
          this.expect(Token.RPAREN);
        } else {
          clause.CatchParameter = null;
        }
        clause.Block = this.parseBlock(false);
        node.Catch = this.finishNode(clause, 'Catch');
      });
    } else {
      node.Catch = null;
    }
    if (this.eat(Token.FINALLY)) {
      node.Finally = this.parseBlock();
    } else {
      node.Finally = null;
    }
    if (!node.Catch && !node.Finally) {
      this.raise('TryMissingCatchOrFinally');
    }
    return this.finishNode(node, 'TryStatement');
  }

  // DebuggerStatement : `debugger` `;`
  parseDebuggerStatement() {
    const node = this.startNode();
    this.expect(Token.DEBUGGER);
    this.semicolon();
    return this.finishNode(node, 'DebuggerStatement');
  }

  // ExpressionStatement :
  //   [lookahead != `{`, `function`, `async` [no LineTerminator here] `function`, `class`, `let` `[` ] Expression `;`
  parseExpressionStatement() {
    switch (this.peek().type) {
      case Token.LBRACE:
      case Token.FUNCTION:
      case Token.CLASS:
        this.unexpected();
        break;
      default:
        if (this.test('async') && this.testAhead(Token.FUNCTION) && !this.peekAhead().hadLineTerminatorBefore) {
          this.unexpected();
        }
        if (this.test('let') && this.testAhead(Token.LBRACK)) {
          this.unexpected();
        }
        break;
    }
    const startToken = this.peek();
    const node = this.startNode();
    const expression = this.parseExpression();
    if (expression.type === 'IdentifierReference' && this.eat(Token.COLON)) {
      const LabelIdentifier = this.repurpose(expression, 'LabelIdentifier');
      node.LabelIdentifier = LabelIdentifier;
      if (this.scope.labels.find(l => l.name === LabelIdentifier.name)) {
        this.raiseEarly('AlreadyDeclared', node.LabelIdentifier, node.LabelIdentifier.name);
      }
      let type = null;
      switch (this.peek().type) {
        case Token.SWITCH:
          type = 'switch';
          break;
        case Token.DO:
        case Token.WHILE:
        case Token.FOR:
          type = 'loop';
          break;
      }
      if (type !== null && this.scope.labels.length > 0) {
        const last = this.scope.labels[this.scope.labels.length - 1];
        if (last.nextToken === startToken) {
          last.type = type;
        }
      }
      this.scope.labels.push({
        name: node.LabelIdentifier.name,
        type,
        nextToken: type === null ? this.peek() : null
      });
      node.LabelledItem = this.parseStatement();
      this.scope.labels.pop();
      return this.finishNode(node, 'LabelledStatement');
    }
    node.Expression = expression;
    this.semicolon();
    return this.finishNode(node, 'ExpressionStatement');
  }
}

class ModuleParser extends StatementParser {
  // ImportDeclaration :
  //   `import` ImportClause FromClause WithClause? `;`
  //   `import` ModuleSpecifier WithClause? `;`
  parseImportDeclaration() {
    if (this.testAhead(Token.PERIOD) || this.testAhead(Token.LPAREN)) {
      // `import` `(`
      // `import` `.`
      return this.parseExpressionStatement();
    }
    const node = this.startNode();
    this.next();
    if (this.test(Token.STRING)) {
      node.ModuleSpecifier = this.parsePrimaryExpression();
    } else {
      node.ImportClause = this.parseImportClause();
      this.scope.declare(node.ImportClause, 'import');
      node.FromClause = this.parseFromClause();
    }
    if (this.test(Token.WITH)) {
      node.WithClause = this.parseWithClause();
    }
    this.semicolon();
    return this.finishNode(node, 'ImportDeclaration');
  }

  // ImportClause :
  //   ImportedDefaultBinding
  //   NameSpaceImport
  //   NamedImports
  //   ImportedDefaultBinding `,` NameSpaceImport
  //   ImportedDefaultBinding `,` NamedImports
  //
  // ImportedBinding :
  //   BindingIdentifier
  parseImportClause() {
    const node = this.startNode();
    if (this.test(Token.IDENTIFIER)) {
      node.ImportedDefaultBinding = this.parseImportedDefaultBinding();
      if (!this.eat(Token.COMMA)) {
        return this.finishNode(node, 'ImportClause');
      }
    }
    if (this.test(Token.MUL)) {
      node.NameSpaceImport = this.parseNameSpaceImport();
    } else if (this.eat(Token.LBRACE)) {
      node.NamedImports = this.parseNamedImports();
    } else {
      this.unexpected();
    }
    return this.finishNode(node, 'ImportClause');
  }

  // ImportedDefaultBinding :
  //   ImportedBinding
  parseImportedDefaultBinding() {
    const node = this.startNode();
    node.ImportedBinding = this.parseBindingIdentifier();
    return this.finishNode(node, 'ImportedDefaultBinding');
  }

  // NameSpaceImport :
  //   `*` `as` ImportedBinding
  parseNameSpaceImport() {
    const node = this.startNode();
    this.expect(Token.MUL);
    this.expect('as');
    node.ImportedBinding = this.parseBindingIdentifier();
    return this.finishNode(node, 'NameSpaceImport');
  }

  // NamedImports :
  //   `{` `}`
  //   `{` ImportsList `}`
  //   `{` ImportsList `,` `}`
  parseNamedImports() {
    const node = this.startNode();
    const ImportsList = [];
    node.ImportsList = ImportsList;
    while (!this.eat(Token.RBRACE)) {
      ImportsList.push(this.parseImportSpecifier());
      if (this.eat(Token.RBRACE)) {
        break;
      }
      this.expect(Token.COMMA);
    }
    return this.finishNode(node, 'NamedImports');
  }

  // ImportSpecifier :
  //   ImportedBinding
  //   ModuleExportName `as` ImportedBinding
  parseImportSpecifier() {
    const node = this.startNode();
    const name = this.parseModuleExportName();
    if (name.type === 'StringLiteral' || this.test('as')) {
      this.expect('as');
      node.ModuleExportName = name;
      node.ImportedBinding = this.parseBindingIdentifier();
    } else {
      node.ImportedBinding = this.repurpose(name, 'BindingIdentifier');
      if (isKeywordRaw(node.ImportedBinding.name)) {
        this.raiseEarly('UnexpectedToken', node.ImportedBinding);
      }
      if (node.ImportedBinding.name === 'eval' || node.ImportedBinding.name === 'arguments') {
        this.raiseEarly('UnexpectedToken', node.ImportedBinding);
      }
    }
    return this.finishNode(node, 'ImportSpecifier');
  }

  // ExportDeclaration :
  //   `export` ExportFromClause FromClause `;`
  //   `export` NamedExports `;`
  //   `export` VariableStatement
  //   `export` Declaration
  //   `export` `default` HoistableDeclaration
  //   `export` `default` ClassDeclaration
  //   `export` `default` AssignmentExpression `;`
  //
  // ExportFromClause :
  //   `*`
  //   `*` as ModuleExportName
  //   NamedExports
  parseExportDeclaration() {
    const node = this.startNode();
    this.expect(Token.EXPORT);
    node.default = this.eat(Token.DEFAULT);
    if (node.default) {
      switch (this.peek().type) {
        case Token.FUNCTION:
          node.HoistableDeclaration = this.scope.with({
            default: true
          }, () => this.parseFunctionDeclaration(FunctionKind.NORMAL));
          break;
        case Token.CLASS:
          node.ClassDeclaration = this.scope.with({
            default: true
          }, () => this.parseClassDeclaration());
          break;
        default:
          if (this.test('async') && this.testAhead(Token.FUNCTION) && !this.peekAhead().hadLineTerminatorBefore) {
            node.HoistableDeclaration = this.scope.with({
              default: true
            }, () => this.parseFunctionDeclaration(FunctionKind.ASYNC));
          } else {
            node.AssignmentExpression = this.parseAssignmentExpression();
            this.semicolon();
          }
          break;
      }
      if (this.scope.exports.has('default')) {
        this.raiseEarly('AlreadyDeclared', node, 'default');
      } else {
        this.scope.exports.add('default');
      }
    } else {
      switch (this.peek().type) {
        case Token.CONST:
          node.Declaration = this.parseLexicalDeclaration();
          this.scope.declare(node.Declaration, 'export');
          break;
        case Token.CLASS:
          node.Declaration = this.parseClassDeclaration();
          this.scope.declare(node.Declaration, 'export');
          break;
        case Token.FUNCTION:
          node.Declaration = this.parseHoistableDeclaration();
          this.scope.declare(node.Declaration, 'export');
          break;
        case Token.VAR:
          node.VariableStatement = this.parseVariableStatement();
          this.scope.declare(node.VariableStatement, 'export');
          break;
        case Token.LBRACE:
          {
            const NamedExports = this.parseNamedExports();
            if (this.test('from')) {
              node.ExportFromClause = NamedExports;
              node.FromClause = this.parseFromClause();
              if (this.test(Token.WITH)) {
                node.WithClause = this.parseWithClause();
              }
            } else {
              NamedExports.ExportsList.forEach(n => {
                if (n.localName.type === 'StringLiteral') {
                  this.raiseEarly('UnexpectedToken', n.localName);
                }
              });
              node.NamedExports = NamedExports;
              this.scope.checkUndefinedExports(node.NamedExports);
            }
            this.semicolon();
            break;
          }
        case Token.MUL:
          {
            const inner = this.startNode();
            this.next();
            if (this.eat('as')) {
              inner.ModuleExportName = this.parseModuleExportName();
              this.scope.declare(inner.ModuleExportName, 'export');
            }
            node.ExportFromClause = this.finishNode(inner, 'ExportFromClause');
            node.FromClause = this.parseFromClause();
            if (this.test(Token.WITH)) {
              node.WithClause = this.parseWithClause();
            }
            this.semicolon();
            break;
          }
        default:
          if (this.test('let')) {
            node.Declaration = this.parseLexicalDeclaration();
            this.scope.declare(node.Declaration, 'export');
          } else if (this.test('async') && this.testAhead(Token.FUNCTION) && !this.peekAhead().hadLineTerminatorBefore) {
            node.Declaration = this.parseHoistableDeclaration();
            this.scope.declare(node.Declaration, 'export');
          } else {
            this.unexpected();
          }
      }
    }
    return this.finishNode(node, 'ExportDeclaration');
  }

  // NamedExports :
  //   `{` `}`
  //   `{` ExportsList `}`
  //   `{` ExportsList `,` `}`
  parseNamedExports() {
    const node = this.startNode();
    this.expect(Token.LBRACE);
    const ExportsList = [];
    node.ExportsList = ExportsList;
    while (!this.eat(Token.RBRACE)) {
      ExportsList.push(this.parseExportSpecifier());
      if (this.eat(Token.RBRACE)) {
        break;
      }
      this.expect(Token.COMMA);
    }
    return this.finishNode(node, 'NamedExports');
  }

  // ExportSpecifier :
  //   ModuleExportName
  //   ModuleExportName `as` ModuleExportName
  parseExportSpecifier() {
    const node = this.startNode();
    node.localName = this.parseModuleExportName();
    if (this.eat('as')) {
      node.exportName = this.parseModuleExportName();
    } else {
      node.exportName = node.localName;
    }
    this.scope.declare(node.exportName, 'export');
    return this.finishNode(node, 'ExportSpecifier');
  }

  // ModuleExportName :
  //   IdentifierName
  //   StringLiteral
  parseModuleExportName() {
    if (this.test(Token.STRING)) {
      const literal = this.parseStringLiteral();
      if (!IsStringWellFormedUnicode(StringValue(literal))) {
        this.raiseEarly('ModuleExportNameInvalidUnicode', literal);
      }
      return literal;
    }
    return this.parseIdentifierName();
  }

  // FromClause :
  //   `from` ModuleSpecifier
  parseFromClause() {
    this.expect('from');
    return this.parseStringLiteral();
  }

  // WithClause :
  //   `with` `{` `}`
  //   `with` `{` WithEntries `,`? `}`
  parseWithClause() {
    const node = this.startNode();
    this.expect(Token.WITH);
    this.expect(Token.LBRACE);
    const seenKeys = new Set();
    const WithEntries = [];
    while (!this.eat(Token.RBRACE)) {
      const entry = this.parseWithEntry();
      const key = StringValue(entry.AttributeKey).value;
      if (seenKeys.has(key)) {
        this.raiseEarly('DuplicateImportAttribute', entry, key);
      }
      seenKeys.add(key);
      WithEntries.push(entry);
      if (this.eat(Token.RBRACE)) {
        break;
      }
      this.expect(Token.COMMA);
    }
    node.WithEntries = WithEntries;
    return this.finishNode(node, 'WithClause');
  }
  parseWithEntry() {
    const node = this.startNode();
    node.AttributeKey = this.test(Token.STRING) ? this.parseStringLiteral() : this.parseIdentifierName();
    this.expect(Token.COLON);
    node.AttributeValue = this.parseStringLiteral();
    return this.finishNode(node, 'WithEntry');
  }
}

class LanguageParser extends ModuleParser {
  // Script : ScriptBody?
  parseScript() {
    this.skipHashbangComment();
    const node = this.startNode();
    if (this.eat(Token.EOS)) {
      node.ScriptBody = null;
    } else {
      node.ScriptBody = this.parseScriptBody();
    }
    node.sourceText = () => this.source;
    return this.finishNode(node, 'Script');
  }

  // ScriptBody : StatementList
  parseScriptBody() {
    const node = this.startNode();
    this.scope.with({
      in: true,
      lexical: true,
      variable: true,
      variableFunctions: true
    }, () => {
      const directives = [];
      node.StatementList = this.parseStatementList(Token.EOS, directives);
      node.strict = directives.includes('use strict');
    });
    node.sourceText = () => this.source;
    return this.finishNode(node, 'ScriptBody');
  }

  // Module : ModuleBody?
  parseModule() {
    this.skipHashbangComment();
    return this.scope.with({
      module: true,
      strict: true,
      in: true,
      importMeta: true,
      await: true,
      lexical: true,
      variable: true
    }, () => {
      const node = this.startNode();
      if (this.eat(Token.EOS)) {
        node.ModuleBody = null;
      } else {
        node.ModuleBody = this.parseModuleBody();
      }
      this.scope.undefinedExports.forEach((importNode, name) => {
        this.raiseEarly('ModuleUndefinedExport', importNode, name);
      });
      node.hasTopLevelAwait = this.state.hasTopLevelAwait;
      node.sourceText = () => this.source;
      return this.finishNode(node, 'Module');
    });
  }

  // ModuleBody :
  //   ModuleItemList
  parseModuleBody() {
    const node = this.startNode();
    node.ModuleItemList = this.parseModuleItemList();
    node.sourceText = () => this.source;
    return this.finishNode(node, 'ModuleBody');
  }

  // ModuleItemList :
  //   ModuleItem
  //   ModuleItemList ModuleItem
  //
  // ModuleItem :
  //   ImportDeclaration
  //   ExportDeclaration
  //   StatementListItem
  parseModuleItemList() {
    const moduleItemList = [];
    while (!this.eat(Token.EOS)) {
      switch (this.peek().type) {
        case Token.IMPORT:
          moduleItemList.push(this.parseImportDeclaration());
          break;
        case Token.EXPORT:
          moduleItemList.push(this.parseExportDeclaration());
          break;
        default:
          moduleItemList.push(this.parseStatementListItem());
          break;
      }
    }
    return moduleItemList;
  }
}

class Parser extends LanguageParser {
  source;
  specifier;
  earlyErrors;
  state;
  scope = new Scope(this);
  constructor({
    source,
    specifier,
    json = false,
    allowAllPrivateNames = false
  }) {
    super();
    this.source = source;
    this.specifier = specifier;
    this.earlyErrors = new Set();
    this.state = {
      hasTopLevelAwait: false,
      strict: false,
      json,
      allowAllPrivateNames
    };
  }
  isStrictMode() {
    return this.state.strict;
  }
  feature(name) {
    return surroundingAgent.feature(name);
  }
  startNode(inheritStart) {
    this.peek();
    const node = {
      type: undefined,
      parent: undefined,
      location: {
        startIndex: inheritStart ? inheritStart.location.startIndex : this.peekToken.startIndex,
        endIndex: -1,
        start: inheritStart ? {
          ...inheritStart.location.start
        } : {
          line: this.peekToken.line,
          column: this.peekToken.column
        },
        end: {
          line: -1,
          column: -1
        }
      },
      strict: this.state.strict,
      sourceText: () => this.source.slice(node.location.startIndex, node.location.endIndex)
    };
    return node;
  }
  markNodeStart(node) {
    node.location.startIndex = this.peekToken.startIndex;
    node.location.start = {
      line: this.peekToken.line,
      column: this.peekToken.column
    };
  }
  finishNode(node, type) {
    node.type = type;
    node.location.endIndex = this.currentToken.endIndex;
    node.location.end.line = this.currentToken.line;
    node.location.end.column = this.currentToken.column;
    return node;
  }
  createSyntaxError(context = this.peek(), template, templateArgs) {
    if (template === 'UnexpectedToken' && typeof context !== 'number' && 'type' in context && context.type === Token.EOS) {
      return this.createSyntaxError(context, 'UnexpectedEOS', []);
    }
    let startIndex;
    let endIndex;
    let line;
    let column;
    if (typeof context === 'number') {
      line = this.line;
      if (context === this.source.length) {
        while (isLineTerminator(this.source[context - 1])) {
          line -= 1;
          context -= 1;
        }
      }
      startIndex = context;
      endIndex = context + 1;
    } else if ('type' in context && context.type === Token.EOS) {
      line = this.line;
      startIndex = context.startIndex;
      while (isLineTerminator(this.source[startIndex - 1])) {
        line -= 1;
        startIndex -= 1;
      }
      endIndex = startIndex + 1;
    } else {
      if ('location' in context && context.location) {
        context = context.location;
      }
      ({
        startIndex,
        endIndex,
        start: {
          line,
          column
        } = context // NOTE: unsound cast
      } = context); // NOTE: unsound cast
    }

    /*
     * Source looks like:
     *
     *  const a = 1;
     *  const b 'string string string'; // a string
     *  const c = 3;                  |            |
     *  |       |                     |            |
     *  |       | startIndex          | endIndex   |
     *  | lineStart                                | lineEnd
     *
     * Exception looks like:
     *
     *  const b 'string string string'; // a string
     *          ^^^^^^^^^^^^^^^^^^^^^^
     *  SyntaxError: unexpected token
    */

    let lineStart = startIndex;
    while (!isLineTerminator(this.source[lineStart - 1]) && this.source[lineStart - 1] !== undefined) {
      lineStart -= 1;
    }
    let lineEnd = startIndex;
    while (!isLineTerminator(this.source[lineEnd]) && this.source[lineEnd] !== undefined) {
      lineEnd += 1;
    }
    if (column === undefined) {
      column = startIndex - lineStart + 1;
    }
    const message = messages[template];
    const e = new SyntaxError(message(...templateArgs));
    e.decoration = `\
${this.specifier ? `${this.specifier}:${line}:${column}\n` : ''}${this.source.slice(lineStart, lineEnd)}
${' '.repeat(startIndex - lineStart)}${'^'.repeat(Math.max(endIndex - startIndex, 1))}`;
    return e;
  }
  raiseEarly(template, context, ...templateArgs) {
    const e = this.createSyntaxError(context, template, templateArgs);
    this.earlyErrors.add(e);
    return e;
  }
  raise(template, context, ...templateArgs) {
    const e = this.createSyntaxError(context, template, templateArgs);
    throw e;
  }
  unexpected(...args) {
    return this.raise('UnexpectedToken', ...args);
  }
}

function handleError(e) {
  if (e instanceof SyntaxError) {
    const v = surroundingAgent.Throw('SyntaxError', 'Raw', e.message).Value;
    if (e.decoration) {
      const stackString = Value('stack');
      /* X */
      let _temp = Get(v, stackString);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! Get(v, stackString) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      const stack = _temp;
      // Note: in many cases the output will be padded by space or text like "Uncaught",
      // insert a new line allow decoration lines get the same padding.
      const newStackString = `\n${e.decoration}\n${stack instanceof JSStringValue ? stack.stringValue() : ''}`;
      /* X */
      let _temp2 = Set$1(v, stackString, Value(newStackString), Value.true);
      /* node:coverage ignore next */
      if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! Set(v, stackString, Value(newStackString), Value.true) returned an abrupt completion", {
        cause: _temp2
      });
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    }
    return v;
  } else {
    throw e;
  }
}
function wrappedParse(init, f) {
  const p = new Parser(init);
  try {
    const r = f(p);
    if (p.earlyErrors.size > 0) {
      return [...p.earlyErrors].map(e => handleError(e));
    }
    return r;
  } catch (e) {
    return [handleError(e)];
  }
}
class ScriptRecord {
  Realm;
  ECMAScriptCode;
  LoadedModules;
  HostDefined;
  mark(m) {
    m(this.Realm);
  }
  constructor(record) {
    this.ECMAScriptCode = record.ECMAScriptCode;
    this.Realm = record.Realm;
    this.LoadedModules = record.LoadedModules;
    this.HostDefined = record.HostDefined;
  }
}
function ParseScript(sourceText, realm, hostDefined = {}) {
  // 1. Assert: sourceText is an ECMAScript source text (see clause 10).
  // 2. Parse sourceText using Script as the goal symbol and analyse the parse result for
  //    any Early Error conditions. If the parse was successful and no early errors were found,
  //    let body be the resulting parse tree. Otherwise, let body be a List of one or more
  //    SyntaxError objects representing the parsing errors and/or early errors. Parsing and
  //    early error detection may be interweaved in an implementation-dependent manner. If more
  //    than one parsing error or early error is present, the number and ordering of error
  //    objects in the list is implementation-dependent, but at least one must be present.
  const body = wrappedParse({
    source: sourceText,
    specifier: hostDefined.specifier,
    json: hostDefined[kInternal]?.json,
    allowAllPrivateNames: hostDefined[kInternal]?.allowAllPrivateNames
  }, p => p.parseScript());
  // 3. If body is a List of errors, return body.
  if (Array.isArray(body)) {
    return body;
  }
  setNodeParent(body, undefined);
  // 4. Return Script Record { [[Realm]]: realm, [[ECMAScriptCode]]: body, [[HostDefined]]: hostDefined }.
  const script = new ScriptRecord({
    Realm: realm,
    ECMAScriptCode: body,
    LoadedModules: [],
    HostDefined: hostDefined
  });
  if (!hostDefined.doNotTrackScriptId) {
    surroundingAgent.addParsedSource(script);
  }
  return script;
}
function ParseModule(sourceText, realm, hostDefined = {}) {
  // 1. Assert: sourceText is an ECMAScript source text (see clause 10).
  // 2. Parse sourceText using Module as the goal symbol and analyse the parse result for
  //    any Early Error conditions. If the parse was successful and no early errors were found,
  //    let body be the resulting parse tree. Otherwise, let body be a List of one or more
  //    SyntaxError objects representing the parsing errors and/or early errors. Parsing and
  //    early error detection may be interweaved in an implementation-dependent manner. If more
  //    than one parsing error or early error is present, the number and ordering of error
  //    objects in the list is implementation-dependent, but at least one must be present.
  const body = wrappedParse({
    source: sourceText,
    specifier: hostDefined.specifier
  }, p => p.parseModule());
  // 3. If body is a List of errors, return body.
  if (Array.isArray(body)) {
    return body;
  }
  setNodeParent(body, undefined);
  // 4. Let requestedModules be the ModuleRequests of body.
  const requestedModules = ModuleRequests(body);
  // 5. Let importEntries be ImportEntries of body.
  const importEntries = ImportEntries(body);
  // 6. Let importedBoundNames be ImportedLocalNames(importEntries).
  const importedBoundNames = new JSStringSet(ImportedLocalNames(importEntries));
  // 7. Let indirectExportEntries be a new empty List.
  const indirectExportEntries = [];
  // 8. Let localExportEntries be a new empty List.
  const localExportEntries = [];
  // 9. Let starExportEntries be a new empty List.
  const starExportEntries = [];
  // 10. Let exportEntries be ExportEntries of body.
  const exportEntries = ExportEntries(body);
  // 11. For each ExportEntry Record ee in exportEntries, do
  for (const ee of exportEntries) {
    // a. If ee.[[ModuleRequest]] is null, then
    if (ee.ModuleRequest === Value.null) {
      // i. If ee.[[LocalName]] is not an element of importedBoundNames, then
      if (!importedBoundNames.has(ee.LocalName)) {
        // 1. Append ee to localExportEntries.
        localExportEntries.push(ee);
      } else {
        // ii. Else,
        // 1. Let ie be the element of importEntries whose [[LocalName]] is the same as ee.[[LocalName]].
        const ie = importEntries.find(e => e.LocalName.stringValue() === ee.LocalName.stringValue());
        // 2. If ie.[[ImportName]] is ~namespace-object~, then
        if (ie.ImportName === 'namespace-object') {
          // a. NOTE: This is a re-export of an imported module namespace object.
          // b. Append ee to localExportEntries.
          localExportEntries.push(ee);
        } else {
          // 3. Else,
          // a. NOTE: This is a re-export of a single name.
          // b. Append the ExportEntry Record { [[ModuleRequest]]: ie.[[ModuleRequest]], [[ImportName]]: ie.[[ImportName]], [[LocalName]]: null, [[ExportName]]: ee.[[ExportName]] } to indirectExportEntries.
          indirectExportEntries.push({
            ModuleRequest: ie.ModuleRequest,
            ImportName: ie.ImportName,
            LocalName: Value.null,
            ExportName: ee.ExportName
          });
        }
      }
    } else if (ee.ImportName && ee.ImportName === 'all-but-default' && ee.ExportName === Value.null) {
      // b. Else if ee.[[ImportName]] is ~all-but-default~ and ee.[[ExportName]] is null, then
      // i. Append ee to starExportEntries.
      starExportEntries.push(ee);
    } else {
      // c. Else,
      // i. Append ee to indirectExportEntries.
      indirectExportEntries.push(ee);
    }
  }
  // 12. Return Source Text Module Record { [[Realm]]: realm, [[Environment]]: undefined, [[Namespace]]: undefined, [[Status]]: unlinked, [[EvaluationError]]: undefined, [[HostDefined]]: hostDefined, [[ECMAScriptCode]]: body, [[Context]]: empty, [[ImportMeta]]: empty, [[RequestedModules]]: requestedModules, [[ImportEntries]]: importEntries, [[LocalExportEntries]]: localExportEntries, [[IndirectExportEntries]]: indirectExportEntries, [[StarExportEntries]]: starExportEntries, [[DFSIndex]]: undefined, [[DFSAncestorIndex]]: undefined }.
  const module = new (hostDefined.SourceTextModuleRecord || SourceTextModuleRecord)({
    Realm: realm,
    Environment: undefined,
    Namespace: Value.undefined,
    Status: 'new',
    EvaluationError: undefined,
    HostDefined: hostDefined,
    ECMAScriptCode: body,
    Context: undefined,
    ImportMeta: undefined,
    RequestedModules: requestedModules,
    LoadedModules: [],
    ImportEntries: importEntries,
    LocalExportEntries: localExportEntries,
    IndirectExportEntries: indirectExportEntries,
    StarExportEntries: starExportEntries,
    CycleRoot: undefined,
    HasTLA: body.hasTopLevelAwait ? Value.true : Value.false,
    AsyncEvaluationOrder: 'unset',
    TopLevelCapability: undefined,
    AsyncParentModules: [],
    DFSIndex: undefined,
    DFSAncestorIndex: undefined,
    PendingAsyncDependencies: undefined
  });
  if (!hostDefined.doNotTrackScriptId) {
    surroundingAgent.addParsedSource(module);
  }
  return module;
}

/** https://tc39.es/ecma262/#sec-parsejsonmodule */
function ParseJSONModule(sourceText, realm, hostDefined) {
  // 1. Let jsonParse be realm's intrinsic object named "%JSON.parse%".
  const jsonParse = realm.Intrinsics['%JSON.parse%'];
  // 1. Let json be ? Call(jsonParse, undefined, « sourceText »).
  /* ReturnIfAbrupt */
  let _temp3 = skipDebugger(Call(jsonParse, Value.undefined, [sourceText]));
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const json = _temp3;
  // 1. Return CreateDefaultExportSyntheticModule(json, realm, hostDefined).
  return CreateDefaultExportSyntheticModule(json, realm, hostDefined);
}
ParseJSONModule.section = 'https://tc39.es/ecma262/#sec-parsejsonmodule';
function setNodeParent(node, parent) {
  node.parent = parent;
  for (const i in node) {
    if (Object.hasOwn(node, i)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const value = node[i];
      if (isArray(value)) {
        value.forEach(val => {
          if (isParseNode(val) && !val.parent) {
            setNodeParent(val, node);
          }
        });
      } else if (isParseNode(value) && !value.parent) {
        setNodeParent(value, node);
      }
    }
  }
}
function isParseNode(value) {
  return !!(value && typeof value === 'object' && 'type' in value && 'location' in value);
}

/** https://tc39.es/ecma262/#sec-parsepattern */
function ParsePattern(patternText, u, v) {
  const parse = flags => {
    try {
      const p = new RegExpParser(patternText);
      return p.scope(flags, () => p.parsePattern());
    } catch (e) {
      return [handleError(e)];
    }
  };
  if (v && u) {
    return [surroundingAgent.NewError('SyntaxError', 'RegExpFlagsCannotUseTogether', 'v', 'u')];
  } else if (v) {
    return parse({
      UnicodeMode: true,
      UnicodeSetsMode: true,
      NamedCaptureGroups: true
    });
  } else if (u) {
    return parse({
      UnicodeMode: true,
      NamedCaptureGroups: true
    });
  } else {
    return parse({
      NamedCaptureGroups: true
    });
  }
}
ParsePattern.section = 'https://tc39.es/ecma262/#sec-parsepattern';

// #table-dynamic-function-sourcetext-prefixes
const DynamicFunctionSourceTextPrefixes = {
  'normal': 'function',
  'generator': 'function*',
  'async': 'async function',
  'asyncGenerator': 'async function*'
};
function* CreateDynamicFunction(constructor, newTarget, kind, args) {
  // 1. Assert: The execution context stack has at least two elements.
  Assert(surroundingAgent.executionContextStack.length >= 2, "surroundingAgent.executionContextStack.length >= 2");
  // 2. Let callerContext be the second to top element of the execution context stack.
  const callerContext = surroundingAgent.executionContextStack[surroundingAgent.executionContextStack.length - 2];
  // 3. Let callerRealm be callerContext's Realm.
  const callerRealm = callerContext.Realm;
  // 4. Let calleeRealm be the current Realm Record.
  const calleeRealm = surroundingAgent.currentRealmRecord;
  // 5. Perform ? HostEnsureCanCompileStrings(callerRealm, calleeRealm).
  /* ReturnIfAbrupt */
  let _temp = HostEnsureCanCompileStrings(callerRealm, calleeRealm);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 6. If newTarget is undefined, set newTarget to constructor.
  if (newTarget instanceof UndefinedValue) {
    newTarget = constructor;
  }
  // 7. If kind is normal, then
  let fallbackProto;
  if (kind === 'normal') {
    // a. Let goal be the grammar symbol FunctionBody[~Yield, ~Await].
    // b. Let parameterGoal be the grammar symbol FormalParameters[~Yield, ~Await].
    // c. Let fallbackProto be "%Function.prototype%".
    fallbackProto = '%Function.prototype%';
  } else if (kind === 'generator') {
    // 8. Else if kind is generator, then
    // a. Let goal be the grammar symbol GeneratorBody.
    // b. Let parameterGoal be the grammar symbol FormalParameters[+Yield, ~Await].
    // c. Let fallbackProto be "%GeneratorFunction.prototype%".
    fallbackProto = '%GeneratorFunction.prototype%';
  } else if (kind === 'async') {
    // 9. Else if kind is async, then
    // a. Let goal be the grammar symbol AsyncBody.
    // b. Let parameterGoal be the grammar symbol FormalParameters[~Yield, +Await].
    // c. Let fallbackProto be "%AsyncFunction.prototype%".
    fallbackProto = '%AsyncFunction.prototype%';
  } else {
    // 10. Else,
    // a. Assert: kind is asyncGenerator.
    Assert(kind === 'asyncGenerator', "kind === 'asyncGenerator'");
    // b. Let goal be the grammar symbol AsyncGeneratorBody.
    // c. Let parameterGoal be the grammar symbol FormalParameters[+Yield, +Await].
    // d. Let fallbackProto be "%AsyncGeneratorFunction.prototype%".
    fallbackProto = '%AsyncGeneratorFunction.prototype%';
  }
  // 11. Let argCount be the number of elements in args.
  const argCount = args.length;
  // 12. Let P be the empty String.
  let P = '';
  // 13. If argCount = 0, let bodyArg be the empty String.
  let bodyArg;
  if (argCount === 0) {
    bodyArg = Value('');
  } else if (argCount === 1) {
    // 14. Else if argCount = 1, let bodyArg be args[0].
    bodyArg = args[0];
  } else {
    // 15. Else,
    // a. Assert: argCount > 1.
    Assert(argCount > 1, "argCount > 1");
    // b. Let firstArg be args[0].
    const firstArg = args[0];
    // c. Set P to ? ToString(firstArg).
    /* ReturnIfAbrupt */
    let _temp2 = yield* ToString(firstArg);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    P = _temp2.stringValue();
    // d. Let k be 1.
    let k = 1;
    // e. Repeat, while k < argCount - 1
    while (k < argCount - 1) {
      // i. Let nextArg be args[k].
      const nextArg = args[k];
      // ii. Let nextArgString be ? ToString(nextArg).
      /* ReturnIfAbrupt */
      let _temp3 = yield* ToString(nextArg);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      const nextArgString = _temp3;
      // iii. Set P to the string-concatenation of the previous value of P, "," (a comma), and nextArgString.
      P = `${P},${nextArgString.stringValue()}`;
      // iv. Set k to k + 1.
      k += 1;
    }
    // f. Let bodyArg be args[k].
    bodyArg = args[k];
  }
  // 16. Let bodyString be the string-concatenation of 0x000A (LINE FEED), ? ToString(bodyArg), and 0x000A (LINE FEED).
  /* ReturnIfAbrupt */
  let _temp4 = yield* ToString(bodyArg);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const bodyString = `\u{000A}${_temp4.stringValue()}\u{000A}`;
  // 17. Let prefix be the prefix associated with kind in Table 48.
  const prefix = DynamicFunctionSourceTextPrefixes[kind];
  // 18. Let sourceString be the string-concatenation of prefix, " anonymous(", P, 0x000A (LINE FEED), ") {", bodyString, and "}".
  const sourceString = `${prefix} anonymous(${P}\u{000A}) {${bodyString}}`;
  // 19. Let sourceText be ! UTF16DecodeString(sourceString).
  const sourceText = sourceString;
  // 20. Perform the following substeps in an implementation-dependent order, possibly interleaving parsing and error detection:
  //   a. Let parameters be the result of parsing ! UTF16DecodeString(P), using parameterGoal as the goal symbol. Throw a SyntaxError exception if the parse fails.
  //   b. Let body be the result of parsing ! UTF16DecodeString(bodyString), using goal as the goal symbol. Throw a SyntaxError exception if the parse fails.
  //   c. Let strict be ContainsUseStrict of body.
  //   d. If any static semantics errors are detected for parameters or body, throw a SyntaxError exception. If strict is true, the Early Error rules for UniqueFormalParameters:FormalParameters are applied.
  //   e. If strict is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.
  //   f. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.
  //   g. If body Contains SuperCall is true, throw a SyntaxError exception.
  //   h. If parameters Contains SuperCall is true, throw a SyntaxError exception.
  //   i. If body Contains SuperProperty is true, throw a SyntaxError exception.
  //   j. If parameters Contains SuperProperty is true, throw a SyntaxError exception.
  //   k. If kind is generator or asyncGenerator, then
  //     i. If parameters Contains YieldExpression is true, throw a SyntaxError exception.
  //   l. If kind is async or asyncGenerator, then
  //     i. If parameters Contains AwaitExpression is true, throw a SyntaxError exception.
  //   m. If strict is true, then
  //     i. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.
  let parameters;
  let body;
  {
    const f = wrappedParse({
      source: sourceString
    }, p => {
      const r = p.parseExpression();
      p.expect(Token.EOS);
      return r;
    });
    if (Array.isArray(f)) {
      return ThrowCompletion(f[0]);
    }
    parameters = f.FormalParameters;
    switch (kind) {
      case 'normal':
        body = f.FunctionBody;
        break;
      case 'generator':
        body = f.GeneratorBody;
        break;
      case 'async':
        body = f.AsyncBody;
        break;
      case 'asyncGenerator':
        body = f.AsyncGeneratorBody;
        break;
      /* node:coverage ignore next */default:
        /* node:coverage ignore next */
        throw new OutOfRange$1('kind', kind);
    }
  }
  // 21. Let proto be ? GetPrototypeFromConstructor(newTarget, fallbackProto).
  /* ReturnIfAbrupt */
  let _temp5 = yield* GetPrototypeFromConstructor(newTarget, fallbackProto);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const proto = _temp5;
  // 22. Let realmF be the current Realm Record.
  const realmF = surroundingAgent.currentRealmRecord;
  // 23. Let scope be realmF.[[GlobalEnv]].
  const scope = realmF.GlobalEnv;
  // 24. Let F be ! OrdinaryFunctionCreate(proto, sourceText, parameters, body, non-lexical-this, scope, null).
  /* X */
  let _temp6 = OrdinaryFunctionCreate(proto, sourceText, parameters, body, 'non-lexical-this', scope, Value.null);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(proto, sourceText, parameters, body, 'non-lexical-this', scope, Value.null) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const F = _temp6;
  // 25. Perform SetFunctionName(F, "anonymous").
  SetFunctionName(F, Value('anonymous'));
  // 26. If kind is generator, then
  if (kind === 'generator') {
    // a. Let prototype be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
    const prototype = OrdinaryObjectCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype%'));
    // b. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
    /* X */
    let _temp7 = DefinePropertyOrThrow(F, Value('prototype'), _Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('prototype'), Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    })) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  } else if (kind === 'asyncGenerator') {
    // 27. Else if kind is asyncGenerator, then
    // a. Let prototype be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
    const prototype = OrdinaryObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype.prototype%'));
    // b. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
    /* X */
    let _temp8 = DefinePropertyOrThrow(F, Value('prototype'), _Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('prototype'), Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    })) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  } else if (kind === 'normal') {
    // 28. Else if kind is normal, then perform MakeConstructor(F).
    MakeConstructor(F);
  }
  // 29. NOTE: Functions whose kind is async are not constructible and do not have a [[Construct]] internal method or a "prototype" property.
  // 20. Return F.
  return F;
}

/** https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluation */
//   GeneratorExpression :
//     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
//     `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
function Evaluate_GeneratorExpression(GeneratorExpression) {
  // 1. Return InstantiateGeneratorFunctionExpression of GeneratorExpression.
  return InstantiateGeneratorFunctionExpression(GeneratorExpression);
}
Evaluate_GeneratorExpression.section = 'https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-evaluation */
function Evaluate_ArrowFunction(ArrowFunction) {
  // 1. Return InstantiateArrowFunctionExpression of ArrowFunction.
  return InstantiateArrowFunctionExpression(ArrowFunction);
}
Evaluate_ArrowFunction.section = 'https://tc39.es/ecma262/#sec-arrow-function-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-async-arrow-function-definitions-runtime-semantics-evaluation */
function Evaluate_AsyncArrowFunction(AsyncArrowFunction) {
  // 1. Return InstantiateAsyncArrowFunctionExpression of AsyncArrowFunction.
  return InstantiateAsyncArrowFunctionExpression(AsyncArrowFunction);
}
Evaluate_AsyncArrowFunction.section = 'https://tc39.es/ecma262/#sec-async-arrow-function-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-break-statement-runtime-semantics-evaluation */
//   BreakStatement :
//     `break` `;`
//     `break` LabelIdentifier `;`
function Evaluate_BreakStatement({
  LabelIdentifier
}) {
  if (!LabelIdentifier) {
    // 1. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.
    return new Completion({
      Type: 'break',
      Value: undefined,
      Target: undefined
    });
  }
  // 1. Let label be the StringValue of LabelIdentifier.
  const label = StringValue(LabelIdentifier);
  // 2. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: label }.
  return new Completion({
    Type: 'break',
    Value: undefined,
    Target: label
  });
}
Evaluate_BreakStatement.section = 'https://tc39.es/ecma262/#sec-break-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-asyncgenerator-definitions-evaluation */
//   AsyncGeneratorExpression :
//     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
//     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
function Evaluate_AsyncGeneratorExpression(AsyncGeneratorExpression) {
  // 1. Return InstantiateAsyncGeneratorFunctionExpression of AsyncGeneratorExpression.
  return InstantiateAsyncGeneratorFunctionExpression(AsyncGeneratorExpression);
}
Evaluate_AsyncGeneratorExpression.section = 'https://tc39.es/ecma262/#sec-asyncgenerator-definitions-evaluation';

/** https://tc39.es/ecma262/#sec-statement-semantics-runtime-semantics-evaluation */
//   HoistableDeclaration :
//     GeneratorDeclaration
//     AsyncFunctionDeclaration
//     AsyncGeneratorDeclaration
function Evaluate_HoistableDeclaration(_HoistableDeclaration) {
  // 1. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
Evaluate_HoistableDeclaration.section = 'https://tc39.es/ecma262/#sec-statement-semantics-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-comma-operator-runtime-semantics-evaluation */
//   Expression :
//     AssignmentExpression
//     Expression `,` AssignmentExpression
function* Evaluate_CommaOperator({
  ExpressionList
}) {
  let result;
  for (const Expression of ExpressionList) {
    /* ReturnIfAbrupt */
    let _temp = yield* Evaluate(Expression);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const lref = _temp;
    /* ReturnIfAbrupt */
    let _temp2 = yield* GetValue(lref);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    result = _temp2;
  }
  return result;
}
Evaluate_CommaOperator.section = 'https://tc39.es/ecma262/#sec-comma-operator-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluation */
//   YieldExpression :
//     `yield`
//     `yield` AssignmentExpression
//     `yield` `*` AssignmentExpression
function* Evaluate_YieldExpression({
  hasStar,
  AssignmentExpression
}) {
  if (hasStar) {
    // 1. Let generatorKind be GetGeneratorKind().
    const generatorKind = GetGeneratorKind();
    // 2. Assert: generatorKind is either sync or async.
    Assert(generatorKind === 'async' || generatorKind === 'sync', "generatorKind === 'async' || generatorKind === 'sync'");
    // 2. Let exprRef be ? Evaluation of AssignmentExpression.
    /* ReturnIfAbrupt */
    let _temp = yield* Evaluate(AssignmentExpression);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const exprRef = _temp;
    // 3. Let value be ? GetValue(exprRef).
    /* ReturnIfAbrupt */
    let _temp2 = yield* GetValue(exprRef);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    let value = _temp2;
    // 4. Let iteratorRecord be ? GetIterator(value, generatorKind).
    /* ReturnIfAbrupt */
    let _temp3 = yield* GetIterator(value, generatorKind);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const iteratorRecord = _temp3;
    // 5. Let iterator be iteratorRecord.[[Iterator]].
    const iterator = iteratorRecord.Iterator;
    // 6. Let received be NormalCompletion(undefined).
    let received = NormalCompletion(Value.undefined);
    // 7. Repeat,
    while (true) {
      // a. If received is a normal completion, then
      if (received instanceof NormalCompletion) {
        /* ReturnIfAbrupt */
        let _temp4 = yield* Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, [received.Value]);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        // i. Let innerResult be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « received.[[Value]] »).
        let innerResult = _temp4;
        // ii. If generatorKind is async, then set innerResult to ? Await(innerResult).
        if (generatorKind === 'async') {
          /* ReturnIfAbrupt */
          let _temp5 = yield* Await(innerResult);
          /* node:coverage ignore next */
          if (_temp5 instanceof AbruptCompletion) return _temp5;
          /* node:coverage ignore next */
          if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
          innerResult = _temp5;
        }
        // iii. If Type(innerResult) is not Object, throw a TypeError exception.
        if (!(innerResult instanceof ObjectValue)) {
          return surroundingAgent.Throw('TypeError', 'NotAnObject', innerResult);
        }
        // iv. Let done be ? IteratorComplete(innerResult).
        /* ReturnIfAbrupt */
        let _temp6 = yield* IteratorComplete(innerResult);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        const done = _temp6;
        // v. If done is true, then
        if (done === Value.true) {
          // 1. Return ? IteratorValue(innerResult).
          return yield* IteratorValue(innerResult);
        }
        // vi. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).
        if (generatorKind === 'async') {
          /* ReturnIfAbrupt */
          let _temp7 = yield* IteratorValue(innerResult);
          /* node:coverage ignore next */
          if (_temp7 instanceof AbruptCompletion) return _temp7;
          /* node:coverage ignore next */
          if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
          received = yield* AsyncGeneratorYield(_temp7);
        } else {
          // vii. Else, set received to GeneratorYield(innerResult).
          received = yield* GeneratorYield(innerResult);
        }
      } else if (received instanceof ThrowCompletion) {
        /* ReturnIfAbrupt */
        let _temp8 = yield* GetMethod(iterator, Value('throw'));
        /* node:coverage ignore next */
        if (_temp8 instanceof AbruptCompletion) return _temp8;
        /* node:coverage ignore next */
        if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        // b. Else if received is a throw completion, then
        // i. Let throw be ? GetMethod(iterator, "throw").
        const thr = _temp8;
        // ii. If throw is not undefined, then
        if (thr !== Value.undefined) {
          /* ReturnIfAbrupt */
          let _temp9 = yield* Call(thr, iterator, [received.Value]);
          /* node:coverage ignore next */
          if (_temp9 instanceof AbruptCompletion) return _temp9;
          /* node:coverage ignore next */
          if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
          // 1. Let innerResult be ? Call(throw, iterator, « received.[[Value]] »).
          let innerResult = _temp9;
          // 2. If generatorKind is async, then set innerResult to ? Await(innerResult).
          if (generatorKind === 'async') {
            /* ReturnIfAbrupt */
            let _temp10 = yield* Await(innerResult);
            /* node:coverage ignore next */
            if (_temp10 instanceof AbruptCompletion) return _temp10;
            /* node:coverage ignore next */
            if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
            innerResult = _temp10;
          }
          // 3. NOTE: Exceptions from the inner iterator throw method are propagated. Normal completions from an inner throw method are processed similarly to an inner next.
          // 4. If Type(innerResult) is not Object, throw a TypeError exception.
          if (!(innerResult instanceof ObjectValue)) {
            return surroundingAgent.Throw('TypeError', 'NotAnObject', innerResult);
          }
          // 5. Let done be ? IteratorComplete(innerResult).
          /* ReturnIfAbrupt */
          let _temp11 = yield* IteratorComplete(innerResult);
          /* node:coverage ignore next */
          if (_temp11 instanceof AbruptCompletion) return _temp11;
          /* node:coverage ignore next */
          if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
          const done = _temp11;
          // 6. If done is true, then
          if (done === Value.true) {
            // a. Return ? IteratorValue(innerResult).
            return yield* IteratorValue(innerResult);
          }
          // 7. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).
          if (generatorKind === 'async') {
            /* ReturnIfAbrupt */
            let _temp12 = yield* IteratorValue(innerResult);
            /* node:coverage ignore next */
            if (_temp12 instanceof AbruptCompletion) return _temp12;
            /* node:coverage ignore next */
            if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
            received = yield* AsyncGeneratorYield(_temp12);
          } else {
            // 8. Else, set received to GeneratorYield(innerResult).
            received = yield* GeneratorYield(innerResult);
          }
        } else {
          // iii. Else,
          // 1. NOTE: If iterator does not have a throw method, this throw is going to terminate the yield* loop. But first we need to give iterator a chance to clean up.
          // 2. Let closeCompletion be NormalCompletion(empty).
          const closeCompletion = NormalCompletion(undefined);
          // 3. If generatorKind is async, perform ? AsyncIteratorClose(iteratorRecord, closeCompletion).
          // 4. Else, perform ? IteratorClose(iteratorRecord, closeCompletion).
          if (generatorKind === 'async') {
            /* ReturnIfAbrupt */
            let _temp13 = yield* AsyncIteratorClose(iteratorRecord, closeCompletion);
            /* node:coverage ignore next */
            if (_temp13 instanceof AbruptCompletion) return _temp13;
            /* node:coverage ignore next */
            if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
          } else {
            /* ReturnIfAbrupt */
            let _temp14 = yield* IteratorClose(iteratorRecord, closeCompletion);
            /* node:coverage ignore next */
            if (_temp14 instanceof AbruptCompletion) return _temp14;
            /* node:coverage ignore next */
            if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
          }
          // 5. NOTE: The next step throws a TypeError to indicate that there was a yield* protocol violation: iterator does not have a throw method.
          // 6. Throw a TypeError exception.
          return surroundingAgent.Throw('TypeError', 'IteratorThrowMissing');
        }
      } else {
        // c. Else,
        // i. Assert: received is a return completion.
        Assert(received instanceof ReturnCompletion, "received instanceof ReturnCompletion");
        // ii. Let return be ? GetMethod(iterator, "return").
        /* ReturnIfAbrupt */
        let _temp15 = yield* GetMethod(iterator, Value('return'));
        /* node:coverage ignore next */
        if (_temp15 instanceof AbruptCompletion) return _temp15;
        /* node:coverage ignore next */
        if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
        const ret = _temp15;
        // iii. If return is undefined, then
        if (ret === Value.undefined) {
          // Set value to received.[[Value]].
          let value = received.Value;
          // 1. If generatorKind is async, then set received.[[Value]] to ? Await(received.[[Value]]).
          if (generatorKind === 'async') {
            /* ReturnIfAbrupt */
            let _temp16 = yield* Await(value);
            /* node:coverage ignore next */
            if (_temp16 instanceof AbruptCompletion) return _temp16;
            /* node:coverage ignore next */
            if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
            value = _temp16;
          }
          // 2. Return ReturnCompletion(value).
          return ReturnCompletion(value);
        }
        // iv. Let innerReturnResult be ? Call(return, iterator, « received.[[Value]] »).
        /* ReturnIfAbrupt */
        let _temp17 = yield* Call(ret, iterator, [received.Value]);
        /* node:coverage ignore next */
        if (_temp17 instanceof AbruptCompletion) return _temp17;
        /* node:coverage ignore next */
        if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
        let innerReturnResult = _temp17;
        // v. If generatorKind is async, then set innerReturnResult to ? Await(innerReturnResult).
        if (generatorKind === 'async') {
          /* ReturnIfAbrupt */
          let _temp18 = yield* Await(innerReturnResult);
          /* node:coverage ignore next */
          if (_temp18 instanceof AbruptCompletion) return _temp18;
          /* node:coverage ignore next */
          if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
          innerReturnResult = _temp18;
        }
        // vi. If Type(innerReturnResult) is not Object, throw a TypeError exception.
        if (!(innerReturnResult instanceof ObjectValue)) {
          return surroundingAgent.Throw('TypeError', 'NotAnObject', innerReturnResult);
        }
        // vii. Let done be ? IteratorComplete(innerReturnResult).
        /* ReturnIfAbrupt */
        let _temp19 = yield* IteratorComplete(innerReturnResult);
        /* node:coverage ignore next */
        if (_temp19 instanceof AbruptCompletion) return _temp19;
        /* node:coverage ignore next */
        if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
        const done = _temp19;
        // viii. If done is true, then
        if (done === Value.true) {
          /* ReturnIfAbrupt */
          let _temp20 = yield* IteratorValue(innerReturnResult);
          /* node:coverage ignore next */
          if (_temp20 instanceof AbruptCompletion) return _temp20;
          /* node:coverage ignore next */
          if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
          // 1. Set value to ? IteratorValue(innerReturnResult).
          value = _temp20;
          // 2. Return ReturnCompletion(value).
          return ReturnCompletion(value);
        }
        // ix. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).
        if (generatorKind === 'async') {
          /* ReturnIfAbrupt */
          let _temp21 = yield* IteratorValue(innerReturnResult);
          /* node:coverage ignore next */
          if (_temp21 instanceof AbruptCompletion) return _temp21;
          /* node:coverage ignore next */
          if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
          received = yield* AsyncGeneratorYield(_temp21);
        } else {
          // ixx. Else, set received to GeneratorYield(innerResult).
          received = yield* GeneratorYield(innerReturnResult);
        }
      }
    }
  }
  if (AssignmentExpression) {
    /* ReturnIfAbrupt */
    let _temp22 = yield* Evaluate(AssignmentExpression);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    // 1. Let exprRef be the result of evaluating AssignmentExpression.
    const exprRef = _temp22;
    // 2. Let value be ? GetValue(exprRef).
    /* ReturnIfAbrupt */
    let _temp23 = yield* GetValue(exprRef);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    const value = _temp23;
    // 3. Return ? Yield(value).
    return yield* Yield(value);
  }
  // 1. Return ? Yield(undefined).
  return yield* Yield(Value.undefined);
}
Evaluate_YieldExpression.section = 'https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluation';

// https://tc39.es/proposal-string-replaceall/#sec-stringindexof
function StringIndexOf(string, searchValue, fromIndex) {
  // 1. Assert: Type(string) is String.
  Assert(string instanceof JSStringValue, "string instanceof JSStringValue");
  // 2. Assert: Type(searchValue) is String.
  Assert(searchValue instanceof JSStringValue, "searchValue instanceof JSStringValue");
  // 3. Assert: fromIndex is a non-negative integer.
  Assert(isNonNegativeInteger(fromIndex), "isNonNegativeInteger(fromIndex)");
  const stringStr = string.stringValue();
  const searchStr = searchValue.stringValue();
  // 4. Let len be the length of string.
  const len = stringStr.length;
  // 5. If searchValue is the empty string, and fromIndex <= len, return 𝔽(fromIndex).
  if (searchStr === '' && fromIndex <= len) {
    return F(fromIndex);
  }
  // 6. Let searchLen be the length of searchValue.
  const searchLen = searchStr.length;
  // 7. If there exists any integer k such that fromIndex ≤ k ≤ len - searchLen and for all nonnegative integers j less than searchLen,
  //    the code unit at index k + j within string is the same as the code unit at index j within searchValue, let pos be the smallest (closest to -∞) such integer.
  //    Otherwise, let pos be -1.
  let k = fromIndex;
  let pos = -1;
  while (k + searchLen <= len) {
    let match = true;
    for (let j = 0; j < searchLen; j += 1) {
      if (searchStr[j] !== stringStr[k + j]) {
        match = false;
        break;
      }
    }
    if (match) {
      pos = k;
      break;
    }
    k += 1;
  }
  // 8. Return 𝔽(pos).
  return F(pos);
}
StringIndexOf.section = 'https://tc39.es/proposal-string-replaceall/#sec-stringindexof';

/** https://tc39.es/ecma262/#sec-numbertobigint */
function NumberToBigInt(number) {
  // 1. Assert: Type(number) is Number.
  Assert(number instanceof NumberValue, "number instanceof NumberValue");
  // 2. If IsIntegralNumber(number) is false, throw a RangeError exception.
  if (IsIntegralNumber(number) === Value.false) {
    return surroundingAgent.Throw('RangeError', 'CannotConvertDecimalToBigInt', number);
  }
  // 3. Return the BigInt value that represents the mathematical value of number.
  return Z(BigInt(R(number)));
}
NumberToBigInt.section = 'https://tc39.es/ecma262/#sec-numbertobigint';

/** https://tc39.es/ecma262/#sec-conditional-operator-runtime-semantics-evaluation */
//   ConditionalExpression :
//     ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression
function* Evaluate_ConditionalExpression({
  ShortCircuitExpression,
  AssignmentExpression_a,
  AssignmentExpression_b
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(ShortCircuitExpression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let lref be the result of evaluating ShortCircuitExpression.
  const lref = _temp;
  // 2. Let lval be ! ToBoolean(? GetValue(lref)).
  /* ReturnIfAbrupt */
  let _temp5 = yield* GetValue(lref);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  /* X */
  let _temp2 = ToBoolean(_temp5);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(Q(yield* GetValue(lref))) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const lval = _temp2;
  // 3. If lval is true, then
  if (lval === Value.true) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* Evaluate(AssignmentExpression_a);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // a. Let trueRef be the result of evaluating the first AssignmentExpression.
    const trueRef = _temp3;
    // b. Return ? GetValue(trueRef).
    return yield* GetValue(trueRef);
  } else {
    /* ReturnIfAbrupt */
    let _temp4 = yield* Evaluate(AssignmentExpression_b);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // 4. Else,
    // a. Let falseRef be the result of evaluating the second AssignmentExpression.
    const falseRef = _temp4;
    // b. Return ? GetValue(falseRef).
    return yield* GetValue(falseRef);
  }
}
Evaluate_ConditionalExpression.section = 'https://tc39.es/ecma262/#sec-conditional-operator-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-regular-expression-literals-runtime-semantics-evaluation */
//   RegularExpressionLiteral :
//     `/` RegularExpressionBody `/` RegularExpressionFlags
function* Evaluate_RegularExpressionLiteral(RegularExpressionLiteral) {
  // 1. Let pattern be ! UTF16Encode(BodyText of RegularExpressionLiteral).
  const pattern = Value(BodyText(RegularExpressionLiteral));
  // 2. Let flags be ! UTF16Encode(FlagText of RegularExpressionLiteral).
  const flags = Value(FlagText(RegularExpressionLiteral));
  // 3. Return RegExpCreate(pattern, flags).
  return yield* RegExpCreate(pattern, flags);
}
Evaluate_RegularExpressionLiteral.section = 'https://tc39.es/ecma262/#sec-regular-expression-literals-runtime-semantics-evaluation';

/* eslint-disable prefer-arrow-callback */
// use function name for better debug

var Direction = /*#__PURE__*/function (Direction) {
  Direction[Direction["Forward"] = 1] = "Forward";
  Direction[Direction["Backward"] = -1] = "Backward";
  return Direction;
}(Direction || {});
/** https://tc39.es/ecma262/#pattern-matchstate */
class MatchState {
  input;
  endIndex;
  captures;
  constructor(input, endIndex, captures) {
    this.input = input;
    this.endIndex = endIndex;
    this.captures = captures;
  }
  static createRegExpMatchingSource(input, raw) {
    input.raw = raw;
    return input;
  }
}

// Note: A strict spec implementation cannot pass test262 because of stack overflow. We use generator to lift all calls to the top level.

function runMatcher(matcher) {
  // when debug, uncomment to use this version might be easier.

  // if (1 + 1 === 2) {
  //   let next: MatcherResult;
  //   while (true) {
  //     const iter = iterator.next(next!);
  //     if (iter.done) {
  //       const ret = iter.value;
  //       return ret;
  //     }
  //     const nextCall = iter.value();
  //     const callResult = runMatcher(nextCall);
  //     next = callResult;
  //   }
  // }

  const stack = [];
  let next;
  while (true) {
    const iter = matcher.next(next);
    if (iter.done) {
      const ret = iter.value;
      // return ret;
      matcher = stack.pop();
      if (matcher) {
        // next = callResult (of upper call)
        next = ret;
        continue;
      } else {
        // outmost call
        return ret;
      }
    }
    const nextCall = iter.value();
    // const callResult = runMatcher(nextCall);
    stack.push(matcher);
    matcher = nextCall;
    next = undefined;
  }
}
/** https://tc39.es/ecma262/#pattern-matcher */

/** https://tc39.es/ecma262/#pattern-matchercontinuation */

/** https://tc39.es/ecma262/#pattern-charset */
class CharSet {
  getStrings() {
    return [...(this.strings || [])];
  }

  /**
   * Return false if the Pattern is compiled in UnicodeSetMode and contains the empty sequence or sequences of more than one character.
   */

  static union(...sets) {
    const unionChars = new Set();
    const unionStrings = new Set();
    let unionCharTesters = [];
    sets.forEach(set => {
      if (set.chars) {
        set.chars.forEach(c => unionChars.add(c));
      }
      if (set.strings) {
        set.strings.forEach(s => unionStrings.add(s));
      }
      if (set.charTester) {
        unionCharTesters = unionCharTesters.concat(set.charTester);
      }
    });
    if (!unionCharTesters.length) {
      if (!unionStrings.size) {
        return new ConcreteCharSet(unionChars);
      }
      if (!unionChars.size) {
        return ConcreteStringSet.of(unionStrings);
      }
    }
    if (!unionChars.size && !unionStrings.size && unionCharTesters.length === 1) {
      return new VirtualCharSet(unionCharTesters[0]);
    }
    return new UnionCharSet(unionChars, unionStrings, unionCharTesters);
  }
  static intersection(...sets) {
    let intersectionChars;
    const setChars = sets.filter(x => x.chars);
    if (setChars.length === 0) {
      intersectionChars = new Set();
    } else if (setChars.length === 1) {
      intersectionChars = setChars[0].chars;
    } else {
      const smallestSet = setChars.reduce((a, b) => a.chars.size < b.chars.size ? a : b);
      intersectionChars = new Set();
      smallestSet.chars.forEach(c => {
        if (setChars.every(s => s.chars.has(c))) {
          intersectionChars.add(c);
        }
      });
    }
    let intersectionStrings;
    const setStrings = sets.filter(x => x.strings);
    if (setStrings.length === 0) {
      intersectionStrings = new Set();
    } else if (setStrings.length === 1) {
      intersectionStrings = setStrings[0].strings;
    } else {
      const smallestSet = setStrings.reduce((a, b) => a.strings.size < b.strings.size ? a : b);
      intersectionStrings = new Set();
      smallestSet.strings.forEach(s => {
        if (setStrings.every(c => c.strings.has(s))) {
          intersectionStrings.add(s);
        }
      });
    }
    let allCharTesters = [];
    sets.forEach(set => {
      if (set.charTester) {
        allCharTesters = allCharTesters.concat(set.charTester);
      }
    });
    if (!allCharTesters.length) {
      if (!intersectionStrings.size) {
        return new ConcreteCharSet(intersectionChars);
      }
      if (!intersectionChars.size) {
        return ConcreteStringSet.of(intersectionStrings);
      }
      return new UnionCharSet(intersectionChars, intersectionStrings, undefined);
    }
    return new UnionCharSet(intersectionChars, intersectionStrings, allCharTesters.length ? [(char, canonicalize) => allCharTesters.every(f => f(char, canonicalize))] : undefined);
  }
  static subtract(maxSet, subtractAllStrings, ...subtracts) {
    const maxChars = maxSet.chars;
    const maxStrings = subtractAllStrings ? undefined : maxSet.strings;
    let allSubtractCharTesters = [];
    subtracts.forEach(subtract => {
      if (maxChars) {
        subtract.chars?.forEach(c => maxChars.delete(c));
      }
      if (maxStrings) {
        subtract.strings?.forEach(s => maxStrings.delete(s));
      }
      if (subtract.charTester) {
        allSubtractCharTesters = allSubtractCharTesters.concat(subtract.charTester);
      }
    });
    if (!maxSet.charTester?.length && !allSubtractCharTesters.length) {
      if (!maxStrings?.size) {
        return new ConcreteCharSet(maxChars || []);
      }
      if (!maxChars?.size) {
        return ConcreteStringSet.of(maxStrings);
      }
      return new UnionCharSet(maxChars, maxStrings, undefined);
    }
    return new UnionCharSet(undefined, maxStrings, [(char, canonicalize) => {
      if (!(maxChars?.has(char) || maxSet.charTester?.some(f => f(char, canonicalize)))) {
        return false;
      }
      if (allSubtractCharTesters.some(f => f(char, canonicalize))) {
        return false;
      }
      return true;
    }]);
  }
}
class VirtualCharSet extends CharSet {
  #f;
  charTester;
  constructor(f) {
    super();
    this.#f = f;
    this.charTester = [f];
  }
  has(c, rer) {
    return this.#f(c, rer);
  }
  hasList(_c) {
    return false;
  }
  characterModeOnly = true;
}
class ConcreteCharSet extends CharSet {
  chars;
  #canonicalize;
  get debuggerGetCodePoints() {
    return [...this.chars].map(char => Unicode.toCodePoint(char));
  }
  constructor(chars) {
    super();
    this.chars = new Set(chars);
  }
  has(c, rer) {
    const canonicalizeKey = JSON.stringify(rer);
    this.#canonicalize ??= {};
    if (!this.#canonicalize[canonicalizeKey]) {
      this.#canonicalize[canonicalizeKey] = new Set();
      const set = this.#canonicalize[canonicalizeKey];
      for (const c of this.chars) {
        const ch = Canonicalize(rer, c);
        set.add(ch);
      }
    }
    return this.#canonicalize[canonicalizeKey].has(c);
  }
  hasList(_c) {
    return false;
  }
  characterModeOnly = true;
  soleChar() {
    Assert(this.chars.size === 1, "this.chars.size === 1");
    return this.chars.values().next().value;
  }
}
class ConcreteStringSet extends CharSet {
  strings;
  constructor(strings) {
    super();
    this.strings = new Set(strings);
  }
  static of(charOrStrings) {
    const chars = new Set();
    const strings = new Set();
    for (const charOrString of charOrStrings) {
      if (charOrString.length <= 1 || charOrString.length === 2 && Array.from(charOrString).length === 1) {
        chars.add(charOrString);
      } else {
        strings.add(charOrString);
      }
    }
    if (chars.size && !strings.size) {
      return new ConcreteCharSet(chars);
    } else if (strings.size && !chars.size) {
      return new ConcreteStringSet(strings);
    }
    return new UnionCharSet(chars, strings, undefined);
  }
  has(_c) {
    return false;
  }
  hasList(c) {
    return this.strings.has(c);
  }
  characterModeOnly = false;
}
class UnionCharSet extends CharSet {
  constructor(chars, strings, charTesters) {
    super();
    this.chars = chars;
    this.strings = strings;
    this.charTester = charTesters;
  }
  has(c, rer) {
    if (this.chars && new ConcreteCharSet(this.chars).has(c, rer)) {
      return true;
    }
    if (this.charTester?.some(f => f(c, rer))) {
      return true;
    }
    return false;
  }
  hasList(c) {
    return !!this.strings?.has(c);
  }
  get characterModeOnly() {
    return !this.strings?.size;
  }
}

/** https://tc39.es/ecma262/#sec-regexp-records */

/** https://tc39.es/ecma262/#sec-compilepattern */
function CompilePattern(pattern, rer) {
  const m = CompileSubPattern(pattern.Disjunction, rer, Direction.Forward);
  annotateMatcher(m, pattern.Disjunction);
  return (input, index) => {
    Assert(index >= 0 && index <= input.length, "index >= 0 && index <= input.length");
    const c = function* MatchSuccess(y) {
      return y;
    };
    // Let cap be a List of rer.[[CapturingGroupsCount]] undefined values, indexed 1 through rer.[[CapturingGroupsCount]].
    const cap = [];
    for (let index = 1; index <= rer.CapturingGroupsCount; index += 1) {
      cap[index] = undefined;
    }
    const x = new MatchState(input, index, cap);
    return runMatcher(m(x, c));
  };
}
CompilePattern.section = 'https://tc39.es/ecma262/#sec-compilepattern';
/** https://tc39.es/ecma262/#sec-compilesubpattern */
function CompileSubPattern(node, rer, direction) {
  switch (node.type) {
    //  Disjunction :: Alternative | Disjunction
    case 'Disjunction':
      {
        if (node.Alternative && node.Disjunction) {
          const m1 = CompileSubPattern(node.Alternative, rer, direction);
          const m2 = CompileSubPattern(node.Disjunction, rer, direction);
          return MatchTwoAlternatives(m1, m2);
        }
        // Disjunction :: Alternative
        return CompileSubPattern(node.Alternative, rer, direction);
      }
    // Alternative :: [empty]
    // Alternative :: Alternative Term
    case 'Alternative':
      {
        if (!node.Term.length) {
          return EmptyMatcher;
        }
        if (node.Term.length === 1) {
          return CompileSubPattern(node.Term[0], rer, direction);
        }
        return node.Term.reduceRight((m2, term) => {
          const m1 = CompileSubPattern(term, rer, direction);
          if (!m2) {
            return m1;
          }
          return MatchSequence(m1, m2, direction);
        }, undefined);
      }
    // Term :: Assertion
    // Term :: Atom
    // Term :: Atom Quantifier
    case 'Term':
      {
        switch (node.production) {
          case 'Assertion':
            return annotateMatcher(CompileAssertion(node.Assertion, rer), node.Assertion);
          case 'Atom':
            if (node.Quantifier) {
              const m = CompileAtom(node.Atom, rer, direction);
              const q = CompileQuantifier(node.Quantifier);
              Assert(q.Min <= q.Max, "q.Min <= q.Max");
              const parenIndex = CountLeftCapturingParensBefore(node);
              const parenCount = CountLeftCapturingParensWithin(node);
              return (x, c) => RepeatMatcher(m, q.Min, q.Max, q.Greedy, x, c, parenIndex, parenCount);
            } else {
              return CompileAtom(node.Atom, rer, direction);
            }
          default:
            unreachable();
        }
      }
  }
  unreachable();
}
CompileSubPattern.section = 'https://tc39.es/ecma262/#sec-compilesubpattern';
/** https://tc39.es/ecma262/#sec-runtime-semantics-repeatmatcher-abstract-operation */
function* RepeatMatcher(m, min, max, greedy, x, c, parenIndex, parenCount) {
  if (max === 0) {
    return yield () => c(x);
  }
  const d = function* RepeatMatcher_d(y) {
    if (min === 0 && y.endIndex === x.endIndex) {
      return 'failure';
    }
    const min2 = min === 0 ? 0 : min - 1;
    const max2 = max === Infinity ? Infinity : max - 1;
    return yield () => RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount);
  };
  const cap = [...x.captures];
  for (let k = parenIndex + 1; k <= parenIndex + parenCount; k += 1) {
    cap[k] = undefined;
  }
  const input = x.input;
  const e = x.endIndex;
  const xr = new MatchState(input, e, cap);
  if (min !== 0) {
    return yield () => m(xr, d);
  }
  if (!greedy) {
    const z = yield () => c(x);
    if (z !== 'failure') {
      return z;
    }
    return yield () => m(xr, d);
  }
  const z = yield () => m(xr, d);
  if (z !== 'failure') {
    return z;
  }
  return yield () => c(x);
}
RepeatMatcher.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-repeatmatcher-abstract-operation';
/** https://tc39.es/ecma262/#sec-emptymatcher */
const EmptyMatcher = (x, c) => c(x);
EmptyMatcher.section = 'https://tc39.es/ecma262/#sec-emptymatcher';
annotateMatcher(EmptyMatcher, 'EmptyMatcher');

/** https://tc39.es/ecma262/#sec-matchtwoalternatives */
function MatchTwoAlternatives(m1, m2) {
  return annotateMatcher(function* TwoAlternatives(x, c) {
    const r = yield () => m1(x, c);
    if (r !== 'failure') {
      return r;
    }
    return yield () => m2(x, c);
  }, [m1.comment || m1, '|', m2.comment || m2]);
}
MatchTwoAlternatives.section = 'https://tc39.es/ecma262/#sec-matchtwoalternatives';
/** https://tc39.es/ecma262/#sec-matchsequence */
function MatchSequence(m1, m2, direction) {
  if (direction === Direction.Forward) {
    return annotateMatcher(function Seq(x, c) {
      const d = y => m2(y, c);
      return m1(x, d);
    }, [m1.comment || m1, '|', m2.comment || m2]);
  } else {
    return annotateMatcher(function Seq_Backword(x, c) {
      const d = y => m1(y, c);
      return m2(x, d);
    }, [m2.comment || m2, '|', m1.comment || m1]);
  }
}
MatchSequence.section = 'https://tc39.es/ecma262/#sec-matchsequence';
/** https://tc39.es/ecma262/#sec-compileassertion */
function CompileAssertion(node, rer) {
  if (node.production === '^') {
    return function* Assertion_Start(x, c) {
      const Input = x.input;
      const e = x.endIndex;
      if (e === 0 || rer.Multiline && isLineTerminator(Input[e - 1])) {
        return yield () => c(x);
      }
      return 'failure';
    };
  } else if (node.production === '$') {
    return function* Assertion_End(x, c) {
      const Input = x.input;
      const e = x.endIndex;
      if (e === Input.length || rer.Multiline && isLineTerminator(Input[e])) {
        return yield () => c(x);
      }
      return 'failure';
    };
  } else if (node.production === 'b') {
    return function* Assertion_WordBoundary(x, c) {
      const Input = x.input;
      const e = x.endIndex;
      const a = IsWordChar(rer, Input.raw, e - 1);
      const b = IsWordChar(rer, Input.raw, e);
      if (a && !b || !a && b) {
        return yield () => c(x);
      }
      return 'failure';
    };
  } else if (node.production === 'B') {
    return function* Assertion_NotWordBoundary(x, c) {
      const Input = x.input;
      const e = x.endIndex;
      const a = IsWordChar(rer, Input.raw, e - 1);
      const b = IsWordChar(rer, Input.raw, e);
      if (a && b || !a && !b) {
        return yield () => c(x);
      }
      return 'failure';
    };
  } else if (node.production === '?=') {
    const m = CompileSubPattern(node.Disjunction, rer, Direction.Forward);
    return function* Assertion_PositiveLookahead(x, c) {
      const d = function* Assertion_PositiveLookahead_Success(y) {
        return y;
      };
      const r = yield () => m(x, d);
      if (r === 'failure') {
        return 'failure';
      }
      const cap = r.captures;
      const input = x.input;
      const xe = x.endIndex;
      const z = new MatchState(input, xe, cap);
      return yield () => c(z);
    };
  } else if (node.production === '?!') {
    const m = CompileSubPattern(node.Disjunction, rer, Direction.Forward);
    return function* Assertion_NegativeLookahead(x, c) {
      const d = function* Assertion_NegativeLookahead_Success(y) {
        return y;
      };
      const r = yield () => m(x, d);
      if (r !== 'failure') {
        return 'failure';
      }
      return yield () => c(x);
    };
  } else if (node.production === '?<=') {
    const m = CompileSubPattern(node.Disjunction, rer, Direction.Backward);
    return function* Assertion_PositiveLookBehind(x, c) {
      const d = function* Assertion_PositiveLookBehind_Success(y) {
        return y;
      };
      const r = yield () => m(x, d);
      if (r === 'failure') {
        return 'failure';
      }
      const cap = r.captures;
      const input = x.input;
      const xe = x.endIndex;
      const z = new MatchState(input, xe, cap);
      return yield () => c(z);
    };
  } else if (node.production === '?<!') {
    const m = CompileSubPattern(node.Disjunction, rer, Direction.Backward);
    return function* Assertion_NegativeLookBehind(x, c) {
      const d = function* Assertion_NegativeLookBehind_Success(y) {
        return y;
      };
      const r = yield () => m(x, d);
      if (r !== 'failure') {
        return 'failure';
      }
      return yield () => c(x);
    };
  }
  unreachable(node.production);
}
CompileAssertion.section = 'https://tc39.es/ecma262/#sec-compileassertion';
/** https://tc39.es/ecma262/#sec-runtime-semantics-iswordchar-abstract-operation */
function IsWordChar(rer, Input, e) {
  const inputLength = Input.length;
  if (e === -1 || e === inputLength) {
    return false;
  }
  const c = Input[e];
  return WordCharacters(rer).has(c, rer);
}
IsWordChar.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-iswordchar-abstract-operation';
/** https://tc39.es/ecma262/#sec-compilequantifier */
function CompileQuantifier(node) {
  const [Min, Max] = CompileQuantifierPrefix(node.QuantifierPrefix);
  return {
    Min,
    Max,
    Greedy: !node.QuestionMark
  };
}
CompileQuantifier.section = 'https://tc39.es/ecma262/#sec-compilequantifier';
/** https://tc39.es/ecma262/#sec-compilequantifierprefix */
function CompileQuantifierPrefix(node) {
  switch (node.production) {
    case '*':
      return [0, Infinity];
    case '+':
      return [1, Infinity];
    case '?':
      return [0, 1];
    default:
      {
        return [node.DecimalDigits_a, node.DecimalDigits_b || node.DecimalDigits_a];
      }
  }
}
CompileQuantifierPrefix.section = 'https://tc39.es/ecma262/#sec-compilequantifierprefix';
/** https://tc39.es/ecma262/#sec-compileatom */
function CompileAtom(node, rer, direction) {
  if (node.type === 'Atom') {
    switch (node.production) {
      // Atom :: PatternCharacter
      case 'PatternCharacter':
        {
          const ch = node.PatternCharacter;
          const A = new ConcreteCharSet([ch]);
          return CharacterSetMatcher(rer, A, false, direction);
        }
      // Atom :: .
      case '.':
        {
          let A = AllCharacters(rer);
          if (!rer.DotAll) {
            // Remove from A all characters corresponding to a code point on the right-hand side of the LineTerminator production.
            A = CharSet.subtract(A, false, new VirtualCharSet(isLineTerminator));
          }
          return CharacterSetMatcher(rer, A, false, direction);
        }
      // Atom :: CharacterClass
      case 'CharacterClass':
        {
          const cc = CompileCharacterClass(node.CharacterClass, rer);
          const cs = cc.CharSet;
          // If rer.[[UnicodeSets]] is false, or if every CharSetElement of cs consists of a single character (including if cs is empty), return CharacterSetMatcher(rer, cs, cc.[[Invert]], direction).
          if (!rer.UnicodeSets || cs.characterModeOnly) {
            return CharacterSetMatcher(rer, cs, cc.Invert, direction);
          }
          Assert(!cc.Invert, "!cc.Invert");
          const lm = [];
          // For each CharSetElement s in cs containing more than 1 character, iterating in descending order of length, do
          for (const s of cs.getStrings().sort((a, b) => b.length - a.length)) {
            // Let cs2 be a one-element CharSet containing the last code point of s.
            const cs2 = new ConcreteCharSet([s.at(-1)]);
            let m2 = CharacterSetMatcher(rer, cs2, false, direction);
            // For each code point c1 in s, iterating backwards from its second-to-last code point, do
            for (const c1 of Unicode.iterateByCodePoint(s).reverse().slice(1)) {
              const cs1 = new ConcreteCharSet([c1]);
              const m1 = CharacterSetMatcher(rer, cs1, false, direction);
              m2 = MatchSequence(m1, m2, direction);
            }
            lm.push(m2);
          }
          // Let singles be the CharSet containing every CharSetElement of cs that consists of a single character.
          const singles = CharSet.subtract(cs, true);
          lm.push(CharacterSetMatcher(rer, singles, false, direction));
          // If cs contains the empty sequence of characters, append EmptyMatcher() to lm.
          if (cs.hasList('')) {
            lm.push(EmptyMatcher);
          }
          let m2 = lm.at(-1);
          // For each Matcher m1 of lm, iterating backwards from its second-to-last element, do
          for (const m1 of lm.toReversed().slice(1)) {
            m2 = MatchTwoAlternatives(m1, m2);
          }
          return m2;
        }
      case 'Group':
        {
          const m = CompileSubPattern(node.Disjunction, rer, direction);
          const parenIndex = CountLeftCapturingParensBefore(node);
          return annotateMatcher(function GroupMatcher(x, c) {
            const d = y => {
              const cap = [...y.captures];
              const Input = x.input;
              const xe = x.endIndex;
              const ye = y.endIndex;
              let r;
              if (direction === Direction.Forward) {
                Assert(xe <= ye, "xe <= ye");
                r = {
                  startIndex: xe,
                  endIndex: ye
                };
              } else {
                Assert(direction === Direction.Backward, "direction === Direction.Backward");
                Assert(ye <= xe, "ye <= xe");
                r = {
                  startIndex: ye,
                  endIndex: xe
                };
              }
              cap[parenIndex + 1] = r;
              const z = new MatchState(Input, ye, cap);
              return c(z);
            };
            return m(x, d);
          }, node);
        }
      case 'Modifier':
        {
          const addModifiers = node.AddModifiers;
          const removeModifiers = node.RemoveModifiers;
          const modifiedRer = UpdateModifiers(rer, addModifiers?.join('') || '', removeModifiers?.join('') || '');
          return CompileSubPattern(node.Disjunction, modifiedRer, direction);
        }
      case 'AtomEscape':
        return CompileAtom(node.AtomEscape, rer, direction);
      default:
        unreachable();
    }
    // Atom :: ( GroupSpecifieropt Disjunction )
  } else if (node.type === 'AtomEscape') {
    switch (node.production) {
      case 'DecimalEscape':
        {
          const n = CapturingGroupNumber(node.DecimalEscape);
          Assert(n <= rer.CapturingGroupsCount, "n <= rer.CapturingGroupsCount");
          return BackreferenceMatcher(rer, [n], direction);
        }
      case 'CharacterEscape':
        {
          const cv = CharacterValue(node.CharacterEscape);
          const ch = Unicode.toCharacter(cv);
          const A = new ConcreteCharSet([ch]);
          return CharacterSetMatcher(rer, A, false, direction);
        }
      case 'CharacterClassEscape':
        {
          const cs = CompileToCharSet(node.CharacterClassEscape, rer);
          // If rer.[[UnicodeSets]] is false, or if every CharSetElement of cs consists of a single character (including if cs is empty), return CharacterSetMatcher(rer, cs, cc.[[Invert]], direction).
          if (!rer.UnicodeSets || cs.characterModeOnly) {
            return CharacterSetMatcher(rer, cs, false, direction);
          }
          const lm = [];
          // For each CharSetElement s in cs containing more than 1 character, iterating in descending order of length, do
          for (const s of cs.getStrings().sort((a, b) => b.length - a.length)) {
            const codePointOfS = Unicode.iterateByCodePoint(s);
            // Let cs2 be a one-element CharSet containing the last code point of s.
            const cs2 = new ConcreteCharSet([codePointOfS.at(-1)]);
            let m2 = CharacterSetMatcher(rer, cs2, false, direction);
            // For each code point c1 in s, iterating backwards from its second-to-last code point, do
            for (const c1 of codePointOfS.reverse().slice(1)) {
              const cs1 = new ConcreteCharSet([c1]);
              const m1 = CharacterSetMatcher(rer, cs1, false, direction);
              m2 = MatchSequence(m1, m2, direction);
            }
            lm.push(m2);
          }
          // Let singles be the CharSet containing every CharSetElement of cs that consists of a single character.
          const singles = CharSet.subtract(cs, true);
          lm.push(CharacterSetMatcher(rer, singles, false, direction));
          // If cs contains the empty sequence of characters, append EmptyMatcher() to lm.
          if (cs.hasList('')) {
            lm.push(EmptyMatcher);
          }
          let m2 = lm.at(-1);
          // For each Matcher m1 of lm, iterating backwards from its second-to-last element, do
          for (const m1 of lm.toReversed().slice(1)) {
            m2 = MatchTwoAlternatives(m1, m2);
          }
          return m2;
        }
      case 'CaptureGroupName':
        {
          const matchingGroupSpecifiers = GroupSpecifiersThatMatch(node);
          const parenIndices = [];
          for (const atom_Group of matchingGroupSpecifiers) {
            // Let parenIndex be CountLeftCapturingParensBefore(groupSpecifier).
            // groupSpecifier is in a Atom_Group, the CountLeftCapturingParensBefore does not count for itself so add 1
            const parenIndex = CountLeftCapturingParensBefore(atom_Group) + 1;
            parenIndices.push(parenIndex);
          }
          return BackreferenceMatcher(rer, parenIndices, direction);
        }
      default:
        unreachable();
    }
  }
  unreachable();
}
CompileAtom.section = 'https://tc39.es/ecma262/#sec-compileatom';
/** https://tc39.es/ecma262/#sec-runtime-semantics-charactersetmatcher-abstract-operation */
function CharacterSetMatcher(rer, A, invert, direction) {
  if (rer.UnicodeSets) {
    Assert(!invert, "!invert");
    // Assert: Every CharSetElement of A consists of a single character.
    Assert(A.characterModeOnly, "A.characterModeOnly");
  }
  return annotateMatcher(function* CharacterSetMatcher(x, c) {
    const Input = x.input;
    const e = x.endIndex;
    const f = direction === Direction.Forward ? e + 1 : e - 1;
    const InputLength = Input.length;
    if (f < 0 || f > InputLength) {
      return 'failure';
    }
    const index = Math.min(e, f);
    const ch = Input[index];
    const cc = Canonicalize(rer, ch);
    // If there exists a CharSetElement in A containing exactly one character a such that Canonicalize(rer, a) is cc, let found be true. Otherwise, let found be false.
    const found = A.has(cc, rer);
    if (!invert && !found || invert && found) {
      return 'failure';
    }
    const cap = x.captures;
    const y = new MatchState(Input, f, cap);
    return yield () => c(y);
  }, [A, invert]);
}
CharacterSetMatcher.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-charactersetmatcher-abstract-operation';
/** https://tc39.es/ecma262/#sec-backreference-matcher */
function BackreferenceMatcher(rer, ns, direction) {
  return annotateMatcher(function* BackreferenceMatcher(x, c) {
    const Input = x.input;
    const cap = x.captures;
    let r;
    for (const n of ns) {
      if (cap[n] !== undefined) {
        Assert(r === undefined, "r === undefined");
        r = cap[n];
      }
    }
    if (r === undefined) {
      return yield () => c(x);
    }
    const e = x.endIndex;
    const rs = r.startIndex;
    const re = r.endIndex;
    const len = re - rs;
    const f = direction === Direction.Forward ? e + len : e - len;
    const InputLength = Input.length;
    if (f < 0 || f > InputLength) {
      return 'failure';
    }
    const g = Math.min(e, f);
    for (let i = 0; i < len; i += 1) {
      if (Canonicalize(rer, Input[rs + i]) !== Canonicalize(rer, Input[g + i])) {
        return 'failure';
      }
    }
    const y = new MatchState(Input, f, cap);
    return yield () => c(y);
  }, ['BackreferenceMatcher', ns, rer]);
}
BackreferenceMatcher.section = 'https://tc39.es/ecma262/#sec-backreference-matcher';
/** https://tc39.es/ecma262/#sec-runtime-semantics-canonicalize-ch */
function Canonicalize(rer, ch) {
  if (HasEitherUnicodeFlag(rer) && rer.IgnoreCase) {
    // If the file CaseFolding.txt of the Unicode Character Database provides a simple or common case folding mapping for ch, return the result of applying that mapping to ch.
    const mapped = Unicode.SimpleOrCommonCaseFoldingMapping(ch);
    if (mapped) {
      return mapped;
    } else {
      return ch;
    }
  }
  if (!rer.IgnoreCase) {
    return ch;
  }
  Assert(ch.length === 1, 'ch is a UTF-16 code unit', "ch.length === 1");
  const cp = Unicode.toCodePoint(ch);
  const u = Unicode.toUppercase(cp);
  const uStr = CodePointsToString(Unicode.toCharacter(u));
  if (uStr.length !== 1) {
    return ch;
  }
  // Let cu be uStr's single code unit element.
  const cu = uStr[0];
  if (Unicode.toCodePoint(ch) >= 128 && Unicode.toCodePoint(cu) < 128) {
    return ch;
  }
  return cu;
}
Canonicalize.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-canonicalize-ch';
/** https://tc39.es/ecma262/#sec-updatemodifiers */
function UpdateModifiers(rer, add, remove) {
  Assert(new Set([...add, ...remove]).size === (add + remove).length, "new Set([...add, ...remove]).size === (add + remove).length");
  const next = {
    ...rer
  };
  if (remove.includes('i')) {
    next.IgnoreCase = false;
  } else if (add.includes('i')) {
    next.IgnoreCase = true;
  }
  if (remove.includes('m')) {
    next.Multiline = false;
  } else if (add.includes('m')) {
    next.Multiline = true;
  }
  if (remove.includes('s')) {
    next.DotAll = false;
  } else if (add.includes('s')) {
    next.DotAll = true;
  }
  return next;
}
UpdateModifiers.section = 'https://tc39.es/ecma262/#sec-updatemodifiers';
/** https://tc39.es/ecma262/#sec-compilecharacterclass */
function CompileCharacterClass(node, rer) {
  const A = CompileToCharSet(node.ClassContents, rer);
  return {
    CharSet: rer.UnicodeSets && node.invert ? CharacterComplement(rer, A) : A,
    Invert: rer.UnicodeSets ? false : node.invert
  };
}
CompileCharacterClass.section = 'https://tc39.es/ecma262/#sec-compilecharacterclass';
/** https://tc39.es/ecma262/#sec-compiletocharset */
function CompileToCharSet(node, rer) {
  switch (node.type) {
    //  ClassContents :: [empty]
    //  NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash
    //  NonemptyClassRanges :: ClassAtom - ClassAtom ClassContents
    //  NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash
    //  NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassContents
    case 'ClassContents':
      {
        if (node.production === 'Empty') {
          return new ConcreteCharSet([]);
        } else if (node.production === 'NonEmptyClassRanges') {
          let allSet = new ConcreteCharSet([]);
          for (const range of node.NonemptyClassRanges) {
            if (isArray(range)) {
              const [A, B] = range;
              const a = CompileToCharSet(A, rer);
              const b = CompileToCharSet(B, rer);
              Assert(a instanceof ConcreteCharSet && b instanceof ConcreteCharSet, "a instanceof ConcreteCharSet && b instanceof ConcreteCharSet");
              const set = CharacterRange(a, b);
              allSet = CharSet.union(allSet, set);
            } else {
              const set = CompileToCharSet(range, rer);
              allSet = CharSet.union(allSet, set);
            }
          }
          return allSet;
        } else if (node.production === 'ClassSetExpression') {
          return CompileToCharSet(node.ClassSetExpression, rer);
        }
        unreachable();
      }
    //  ClassAtom :: -
    //  ClassAtomNoDash :: SourceCharacter but not one of \ or ] or -
    case 'ClassAtom':
      {
        if (node.production === '-') {
          return new ConcreteCharSet(['-']);
        } else if (node.production === 'SourceCharacter') {
          return new ConcreteCharSet([node.SourceCharacter]);
        } else if (node.production === 'ClassEscape') {
          return CompileToCharSet(node.ClassEscape, rer);
        }
        unreachable();
      }
    //  ClassEscape :: -
    //  ClassEscape :: CharacterEscape
    case 'ClassEscape':
      {
        if (node.production === 'CharacterClassEscape') {
          return CompileToCharSet(node.CharacterClassEscape, rer);
        }
        const cv = CharacterValue(node);
        return new ConcreteCharSet([Unicode.toCharacter(cv)]);
      }
    //  CharacterClassEscape :: d d s S w W
    //  CharacterClassEscape :: p{ UnicodePropertyValueExpression }
    //  CharacterClassEscape :: P{ UnicodePropertyValueExpression }
    case 'CharacterClassEscape':
      {
        switch (node.production) {
          case 'd':
            return new ConcreteCharSet('0123456789');
          case 'D':
            return CharacterComplement(rer, new ConcreteCharSet('0123456789'));
          case 's':
            return new VirtualCharSet(char => isWhitespace(char) || isLineTerminator(char));
          case 'S':
            return new VirtualCharSet(char => !isWhitespace(char) && !isLineTerminator(char));
          case 'w':
            return MaybeSimpleCaseFolding(rer, WordCharacters(rer));
          case 'W':
            return CharacterComplement(rer, MaybeSimpleCaseFolding(rer, WordCharacters(rer)));
          case 'p':
            return CompileToCharSet(node.UnicodePropertyValueExpression, rer);
          case 'P':
            {
              const S = CompileToCharSet(node.UnicodePropertyValueExpression, rer);
              // Cannot implement: Assert: S contains only single code points.
              return CharacterComplement(rer, S);
            }
          default:
            unreachable();
        }
      }
    //  UnicodePropertyValueExpression :: UnicodePropertyName = UnicodePropertyValue
    //  UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue
    case 'UnicodePropertyValueExpression':
      {
        if (node.production === '=') {
          const ps = node.UnicodePropertyName;
          const p = UnicodeMatchProperty(rer, ps);
          Assert(p in Table69_NonbinaryUnicodeProperties, "p in Table69_NonbinaryUnicodeProperties");
          const vs = node.UnicodePropertyValue;
          let v;
          let A;
          if (p === 'Script_Extensions') {
            Assert(vs in PropertyValueAliases.Script, "vs in PropertyValueAliases.Script");
            // Let v be the Set containing the “short name”, “long name”, and any other aliases corresponding with value vs for property “Script” in PropertyValueAliases.txt.
            v = UnicodeMatchPropertyValue('Script', vs);
            // Return the CharSet containing all Unicode code points whose character database definition includes the property “Script_Extensions” with value having a non-empty intersection with v.
            A = new VirtualCharSet((ch, rer) => Unicode.characterMatchPropertyValue(ch, p, v, rer));
          } else {
            v = UnicodeMatchPropertyValue(p, vs);
            // Let A be the CharSet containing all Unicode code points whose character database definition includes the property p with value v.
            A = new VirtualCharSet((ch, rer) => Unicode.characterMatchPropertyValue(ch, p, v, rer));
          }
          return MaybeSimpleCaseFolding(rer, A);
        } else {
          const s = node.LoneUnicodePropertyNameOrValue;
          if (s in PropertyValueAliases.General_Category) {
            const v = UnicodeMatchPropertyValue('General_Category', s);
            // Return the CharSet containing all Unicode code points whose character database definition includes the property “General_Category” with value v.
            return new VirtualCharSet((ch, rer) => Unicode.characterMatchPropertyValue(ch, 'General_Category', v, rer));
          }
          const p = UnicodeMatchProperty(rer, s);
          Assert(p in Table70_BinaryUnicodeProperties || p in Table71_BinaryPropertyOfStrings, "p in Table70_BinaryUnicodeProperties || p in Table71_BinaryPropertyOfStrings");
          // Let A be the CharSet containing all CharSetElements whose character database definition includes the property p with value “True”.
          if (p in Table71_BinaryPropertyOfStrings) {
            const A = ConcreteStringSet.of(Unicode.getStringPropertySet(p));
            return MaybeSimpleCaseFolding(rer, A);
          }
          const A = new VirtualCharSet((ch, rer) => Unicode.characterMatchPropertyValue(ch, p, undefined, rer));
          return MaybeSimpleCaseFolding(rer, A);
        }
      }
    //  ClassUnion :: ClassSetRange ClassUnion
    //  ClassUnion :: ClassSetOperand ClassUnion
    case 'ClassUnion':
      {
        return CharSet.union(...node.union.map(part => CompileToCharSet(part, rer)));
      }
    //  ClassIntersection :: ClassSetOperand && ClassSetOperand
    //  ClassIntersection :: ClassIntersection && ClassSetOperand
    case 'ClassIntersection':
      {
        return CharSet.intersection(...node.operands.map(part => CompileToCharSet(part, rer)));
      }
    //  ClassSubtraction :: ClassSetOperand -- ClassSetOperand
    //  ClassSubtraction :: ClassSubtraction -- ClassSetOperand
    case 'ClassSubtraction':
      {
        const mainSet = CompileToCharSet(node.operands[0], rer);
        return CharSet.subtract(mainSet, false, ...node.operands.slice(1).map(part => CompileToCharSet(part, rer)));
      }
    //  ClassSetRange :: ClassSetCharacter - ClassSetCharacter
    case 'ClassSetRange':
      {
        const A = CompileToCharSet(node.left, rer);
        const B = CompileToCharSet(node.right, rer);
        Assert(A instanceof ConcreteCharSet && B instanceof ConcreteCharSet, "A instanceof ConcreteCharSet && B instanceof ConcreteCharSet");
        return MaybeSimpleCaseFolding(rer, CharacterRange(A, B));
      }
    //  ClassSetOperand :: ClassSetCharacter
    //  ClassSetOperand :: ClassStringDisjunction
    //  ClassSetOperand :: NestedClass
    case 'ClassSetOperand':
      {
        if (node.production === 'NestedClass') {
          return CompileToCharSet(node.NestedClass, rer);
        } else if (node.production === 'ClassSetCharacter') {
          const A = CompileToCharSet(node.ClassSetCharacter, rer);
          return MaybeSimpleCaseFolding(rer, A);
        } else if (node.production === 'ClassStringDisjunction') {
          const A = CompileToCharSet(node.ClassStringDisjunction, rer);
          return MaybeSimpleCaseFolding(rer, A);
        }
        unreachable();
      }
    //  NestedClass :: [ ClassContents ]
    //  NestedClass :: [^ ClassContents ]
    //  NestedClass :: \ CharacterClassEscape
    case 'NestedClass':
      {
        if (node.production === 'ClassContents') {
          const A = CompileToCharSet(node.ClassContents, rer);
          if (node.invert) {
            return CharacterComplement(rer, A);
          }
          return A;
        }
        if (node.CharacterClassEscape) {
          return CompileToCharSet(node.CharacterClassEscape, rer);
        }
        throw new Assert.Error('Invalid AST');
      }
    // ClassStringDisjunction :: \q{ ClassStringDisjunctionContents }
    // ClassStringDisjunctionContents :: ClassString
    // ClassStringDisjunctionContents :: ClassString | ClassStringDisjunctionContents
    case 'ClassStringDisjunction':
      {
        const s = node.ClassString.map(node => CompileClassSetString(node, rer));
        const A = ConcreteStringSet.of(s);
        return A;
      }
    // ClassSetCharacter ::
    //   SourceCharacter but not ClassSetSyntaxCharacter
    //   \ CharacterEscape
    //   \ ClassSetReservedPunctuator
    case 'ClassSetCharacter':
      {
        const cv = CharacterValue(node);
        const A = new ConcreteCharSet([Unicode.toCharacter(cv)]);
        return A;
      }
    default:
      unreachable();
  }
}
CompileToCharSet.section = 'https://tc39.es/ecma262/#sec-compiletocharset';
/** https://tc39.es/ecma262/#sec-runtime-semantics-characterrange-abstract-operation */
function CharacterRange(A, B) {
  const a = A.soleChar();
  const b = B.soleChar();
  const i = Unicode.toCodePoint(a);
  const j = Unicode.toCodePoint(b);
  Assert(i <= j, "i <= j");
  const canonicalized = {};
  // Return the CharSet containing all characters with a character value in the inclusive interval from i to j.
  return new VirtualCharSet((ch, rer) => {
    const cp = Unicode.toCodePoint(ch);
    if (rer) {
      const canonicalizedKey = JSON.stringify(rer);
      if (canonicalized[canonicalizedKey] === undefined) {
        canonicalized[canonicalizedKey] = new Set();
        const set = canonicalized[canonicalizedKey];
        for (let index = i; index <= j; index = index + 1) {
          const ch = Unicode.toCharacter(index);
          set.add(Canonicalize(rer, ch));
        }
      }
      return canonicalized[canonicalizedKey].has(ch);
    }
    return cp >= i && cp <= j;
  });
}
CharacterRange.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-characterrange-abstract-operation';
/** https://tc39.es/ecma262/#sec-runtime-semantics-haseitherunicodeflag-abstract-operation */
function HasEitherUnicodeFlag(rer) {
  return rer.Unicode || rer.UnicodeSets;
}
HasEitherUnicodeFlag.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-haseitherunicodeflag-abstract-operation';
/** https://tc39.es/ecma262/#sec-wordcharacters */
function WordCharacters(rer) {
  const basicWordChars = new ConcreteCharSet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_');
  const extraWordChars = new VirtualCharSet(c => Unicode.isCharacter(c) && !basicWordChars.has(c, rer) && basicWordChars.has(Canonicalize(rer, c), rer));
  return CharSet.union(basicWordChars, extraWordChars);
}
WordCharacters.section = 'https://tc39.es/ecma262/#sec-wordcharacters';
/** https://tc39.es/ecma262/#sec-allcharacters */
function AllCharacters(rer) {
  if (rer.UnicodeSets && rer.IgnoreCase) {
    // Return the CharSet containing all Unicode code points c that do not have a Simple Case Folding mapping (that is, scf(c)=c).
    return new VirtualCharSet(char => Unicode.isCharacter(char) && Unicode.SimpleOrCommonCaseFoldingMapping(char) !== char);
  } else if (HasEitherUnicodeFlag(rer)) {
    // Return the CharSet containing all code point values.
    return new VirtualCharSet(char => Unicode.isCharacter(char));
  } else {
    // Return the CharSet containing all code unit values.
    return new VirtualCharSet(ch => ch.length === 1);
  }
}
AllCharacters.section = 'https://tc39.es/ecma262/#sec-allcharacters';
/** https://tc39.es/ecma262/#sec-maybesimplecasefolding */
function MaybeSimpleCaseFolding(rer, A) {
  if (!rer.UnicodeSets || !rer.IgnoreCase) {
    return A;
  }
  const strings = A.getStrings();
  const scfString = strings.map(s => Array.from(Unicode.iterateCharacterByCodePoint(s)).map(Unicode.SimpleOrCommonCaseFoldingMapping).join(''));
  const scfChar = (ch, rer) => {
    // before optimized:
    // a. Let t be an empty sequence of characters.
    // b. For each single code point cp in s, do
    //   i. Append scf(cp) to t.
    // c. Add t to B.

    // it means B only contains scf(A)
    // we optimized it as:
    // if scf(ch) !== ch, it means ch is impossible to appear in scf(A).
    let scf = '';
    for (const cp of Unicode.iterateCharacterByCodePoint(ch)) {
      scf += Unicode.SimpleOrCommonCaseFoldingMapping(cp);
    }
    if (scf !== ch) {
      return false;
    }
    return A.has(ch, rer);
  };
  return CharSet.union(ConcreteStringSet.of(scfString), new VirtualCharSet(scfChar));
}
MaybeSimpleCaseFolding.section = 'https://tc39.es/ecma262/#sec-maybesimplecasefolding';
/** https://tc39.es/ecma262/#sec-charactercomplement */
function CharacterComplement(rer, S) {
  const A = AllCharacters(rer);
  // Return the CharSet containing the CharSetElements of A which are not also CharSetElements of S.
  return new VirtualCharSet((ch, rer) => A.has(ch, rer) && !S.has(ch, rer));
}
CharacterComplement.section = 'https://tc39.es/ecma262/#sec-charactercomplement';
/** https://tc39.es/ecma262/#sec-runtime-semantics-unicodematchproperty-p */
function UnicodeMatchProperty(rer, p) {
  // If rer.[[UnicodeSets]] is true and _p_ is listed in the “Property name” column of Table 71, then, then
  if (rer.UnicodeSets && p in Table71_BinaryPropertyOfStrings) {
    return p;
  }
  // Assert: p is listed in the “Property name and aliases” column of Table 69 or Table 70.
  // Return the “canonical property name” corresponding to the property name or property alias p in Table 69 or Table 70.
  if (p in Table69_NonbinaryUnicodeProperties) {
    return Table69_NonbinaryUnicodeProperties[p];
  }
  if (p in Table70_BinaryUnicodeProperties) {
    return Table70_BinaryUnicodeProperties[p];
  }
  Assert(false, 'p in Table69_NonbinaryUnicodeProperties || p in Table70_BinaryUnicodeProperties', "false");
}
UnicodeMatchProperty.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-unicodematchproperty-p';
/** https://tc39.es/ecma262/#sec-runtime-semantics-unicodematchpropertyvalue-p-v */
function UnicodeMatchPropertyValue(p, v) {
  // Assert: p is a canonical, unaliased Unicode property name listed in the “Canonical property name” column of Table 69.
  const CanonicalizedP = Table69_NonbinaryUnicodeProperties[p];
  Assert(p in Table69_NonbinaryUnicodeProperties && CanonicalizedP === p, "p in Table69_NonbinaryUnicodeProperties && CanonicalizedP === p");
  const table = PropertyValueAliases[CanonicalizedP];
  // Assert: v is a property value or property value alias for the Unicode property p listed in PropertyValueAliases.txt.
  Assert(v in table, "v in table");
  // If v is a “short name” or other alias associated with some “long name” l for property name p in PropertyValueAliases.txt, return l; otherwise, return v.
  return table[v];
}
UnicodeMatchPropertyValue.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-unicodematchpropertyvalue-p-v';
/** https://tc39.es/ecma262/#sec-compileclasssetstring */
function CompileClassSetString(node, rer) {
  let str = '';
  for (const char of node) {
    const cs = CompileToCharSet(char, rer);
    Assert(cs instanceof ConcreteCharSet, "cs instanceof ConcreteCharSet");
    const s1 = cs.soleChar();
    str += s1;
  }
  return str;
}
CompileClassSetString.section = 'https://tc39.es/ecma262/#sec-compileclasssetstring'; // SS:
function CountLeftCapturingParensWithin(node) {
  if (node.type === 'Pattern') {
    return node.capturingGroups.length;
  }
  return node.capturingParenthesesWithin;
}
function CountLeftCapturingParensBefore(node) {
  return node.leftCapturingParenthesesBefore;
}
function IsCharacterClass(node) {
  return node.production === 'ClassEscape' && node.ClassEscape.production === 'CharacterClassEscape';
}
function CapturingGroupNumber(node) {
  return node.value;
}
function GroupSpecifiersThatMatch(node) {
  return node.groupSpecifiersThatMatchSelf;
}

// for debugging purpose

function annotateMatcher(matcher, comment) {
  Object.assign(matcher, {
    comment
  });
  return matcher;
}

/** https://tc39.es/ecma262/#sec-stringpad */
function* StringPad(O, maxLength, fillString, placement) {
  Assert(placement === 'start' || placement === 'end', "placement === 'start' || placement === 'end'");
  /* ReturnIfAbrupt */
  let _temp = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const S = _temp;
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToLength(maxLength);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const intMaxLength = R(_temp2);
  const stringLength = S.stringValue().length;
  if (intMaxLength <= stringLength) {
    return S;
  }
  let filler;
  if (fillString === Value.undefined) {
    filler = ' ';
  } else {
    /* ReturnIfAbrupt */
    let _temp3 = yield* ToString(fillString);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    filler = _temp3.stringValue();
  }
  if (filler === '') {
    return S;
  }
  const fillLen = intMaxLength - stringLength;
  const stringFiller = filler.repeat(Math.ceil(fillLen / filler.length));
  const truncatedStringFiller = stringFiller.slice(0, fillLen);
  if (placement === 'start') {
    return Value(truncatedStringFiller + S.stringValue());
  } else {
    return Value(S.stringValue() + truncatedStringFiller);
  }
}
StringPad.section = 'https://tc39.es/ecma262/#sec-stringpad';

/** https://tc39.es/ecma262/#sec-trimstring */
function* TrimString(string, where) {
  /* ReturnIfAbrupt */
  let _temp = RequireObjectCoercible(string);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const str = _temp;
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToString(str);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const S = _temp2.stringValue();
  let T;
  if (where === 'start') {
    T = S.trimStart();
  } else if (where === 'end') {
    T = S.trimEnd();
  } else {
    Assert(where === 'start+end', "where === 'start+end'");
    T = S.trim();
  }
  return Value(T);
}
TrimString.section = 'https://tc39.es/ecma262/#sec-trimstring';

/** https://tc39.es/ecma262/#sec-meta-properties-runtime-semantics-evaluation */
// NewTarget : `new` `.` `target`
function Evaluate_NewTarget() {
  // 1. Return GetNewTarget().
  return GetNewTarget();
}
Evaluate_NewTarget.section = 'https://tc39.es/ecma262/#sec-meta-properties-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-async-function-definitions-runtime-semantics-evaluation */
//   AwaitExpression : `await` UnaryExpression
function* Evaluate_AwaitExpression({
  UnaryExpression
}) {
  /* ReturnIfAbrupt */
  let _temp = surroundingAgent.debugger_cannotPreview;
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let exprRef be the result of evaluating UnaryExpression.
  /* ReturnIfAbrupt */
  let _temp2 = yield* Evaluate(UnaryExpression);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const exprRef = _temp2;
  // 2. Let value be ? GetValue(exprRef).
  /* ReturnIfAbrupt */
  let _temp3 = yield* GetValue(exprRef);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const value = _temp3;
  // 3. Return ? Await(value).
  return yield* Await(value);
}
Evaluate_AwaitExpression.section = 'https://tc39.es/ecma262/#sec-async-function-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-runtime-semantics-bindingclassdeclarationevaluation */
//   ClassDeclaration :
//     `class` BindingIdentifier ClassTail
//     `class` ClassTail
function* BindingClassDeclarationEvaluation(ClassDeclaration) {
  const {
    BindingIdentifier,
    ClassTail
  } = ClassDeclaration;
  if (!BindingIdentifier) {
    /* ReturnIfAbrupt */
    let _temp = yield* ClassDefinitionEvaluation(ClassTail, Value.undefined, Value('default'));
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // 1. Let value be ? ClassDefinitionEvaluation of ClassTail with arguments undefined and "default".
    const value = _temp;
    // 2. Set value.[[SourceText]] to the source text matched by ClassDeclaration.
    value.SourceText = sourceTextMatchedBy(ClassDeclaration);
    // 3. Return value.
    return value;
  }
  // 1. Let className be StringValue of BindingIdentifier.
  const className = StringValue(BindingIdentifier);
  // 2. Let value be ? ClassDefinitionEvaluation of ClassTail with arguments className and className.
  /* ReturnIfAbrupt */
  let _temp2 = yield* ClassDefinitionEvaluation(ClassTail, className, className);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const value = _temp2;
  // 3. Set value.[[SourceText]] to the source text matched by ClassDeclaration.
  value.SourceText = sourceTextMatchedBy(ClassDeclaration);
  // 4. Let env be the running execution context's LexicalEnvironment.
  const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 5. Perform ? InitializeBoundName(className, value, env).
  /* ReturnIfAbrupt */
  let _temp3 = yield* InitializeBoundName(className, value, env);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 6. Return value.
  return value;
}
BindingClassDeclarationEvaluation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-bindingclassdeclarationevaluation';
/** https://tc39.es/ecma262/#sec-class-definitions-runtime-semantics-evaluation */
//   ClassDeclaration : `class` BindingIdentifier ClassTAil
function* Evaluate_ClassDeclaration(ClassDeclaration) {
  /* ReturnIfAbrupt */
  let _temp4 = yield* BindingClassDeclarationEvaluation(ClassDeclaration);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 2. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
Evaluate_ClassDeclaration.section = 'https://tc39.es/ecma262/#sec-class-definitions-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-with-statement-runtime-semantics-evaluation */
//   WithStatement : `with` `(` Expression `)` Statement
function* Evaluate_WithStatement({
  Expression,
  Statement
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(Expression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let val be the result of evaluating Expression.
  const val = _temp;
  // 2. Let obj be ? ToObject(? GetValue(val)).
  /* ReturnIfAbrupt */
  let _temp3 = yield* GetValue(val);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  /* ReturnIfAbrupt */
  let _temp2 = ToObject(_temp3);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const obj = _temp2;
  // 3. Let oldEnv be the running execution context's LexicalEnvironment.
  const oldEnv = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 4. Let newEnv be NewObjectEnvironment(obj, true, oldEnv).
  const newEnv = new ObjectEnvironmentRecord(obj, Value.true, oldEnv);
  // 5. Set the running execution context's LexicalEnvironment to newEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = newEnv;
  // 6. Let C be the result of evaluating Statement.
  const C = EnsureCompletion(yield* Evaluate(Statement));
  // 7. Set the running execution context's LexicalEnvironment to oldEnv.
  surroundingAgent.runningExecutionContext.LexicalEnvironment = oldEnv;
  // 8. Return Completion(UpdateEmpty(C, undefined)).
  return Completion(UpdateEmpty(C, Value.undefined));
}
Evaluate_WithStatement.section = 'https://tc39.es/ecma262/#sec-with-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-module-semantics-runtime-semantics-evaluation */
// Module :
//   [empty]
//   ModuleBody
function* Evaluate_Module({
  ModuleBody
}) {
  if (!ModuleBody) {
    return NormalCompletion(Value.undefined);
  }
  return yield* Evaluate(ModuleBody);
}
Evaluate_Module.section = 'https://tc39.es/ecma262/#sec-module-semantics-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-module-semantics-runtime-semantics-evaluation */
// ModuleBody : ModuleItemList
function Evaluate_ModuleBody({
  ModuleItemList
}) {
  // TODO(ts): ModuleItemList might contain ImportDeclaration or ExportDeclaration which is not accepted by Evaluate_StatementList.
  // @ts-expect-error
  return Evaluate_StatementList(ModuleItemList);
}
Evaluate_ModuleBody.section = 'https://tc39.es/ecma262/#sec-module-semantics-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-module-semantics-runtime-semantics-evaluation */
// ModuleItem : ImportDeclaration
function Evaluate_ImportDeclaration(_ImportDeclaration) {
  // 1. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
Evaluate_ImportDeclaration.section = 'https://tc39.es/ecma262/#sec-module-semantics-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-exports-runtime-semantics-evaluation */
//   ExportDeclaration :
//     `export` ExportFromClause FromClause `;`
//     `export` NamedExports `;`
//     `export` VariableDeclaration
//     `export` Declaration
//     `export` `default` HoistableDeclaration
//     `export` `default` ClassDeclaration
//     `export` `default` AssignmentExpression `;`
function* Evaluate_ExportDeclaration(ExportDeclaration) {
  const {
    FromClause,
    NamedExports,
    VariableStatement,
    Declaration,
    default: isDefault,
    HoistableDeclaration,
    ClassDeclaration,
    AssignmentExpression
  } = ExportDeclaration;
  if (FromClause || NamedExports) {
    // 1. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
  if (VariableStatement) {
    // 1. Return the result of evaluating VariableStatement.
    return yield* Evaluate(VariableStatement);
  }
  if (Declaration) {
    // 1. Return the result of evaluating Declaration.
    return yield* Evaluate(ExportDeclaration.Declaration);
  }
  if (!isDefault) {
    /* node:coverage ignore next */
    throw new OutOfRange$1('Evaluate_ExportDeclaration', ExportDeclaration);
  }
  if (HoistableDeclaration) {
    // 1. Return the result of evaluating HoistableDeclaration.
    return yield* Evaluate(HoistableDeclaration);
  }
  if (ClassDeclaration) {
    /* ReturnIfAbrupt */
    let _temp = yield* BindingClassDeclarationEvaluation(ClassDeclaration);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // 1. Let value be ? BindingClassDeclarationEvaluation of ClassDeclaration.
    const value = _temp;
    // 2. Let className be the sole element of BoundNames of ClassDeclaration.
    const className = BoundNames(ClassDeclaration)[0];
    // If className is "*default*", then
    if (className.stringValue() === '*default*') {
      // a. Let env be the running execution context's LexicalEnvironment.
      const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
      // b. Perform ? InitializeBoundName("*default*", value, env).
      /* ReturnIfAbrupt */
      let _temp2 = yield* InitializeBoundName(Value('*default*'), value, env);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    }
    // 3. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
  if (AssignmentExpression) {
    let value;
    // 1. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then
    if (IsAnonymousFunctionDefinition(AssignmentExpression)) {
      // a. Let value be NamedEvaluation of AssignmentExpression with argument "default".
      value = yield* NamedEvaluation(AssignmentExpression, Value('default'));
    } else {
      /* ReturnIfAbrupt */
      let _temp3 = yield* Evaluate(AssignmentExpression);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // 2. Else,
      // a. Let rhs be the result of evaluating AssignmentExpression.
      const rhs = _temp3;
      // a. Let value be ? GetValue(rhs).
      /* ReturnIfAbrupt */
      let _temp4 = yield* GetValue(rhs);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      value = _temp4;
    }
    // 3. Let env be the running execution context's LexicalEnvironment.
    const env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    // 4. Perform ? InitializeBoundName("*default*", value, env).
    /* ReturnIfAbrupt */
    let _temp5 = yield* InitializeBoundName(Value('*default*'), value, env);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // 5. Return NormalCompletion(empty).
    return NormalCompletion(undefined);
  }
  /* node:coverage ignore next */
  throw new OutOfRange$1('Evaluate_ExportDeclaration', ExportDeclaration);
}
Evaluate_ExportDeclaration.section = 'https://tc39.es/ecma262/#sec-exports-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-optional-chaining-evaluation */
//   OptionalExpression :
//     MemberExpression OptionalChain
//     CallExpression OptionalChain
//     OptionalExpression OptionalChain
function* Evaluate_OptionalExpression({
  MemberExpression,
  OptionalChain
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(MemberExpression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let baseReference be the result of evaluating MemberExpression.
  const baseReference = _temp;
  // 2. Let baseValue be ? GetValue(baseReference).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(baseReference);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const baseValue = _temp2;
  // 3. If baseValue is undefined or null, then
  if (baseValue === Value.undefined || baseValue === Value.null) {
    // a. Return undefined.
    return Value.undefined;
  }
  // 4. Return the result of performing ChainEvaluation of OptionalChain with arguments baseValue and baseReference.
  /* X */
  let _temp3 = baseReference;
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! baseReference returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  return yield* ChainEvaluation(OptionalChain, baseValue, _temp3);
}
Evaluate_OptionalExpression.section = 'https://tc39.es/ecma262/#sec-optional-chaining-evaluation';
/** https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation */
//   OptionalChain :
//     `?.` Arguments
//     `?.` `[` Expression `]`
//     `?.` IdentifierName
//     `?.` PrivateIdentifier
//     OptionalChain Arguments
//     OptionalChain `[` Expression `]`
//     OptionalChain `.` IdentifierName
//     OptionalChain `.` PrivateIdentifier
function* ChainEvaluation(node, baseValue, baseReference) {
  const {
    OptionalChain,
    Arguments,
    Expression,
    IdentifierName,
    PrivateIdentifier
  } = node;
  if (Arguments) {
    if (OptionalChain) {
      // 1. Let optionalChain be OptionalChain.
      const optionalChain = OptionalChain;
      // 2. Let newReference be ? ChainEvaluation of optionalChain with arguments baseValue and baseReference.
      /* ReturnIfAbrupt */
      let _temp4 = yield* ChainEvaluation(optionalChain, baseValue, baseReference);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      const newReference = _temp4;
      // 3. Let newValue be ? GetValue(newReference).
      /* ReturnIfAbrupt */
      let _temp5 = yield* GetValue(newReference);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) return _temp5;
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      const newValue = _temp5;
      // 5. Let tailCall be IsInTailPosition(thisChain).
      const tailCall = IsInTailPosition();
      // 6. Return ? EvaluateCall(newValue, newReference, Arguments, tailCall).
      return yield* EvaluateCall(newValue, newReference, Arguments, tailCall);
    }
    // 2. Let tailCall be IsInTailPosition(thisChain).
    const tailCall = IsInTailPosition();
    // 3. Return ? EvaluateCall(baseValue, baseReference, Arguments, tailCall).
    return yield* EvaluateCall(baseValue, baseReference, Arguments, tailCall);
  }
  if (Expression) {
    if (OptionalChain) {
      // 1. Let optionalChain be OptionalChain.
      const optionalChain = OptionalChain;
      // 2. Let newReference be ? ChainEvaluation of optionalChain with arguments baseValue and baseReference.
      /* ReturnIfAbrupt */
      let _temp6 = yield* ChainEvaluation(optionalChain, baseValue, baseReference);
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) return _temp6;
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      const newReference = _temp6;
      // 3. Let newValue be ? GetValue(newReference).
      /* ReturnIfAbrupt */
      let _temp7 = yield* GetValue(newReference);
      /* node:coverage ignore next */
      if (_temp7 instanceof AbruptCompletion) return _temp7;
      /* node:coverage ignore next */
      if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
      const newValue = _temp7;
      // 4. If the code matched by this OptionalChain is strict mode code, let strict be true; else let strict be false.
      const strict = node.strict;
      // 5. Return ? EvaluatePropertyAccessWithExpressionKey(newValue, Expression, strict).
      return yield* EvaluatePropertyAccessWithExpressionKey(newValue, Expression, strict);
    }
    // 1. If the code matched by this OptionalChain is strict mode code, let strict be true; else let strict be false.
    const strict = node.strict;
    // 2. Return ? EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict).
    return yield* EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict);
  }
  if (IdentifierName) {
    if (OptionalChain) {
      // 1. Let optionalChain be OptionalChain.
      const optionalChain = OptionalChain;
      // 2. Let newReference be ? ChainEvaluation of optionalChain with arguments baseValue and baseReference.
      /* ReturnIfAbrupt */
      let _temp8 = yield* ChainEvaluation(optionalChain, baseValue, baseReference);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) return _temp8;
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
      const newReference = _temp8;
      // 3. Let newValue be ? GetValue(newReference).
      /* ReturnIfAbrupt */
      let _temp9 = yield* GetValue(newReference);
      /* node:coverage ignore next */
      if (_temp9 instanceof AbruptCompletion) return _temp9;
      /* node:coverage ignore next */
      if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
      const newValue = _temp9;
      // 4. If the code matched by this OptionalChain is strict mode code, let strict be true; else let strict be false.
      const strict = node.strict;
      // 5. Return ! EvaluatePropertyAccessWithIdentifierKey(newValue, IdentifierName, strict).
      /* X */
      let _temp10 = EvaluatePropertyAccessWithIdentifierKey(newValue, IdentifierName, strict);
      /* node:coverage ignore next */
      if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
      /* node:coverage ignore next */
      if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! EvaluatePropertyAccessWithIdentifierKey(newValue, IdentifierName, strict) returned an abrupt completion", {
        cause: _temp10
      });
      /* node:coverage ignore next */
      if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
      return _temp10;
    }
    // 1. If the code matched by this OptionalChain is strict mode code, let strict be true; else let strict be false.
    const strict = node.strict;
    // 2. Return ! EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict).
    /* X */
    let _temp11 = EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict);
    /* node:coverage ignore next */
    if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    return _temp11;
  }
  if (PrivateIdentifier) {
    if (OptionalChain) {
      // 1. Let optionalChain be OptionalChain.
      const optionalChain = OptionalChain;
      // 2. Let newReference be ? ChainEvaluation of optionalChain with arguments baseValue and baseReference.
      /* ReturnIfAbrupt */
      let _temp12 = yield* ChainEvaluation(optionalChain, baseValue, baseReference);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      const newReference = _temp12;
      // 3. Let newValue be ? GetValue(newReference).
      /* ReturnIfAbrupt */
      let _temp13 = yield* GetValue(newReference);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      const newValue = _temp13;
      // 4. Let fieldNameString be the StringValue of PrivateIdentifier.
      const fieldNameString = StringValue(PrivateIdentifier);
      // 5. Return ! MakePrivateReference(nv, fieldNameString).
      /* X */
      let _temp14 = MakePrivateReference(newValue, fieldNameString);
      /* node:coverage ignore next */
      if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
      /* node:coverage ignore next */
      if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! MakePrivateReference(newValue, fieldNameString) returned an abrupt completion", {
        cause: _temp14
      });
      /* node:coverage ignore next */
      if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
      return _temp14;
    }
    // 1. Let fieldNameString be the StringValue of PrivateIdentifier.
    const fieldNameString = StringValue(PrivateIdentifier);
    // 2. Return ! MakePrivateReference(bv, fieldNameString).
    /* X */
    let _temp15 = MakePrivateReference(baseValue, fieldNameString);
    /* node:coverage ignore next */
    if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! MakePrivateReference(baseValue, fieldNameString) returned an abrupt completion", {
      cause: _temp15
    });
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    return _temp15;
  }
  /* node:coverage ignore next */
  throw new OutOfRange$1('ChainEvaluation', node);
}
ChainEvaluation.section = 'https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation';

/** https://tc39.es/ecma262/#sec-tagged-templates-runtime-semantics-evaluation */
//   MemberExpression :
//     MemberExpression TemplateLiteral
function* Evaluate_TaggedTemplateExpression(node) {
  const {
    MemberExpression,
    TemplateLiteral
  } = node;
  // 1. Let tagRef be ? Evaluation of MemberExpression.
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(MemberExpression);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const tagRef = _temp;
  // 1. Let tagFunc be ? GetValue(tagRef).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(tagRef);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const tagFunc = _temp2;
  // 1. Let tailCall be IsInTailPosition(thisCall).
  const tailCall = IsInTailPosition();
  // 1. Return ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall).
  return yield* EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall);
}
Evaluate_TaggedTemplateExpression.section = 'https://tc39.es/ecma262/#sec-tagged-templates-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-getsubstitution */
function* GetSubstitution(matched, str, position, captures, namedCaptures, replacementTemplate) {
  const stringLength = str.stringValue().length;
  Assert(position <= stringLength, "position <= stringLength");
  const result = [];
  let templateRemainder = replacementTemplate.stringValue();
  let ref;
  let refReplacement;
  while (templateRemainder.length) {
    if (templateRemainder.startsWith('$$')) {
      ref = '$$';
      refReplacement = '$';
    } else if (templateRemainder.startsWith('$`')) {
      ref = '$`';
      refReplacement = str.stringValue().slice(0, position);
    } else if (templateRemainder.startsWith('$&')) {
      ref = '$&';
      refReplacement = matched.stringValue();
    } else if (templateRemainder.startsWith("$'")) {
      ref = "$'";
      const matchLength = matched.stringValue().length;
      const tailPos = position + matchLength;
      refReplacement = str.stringValue().slice(Math.min(tailPos, stringLength));
    } else if (templateRemainder.match(/^\$\d+/)) {
      let digitCount = templateRemainder.match(/^\$\d\d/) ? 2 : 1;
      let digits = templateRemainder.slice(1, 1 + digitCount);
      let index = parseInt(digits, 10);
      Assert(index >= 0 && index <= 99, "index >= 0 && index <= 99");
      const captureLen = captures.length;
      if (index > captureLen && digitCount === 2) {
        digitCount = 1;
        digits = digits[0];
        index = parseInt(digits, 10);
      }
      ref = templateRemainder.slice(0, 1 + digitCount);
      if (index >= 1 && index <= captureLen) {
        const capture = captures[index - 1];
        if (capture instanceof UndefinedValue) {
          refReplacement = '';
        } else {
          refReplacement = capture.stringValue();
        }
      } else {
        refReplacement = ref;
      }
    } else if (templateRemainder.startsWith('$<')) {
      const gtPos = templateRemainder.indexOf('>', 0);
      if (gtPos === -1 || namedCaptures instanceof UndefinedValue) {
        ref = '$<';
        refReplacement = ref;
      } else {
        ref = templateRemainder.slice(0, gtPos + 1);
        const groupName = templateRemainder.slice(2, gtPos);
        Assert(namedCaptures instanceof ObjectValue, "namedCaptures instanceof ObjectValue");
        /* ReturnIfAbrupt */
        let _temp = yield* Get(namedCaptures, Value(groupName));
        /* node:coverage ignore next */
        if (_temp instanceof AbruptCompletion) return _temp;
        /* node:coverage ignore next */
        if (_temp instanceof Completion) _temp = _temp.Value;
        const capture = _temp;
        if (capture instanceof UndefinedValue) {
          refReplacement = '';
        } else {
          /* ReturnIfAbrupt */
          let _temp2 = yield* ToString(capture);
          /* node:coverage ignore next */
          if (_temp2 instanceof AbruptCompletion) return _temp2;
          /* node:coverage ignore next */
          if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
          refReplacement = _temp2.stringValue();
        }
      }
    } else {
      ref = templateRemainder[0];
      refReplacement = ref;
    }
    const refLength = ref.length;
    templateRemainder = templateRemainder.slice(refLength);
    result.push(refReplacement);
  }
  let result_str;
  try {
    result_str = result.join('');
  } catch (e) {
    // test262/test/staging/sm/String/replace-math.js
    return surroundingAgent.Throw('RangeError', 'OutOfRange', 'String too long');
  }
  return Value(result_str);
}
GetSubstitution.section = 'https://tc39.es/ecma262/#sec-getsubstitution';

/** https://tc39.es/ecma262/#sec-continue-statement-runtime-semantics-evaluation */
//   ContinueStatement :
//     `continue` `;`
//     `continue` LabelIdentifier `;`
function Evaluate_ContinueStatement({
  LabelIdentifier
}) {
  if (!LabelIdentifier) {
    // 1. Return Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: empty }.
    return new Completion({
      Type: 'continue',
      Value: undefined,
      Target: undefined
    });
  }
  // 1. Let label be the StringValue of LabelIdentifier.
  const label = StringValue(LabelIdentifier);
  // 2. Return Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: label }.
  return new Completion({
    Type: 'continue',
    Value: undefined,
    Target: label
  });
}
Evaluate_ContinueStatement.section = 'https://tc39.es/ecma262/#sec-continue-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-labelled-statements-runtime-semantics-evaluation */
function Evaluate_LabelledStatement(LabelledStatement) {
  // 1. Let newLabelSet be a new empty List.
  const newLabelSet = new JSStringSet();
  // 2. Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.
  return LabelledEvaluation(LabelledStatement, newLabelSet);
}
Evaluate_LabelledStatement.section = 'https://tc39.es/ecma262/#sec-labelled-statements-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-runtime-semantics-mv-s */
//   StringNumericLiteral :::
//     [empty]
//     StrWhiteSpace
//     StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt
function MV_StringNumericLiteral(StringNumericLiteral) {
  return F(Number(StringNumericLiteral));
}
MV_StringNumericLiteral.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-mv-s';

/** https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator */
function* ApplyStringOrNumericBinaryOperator(lval, opText, rval) {
  // 1. If opText is +, then
  if (opText === '+') {
    /* ReturnIfAbrupt */
    let _temp = yield* ToPrimitive(lval);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // a. Let lprim be ? ToPrimitive(lval).
    const lprim = _temp;
    // b. Let rprim be ? ToPrimitive(rval).
    /* ReturnIfAbrupt */
    let _temp2 = yield* ToPrimitive(rval);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const rprim = _temp2;
    // c. If Type(lprim) is String or Type(rprim) is String, then
    if (lprim instanceof JSStringValue || rprim instanceof JSStringValue) {
      /* ReturnIfAbrupt */
      let _temp3 = yield* ToString(lprim);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // i. Let lstr be ? ToString(lprim).
      const lstr = _temp3;
      // ii. Let rstr be ? ToString(rprim).
      /* ReturnIfAbrupt */
      let _temp4 = yield* ToString(rprim);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      const rstr = _temp4;
      // iii. Return the string-concatenation of lstr and rstr.
      return Value(lstr.stringValue() + rstr.stringValue());
    }
    // d. Set lval to lprim.
    lval = lprim;
    // e. Set rval to rprim.
    rval = rprim;
  }
  // 2. NOTE: At this point, it must be a numeric operation.
  // 3. Let lnum be ? ToNumeric(lval).
  /* ReturnIfAbrupt */
  let _temp5 = yield* ToNumeric(lval);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const lnum = _temp5;
  // 4. Let rnum be ? ToNumeric(rval).
  /* ReturnIfAbrupt */
  let _temp6 = yield* ToNumeric(rval);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const rnum = _temp6;
  // 5. If SameType(lNum, rNum) is false, throw a TypeError exception.
  if (!SameType(lnum, rnum)) {
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  }
  if (lnum instanceof BigIntValue) {
    const operations = {
      '**': BigIntValue.exponentiate,
      '*': BigIntValue.multiply,
      '/': BigIntValue.divide,
      '%': BigIntValue.remainder,
      '+': BigIntValue.add,
      '-': BigIntValue.subtract,
      '<<': BigIntValue.leftShift,
      '>>': BigIntValue.signedRightShift,
      '>>>': BigIntValue.unsignedRightShift,
      '&': BigIntValue.bitwiseAND,
      '^': BigIntValue.bitwiseXOR,
      '|': BigIntValue.bitwiseOR
    };
    return operations[opText](lnum, rnum);
  } else {
    Assert(lnum instanceof NumberValue, "lnum instanceof NumberValue");
    const operations = {
      '**': NumberValue.exponentiate,
      '*': NumberValue.multiply,
      '/': NumberValue.divide,
      '%': NumberValue.remainder,
      '+': NumberValue.add,
      '-': NumberValue.subtract,
      '<<': NumberValue.leftShift,
      '>>': NumberValue.signedRightShift,
      '>>>': NumberValue.unsignedRightShift,
      '&': NumberValue.bitwiseAND,
      '^': NumberValue.bitwiseXOR,
      '|': NumberValue.bitwiseOR
    };
    return operations[opText](lnum, rnum);
  }
}
ApplyStringOrNumericBinaryOperator.section = 'https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator';

/** https://tc39.es/ecma262/#sec-evaluatestringornumericbinaryexpression */
function* EvaluateStringOrNumericBinaryExpression(leftOperand, opText, rightOperand) {
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate(leftOperand);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let lref be the result of evaluating leftOperand.
  const lref = _temp;
  // 2. Let lval be ? GetValue(lref).
  /* ReturnIfAbrupt */
  let _temp2 = yield* GetValue(lref);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const lval = _temp2;
  // 3. Let rref be the result of evaluating rightOperand.
  /* ReturnIfAbrupt */
  let _temp3 = yield* Evaluate(rightOperand);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const rref = _temp3;
  // 4. Let rval be ? GetValue(rref).
  /* ReturnIfAbrupt */
  let _temp4 = yield* GetValue(rref);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const rval = _temp4;
  // 5. Return ? ApplyStringOrNumericBinaryOperator(lval, opText, rval).
  return yield* ApplyStringOrNumericBinaryOperator(lval, opText, rval);
}
EvaluateStringOrNumericBinaryExpression.section = 'https://tc39.es/ecma262/#sec-evaluatestringornumericbinaryexpression';

/** https://tc39.es/ecma262/#sec-meta-properties */
//   ImportMeta : `import` `.` `meta`
function Evaluate_ImportMeta(_ImportMeta) {
  /* X */
  let _temp = GetActiveScriptOrModule();
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! GetActiveScriptOrModule() returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let module be ! GetActiveScriptOrModule().
  const module = _temp;
  // 2. Assert: module is a Source Text Module Record.
  Assert(module instanceof SourceTextModuleRecord, "module instanceof SourceTextModuleRecord");
  // 3. Let importMeta be module.[[ImportMeta]].
  let importMeta = module.ImportMeta;
  // 4. If importMeta is empty, then
  if (importMeta === undefined) {
    /* X */
    let _temp2 = OrdinaryObjectCreate(Value.null);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(Value.null) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // a. Set importMeta to ! OrdinaryObjectCreate(null).
    importMeta = _temp2;
    // b. Let importMetaValues be ! HostGetImportMetaProperties(module).
    /* X */
    let _temp3 = HostGetImportMetaProperties(module);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! HostGetImportMetaProperties(module) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const importMetaValues = _temp3;
    // c. For each Record { [[Key]], [[Value]] } p that is an element of importMetaValues, do
    for (const p of importMetaValues) {
      /* X */
      let _temp4 = CreateDataPropertyOrThrow(importMeta, p.Key, p.Value);
      /* node:coverage ignore next */
      if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(importMeta, p.Key, p.Value) returned an abrupt completion", {
        cause: _temp4
      });
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    }
    // d. Perform ! HostFinalizeImportMeta(importMeta, module).
    /* X */
    let _temp5 = HostFinalizeImportMeta(importMeta, module);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! HostFinalizeImportMeta(importMeta, module) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // e. Set module.[[ImportMeta]] to importMeta.
    module.ImportMeta = importMeta;
    // f. Return importMeta.
    return importMeta;
  } else {
    // 5. Else,
    // a. Assert: Type(importMeta) is Object.
    Assert(importMeta instanceof ObjectValue, "importMeta instanceof ObjectValue");
    // b. Return importMeta.
    return importMeta;
  }
}
Evaluate_ImportMeta.section = 'https://tc39.es/ecma262/#sec-meta-properties';

/** https://tc39.es/ecma262/#sec-debugger-statement-runtime-semantics-evaluation */
// DebuggerStatement : `debugger` `;`
function* Evaluate_DebuggerStatement(_node) {
  // 1. If an implementation-defined debugging facility is available and enabled, then
  if (surroundingAgent.hostDefinedOptions.onDebugger) {
    // a. Perform an implementation-defined debugging action.
    // b. Let result be an implementation-defined Completion value.
    const completion = yield {
      type: 'debugger'
    };
    Assert(completion.type === 'debugger-resume', "completion.type === 'debugger-resume'");
    return completion.value;
  }
  // 2. Return result.
  return NormalCompletion(undefined);
}
Evaluate_DebuggerStatement.section = 'https://tc39.es/ecma262/#sec-debugger-statement-runtime-semantics-evaluation';

/** https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization */
// BindingPropertyList : BIndingPropertyList `,` BindingProperty
// BindingProperty :
//   SingleNameBinding
//   PropertyName `:` BindingElement
function* PropertyBindingInitialization(node, value, environment) {
  if (isArray(node)) {
    // 1. Let boundNames be ? PropertyBindingInitialization of BindingPropertyList with arguments value and environment.
    // 2. Let nextNames be ? PropertyBindingInitialization of BindingProperty with arguments value and environment.
    // 3. Append each item in nextNames to the end of boundNames.
    // 4. Return boundNames.
    const boundNames = [];
    for (const item of node) {
      /* ReturnIfAbrupt */
      let _temp = yield* PropertyBindingInitialization(item, value, environment);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) return _temp;
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      const nextNames = _temp;
      boundNames.push(...nextNames);
    }
    return boundNames;
  }
  if ('PropertyName' in node && node.PropertyName) {
    // 1. Let P be the result of evaluating PropertyName.
    let P = yield* Evaluate_PropertyName(node.PropertyName);
    // 2. ReturnIfAbrupt(P).
    /* ReturnIfAbrupt */
    /* node:coverage ignore next */
    if (P && typeof P === 'object' && 'next' in P) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (P instanceof AbruptCompletion) return P;
    /* node:coverage ignore next */
    if (P instanceof Completion) P = P.Value;
    // 3. Perform ? KeyedBindingInitialization of BindingElement with value, environment, and P as the arguments.
    /* ReturnIfAbrupt */
    let _temp2 = yield* KeyedBindingInitialization(node.BindingElement, value, environment, P);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // 4. Return a new List containing P.
    return [P];
  } else {
    // 1. Let name be the string that is the only element of BoundNames of SingleNameBinding.
    const name = BoundNames(node)[0];
    // 2. Perform ? KeyedBindingInitialization for SingleNameBinding using value, environment, and name as the arguments.
    /* ReturnIfAbrupt */
    let _temp3 = yield* KeyedBindingInitialization(node, value, environment, name);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // 3. Return a new List containing name.
    return [name];
  }
}
PropertyBindingInitialization.section = 'https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization';

/** https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization */
function* KeyedBindingInitialization(node, value, environment, propertyName) {
  if (node.type === 'BindingElement') {
    /* ReturnIfAbrupt */
    let _temp = yield* GetV(value, propertyName);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // 1. Let v be ? GetV(value, propertyName).
    let v = _temp;
    // 2. If Initializer is present and v is undefined, then
    if (node.Initializer && v === Value.undefined) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* Evaluate(node.Initializer);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      // a. Let defaultValue be the result of evaluating Initializer.
      const defaultValue = _temp2;
      // b. Set v to ? GetValue(defaultValue).
      /* ReturnIfAbrupt */
      let _temp3 = yield* GetValue(defaultValue);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      v = _temp3;
    }
    // 2. Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.
    return yield* BindingInitialization(node.BindingPattern, v, environment);
  } else {
    // 1. Let bindingId be StringValue of BindingIdentifier.
    const bindingId = StringValue(node.BindingIdentifier);
    // 2. Let lhs be ? ResolveBinding(bindingId, environment).
    /* ReturnIfAbrupt */
    let _temp4 = yield* ResolveBinding(bindingId, environment, node.BindingIdentifier.strict);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    const lhs = _temp4;
    // 3. Let v be ? GetV(value, propertyName).
    /* ReturnIfAbrupt */
    let _temp5 = yield* GetV(value, propertyName);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    let v = _temp5;
    if (node.Initializer && v === Value.undefined) {
      // a. If IsAnonymousFunctionDefinition(Initializer) is true, then
      if (IsAnonymousFunctionDefinition(node.Initializer)) {
        // i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.
        v = yield* NamedEvaluation(node.Initializer, bindingId);
      } else {
        /* ReturnIfAbrupt */
        let _temp6 = yield* Evaluate(node.Initializer);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        // b. Else,
        // i. Let defaultValue be the result of evaluating Initializer.
        const defaultValue = _temp6;
        // ii. Set v to ? GetValue(defaultValue).
        /* ReturnIfAbrupt */
        let _temp7 = yield* GetValue(defaultValue);
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) return _temp7;
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        v = _temp7;
      }
    }
    // 5. If environment is undefined, return ? PutValue(lhs, v).
    if (environment === Value.undefined) {
      return yield* PutValue(lhs, v);
    }
    // 6. Return InitializeReferencedBinding(lhs, v).
    return yield* InitializeReferencedBinding(lhs, v);
  }
}
KeyedBindingInitialization.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization';

// ObjectAssignmentPattern :
//  `{` `}`
//  `{` AssignmentPropertyList `}`
//  `{` AssignmentPropertyList `,` `}`
//  `{` AssignmentPropertyList `,` AssignmentRestProperty? `}`
function* DestructuringAssignmentEvaluation_ObjectAssignmentPattern({
  AssignmentPropertyList,
  AssignmentRestProperty
}, value) {
  /* ReturnIfAbrupt */
  let _temp = RequireObjectCoercible(value);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 2. Perform ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.
  /* ReturnIfAbrupt */
  let _temp2 = yield* PropertyDestructuringAssignmentEvaluation(AssignmentPropertyList, value);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const excludedNames = _temp2;
  if (AssignmentRestProperty) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* RestDestructuringAssignmentEvaluation(AssignmentRestProperty, value, excludedNames);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }
  // 3. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}

/** https://tc39.es/ecma262/#sec-runtime-semantics-restdestructuringassignmentevaluation */
// AssignmentRestProperty : `...` DestructuringAssignmentTarget
function* RestDestructuringAssignmentEvaluation({
  DestructuringAssignmentTarget
}, value, excludedNames) {
  /* ReturnIfAbrupt */
  let _temp4 = yield* Evaluate(DestructuringAssignmentTarget);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 1. Let lref be the result of evaluating DestructuringAssignmentTarget.
  let lref = _temp4;
  // 2. ReturnIfAbrupt(lref).
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (lref && typeof lref === 'object' && 'next' in lref) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (lref instanceof AbruptCompletion) return lref;
  /* node:coverage ignore next */
  if (lref instanceof Completion) lref = lref.Value;
  // 3. Let restObj be OrdinaryObjectCreate(%Object.prototype%).
  const restObj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  // 4. Perform ? CopyDataProperties(restObj, value, excludedNames).
  /* ReturnIfAbrupt */
  let _temp5 = yield* CopyDataProperties(restObj, value, excludedNames);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 5. Return PutValue(lref, restObj).
  return yield* PutValue(lref, restObj);
}
RestDestructuringAssignmentEvaluation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-restdestructuringassignmentevaluation';
function* PropertyDestructuringAssignmentEvaluation(AssignmentPropertyList, value) {
  const propertyNames = [];
  for (const AssignmentProperty of AssignmentPropertyList) {
    if ('IdentifierReference' in AssignmentProperty) {
      // 1. Let P be StringValue of IdentifierReference.
      const P = StringValue(AssignmentProperty.IdentifierReference);
      // 2. Let lref be ? ResolveBinding(P).
      /* ReturnIfAbrupt */
      let _temp6 = yield* ResolveBinding(P, undefined, AssignmentProperty.IdentifierReference.strict);
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) return _temp6;
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      const lref = _temp6;
      // 3. Let v be ? GetV(value, P).
      /* ReturnIfAbrupt */
      let _temp7 = yield* GetV(value, P);
      /* node:coverage ignore next */
      if (_temp7 instanceof AbruptCompletion) return _temp7;
      /* node:coverage ignore next */
      if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
      let v = _temp7;
      // 4. If Initializer? is present and v is undefined, then
      if (AssignmentProperty.Initializer && v === Value.undefined) {
        // a. If IsAnonymousFunctionDefinition(Initializer) is true, then
        if (IsAnonymousFunctionDefinition(AssignmentProperty.Initializer)) {
          /* ReturnIfAbrupt */
          let _temp8 = yield* NamedEvaluation(AssignmentProperty.Initializer, P);
          /* node:coverage ignore next */
          if (_temp8 instanceof AbruptCompletion) return _temp8;
          /* node:coverage ignore next */
          if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
          // i. Set v to the result of performing NamedEvaluation for Initializer with argument P.
          v = _temp8;
        } else {
          /* ReturnIfAbrupt */
          let _temp9 = yield* Evaluate(AssignmentProperty.Initializer);
          /* node:coverage ignore next */
          if (_temp9 instanceof AbruptCompletion) return _temp9;
          /* node:coverage ignore next */
          if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
          // b. Else,
          // i. Let defaultValue be the result of evaluating Initializer.
          const defaultValue = _temp9;
          // ii. Set v to ? GetValue(defaultValue)
          /* ReturnIfAbrupt */
          let _temp10 = yield* GetValue(defaultValue);
          /* node:coverage ignore next */
          if (_temp10 instanceof AbruptCompletion) return _temp10;
          /* node:coverage ignore next */
          if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
          v = _temp10;
        }
      }
      // 5. Perform ? PutValue(lref, v).
      /* ReturnIfAbrupt */
      let _temp11 = yield* PutValue(lref, v);
      /* node:coverage ignore next */
      if (_temp11 instanceof AbruptCompletion) return _temp11;
      /* node:coverage ignore next */
      if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
      // 6. Return a new List containing P.
      propertyNames.push(P);
    } else {
      Assert('PropertyName' in AssignmentProperty, "'PropertyName' in AssignmentProperty");
      // 1. Let name be the result of evaluating PropertyName.
      let name = yield* Evaluate_PropertyName(AssignmentProperty.PropertyName);
      // 2. ReturnIfAbrupt(name).
      /* ReturnIfAbrupt */
      /* node:coverage ignore next */
      if (name && typeof name === 'object' && 'next' in name) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (name instanceof AbruptCompletion) return name;
      /* node:coverage ignore next */
      if (name instanceof Completion) name = name.Value;
      // 3. Perform ? KeyedDestructuringAssignmentEvaluation of AssignmentElement with value and name as the arguments.
      /* ReturnIfAbrupt */
      let _temp12 = yield* KeyedDestructuringAssignmentEvaluation(AssignmentProperty.AssignmentElement, value, name);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      // 4. Return a new List containing name.
      propertyNames.push(name);
    }
  }
  return propertyNames;
}

// AssignmentElement : DestructuringAssignmentTarget Initializer?
function* KeyedDestructuringAssignmentEvaluation({
  DestructuringAssignmentTarget,
  Initializer
}, value, propertyName) {
  // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
  let lref;
  if (DestructuringAssignmentTarget.type !== 'ObjectLiteral' && DestructuringAssignmentTarget.type !== 'ArrayLiteral') {
    /* ReturnIfAbrupt */
    let _temp13 = yield* Evaluate(DestructuringAssignmentTarget);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) return _temp13;
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.
    lref = _temp13;
  }
  // 2. Let v be ? GetV(value, propertyName).
  /* ReturnIfAbrupt */
  let _temp14 = yield* GetV(value, propertyName);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const v = _temp14;
  // 3. If Initializer is present and v is undefined, then
  let rhsValue;
  if (Initializer && v === Value.undefined) {
    // a. If IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then
    if (IsAnonymousFunctionDefinition(Initializer) && IsIdentifierRef(DestructuringAssignmentTarget)) {
      /* ReturnIfAbrupt */
      let _temp15 = yield* NamedEvaluation(Initializer, lref.ReferencedName);
      /* node:coverage ignore next */
      if (_temp15 instanceof AbruptCompletion) return _temp15;
      /* node:coverage ignore next */
      if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
      // i. Let rhsValue be NamedEvaluation of Initializer with argument GetReferencedName(lref).
      rhsValue = _temp15;
    } else {
      /* ReturnIfAbrupt */
      let _temp16 = yield* Evaluate(Initializer);
      /* node:coverage ignore next */
      if (_temp16 instanceof AbruptCompletion) return _temp16;
      /* node:coverage ignore next */
      if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
      // i. Let defaultValue be the result of evaluating Initializer.
      const defaultValue = _temp16;
      // ii. Let rhsValue be ? GetValue(defaultValue).
      /* ReturnIfAbrupt */
      let _temp17 = yield* GetValue(defaultValue);
      /* node:coverage ignore next */
      if (_temp17 instanceof AbruptCompletion) return _temp17;
      /* node:coverage ignore next */
      if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
      rhsValue = _temp17;
    }
  } else {
    // 4. Else, let rhsValue be v.
    rhsValue = v;
  }
  // 5. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
  if (DestructuringAssignmentTarget.type === 'ObjectLiteral' || DestructuringAssignmentTarget.type === 'ArrayLiteral') {
    // a. Let assignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
    const assignmentPattern = refineLeftHandSideExpression(DestructuringAssignmentTarget);
    // b. Return the result of performing DestructuringAssignmentEvaluation of assignmentPattern with rhsValue as the argument.
    /* X */
    let _temp18 = rhsValue;
    /* node:coverage ignore next */
    if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! rhsValue returned an abrupt completion", {
      cause: _temp18
    });
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    return yield* DestructuringAssignmentEvaluation(assignmentPattern, _temp18);
  }
  // 6. Return ? PutValue(lref, rhsValue).
  /* X */
  let _temp19 = lref;
  /* node:coverage ignore next */
  if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! lref returned an abrupt completion", {
    cause: _temp19
  });
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  return yield* PutValue(_temp19, rhsValue);
}

// ArrayAssignmentPattern :
//   `[` `]`
//   `[` AssignmentElementList `]`
//   `[` AssignmentElementList `,` AssignmentRestElement? `]`
function* DestructuringAssignmentEvaluation_ArrayAssignmentPattern({
  AssignmentElementList,
  AssignmentRestElement
}, value) {
  /* ReturnIfAbrupt */
  let _temp20 = yield* GetIterator(value, 'sync');
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  // 1. Let iteratorRecord be ? GetIterator(value).
  const iteratorRecord = _temp20;
  // 2. Let status be IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord.
  let status = EnsureCompletion(yield* IteratorDestructuringAssignmentEvaluation(AssignmentElementList, iteratorRecord));
  // 3. If status is an abrupt completion, then
  if (status instanceof AbruptCompletion) {
    // a. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, status).
    if (iteratorRecord.Done === Value.false) {
      return yield* IteratorClose(iteratorRecord, status);
    }
    // b. Return Completion(status).
    return status;
  }
  // 4. If Elision is present, then
  // ...
  // 5. If AssignmentRestElement is present, then
  if (AssignmentRestElement) {
    // a. Set status to the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with iteratorRecord as the argument.
    status = EnsureCompletion(yield* IteratorDestructuringAssignmentEvaluation(AssignmentRestElement, iteratorRecord));
  }
  // 6. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, status).
  if (iteratorRecord.Done === Value.false) {
    return yield* IteratorClose(iteratorRecord, status);
  }
  return Completion(status);
}
function* IteratorDestructuringAssignmentEvaluation(node, iteratorRecord) {
  if (Array.isArray(node)) {
    for (const n of node) {
      /* ReturnIfAbrupt */
      let _temp21 = yield* IteratorDestructuringAssignmentEvaluation(n, iteratorRecord);
      /* node:coverage ignore next */
      if (_temp21 instanceof AbruptCompletion) return _temp21;
      /* node:coverage ignore next */
      if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    }
    return NormalCompletion(undefined);
  }
  switch (node.type) {
    case 'Elision':
      // 1. If iteratorRecord.[[Done]] is false, then
      if (iteratorRecord.Done === Value.false) {
        /* ReturnIfAbrupt */
        let _temp22 = yield* IteratorStep(iteratorRecord);
        /* node:coverage ignore next */
        if (_temp22 instanceof AbruptCompletion) return _temp22;
        /* node:coverage ignore next */
        if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
      }
      // 2. Return NormalCompletion(empty).
      return NormalCompletion(undefined);
    case 'AssignmentElement':
      {
        const {
          DestructuringAssignmentTarget,
          Initializer
        } = node;
        let lref;
        // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
        if (DestructuringAssignmentTarget.type !== 'ObjectLiteral' && DestructuringAssignmentTarget.type !== 'ArrayLiteral') {
          /* ReturnIfAbrupt */
          let _temp23 = yield* Evaluate(DestructuringAssignmentTarget);
          /* node:coverage ignore next */
          if (_temp23 instanceof AbruptCompletion) return _temp23;
          /* node:coverage ignore next */
          if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
          lref = _temp23;
        }
        let value = Value.undefined;
        // 2. If iteratorRecord.[[Done]] is false, then
        if (iteratorRecord.Done === Value.false) {
          /* ReturnIfAbrupt */
          let _temp24 = yield* IteratorStepValue(iteratorRecord);
          /* node:coverage ignore next */
          if (_temp24 instanceof AbruptCompletion) return _temp24;
          /* node:coverage ignore next */
          if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
          // a. Let next be ? IteratorStepValue(iteratorRecord).
          const next = _temp24;
          // d. If next is not done, set value to next.
          if (next !== 'done') {
            value = next;
          }
        }
        let v;
        // 4. If Initializer is present and value is undefined, then
        if (Initializer && value === Value.undefined) {
          // a. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
          if (IsAnonymousFunctionDefinition(Initializer) && IsIdentifierRef(DestructuringAssignmentTarget)) {
            // i. Let target be the StringValue of DestructuringAssignmentTarget.
            const target = lref.ReferencedName;
            // i. ii. Let v be ? NamedEvaluation of Initializer with argument target.
            /* ReturnIfAbrupt */
            let _temp25 = yield* NamedEvaluation(Initializer, target);
            /* node:coverage ignore next */
            if (_temp25 instanceof AbruptCompletion) return _temp25;
            /* node:coverage ignore next */
            if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
            v = _temp25;
          } else {
            /* ReturnIfAbrupt */
            let _temp26 = yield* Evaluate(Initializer);
            /* node:coverage ignore next */
            if (_temp26 instanceof AbruptCompletion) return _temp26;
            /* node:coverage ignore next */
            if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
            // b. Else,
            // i. Let defaultValue be the result of evaluating Initializer.
            const defaultValue = _temp26;
            // ii. Let v be ? GetValue(defaultValue).
            /* ReturnIfAbrupt */
            let _temp27 = yield* GetValue(defaultValue);
            /* node:coverage ignore next */
            if (_temp27 instanceof AbruptCompletion) return _temp27;
            /* node:coverage ignore next */
            if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
            v = _temp27;
          }
        } else {
          /* ReturnIfAbrupt */
          /* node:coverage ignore next */
          if (value && typeof value === 'object' && 'next' in value) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (value instanceof AbruptCompletion) return value;
          /* node:coverage ignore next */
          if (value instanceof Completion) value = value.Value;
          // 5. Else, let v be value.
          v = value;
        }
        // 6. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
        if (DestructuringAssignmentTarget.type === 'ObjectLiteral' || DestructuringAssignmentTarget.type === 'ArrayLiteral') {
          // a. Let nestedAssignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
          const nestedAssignmentPattern = refineLeftHandSideExpression(DestructuringAssignmentTarget);
          // b. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with v as the argument.
          /* X */
          let _temp28 = v;
          /* node:coverage ignore next */
          if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) _temp28 = skipDebugger(_temp28);
          /* node:coverage ignore next */
          if (_temp28 instanceof AbruptCompletion) throw new Assert.Error("! v returned an abrupt completion", {
            cause: _temp28
          });
          /* node:coverage ignore next */
          if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
          return yield* DestructuringAssignmentEvaluation(nestedAssignmentPattern, _temp28);
        }
        // 7. Return ? PutValue(lref, v).
        /* ReturnIfAbrupt */
        /* node:coverage ignore next */
        if (lref && typeof lref === 'object' && 'next' in lref) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (lref instanceof AbruptCompletion) return lref;
        /* node:coverage ignore next */
        if (lref instanceof Completion) lref = lref.Value;
        return yield* PutValue(lref, v);
      }
    case 'AssignmentRestElement':
      {
        const {
          AssignmentExpression: DestructuringAssignmentTarget
        } = node;
        let lref;
        // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
        if (DestructuringAssignmentTarget.type !== 'ObjectLiteral' && DestructuringAssignmentTarget.type !== 'ArrayLiteral') {
          lref = yield* Evaluate(DestructuringAssignmentTarget);
          /* ReturnIfAbrupt */
          /* node:coverage ignore next */
          if (lref && typeof lref === 'object' && 'next' in lref) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (lref instanceof AbruptCompletion) return lref;
          /* node:coverage ignore next */
          if (lref instanceof Completion) lref = lref.Value;
        }
        // 2. Let A be ! ArrayCreate(0).
        /* X */
        let _temp29 = ArrayCreate(0);
        /* node:coverage ignore next */
        if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) _temp29 = skipDebugger(_temp29);
        /* node:coverage ignore next */
        if (_temp29 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
          cause: _temp29
        });
        /* node:coverage ignore next */
        if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
        const A = _temp29;
        // 3. Let n be 0.
        let n = 0;
        // 4. Repeat, while iteratorRecord.[[Done]] is false,
        while (iteratorRecord.Done === Value.false) {
          /* ReturnIfAbrupt */
          let _temp30 = yield* IteratorStepValue(iteratorRecord);
          /* node:coverage ignore next */
          if (_temp30 instanceof AbruptCompletion) return _temp30;
          /* node:coverage ignore next */
          if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
          // a. Let next be IteratorStep(iteratorRecord).
          const next = _temp30;
          // d. If next is not done, then
          if (next !== 'done') {
            /* X */
            let _temp32 = ToString(F(n));
            /* node:coverage ignore next */
            if (_temp32 && typeof _temp32 === 'object' && 'next' in _temp32) _temp32 = skipDebugger(_temp32);
            /* node:coverage ignore next */
            if (_temp32 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
              cause: _temp32
            });
            /* node:coverage ignore next */
            if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
            /* X */
            let _temp33 = next;
            /* node:coverage ignore next */
            if (_temp33 && typeof _temp33 === 'object' && 'next' in _temp33) _temp33 = skipDebugger(_temp33);
            /* node:coverage ignore next */
            if (_temp33 instanceof AbruptCompletion) throw new Assert.Error("! next returned an abrupt completion", {
              cause: _temp33
            });
            /* node:coverage ignore next */
            if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
            /* X */
            let _temp31 = CreateDataPropertyOrThrow(A, _temp32, _temp33);
            /* node:coverage ignore next */
            if (_temp31 && typeof _temp31 === 'object' && 'next' in _temp31) _temp31 = skipDebugger(_temp31);
            /* node:coverage ignore next */
            if (_temp31 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(F(n))), X(next)) returned an abrupt completion", {
              cause: _temp31
            });
            /* node:coverage ignore next */
            if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
            // v. Set n to n + 1.
            n += 1;
          }
        }
        // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
        if (DestructuringAssignmentTarget.type !== 'ObjectLiteral' && DestructuringAssignmentTarget.type !== 'ArrayLiteral') {
          /* ReturnIfAbrupt */
          /* node:coverage ignore next */
          if (lref && typeof lref === 'object' && 'next' in lref) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (lref instanceof AbruptCompletion) return lref;
          /* node:coverage ignore next */
          if (lref instanceof Completion) lref = lref.Value;
          return yield* PutValue(lref, A);
        }
        // 6. Let nestedAssignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
        const nestedAssignmentPattern = refineLeftHandSideExpression(DestructuringAssignmentTarget);
        // 7. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with A as the argument.
        return yield* DestructuringAssignmentEvaluation(nestedAssignmentPattern, A);
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('IteratorDestructuringAssignmentEvaluation', node);
  }
}
function DestructuringAssignmentEvaluation(node, value) {
  switch (node.type) {
    case 'ObjectAssignmentPattern':
      return DestructuringAssignmentEvaluation_ObjectAssignmentPattern(node, value);
    case 'ArrayAssignmentPattern':
      return DestructuringAssignmentEvaluation_ArrayAssignmentPattern(node, value);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('DestructuringAssignmentEvaluation', node);
  }
}

// BindingRestProperty : `...` BindingIdentifier
function* RestBindingInitialization({
  BindingIdentifier
}, value, environment, excludedNames) {
  /* ReturnIfAbrupt */
  let _temp = yield* ResolveBinding(StringValue(BindingIdentifier), environment, BindingIdentifier.strict);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).
  const lhs = _temp;
  // 2. Let restObj be OrdinaryObjectCreate(%Object.prototype%).
  const restObj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  // 3. Perform ? CopyDataProperties(restObj, value, excludedNames).
  /* ReturnIfAbrupt */
  let _temp2 = yield* CopyDataProperties(restObj, value, excludedNames);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 4. If environment is undefined, return PutValue(lhs, restObj).
  if (environment === Value.undefined) {
    return yield* PutValue(lhs, restObj);
  }
  // 5. Return InitializeReferencedBinding(lhs, restObj).
  return yield* InitializeReferencedBinding(lhs, restObj);
}

var unicodeCaseFoldingCommon = new Map(JSON.parse("[[65,97],[66,98],[67,99],[68,100],[69,101],[70,102],[71,103],[72,104],[73,105],[74,106],[75,107],[76,108],[77,109],[78,110],[79,111],[80,112],[81,113],[82,114],[83,115],[84,116],[85,117],[86,118],[87,119],[88,120],[89,121],[90,122],[181,956],[192,224],[193,225],[194,226],[195,227],[196,228],[197,229],[198,230],[199,231],[200,232],[201,233],[202,234],[203,235],[204,236],[205,237],[206,238],[207,239],[208,240],[209,241],[210,242],[211,243],[212,244],[213,245],[214,246],[216,248],[217,249],[218,250],[219,251],[220,252],[221,253],[222,254],[256,257],[258,259],[260,261],[262,263],[264,265],[266,267],[268,269],[270,271],[272,273],[274,275],[276,277],[278,279],[280,281],[282,283],[284,285],[286,287],[288,289],[290,291],[292,293],[294,295],[296,297],[298,299],[300,301],[302,303],[306,307],[308,309],[310,311],[313,314],[315,316],[317,318],[319,320],[321,322],[323,324],[325,326],[327,328],[330,331],[332,333],[334,335],[336,337],[338,339],[340,341],[342,343],[344,345],[346,347],[348,349],[350,351],[352,353],[354,355],[356,357],[358,359],[360,361],[362,363],[364,365],[366,367],[368,369],[370,371],[372,373],[374,375],[376,255],[377,378],[379,380],[381,382],[383,115],[385,595],[386,387],[388,389],[390,596],[391,392],[393,598],[394,599],[395,396],[398,477],[399,601],[400,603],[401,402],[403,608],[404,611],[406,617],[407,616],[408,409],[412,623],[413,626],[415,629],[416,417],[418,419],[420,421],[422,640],[423,424],[425,643],[428,429],[430,648],[431,432],[433,650],[434,651],[435,436],[437,438],[439,658],[440,441],[444,445],[452,454],[453,454],[455,457],[456,457],[458,460],[459,460],[461,462],[463,464],[465,466],[467,468],[469,470],[471,472],[473,474],[475,476],[478,479],[480,481],[482,483],[484,485],[486,487],[488,489],[490,491],[492,493],[494,495],[497,499],[498,499],[500,501],[502,405],[503,447],[504,505],[506,507],[508,509],[510,511],[512,513],[514,515],[516,517],[518,519],[520,521],[522,523],[524,525],[526,527],[528,529],[530,531],[532,533],[534,535],[536,537],[538,539],[540,541],[542,543],[544,414],[546,547],[548,549],[550,551],[552,553],[554,555],[556,557],[558,559],[560,561],[562,563],[570,11365],[571,572],[573,410],[574,11366],[577,578],[579,384],[580,649],[581,652],[582,583],[584,585],[586,587],[588,589],[590,591],[837,953],[880,881],[882,883],[886,887],[895,1011],[902,940],[904,941],[905,942],[906,943],[908,972],[910,973],[911,974],[913,945],[914,946],[915,947],[916,948],[917,949],[918,950],[919,951],[920,952],[921,953],[922,954],[923,955],[924,956],[925,957],[926,958],[927,959],[928,960],[929,961],[931,963],[932,964],[933,965],[934,966],[935,967],[936,968],[937,969],[938,970],[939,971],[962,963],[975,983],[976,946],[977,952],[981,966],[982,960],[984,985],[986,987],[988,989],[990,991],[992,993],[994,995],[996,997],[998,999],[1000,1001],[1002,1003],[1004,1005],[1006,1007],[1008,954],[1009,961],[1012,952],[1013,949],[1015,1016],[1017,1010],[1018,1019],[1021,891],[1022,892],[1023,893],[1024,1104],[1025,1105],[1026,1106],[1027,1107],[1028,1108],[1029,1109],[1030,1110],[1031,1111],[1032,1112],[1033,1113],[1034,1114],[1035,1115],[1036,1116],[1037,1117],[1038,1118],[1039,1119],[1040,1072],[1041,1073],[1042,1074],[1043,1075],[1044,1076],[1045,1077],[1046,1078],[1047,1079],[1048,1080],[1049,1081],[1050,1082],[1051,1083],[1052,1084],[1053,1085],[1054,1086],[1055,1087],[1056,1088],[1057,1089],[1058,1090],[1059,1091],[1060,1092],[1061,1093],[1062,1094],[1063,1095],[1064,1096],[1065,1097],[1066,1098],[1067,1099],[1068,1100],[1069,1101],[1070,1102],[1071,1103],[1120,1121],[1122,1123],[1124,1125],[1126,1127],[1128,1129],[1130,1131],[1132,1133],[1134,1135],[1136,1137],[1138,1139],[1140,1141],[1142,1143],[1144,1145],[1146,1147],[1148,1149],[1150,1151],[1152,1153],[1162,1163],[1164,1165],[1166,1167],[1168,1169],[1170,1171],[1172,1173],[1174,1175],[1176,1177],[1178,1179],[1180,1181],[1182,1183],[1184,1185],[1186,1187],[1188,1189],[1190,1191],[1192,1193],[1194,1195],[1196,1197],[1198,1199],[1200,1201],[1202,1203],[1204,1205],[1206,1207],[1208,1209],[1210,1211],[1212,1213],[1214,1215],[1216,1231],[1217,1218],[1219,1220],[1221,1222],[1223,1224],[1225,1226],[1227,1228],[1229,1230],[1232,1233],[1234,1235],[1236,1237],[1238,1239],[1240,1241],[1242,1243],[1244,1245],[1246,1247],[1248,1249],[1250,1251],[1252,1253],[1254,1255],[1256,1257],[1258,1259],[1260,1261],[1262,1263],[1264,1265],[1266,1267],[1268,1269],[1270,1271],[1272,1273],[1274,1275],[1276,1277],[1278,1279],[1280,1281],[1282,1283],[1284,1285],[1286,1287],[1288,1289],[1290,1291],[1292,1293],[1294,1295],[1296,1297],[1298,1299],[1300,1301],[1302,1303],[1304,1305],[1306,1307],[1308,1309],[1310,1311],[1312,1313],[1314,1315],[1316,1317],[1318,1319],[1320,1321],[1322,1323],[1324,1325],[1326,1327],[1329,1377],[1330,1378],[1331,1379],[1332,1380],[1333,1381],[1334,1382],[1335,1383],[1336,1384],[1337,1385],[1338,1386],[1339,1387],[1340,1388],[1341,1389],[1342,1390],[1343,1391],[1344,1392],[1345,1393],[1346,1394],[1347,1395],[1348,1396],[1349,1397],[1350,1398],[1351,1399],[1352,1400],[1353,1401],[1354,1402],[1355,1403],[1356,1404],[1357,1405],[1358,1406],[1359,1407],[1360,1408],[1361,1409],[1362,1410],[1363,1411],[1364,1412],[1365,1413],[1366,1414],[4256,11520],[4257,11521],[4258,11522],[4259,11523],[4260,11524],[4261,11525],[4262,11526],[4263,11527],[4264,11528],[4265,11529],[4266,11530],[4267,11531],[4268,11532],[4269,11533],[4270,11534],[4271,11535],[4272,11536],[4273,11537],[4274,11538],[4275,11539],[4276,11540],[4277,11541],[4278,11542],[4279,11543],[4280,11544],[4281,11545],[4282,11546],[4283,11547],[4284,11548],[4285,11549],[4286,11550],[4287,11551],[4288,11552],[4289,11553],[4290,11554],[4291,11555],[4292,11556],[4293,11557],[4295,11559],[4301,11565],[5112,5104],[5113,5105],[5114,5106],[5115,5107],[5116,5108],[5117,5109],[7296,1074],[7297,1076],[7298,1086],[7299,1089],[7300,1090],[7301,1090],[7302,1098],[7303,1123],[7304,42571],[7305,7306],[7312,4304],[7313,4305],[7314,4306],[7315,4307],[7316,4308],[7317,4309],[7318,4310],[7319,4311],[7320,4312],[7321,4313],[7322,4314],[7323,4315],[7324,4316],[7325,4317],[7326,4318],[7327,4319],[7328,4320],[7329,4321],[7330,4322],[7331,4323],[7332,4324],[7333,4325],[7334,4326],[7335,4327],[7336,4328],[7337,4329],[7338,4330],[7339,4331],[7340,4332],[7341,4333],[7342,4334],[7343,4335],[7344,4336],[7345,4337],[7346,4338],[7347,4339],[7348,4340],[7349,4341],[7350,4342],[7351,4343],[7352,4344],[7353,4345],[7354,4346],[7357,4349],[7358,4350],[7359,4351],[7680,7681],[7682,7683],[7684,7685],[7686,7687],[7688,7689],[7690,7691],[7692,7693],[7694,7695],[7696,7697],[7698,7699],[7700,7701],[7702,7703],[7704,7705],[7706,7707],[7708,7709],[7710,7711],[7712,7713],[7714,7715],[7716,7717],[7718,7719],[7720,7721],[7722,7723],[7724,7725],[7726,7727],[7728,7729],[7730,7731],[7732,7733],[7734,7735],[7736,7737],[7738,7739],[7740,7741],[7742,7743],[7744,7745],[7746,7747],[7748,7749],[7750,7751],[7752,7753],[7754,7755],[7756,7757],[7758,7759],[7760,7761],[7762,7763],[7764,7765],[7766,7767],[7768,7769],[7770,7771],[7772,7773],[7774,7775],[7776,7777],[7778,7779],[7780,7781],[7782,7783],[7784,7785],[7786,7787],[7788,7789],[7790,7791],[7792,7793],[7794,7795],[7796,7797],[7798,7799],[7800,7801],[7802,7803],[7804,7805],[7806,7807],[7808,7809],[7810,7811],[7812,7813],[7814,7815],[7816,7817],[7818,7819],[7820,7821],[7822,7823],[7824,7825],[7826,7827],[7828,7829],[7835,7777],[7840,7841],[7842,7843],[7844,7845],[7846,7847],[7848,7849],[7850,7851],[7852,7853],[7854,7855],[7856,7857],[7858,7859],[7860,7861],[7862,7863],[7864,7865],[7866,7867],[7868,7869],[7870,7871],[7872,7873],[7874,7875],[7876,7877],[7878,7879],[7880,7881],[7882,7883],[7884,7885],[7886,7887],[7888,7889],[7890,7891],[7892,7893],[7894,7895],[7896,7897],[7898,7899],[7900,7901],[7902,7903],[7904,7905],[7906,7907],[7908,7909],[7910,7911],[7912,7913],[7914,7915],[7916,7917],[7918,7919],[7920,7921],[7922,7923],[7924,7925],[7926,7927],[7928,7929],[7930,7931],[7932,7933],[7934,7935],[7944,7936],[7945,7937],[7946,7938],[7947,7939],[7948,7940],[7949,7941],[7950,7942],[7951,7943],[7960,7952],[7961,7953],[7962,7954],[7963,7955],[7964,7956],[7965,7957],[7976,7968],[7977,7969],[7978,7970],[7979,7971],[7980,7972],[7981,7973],[7982,7974],[7983,7975],[7992,7984],[7993,7985],[7994,7986],[7995,7987],[7996,7988],[7997,7989],[7998,7990],[7999,7991],[8008,8000],[8009,8001],[8010,8002],[8011,8003],[8012,8004],[8013,8005],[8025,8017],[8027,8019],[8029,8021],[8031,8023],[8040,8032],[8041,8033],[8042,8034],[8043,8035],[8044,8036],[8045,8037],[8046,8038],[8047,8039],[8120,8112],[8121,8113],[8122,8048],[8123,8049],[8126,953],[8136,8050],[8137,8051],[8138,8052],[8139,8053],[8152,8144],[8153,8145],[8154,8054],[8155,8055],[8168,8160],[8169,8161],[8170,8058],[8171,8059],[8172,8165],[8184,8056],[8185,8057],[8186,8060],[8187,8061],[8486,969],[8490,107],[8491,229],[8498,8526],[8544,8560],[8545,8561],[8546,8562],[8547,8563],[8548,8564],[8549,8565],[8550,8566],[8551,8567],[8552,8568],[8553,8569],[8554,8570],[8555,8571],[8556,8572],[8557,8573],[8558,8574],[8559,8575],[8579,8580],[9398,9424],[9399,9425],[9400,9426],[9401,9427],[9402,9428],[9403,9429],[9404,9430],[9405,9431],[9406,9432],[9407,9433],[9408,9434],[9409,9435],[9410,9436],[9411,9437],[9412,9438],[9413,9439],[9414,9440],[9415,9441],[9416,9442],[9417,9443],[9418,9444],[9419,9445],[9420,9446],[9421,9447],[9422,9448],[9423,9449],[11264,11312],[11265,11313],[11266,11314],[11267,11315],[11268,11316],[11269,11317],[11270,11318],[11271,11319],[11272,11320],[11273,11321],[11274,11322],[11275,11323],[11276,11324],[11277,11325],[11278,11326],[11279,11327],[11280,11328],[11281,11329],[11282,11330],[11283,11331],[11284,11332],[11285,11333],[11286,11334],[11287,11335],[11288,11336],[11289,11337],[11290,11338],[11291,11339],[11292,11340],[11293,11341],[11294,11342],[11295,11343],[11296,11344],[11297,11345],[11298,11346],[11299,11347],[11300,11348],[11301,11349],[11302,11350],[11303,11351],[11304,11352],[11305,11353],[11306,11354],[11307,11355],[11308,11356],[11309,11357],[11310,11358],[11311,11359],[11360,11361],[11362,619],[11363,7549],[11364,637],[11367,11368],[11369,11370],[11371,11372],[11373,593],[11374,625],[11375,592],[11376,594],[11378,11379],[11381,11382],[11390,575],[11391,576],[11392,11393],[11394,11395],[11396,11397],[11398,11399],[11400,11401],[11402,11403],[11404,11405],[11406,11407],[11408,11409],[11410,11411],[11412,11413],[11414,11415],[11416,11417],[11418,11419],[11420,11421],[11422,11423],[11424,11425],[11426,11427],[11428,11429],[11430,11431],[11432,11433],[11434,11435],[11436,11437],[11438,11439],[11440,11441],[11442,11443],[11444,11445],[11446,11447],[11448,11449],[11450,11451],[11452,11453],[11454,11455],[11456,11457],[11458,11459],[11460,11461],[11462,11463],[11464,11465],[11466,11467],[11468,11469],[11470,11471],[11472,11473],[11474,11475],[11476,11477],[11478,11479],[11480,11481],[11482,11483],[11484,11485],[11486,11487],[11488,11489],[11490,11491],[11499,11500],[11501,11502],[11506,11507],[42560,42561],[42562,42563],[42564,42565],[42566,42567],[42568,42569],[42570,42571],[42572,42573],[42574,42575],[42576,42577],[42578,42579],[42580,42581],[42582,42583],[42584,42585],[42586,42587],[42588,42589],[42590,42591],[42592,42593],[42594,42595],[42596,42597],[42598,42599],[42600,42601],[42602,42603],[42604,42605],[42624,42625],[42626,42627],[42628,42629],[42630,42631],[42632,42633],[42634,42635],[42636,42637],[42638,42639],[42640,42641],[42642,42643],[42644,42645],[42646,42647],[42648,42649],[42650,42651],[42786,42787],[42788,42789],[42790,42791],[42792,42793],[42794,42795],[42796,42797],[42798,42799],[42802,42803],[42804,42805],[42806,42807],[42808,42809],[42810,42811],[42812,42813],[42814,42815],[42816,42817],[42818,42819],[42820,42821],[42822,42823],[42824,42825],[42826,42827],[42828,42829],[42830,42831],[42832,42833],[42834,42835],[42836,42837],[42838,42839],[42840,42841],[42842,42843],[42844,42845],[42846,42847],[42848,42849],[42850,42851],[42852,42853],[42854,42855],[42856,42857],[42858,42859],[42860,42861],[42862,42863],[42873,42874],[42875,42876],[42877,7545],[42878,42879],[42880,42881],[42882,42883],[42884,42885],[42886,42887],[42891,42892],[42893,613],[42896,42897],[42898,42899],[42902,42903],[42904,42905],[42906,42907],[42908,42909],[42910,42911],[42912,42913],[42914,42915],[42916,42917],[42918,42919],[42920,42921],[42922,614],[42923,604],[42924,609],[42925,620],[42926,618],[42928,670],[42929,647],[42930,669],[42931,43859],[42932,42933],[42934,42935],[42936,42937],[42938,42939],[42940,42941],[42942,42943],[42944,42945],[42946,42947],[42948,42900],[42949,642],[42950,7566],[42951,42952],[42953,42954],[42955,612],[42956,42957],[42960,42961],[42966,42967],[42968,42969],[42970,42971],[42972,411],[42997,42998],[43888,5024],[43889,5025],[43890,5026],[43891,5027],[43892,5028],[43893,5029],[43894,5030],[43895,5031],[43896,5032],[43897,5033],[43898,5034],[43899,5035],[43900,5036],[43901,5037],[43902,5038],[43903,5039],[43904,5040],[43905,5041],[43906,5042],[43907,5043],[43908,5044],[43909,5045],[43910,5046],[43911,5047],[43912,5048],[43913,5049],[43914,5050],[43915,5051],[43916,5052],[43917,5053],[43918,5054],[43919,5055],[43920,5056],[43921,5057],[43922,5058],[43923,5059],[43924,5060],[43925,5061],[43926,5062],[43927,5063],[43928,5064],[43929,5065],[43930,5066],[43931,5067],[43932,5068],[43933,5069],[43934,5070],[43935,5071],[43936,5072],[43937,5073],[43938,5074],[43939,5075],[43940,5076],[43941,5077],[43942,5078],[43943,5079],[43944,5080],[43945,5081],[43946,5082],[43947,5083],[43948,5084],[43949,5085],[43950,5086],[43951,5087],[43952,5088],[43953,5089],[43954,5090],[43955,5091],[43956,5092],[43957,5093],[43958,5094],[43959,5095],[43960,5096],[43961,5097],[43962,5098],[43963,5099],[43964,5100],[43965,5101],[43966,5102],[43967,5103],[65313,65345],[65314,65346],[65315,65347],[65316,65348],[65317,65349],[65318,65350],[65319,65351],[65320,65352],[65321,65353],[65322,65354],[65323,65355],[65324,65356],[65325,65357],[65326,65358],[65327,65359],[65328,65360],[65329,65361],[65330,65362],[65331,65363],[65332,65364],[65333,65365],[65334,65366],[65335,65367],[65336,65368],[65337,65369],[65338,65370],[66560,66600],[66561,66601],[66562,66602],[66563,66603],[66564,66604],[66565,66605],[66566,66606],[66567,66607],[66568,66608],[66569,66609],[66570,66610],[66571,66611],[66572,66612],[66573,66613],[66574,66614],[66575,66615],[66576,66616],[66577,66617],[66578,66618],[66579,66619],[66580,66620],[66581,66621],[66582,66622],[66583,66623],[66584,66624],[66585,66625],[66586,66626],[66587,66627],[66588,66628],[66589,66629],[66590,66630],[66591,66631],[66592,66632],[66593,66633],[66594,66634],[66595,66635],[66596,66636],[66597,66637],[66598,66638],[66599,66639],[66736,66776],[66737,66777],[66738,66778],[66739,66779],[66740,66780],[66741,66781],[66742,66782],[66743,66783],[66744,66784],[66745,66785],[66746,66786],[66747,66787],[66748,66788],[66749,66789],[66750,66790],[66751,66791],[66752,66792],[66753,66793],[66754,66794],[66755,66795],[66756,66796],[66757,66797],[66758,66798],[66759,66799],[66760,66800],[66761,66801],[66762,66802],[66763,66803],[66764,66804],[66765,66805],[66766,66806],[66767,66807],[66768,66808],[66769,66809],[66770,66810],[66771,66811],[66928,66967],[66929,66968],[66930,66969],[66931,66970],[66932,66971],[66933,66972],[66934,66973],[66935,66974],[66936,66975],[66937,66976],[66938,66977],[66940,66979],[66941,66980],[66942,66981],[66943,66982],[66944,66983],[66945,66984],[66946,66985],[66947,66986],[66948,66987],[66949,66988],[66950,66989],[66951,66990],[66952,66991],[66953,66992],[66954,66993],[66956,66995],[66957,66996],[66958,66997],[66959,66998],[66960,66999],[66961,67000],[66962,67001],[66964,67003],[66965,67004],[68736,68800],[68737,68801],[68738,68802],[68739,68803],[68740,68804],[68741,68805],[68742,68806],[68743,68807],[68744,68808],[68745,68809],[68746,68810],[68747,68811],[68748,68812],[68749,68813],[68750,68814],[68751,68815],[68752,68816],[68753,68817],[68754,68818],[68755,68819],[68756,68820],[68757,68821],[68758,68822],[68759,68823],[68760,68824],[68761,68825],[68762,68826],[68763,68827],[68764,68828],[68765,68829],[68766,68830],[68767,68831],[68768,68832],[68769,68833],[68770,68834],[68771,68835],[68772,68836],[68773,68837],[68774,68838],[68775,68839],[68776,68840],[68777,68841],[68778,68842],[68779,68843],[68780,68844],[68781,68845],[68782,68846],[68783,68847],[68784,68848],[68785,68849],[68786,68850],[68944,68976],[68945,68977],[68946,68978],[68947,68979],[68948,68980],[68949,68981],[68950,68982],[68951,68983],[68952,68984],[68953,68985],[68954,68986],[68955,68987],[68956,68988],[68957,68989],[68958,68990],[68959,68991],[68960,68992],[68961,68993],[68962,68994],[68963,68995],[68964,68996],[68965,68997],[71840,71872],[71841,71873],[71842,71874],[71843,71875],[71844,71876],[71845,71877],[71846,71878],[71847,71879],[71848,71880],[71849,71881],[71850,71882],[71851,71883],[71852,71884],[71853,71885],[71854,71886],[71855,71887],[71856,71888],[71857,71889],[71858,71890],[71859,71891],[71860,71892],[71861,71893],[71862,71894],[71863,71895],[71864,71896],[71865,71897],[71866,71898],[71867,71899],[71868,71900],[71869,71901],[71870,71902],[71871,71903],[93760,93792],[93761,93793],[93762,93794],[93763,93795],[93764,93796],[93765,93797],[93766,93798],[93767,93799],[93768,93800],[93769,93801],[93770,93802],[93771,93803],[93772,93804],[93773,93805],[93774,93806],[93775,93807],[93776,93808],[93777,93809],[93778,93810],[93779,93811],[93780,93812],[93781,93813],[93782,93814],[93783,93815],[93784,93816],[93785,93817],[93786,93818],[93787,93819],[93788,93820],[93789,93821],[93790,93822],[93791,93823],[125184,125218],[125185,125219],[125186,125220],[125187,125221],[125188,125222],[125189,125223],[125190,125224],[125191,125225],[125192,125226],[125193,125227],[125194,125228],[125195,125229],[125196,125230],[125197,125231],[125198,125232],[125199,125233],[125200,125234],[125201,125235],[125202,125236],[125203,125237],[125204,125238],[125205,125239],[125206,125240],[125207,125241],[125208,125242],[125209,125243],[125210,125244],[125211,125245],[125212,125246],[125213,125247],[125214,125248],[125215,125249],[125216,125250],[125217,125251]]").map(([cp1, cp2]) => [String.fromCodePoint(cp1), String.fromCodePoint(cp2)]));

var unicodeCaseFoldingSimple = new Map(JSON.parse("[[7838,223],[8072,8064],[8073,8065],[8074,8066],[8075,8067],[8076,8068],[8077,8069],[8078,8070],[8079,8071],[8088,8080],[8089,8081],[8090,8082],[8091,8083],[8092,8084],[8093,8085],[8094,8086],[8095,8087],[8104,8096],[8105,8097],[8106,8098],[8107,8099],[8108,8100],[8109,8101],[8110,8102],[8111,8103],[8124,8115],[8140,8131],[8147,912],[8163,944],[8188,8179],[64261,64262]]").map(([cp1, cp2]) => [String.fromCodePoint(cp1), String.fromCodePoint(cp2)]));

var UnicodeSets = {"General_Category/Control":[[0,31],[127,159]],"General_Category/Separator":[[32,32],[160,160],[5760,5760],[8192,8202],[8232,8233],[8239,8239],[8287,8287],[12288,12288]],"General_Category/Space_Separator":[[32,32],[160,160],[5760,5760],[8192,8202],[8239,8239],[8287,8287],[12288,12288]],"General_Category/Titlecase_Letter":[[453,453],[456,456],[459,459],[498,498],[8072,8079],[8088,8095],[8104,8111],[8124,8124],[8140,8140],[8188,8188]],"General_Category/Enclosing_Mark":[[1160,1161],[6846,6846],[8413,8416],[8418,8420],[42608,42610]],"General_Category/Modifier_Letter":[[688,705],[710,721],[736,740],[748,748],[750,750],[884,884],[890,890],[1369,1369],[1600,1600],[1765,1766],[2036,2037],[2042,2042],[2074,2074],[2084,2084],[2088,2088],[2249,2249],[2417,2417],[3654,3654],[3782,3782],[4348,4348],[6103,6103],[6211,6211],[6823,6823],[7288,7293],[7468,7530],[7544,7544],[7579,7615],[8305,8305],[8319,8319],[8336,8348],[11388,11389],[11631,11631],[11823,11823],[12293,12293],[12337,12341],[12347,12347],[12445,12446],[12540,12542],[40981,40981],[42232,42237],[42508,42508],[42623,42623],[42652,42653],[42775,42783],[42864,42864],[42888,42888],[42994,42996],[43000,43001],[43471,43471],[43494,43494],[43632,43632],[43741,43741],[43763,43764],[43868,43871],[43881,43881],[65392,65392],[65438,65439],[67456,67461],[67463,67504],[67506,67514],[68942,68942],[68975,68975],[92992,92995],[93504,93506],[93547,93548],[94099,94111],[94176,94177],[94179,94179],[110576,110579],[110581,110587],[110589,110590],[122928,122989],[123191,123197],[124139,124139],[125259,125259]],"General_Category/Open_Punctuation":[[40,40],[91,91],[123,123],[3898,3898],[3900,3900],[5787,5787],[8218,8218],[8222,8222],[8261,8261],[8317,8317],[8333,8333],[8968,8968],[8970,8970],[9001,9001],[10088,10088],[10090,10090],[10092,10092],[10094,10094],[10096,10096],[10098,10098],[10100,10100],[10181,10181],[10214,10214],[10216,10216],[10218,10218],[10220,10220],[10222,10222],[10627,10627],[10629,10629],[10631,10631],[10633,10633],[10635,10635],[10637,10637],[10639,10639],[10641,10641],[10643,10643],[10645,10645],[10647,10647],[10712,10712],[10714,10714],[10748,10748],[11810,11810],[11812,11812],[11814,11814],[11816,11816],[11842,11842],[11861,11861],[11863,11863],[11865,11865],[11867,11867],[12296,12296],[12298,12298],[12300,12300],[12302,12302],[12304,12304],[12308,12308],[12310,12310],[12312,12312],[12314,12314],[12317,12317],[64831,64831],[65047,65047],[65077,65077],[65079,65079],[65081,65081],[65083,65083],[65085,65085],[65087,65087],[65089,65089],[65091,65091],[65095,65095],[65113,65113],[65115,65115],[65117,65117],[65288,65288],[65339,65339],[65371,65371],[65375,65375],[65378,65378]],"General_Category/Number":[[48,57],[178,179],[185,185],[188,190],[1632,1641],[1776,1785],[1984,1993],[2406,2415],[2534,2543],[2548,2553],[2662,2671],[2790,2799],[2918,2927],[2930,2935],[3046,3058],[3174,3183],[3192,3198],[3302,3311],[3416,3422],[3430,3448],[3558,3567],[3664,3673],[3792,3801],[3872,3891],[4160,4169],[4240,4249],[4969,4988],[5870,5872],[6112,6121],[6128,6137],[6160,6169],[6470,6479],[6608,6618],[6784,6793],[6800,6809],[6992,7001],[7088,7097],[7232,7241],[7248,7257],[8304,8304],[8308,8313],[8320,8329],[8528,8578],[8581,8585],[9312,9371],[9450,9471],[10102,10131],[11517,11517],[12295,12295],[12321,12329],[12344,12346],[12690,12693],[12832,12841],[12872,12879],[12881,12895],[12928,12937],[12977,12991],[42528,42537],[42726,42735],[43056,43061],[43216,43225],[43264,43273],[43472,43481],[43504,43513],[43600,43609],[44016,44025],[65296,65305],[65799,65843],[65856,65912],[65930,65931],[66273,66299],[66336,66339],[66369,66369],[66378,66378],[66513,66517],[66720,66729],[67672,67679],[67705,67711],[67751,67759],[67835,67839],[67862,67867],[68028,68029],[68032,68047],[68050,68095],[68160,68168],[68221,68222],[68253,68255],[68331,68335],[68440,68447],[68472,68479],[68521,68527],[68858,68863],[68912,68921],[68928,68937],[69216,69246],[69405,69414],[69457,69460],[69573,69579],[69714,69743],[69872,69881],[69942,69951],[70096,70105],[70113,70132],[70384,70393],[70736,70745],[70864,70873],[71248,71257],[71360,71369],[71376,71395],[71472,71483],[71904,71922],[72016,72025],[72688,72697],[72784,72812],[73040,73049],[73120,73129],[73552,73561],[73664,73684],[74752,74862],[90416,90425],[92768,92777],[92864,92873],[93008,93017],[93019,93025],[93552,93561],[93824,93846],[118000,118009],[119488,119507],[119520,119539],[119648,119672],[120782,120831],[123200,123209],[123632,123641],[124144,124153],[124401,124410],[125127,125135],[125264,125273],[126065,126123],[126125,126127],[126129,126132],[126209,126253],[126255,126269],[127232,127244],[130032,130041]],"General_Category/Other_Letter":[[170,170],[186,186],[443,443],[448,451],[660,660],[1488,1514],[1519,1522],[1568,1599],[1601,1610],[1646,1647],[1649,1747],[1749,1749],[1774,1775],[1786,1788],[1791,1791],[1808,1808],[1810,1839],[1869,1957],[1969,1969],[1994,2026],[2048,2069],[2112,2136],[2144,2154],[2160,2183],[2185,2190],[2208,2248],[2308,2361],[2365,2365],[2384,2384],[2392,2401],[2418,2432],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2493,2493],[2510,2510],[2524,2525],[2527,2529],[2544,2545],[2556,2556],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2649,2652],[2654,2654],[2674,2676],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2749,2749],[2768,2768],[2784,2785],[2809,2809],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2877,2877],[2908,2909],[2911,2913],[2929,2929],[2947,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3024,3024],[3077,3084],[3086,3088],[3090,3112],[3114,3129],[3133,3133],[3160,3162],[3165,3165],[3168,3169],[3200,3200],[3205,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3261,3261],[3293,3294],[3296,3297],[3313,3314],[3332,3340],[3342,3344],[3346,3386],[3389,3389],[3406,3406],[3412,3414],[3423,3425],[3450,3455],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3585,3632],[3634,3635],[3648,3653],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3760],[3762,3763],[3773,3773],[3776,3780],[3804,3807],[3840,3840],[3904,3911],[3913,3948],[3976,3980],[4096,4138],[4159,4159],[4176,4181],[4186,4189],[4193,4193],[4197,4198],[4206,4208],[4213,4225],[4238,4238],[4352,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4992,5007],[5121,5740],[5743,5759],[5761,5786],[5792,5866],[5873,5880],[5888,5905],[5919,5937],[5952,5969],[5984,5996],[5998,6000],[6016,6067],[6108,6108],[6176,6210],[6212,6264],[6272,6276],[6279,6312],[6314,6314],[6320,6389],[6400,6430],[6480,6509],[6512,6516],[6528,6571],[6576,6601],[6656,6678],[6688,6740],[6917,6963],[6981,6988],[7043,7072],[7086,7087],[7098,7141],[7168,7203],[7245,7247],[7258,7287],[7401,7404],[7406,7411],[7413,7414],[7418,7418],[8501,8504],[11568,11623],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[12294,12294],[12348,12348],[12353,12438],[12447,12447],[12449,12538],[12543,12543],[12549,12591],[12593,12686],[12704,12735],[12784,12799],[13312,19903],[19968,40980],[40982,42124],[42192,42231],[42240,42507],[42512,42527],[42538,42539],[42606,42606],[42656,42725],[42895,42895],[42999,42999],[43003,43009],[43011,43013],[43015,43018],[43020,43042],[43072,43123],[43138,43187],[43250,43255],[43259,43259],[43261,43262],[43274,43301],[43312,43334],[43360,43388],[43396,43442],[43488,43492],[43495,43503],[43514,43518],[43520,43560],[43584,43586],[43588,43595],[43616,43631],[43633,43638],[43642,43642],[43646,43695],[43697,43697],[43701,43702],[43705,43709],[43712,43712],[43714,43714],[43739,43740],[43744,43754],[43762,43762],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43968,44002],[44032,55203],[55216,55238],[55243,55291],[63744,64109],[64112,64217],[64285,64285],[64287,64296],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64829],[64848,64911],[64914,64967],[65008,65019],[65136,65140],[65142,65276],[65382,65391],[65393,65437],[65440,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[66176,66204],[66208,66256],[66304,66335],[66349,66368],[66370,66377],[66384,66421],[66432,66461],[66464,66499],[66504,66511],[66640,66717],[66816,66855],[66864,66915],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67680,67702],[67712,67742],[67808,67826],[67828,67829],[67840,67861],[67872,67897],[67968,68023],[68030,68031],[68096,68096],[68112,68115],[68117,68119],[68121,68149],[68192,68220],[68224,68252],[68288,68295],[68297,68324],[68352,68405],[68416,68437],[68448,68466],[68480,68497],[68608,68680],[68864,68899],[68938,68941],[68943,68943],[69248,69289],[69296,69297],[69314,69316],[69376,69404],[69415,69415],[69424,69445],[69488,69505],[69552,69572],[69600,69622],[69635,69687],[69745,69746],[69749,69749],[69763,69807],[69840,69864],[69891,69926],[69956,69956],[69959,69959],[69968,70002],[70006,70006],[70019,70066],[70081,70084],[70106,70106],[70108,70108],[70144,70161],[70163,70187],[70207,70208],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70312],[70320,70366],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70461,70461],[70480,70480],[70493,70497],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70583],[70609,70609],[70611,70611],[70656,70708],[70727,70730],[70751,70753],[70784,70831],[70852,70853],[70855,70855],[71040,71086],[71128,71131],[71168,71215],[71236,71236],[71296,71338],[71352,71352],[71424,71450],[71488,71494],[71680,71723],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71983],[71999,71999],[72001,72001],[72096,72103],[72106,72144],[72161,72161],[72163,72163],[72192,72192],[72203,72242],[72250,72250],[72272,72272],[72284,72329],[72349,72349],[72368,72440],[72640,72672],[72704,72712],[72714,72750],[72768,72768],[72818,72847],[72960,72966],[72968,72969],[72971,73008],[73030,73030],[73056,73061],[73063,73064],[73066,73097],[73112,73112],[73440,73458],[73474,73474],[73476,73488],[73490,73523],[73648,73648],[73728,74649],[74880,75075],[77712,77808],[77824,78895],[78913,78918],[78944,82938],[82944,83526],[90368,90397],[92160,92728],[92736,92766],[92784,92862],[92880,92909],[92928,92975],[93027,93047],[93053,93071],[93507,93546],[93952,94026],[94032,94032],[94208,100343],[100352,101589],[101631,101640],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[122634,122634],[123136,123180],[123214,123214],[123536,123565],[123584,123627],[124112,124138],[124368,124397],[124400,124400],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"General_Category/Dash_Punctuation":[[45,45],[1418,1418],[1470,1470],[5120,5120],[6150,6150],[8208,8213],[11799,11799],[11802,11802],[11834,11835],[11840,11840],[11869,11869],[12316,12316],[12336,12336],[12448,12448],[65073,65074],[65112,65112],[65123,65123],[65293,65293],[68974,68974],[69293,69293]],"General_Category/Letter_Number":[[5870,5872],[8544,8578],[8581,8584],[12295,12295],[12321,12329],[12344,12346],[42726,42735],[65856,65908],[66369,66369],[66378,66378],[66513,66517],[74752,74862]],"General_Category/Final_Punctuation":[[187,187],[8217,8217],[8221,8221],[8250,8250],[11779,11779],[11781,11781],[11786,11786],[11789,11789],[11805,11805],[11809,11809]],"General_Category/Surrogate":[[55296,57343]],"General_Category/Other":[[0,31],[127,159],[173,173],[888,889],[896,899],[907,907],[909,909],[930,930],[1328,1328],[1367,1368],[1419,1420],[1424,1424],[1480,1487],[1515,1518],[1525,1541],[1564,1564],[1757,1757],[1806,1807],[1867,1868],[1970,1983],[2043,2044],[2094,2095],[2111,2111],[2140,2141],[2143,2143],[2155,2159],[2191,2198],[2274,2274],[2436,2436],[2445,2446],[2449,2450],[2473,2473],[2481,2481],[2483,2485],[2490,2491],[2501,2502],[2505,2506],[2511,2518],[2520,2523],[2526,2526],[2532,2533],[2559,2560],[2564,2564],[2571,2574],[2577,2578],[2601,2601],[2609,2609],[2612,2612],[2615,2615],[2618,2619],[2621,2621],[2627,2630],[2633,2634],[2638,2640],[2642,2648],[2653,2653],[2655,2661],[2679,2688],[2692,2692],[2702,2702],[2706,2706],[2729,2729],[2737,2737],[2740,2740],[2746,2747],[2758,2758],[2762,2762],[2766,2767],[2769,2783],[2788,2789],[2802,2808],[2816,2816],[2820,2820],[2829,2830],[2833,2834],[2857,2857],[2865,2865],[2868,2868],[2874,2875],[2885,2886],[2889,2890],[2894,2900],[2904,2907],[2910,2910],[2916,2917],[2936,2945],[2948,2948],[2955,2957],[2961,2961],[2966,2968],[2971,2971],[2973,2973],[2976,2978],[2981,2983],[2987,2989],[3002,3005],[3011,3013],[3017,3017],[3022,3023],[3025,3030],[3032,3045],[3067,3071],[3085,3085],[3089,3089],[3113,3113],[3130,3131],[3141,3141],[3145,3145],[3150,3156],[3159,3159],[3163,3164],[3166,3167],[3172,3173],[3184,3190],[3213,3213],[3217,3217],[3241,3241],[3252,3252],[3258,3259],[3269,3269],[3273,3273],[3278,3284],[3287,3292],[3295,3295],[3300,3301],[3312,3312],[3316,3327],[3341,3341],[3345,3345],[3397,3397],[3401,3401],[3408,3411],[3428,3429],[3456,3456],[3460,3460],[3479,3481],[3506,3506],[3516,3516],[3518,3519],[3527,3529],[3531,3534],[3541,3541],[3543,3543],[3552,3557],[3568,3569],[3573,3584],[3643,3646],[3676,3712],[3715,3715],[3717,3717],[3723,3723],[3748,3748],[3750,3750],[3774,3775],[3781,3781],[3783,3783],[3791,3791],[3802,3803],[3808,3839],[3912,3912],[3949,3952],[3992,3992],[4029,4029],[4045,4045],[4059,4095],[4294,4294],[4296,4300],[4302,4303],[4681,4681],[4686,4687],[4695,4695],[4697,4697],[4702,4703],[4745,4745],[4750,4751],[4785,4785],[4790,4791],[4799,4799],[4801,4801],[4806,4807],[4823,4823],[4881,4881],[4886,4887],[4955,4956],[4989,4991],[5018,5023],[5110,5111],[5118,5119],[5789,5791],[5881,5887],[5910,5918],[5943,5951],[5972,5983],[5997,5997],[6001,6001],[6004,6015],[6110,6111],[6122,6127],[6138,6143],[6158,6158],[6170,6175],[6265,6271],[6315,6319],[6390,6399],[6431,6431],[6444,6447],[6460,6463],[6465,6467],[6510,6511],[6517,6527],[6572,6575],[6602,6607],[6619,6621],[6684,6685],[6751,6751],[6781,6782],[6794,6799],[6810,6815],[6830,6831],[6863,6911],[6989,6989],[7156,7163],[7224,7226],[7242,7244],[7307,7311],[7355,7356],[7368,7375],[7419,7423],[7958,7959],[7966,7967],[8006,8007],[8014,8015],[8024,8024],[8026,8026],[8028,8028],[8030,8030],[8062,8063],[8117,8117],[8133,8133],[8148,8149],[8156,8156],[8176,8177],[8181,8181],[8191,8191],[8203,8207],[8234,8238],[8288,8303],[8306,8307],[8335,8335],[8349,8351],[8385,8399],[8433,8447],[8588,8591],[9258,9279],[9291,9311],[11124,11125],[11158,11158],[11508,11512],[11558,11558],[11560,11564],[11566,11567],[11624,11630],[11633,11646],[11671,11679],[11687,11687],[11695,11695],[11703,11703],[11711,11711],[11719,11719],[11727,11727],[11735,11735],[11743,11743],[11870,11903],[11930,11930],[12020,12031],[12246,12271],[12352,12352],[12439,12440],[12544,12548],[12592,12592],[12687,12687],[12774,12782],[12831,12831],[42125,42127],[42183,42191],[42540,42559],[42744,42751],[42958,42959],[42962,42962],[42964,42964],[42973,42993],[43053,43055],[43066,43071],[43128,43135],[43206,43213],[43226,43231],[43348,43358],[43389,43391],[43470,43470],[43482,43485],[43519,43519],[43575,43583],[43598,43599],[43610,43611],[43715,43738],[43767,43776],[43783,43784],[43791,43792],[43799,43807],[43815,43815],[43823,43823],[43884,43887],[44014,44015],[44026,44031],[55204,55215],[55239,55242],[55292,63743],[64110,64111],[64218,64255],[64263,64274],[64280,64284],[64311,64311],[64317,64317],[64319,64319],[64322,64322],[64325,64325],[64451,64466],[64912,64913],[64968,64974],[64976,65007],[65050,65055],[65107,65107],[65127,65127],[65132,65135],[65141,65141],[65277,65280],[65471,65473],[65480,65481],[65488,65489],[65496,65497],[65501,65503],[65511,65511],[65519,65531],[65534,65535],[65548,65548],[65575,65575],[65595,65595],[65598,65598],[65614,65615],[65630,65663],[65787,65791],[65795,65798],[65844,65846],[65935,65935],[65949,65951],[65953,65999],[66046,66175],[66205,66207],[66257,66271],[66300,66303],[66340,66348],[66379,66383],[66427,66431],[66462,66462],[66500,66503],[66518,66559],[66718,66719],[66730,66735],[66772,66775],[66812,66815],[66856,66863],[66916,66926],[66939,66939],[66955,66955],[66963,66963],[66966,66966],[66978,66978],[66994,66994],[67002,67002],[67005,67007],[67060,67071],[67383,67391],[67414,67423],[67432,67455],[67462,67462],[67505,67505],[67515,67583],[67590,67591],[67593,67593],[67638,67638],[67641,67643],[67645,67646],[67670,67670],[67743,67750],[67760,67807],[67827,67827],[67830,67834],[67868,67870],[67898,67902],[67904,67967],[68024,68027],[68048,68049],[68100,68100],[68103,68107],[68116,68116],[68120,68120],[68150,68151],[68155,68158],[68169,68175],[68185,68191],[68256,68287],[68327,68330],[68343,68351],[68406,68408],[68438,68439],[68467,68471],[68498,68504],[68509,68520],[68528,68607],[68681,68735],[68787,68799],[68851,68857],[68904,68911],[68922,68927],[68966,68968],[68998,69005],[69008,69215],[69247,69247],[69290,69290],[69294,69295],[69298,69313],[69317,69371],[69416,69423],[69466,69487],[69514,69551],[69580,69599],[69623,69631],[69710,69713],[69750,69758],[69821,69821],[69827,69839],[69865,69871],[69882,69887],[69941,69941],[69960,69967],[70007,70015],[70112,70112],[70133,70143],[70162,70162],[70210,70271],[70279,70279],[70281,70281],[70286,70286],[70302,70302],[70314,70319],[70379,70383],[70394,70399],[70404,70404],[70413,70414],[70417,70418],[70441,70441],[70449,70449],[70452,70452],[70458,70458],[70469,70470],[70473,70474],[70478,70479],[70481,70486],[70488,70492],[70500,70501],[70509,70511],[70517,70527],[70538,70538],[70540,70541],[70543,70543],[70582,70582],[70593,70593],[70595,70596],[70598,70598],[70603,70603],[70614,70614],[70617,70624],[70627,70655],[70748,70748],[70754,70783],[70856,70863],[70874,71039],[71094,71095],[71134,71167],[71237,71247],[71258,71263],[71277,71295],[71354,71359],[71370,71375],[71396,71423],[71451,71452],[71468,71471],[71495,71679],[71740,71839],[71923,71934],[71943,71944],[71946,71947],[71956,71956],[71959,71959],[71990,71990],[71993,71994],[72007,72015],[72026,72095],[72104,72105],[72152,72153],[72165,72191],[72264,72271],[72355,72367],[72441,72447],[72458,72639],[72674,72687],[72698,72703],[72713,72713],[72759,72759],[72774,72783],[72813,72815],[72848,72849],[72872,72872],[72887,72959],[72967,72967],[72970,72970],[73015,73017],[73019,73019],[73022,73022],[73032,73039],[73050,73055],[73062,73062],[73065,73065],[73103,73103],[73106,73106],[73113,73119],[73130,73439],[73465,73471],[73489,73489],[73531,73533],[73563,73647],[73649,73663],[73714,73726],[74650,74751],[74863,74863],[74869,74879],[75076,77711],[77811,77823],[78896,78911],[78934,78943],[82939,82943],[83527,90367],[90426,92159],[92729,92735],[92767,92767],[92778,92781],[92863,92863],[92874,92879],[92910,92911],[92918,92927],[92998,93007],[93018,93018],[93026,93026],[93048,93052],[93072,93503],[93562,93759],[93851,93951],[94027,94030],[94088,94094],[94112,94175],[94181,94191],[94194,94207],[100344,100351],[101590,101630],[101641,110575],[110580,110580],[110588,110588],[110591,110591],[110883,110897],[110899,110927],[110931,110932],[110934,110947],[110952,110959],[111356,113663],[113771,113775],[113789,113791],[113801,113807],[113818,113819],[113824,117759],[118010,118015],[118452,118527],[118574,118575],[118599,118607],[118724,118783],[119030,119039],[119079,119080],[119155,119162],[119275,119295],[119366,119487],[119508,119519],[119540,119551],[119639,119647],[119673,119807],[119893,119893],[119965,119965],[119968,119969],[119971,119972],[119975,119976],[119981,119981],[119994,119994],[119996,119996],[120004,120004],[120070,120070],[120075,120076],[120085,120085],[120093,120093],[120122,120122],[120127,120127],[120133,120133],[120135,120137],[120145,120145],[120486,120487],[120780,120781],[121484,121498],[121504,121504],[121520,122623],[122655,122660],[122667,122879],[122887,122887],[122905,122906],[122914,122914],[122917,122917],[122923,122927],[122990,123022],[123024,123135],[123181,123183],[123198,123199],[123210,123213],[123216,123535],[123567,123583],[123642,123646],[123648,124111],[124154,124367],[124411,124414],[124416,124895],[124903,124903],[124908,124908],[124911,124911],[124927,124927],[125125,125126],[125143,125183],[125260,125263],[125274,125277],[125280,126064],[126133,126208],[126270,126463],[126468,126468],[126496,126496],[126499,126499],[126501,126502],[126504,126504],[126515,126515],[126520,126520],[126522,126522],[126524,126529],[126531,126534],[126536,126536],[126538,126538],[126540,126540],[126544,126544],[126547,126547],[126549,126550],[126552,126552],[126554,126554],[126556,126556],[126558,126558],[126560,126560],[126563,126563],[126565,126566],[126571,126571],[126579,126579],[126584,126584],[126589,126589],[126591,126591],[126602,126602],[126620,126624],[126628,126628],[126634,126634],[126652,126703],[126706,126975],[127020,127023],[127124,127135],[127151,127152],[127168,127168],[127184,127184],[127222,127231],[127406,127461],[127491,127503],[127548,127551],[127561,127567],[127570,127583],[127590,127743],[128728,128731],[128749,128751],[128765,128767],[128887,128890],[128986,128991],[129004,129007],[129009,129023],[129036,129039],[129096,129103],[129114,129119],[129160,129167],[129198,129199],[129212,129215],[129218,129279],[129620,129631],[129646,129647],[129661,129663],[129674,129678],[129735,129741],[129757,129758],[129770,129775],[129785,129791],[129939,129939],[130042,131071],[173792,173823],[177978,177983],[178206,178207],[183970,183983],[191457,191471],[192094,194559],[195102,196607],[201547,201551],[205744,917759],[918000,1114111]],"General_Category/Other_Number":[[178,179],[185,185],[188,190],[2548,2553],[2930,2935],[3056,3058],[3192,3198],[3416,3422],[3440,3448],[3882,3891],[4969,4988],[6128,6137],[6618,6618],[8304,8304],[8308,8313],[8320,8329],[8528,8543],[8585,8585],[9312,9371],[9450,9471],[10102,10131],[11517,11517],[12690,12693],[12832,12841],[12872,12879],[12881,12895],[12928,12937],[12977,12991],[43056,43061],[65799,65843],[65909,65912],[65930,65931],[66273,66299],[66336,66339],[67672,67679],[67705,67711],[67751,67759],[67835,67839],[67862,67867],[68028,68029],[68032,68047],[68050,68095],[68160,68168],[68221,68222],[68253,68255],[68331,68335],[68440,68447],[68472,68479],[68521,68527],[68858,68863],[69216,69246],[69405,69414],[69457,69460],[69573,69579],[69714,69733],[70113,70132],[71482,71483],[71914,71922],[72794,72812],[73664,73684],[93019,93025],[93824,93846],[119488,119507],[119520,119539],[119648,119672],[125127,125135],[126065,126123],[126125,126127],[126129,126132],[126209,126253],[126255,126269],[127232,127244]],"General_Category/Letter":[[65,90],[97,122],[170,170],[181,181],[186,186],[192,214],[216,246],[248,705],[710,721],[736,740],[748,748],[750,750],[880,884],[886,887],[890,893],[895,895],[902,902],[904,906],[908,908],[910,929],[931,1013],[1015,1153],[1162,1327],[1329,1366],[1369,1369],[1376,1416],[1488,1514],[1519,1522],[1568,1610],[1646,1647],[1649,1747],[1749,1749],[1765,1766],[1774,1775],[1786,1788],[1791,1791],[1808,1808],[1810,1839],[1869,1957],[1969,1969],[1994,2026],[2036,2037],[2042,2042],[2048,2069],[2074,2074],[2084,2084],[2088,2088],[2112,2136],[2144,2154],[2160,2183],[2185,2190],[2208,2249],[2308,2361],[2365,2365],[2384,2384],[2392,2401],[2417,2432],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2493,2493],[2510,2510],[2524,2525],[2527,2529],[2544,2545],[2556,2556],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2649,2652],[2654,2654],[2674,2676],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2749,2749],[2768,2768],[2784,2785],[2809,2809],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2877,2877],[2908,2909],[2911,2913],[2929,2929],[2947,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3024,3024],[3077,3084],[3086,3088],[3090,3112],[3114,3129],[3133,3133],[3160,3162],[3165,3165],[3168,3169],[3200,3200],[3205,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3261,3261],[3293,3294],[3296,3297],[3313,3314],[3332,3340],[3342,3344],[3346,3386],[3389,3389],[3406,3406],[3412,3414],[3423,3425],[3450,3455],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3585,3632],[3634,3635],[3648,3654],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3760],[3762,3763],[3773,3773],[3776,3780],[3782,3782],[3804,3807],[3840,3840],[3904,3911],[3913,3948],[3976,3980],[4096,4138],[4159,4159],[4176,4181],[4186,4189],[4193,4193],[4197,4198],[4206,4208],[4213,4225],[4238,4238],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4348,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4992,5007],[5024,5109],[5112,5117],[5121,5740],[5743,5759],[5761,5786],[5792,5866],[5873,5880],[5888,5905],[5919,5937],[5952,5969],[5984,5996],[5998,6000],[6016,6067],[6103,6103],[6108,6108],[6176,6264],[6272,6276],[6279,6312],[6314,6314],[6320,6389],[6400,6430],[6480,6509],[6512,6516],[6528,6571],[6576,6601],[6656,6678],[6688,6740],[6823,6823],[6917,6963],[6981,6988],[7043,7072],[7086,7087],[7098,7141],[7168,7203],[7245,7247],[7258,7293],[7296,7306],[7312,7354],[7357,7359],[7401,7404],[7406,7411],[7413,7414],[7418,7418],[7424,7615],[7680,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8305,8305],[8319,8319],[8336,8348],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8473,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8493],[8495,8505],[8508,8511],[8517,8521],[8526,8526],[8579,8580],[11264,11492],[11499,11502],[11506,11507],[11520,11557],[11559,11559],[11565,11565],[11568,11623],[11631,11631],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[11823,11823],[12293,12294],[12337,12341],[12347,12348],[12353,12438],[12445,12447],[12449,12538],[12540,12543],[12549,12591],[12593,12686],[12704,12735],[12784,12799],[13312,19903],[19968,42124],[42192,42237],[42240,42508],[42512,42527],[42538,42539],[42560,42606],[42623,42653],[42656,42725],[42775,42783],[42786,42888],[42891,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43009],[43011,43013],[43015,43018],[43020,43042],[43072,43123],[43138,43187],[43250,43255],[43259,43259],[43261,43262],[43274,43301],[43312,43334],[43360,43388],[43396,43442],[43471,43471],[43488,43492],[43494,43503],[43514,43518],[43520,43560],[43584,43586],[43588,43595],[43616,43638],[43642,43642],[43646,43695],[43697,43697],[43701,43702],[43705,43709],[43712,43712],[43714,43714],[43739,43741],[43744,43754],[43762,43764],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43866],[43868,43881],[43888,44002],[44032,55203],[55216,55238],[55243,55291],[63744,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64285],[64287,64296],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64829],[64848,64911],[64914,64967],[65008,65019],[65136,65140],[65142,65276],[65313,65338],[65345,65370],[65382,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[66176,66204],[66208,66256],[66304,66335],[66349,66368],[66370,66377],[66384,66421],[66432,66461],[66464,66499],[66504,66511],[66560,66717],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67680,67702],[67712,67742],[67808,67826],[67828,67829],[67840,67861],[67872,67897],[67968,68023],[68030,68031],[68096,68096],[68112,68115],[68117,68119],[68121,68149],[68192,68220],[68224,68252],[68288,68295],[68297,68324],[68352,68405],[68416,68437],[68448,68466],[68480,68497],[68608,68680],[68736,68786],[68800,68850],[68864,68899],[68938,68965],[68975,68997],[69248,69289],[69296,69297],[69314,69316],[69376,69404],[69415,69415],[69424,69445],[69488,69505],[69552,69572],[69600,69622],[69635,69687],[69745,69746],[69749,69749],[69763,69807],[69840,69864],[69891,69926],[69956,69956],[69959,69959],[69968,70002],[70006,70006],[70019,70066],[70081,70084],[70106,70106],[70108,70108],[70144,70161],[70163,70187],[70207,70208],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70312],[70320,70366],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70461,70461],[70480,70480],[70493,70497],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70583],[70609,70609],[70611,70611],[70656,70708],[70727,70730],[70751,70753],[70784,70831],[70852,70853],[70855,70855],[71040,71086],[71128,71131],[71168,71215],[71236,71236],[71296,71338],[71352,71352],[71424,71450],[71488,71494],[71680,71723],[71840,71903],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71983],[71999,71999],[72001,72001],[72096,72103],[72106,72144],[72161,72161],[72163,72163],[72192,72192],[72203,72242],[72250,72250],[72272,72272],[72284,72329],[72349,72349],[72368,72440],[72640,72672],[72704,72712],[72714,72750],[72768,72768],[72818,72847],[72960,72966],[72968,72969],[72971,73008],[73030,73030],[73056,73061],[73063,73064],[73066,73097],[73112,73112],[73440,73458],[73474,73474],[73476,73488],[73490,73523],[73648,73648],[73728,74649],[74880,75075],[77712,77808],[77824,78895],[78913,78918],[78944,82938],[82944,83526],[90368,90397],[92160,92728],[92736,92766],[92784,92862],[92880,92909],[92928,92975],[92992,92995],[93027,93047],[93053,93071],[93504,93548],[93760,93823],[93952,94026],[94032,94032],[94099,94111],[94176,94177],[94179,94179],[94208,100343],[100352,101589],[101631,101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[122624,122654],[122661,122666],[122928,122989],[123136,123180],[123191,123197],[123214,123214],[123536,123565],[123584,123627],[124112,124139],[124368,124397],[124400,124400],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125184,125251],[125259,125259],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"General_Category/Close_Punctuation":[[41,41],[93,93],[125,125],[3899,3899],[3901,3901],[5788,5788],[8262,8262],[8318,8318],[8334,8334],[8969,8969],[8971,8971],[9002,9002],[10089,10089],[10091,10091],[10093,10093],[10095,10095],[10097,10097],[10099,10099],[10101,10101],[10182,10182],[10215,10215],[10217,10217],[10219,10219],[10221,10221],[10223,10223],[10628,10628],[10630,10630],[10632,10632],[10634,10634],[10636,10636],[10638,10638],[10640,10640],[10642,10642],[10644,10644],[10646,10646],[10648,10648],[10713,10713],[10715,10715],[10749,10749],[11811,11811],[11813,11813],[11815,11815],[11817,11817],[11862,11862],[11864,11864],[11866,11866],[11868,11868],[12297,12297],[12299,12299],[12301,12301],[12303,12303],[12305,12305],[12309,12309],[12311,12311],[12313,12313],[12315,12315],[12318,12319],[64830,64830],[65048,65048],[65078,65078],[65080,65080],[65082,65082],[65084,65084],[65086,65086],[65088,65088],[65090,65090],[65092,65092],[65096,65096],[65114,65114],[65116,65116],[65118,65118],[65289,65289],[65341,65341],[65373,65373],[65376,65376],[65379,65379]],"General_Category/Private_Use":[[57344,63743],[983040,1048573],[1048576,1114109]],"General_Category/Paragraph_Separator":[[8233,8233]],"General_Category/Nonspacing_Mark":[[768,879],[1155,1159],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1552,1562],[1611,1631],[1648,1648],[1750,1756],[1759,1764],[1767,1768],[1770,1773],[1809,1809],[1840,1866],[1958,1968],[2027,2035],[2045,2045],[2070,2073],[2075,2083],[2085,2087],[2089,2093],[2137,2139],[2199,2207],[2250,2273],[2275,2306],[2362,2362],[2364,2364],[2369,2376],[2381,2381],[2385,2391],[2402,2403],[2433,2433],[2492,2492],[2497,2500],[2509,2509],[2530,2531],[2558,2558],[2561,2562],[2620,2620],[2625,2626],[2631,2632],[2635,2637],[2641,2641],[2672,2673],[2677,2677],[2689,2690],[2748,2748],[2753,2757],[2759,2760],[2765,2765],[2786,2787],[2810,2815],[2817,2817],[2876,2876],[2879,2879],[2881,2884],[2893,2893],[2901,2902],[2914,2915],[2946,2946],[3008,3008],[3021,3021],[3072,3072],[3076,3076],[3132,3132],[3134,3136],[3142,3144],[3146,3149],[3157,3158],[3170,3171],[3201,3201],[3260,3260],[3263,3263],[3270,3270],[3276,3277],[3298,3299],[3328,3329],[3387,3388],[3393,3396],[3405,3405],[3426,3427],[3457,3457],[3530,3530],[3538,3540],[3542,3542],[3633,3633],[3636,3642],[3655,3662],[3761,3761],[3764,3772],[3784,3790],[3864,3865],[3893,3893],[3895,3895],[3897,3897],[3953,3966],[3968,3972],[3974,3975],[3981,3991],[3993,4028],[4038,4038],[4141,4144],[4146,4151],[4153,4154],[4157,4158],[4184,4185],[4190,4192],[4209,4212],[4226,4226],[4229,4230],[4237,4237],[4253,4253],[4957,4959],[5906,5908],[5938,5939],[5970,5971],[6002,6003],[6068,6069],[6071,6077],[6086,6086],[6089,6099],[6109,6109],[6155,6157],[6159,6159],[6277,6278],[6313,6313],[6432,6434],[6439,6440],[6450,6450],[6457,6459],[6679,6680],[6683,6683],[6742,6742],[6744,6750],[6752,6752],[6754,6754],[6757,6764],[6771,6780],[6783,6783],[6832,6845],[6847,6862],[6912,6915],[6964,6964],[6966,6970],[6972,6972],[6978,6978],[7019,7027],[7040,7041],[7074,7077],[7080,7081],[7083,7085],[7142,7142],[7144,7145],[7149,7149],[7151,7153],[7212,7219],[7222,7223],[7376,7378],[7380,7392],[7394,7400],[7405,7405],[7412,7412],[7416,7417],[7616,7679],[8400,8412],[8417,8417],[8421,8432],[11503,11505],[11647,11647],[11744,11775],[12330,12333],[12441,12442],[42607,42607],[42612,42621],[42654,42655],[42736,42737],[43010,43010],[43014,43014],[43019,43019],[43045,43046],[43052,43052],[43204,43205],[43232,43249],[43263,43263],[43302,43309],[43335,43345],[43392,43394],[43443,43443],[43446,43449],[43452,43453],[43493,43493],[43561,43566],[43569,43570],[43573,43574],[43587,43587],[43596,43596],[43644,43644],[43696,43696],[43698,43700],[43703,43704],[43710,43711],[43713,43713],[43756,43757],[43766,43766],[44005,44005],[44008,44008],[44013,44013],[64286,64286],[65024,65039],[65056,65071],[66045,66045],[66272,66272],[66422,66426],[68097,68099],[68101,68102],[68108,68111],[68152,68154],[68159,68159],[68325,68326],[68900,68903],[68969,68973],[69291,69292],[69372,69375],[69446,69456],[69506,69509],[69633,69633],[69688,69702],[69744,69744],[69747,69748],[69759,69761],[69811,69814],[69817,69818],[69826,69826],[69888,69890],[69927,69931],[69933,69940],[70003,70003],[70016,70017],[70070,70078],[70089,70092],[70095,70095],[70191,70193],[70196,70196],[70198,70199],[70206,70206],[70209,70209],[70367,70367],[70371,70378],[70400,70401],[70459,70460],[70464,70464],[70502,70508],[70512,70516],[70587,70592],[70606,70606],[70608,70608],[70610,70610],[70625,70626],[70712,70719],[70722,70724],[70726,70726],[70750,70750],[70835,70840],[70842,70842],[70847,70848],[70850,70851],[71090,71093],[71100,71101],[71103,71104],[71132,71133],[71219,71226],[71229,71229],[71231,71232],[71339,71339],[71341,71341],[71344,71349],[71351,71351],[71453,71453],[71455,71455],[71458,71461],[71463,71467],[71727,71735],[71737,71738],[71995,71996],[71998,71998],[72003,72003],[72148,72151],[72154,72155],[72160,72160],[72193,72202],[72243,72248],[72251,72254],[72263,72263],[72273,72278],[72281,72283],[72330,72342],[72344,72345],[72752,72758],[72760,72765],[72767,72767],[72850,72871],[72874,72880],[72882,72883],[72885,72886],[73009,73014],[73018,73018],[73020,73021],[73023,73029],[73031,73031],[73104,73105],[73109,73109],[73111,73111],[73459,73460],[73472,73473],[73526,73530],[73536,73536],[73538,73538],[73562,73562],[78912,78912],[78919,78933],[90398,90409],[90413,90415],[92912,92916],[92976,92982],[94031,94031],[94095,94098],[94180,94180],[113821,113822],[118528,118573],[118576,118598],[119143,119145],[119163,119170],[119173,119179],[119210,119213],[119362,119364],[121344,121398],[121403,121452],[121461,121461],[121476,121476],[121499,121503],[121505,121519],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[123023,123023],[123184,123190],[123566,123566],[123628,123631],[124140,124143],[124398,124399],[125136,125142],[125252,125258],[917760,917999]],"General_Category/Modifier_Symbol":[[94,94],[96,96],[168,168],[175,175],[180,180],[184,184],[706,709],[722,735],[741,747],[749,749],[751,767],[885,885],[900,901],[2184,2184],[8125,8125],[8127,8129],[8141,8143],[8157,8159],[8173,8175],[8189,8190],[12443,12444],[42752,42774],[42784,42785],[42889,42890],[43867,43867],[43882,43883],[64434,64450],[65342,65342],[65344,65344],[65507,65507],[127995,127999]],"General_Category/Symbol":[[36,36],[43,43],[60,62],[94,94],[96,96],[124,124],[126,126],[162,166],[168,169],[172,172],[174,177],[180,180],[184,184],[215,215],[247,247],[706,709],[722,735],[741,747],[749,749],[751,767],[885,885],[900,901],[1014,1014],[1154,1154],[1421,1423],[1542,1544],[1547,1547],[1550,1551],[1758,1758],[1769,1769],[1789,1790],[2038,2038],[2046,2047],[2184,2184],[2546,2547],[2554,2555],[2801,2801],[2928,2928],[3059,3066],[3199,3199],[3407,3407],[3449,3449],[3647,3647],[3841,3843],[3859,3859],[3861,3863],[3866,3871],[3892,3892],[3894,3894],[3896,3896],[4030,4037],[4039,4044],[4046,4047],[4053,4056],[4254,4255],[5008,5017],[5741,5741],[6107,6107],[6464,6464],[6622,6655],[7009,7018],[7028,7036],[8125,8125],[8127,8129],[8141,8143],[8157,8159],[8173,8175],[8189,8190],[8260,8260],[8274,8274],[8314,8316],[8330,8332],[8352,8384],[8448,8449],[8451,8454],[8456,8457],[8468,8468],[8470,8472],[8478,8483],[8485,8485],[8487,8487],[8489,8489],[8494,8494],[8506,8507],[8512,8516],[8522,8525],[8527,8527],[8586,8587],[8592,8967],[8972,9000],[9003,9257],[9280,9290],[9372,9449],[9472,10087],[10132,10180],[10183,10213],[10224,10626],[10649,10711],[10716,10747],[10750,11123],[11126,11157],[11159,11263],[11493,11498],[11856,11857],[11904,11929],[11931,12019],[12032,12245],[12272,12287],[12292,12292],[12306,12307],[12320,12320],[12342,12343],[12350,12351],[12443,12444],[12688,12689],[12694,12703],[12736,12773],[12783,12783],[12800,12830],[12842,12871],[12880,12880],[12896,12927],[12938,12976],[12992,13311],[19904,19967],[42128,42182],[42752,42774],[42784,42785],[42889,42890],[43048,43051],[43062,43065],[43639,43641],[43867,43867],[43882,43883],[64297,64297],[64434,64450],[64832,64847],[64975,64975],[65020,65023],[65122,65122],[65124,65126],[65129,65129],[65284,65284],[65291,65291],[65308,65310],[65342,65342],[65344,65344],[65372,65372],[65374,65374],[65504,65510],[65512,65518],[65532,65533],[65847,65855],[65913,65929],[65932,65934],[65936,65948],[65952,65952],[66000,66044],[67703,67704],[68296,68296],[69006,69007],[71487,71487],[73685,73713],[92988,92991],[92997,92997],[113820,113820],[117760,117999],[118016,118451],[118608,118723],[118784,119029],[119040,119078],[119081,119140],[119146,119148],[119171,119172],[119180,119209],[119214,119274],[119296,119361],[119365,119365],[119552,119638],[120513,120513],[120539,120539],[120571,120571],[120597,120597],[120629,120629],[120655,120655],[120687,120687],[120713,120713],[120745,120745],[120771,120771],[120832,121343],[121399,121402],[121453,121460],[121462,121475],[121477,121478],[123215,123215],[123647,123647],[126124,126124],[126128,126128],[126254,126254],[126704,126705],[126976,127019],[127024,127123],[127136,127150],[127153,127167],[127169,127183],[127185,127221],[127245,127405],[127462,127490],[127504,127547],[127552,127560],[127568,127569],[127584,127589],[127744,128727],[128732,128748],[128752,128764],[128768,128886],[128891,128985],[128992,129003],[129008,129008],[129024,129035],[129040,129095],[129104,129113],[129120,129159],[129168,129197],[129200,129211],[129216,129217],[129280,129619],[129632,129645],[129648,129660],[129664,129673],[129679,129734],[129742,129756],[129759,129769],[129776,129784],[129792,129938],[129940,130031]],"General_Category/Cased_Letter":[[65,90],[97,122],[181,181],[192,214],[216,246],[248,442],[444,447],[452,659],[661,687],[880,883],[886,887],[891,893],[895,895],[902,902],[904,906],[908,908],[910,929],[931,1013],[1015,1153],[1162,1327],[1329,1366],[1376,1416],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4349,4351],[5024,5109],[5112,5117],[7296,7306],[7312,7354],[7357,7359],[7424,7467],[7531,7543],[7545,7578],[7680,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8473,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8493],[8495,8500],[8505,8505],[8508,8511],[8517,8521],[8526,8526],[8579,8580],[11264,11387],[11390,11492],[11499,11502],[11506,11507],[11520,11557],[11559,11559],[11565,11565],[42560,42605],[42624,42651],[42786,42863],[42865,42887],[42891,42894],[42896,42957],[42960,42961],[42963,42963],[42965,42972],[42997,42998],[43002,43002],[43824,43866],[43872,43880],[43888,43967],[64256,64262],[64275,64279],[65313,65338],[65345,65370],[66560,66639],[66736,66771],[66776,66811],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[68736,68786],[68800,68850],[68944,68965],[68976,68997],[71840,71903],[93760,93823],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[122624,122633],[122635,122654],[122661,122666],[125184,125251]],"General_Category/Line_Separator":[[8232,8232]],"General_Category/Currency_Symbol":[[36,36],[162,165],[1423,1423],[1547,1547],[2046,2047],[2546,2547],[2555,2555],[2801,2801],[3065,3065],[3647,3647],[6107,6107],[8352,8384],[43064,43064],[65020,65020],[65129,65129],[65284,65284],[65504,65505],[65509,65510],[73693,73696],[123647,123647],[126128,126128]],"General_Category/Uppercase_Letter":[[65,90],[192,214],[216,222],[256,256],[258,258],[260,260],[262,262],[264,264],[266,266],[268,268],[270,270],[272,272],[274,274],[276,276],[278,278],[280,280],[282,282],[284,284],[286,286],[288,288],[290,290],[292,292],[294,294],[296,296],[298,298],[300,300],[302,302],[304,304],[306,306],[308,308],[310,310],[313,313],[315,315],[317,317],[319,319],[321,321],[323,323],[325,325],[327,327],[330,330],[332,332],[334,334],[336,336],[338,338],[340,340],[342,342],[344,344],[346,346],[348,348],[350,350],[352,352],[354,354],[356,356],[358,358],[360,360],[362,362],[364,364],[366,366],[368,368],[370,370],[372,372],[374,374],[376,377],[379,379],[381,381],[385,386],[388,388],[390,391],[393,395],[398,401],[403,404],[406,408],[412,413],[415,416],[418,418],[420,420],[422,423],[425,425],[428,428],[430,431],[433,435],[437,437],[439,440],[444,444],[452,452],[455,455],[458,458],[461,461],[463,463],[465,465],[467,467],[469,469],[471,471],[473,473],[475,475],[478,478],[480,480],[482,482],[484,484],[486,486],[488,488],[490,490],[492,492],[494,494],[497,497],[500,500],[502,504],[506,506],[508,508],[510,510],[512,512],[514,514],[516,516],[518,518],[520,520],[522,522],[524,524],[526,526],[528,528],[530,530],[532,532],[534,534],[536,536],[538,538],[540,540],[542,542],[544,544],[546,546],[548,548],[550,550],[552,552],[554,554],[556,556],[558,558],[560,560],[562,562],[570,571],[573,574],[577,577],[579,582],[584,584],[586,586],[588,588],[590,590],[880,880],[882,882],[886,886],[895,895],[902,902],[904,906],[908,908],[910,911],[913,929],[931,939],[975,975],[978,980],[984,984],[986,986],[988,988],[990,990],[992,992],[994,994],[996,996],[998,998],[1000,1000],[1002,1002],[1004,1004],[1006,1006],[1012,1012],[1015,1015],[1017,1018],[1021,1071],[1120,1120],[1122,1122],[1124,1124],[1126,1126],[1128,1128],[1130,1130],[1132,1132],[1134,1134],[1136,1136],[1138,1138],[1140,1140],[1142,1142],[1144,1144],[1146,1146],[1148,1148],[1150,1150],[1152,1152],[1162,1162],[1164,1164],[1166,1166],[1168,1168],[1170,1170],[1172,1172],[1174,1174],[1176,1176],[1178,1178],[1180,1180],[1182,1182],[1184,1184],[1186,1186],[1188,1188],[1190,1190],[1192,1192],[1194,1194],[1196,1196],[1198,1198],[1200,1200],[1202,1202],[1204,1204],[1206,1206],[1208,1208],[1210,1210],[1212,1212],[1214,1214],[1216,1217],[1219,1219],[1221,1221],[1223,1223],[1225,1225],[1227,1227],[1229,1229],[1232,1232],[1234,1234],[1236,1236],[1238,1238],[1240,1240],[1242,1242],[1244,1244],[1246,1246],[1248,1248],[1250,1250],[1252,1252],[1254,1254],[1256,1256],[1258,1258],[1260,1260],[1262,1262],[1264,1264],[1266,1266],[1268,1268],[1270,1270],[1272,1272],[1274,1274],[1276,1276],[1278,1278],[1280,1280],[1282,1282],[1284,1284],[1286,1286],[1288,1288],[1290,1290],[1292,1292],[1294,1294],[1296,1296],[1298,1298],[1300,1300],[1302,1302],[1304,1304],[1306,1306],[1308,1308],[1310,1310],[1312,1312],[1314,1314],[1316,1316],[1318,1318],[1320,1320],[1322,1322],[1324,1324],[1326,1326],[1329,1366],[4256,4293],[4295,4295],[4301,4301],[5024,5109],[7305,7305],[7312,7354],[7357,7359],[7680,7680],[7682,7682],[7684,7684],[7686,7686],[7688,7688],[7690,7690],[7692,7692],[7694,7694],[7696,7696],[7698,7698],[7700,7700],[7702,7702],[7704,7704],[7706,7706],[7708,7708],[7710,7710],[7712,7712],[7714,7714],[7716,7716],[7718,7718],[7720,7720],[7722,7722],[7724,7724],[7726,7726],[7728,7728],[7730,7730],[7732,7732],[7734,7734],[7736,7736],[7738,7738],[7740,7740],[7742,7742],[7744,7744],[7746,7746],[7748,7748],[7750,7750],[7752,7752],[7754,7754],[7756,7756],[7758,7758],[7760,7760],[7762,7762],[7764,7764],[7766,7766],[7768,7768],[7770,7770],[7772,7772],[7774,7774],[7776,7776],[7778,7778],[7780,7780],[7782,7782],[7784,7784],[7786,7786],[7788,7788],[7790,7790],[7792,7792],[7794,7794],[7796,7796],[7798,7798],[7800,7800],[7802,7802],[7804,7804],[7806,7806],[7808,7808],[7810,7810],[7812,7812],[7814,7814],[7816,7816],[7818,7818],[7820,7820],[7822,7822],[7824,7824],[7826,7826],[7828,7828],[7838,7838],[7840,7840],[7842,7842],[7844,7844],[7846,7846],[7848,7848],[7850,7850],[7852,7852],[7854,7854],[7856,7856],[7858,7858],[7860,7860],[7862,7862],[7864,7864],[7866,7866],[7868,7868],[7870,7870],[7872,7872],[7874,7874],[7876,7876],[7878,7878],[7880,7880],[7882,7882],[7884,7884],[7886,7886],[7888,7888],[7890,7890],[7892,7892],[7894,7894],[7896,7896],[7898,7898],[7900,7900],[7902,7902],[7904,7904],[7906,7906],[7908,7908],[7910,7910],[7912,7912],[7914,7914],[7916,7916],[7918,7918],[7920,7920],[7922,7922],[7924,7924],[7926,7926],[7928,7928],[7930,7930],[7932,7932],[7934,7934],[7944,7951],[7960,7965],[7976,7983],[7992,7999],[8008,8013],[8025,8025],[8027,8027],[8029,8029],[8031,8031],[8040,8047],[8120,8123],[8136,8139],[8152,8155],[8168,8172],[8184,8187],[8450,8450],[8455,8455],[8459,8461],[8464,8466],[8469,8469],[8473,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8493],[8496,8499],[8510,8511],[8517,8517],[8579,8579],[11264,11311],[11360,11360],[11362,11364],[11367,11367],[11369,11369],[11371,11371],[11373,11376],[11378,11378],[11381,11381],[11390,11392],[11394,11394],[11396,11396],[11398,11398],[11400,11400],[11402,11402],[11404,11404],[11406,11406],[11408,11408],[11410,11410],[11412,11412],[11414,11414],[11416,11416],[11418,11418],[11420,11420],[11422,11422],[11424,11424],[11426,11426],[11428,11428],[11430,11430],[11432,11432],[11434,11434],[11436,11436],[11438,11438],[11440,11440],[11442,11442],[11444,11444],[11446,11446],[11448,11448],[11450,11450],[11452,11452],[11454,11454],[11456,11456],[11458,11458],[11460,11460],[11462,11462],[11464,11464],[11466,11466],[11468,11468],[11470,11470],[11472,11472],[11474,11474],[11476,11476],[11478,11478],[11480,11480],[11482,11482],[11484,11484],[11486,11486],[11488,11488],[11490,11490],[11499,11499],[11501,11501],[11506,11506],[42560,42560],[42562,42562],[42564,42564],[42566,42566],[42568,42568],[42570,42570],[42572,42572],[42574,42574],[42576,42576],[42578,42578],[42580,42580],[42582,42582],[42584,42584],[42586,42586],[42588,42588],[42590,42590],[42592,42592],[42594,42594],[42596,42596],[42598,42598],[42600,42600],[42602,42602],[42604,42604],[42624,42624],[42626,42626],[42628,42628],[42630,42630],[42632,42632],[42634,42634],[42636,42636],[42638,42638],[42640,42640],[42642,42642],[42644,42644],[42646,42646],[42648,42648],[42650,42650],[42786,42786],[42788,42788],[42790,42790],[42792,42792],[42794,42794],[42796,42796],[42798,42798],[42802,42802],[42804,42804],[42806,42806],[42808,42808],[42810,42810],[42812,42812],[42814,42814],[42816,42816],[42818,42818],[42820,42820],[42822,42822],[42824,42824],[42826,42826],[42828,42828],[42830,42830],[42832,42832],[42834,42834],[42836,42836],[42838,42838],[42840,42840],[42842,42842],[42844,42844],[42846,42846],[42848,42848],[42850,42850],[42852,42852],[42854,42854],[42856,42856],[42858,42858],[42860,42860],[42862,42862],[42873,42873],[42875,42875],[42877,42878],[42880,42880],[42882,42882],[42884,42884],[42886,42886],[42891,42891],[42893,42893],[42896,42896],[42898,42898],[42902,42902],[42904,42904],[42906,42906],[42908,42908],[42910,42910],[42912,42912],[42914,42914],[42916,42916],[42918,42918],[42920,42920],[42922,42926],[42928,42932],[42934,42934],[42936,42936],[42938,42938],[42940,42940],[42942,42942],[42944,42944],[42946,42946],[42948,42951],[42953,42953],[42955,42956],[42960,42960],[42966,42966],[42968,42968],[42970,42970],[42972,42972],[42997,42997],[65313,65338],[66560,66599],[66736,66771],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[68736,68786],[68944,68965],[71840,71871],[93760,93791],[119808,119833],[119860,119885],[119912,119937],[119964,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119989],[120016,120041],[120068,120069],[120071,120074],[120077,120084],[120086,120092],[120120,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120172,120197],[120224,120249],[120276,120301],[120328,120353],[120380,120405],[120432,120457],[120488,120512],[120546,120570],[120604,120628],[120662,120686],[120720,120744],[120778,120778],[125184,125217]],"General_Category/Other_Punctuation":[[33,35],[37,39],[42,42],[44,44],[46,47],[58,59],[63,64],[92,92],[161,161],[167,167],[182,183],[191,191],[894,894],[903,903],[1370,1375],[1417,1417],[1472,1472],[1475,1475],[1478,1478],[1523,1524],[1545,1546],[1548,1549],[1563,1563],[1565,1567],[1642,1645],[1748,1748],[1792,1805],[2039,2041],[2096,2110],[2142,2142],[2404,2405],[2416,2416],[2557,2557],[2678,2678],[2800,2800],[3191,3191],[3204,3204],[3572,3572],[3663,3663],[3674,3675],[3844,3858],[3860,3860],[3973,3973],[4048,4052],[4057,4058],[4170,4175],[4347,4347],[4960,4968],[5742,5742],[5867,5869],[5941,5942],[6100,6102],[6104,6106],[6144,6149],[6151,6154],[6468,6469],[6686,6687],[6816,6822],[6824,6829],[6990,6991],[7002,7008],[7037,7039],[7164,7167],[7227,7231],[7294,7295],[7360,7367],[7379,7379],[8214,8215],[8224,8231],[8240,8248],[8251,8254],[8257,8259],[8263,8273],[8275,8275],[8277,8286],[11513,11516],[11518,11519],[11632,11632],[11776,11777],[11782,11784],[11787,11787],[11790,11798],[11800,11801],[11803,11803],[11806,11807],[11818,11822],[11824,11833],[11836,11839],[11841,11841],[11843,11855],[11858,11860],[12289,12291],[12349,12349],[12539,12539],[42238,42239],[42509,42511],[42611,42611],[42622,42622],[42738,42743],[43124,43127],[43214,43215],[43256,43258],[43260,43260],[43310,43311],[43359,43359],[43457,43469],[43486,43487],[43612,43615],[43742,43743],[43760,43761],[44011,44011],[65040,65046],[65049,65049],[65072,65072],[65093,65094],[65097,65100],[65104,65106],[65108,65111],[65119,65121],[65128,65128],[65130,65131],[65281,65283],[65285,65287],[65290,65290],[65292,65292],[65294,65295],[65306,65307],[65311,65312],[65340,65340],[65377,65377],[65380,65381],[65792,65794],[66463,66463],[66512,66512],[66927,66927],[67671,67671],[67871,67871],[67903,67903],[68176,68184],[68223,68223],[68336,68342],[68409,68415],[68505,68508],[69461,69465],[69510,69513],[69703,69709],[69819,69820],[69822,69825],[69952,69955],[70004,70005],[70085,70088],[70093,70093],[70107,70107],[70109,70111],[70200,70205],[70313,70313],[70612,70613],[70615,70616],[70731,70735],[70746,70747],[70749,70749],[70854,70854],[71105,71127],[71233,71235],[71264,71276],[71353,71353],[71484,71486],[71739,71739],[72004,72006],[72162,72162],[72255,72262],[72346,72348],[72350,72354],[72448,72457],[72673,72673],[72769,72773],[72816,72817],[73463,73464],[73539,73551],[73727,73727],[74864,74868],[77809,77810],[92782,92783],[92917,92917],[92983,92987],[92996,92996],[93549,93551],[93847,93850],[94178,94178],[113823,113823],[121479,121483],[124415,124415],[125278,125279]],"General_Category/Mark":[[768,879],[1155,1161],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1552,1562],[1611,1631],[1648,1648],[1750,1756],[1759,1764],[1767,1768],[1770,1773],[1809,1809],[1840,1866],[1958,1968],[2027,2035],[2045,2045],[2070,2073],[2075,2083],[2085,2087],[2089,2093],[2137,2139],[2199,2207],[2250,2273],[2275,2307],[2362,2364],[2366,2383],[2385,2391],[2402,2403],[2433,2435],[2492,2492],[2494,2500],[2503,2504],[2507,2509],[2519,2519],[2530,2531],[2558,2558],[2561,2563],[2620,2620],[2622,2626],[2631,2632],[2635,2637],[2641,2641],[2672,2673],[2677,2677],[2689,2691],[2748,2748],[2750,2757],[2759,2761],[2763,2765],[2786,2787],[2810,2815],[2817,2819],[2876,2876],[2878,2884],[2887,2888],[2891,2893],[2901,2903],[2914,2915],[2946,2946],[3006,3010],[3014,3016],[3018,3021],[3031,3031],[3072,3076],[3132,3132],[3134,3140],[3142,3144],[3146,3149],[3157,3158],[3170,3171],[3201,3203],[3260,3260],[3262,3268],[3270,3272],[3274,3277],[3285,3286],[3298,3299],[3315,3315],[3328,3331],[3387,3388],[3390,3396],[3398,3400],[3402,3405],[3415,3415],[3426,3427],[3457,3459],[3530,3530],[3535,3540],[3542,3542],[3544,3551],[3570,3571],[3633,3633],[3636,3642],[3655,3662],[3761,3761],[3764,3772],[3784,3790],[3864,3865],[3893,3893],[3895,3895],[3897,3897],[3902,3903],[3953,3972],[3974,3975],[3981,3991],[3993,4028],[4038,4038],[4139,4158],[4182,4185],[4190,4192],[4194,4196],[4199,4205],[4209,4212],[4226,4237],[4239,4239],[4250,4253],[4957,4959],[5906,5909],[5938,5940],[5970,5971],[6002,6003],[6068,6099],[6109,6109],[6155,6157],[6159,6159],[6277,6278],[6313,6313],[6432,6443],[6448,6459],[6679,6683],[6741,6750],[6752,6780],[6783,6783],[6832,6862],[6912,6916],[6964,6980],[7019,7027],[7040,7042],[7073,7085],[7142,7155],[7204,7223],[7376,7378],[7380,7400],[7405,7405],[7412,7412],[7415,7417],[7616,7679],[8400,8432],[11503,11505],[11647,11647],[11744,11775],[12330,12335],[12441,12442],[42607,42610],[42612,42621],[42654,42655],[42736,42737],[43010,43010],[43014,43014],[43019,43019],[43043,43047],[43052,43052],[43136,43137],[43188,43205],[43232,43249],[43263,43263],[43302,43309],[43335,43347],[43392,43395],[43443,43456],[43493,43493],[43561,43574],[43587,43587],[43596,43597],[43643,43645],[43696,43696],[43698,43700],[43703,43704],[43710,43711],[43713,43713],[43755,43759],[43765,43766],[44003,44010],[44012,44013],[64286,64286],[65024,65039],[65056,65071],[66045,66045],[66272,66272],[66422,66426],[68097,68099],[68101,68102],[68108,68111],[68152,68154],[68159,68159],[68325,68326],[68900,68903],[68969,68973],[69291,69292],[69372,69375],[69446,69456],[69506,69509],[69632,69634],[69688,69702],[69744,69744],[69747,69748],[69759,69762],[69808,69818],[69826,69826],[69888,69890],[69927,69940],[69957,69958],[70003,70003],[70016,70018],[70067,70080],[70089,70092],[70094,70095],[70188,70199],[70206,70206],[70209,70209],[70367,70378],[70400,70403],[70459,70460],[70462,70468],[70471,70472],[70475,70477],[70487,70487],[70498,70499],[70502,70508],[70512,70516],[70584,70592],[70594,70594],[70597,70597],[70599,70602],[70604,70608],[70610,70610],[70625,70626],[70709,70726],[70750,70750],[70832,70851],[71087,71093],[71096,71104],[71132,71133],[71216,71232],[71339,71351],[71453,71467],[71724,71738],[71984,71989],[71991,71992],[71995,71998],[72000,72000],[72002,72003],[72145,72151],[72154,72160],[72164,72164],[72193,72202],[72243,72249],[72251,72254],[72263,72263],[72273,72283],[72330,72345],[72751,72758],[72760,72767],[72850,72871],[72873,72886],[73009,73014],[73018,73018],[73020,73021],[73023,73029],[73031,73031],[73098,73102],[73104,73105],[73107,73111],[73459,73462],[73472,73473],[73475,73475],[73524,73530],[73534,73538],[73562,73562],[78912,78912],[78919,78933],[90398,90415],[92912,92916],[92976,92982],[94031,94031],[94033,94087],[94095,94098],[94180,94180],[94192,94193],[113821,113822],[118528,118573],[118576,118598],[119141,119145],[119149,119154],[119163,119170],[119173,119179],[119210,119213],[119362,119364],[121344,121398],[121403,121452],[121461,121461],[121476,121476],[121499,121503],[121505,121519],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[123023,123023],[123184,123190],[123566,123566],[123628,123631],[124140,124143],[124398,124399],[125136,125142],[125252,125258],[917760,917999]],"General_Category/Unassigned":[[888,889],[896,899],[907,907],[909,909],[930,930],[1328,1328],[1367,1368],[1419,1420],[1424,1424],[1480,1487],[1515,1518],[1525,1535],[1806,1806],[1867,1868],[1970,1983],[2043,2044],[2094,2095],[2111,2111],[2140,2141],[2143,2143],[2155,2159],[2191,2191],[2194,2198],[2436,2436],[2445,2446],[2449,2450],[2473,2473],[2481,2481],[2483,2485],[2490,2491],[2501,2502],[2505,2506],[2511,2518],[2520,2523],[2526,2526],[2532,2533],[2559,2560],[2564,2564],[2571,2574],[2577,2578],[2601,2601],[2609,2609],[2612,2612],[2615,2615],[2618,2619],[2621,2621],[2627,2630],[2633,2634],[2638,2640],[2642,2648],[2653,2653],[2655,2661],[2679,2688],[2692,2692],[2702,2702],[2706,2706],[2729,2729],[2737,2737],[2740,2740],[2746,2747],[2758,2758],[2762,2762],[2766,2767],[2769,2783],[2788,2789],[2802,2808],[2816,2816],[2820,2820],[2829,2830],[2833,2834],[2857,2857],[2865,2865],[2868,2868],[2874,2875],[2885,2886],[2889,2890],[2894,2900],[2904,2907],[2910,2910],[2916,2917],[2936,2945],[2948,2948],[2955,2957],[2961,2961],[2966,2968],[2971,2971],[2973,2973],[2976,2978],[2981,2983],[2987,2989],[3002,3005],[3011,3013],[3017,3017],[3022,3023],[3025,3030],[3032,3045],[3067,3071],[3085,3085],[3089,3089],[3113,3113],[3130,3131],[3141,3141],[3145,3145],[3150,3156],[3159,3159],[3163,3164],[3166,3167],[3172,3173],[3184,3190],[3213,3213],[3217,3217],[3241,3241],[3252,3252],[3258,3259],[3269,3269],[3273,3273],[3278,3284],[3287,3292],[3295,3295],[3300,3301],[3312,3312],[3316,3327],[3341,3341],[3345,3345],[3397,3397],[3401,3401],[3408,3411],[3428,3429],[3456,3456],[3460,3460],[3479,3481],[3506,3506],[3516,3516],[3518,3519],[3527,3529],[3531,3534],[3541,3541],[3543,3543],[3552,3557],[3568,3569],[3573,3584],[3643,3646],[3676,3712],[3715,3715],[3717,3717],[3723,3723],[3748,3748],[3750,3750],[3774,3775],[3781,3781],[3783,3783],[3791,3791],[3802,3803],[3808,3839],[3912,3912],[3949,3952],[3992,3992],[4029,4029],[4045,4045],[4059,4095],[4294,4294],[4296,4300],[4302,4303],[4681,4681],[4686,4687],[4695,4695],[4697,4697],[4702,4703],[4745,4745],[4750,4751],[4785,4785],[4790,4791],[4799,4799],[4801,4801],[4806,4807],[4823,4823],[4881,4881],[4886,4887],[4955,4956],[4989,4991],[5018,5023],[5110,5111],[5118,5119],[5789,5791],[5881,5887],[5910,5918],[5943,5951],[5972,5983],[5997,5997],[6001,6001],[6004,6015],[6110,6111],[6122,6127],[6138,6143],[6170,6175],[6265,6271],[6315,6319],[6390,6399],[6431,6431],[6444,6447],[6460,6463],[6465,6467],[6510,6511],[6517,6527],[6572,6575],[6602,6607],[6619,6621],[6684,6685],[6751,6751],[6781,6782],[6794,6799],[6810,6815],[6830,6831],[6863,6911],[6989,6989],[7156,7163],[7224,7226],[7242,7244],[7307,7311],[7355,7356],[7368,7375],[7419,7423],[7958,7959],[7966,7967],[8006,8007],[8014,8015],[8024,8024],[8026,8026],[8028,8028],[8030,8030],[8062,8063],[8117,8117],[8133,8133],[8148,8149],[8156,8156],[8176,8177],[8181,8181],[8191,8191],[8293,8293],[8306,8307],[8335,8335],[8349,8351],[8385,8399],[8433,8447],[8588,8591],[9258,9279],[9291,9311],[11124,11125],[11158,11158],[11508,11512],[11558,11558],[11560,11564],[11566,11567],[11624,11630],[11633,11646],[11671,11679],[11687,11687],[11695,11695],[11703,11703],[11711,11711],[11719,11719],[11727,11727],[11735,11735],[11743,11743],[11870,11903],[11930,11930],[12020,12031],[12246,12271],[12352,12352],[12439,12440],[12544,12548],[12592,12592],[12687,12687],[12774,12782],[12831,12831],[42125,42127],[42183,42191],[42540,42559],[42744,42751],[42958,42959],[42962,42962],[42964,42964],[42973,42993],[43053,43055],[43066,43071],[43128,43135],[43206,43213],[43226,43231],[43348,43358],[43389,43391],[43470,43470],[43482,43485],[43519,43519],[43575,43583],[43598,43599],[43610,43611],[43715,43738],[43767,43776],[43783,43784],[43791,43792],[43799,43807],[43815,43815],[43823,43823],[43884,43887],[44014,44015],[44026,44031],[55204,55215],[55239,55242],[55292,55295],[64110,64111],[64218,64255],[64263,64274],[64280,64284],[64311,64311],[64317,64317],[64319,64319],[64322,64322],[64325,64325],[64451,64466],[64912,64913],[64968,64974],[64976,65007],[65050,65055],[65107,65107],[65127,65127],[65132,65135],[65141,65141],[65277,65278],[65280,65280],[65471,65473],[65480,65481],[65488,65489],[65496,65497],[65501,65503],[65511,65511],[65519,65528],[65534,65535],[65548,65548],[65575,65575],[65595,65595],[65598,65598],[65614,65615],[65630,65663],[65787,65791],[65795,65798],[65844,65846],[65935,65935],[65949,65951],[65953,65999],[66046,66175],[66205,66207],[66257,66271],[66300,66303],[66340,66348],[66379,66383],[66427,66431],[66462,66462],[66500,66503],[66518,66559],[66718,66719],[66730,66735],[66772,66775],[66812,66815],[66856,66863],[66916,66926],[66939,66939],[66955,66955],[66963,66963],[66966,66966],[66978,66978],[66994,66994],[67002,67002],[67005,67007],[67060,67071],[67383,67391],[67414,67423],[67432,67455],[67462,67462],[67505,67505],[67515,67583],[67590,67591],[67593,67593],[67638,67638],[67641,67643],[67645,67646],[67670,67670],[67743,67750],[67760,67807],[67827,67827],[67830,67834],[67868,67870],[67898,67902],[67904,67967],[68024,68027],[68048,68049],[68100,68100],[68103,68107],[68116,68116],[68120,68120],[68150,68151],[68155,68158],[68169,68175],[68185,68191],[68256,68287],[68327,68330],[68343,68351],[68406,68408],[68438,68439],[68467,68471],[68498,68504],[68509,68520],[68528,68607],[68681,68735],[68787,68799],[68851,68857],[68904,68911],[68922,68927],[68966,68968],[68998,69005],[69008,69215],[69247,69247],[69290,69290],[69294,69295],[69298,69313],[69317,69371],[69416,69423],[69466,69487],[69514,69551],[69580,69599],[69623,69631],[69710,69713],[69750,69758],[69827,69836],[69838,69839],[69865,69871],[69882,69887],[69941,69941],[69960,69967],[70007,70015],[70112,70112],[70133,70143],[70162,70162],[70210,70271],[70279,70279],[70281,70281],[70286,70286],[70302,70302],[70314,70319],[70379,70383],[70394,70399],[70404,70404],[70413,70414],[70417,70418],[70441,70441],[70449,70449],[70452,70452],[70458,70458],[70469,70470],[70473,70474],[70478,70479],[70481,70486],[70488,70492],[70500,70501],[70509,70511],[70517,70527],[70538,70538],[70540,70541],[70543,70543],[70582,70582],[70593,70593],[70595,70596],[70598,70598],[70603,70603],[70614,70614],[70617,70624],[70627,70655],[70748,70748],[70754,70783],[70856,70863],[70874,71039],[71094,71095],[71134,71167],[71237,71247],[71258,71263],[71277,71295],[71354,71359],[71370,71375],[71396,71423],[71451,71452],[71468,71471],[71495,71679],[71740,71839],[71923,71934],[71943,71944],[71946,71947],[71956,71956],[71959,71959],[71990,71990],[71993,71994],[72007,72015],[72026,72095],[72104,72105],[72152,72153],[72165,72191],[72264,72271],[72355,72367],[72441,72447],[72458,72639],[72674,72687],[72698,72703],[72713,72713],[72759,72759],[72774,72783],[72813,72815],[72848,72849],[72872,72872],[72887,72959],[72967,72967],[72970,72970],[73015,73017],[73019,73019],[73022,73022],[73032,73039],[73050,73055],[73062,73062],[73065,73065],[73103,73103],[73106,73106],[73113,73119],[73130,73439],[73465,73471],[73489,73489],[73531,73533],[73563,73647],[73649,73663],[73714,73726],[74650,74751],[74863,74863],[74869,74879],[75076,77711],[77811,77823],[78934,78943],[82939,82943],[83527,90367],[90426,92159],[92729,92735],[92767,92767],[92778,92781],[92863,92863],[92874,92879],[92910,92911],[92918,92927],[92998,93007],[93018,93018],[93026,93026],[93048,93052],[93072,93503],[93562,93759],[93851,93951],[94027,94030],[94088,94094],[94112,94175],[94181,94191],[94194,94207],[100344,100351],[101590,101630],[101641,110575],[110580,110580],[110588,110588],[110591,110591],[110883,110897],[110899,110927],[110931,110932],[110934,110947],[110952,110959],[111356,113663],[113771,113775],[113789,113791],[113801,113807],[113818,113819],[113828,117759],[118010,118015],[118452,118527],[118574,118575],[118599,118607],[118724,118783],[119030,119039],[119079,119080],[119275,119295],[119366,119487],[119508,119519],[119540,119551],[119639,119647],[119673,119807],[119893,119893],[119965,119965],[119968,119969],[119971,119972],[119975,119976],[119981,119981],[119994,119994],[119996,119996],[120004,120004],[120070,120070],[120075,120076],[120085,120085],[120093,120093],[120122,120122],[120127,120127],[120133,120133],[120135,120137],[120145,120145],[120486,120487],[120780,120781],[121484,121498],[121504,121504],[121520,122623],[122655,122660],[122667,122879],[122887,122887],[122905,122906],[122914,122914],[122917,122917],[122923,122927],[122990,123022],[123024,123135],[123181,123183],[123198,123199],[123210,123213],[123216,123535],[123567,123583],[123642,123646],[123648,124111],[124154,124367],[124411,124414],[124416,124895],[124903,124903],[124908,124908],[124911,124911],[124927,124927],[125125,125126],[125143,125183],[125260,125263],[125274,125277],[125280,126064],[126133,126208],[126270,126463],[126468,126468],[126496,126496],[126499,126499],[126501,126502],[126504,126504],[126515,126515],[126520,126520],[126522,126522],[126524,126529],[126531,126534],[126536,126536],[126538,126538],[126540,126540],[126544,126544],[126547,126547],[126549,126550],[126552,126552],[126554,126554],[126556,126556],[126558,126558],[126560,126560],[126563,126563],[126565,126566],[126571,126571],[126579,126579],[126584,126584],[126589,126589],[126591,126591],[126602,126602],[126620,126624],[126628,126628],[126634,126634],[126652,126703],[126706,126975],[127020,127023],[127124,127135],[127151,127152],[127168,127168],[127184,127184],[127222,127231],[127406,127461],[127491,127503],[127548,127551],[127561,127567],[127570,127583],[127590,127743],[128728,128731],[128749,128751],[128765,128767],[128887,128890],[128986,128991],[129004,129007],[129009,129023],[129036,129039],[129096,129103],[129114,129119],[129160,129167],[129198,129199],[129212,129215],[129218,129279],[129620,129631],[129646,129647],[129661,129663],[129674,129678],[129735,129741],[129757,129758],[129770,129775],[129785,129791],[129939,129939],[130042,131071],[173792,173823],[177978,177983],[178206,178207],[183970,183983],[191457,191471],[192094,194559],[195102,196607],[201547,201551],[205744,917504],[917506,917535],[917632,917759],[918000,983039],[1048574,1048575],[1114110,1114111]],"General_Category/Initial_Punctuation":[[171,171],[8216,8216],[8219,8220],[8223,8223],[8249,8249],[11778,11778],[11780,11780],[11785,11785],[11788,11788],[11804,11804],[11808,11808]],"General_Category/Math_Symbol":[[43,43],[60,62],[124,124],[126,126],[172,172],[177,177],[215,215],[247,247],[1014,1014],[1542,1544],[8260,8260],[8274,8274],[8314,8316],[8330,8332],[8472,8472],[8512,8516],[8523,8523],[8592,8596],[8602,8603],[8608,8608],[8611,8611],[8614,8614],[8622,8622],[8654,8655],[8658,8658],[8660,8660],[8692,8959],[8992,8993],[9084,9084],[9115,9139],[9180,9185],[9655,9655],[9665,9665],[9720,9727],[9839,9839],[10176,10180],[10183,10213],[10224,10239],[10496,10626],[10649,10711],[10716,10747],[10750,11007],[11056,11076],[11079,11084],[64297,64297],[65122,65122],[65124,65126],[65291,65291],[65308,65310],[65372,65372],[65374,65374],[65506,65506],[65513,65516],[69006,69007],[120513,120513],[120539,120539],[120571,120571],[120597,120597],[120629,120629],[120655,120655],[120687,120687],[120713,120713],[120745,120745],[120771,120771],[126704,126705]],"General_Category/Decimal_Number":[[48,57],[1632,1641],[1776,1785],[1984,1993],[2406,2415],[2534,2543],[2662,2671],[2790,2799],[2918,2927],[3046,3055],[3174,3183],[3302,3311],[3430,3439],[3558,3567],[3664,3673],[3792,3801],[3872,3881],[4160,4169],[4240,4249],[6112,6121],[6160,6169],[6470,6479],[6608,6617],[6784,6793],[6800,6809],[6992,7001],[7088,7097],[7232,7241],[7248,7257],[42528,42537],[43216,43225],[43264,43273],[43472,43481],[43504,43513],[43600,43609],[44016,44025],[65296,65305],[66720,66729],[68912,68921],[68928,68937],[69734,69743],[69872,69881],[69942,69951],[70096,70105],[70384,70393],[70736,70745],[70864,70873],[71248,71257],[71360,71369],[71376,71395],[71472,71481],[71904,71913],[72016,72025],[72688,72697],[72784,72793],[73040,73049],[73120,73129],[73552,73561],[90416,90425],[92768,92777],[92864,92873],[93008,93017],[93552,93561],[118000,118009],[120782,120831],[123200,123209],[123632,123641],[124144,124153],[124401,124410],[125264,125273],[130032,130041]],"General_Category/Connector_Punctuation":[[95,95],[8255,8256],[8276,8276],[65075,65076],[65101,65103],[65343,65343]],"General_Category/Format":[[173,173],[1536,1541],[1564,1564],[1757,1757],[1807,1807],[2192,2193],[2274,2274],[6158,6158],[8203,8207],[8234,8238],[8288,8292],[8294,8303],[65279,65279],[65529,65531],[69821,69821],[69837,69837],[78896,78911],[113824,113827],[119155,119162],[917505,917505],[917536,917631]],"General_Category/Spacing_Mark":[[2307,2307],[2363,2363],[2366,2368],[2377,2380],[2382,2383],[2434,2435],[2494,2496],[2503,2504],[2507,2508],[2519,2519],[2563,2563],[2622,2624],[2691,2691],[2750,2752],[2761,2761],[2763,2764],[2818,2819],[2878,2878],[2880,2880],[2887,2888],[2891,2892],[2903,2903],[3006,3007],[3009,3010],[3014,3016],[3018,3020],[3031,3031],[3073,3075],[3137,3140],[3202,3203],[3262,3262],[3264,3268],[3271,3272],[3274,3275],[3285,3286],[3315,3315],[3330,3331],[3390,3392],[3398,3400],[3402,3404],[3415,3415],[3458,3459],[3535,3537],[3544,3551],[3570,3571],[3902,3903],[3967,3967],[4139,4140],[4145,4145],[4152,4152],[4155,4156],[4182,4183],[4194,4196],[4199,4205],[4227,4228],[4231,4236],[4239,4239],[4250,4252],[5909,5909],[5940,5940],[6070,6070],[6078,6085],[6087,6088],[6435,6438],[6441,6443],[6448,6449],[6451,6456],[6681,6682],[6741,6741],[6743,6743],[6753,6753],[6755,6756],[6765,6770],[6916,6916],[6965,6965],[6971,6971],[6973,6977],[6979,6980],[7042,7042],[7073,7073],[7078,7079],[7082,7082],[7143,7143],[7146,7148],[7150,7150],[7154,7155],[7204,7211],[7220,7221],[7393,7393],[7415,7415],[12334,12335],[43043,43044],[43047,43047],[43136,43137],[43188,43203],[43346,43347],[43395,43395],[43444,43445],[43450,43451],[43454,43456],[43567,43568],[43571,43572],[43597,43597],[43643,43643],[43645,43645],[43755,43755],[43758,43759],[43765,43765],[44003,44004],[44006,44007],[44009,44010],[44012,44012],[69632,69632],[69634,69634],[69762,69762],[69808,69810],[69815,69816],[69932,69932],[69957,69958],[70018,70018],[70067,70069],[70079,70080],[70094,70094],[70188,70190],[70194,70195],[70197,70197],[70368,70370],[70402,70403],[70462,70463],[70465,70468],[70471,70472],[70475,70477],[70487,70487],[70498,70499],[70584,70586],[70594,70594],[70597,70597],[70599,70602],[70604,70605],[70607,70607],[70709,70711],[70720,70721],[70725,70725],[70832,70834],[70841,70841],[70843,70846],[70849,70849],[71087,71089],[71096,71099],[71102,71102],[71216,71218],[71227,71228],[71230,71230],[71340,71340],[71342,71343],[71350,71350],[71454,71454],[71456,71457],[71462,71462],[71724,71726],[71736,71736],[71984,71989],[71991,71992],[71997,71997],[72000,72000],[72002,72002],[72145,72147],[72156,72159],[72164,72164],[72249,72249],[72279,72280],[72343,72343],[72751,72751],[72766,72766],[72873,72873],[72881,72881],[72884,72884],[73098,73102],[73107,73108],[73110,73110],[73461,73462],[73475,73475],[73524,73525],[73534,73535],[73537,73537],[90410,90412],[94033,94087],[94192,94193],[119141,119142],[119149,119154]],"General_Category/Lowercase_Letter":[[97,122],[181,181],[223,246],[248,255],[257,257],[259,259],[261,261],[263,263],[265,265],[267,267],[269,269],[271,271],[273,273],[275,275],[277,277],[279,279],[281,281],[283,283],[285,285],[287,287],[289,289],[291,291],[293,293],[295,295],[297,297],[299,299],[301,301],[303,303],[305,305],[307,307],[309,309],[311,312],[314,314],[316,316],[318,318],[320,320],[322,322],[324,324],[326,326],[328,329],[331,331],[333,333],[335,335],[337,337],[339,339],[341,341],[343,343],[345,345],[347,347],[349,349],[351,351],[353,353],[355,355],[357,357],[359,359],[361,361],[363,363],[365,365],[367,367],[369,369],[371,371],[373,373],[375,375],[378,378],[380,380],[382,384],[387,387],[389,389],[392,392],[396,397],[402,402],[405,405],[409,411],[414,414],[417,417],[419,419],[421,421],[424,424],[426,427],[429,429],[432,432],[436,436],[438,438],[441,442],[445,447],[454,454],[457,457],[460,460],[462,462],[464,464],[466,466],[468,468],[470,470],[472,472],[474,474],[476,477],[479,479],[481,481],[483,483],[485,485],[487,487],[489,489],[491,491],[493,493],[495,496],[499,499],[501,501],[505,505],[507,507],[509,509],[511,511],[513,513],[515,515],[517,517],[519,519],[521,521],[523,523],[525,525],[527,527],[529,529],[531,531],[533,533],[535,535],[537,537],[539,539],[541,541],[543,543],[545,545],[547,547],[549,549],[551,551],[553,553],[555,555],[557,557],[559,559],[561,561],[563,569],[572,572],[575,576],[578,578],[583,583],[585,585],[587,587],[589,589],[591,659],[661,687],[881,881],[883,883],[887,887],[891,893],[912,912],[940,974],[976,977],[981,983],[985,985],[987,987],[989,989],[991,991],[993,993],[995,995],[997,997],[999,999],[1001,1001],[1003,1003],[1005,1005],[1007,1011],[1013,1013],[1016,1016],[1019,1020],[1072,1119],[1121,1121],[1123,1123],[1125,1125],[1127,1127],[1129,1129],[1131,1131],[1133,1133],[1135,1135],[1137,1137],[1139,1139],[1141,1141],[1143,1143],[1145,1145],[1147,1147],[1149,1149],[1151,1151],[1153,1153],[1163,1163],[1165,1165],[1167,1167],[1169,1169],[1171,1171],[1173,1173],[1175,1175],[1177,1177],[1179,1179],[1181,1181],[1183,1183],[1185,1185],[1187,1187],[1189,1189],[1191,1191],[1193,1193],[1195,1195],[1197,1197],[1199,1199],[1201,1201],[1203,1203],[1205,1205],[1207,1207],[1209,1209],[1211,1211],[1213,1213],[1215,1215],[1218,1218],[1220,1220],[1222,1222],[1224,1224],[1226,1226],[1228,1228],[1230,1231],[1233,1233],[1235,1235],[1237,1237],[1239,1239],[1241,1241],[1243,1243],[1245,1245],[1247,1247],[1249,1249],[1251,1251],[1253,1253],[1255,1255],[1257,1257],[1259,1259],[1261,1261],[1263,1263],[1265,1265],[1267,1267],[1269,1269],[1271,1271],[1273,1273],[1275,1275],[1277,1277],[1279,1279],[1281,1281],[1283,1283],[1285,1285],[1287,1287],[1289,1289],[1291,1291],[1293,1293],[1295,1295],[1297,1297],[1299,1299],[1301,1301],[1303,1303],[1305,1305],[1307,1307],[1309,1309],[1311,1311],[1313,1313],[1315,1315],[1317,1317],[1319,1319],[1321,1321],[1323,1323],[1325,1325],[1327,1327],[1376,1416],[4304,4346],[4349,4351],[5112,5117],[7296,7304],[7306,7306],[7424,7467],[7531,7543],[7545,7578],[7681,7681],[7683,7683],[7685,7685],[7687,7687],[7689,7689],[7691,7691],[7693,7693],[7695,7695],[7697,7697],[7699,7699],[7701,7701],[7703,7703],[7705,7705],[7707,7707],[7709,7709],[7711,7711],[7713,7713],[7715,7715],[7717,7717],[7719,7719],[7721,7721],[7723,7723],[7725,7725],[7727,7727],[7729,7729],[7731,7731],[7733,7733],[7735,7735],[7737,7737],[7739,7739],[7741,7741],[7743,7743],[7745,7745],[7747,7747],[7749,7749],[7751,7751],[7753,7753],[7755,7755],[7757,7757],[7759,7759],[7761,7761],[7763,7763],[7765,7765],[7767,7767],[7769,7769],[7771,7771],[7773,7773],[7775,7775],[7777,7777],[7779,7779],[7781,7781],[7783,7783],[7785,7785],[7787,7787],[7789,7789],[7791,7791],[7793,7793],[7795,7795],[7797,7797],[7799,7799],[7801,7801],[7803,7803],[7805,7805],[7807,7807],[7809,7809],[7811,7811],[7813,7813],[7815,7815],[7817,7817],[7819,7819],[7821,7821],[7823,7823],[7825,7825],[7827,7827],[7829,7837],[7839,7839],[7841,7841],[7843,7843],[7845,7845],[7847,7847],[7849,7849],[7851,7851],[7853,7853],[7855,7855],[7857,7857],[7859,7859],[7861,7861],[7863,7863],[7865,7865],[7867,7867],[7869,7869],[7871,7871],[7873,7873],[7875,7875],[7877,7877],[7879,7879],[7881,7881],[7883,7883],[7885,7885],[7887,7887],[7889,7889],[7891,7891],[7893,7893],[7895,7895],[7897,7897],[7899,7899],[7901,7901],[7903,7903],[7905,7905],[7907,7907],[7909,7909],[7911,7911],[7913,7913],[7915,7915],[7917,7917],[7919,7919],[7921,7921],[7923,7923],[7925,7925],[7927,7927],[7929,7929],[7931,7931],[7933,7933],[7935,7943],[7952,7957],[7968,7975],[7984,7991],[8000,8005],[8016,8023],[8032,8039],[8048,8061],[8064,8071],[8080,8087],[8096,8103],[8112,8116],[8118,8119],[8126,8126],[8130,8132],[8134,8135],[8144,8147],[8150,8151],[8160,8167],[8178,8180],[8182,8183],[8458,8458],[8462,8463],[8467,8467],[8495,8495],[8500,8500],[8505,8505],[8508,8509],[8518,8521],[8526,8526],[8580,8580],[11312,11359],[11361,11361],[11365,11366],[11368,11368],[11370,11370],[11372,11372],[11377,11377],[11379,11380],[11382,11387],[11393,11393],[11395,11395],[11397,11397],[11399,11399],[11401,11401],[11403,11403],[11405,11405],[11407,11407],[11409,11409],[11411,11411],[11413,11413],[11415,11415],[11417,11417],[11419,11419],[11421,11421],[11423,11423],[11425,11425],[11427,11427],[11429,11429],[11431,11431],[11433,11433],[11435,11435],[11437,11437],[11439,11439],[11441,11441],[11443,11443],[11445,11445],[11447,11447],[11449,11449],[11451,11451],[11453,11453],[11455,11455],[11457,11457],[11459,11459],[11461,11461],[11463,11463],[11465,11465],[11467,11467],[11469,11469],[11471,11471],[11473,11473],[11475,11475],[11477,11477],[11479,11479],[11481,11481],[11483,11483],[11485,11485],[11487,11487],[11489,11489],[11491,11492],[11500,11500],[11502,11502],[11507,11507],[11520,11557],[11559,11559],[11565,11565],[42561,42561],[42563,42563],[42565,42565],[42567,42567],[42569,42569],[42571,42571],[42573,42573],[42575,42575],[42577,42577],[42579,42579],[42581,42581],[42583,42583],[42585,42585],[42587,42587],[42589,42589],[42591,42591],[42593,42593],[42595,42595],[42597,42597],[42599,42599],[42601,42601],[42603,42603],[42605,42605],[42625,42625],[42627,42627],[42629,42629],[42631,42631],[42633,42633],[42635,42635],[42637,42637],[42639,42639],[42641,42641],[42643,42643],[42645,42645],[42647,42647],[42649,42649],[42651,42651],[42787,42787],[42789,42789],[42791,42791],[42793,42793],[42795,42795],[42797,42797],[42799,42801],[42803,42803],[42805,42805],[42807,42807],[42809,42809],[42811,42811],[42813,42813],[42815,42815],[42817,42817],[42819,42819],[42821,42821],[42823,42823],[42825,42825],[42827,42827],[42829,42829],[42831,42831],[42833,42833],[42835,42835],[42837,42837],[42839,42839],[42841,42841],[42843,42843],[42845,42845],[42847,42847],[42849,42849],[42851,42851],[42853,42853],[42855,42855],[42857,42857],[42859,42859],[42861,42861],[42863,42863],[42865,42872],[42874,42874],[42876,42876],[42879,42879],[42881,42881],[42883,42883],[42885,42885],[42887,42887],[42892,42892],[42894,42894],[42897,42897],[42899,42901],[42903,42903],[42905,42905],[42907,42907],[42909,42909],[42911,42911],[42913,42913],[42915,42915],[42917,42917],[42919,42919],[42921,42921],[42927,42927],[42933,42933],[42935,42935],[42937,42937],[42939,42939],[42941,42941],[42943,42943],[42945,42945],[42947,42947],[42952,42952],[42954,42954],[42957,42957],[42961,42961],[42963,42963],[42965,42965],[42967,42967],[42969,42969],[42971,42971],[42998,42998],[43002,43002],[43824,43866],[43872,43880],[43888,43967],[64256,64262],[64275,64279],[65345,65370],[66600,66639],[66776,66811],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[68800,68850],[68976,68997],[71872,71903],[93792,93823],[119834,119859],[119886,119892],[119894,119911],[119938,119963],[119990,119993],[119995,119995],[119997,120003],[120005,120015],[120042,120067],[120094,120119],[120146,120171],[120198,120223],[120250,120275],[120302,120327],[120354,120379],[120406,120431],[120458,120485],[120514,120538],[120540,120545],[120572,120596],[120598,120603],[120630,120654],[120656,120661],[120688,120712],[120714,120719],[120746,120770],[120772,120777],[120779,120779],[122624,122633],[122635,122654],[122661,122666],[125218,125251]],"General_Category/Other_Symbol":[[166,166],[169,169],[174,174],[176,176],[1154,1154],[1421,1422],[1550,1551],[1758,1758],[1769,1769],[1789,1790],[2038,2038],[2554,2554],[2928,2928],[3059,3064],[3066,3066],[3199,3199],[3407,3407],[3449,3449],[3841,3843],[3859,3859],[3861,3863],[3866,3871],[3892,3892],[3894,3894],[3896,3896],[4030,4037],[4039,4044],[4046,4047],[4053,4056],[4254,4255],[5008,5017],[5741,5741],[6464,6464],[6622,6655],[7009,7018],[7028,7036],[8448,8449],[8451,8454],[8456,8457],[8468,8468],[8470,8471],[8478,8483],[8485,8485],[8487,8487],[8489,8489],[8494,8494],[8506,8507],[8522,8522],[8524,8525],[8527,8527],[8586,8587],[8597,8601],[8604,8607],[8609,8610],[8612,8613],[8615,8621],[8623,8653],[8656,8657],[8659,8659],[8661,8691],[8960,8967],[8972,8991],[8994,9000],[9003,9083],[9085,9114],[9140,9179],[9186,9257],[9280,9290],[9372,9449],[9472,9654],[9656,9664],[9666,9719],[9728,9838],[9840,10087],[10132,10175],[10240,10495],[11008,11055],[11077,11078],[11085,11123],[11126,11157],[11159,11263],[11493,11498],[11856,11857],[11904,11929],[11931,12019],[12032,12245],[12272,12287],[12292,12292],[12306,12307],[12320,12320],[12342,12343],[12350,12351],[12688,12689],[12694,12703],[12736,12773],[12783,12783],[12800,12830],[12842,12871],[12880,12880],[12896,12927],[12938,12976],[12992,13311],[19904,19967],[42128,42182],[43048,43051],[43062,43063],[43065,43065],[43639,43641],[64832,64847],[64975,64975],[65021,65023],[65508,65508],[65512,65512],[65517,65518],[65532,65533],[65847,65855],[65913,65929],[65932,65934],[65936,65948],[65952,65952],[66000,66044],[67703,67704],[68296,68296],[71487,71487],[73685,73692],[73697,73713],[92988,92991],[92997,92997],[113820,113820],[117760,117999],[118016,118451],[118608,118723],[118784,119029],[119040,119078],[119081,119140],[119146,119148],[119171,119172],[119180,119209],[119214,119274],[119296,119361],[119365,119365],[119552,119638],[120832,121343],[121399,121402],[121453,121460],[121462,121475],[121477,121478],[123215,123215],[126124,126124],[126254,126254],[126976,127019],[127024,127123],[127136,127150],[127153,127167],[127169,127183],[127185,127221],[127245,127405],[127462,127490],[127504,127547],[127552,127560],[127568,127569],[127584,127589],[127744,127994],[128000,128727],[128732,128748],[128752,128764],[128768,128886],[128891,128985],[128992,129003],[129008,129008],[129024,129035],[129040,129095],[129104,129113],[129120,129159],[129168,129197],[129200,129211],[129216,129217],[129280,129619],[129632,129645],[129648,129660],[129664,129673],[129679,129734],[129742,129756],[129759,129769],[129776,129784],[129792,129938],[129940,130031]],"General_Category/Punctuation":[[33,35],[37,42],[44,47],[58,59],[63,64],[91,93],[95,95],[123,123],[125,125],[161,161],[167,167],[171,171],[182,183],[187,187],[191,191],[894,894],[903,903],[1370,1375],[1417,1418],[1470,1470],[1472,1472],[1475,1475],[1478,1478],[1523,1524],[1545,1546],[1548,1549],[1563,1563],[1565,1567],[1642,1645],[1748,1748],[1792,1805],[2039,2041],[2096,2110],[2142,2142],[2404,2405],[2416,2416],[2557,2557],[2678,2678],[2800,2800],[3191,3191],[3204,3204],[3572,3572],[3663,3663],[3674,3675],[3844,3858],[3860,3860],[3898,3901],[3973,3973],[4048,4052],[4057,4058],[4170,4175],[4347,4347],[4960,4968],[5120,5120],[5742,5742],[5787,5788],[5867,5869],[5941,5942],[6100,6102],[6104,6106],[6144,6154],[6468,6469],[6686,6687],[6816,6822],[6824,6829],[6990,6991],[7002,7008],[7037,7039],[7164,7167],[7227,7231],[7294,7295],[7360,7367],[7379,7379],[8208,8231],[8240,8259],[8261,8273],[8275,8286],[8317,8318],[8333,8334],[8968,8971],[9001,9002],[10088,10101],[10181,10182],[10214,10223],[10627,10648],[10712,10715],[10748,10749],[11513,11516],[11518,11519],[11632,11632],[11776,11822],[11824,11855],[11858,11869],[12289,12291],[12296,12305],[12308,12319],[12336,12336],[12349,12349],[12448,12448],[12539,12539],[42238,42239],[42509,42511],[42611,42611],[42622,42622],[42738,42743],[43124,43127],[43214,43215],[43256,43258],[43260,43260],[43310,43311],[43359,43359],[43457,43469],[43486,43487],[43612,43615],[43742,43743],[43760,43761],[44011,44011],[64830,64831],[65040,65049],[65072,65106],[65108,65121],[65123,65123],[65128,65128],[65130,65131],[65281,65283],[65285,65290],[65292,65295],[65306,65307],[65311,65312],[65339,65341],[65343,65343],[65371,65371],[65373,65373],[65375,65381],[65792,65794],[66463,66463],[66512,66512],[66927,66927],[67671,67671],[67871,67871],[67903,67903],[68176,68184],[68223,68223],[68336,68342],[68409,68415],[68505,68508],[68974,68974],[69293,69293],[69461,69465],[69510,69513],[69703,69709],[69819,69820],[69822,69825],[69952,69955],[70004,70005],[70085,70088],[70093,70093],[70107,70107],[70109,70111],[70200,70205],[70313,70313],[70612,70613],[70615,70616],[70731,70735],[70746,70747],[70749,70749],[70854,70854],[71105,71127],[71233,71235],[71264,71276],[71353,71353],[71484,71486],[71739,71739],[72004,72006],[72162,72162],[72255,72262],[72346,72348],[72350,72354],[72448,72457],[72673,72673],[72769,72773],[72816,72817],[73463,73464],[73539,73551],[73727,73727],[74864,74868],[77809,77810],[92782,92783],[92917,92917],[92983,92987],[92996,92996],[93549,93551],[93847,93850],[94178,94178],[113823,113823],[121479,121483],[124415,124415],[125278,125279]],"Script/Sogdian":[[69424,69465]],"Script/Kannada":[[3200,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3260,3268],[3270,3272],[3274,3277],[3285,3286],[3293,3294],[3296,3299],[3302,3311],[3313,3315]],"Script/Common":[[0,64],[91,96],[123,169],[171,185],[187,191],[215,215],[247,247],[697,735],[741,745],[748,767],[884,884],[894,894],[901,901],[903,903],[1541,1541],[1548,1548],[1563,1563],[1567,1567],[1600,1600],[1757,1757],[2274,2274],[2404,2405],[3647,3647],[4053,4056],[4347,4347],[5867,5869],[5941,5942],[6146,6147],[6149,6149],[7379,7379],[7393,7393],[7401,7404],[7406,7411],[7413,7415],[7418,7418],[8192,8203],[8206,8292],[8294,8304],[8308,8318],[8320,8334],[8352,8384],[8448,8485],[8487,8489],[8492,8497],[8499,8525],[8527,8543],[8585,8587],[8592,9257],[9280,9290],[9312,10239],[10496,11123],[11126,11157],[11159,11263],[11776,11869],[12272,12292],[12294,12294],[12296,12320],[12336,12343],[12348,12351],[12443,12444],[12448,12448],[12539,12540],[12688,12703],[12736,12773],[12783,12783],[12832,12895],[12927,13007],[13055,13055],[13144,13311],[19904,19967],[42752,42785],[42888,42890],[43056,43065],[43310,43310],[43471,43471],[43867,43867],[43882,43883],[64830,64831],[65040,65049],[65072,65106],[65108,65126],[65128,65131],[65279,65279],[65281,65312],[65339,65344],[65371,65381],[65392,65392],[65438,65439],[65504,65510],[65512,65518],[65529,65533],[65792,65794],[65799,65843],[65847,65855],[65936,65948],[66000,66044],[66273,66299],[113824,113827],[117760,118009],[118016,118451],[118608,118723],[118784,119029],[119040,119078],[119081,119142],[119146,119162],[119171,119172],[119180,119209],[119214,119274],[119488,119507],[119520,119539],[119552,119638],[119648,119672],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120779],[120782,120831],[126065,126132],[126209,126269],[126976,127019],[127024,127123],[127136,127150],[127153,127167],[127169,127183],[127185,127221],[127232,127405],[127462,127487],[127489,127490],[127504,127547],[127552,127560],[127568,127569],[127584,127589],[127744,128727],[128732,128748],[128752,128764],[128768,128886],[128891,128985],[128992,129003],[129008,129008],[129024,129035],[129040,129095],[129104,129113],[129120,129159],[129168,129197],[129200,129211],[129216,129217],[129280,129619],[129632,129645],[129648,129660],[129664,129673],[129679,129734],[129742,129756],[129759,129769],[129776,129784],[129792,129938],[129940,130041],[917505,917505],[917536,917631]],"Script/New_Tai_Lue":[[6528,6571],[6576,6601],[6608,6618],[6622,6623]],"Script/Soyombo":[[72272,72354]],"Script/Ethiopic":[[4608,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4957,4988],[4992,5017],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[124896,124902],[124904,124907],[124909,124910],[124912,124926]],"Script/Tai_Tham":[[6688,6750],[6752,6780],[6783,6793],[6800,6809],[6816,6829]],"Script/Linear_A":[[67072,67382],[67392,67413],[67424,67431]],"Script/Deseret":[[66560,66639]],"Script/Cypriot":[[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67647]],"Script/Kawi":[[73472,73488],[73490,73530],[73534,73562]],"Script/Myanmar":[[4096,4255],[43488,43518],[43616,43647],[71376,71395]],"Script/Sinhala":[[3457,3459],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3530,3530],[3535,3540],[3542,3542],[3544,3551],[3558,3567],[3570,3572],[70113,70132]],"Script/Bassa_Vah":[[92880,92909],[92912,92917]],"Script/Sora_Sompeng":[[69840,69864],[69872,69881]],"Script/SignWriting":[[120832,121483],[121499,121503],[121505,121519]],"Script/Khitan_Small_Script":[[94180,94180],[101120,101589],[101631,101631]],"Script/Chorasmian":[[69552,69579]],"Script/Lydian":[[67872,67897],[67903,67903]],"Script/Buginese":[[6656,6683],[6686,6687]],"Script/Ugaritic":[[66432,66461],[66463,66463]],"Script/Khojki":[[70144,70161],[70163,70209]],"Script/Greek":[[880,883],[885,887],[890,893],[895,895],[900,900],[902,902],[904,906],[908,908],[910,929],[931,993],[1008,1023],[7462,7466],[7517,7521],[7526,7530],[7615,7615],[7936,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8132],[8134,8147],[8150,8155],[8157,8175],[8178,8180],[8182,8190],[8486,8486],[43877,43877],[65856,65934],[65952,65952],[119296,119365]],"Script/Latin":[[65,90],[97,122],[170,170],[186,186],[192,214],[216,246],[248,696],[736,740],[7424,7461],[7468,7516],[7522,7525],[7531,7543],[7545,7614],[7680,7935],[8305,8305],[8319,8319],[8336,8348],[8490,8491],[8498,8498],[8526,8526],[8544,8584],[11360,11391],[42786,42887],[42891,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43007],[43824,43866],[43868,43876],[43878,43881],[64256,64262],[65313,65338],[65345,65370],[67456,67461],[67463,67504],[67506,67514],[122624,122654],[122661,122666]],"Script/Tangut":[[94176,94176],[94208,100343],[100352,101119],[101632,101640]],"Script/Telugu":[[3072,3084],[3086,3088],[3090,3112],[3114,3129],[3132,3140],[3142,3144],[3146,3149],[3157,3158],[3160,3162],[3165,3165],[3168,3171],[3174,3183],[3191,3199]],"Script/Osage":[[66736,66771],[66776,66811]],"Script/Mende_Kikakui":[[124928,125124],[125127,125142]],"Script/Phoenician":[[67840,67867],[67871,67871]],"Script/Samaritan":[[2048,2093],[2096,2110]],"Script/Mongolian":[[6144,6145],[6148,6148],[6150,6169],[6176,6264],[6272,6314],[71264,71276]],"Script/Mro":[[92736,92766],[92768,92777],[92782,92783]],"Script/Imperial_Aramaic":[[67648,67669],[67671,67679]],"Script/Gurung_Khema":[[90368,90425]],"Script/Han":[[11904,11929],[11931,12019],[12032,12245],[12293,12293],[12295,12295],[12321,12329],[12344,12347],[13312,19903],[19968,40959],[63744,64109],[64112,64217],[94178,94179],[94192,94193],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"Script/Anatolian_Hieroglyphs":[[82944,83526]],"Script/Newa":[[70656,70747],[70749,70753]],"Script/Nushu":[[94177,94177],[110960,111355]],"Script/Vai":[[42240,42539]],"Script/Yezidi":[[69248,69289],[69291,69293],[69296,69297]],"Script/Lycian":[[66176,66204]],"Script/Hebrew":[[1425,1479],[1488,1514],[1519,1524],[64285,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64335]],"Script/Gurmukhi":[[2561,2563],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2620,2620],[2622,2626],[2631,2632],[2635,2637],[2641,2641],[2649,2652],[2654,2654],[2662,2678]],"Script/Oriya":[[2817,2819],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2876,2884],[2887,2888],[2891,2893],[2901,2903],[2908,2909],[2911,2915],[2918,2935]],"Script/Warang_Citi":[[71840,71922],[71935,71935]],"Script/Cham":[[43520,43574],[43584,43597],[43600,43609],[43612,43615]],"Script/Dogra":[[71680,71739]],"Script/Cyrillic":[[1024,1156],[1159,1327],[7296,7306],[7467,7467],[7544,7544],[11744,11775],[42560,42655],[65070,65071],[122928,122989],[123023,123023]],"Script/Siddham":[[71040,71093],[71096,71133]],"Script/Khudawadi":[[70320,70378],[70384,70393]],"Script/Kayah_Li":[[43264,43309],[43311,43311]],"Script/Gunjala_Gondi":[[73056,73061],[73063,73064],[73066,73102],[73104,73105],[73107,73112],[73120,73129]],"Script/Nandinagari":[[72096,72103],[72106,72151],[72154,72164]],"Script/Avestan":[[68352,68405],[68409,68415]],"Script/Tibetan":[[3840,3911],[3913,3948],[3953,3991],[3993,4028],[4030,4044],[4046,4052],[4057,4058]],"Script/Psalter_Pahlavi":[[68480,68497],[68505,68508],[68521,68527]],"Script/Vithkuqi":[[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004]],"Script/Meroitic_Cursive":[[68000,68023],[68028,68047],[68050,68095]],"Script/Linear_B":[[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786]],"Script/Sunuwar":[[72640,72673],[72688,72697]],"Script/Multani":[[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70313]],"Script/Sharada":[[70016,70111]],"Script/Arabic":[[1536,1540],[1542,1547],[1549,1562],[1564,1566],[1568,1599],[1601,1610],[1622,1647],[1649,1756],[1758,1791],[1872,1919],[2160,2190],[2192,2193],[2199,2273],[2275,2303],[64336,64450],[64467,64829],[64832,64911],[64914,64967],[64975,64975],[65008,65023],[65136,65140],[65142,65276],[69216,69246],[69314,69316],[69372,69375],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[126704,126705]],"Script/Pahawh_Hmong":[[92928,92997],[93008,93017],[93019,93025],[93027,93047],[93053,93071]],"Script/Canadian_Aboriginal":[[5120,5759],[6320,6389],[72368,72383]],"Script/Bopomofo":[[746,747],[12549,12591],[12704,12735]],"Script/Armenian":[[1329,1366],[1369,1418],[1421,1423],[64275,64279]],"Script/Kirat_Rai":[[93504,93561]],"Script/Elbasan":[[66816,66855]],"Script/Coptic":[[994,1007],[11392,11507],[11513,11519]],"Script/Yi":[[40960,42124],[42128,42182]],"Script/Tirhuta":[[70784,70855],[70864,70873]],"Script/Tai_Viet":[[43648,43714],[43739,43743]],"Script/Inscriptional_Pahlavi":[[68448,68466],[68472,68479]],"Script/Miao":[[93952,94026],[94031,94087],[94095,94111]],"Script/Hiragana":[[12353,12438],[12445,12447],[110593,110879],[110898,110898],[110928,110930],[127488,127488]],"Script/Buhid":[[5952,5971]],"Script/Nag_Mundari":[[124112,124153]],"Script/Kharoshthi":[[68096,68099],[68101,68102],[68108,68115],[68117,68119],[68121,68149],[68152,68154],[68159,68168],[68176,68184]],"Script/Tulu_Tigalari":[[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70592],[70594,70594],[70597,70597],[70599,70602],[70604,70613],[70615,70616],[70625,70626]],"Script/Glagolitic":[[11264,11359],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922]],"Script/Bamum":[[42656,42743],[92160,92728]],"Script/Tagalog":[[5888,5909],[5919,5919]],"Script/Brahmi":[[69632,69709],[69714,69749],[69759,69759]],"Script/Khmer":[[6016,6109],[6112,6121],[6128,6137],[6624,6655]],"Script/Carian":[[66208,66256]],"Script/Ol_Onal":[[124368,124410],[124415,124415]],"Script/Tai_Le":[[6480,6509],[6512,6516]],"Script/Tamil":[[2946,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3006,3010],[3014,3016],[3018,3021],[3024,3024],[3031,3031],[3046,3066],[73664,73713],[73727,73727]],"Script/Tangsa":[[92784,92862],[92864,92873]],"Script/Gothic":[[66352,66378]],"Script/Adlam":[[125184,125259],[125264,125273],[125278,125279]],"Script/Ahom":[[71424,71450],[71453,71467],[71472,71494]],"Script/Nyiakeng_Puachue_Hmong":[[123136,123180],[123184,123197],[123200,123209],[123214,123215]],"Script/Nabataean":[[67712,67742],[67751,67759]],"Script/Old_Sogdian":[[69376,69415]],"Script/Hanifi_Rohingya":[[68864,68903],[68912,68921]],"Script/Mahajani":[[69968,70006]],"Script/Phags_Pa":[[43072,43127]],"Script/Old_Hungarian":[[68736,68786],[68800,68850],[68858,68863]],"Script/Old_Persian":[[66464,66499],[66504,66517]],"Script/Todhri":[[67008,67059]],"Script/Old_Uyghur":[[69488,69513]],"Script/Limbu":[[6400,6430],[6432,6443],[6448,6459],[6464,6464],[6468,6479]],"Script/Tifinagh":[[11568,11623],[11631,11632],[11647,11647]],"Script/Lisu":[[42192,42239],[73648,73648]],"Script/Bengali":[[2432,2435],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2492,2500],[2503,2504],[2507,2510],[2519,2519],[2524,2525],[2527,2531],[2534,2558]],"Script/Pau_Cin_Hau":[[72384,72440]],"Script/Elymaic":[[69600,69622]],"Script/Saurashtra":[[43136,43205],[43214,43225]],"Script/Meetei_Mayek":[[43744,43766],[43968,44013],[44016,44025]],"Script/Old_Turkic":[[68608,68680]],"Script/Thai":[[3585,3642],[3648,3675]],"Script/Old_Italic":[[66304,66339],[66349,66351]],"Script/Palmyrene":[[67680,67711]],"Script/Braille":[[10240,10495]],"Script/Balinese":[[6912,6988],[6990,7039]],"Script/Meroitic_Hieroglyphs":[[67968,67999]],"Script/Masaram_Gondi":[[72960,72966],[72968,72969],[72971,73014],[73018,73018],[73020,73021],[73023,73031],[73040,73049]],"Script/Katakana":[[12449,12538],[12541,12543],[12784,12799],[13008,13054],[13056,13143],[65382,65391],[65393,65437],[110576,110579],[110581,110587],[110589,110590],[110592,110592],[110880,110882],[110933,110933],[110948,110951]],"Script/Modi":[[71168,71236],[71248,71257]],"Script/Lepcha":[[7168,7223],[7227,7241],[7245,7247]],"Script/Ogham":[[5760,5788]],"Script/Medefaidrin":[[93760,93850]],"Script/Makasar":[[73440,73464]],"Script/Sundanese":[[7040,7103],[7360,7367]],"Script/Old_South_Arabian":[[68192,68223]],"Script/Old_North_Arabian":[[68224,68255]],"Script/Devanagari":[[2304,2384],[2389,2403],[2406,2431],[43232,43263],[72448,72457]],"Script/Batak":[[7104,7155],[7164,7167]],"Script/Thaana":[[1920,1969]],"Script/Hanunoo":[[5920,5940]],"Script/Inscriptional_Parthian":[[68416,68437],[68440,68447]],"Script/Dives_Akuru":[[71936,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71989],[71991,71992],[71995,72006],[72016,72025]],"Script/Chakma":[[69888,69940],[69942,69959]],"Script/Takri":[[71296,71353],[71360,71369]],"Script/Cypro_Minoan":[[77712,77810]],"Script/Runic":[[5792,5866],[5870,5880]],"Script/Kaithi":[[69760,69826],[69837,69837]],"Script/Cherokee":[[5024,5109],[5112,5117],[43888,43967]],"Script/Garay":[[68928,68965],[68969,68997],[69006,69007]],"Script/Shavian":[[66640,66687]],"Script/Osmanya":[[66688,66717],[66720,66729]],"Script/Marchen":[[72816,72847],[72850,72871],[72873,72886]],"Script/Manichaean":[[68288,68326],[68331,68342]],"Script/Lao":[[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3773],[3776,3780],[3782,3782],[3784,3790],[3792,3801],[3804,3807]],"Script/Rejang":[[43312,43347],[43359,43359]],"Script/Gujarati":[[2689,2691],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2748,2757],[2759,2761],[2763,2765],[2768,2768],[2784,2787],[2790,2801],[2809,2815]],"Script/Javanese":[[43392,43469],[43472,43481],[43486,43487]],"Script/Grantha":[[70400,70403],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70460,70468],[70471,70472],[70475,70477],[70480,70480],[70487,70487],[70493,70499],[70502,70508],[70512,70516]],"Script/Cuneiform":[[73728,74649],[74752,74862],[74864,74868],[74880,75075]],"Script/Toto":[[123536,123566]],"Script/Bhaiksuki":[[72704,72712],[72714,72758],[72760,72773],[72784,72812]],"Script/Mandaic":[[2112,2139],[2142,2142]],"Script/Syloti_Nagri":[[43008,43052]],"Script/Ol_Chiki":[[7248,7295]],"Script/Malayalam":[[3328,3340],[3342,3344],[3346,3396],[3398,3400],[3402,3407],[3412,3427],[3430,3455]],"Script/Hatran":[[67808,67826],[67828,67829],[67835,67839]],"Script/Georgian":[[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4348,4351],[7312,7354],[7357,7359],[11520,11557],[11559,11559],[11565,11565]],"Script/Zanabazar_Square":[[72192,72263]],"Script/Caucasian_Albanian":[[66864,66915],[66927,66927]],"Script/Duployan":[[113664,113770],[113776,113788],[113792,113800],[113808,113817],[113820,113823]],"Script/Hangul":[[4352,4607],[12334,12335],[12593,12686],[12800,12830],[12896,12926],[43360,43388],[44032,55203],[55216,55238],[55243,55291],[65440,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500]],"Script/Wancho":[[123584,123641],[123647,123647]],"Script/Nko":[[1984,2042],[2045,2047]],"Script/Syriac":[[1792,1805],[1807,1866],[1869,1871],[2144,2154]],"Script/Tagbanwa":[[5984,5996],[5998,6000],[6002,6003]],"Script/Inherited":[[768,879],[1157,1158],[1611,1621],[1648,1648],[2385,2388],[6832,6862],[7376,7378],[7380,7392],[7394,7400],[7405,7405],[7412,7412],[7416,7417],[7616,7679],[8204,8205],[8400,8432],[12330,12333],[12441,12442],[65024,65039],[65056,65069],[66045,66045],[66272,66272],[70459,70459],[118528,118573],[118576,118598],[119143,119145],[119163,119170],[119173,119179],[119210,119213],[917760,917999]],"Script/Old_Permic":[[66384,66426]],"Script/Egyptian_Hieroglyphs":[[77824,78933],[78944,82938]],"Script_Extensions/Sogdian":[[1600,1600],[69424,69465]],"Script_Extensions/Kannada":[[2385,2386],[2404,2405],[3200,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3260,3268],[3270,3272],[3274,3277],[3285,3286],[3293,3294],[3296,3299],[3302,3311],[3313,3315],[7376,7376],[7378,7379],[7386,7386],[7410,7410],[7412,7412],[43056,43061]],"Script_Extensions/Common":[[0,64],[91,96],[123,169],[171,182],[184,185],[187,191],[215,215],[247,247],[697,699],[701,710],[712,712],[716,716],[718,726],[728,728],[730,735],[741,745],[748,767],[894,894],[901,901],[903,903],[1541,1541],[1757,1757],[2274,2274],[3647,3647],[4053,4056],[8192,8203],[8206,8238],[8240,8270],[8272,8281],[8283,8284],[8286,8292],[8294,8304],[8308,8318],[8320,8334],[8352,8384],[8448,8485],[8487,8489],[8492,8497],[8499,8525],[8527,8543],[8585,8587],[8592,9257],[9280,9290],[9312,10239],[10496,11123],[11126,11157],[11159,11263],[11776,11798],[11800,11823],[11826,11835],[11837,11840],[11842,11842],[11844,11869],[12288,12288],[12292,12292],[12306,12306],[12320,12320],[12342,12342],[12872,12895],[12927,12927],[12977,12991],[13004,13007],[13169,13178],[13184,13279],[13311,13311],[19904,19967],[42760,42785],[42888,42890],[43867,43867],[43882,43883],[65040,65049],[65072,65092],[65095,65106],[65108,65126],[65128,65131],[65279,65279],[65281,65312],[65339,65344],[65371,65376],[65504,65510],[65512,65518],[65529,65533],[65936,65948],[66000,66044],[117760,118009],[118016,118451],[118608,118723],[118784,119029],[119040,119078],[119081,119142],[119146,119162],[119171,119172],[119180,119209],[119214,119274],[119488,119507],[119520,119539],[119552,119638],[119666,119672],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120779],[120782,120831],[126065,126132],[126209,126269],[126976,127019],[127024,127123],[127136,127150],[127153,127167],[127169,127183],[127185,127221],[127232,127405],[127462,127487],[127489,127490],[127504,127547],[127552,127560],[127584,127589],[127744,128727],[128732,128748],[128752,128764],[128768,128886],[128891,128985],[128992,129003],[129008,129008],[129024,129035],[129040,129095],[129104,129113],[129120,129159],[129168,129197],[129200,129211],[129216,129217],[129280,129619],[129632,129645],[129648,129660],[129664,129673],[129679,129734],[129742,129756],[129759,129769],[129776,129784],[129792,129938],[129940,130041],[917505,917505],[917536,917631]],"Script_Extensions/New_Tai_Lue":[[6528,6571],[6576,6601],[6608,6618],[6622,6623]],"Script_Extensions/Soyombo":[[72272,72354]],"Script_Extensions/Ethiopic":[[782,782],[4608,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4957,4988],[4992,5017],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[124896,124902],[124904,124907],[124909,124910],[124912,124926]],"Script_Extensions/Tai_Tham":[[6688,6750],[6752,6780],[6783,6793],[6800,6809],[6816,6829]],"Script_Extensions/Linear_A":[[65799,65843],[67072,67382],[67392,67413],[67424,67431]],"Script_Extensions/Deseret":[[66560,66639]],"Script_Extensions/Cypriot":[[65792,65794],[65799,65843],[65847,65855],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67647]],"Script_Extensions/Kawi":[[73472,73488],[73490,73530],[73534,73562]],"Script_Extensions/Myanmar":[[4096,4255],[43310,43310],[43488,43518],[43616,43647],[71376,71395]],"Script_Extensions/Sinhala":[[2404,2405],[3457,3459],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3530,3530],[3535,3540],[3542,3542],[3544,3551],[3558,3567],[3570,3572],[7410,7410],[70113,70132]],"Script_Extensions/Bassa_Vah":[[92880,92909],[92912,92917]],"Script_Extensions/Sora_Sompeng":[[69840,69864],[69872,69881]],"Script_Extensions/SignWriting":[[120832,121483],[121499,121503],[121505,121519]],"Script_Extensions/Khitan_Small_Script":[[94180,94180],[101120,101589],[101631,101631]],"Script_Extensions/Chorasmian":[[69552,69579]],"Script_Extensions/Lydian":[[183,183],[11825,11825],[67872,67897],[67903,67903]],"Script_Extensions/Buginese":[[6656,6683],[6686,6687],[43471,43471]],"Script_Extensions/Ugaritic":[[66432,66461],[66463,66463]],"Script_Extensions/Khojki":[[2790,2799],[43056,43065],[70144,70161],[70163,70209]],"Script_Extensions/Greek":[[183,183],[768,769],[772,772],[774,774],[776,776],[787,787],[834,834],[837,837],[880,887],[890,893],[895,895],[900,900],[902,902],[904,906],[908,908],[910,929],[931,993],[1008,1023],[7462,7466],[7517,7521],[7526,7530],[7615,7617],[7936,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8132],[8134,8147],[8150,8155],[8157,8175],[8178,8180],[8182,8190],[8285,8285],[8486,8486],[43877,43877],[65856,65934],[65952,65952],[119296,119365]],"Script_Extensions/Latin":[[65,90],[97,122],[170,170],[183,183],[186,186],[192,214],[216,246],[248,696],[700,700],[711,711],[713,715],[717,717],[727,727],[729,729],[736,740],[768,782],[784,785],[787,787],[800,800],[803,805],[813,814],[816,817],[856,856],[862,862],[867,879],[1157,1158],[2385,2386],[4347,4347],[7424,7461],[7468,7516],[7522,7525],[7531,7543],[7545,7614],[7672,7672],[7680,7935],[8239,8239],[8305,8305],[8319,8319],[8336,8348],[8432,8432],[8490,8491],[8498,8498],[8526,8526],[8544,8584],[11360,11391],[11799,11799],[42752,42759],[42786,42887],[42891,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43007],[43310,43310],[43824,43866],[43868,43876],[43878,43881],[64256,64262],[65313,65338],[65345,65370],[67456,67461],[67463,67504],[67506,67514],[122624,122654],[122661,122666]],"Script_Extensions/Tangut":[[12272,12287],[12783,12783],[94176,94176],[94208,100343],[100352,101119],[101632,101640]],"Script_Extensions/Telugu":[[2385,2386],[2404,2405],[3072,3084],[3086,3088],[3090,3112],[3114,3129],[3132,3140],[3142,3144],[3146,3149],[3157,3158],[3160,3162],[3165,3165],[3168,3171],[3174,3183],[3191,3199],[7386,7386],[7410,7410]],"Script_Extensions/Osage":[[769,769],[772,772],[779,779],[856,856],[66736,66771],[66776,66811]],"Script_Extensions/Mende_Kikakui":[[124928,125124],[125127,125142]],"Script_Extensions/Phoenician":[[67840,67867],[67871,67871]],"Script_Extensions/Samaritan":[[2048,2093],[2096,2110],[11825,11825]],"Script_Extensions/Mongolian":[[6144,6169],[6176,6264],[6272,6314],[8239,8239],[12289,12290],[12296,12299],[71264,71276]],"Script_Extensions/Mro":[[92736,92766],[92768,92777],[92782,92783]],"Script_Extensions/Imperial_Aramaic":[[67648,67669],[67671,67679]],"Script_Extensions/Gurung_Khema":[[2405,2405],[90368,90425]],"Script_Extensions/Han":[[183,183],[11904,11929],[11931,12019],[12032,12245],[12272,12287],[12289,12291],[12293,12305],[12307,12319],[12321,12333],[12336,12336],[12343,12351],[12539,12539],[12688,12703],[12736,12773],[12783,12783],[12832,12871],[12928,12976],[12992,13003],[13055,13055],[13144,13168],[13179,13183],[13280,13310],[13312,19903],[19968,40959],[42752,42759],[63744,64109],[64112,64217],[65093,65094],[65377,65381],[94178,94179],[94192,94193],[119648,119665],[127568,127569],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"Script_Extensions/Anatolian_Hieroglyphs":[[82944,83526]],"Script_Extensions/Newa":[[70656,70747],[70749,70753]],"Script_Extensions/Nushu":[[94177,94177],[110960,111355]],"Script_Extensions/Vai":[[42240,42539]],"Script_Extensions/Yezidi":[[1548,1548],[1563,1563],[1567,1567],[1632,1641],[69248,69289],[69291,69293],[69296,69297]],"Script_Extensions/Lycian":[[8282,8282],[66176,66204]],"Script_Extensions/Hebrew":[[775,776],[1425,1479],[1488,1514],[1519,1524],[64285,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64335]],"Script_Extensions/Gurmukhi":[[2385,2386],[2404,2405],[2561,2563],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2620,2620],[2622,2626],[2631,2632],[2635,2637],[2641,2641],[2649,2652],[2654,2654],[2662,2678],[43056,43065]],"Script_Extensions/Oriya":[[2385,2386],[2404,2405],[2817,2819],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2876,2884],[2887,2888],[2891,2893],[2901,2903],[2908,2909],[2911,2915],[2918,2935],[7386,7386],[7410,7410]],"Script_Extensions/Warang_Citi":[[71840,71922],[71935,71935]],"Script_Extensions/Cham":[[43520,43574],[43584,43597],[43600,43609],[43612,43615]],"Script_Extensions/Dogra":[[2404,2415],[43056,43065],[71680,71739]],"Script_Extensions/Cyrillic":[[700,700],[768,770],[772,772],[774,774],[776,776],[779,779],[785,785],[1024,1327],[7296,7306],[7467,7467],[7544,7544],[7672,7672],[11744,11775],[11843,11843],[42560,42655],[65070,65071],[122928,122989],[123023,123023]],"Script_Extensions/Siddham":[[71040,71093],[71096,71133]],"Script_Extensions/Khudawadi":[[2404,2405],[43056,43065],[70320,70378],[70384,70393]],"Script_Extensions/Kayah_Li":[[43264,43311]],"Script_Extensions/Gunjala_Gondi":[[183,183],[2404,2405],[73056,73061],[73063,73064],[73066,73102],[73104,73105],[73107,73112],[73120,73129]],"Script_Extensions/Nandinagari":[[2404,2405],[3302,3311],[7401,7401],[7410,7410],[7418,7418],[43056,43061],[72096,72103],[72106,72151],[72154,72164]],"Script_Extensions/Avestan":[[183,183],[11824,11825],[68352,68405],[68409,68415]],"Script_Extensions/Tibetan":[[3840,3911],[3913,3948],[3953,3991],[3993,4028],[4030,4044],[4046,4052],[4057,4058],[12296,12299]],"Script_Extensions/Psalter_Pahlavi":[[1600,1600],[68480,68497],[68505,68508],[68521,68527]],"Script_Extensions/Vithkuqi":[[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004]],"Script_Extensions/Meroitic_Cursive":[[68000,68023],[68028,68047],[68050,68095]],"Script_Extensions/Linear_B":[[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65792,65794],[65799,65843],[65847,65855]],"Script_Extensions/Sunuwar":[[768,769],[771,771],[781,781],[784,784],[813,813],[817,817],[72640,72673],[72688,72697]],"Script_Extensions/Multani":[[2662,2671],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70313]],"Script_Extensions/Sharada":[[2385,2385],[7383,7383],[7385,7385],[7388,7389],[7392,7392],[43056,43061],[43064,43064],[70016,70111]],"Script_Extensions/Arabic":[[1536,1540],[1542,1756],[1758,1791],[1872,1919],[2160,2190],[2192,2193],[2199,2273],[2275,2303],[8271,8271],[11841,11841],[64336,64450],[64467,64911],[64914,64967],[64975,64975],[65008,65023],[65136,65140],[65142,65276],[66272,66299],[69216,69246],[69314,69316],[69372,69375],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[126704,126705]],"Script_Extensions/Pahawh_Hmong":[[92928,92997],[93008,93017],[93019,93025],[93027,93047],[93053,93071]],"Script_Extensions/Canadian_Aboriginal":[[5120,5759],[6320,6389],[72368,72383]],"Script_Extensions/Bopomofo":[[711,711],[713,715],[729,729],[746,747],[12289,12291],[12296,12305],[12307,12319],[12330,12333],[12336,12336],[12343,12343],[12539,12539],[12549,12591],[12704,12735],[65093,65094],[65377,65381]],"Script_Extensions/Armenian":[[776,776],[1329,1366],[1369,1418],[1421,1423],[64275,64279]],"Script_Extensions/Kirat_Rai":[[93504,93561]],"Script_Extensions/Elbasan":[[183,183],[773,773],[66816,66855]],"Script_Extensions/Coptic":[[183,183],[768,768],[772,773],[775,775],[884,885],[994,1007],[11392,11507],[11513,11519],[11799,11799],[66272,66299]],"Script_Extensions/Yi":[[12289,12290],[12296,12305],[12308,12315],[12539,12539],[40960,42124],[42128,42182],[65377,65381]],"Script_Extensions/Tirhuta":[[2385,2386],[2404,2405],[7410,7410],[43056,43065],[70784,70855],[70864,70873]],"Script_Extensions/Tai_Viet":[[43648,43714],[43739,43743]],"Script_Extensions/Inscriptional_Pahlavi":[[68448,68466],[68472,68479]],"Script_Extensions/Miao":[[93952,94026],[94031,94087],[94095,94111]],"Script_Extensions/Hiragana":[[12289,12291],[12296,12305],[12307,12319],[12336,12341],[12343,12343],[12348,12349],[12353,12438],[12441,12448],[12539,12540],[65093,65094],[65377,65381],[65392,65392],[65438,65439],[110593,110879],[110898,110898],[110928,110930],[127488,127488]],"Script_Extensions/Buhid":[[5941,5942],[5952,5971]],"Script_Extensions/Nag_Mundari":[[124112,124153]],"Script_Extensions/Kharoshthi":[[68096,68099],[68101,68102],[68108,68115],[68117,68119],[68121,68149],[68152,68154],[68159,68168],[68176,68184]],"Script_Extensions/Tulu_Tigalari":[[3302,3311],[7410,7410],[7412,7412],[43056,43061],[43249,43249],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70592],[70594,70594],[70597,70597],[70599,70602],[70604,70613],[70615,70616],[70625,70626]],"Script_Extensions/Glagolitic":[[183,183],[771,771],[773,773],[1156,1156],[1159,1159],[1417,1417],[4347,4347],[8282,8282],[11264,11359],[11843,11843],[42607,42607],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922]],"Script_Extensions/Bamum":[[42656,42743],[92160,92728]],"Script_Extensions/Tagalog":[[5888,5909],[5919,5919],[5941,5942]],"Script_Extensions/Brahmi":[[69632,69709],[69714,69749],[69759,69759]],"Script_Extensions/Khmer":[[6016,6109],[6112,6121],[6128,6137],[6624,6655]],"Script_Extensions/Carian":[[183,183],[8282,8282],[8285,8285],[11825,11825],[66208,66256]],"Script_Extensions/Ol_Onal":[[2404,2405],[124368,124410],[124415,124415]],"Script_Extensions/Tai_Le":[[768,769],[775,776],[780,780],[4160,4169],[6480,6509],[6512,6516]],"Script_Extensions/Tamil":[[2385,2386],[2404,2405],[2946,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3006,3010],[3014,3016],[3018,3021],[3024,3024],[3031,3031],[3046,3066],[7386,7386],[43251,43251],[70401,70401],[70403,70403],[70459,70460],[73664,73713],[73727,73727]],"Script_Extensions/Tangsa":[[92784,92862],[92864,92873]],"Script_Extensions/Gothic":[[183,183],[772,773],[776,776],[817,817],[66352,66378]],"Script_Extensions/Adlam":[[1567,1567],[1600,1600],[8271,8271],[11841,11841],[125184,125259],[125264,125273],[125278,125279]],"Script_Extensions/Ahom":[[71424,71450],[71453,71467],[71472,71494]],"Script_Extensions/Nyiakeng_Puachue_Hmong":[[123136,123180],[123184,123197],[123200,123209],[123214,123215]],"Script_Extensions/Nabataean":[[67712,67742],[67751,67759]],"Script_Extensions/Old_Sogdian":[[69376,69415]],"Script_Extensions/Hanifi_Rohingya":[[1548,1548],[1563,1563],[1567,1567],[1600,1600],[1748,1748],[68864,68903],[68912,68921]],"Script_Extensions/Mahajani":[[183,183],[2404,2415],[43056,43065],[69968,70006]],"Script_Extensions/Phags_Pa":[[6146,6147],[6149,6149],[8239,8239],[12290,12290],[43072,43127]],"Script_Extensions/Old_Hungarian":[[8282,8282],[8285,8285],[11825,11825],[11841,11841],[68736,68786],[68800,68850],[68858,68863]],"Script_Extensions/Old_Persian":[[66464,66499],[66504,66517]],"Script_Extensions/Todhri":[[769,769],[772,772],[775,775],[785,785],[787,787],[862,862],[67008,67059]],"Script_Extensions/Old_Uyghur":[[1600,1600],[68338,68338],[69488,69513]],"Script_Extensions/Limbu":[[2405,2405],[6400,6430],[6432,6443],[6448,6459],[6464,6464],[6468,6479]],"Script_Extensions/Tifinagh":[[770,770],[772,772],[775,775],[777,777],[11568,11623],[11631,11632],[11647,11647]],"Script_Extensions/Lisu":[[700,700],[717,717],[12298,12299],[42192,42239],[73648,73648]],"Script_Extensions/Bengali":[[700,700],[2385,2386],[2404,2405],[2432,2435],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2492,2500],[2503,2504],[2507,2510],[2519,2519],[2524,2525],[2527,2531],[2534,2558],[7376,7376],[7378,7378],[7381,7382],[7384,7384],[7393,7393],[7402,7402],[7405,7405],[7410,7410],[7413,7415],[43249,43249]],"Script_Extensions/Pau_Cin_Hau":[[72384,72440]],"Script_Extensions/Elymaic":[[69600,69622]],"Script_Extensions/Saurashtra":[[43136,43205],[43214,43225]],"Script_Extensions/Meetei_Mayek":[[43744,43766],[43968,44013],[44016,44025]],"Script_Extensions/Old_Turkic":[[8282,8282],[11824,11824],[68608,68680]],"Script_Extensions/Thai":[[700,700],[727,727],[771,771],[817,817],[3585,3642],[3648,3675]],"Script_Extensions/Old_Italic":[[66304,66339],[66349,66351]],"Script_Extensions/Palmyrene":[[67680,67711]],"Script_Extensions/Braille":[[10240,10495]],"Script_Extensions/Balinese":[[6912,6988],[6990,7039]],"Script_Extensions/Meroitic_Hieroglyphs":[[8285,8285],[67968,67999]],"Script_Extensions/Masaram_Gondi":[[2404,2405],[72960,72966],[72968,72969],[72971,73014],[73018,73018],[73020,73021],[73023,73031],[73040,73049]],"Script_Extensions/Katakana":[[773,773],[803,803],[12289,12291],[12296,12305],[12307,12319],[12336,12341],[12343,12343],[12348,12349],[12441,12444],[12448,12543],[12784,12799],[13008,13054],[13056,13143],[65093,65094],[65377,65439],[110576,110579],[110581,110587],[110589,110590],[110592,110592],[110880,110882],[110933,110933],[110948,110951]],"Script_Extensions/Modi":[[43056,43065],[71168,71236],[71248,71257]],"Script_Extensions/Lepcha":[[7168,7223],[7227,7241],[7245,7247]],"Script_Extensions/Ogham":[[5760,5788]],"Script_Extensions/Medefaidrin":[[93760,93850]],"Script_Extensions/Makasar":[[73440,73464]],"Script_Extensions/Sundanese":[[7040,7103],[7360,7367]],"Script_Extensions/Old_South_Arabian":[[68192,68223]],"Script_Extensions/Old_North_Arabian":[[68224,68255]],"Script_Extensions/Devanagari":[[700,700],[2304,2386],[2389,2431],[7376,7414],[7416,7417],[8432,8432],[43056,43065],[43232,43263],[72448,72457]],"Script_Extensions/Batak":[[7104,7155],[7164,7167]],"Script_Extensions/Thaana":[[1548,1548],[1563,1564],[1567,1567],[1632,1641],[1920,1969],[65010,65010],[65021,65021]],"Script_Extensions/Hanunoo":[[5920,5942]],"Script_Extensions/Inscriptional_Parthian":[[68416,68437],[68440,68447]],"Script_Extensions/Dives_Akuru":[[71936,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71989],[71991,71992],[71995,72006],[72016,72025]],"Script_Extensions/Chakma":[[2534,2543],[4160,4169],[69888,69940],[69942,69959]],"Script_Extensions/Takri":[[2404,2405],[43056,43065],[71296,71353],[71360,71369]],"Script_Extensions/Cypro_Minoan":[[65792,65793],[77712,77810]],"Script_Extensions/Runic":[[5792,5880]],"Script_Extensions/Kaithi":[[2406,2415],[11825,11825],[43056,43065],[69760,69826],[69837,69837]],"Script_Extensions/Cherokee":[[768,770],[772,772],[779,780],[803,804],[816,817],[5024,5109],[5112,5117],[43888,43967]],"Script_Extensions/Garay":[[1548,1548],[1563,1563],[1567,1567],[68928,68965],[68969,68997],[69006,69007]],"Script_Extensions/Shavian":[[183,183],[66640,66687]],"Script_Extensions/Osmanya":[[66688,66717],[66720,66729]],"Script_Extensions/Marchen":[[72816,72847],[72850,72871],[72873,72886]],"Script_Extensions/Manichaean":[[1600,1600],[68288,68326],[68331,68342]],"Script_Extensions/Lao":[[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3773],[3776,3780],[3782,3782],[3784,3790],[3792,3801],[3804,3807]],"Script_Extensions/Rejang":[[43312,43347],[43359,43359]],"Script_Extensions/Gujarati":[[2385,2386],[2404,2405],[2689,2691],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2748,2757],[2759,2761],[2763,2765],[2768,2768],[2784,2787],[2790,2801],[2809,2815],[43056,43065]],"Script_Extensions/Javanese":[[43392,43469],[43471,43481],[43486,43487]],"Script_Extensions/Grantha":[[2385,2386],[2404,2405],[3046,3059],[7376,7376],[7378,7379],[7410,7412],[7416,7417],[8432,8432],[70400,70403],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70459,70468],[70471,70472],[70475,70477],[70480,70480],[70487,70487],[70493,70499],[70502,70508],[70512,70516],[73680,73681],[73683,73683]],"Script_Extensions/Cuneiform":[[73728,74649],[74752,74862],[74864,74868],[74880,75075]],"Script_Extensions/Toto":[[700,700],[123536,123566]],"Script_Extensions/Bhaiksuki":[[72704,72712],[72714,72758],[72760,72773],[72784,72812]],"Script_Extensions/Mandaic":[[1600,1600],[2112,2139],[2142,2142]],"Script_Extensions/Syloti_Nagri":[[2404,2405],[2534,2543],[43008,43052]],"Script_Extensions/Ol_Chiki":[[7248,7295]],"Script_Extensions/Malayalam":[[2385,2386],[2404,2405],[3328,3340],[3342,3344],[3346,3396],[3398,3400],[3402,3407],[3412,3427],[3430,3455],[7386,7386],[7410,7410],[43056,43058]],"Script_Extensions/Hatran":[[67808,67826],[67828,67829],[67835,67839]],"Script_Extensions/Georgian":[[183,183],[1417,1417],[4256,4293],[4295,4295],[4301,4301],[4304,4351],[7312,7354],[7357,7359],[8282,8282],[11520,11557],[11559,11559],[11565,11565],[11825,11825]],"Script_Extensions/Zanabazar_Square":[[72192,72263]],"Script_Extensions/Caucasian_Albanian":[[772,772],[817,817],[862,862],[66864,66915],[66927,66927]],"Script_Extensions/Duployan":[[183,183],[775,776],[778,778],[803,804],[11836,11836],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[113820,113827]],"Script_Extensions/Hangul":[[4352,4607],[12289,12291],[12296,12305],[12307,12319],[12334,12336],[12343,12343],[12539,12539],[12593,12686],[12800,12830],[12896,12926],[43360,43388],[44032,55203],[55216,55238],[55243,55291],[65093,65094],[65377,65381],[65440,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500]],"Script_Extensions/Wancho":[[123584,123641],[123647,123647]],"Script_Extensions/Nko":[[1548,1548],[1563,1563],[1567,1567],[1984,2042],[2045,2047],[64830,64831]],"Script_Extensions/Syriac":[[771,772],[775,776],[778,778],[800,800],[803,805],[813,814],[816,816],[1548,1548],[1563,1564],[1567,1567],[1600,1600],[1611,1621],[1648,1648],[1792,1805],[1807,1866],[1869,1871],[2144,2154],[7672,7672],[7674,7674]],"Script_Extensions/Tagbanwa":[[5941,5942],[5984,5996],[5998,6000],[6002,6003]],"Script_Extensions/Inherited":[[783,783],[786,786],[788,799],[801,802],[806,812],[815,815],[818,833],[835,836],[838,855],[857,861],[863,866],[2387,2388],[6832,6862],[7618,7671],[7673,7673],[7675,7679],[8204,8205],[8400,8431],[65024,65039],[65056,65069],[66045,66045],[118528,118573],[118576,118598],[119143,119145],[119163,119170],[119173,119179],[119210,119213],[917760,917999]],"Script_Extensions/Old_Permic":[[183,183],[768,768],[774,776],[787,787],[1155,1155],[66384,66426]],"Script_Extensions/Egyptian_Hieroglyphs":[[77824,78933],[78944,82938]],"Binary_Property/Any":[[0,1114111]],"Binary_Property/Expands_On_NFC":[[836,836],[2392,2399],[2524,2525],[2527,2527],[2611,2611],[2614,2614],[2649,2651],[2654,2654],[2908,2909],[3907,3907],[3917,3917],[3922,3922],[3927,3927],[3932,3932],[3945,3945],[3955,3955],[3957,3958],[3960,3960],[3969,3969],[3987,3987],[3997,3997],[4002,4002],[4007,4007],[4012,4012],[4025,4025],[10972,10972],[64285,64285],[64287,64287],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64334],[119134,119140],[119227,119232]],"Binary_Property/Hyphen":[[45,45],[173,173],[1418,1418],[6150,6150],[8208,8209],[11799,11799],[12539,12539],[65123,65123],[65293,65293],[65381,65381]],"Binary_Property/Logical_Order_Exception":[[3648,3652],[3776,3780],[6581,6583],[6586,6586],[43701,43702],[43705,43705],[43707,43708]],"Binary_Property/Grapheme_Link":[[2381,2381],[2509,2509],[2637,2637],[2765,2765],[2893,2893],[3021,3021],[3149,3149],[3277,3277],[3387,3388],[3405,3405],[3530,3530],[3642,3642],[3770,3770],[3972,3972],[4153,4154],[5908,5909],[5940,5940],[6098,6098],[6752,6752],[6980,6980],[7082,7083],[7154,7155],[11647,11647],[43014,43014],[43052,43052],[43204,43204],[43347,43347],[43456,43456],[43766,43766],[44013,44013],[68159,68159],[69702,69702],[69744,69744],[69759,69759],[69817,69817],[69939,69940],[70080,70080],[70197,70197],[70378,70378],[70477,70477],[70606,70608],[70722,70722],[70850,70850],[71103,71103],[71231,71231],[71350,71350],[71467,71467],[71737,71737],[71997,71998],[72160,72160],[72244,72244],[72263,72263],[72345,72345],[72767,72767],[73028,73029],[73111,73111],[73537,73538],[90415,90415]],"Binary_Property/Full_Composition_Exclusion":[[832,833],[835,836],[884,884],[894,894],[903,903],[2392,2399],[2524,2525],[2527,2527],[2611,2611],[2614,2614],[2649,2651],[2654,2654],[2908,2909],[3907,3907],[3917,3917],[3922,3922],[3927,3927],[3932,3932],[3945,3945],[3955,3955],[3957,3958],[3960,3960],[3969,3969],[3987,3987],[3997,3997],[4002,4002],[4007,4007],[4012,4012],[4025,4025],[8049,8049],[8051,8051],[8053,8053],[8055,8055],[8057,8057],[8059,8059],[8061,8061],[8123,8123],[8126,8126],[8137,8137],[8139,8139],[8147,8147],[8155,8155],[8163,8163],[8171,8171],[8174,8175],[8185,8185],[8187,8187],[8189,8189],[8192,8193],[8486,8486],[8490,8491],[9001,9002],[10972,10972],[63744,64013],[64016,64016],[64018,64018],[64021,64030],[64032,64032],[64034,64034],[64037,64038],[64042,64109],[64112,64217],[64285,64285],[64287,64287],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64334],[119134,119140],[119227,119232],[194560,195101]],"Binary_Property/ID_Start":[[65,90],[97,122],[170,170],[181,181],[186,186],[192,214],[216,246],[248,705],[710,721],[736,740],[748,748],[750,750],[880,884],[886,887],[890,893],[895,895],[902,902],[904,906],[908,908],[910,929],[931,1013],[1015,1153],[1162,1327],[1329,1366],[1369,1369],[1376,1416],[1488,1514],[1519,1522],[1568,1610],[1646,1647],[1649,1747],[1749,1749],[1765,1766],[1774,1775],[1786,1788],[1791,1791],[1808,1808],[1810,1839],[1869,1957],[1969,1969],[1994,2026],[2036,2037],[2042,2042],[2048,2069],[2074,2074],[2084,2084],[2088,2088],[2112,2136],[2144,2154],[2160,2183],[2185,2190],[2208,2249],[2308,2361],[2365,2365],[2384,2384],[2392,2401],[2417,2432],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2493,2493],[2510,2510],[2524,2525],[2527,2529],[2544,2545],[2556,2556],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2649,2652],[2654,2654],[2674,2676],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2749,2749],[2768,2768],[2784,2785],[2809,2809],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2877,2877],[2908,2909],[2911,2913],[2929,2929],[2947,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3024,3024],[3077,3084],[3086,3088],[3090,3112],[3114,3129],[3133,3133],[3160,3162],[3165,3165],[3168,3169],[3200,3200],[3205,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3261,3261],[3293,3294],[3296,3297],[3313,3314],[3332,3340],[3342,3344],[3346,3386],[3389,3389],[3406,3406],[3412,3414],[3423,3425],[3450,3455],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3585,3632],[3634,3635],[3648,3654],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3760],[3762,3763],[3773,3773],[3776,3780],[3782,3782],[3804,3807],[3840,3840],[3904,3911],[3913,3948],[3976,3980],[4096,4138],[4159,4159],[4176,4181],[4186,4189],[4193,4193],[4197,4198],[4206,4208],[4213,4225],[4238,4238],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4348,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4992,5007],[5024,5109],[5112,5117],[5121,5740],[5743,5759],[5761,5786],[5792,5866],[5870,5880],[5888,5905],[5919,5937],[5952,5969],[5984,5996],[5998,6000],[6016,6067],[6103,6103],[6108,6108],[6176,6264],[6272,6312],[6314,6314],[6320,6389],[6400,6430],[6480,6509],[6512,6516],[6528,6571],[6576,6601],[6656,6678],[6688,6740],[6823,6823],[6917,6963],[6981,6988],[7043,7072],[7086,7087],[7098,7141],[7168,7203],[7245,7247],[7258,7293],[7296,7306],[7312,7354],[7357,7359],[7401,7404],[7406,7411],[7413,7414],[7418,7418],[7424,7615],[7680,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8305,8305],[8319,8319],[8336,8348],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8472,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8505],[8508,8511],[8517,8521],[8526,8526],[8544,8584],[11264,11492],[11499,11502],[11506,11507],[11520,11557],[11559,11559],[11565,11565],[11568,11623],[11631,11631],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[12293,12295],[12321,12329],[12337,12341],[12344,12348],[12353,12438],[12443,12447],[12449,12538],[12540,12543],[12549,12591],[12593,12686],[12704,12735],[12784,12799],[13312,19903],[19968,42124],[42192,42237],[42240,42508],[42512,42527],[42538,42539],[42560,42606],[42623,42653],[42656,42735],[42775,42783],[42786,42888],[42891,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43009],[43011,43013],[43015,43018],[43020,43042],[43072,43123],[43138,43187],[43250,43255],[43259,43259],[43261,43262],[43274,43301],[43312,43334],[43360,43388],[43396,43442],[43471,43471],[43488,43492],[43494,43503],[43514,43518],[43520,43560],[43584,43586],[43588,43595],[43616,43638],[43642,43642],[43646,43695],[43697,43697],[43701,43702],[43705,43709],[43712,43712],[43714,43714],[43739,43741],[43744,43754],[43762,43764],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43866],[43868,43881],[43888,44002],[44032,55203],[55216,55238],[55243,55291],[63744,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64285],[64287,64296],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64829],[64848,64911],[64914,64967],[65008,65019],[65136,65140],[65142,65276],[65313,65338],[65345,65370],[65382,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65856,65908],[66176,66204],[66208,66256],[66304,66335],[66349,66378],[66384,66421],[66432,66461],[66464,66499],[66504,66511],[66513,66517],[66560,66717],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67680,67702],[67712,67742],[67808,67826],[67828,67829],[67840,67861],[67872,67897],[67968,68023],[68030,68031],[68096,68096],[68112,68115],[68117,68119],[68121,68149],[68192,68220],[68224,68252],[68288,68295],[68297,68324],[68352,68405],[68416,68437],[68448,68466],[68480,68497],[68608,68680],[68736,68786],[68800,68850],[68864,68899],[68938,68965],[68975,68997],[69248,69289],[69296,69297],[69314,69316],[69376,69404],[69415,69415],[69424,69445],[69488,69505],[69552,69572],[69600,69622],[69635,69687],[69745,69746],[69749,69749],[69763,69807],[69840,69864],[69891,69926],[69956,69956],[69959,69959],[69968,70002],[70006,70006],[70019,70066],[70081,70084],[70106,70106],[70108,70108],[70144,70161],[70163,70187],[70207,70208],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70312],[70320,70366],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70461,70461],[70480,70480],[70493,70497],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70583],[70609,70609],[70611,70611],[70656,70708],[70727,70730],[70751,70753],[70784,70831],[70852,70853],[70855,70855],[71040,71086],[71128,71131],[71168,71215],[71236,71236],[71296,71338],[71352,71352],[71424,71450],[71488,71494],[71680,71723],[71840,71903],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71983],[71999,71999],[72001,72001],[72096,72103],[72106,72144],[72161,72161],[72163,72163],[72192,72192],[72203,72242],[72250,72250],[72272,72272],[72284,72329],[72349,72349],[72368,72440],[72640,72672],[72704,72712],[72714,72750],[72768,72768],[72818,72847],[72960,72966],[72968,72969],[72971,73008],[73030,73030],[73056,73061],[73063,73064],[73066,73097],[73112,73112],[73440,73458],[73474,73474],[73476,73488],[73490,73523],[73648,73648],[73728,74649],[74752,74862],[74880,75075],[77712,77808],[77824,78895],[78913,78918],[78944,82938],[82944,83526],[90368,90397],[92160,92728],[92736,92766],[92784,92862],[92880,92909],[92928,92975],[92992,92995],[93027,93047],[93053,93071],[93504,93548],[93760,93823],[93952,94026],[94032,94032],[94099,94111],[94176,94177],[94179,94179],[94208,100343],[100352,101589],[101631,101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[122624,122654],[122661,122666],[122928,122989],[123136,123180],[123191,123197],[123214,123214],[123536,123565],[123584,123627],[124112,124139],[124368,124397],[124400,124400],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125184,125251],[125259,125259],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"Binary_Property/Pattern_White_Space":[[9,13],[32,32],[133,133],[8206,8207],[8232,8233]],"Binary_Property/Changes_When_Titlecased":[[97,122],[181,181],[223,246],[248,255],[257,257],[259,259],[261,261],[263,263],[265,265],[267,267],[269,269],[271,271],[273,273],[275,275],[277,277],[279,279],[281,281],[283,283],[285,285],[287,287],[289,289],[291,291],[293,293],[295,295],[297,297],[299,299],[301,301],[303,303],[305,305],[307,307],[309,309],[311,311],[314,314],[316,316],[318,318],[320,320],[322,322],[324,324],[326,326],[328,329],[331,331],[333,333],[335,335],[337,337],[339,339],[341,341],[343,343],[345,345],[347,347],[349,349],[351,351],[353,353],[355,355],[357,357],[359,359],[361,361],[363,363],[365,365],[367,367],[369,369],[371,371],[373,373],[375,375],[378,378],[380,380],[382,384],[387,387],[389,389],[392,392],[396,396],[402,402],[405,405],[409,411],[414,414],[417,417],[419,419],[421,421],[424,424],[429,429],[432,432],[436,436],[438,438],[441,441],[445,445],[447,447],[452,452],[454,455],[457,458],[460,460],[462,462],[464,464],[466,466],[468,468],[470,470],[472,472],[474,474],[476,477],[479,479],[481,481],[483,483],[485,485],[487,487],[489,489],[491,491],[493,493],[495,497],[499,499],[501,501],[505,505],[507,507],[509,509],[511,511],[513,513],[515,515],[517,517],[519,519],[521,521],[523,523],[525,525],[527,527],[529,529],[531,531],[533,533],[535,535],[537,537],[539,539],[541,541],[543,543],[547,547],[549,549],[551,551],[553,553],[555,555],[557,557],[559,559],[561,561],[563,563],[572,572],[575,576],[578,578],[583,583],[585,585],[587,587],[589,589],[591,596],[598,599],[601,601],[603,604],[608,609],[611,614],[616,620],[623,623],[625,626],[629,629],[637,637],[640,640],[642,643],[647,652],[658,658],[669,670],[837,837],[881,881],[883,883],[887,887],[891,893],[912,912],[940,974],[976,977],[981,983],[985,985],[987,987],[989,989],[991,991],[993,993],[995,995],[997,997],[999,999],[1001,1001],[1003,1003],[1005,1005],[1007,1011],[1013,1013],[1016,1016],[1019,1019],[1072,1119],[1121,1121],[1123,1123],[1125,1125],[1127,1127],[1129,1129],[1131,1131],[1133,1133],[1135,1135],[1137,1137],[1139,1139],[1141,1141],[1143,1143],[1145,1145],[1147,1147],[1149,1149],[1151,1151],[1153,1153],[1163,1163],[1165,1165],[1167,1167],[1169,1169],[1171,1171],[1173,1173],[1175,1175],[1177,1177],[1179,1179],[1181,1181],[1183,1183],[1185,1185],[1187,1187],[1189,1189],[1191,1191],[1193,1193],[1195,1195],[1197,1197],[1199,1199],[1201,1201],[1203,1203],[1205,1205],[1207,1207],[1209,1209],[1211,1211],[1213,1213],[1215,1215],[1218,1218],[1220,1220],[1222,1222],[1224,1224],[1226,1226],[1228,1228],[1230,1231],[1233,1233],[1235,1235],[1237,1237],[1239,1239],[1241,1241],[1243,1243],[1245,1245],[1247,1247],[1249,1249],[1251,1251],[1253,1253],[1255,1255],[1257,1257],[1259,1259],[1261,1261],[1263,1263],[1265,1265],[1267,1267],[1269,1269],[1271,1271],[1273,1273],[1275,1275],[1277,1277],[1279,1279],[1281,1281],[1283,1283],[1285,1285],[1287,1287],[1289,1289],[1291,1291],[1293,1293],[1295,1295],[1297,1297],[1299,1299],[1301,1301],[1303,1303],[1305,1305],[1307,1307],[1309,1309],[1311,1311],[1313,1313],[1315,1315],[1317,1317],[1319,1319],[1321,1321],[1323,1323],[1325,1325],[1327,1327],[1377,1415],[5112,5117],[7296,7304],[7306,7306],[7545,7545],[7549,7549],[7566,7566],[7681,7681],[7683,7683],[7685,7685],[7687,7687],[7689,7689],[7691,7691],[7693,7693],[7695,7695],[7697,7697],[7699,7699],[7701,7701],[7703,7703],[7705,7705],[7707,7707],[7709,7709],[7711,7711],[7713,7713],[7715,7715],[7717,7717],[7719,7719],[7721,7721],[7723,7723],[7725,7725],[7727,7727],[7729,7729],[7731,7731],[7733,7733],[7735,7735],[7737,7737],[7739,7739],[7741,7741],[7743,7743],[7745,7745],[7747,7747],[7749,7749],[7751,7751],[7753,7753],[7755,7755],[7757,7757],[7759,7759],[7761,7761],[7763,7763],[7765,7765],[7767,7767],[7769,7769],[7771,7771],[7773,7773],[7775,7775],[7777,7777],[7779,7779],[7781,7781],[7783,7783],[7785,7785],[7787,7787],[7789,7789],[7791,7791],[7793,7793],[7795,7795],[7797,7797],[7799,7799],[7801,7801],[7803,7803],[7805,7805],[7807,7807],[7809,7809],[7811,7811],[7813,7813],[7815,7815],[7817,7817],[7819,7819],[7821,7821],[7823,7823],[7825,7825],[7827,7827],[7829,7835],[7841,7841],[7843,7843],[7845,7845],[7847,7847],[7849,7849],[7851,7851],[7853,7853],[7855,7855],[7857,7857],[7859,7859],[7861,7861],[7863,7863],[7865,7865],[7867,7867],[7869,7869],[7871,7871],[7873,7873],[7875,7875],[7877,7877],[7879,7879],[7881,7881],[7883,7883],[7885,7885],[7887,7887],[7889,7889],[7891,7891],[7893,7893],[7895,7895],[7897,7897],[7899,7899],[7901,7901],[7903,7903],[7905,7905],[7907,7907],[7909,7909],[7911,7911],[7913,7913],[7915,7915],[7917,7917],[7919,7919],[7921,7921],[7923,7923],[7925,7925],[7927,7927],[7929,7929],[7931,7931],[7933,7933],[7935,7943],[7952,7957],[7968,7975],[7984,7991],[8000,8005],[8016,8023],[8032,8039],[8048,8061],[8064,8071],[8080,8087],[8096,8103],[8112,8116],[8118,8119],[8126,8126],[8130,8132],[8134,8135],[8144,8147],[8150,8151],[8160,8167],[8178,8180],[8182,8183],[8526,8526],[8560,8575],[8580,8580],[9424,9449],[11312,11359],[11361,11361],[11365,11366],[11368,11368],[11370,11370],[11372,11372],[11379,11379],[11382,11382],[11393,11393],[11395,11395],[11397,11397],[11399,11399],[11401,11401],[11403,11403],[11405,11405],[11407,11407],[11409,11409],[11411,11411],[11413,11413],[11415,11415],[11417,11417],[11419,11419],[11421,11421],[11423,11423],[11425,11425],[11427,11427],[11429,11429],[11431,11431],[11433,11433],[11435,11435],[11437,11437],[11439,11439],[11441,11441],[11443,11443],[11445,11445],[11447,11447],[11449,11449],[11451,11451],[11453,11453],[11455,11455],[11457,11457],[11459,11459],[11461,11461],[11463,11463],[11465,11465],[11467,11467],[11469,11469],[11471,11471],[11473,11473],[11475,11475],[11477,11477],[11479,11479],[11481,11481],[11483,11483],[11485,11485],[11487,11487],[11489,11489],[11491,11491],[11500,11500],[11502,11502],[11507,11507],[11520,11557],[11559,11559],[11565,11565],[42561,42561],[42563,42563],[42565,42565],[42567,42567],[42569,42569],[42571,42571],[42573,42573],[42575,42575],[42577,42577],[42579,42579],[42581,42581],[42583,42583],[42585,42585],[42587,42587],[42589,42589],[42591,42591],[42593,42593],[42595,42595],[42597,42597],[42599,42599],[42601,42601],[42603,42603],[42605,42605],[42625,42625],[42627,42627],[42629,42629],[42631,42631],[42633,42633],[42635,42635],[42637,42637],[42639,42639],[42641,42641],[42643,42643],[42645,42645],[42647,42647],[42649,42649],[42651,42651],[42787,42787],[42789,42789],[42791,42791],[42793,42793],[42795,42795],[42797,42797],[42799,42799],[42803,42803],[42805,42805],[42807,42807],[42809,42809],[42811,42811],[42813,42813],[42815,42815],[42817,42817],[42819,42819],[42821,42821],[42823,42823],[42825,42825],[42827,42827],[42829,42829],[42831,42831],[42833,42833],[42835,42835],[42837,42837],[42839,42839],[42841,42841],[42843,42843],[42845,42845],[42847,42847],[42849,42849],[42851,42851],[42853,42853],[42855,42855],[42857,42857],[42859,42859],[42861,42861],[42863,42863],[42874,42874],[42876,42876],[42879,42879],[42881,42881],[42883,42883],[42885,42885],[42887,42887],[42892,42892],[42897,42897],[42899,42900],[42903,42903],[42905,42905],[42907,42907],[42909,42909],[42911,42911],[42913,42913],[42915,42915],[42917,42917],[42919,42919],[42921,42921],[42933,42933],[42935,42935],[42937,42937],[42939,42939],[42941,42941],[42943,42943],[42945,42945],[42947,42947],[42952,42952],[42954,42954],[42957,42957],[42961,42961],[42967,42967],[42969,42969],[42971,42971],[42998,42998],[43859,43859],[43888,43967],[64256,64262],[64275,64279],[65345,65370],[66600,66639],[66776,66811],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[68800,68850],[68976,68997],[71872,71903],[93792,93823],[125218,125251]],"Binary_Property/Changes_When_Casefolded":[[65,90],[181,181],[192,214],[216,223],[256,256],[258,258],[260,260],[262,262],[264,264],[266,266],[268,268],[270,270],[272,272],[274,274],[276,276],[278,278],[280,280],[282,282],[284,284],[286,286],[288,288],[290,290],[292,292],[294,294],[296,296],[298,298],[300,300],[302,302],[304,304],[306,306],[308,308],[310,310],[313,313],[315,315],[317,317],[319,319],[321,321],[323,323],[325,325],[327,327],[329,330],[332,332],[334,334],[336,336],[338,338],[340,340],[342,342],[344,344],[346,346],[348,348],[350,350],[352,352],[354,354],[356,356],[358,358],[360,360],[362,362],[364,364],[366,366],[368,368],[370,370],[372,372],[374,374],[376,377],[379,379],[381,381],[383,383],[385,386],[388,388],[390,391],[393,395],[398,401],[403,404],[406,408],[412,413],[415,416],[418,418],[420,420],[422,423],[425,425],[428,428],[430,431],[433,435],[437,437],[439,440],[444,444],[452,453],[455,456],[458,459],[461,461],[463,463],[465,465],[467,467],[469,469],[471,471],[473,473],[475,475],[478,478],[480,480],[482,482],[484,484],[486,486],[488,488],[490,490],[492,492],[494,494],[497,498],[500,500],[502,504],[506,506],[508,508],[510,510],[512,512],[514,514],[516,516],[518,518],[520,520],[522,522],[524,524],[526,526],[528,528],[530,530],[532,532],[534,534],[536,536],[538,538],[540,540],[542,542],[544,544],[546,546],[548,548],[550,550],[552,552],[554,554],[556,556],[558,558],[560,560],[562,562],[570,571],[573,574],[577,577],[579,582],[584,584],[586,586],[588,588],[590,590],[837,837],[880,880],[882,882],[886,886],[895,895],[902,902],[904,906],[908,908],[910,911],[913,929],[931,939],[962,962],[975,977],[981,982],[984,984],[986,986],[988,988],[990,990],[992,992],[994,994],[996,996],[998,998],[1000,1000],[1002,1002],[1004,1004],[1006,1006],[1008,1009],[1012,1013],[1015,1015],[1017,1018],[1021,1071],[1120,1120],[1122,1122],[1124,1124],[1126,1126],[1128,1128],[1130,1130],[1132,1132],[1134,1134],[1136,1136],[1138,1138],[1140,1140],[1142,1142],[1144,1144],[1146,1146],[1148,1148],[1150,1150],[1152,1152],[1162,1162],[1164,1164],[1166,1166],[1168,1168],[1170,1170],[1172,1172],[1174,1174],[1176,1176],[1178,1178],[1180,1180],[1182,1182],[1184,1184],[1186,1186],[1188,1188],[1190,1190],[1192,1192],[1194,1194],[1196,1196],[1198,1198],[1200,1200],[1202,1202],[1204,1204],[1206,1206],[1208,1208],[1210,1210],[1212,1212],[1214,1214],[1216,1217],[1219,1219],[1221,1221],[1223,1223],[1225,1225],[1227,1227],[1229,1229],[1232,1232],[1234,1234],[1236,1236],[1238,1238],[1240,1240],[1242,1242],[1244,1244],[1246,1246],[1248,1248],[1250,1250],[1252,1252],[1254,1254],[1256,1256],[1258,1258],[1260,1260],[1262,1262],[1264,1264],[1266,1266],[1268,1268],[1270,1270],[1272,1272],[1274,1274],[1276,1276],[1278,1278],[1280,1280],[1282,1282],[1284,1284],[1286,1286],[1288,1288],[1290,1290],[1292,1292],[1294,1294],[1296,1296],[1298,1298],[1300,1300],[1302,1302],[1304,1304],[1306,1306],[1308,1308],[1310,1310],[1312,1312],[1314,1314],[1316,1316],[1318,1318],[1320,1320],[1322,1322],[1324,1324],[1326,1326],[1329,1366],[1415,1415],[4256,4293],[4295,4295],[4301,4301],[5112,5117],[7296,7305],[7312,7354],[7357,7359],[7680,7680],[7682,7682],[7684,7684],[7686,7686],[7688,7688],[7690,7690],[7692,7692],[7694,7694],[7696,7696],[7698,7698],[7700,7700],[7702,7702],[7704,7704],[7706,7706],[7708,7708],[7710,7710],[7712,7712],[7714,7714],[7716,7716],[7718,7718],[7720,7720],[7722,7722],[7724,7724],[7726,7726],[7728,7728],[7730,7730],[7732,7732],[7734,7734],[7736,7736],[7738,7738],[7740,7740],[7742,7742],[7744,7744],[7746,7746],[7748,7748],[7750,7750],[7752,7752],[7754,7754],[7756,7756],[7758,7758],[7760,7760],[7762,7762],[7764,7764],[7766,7766],[7768,7768],[7770,7770],[7772,7772],[7774,7774],[7776,7776],[7778,7778],[7780,7780],[7782,7782],[7784,7784],[7786,7786],[7788,7788],[7790,7790],[7792,7792],[7794,7794],[7796,7796],[7798,7798],[7800,7800],[7802,7802],[7804,7804],[7806,7806],[7808,7808],[7810,7810],[7812,7812],[7814,7814],[7816,7816],[7818,7818],[7820,7820],[7822,7822],[7824,7824],[7826,7826],[7828,7828],[7834,7835],[7838,7838],[7840,7840],[7842,7842],[7844,7844],[7846,7846],[7848,7848],[7850,7850],[7852,7852],[7854,7854],[7856,7856],[7858,7858],[7860,7860],[7862,7862],[7864,7864],[7866,7866],[7868,7868],[7870,7870],[7872,7872],[7874,7874],[7876,7876],[7878,7878],[7880,7880],[7882,7882],[7884,7884],[7886,7886],[7888,7888],[7890,7890],[7892,7892],[7894,7894],[7896,7896],[7898,7898],[7900,7900],[7902,7902],[7904,7904],[7906,7906],[7908,7908],[7910,7910],[7912,7912],[7914,7914],[7916,7916],[7918,7918],[7920,7920],[7922,7922],[7924,7924],[7926,7926],[7928,7928],[7930,7930],[7932,7932],[7934,7934],[7944,7951],[7960,7965],[7976,7983],[7992,7999],[8008,8013],[8025,8025],[8027,8027],[8029,8029],[8031,8031],[8040,8047],[8064,8111],[8114,8116],[8119,8124],[8130,8132],[8135,8140],[8152,8155],[8168,8172],[8178,8180],[8183,8188],[8486,8486],[8490,8491],[8498,8498],[8544,8559],[8579,8579],[9398,9423],[11264,11311],[11360,11360],[11362,11364],[11367,11367],[11369,11369],[11371,11371],[11373,11376],[11378,11378],[11381,11381],[11390,11392],[11394,11394],[11396,11396],[11398,11398],[11400,11400],[11402,11402],[11404,11404],[11406,11406],[11408,11408],[11410,11410],[11412,11412],[11414,11414],[11416,11416],[11418,11418],[11420,11420],[11422,11422],[11424,11424],[11426,11426],[11428,11428],[11430,11430],[11432,11432],[11434,11434],[11436,11436],[11438,11438],[11440,11440],[11442,11442],[11444,11444],[11446,11446],[11448,11448],[11450,11450],[11452,11452],[11454,11454],[11456,11456],[11458,11458],[11460,11460],[11462,11462],[11464,11464],[11466,11466],[11468,11468],[11470,11470],[11472,11472],[11474,11474],[11476,11476],[11478,11478],[11480,11480],[11482,11482],[11484,11484],[11486,11486],[11488,11488],[11490,11490],[11499,11499],[11501,11501],[11506,11506],[42560,42560],[42562,42562],[42564,42564],[42566,42566],[42568,42568],[42570,42570],[42572,42572],[42574,42574],[42576,42576],[42578,42578],[42580,42580],[42582,42582],[42584,42584],[42586,42586],[42588,42588],[42590,42590],[42592,42592],[42594,42594],[42596,42596],[42598,42598],[42600,42600],[42602,42602],[42604,42604],[42624,42624],[42626,42626],[42628,42628],[42630,42630],[42632,42632],[42634,42634],[42636,42636],[42638,42638],[42640,42640],[42642,42642],[42644,42644],[42646,42646],[42648,42648],[42650,42650],[42786,42786],[42788,42788],[42790,42790],[42792,42792],[42794,42794],[42796,42796],[42798,42798],[42802,42802],[42804,42804],[42806,42806],[42808,42808],[42810,42810],[42812,42812],[42814,42814],[42816,42816],[42818,42818],[42820,42820],[42822,42822],[42824,42824],[42826,42826],[42828,42828],[42830,42830],[42832,42832],[42834,42834],[42836,42836],[42838,42838],[42840,42840],[42842,42842],[42844,42844],[42846,42846],[42848,42848],[42850,42850],[42852,42852],[42854,42854],[42856,42856],[42858,42858],[42860,42860],[42862,42862],[42873,42873],[42875,42875],[42877,42878],[42880,42880],[42882,42882],[42884,42884],[42886,42886],[42891,42891],[42893,42893],[42896,42896],[42898,42898],[42902,42902],[42904,42904],[42906,42906],[42908,42908],[42910,42910],[42912,42912],[42914,42914],[42916,42916],[42918,42918],[42920,42920],[42922,42926],[42928,42932],[42934,42934],[42936,42936],[42938,42938],[42940,42940],[42942,42942],[42944,42944],[42946,42946],[42948,42951],[42953,42953],[42955,42956],[42960,42960],[42966,42966],[42968,42968],[42970,42970],[42972,42972],[42997,42997],[43888,43967],[64256,64262],[64275,64279],[65313,65338],[66560,66599],[66736,66771],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[68736,68786],[68944,68965],[71840,71871],[93760,93791],[125184,125217]],"Binary_Property/Unified_Ideograph":[[13312,19903],[19968,40959],[64014,64015],[64017,64017],[64019,64020],[64031,64031],[64033,64033],[64035,64036],[64039,64041],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[196608,201546],[201552,205743]],"Binary_Property/ASCII":[[0,127]],"Binary_Property/Hex_Digit":[[48,57],[65,70],[97,102],[65296,65305],[65313,65318],[65345,65350]],"Binary_Property/Other_Lowercase":[[170,170],[186,186],[688,696],[704,705],[736,740],[837,837],[890,890],[4348,4348],[7468,7530],[7544,7544],[7579,7615],[8305,8305],[8319,8319],[8336,8348],[8560,8575],[9424,9449],[11388,11389],[42652,42653],[42864,42864],[42994,42996],[43000,43001],[43868,43871],[43881,43881],[67456,67456],[67459,67461],[67463,67504],[67506,67514],[122928,122989]],"Binary_Property/Radical":[[11904,11929],[11931,12019],[12032,12245]],"Binary_Property/Modifier_Combining_Mark":[[1620,1621],[1624,1624],[1756,1756],[1763,1763],[1767,1768],[2250,2251],[2253,2255],[2259,2259],[2291,2291]],"Binary_Property/XID_Start":[[65,90],[97,122],[170,170],[181,181],[186,186],[192,214],[216,246],[248,705],[710,721],[736,740],[748,748],[750,750],[880,884],[886,887],[891,893],[895,895],[902,902],[904,906],[908,908],[910,929],[931,1013],[1015,1153],[1162,1327],[1329,1366],[1369,1369],[1376,1416],[1488,1514],[1519,1522],[1568,1610],[1646,1647],[1649,1747],[1749,1749],[1765,1766],[1774,1775],[1786,1788],[1791,1791],[1808,1808],[1810,1839],[1869,1957],[1969,1969],[1994,2026],[2036,2037],[2042,2042],[2048,2069],[2074,2074],[2084,2084],[2088,2088],[2112,2136],[2144,2154],[2160,2183],[2185,2190],[2208,2249],[2308,2361],[2365,2365],[2384,2384],[2392,2401],[2417,2432],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2493,2493],[2510,2510],[2524,2525],[2527,2529],[2544,2545],[2556,2556],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2649,2652],[2654,2654],[2674,2676],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2749,2749],[2768,2768],[2784,2785],[2809,2809],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2877,2877],[2908,2909],[2911,2913],[2929,2929],[2947,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3024,3024],[3077,3084],[3086,3088],[3090,3112],[3114,3129],[3133,3133],[3160,3162],[3165,3165],[3168,3169],[3200,3200],[3205,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3261,3261],[3293,3294],[3296,3297],[3313,3314],[3332,3340],[3342,3344],[3346,3386],[3389,3389],[3406,3406],[3412,3414],[3423,3425],[3450,3455],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3585,3632],[3634,3634],[3648,3654],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3760],[3762,3762],[3773,3773],[3776,3780],[3782,3782],[3804,3807],[3840,3840],[3904,3911],[3913,3948],[3976,3980],[4096,4138],[4159,4159],[4176,4181],[4186,4189],[4193,4193],[4197,4198],[4206,4208],[4213,4225],[4238,4238],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4348,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4992,5007],[5024,5109],[5112,5117],[5121,5740],[5743,5759],[5761,5786],[5792,5866],[5870,5880],[5888,5905],[5919,5937],[5952,5969],[5984,5996],[5998,6000],[6016,6067],[6103,6103],[6108,6108],[6176,6264],[6272,6312],[6314,6314],[6320,6389],[6400,6430],[6480,6509],[6512,6516],[6528,6571],[6576,6601],[6656,6678],[6688,6740],[6823,6823],[6917,6963],[6981,6988],[7043,7072],[7086,7087],[7098,7141],[7168,7203],[7245,7247],[7258,7293],[7296,7306],[7312,7354],[7357,7359],[7401,7404],[7406,7411],[7413,7414],[7418,7418],[7424,7615],[7680,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8305,8305],[8319,8319],[8336,8348],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8472,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8505],[8508,8511],[8517,8521],[8526,8526],[8544,8584],[11264,11492],[11499,11502],[11506,11507],[11520,11557],[11559,11559],[11565,11565],[11568,11623],[11631,11631],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[12293,12295],[12321,12329],[12337,12341],[12344,12348],[12353,12438],[12445,12447],[12449,12538],[12540,12543],[12549,12591],[12593,12686],[12704,12735],[12784,12799],[13312,19903],[19968,42124],[42192,42237],[42240,42508],[42512,42527],[42538,42539],[42560,42606],[42623,42653],[42656,42735],[42775,42783],[42786,42888],[42891,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43009],[43011,43013],[43015,43018],[43020,43042],[43072,43123],[43138,43187],[43250,43255],[43259,43259],[43261,43262],[43274,43301],[43312,43334],[43360,43388],[43396,43442],[43471,43471],[43488,43492],[43494,43503],[43514,43518],[43520,43560],[43584,43586],[43588,43595],[43616,43638],[43642,43642],[43646,43695],[43697,43697],[43701,43702],[43705,43709],[43712,43712],[43714,43714],[43739,43741],[43744,43754],[43762,43764],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43866],[43868,43881],[43888,44002],[44032,55203],[55216,55238],[55243,55291],[63744,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64285],[64287,64296],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64605],[64612,64829],[64848,64911],[64914,64967],[65008,65017],[65137,65137],[65139,65139],[65143,65143],[65145,65145],[65147,65147],[65149,65149],[65151,65276],[65313,65338],[65345,65370],[65382,65437],[65440,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65856,65908],[66176,66204],[66208,66256],[66304,66335],[66349,66378],[66384,66421],[66432,66461],[66464,66499],[66504,66511],[66513,66517],[66560,66717],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67680,67702],[67712,67742],[67808,67826],[67828,67829],[67840,67861],[67872,67897],[67968,68023],[68030,68031],[68096,68096],[68112,68115],[68117,68119],[68121,68149],[68192,68220],[68224,68252],[68288,68295],[68297,68324],[68352,68405],[68416,68437],[68448,68466],[68480,68497],[68608,68680],[68736,68786],[68800,68850],[68864,68899],[68938,68965],[68975,68997],[69248,69289],[69296,69297],[69314,69316],[69376,69404],[69415,69415],[69424,69445],[69488,69505],[69552,69572],[69600,69622],[69635,69687],[69745,69746],[69749,69749],[69763,69807],[69840,69864],[69891,69926],[69956,69956],[69959,69959],[69968,70002],[70006,70006],[70019,70066],[70081,70084],[70106,70106],[70108,70108],[70144,70161],[70163,70187],[70207,70208],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70312],[70320,70366],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70461,70461],[70480,70480],[70493,70497],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70583],[70609,70609],[70611,70611],[70656,70708],[70727,70730],[70751,70753],[70784,70831],[70852,70853],[70855,70855],[71040,71086],[71128,71131],[71168,71215],[71236,71236],[71296,71338],[71352,71352],[71424,71450],[71488,71494],[71680,71723],[71840,71903],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71983],[71999,71999],[72001,72001],[72096,72103],[72106,72144],[72161,72161],[72163,72163],[72192,72192],[72203,72242],[72250,72250],[72272,72272],[72284,72329],[72349,72349],[72368,72440],[72640,72672],[72704,72712],[72714,72750],[72768,72768],[72818,72847],[72960,72966],[72968,72969],[72971,73008],[73030,73030],[73056,73061],[73063,73064],[73066,73097],[73112,73112],[73440,73458],[73474,73474],[73476,73488],[73490,73523],[73648,73648],[73728,74649],[74752,74862],[74880,75075],[77712,77808],[77824,78895],[78913,78918],[78944,82938],[82944,83526],[90368,90397],[92160,92728],[92736,92766],[92784,92862],[92880,92909],[92928,92975],[92992,92995],[93027,93047],[93053,93071],[93504,93548],[93760,93823],[93952,94026],[94032,94032],[94099,94111],[94176,94177],[94179,94179],[94208,100343],[100352,101589],[101631,101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[122624,122654],[122661,122666],[122928,122989],[123136,123180],[123191,123197],[123214,123214],[123536,123565],[123584,123627],[124112,124139],[124368,124397],[124400,124400],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125184,125251],[125259,125259],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"Binary_Property/Emoji_Modifier_Base":[[9757,9757],[9977,9977],[9994,9997],[127877,127877],[127938,127940],[127943,127943],[127946,127948],[128066,128067],[128070,128080],[128102,128120],[128124,128124],[128129,128131],[128133,128135],[128143,128143],[128145,128145],[128170,128170],[128372,128373],[128378,128378],[128400,128400],[128405,128406],[128581,128583],[128587,128591],[128675,128675],[128692,128694],[128704,128704],[128716,128716],[129292,129292],[129295,129295],[129304,129311],[129318,129318],[129328,129337],[129340,129342],[129399,129399],[129461,129462],[129464,129465],[129467,129467],[129485,129487],[129489,129501],[129731,129733],[129776,129784]],"Binary_Property/Uppercase":[[65,90],[192,214],[216,222],[256,256],[258,258],[260,260],[262,262],[264,264],[266,266],[268,268],[270,270],[272,272],[274,274],[276,276],[278,278],[280,280],[282,282],[284,284],[286,286],[288,288],[290,290],[292,292],[294,294],[296,296],[298,298],[300,300],[302,302],[304,304],[306,306],[308,308],[310,310],[313,313],[315,315],[317,317],[319,319],[321,321],[323,323],[325,325],[327,327],[330,330],[332,332],[334,334],[336,336],[338,338],[340,340],[342,342],[344,344],[346,346],[348,348],[350,350],[352,352],[354,354],[356,356],[358,358],[360,360],[362,362],[364,364],[366,366],[368,368],[370,370],[372,372],[374,374],[376,377],[379,379],[381,381],[385,386],[388,388],[390,391],[393,395],[398,401],[403,404],[406,408],[412,413],[415,416],[418,418],[420,420],[422,423],[425,425],[428,428],[430,431],[433,435],[437,437],[439,440],[444,444],[452,452],[455,455],[458,458],[461,461],[463,463],[465,465],[467,467],[469,469],[471,471],[473,473],[475,475],[478,478],[480,480],[482,482],[484,484],[486,486],[488,488],[490,490],[492,492],[494,494],[497,497],[500,500],[502,504],[506,506],[508,508],[510,510],[512,512],[514,514],[516,516],[518,518],[520,520],[522,522],[524,524],[526,526],[528,528],[530,530],[532,532],[534,534],[536,536],[538,538],[540,540],[542,542],[544,544],[546,546],[548,548],[550,550],[552,552],[554,554],[556,556],[558,558],[560,560],[562,562],[570,571],[573,574],[577,577],[579,582],[584,584],[586,586],[588,588],[590,590],[880,880],[882,882],[886,886],[895,895],[902,902],[904,906],[908,908],[910,911],[913,929],[931,939],[975,975],[978,980],[984,984],[986,986],[988,988],[990,990],[992,992],[994,994],[996,996],[998,998],[1000,1000],[1002,1002],[1004,1004],[1006,1006],[1012,1012],[1015,1015],[1017,1018],[1021,1071],[1120,1120],[1122,1122],[1124,1124],[1126,1126],[1128,1128],[1130,1130],[1132,1132],[1134,1134],[1136,1136],[1138,1138],[1140,1140],[1142,1142],[1144,1144],[1146,1146],[1148,1148],[1150,1150],[1152,1152],[1162,1162],[1164,1164],[1166,1166],[1168,1168],[1170,1170],[1172,1172],[1174,1174],[1176,1176],[1178,1178],[1180,1180],[1182,1182],[1184,1184],[1186,1186],[1188,1188],[1190,1190],[1192,1192],[1194,1194],[1196,1196],[1198,1198],[1200,1200],[1202,1202],[1204,1204],[1206,1206],[1208,1208],[1210,1210],[1212,1212],[1214,1214],[1216,1217],[1219,1219],[1221,1221],[1223,1223],[1225,1225],[1227,1227],[1229,1229],[1232,1232],[1234,1234],[1236,1236],[1238,1238],[1240,1240],[1242,1242],[1244,1244],[1246,1246],[1248,1248],[1250,1250],[1252,1252],[1254,1254],[1256,1256],[1258,1258],[1260,1260],[1262,1262],[1264,1264],[1266,1266],[1268,1268],[1270,1270],[1272,1272],[1274,1274],[1276,1276],[1278,1278],[1280,1280],[1282,1282],[1284,1284],[1286,1286],[1288,1288],[1290,1290],[1292,1292],[1294,1294],[1296,1296],[1298,1298],[1300,1300],[1302,1302],[1304,1304],[1306,1306],[1308,1308],[1310,1310],[1312,1312],[1314,1314],[1316,1316],[1318,1318],[1320,1320],[1322,1322],[1324,1324],[1326,1326],[1329,1366],[4256,4293],[4295,4295],[4301,4301],[5024,5109],[7305,7305],[7312,7354],[7357,7359],[7680,7680],[7682,7682],[7684,7684],[7686,7686],[7688,7688],[7690,7690],[7692,7692],[7694,7694],[7696,7696],[7698,7698],[7700,7700],[7702,7702],[7704,7704],[7706,7706],[7708,7708],[7710,7710],[7712,7712],[7714,7714],[7716,7716],[7718,7718],[7720,7720],[7722,7722],[7724,7724],[7726,7726],[7728,7728],[7730,7730],[7732,7732],[7734,7734],[7736,7736],[7738,7738],[7740,7740],[7742,7742],[7744,7744],[7746,7746],[7748,7748],[7750,7750],[7752,7752],[7754,7754],[7756,7756],[7758,7758],[7760,7760],[7762,7762],[7764,7764],[7766,7766],[7768,7768],[7770,7770],[7772,7772],[7774,7774],[7776,7776],[7778,7778],[7780,7780],[7782,7782],[7784,7784],[7786,7786],[7788,7788],[7790,7790],[7792,7792],[7794,7794],[7796,7796],[7798,7798],[7800,7800],[7802,7802],[7804,7804],[7806,7806],[7808,7808],[7810,7810],[7812,7812],[7814,7814],[7816,7816],[7818,7818],[7820,7820],[7822,7822],[7824,7824],[7826,7826],[7828,7828],[7838,7838],[7840,7840],[7842,7842],[7844,7844],[7846,7846],[7848,7848],[7850,7850],[7852,7852],[7854,7854],[7856,7856],[7858,7858],[7860,7860],[7862,7862],[7864,7864],[7866,7866],[7868,7868],[7870,7870],[7872,7872],[7874,7874],[7876,7876],[7878,7878],[7880,7880],[7882,7882],[7884,7884],[7886,7886],[7888,7888],[7890,7890],[7892,7892],[7894,7894],[7896,7896],[7898,7898],[7900,7900],[7902,7902],[7904,7904],[7906,7906],[7908,7908],[7910,7910],[7912,7912],[7914,7914],[7916,7916],[7918,7918],[7920,7920],[7922,7922],[7924,7924],[7926,7926],[7928,7928],[7930,7930],[7932,7932],[7934,7934],[7944,7951],[7960,7965],[7976,7983],[7992,7999],[8008,8013],[8025,8025],[8027,8027],[8029,8029],[8031,8031],[8040,8047],[8120,8123],[8136,8139],[8152,8155],[8168,8172],[8184,8187],[8450,8450],[8455,8455],[8459,8461],[8464,8466],[8469,8469],[8473,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8493],[8496,8499],[8510,8511],[8517,8517],[8544,8559],[8579,8579],[9398,9423],[11264,11311],[11360,11360],[11362,11364],[11367,11367],[11369,11369],[11371,11371],[11373,11376],[11378,11378],[11381,11381],[11390,11392],[11394,11394],[11396,11396],[11398,11398],[11400,11400],[11402,11402],[11404,11404],[11406,11406],[11408,11408],[11410,11410],[11412,11412],[11414,11414],[11416,11416],[11418,11418],[11420,11420],[11422,11422],[11424,11424],[11426,11426],[11428,11428],[11430,11430],[11432,11432],[11434,11434],[11436,11436],[11438,11438],[11440,11440],[11442,11442],[11444,11444],[11446,11446],[11448,11448],[11450,11450],[11452,11452],[11454,11454],[11456,11456],[11458,11458],[11460,11460],[11462,11462],[11464,11464],[11466,11466],[11468,11468],[11470,11470],[11472,11472],[11474,11474],[11476,11476],[11478,11478],[11480,11480],[11482,11482],[11484,11484],[11486,11486],[11488,11488],[11490,11490],[11499,11499],[11501,11501],[11506,11506],[42560,42560],[42562,42562],[42564,42564],[42566,42566],[42568,42568],[42570,42570],[42572,42572],[42574,42574],[42576,42576],[42578,42578],[42580,42580],[42582,42582],[42584,42584],[42586,42586],[42588,42588],[42590,42590],[42592,42592],[42594,42594],[42596,42596],[42598,42598],[42600,42600],[42602,42602],[42604,42604],[42624,42624],[42626,42626],[42628,42628],[42630,42630],[42632,42632],[42634,42634],[42636,42636],[42638,42638],[42640,42640],[42642,42642],[42644,42644],[42646,42646],[42648,42648],[42650,42650],[42786,42786],[42788,42788],[42790,42790],[42792,42792],[42794,42794],[42796,42796],[42798,42798],[42802,42802],[42804,42804],[42806,42806],[42808,42808],[42810,42810],[42812,42812],[42814,42814],[42816,42816],[42818,42818],[42820,42820],[42822,42822],[42824,42824],[42826,42826],[42828,42828],[42830,42830],[42832,42832],[42834,42834],[42836,42836],[42838,42838],[42840,42840],[42842,42842],[42844,42844],[42846,42846],[42848,42848],[42850,42850],[42852,42852],[42854,42854],[42856,42856],[42858,42858],[42860,42860],[42862,42862],[42873,42873],[42875,42875],[42877,42878],[42880,42880],[42882,42882],[42884,42884],[42886,42886],[42891,42891],[42893,42893],[42896,42896],[42898,42898],[42902,42902],[42904,42904],[42906,42906],[42908,42908],[42910,42910],[42912,42912],[42914,42914],[42916,42916],[42918,42918],[42920,42920],[42922,42926],[42928,42932],[42934,42934],[42936,42936],[42938,42938],[42940,42940],[42942,42942],[42944,42944],[42946,42946],[42948,42951],[42953,42953],[42955,42956],[42960,42960],[42966,42966],[42968,42968],[42970,42970],[42972,42972],[42997,42997],[65313,65338],[66560,66599],[66736,66771],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[68736,68786],[68944,68965],[71840,71871],[93760,93791],[119808,119833],[119860,119885],[119912,119937],[119964,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119989],[120016,120041],[120068,120069],[120071,120074],[120077,120084],[120086,120092],[120120,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120172,120197],[120224,120249],[120276,120301],[120328,120353],[120380,120405],[120432,120457],[120488,120512],[120546,120570],[120604,120628],[120662,120686],[120720,120744],[120778,120778],[125184,125217],[127280,127305],[127312,127337],[127344,127369]],"Binary_Property/Changes_When_Lowercased":[[65,90],[192,214],[216,222],[256,256],[258,258],[260,260],[262,262],[264,264],[266,266],[268,268],[270,270],[272,272],[274,274],[276,276],[278,278],[280,280],[282,282],[284,284],[286,286],[288,288],[290,290],[292,292],[294,294],[296,296],[298,298],[300,300],[302,302],[304,304],[306,306],[308,308],[310,310],[313,313],[315,315],[317,317],[319,319],[321,321],[323,323],[325,325],[327,327],[330,330],[332,332],[334,334],[336,336],[338,338],[340,340],[342,342],[344,344],[346,346],[348,348],[350,350],[352,352],[354,354],[356,356],[358,358],[360,360],[362,362],[364,364],[366,366],[368,368],[370,370],[372,372],[374,374],[376,377],[379,379],[381,381],[385,386],[388,388],[390,391],[393,395],[398,401],[403,404],[406,408],[412,413],[415,416],[418,418],[420,420],[422,423],[425,425],[428,428],[430,431],[433,435],[437,437],[439,440],[444,444],[452,453],[455,456],[458,459],[461,461],[463,463],[465,465],[467,467],[469,469],[471,471],[473,473],[475,475],[478,478],[480,480],[482,482],[484,484],[486,486],[488,488],[490,490],[492,492],[494,494],[497,498],[500,500],[502,504],[506,506],[508,508],[510,510],[512,512],[514,514],[516,516],[518,518],[520,520],[522,522],[524,524],[526,526],[528,528],[530,530],[532,532],[534,534],[536,536],[538,538],[540,540],[542,542],[544,544],[546,546],[548,548],[550,550],[552,552],[554,554],[556,556],[558,558],[560,560],[562,562],[570,571],[573,574],[577,577],[579,582],[584,584],[586,586],[588,588],[590,590],[880,880],[882,882],[886,886],[895,895],[902,902],[904,906],[908,908],[910,911],[913,929],[931,939],[975,975],[984,984],[986,986],[988,988],[990,990],[992,992],[994,994],[996,996],[998,998],[1000,1000],[1002,1002],[1004,1004],[1006,1006],[1012,1012],[1015,1015],[1017,1018],[1021,1071],[1120,1120],[1122,1122],[1124,1124],[1126,1126],[1128,1128],[1130,1130],[1132,1132],[1134,1134],[1136,1136],[1138,1138],[1140,1140],[1142,1142],[1144,1144],[1146,1146],[1148,1148],[1150,1150],[1152,1152],[1162,1162],[1164,1164],[1166,1166],[1168,1168],[1170,1170],[1172,1172],[1174,1174],[1176,1176],[1178,1178],[1180,1180],[1182,1182],[1184,1184],[1186,1186],[1188,1188],[1190,1190],[1192,1192],[1194,1194],[1196,1196],[1198,1198],[1200,1200],[1202,1202],[1204,1204],[1206,1206],[1208,1208],[1210,1210],[1212,1212],[1214,1214],[1216,1217],[1219,1219],[1221,1221],[1223,1223],[1225,1225],[1227,1227],[1229,1229],[1232,1232],[1234,1234],[1236,1236],[1238,1238],[1240,1240],[1242,1242],[1244,1244],[1246,1246],[1248,1248],[1250,1250],[1252,1252],[1254,1254],[1256,1256],[1258,1258],[1260,1260],[1262,1262],[1264,1264],[1266,1266],[1268,1268],[1270,1270],[1272,1272],[1274,1274],[1276,1276],[1278,1278],[1280,1280],[1282,1282],[1284,1284],[1286,1286],[1288,1288],[1290,1290],[1292,1292],[1294,1294],[1296,1296],[1298,1298],[1300,1300],[1302,1302],[1304,1304],[1306,1306],[1308,1308],[1310,1310],[1312,1312],[1314,1314],[1316,1316],[1318,1318],[1320,1320],[1322,1322],[1324,1324],[1326,1326],[1329,1366],[4256,4293],[4295,4295],[4301,4301],[5024,5109],[7305,7305],[7312,7354],[7357,7359],[7680,7680],[7682,7682],[7684,7684],[7686,7686],[7688,7688],[7690,7690],[7692,7692],[7694,7694],[7696,7696],[7698,7698],[7700,7700],[7702,7702],[7704,7704],[7706,7706],[7708,7708],[7710,7710],[7712,7712],[7714,7714],[7716,7716],[7718,7718],[7720,7720],[7722,7722],[7724,7724],[7726,7726],[7728,7728],[7730,7730],[7732,7732],[7734,7734],[7736,7736],[7738,7738],[7740,7740],[7742,7742],[7744,7744],[7746,7746],[7748,7748],[7750,7750],[7752,7752],[7754,7754],[7756,7756],[7758,7758],[7760,7760],[7762,7762],[7764,7764],[7766,7766],[7768,7768],[7770,7770],[7772,7772],[7774,7774],[7776,7776],[7778,7778],[7780,7780],[7782,7782],[7784,7784],[7786,7786],[7788,7788],[7790,7790],[7792,7792],[7794,7794],[7796,7796],[7798,7798],[7800,7800],[7802,7802],[7804,7804],[7806,7806],[7808,7808],[7810,7810],[7812,7812],[7814,7814],[7816,7816],[7818,7818],[7820,7820],[7822,7822],[7824,7824],[7826,7826],[7828,7828],[7838,7838],[7840,7840],[7842,7842],[7844,7844],[7846,7846],[7848,7848],[7850,7850],[7852,7852],[7854,7854],[7856,7856],[7858,7858],[7860,7860],[7862,7862],[7864,7864],[7866,7866],[7868,7868],[7870,7870],[7872,7872],[7874,7874],[7876,7876],[7878,7878],[7880,7880],[7882,7882],[7884,7884],[7886,7886],[7888,7888],[7890,7890],[7892,7892],[7894,7894],[7896,7896],[7898,7898],[7900,7900],[7902,7902],[7904,7904],[7906,7906],[7908,7908],[7910,7910],[7912,7912],[7914,7914],[7916,7916],[7918,7918],[7920,7920],[7922,7922],[7924,7924],[7926,7926],[7928,7928],[7930,7930],[7932,7932],[7934,7934],[7944,7951],[7960,7965],[7976,7983],[7992,7999],[8008,8013],[8025,8025],[8027,8027],[8029,8029],[8031,8031],[8040,8047],[8072,8079],[8088,8095],[8104,8111],[8120,8124],[8136,8140],[8152,8155],[8168,8172],[8184,8188],[8486,8486],[8490,8491],[8498,8498],[8544,8559],[8579,8579],[9398,9423],[11264,11311],[11360,11360],[11362,11364],[11367,11367],[11369,11369],[11371,11371],[11373,11376],[11378,11378],[11381,11381],[11390,11392],[11394,11394],[11396,11396],[11398,11398],[11400,11400],[11402,11402],[11404,11404],[11406,11406],[11408,11408],[11410,11410],[11412,11412],[11414,11414],[11416,11416],[11418,11418],[11420,11420],[11422,11422],[11424,11424],[11426,11426],[11428,11428],[11430,11430],[11432,11432],[11434,11434],[11436,11436],[11438,11438],[11440,11440],[11442,11442],[11444,11444],[11446,11446],[11448,11448],[11450,11450],[11452,11452],[11454,11454],[11456,11456],[11458,11458],[11460,11460],[11462,11462],[11464,11464],[11466,11466],[11468,11468],[11470,11470],[11472,11472],[11474,11474],[11476,11476],[11478,11478],[11480,11480],[11482,11482],[11484,11484],[11486,11486],[11488,11488],[11490,11490],[11499,11499],[11501,11501],[11506,11506],[42560,42560],[42562,42562],[42564,42564],[42566,42566],[42568,42568],[42570,42570],[42572,42572],[42574,42574],[42576,42576],[42578,42578],[42580,42580],[42582,42582],[42584,42584],[42586,42586],[42588,42588],[42590,42590],[42592,42592],[42594,42594],[42596,42596],[42598,42598],[42600,42600],[42602,42602],[42604,42604],[42624,42624],[42626,42626],[42628,42628],[42630,42630],[42632,42632],[42634,42634],[42636,42636],[42638,42638],[42640,42640],[42642,42642],[42644,42644],[42646,42646],[42648,42648],[42650,42650],[42786,42786],[42788,42788],[42790,42790],[42792,42792],[42794,42794],[42796,42796],[42798,42798],[42802,42802],[42804,42804],[42806,42806],[42808,42808],[42810,42810],[42812,42812],[42814,42814],[42816,42816],[42818,42818],[42820,42820],[42822,42822],[42824,42824],[42826,42826],[42828,42828],[42830,42830],[42832,42832],[42834,42834],[42836,42836],[42838,42838],[42840,42840],[42842,42842],[42844,42844],[42846,42846],[42848,42848],[42850,42850],[42852,42852],[42854,42854],[42856,42856],[42858,42858],[42860,42860],[42862,42862],[42873,42873],[42875,42875],[42877,42878],[42880,42880],[42882,42882],[42884,42884],[42886,42886],[42891,42891],[42893,42893],[42896,42896],[42898,42898],[42902,42902],[42904,42904],[42906,42906],[42908,42908],[42910,42910],[42912,42912],[42914,42914],[42916,42916],[42918,42918],[42920,42920],[42922,42926],[42928,42932],[42934,42934],[42936,42936],[42938,42938],[42940,42940],[42942,42942],[42944,42944],[42946,42946],[42948,42951],[42953,42953],[42955,42956],[42960,42960],[42966,42966],[42968,42968],[42970,42970],[42972,42972],[42997,42997],[65313,65338],[66560,66599],[66736,66771],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[68736,68786],[68944,68965],[71840,71871],[93760,93791],[125184,125217]],"Binary_Property/Join_Control":[[8204,8205]],"Binary_Property/Emoji_Component":[[35,35],[42,42],[48,57],[8205,8205],[8419,8419],[65039,65039],[127462,127487],[127995,127999],[129456,129459],[917536,917631]],"Binary_Property/Grapheme_Extend":[[768,879],[1155,1161],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1552,1562],[1611,1631],[1648,1648],[1750,1756],[1759,1764],[1767,1768],[1770,1773],[1809,1809],[1840,1866],[1958,1968],[2027,2035],[2045,2045],[2070,2073],[2075,2083],[2085,2087],[2089,2093],[2137,2139],[2199,2207],[2250,2273],[2275,2306],[2362,2362],[2364,2364],[2369,2376],[2381,2381],[2385,2391],[2402,2403],[2433,2433],[2492,2492],[2494,2494],[2497,2500],[2509,2509],[2519,2519],[2530,2531],[2558,2558],[2561,2562],[2620,2620],[2625,2626],[2631,2632],[2635,2637],[2641,2641],[2672,2673],[2677,2677],[2689,2690],[2748,2748],[2753,2757],[2759,2760],[2765,2765],[2786,2787],[2810,2815],[2817,2817],[2876,2876],[2878,2879],[2881,2884],[2893,2893],[2901,2903],[2914,2915],[2946,2946],[3006,3006],[3008,3008],[3021,3021],[3031,3031],[3072,3072],[3076,3076],[3132,3132],[3134,3136],[3142,3144],[3146,3149],[3157,3158],[3170,3171],[3201,3201],[3260,3260],[3263,3264],[3266,3266],[3270,3272],[3274,3277],[3285,3286],[3298,3299],[3328,3329],[3387,3388],[3390,3390],[3393,3396],[3405,3405],[3415,3415],[3426,3427],[3457,3457],[3530,3530],[3535,3535],[3538,3540],[3542,3542],[3551,3551],[3633,3633],[3636,3642],[3655,3662],[3761,3761],[3764,3772],[3784,3790],[3864,3865],[3893,3893],[3895,3895],[3897,3897],[3953,3966],[3968,3972],[3974,3975],[3981,3991],[3993,4028],[4038,4038],[4141,4144],[4146,4151],[4153,4154],[4157,4158],[4184,4185],[4190,4192],[4209,4212],[4226,4226],[4229,4230],[4237,4237],[4253,4253],[4957,4959],[5906,5909],[5938,5940],[5970,5971],[6002,6003],[6068,6069],[6071,6077],[6086,6086],[6089,6099],[6109,6109],[6155,6157],[6159,6159],[6277,6278],[6313,6313],[6432,6434],[6439,6440],[6450,6450],[6457,6459],[6679,6680],[6683,6683],[6742,6742],[6744,6750],[6752,6752],[6754,6754],[6757,6764],[6771,6780],[6783,6783],[6832,6862],[6912,6915],[6964,6973],[6978,6980],[7019,7027],[7040,7041],[7074,7077],[7080,7085],[7142,7142],[7144,7145],[7149,7149],[7151,7155],[7212,7219],[7222,7223],[7376,7378],[7380,7392],[7394,7400],[7405,7405],[7412,7412],[7416,7417],[7616,7679],[8204,8204],[8400,8432],[11503,11505],[11647,11647],[11744,11775],[12330,12335],[12441,12442],[42607,42610],[42612,42621],[42654,42655],[42736,42737],[43010,43010],[43014,43014],[43019,43019],[43045,43046],[43052,43052],[43204,43205],[43232,43249],[43263,43263],[43302,43309],[43335,43345],[43347,43347],[43392,43394],[43443,43443],[43446,43449],[43452,43453],[43456,43456],[43493,43493],[43561,43566],[43569,43570],[43573,43574],[43587,43587],[43596,43596],[43644,43644],[43696,43696],[43698,43700],[43703,43704],[43710,43711],[43713,43713],[43756,43757],[43766,43766],[44005,44005],[44008,44008],[44013,44013],[64286,64286],[65024,65039],[65056,65071],[65438,65439],[66045,66045],[66272,66272],[66422,66426],[68097,68099],[68101,68102],[68108,68111],[68152,68154],[68159,68159],[68325,68326],[68900,68903],[68969,68973],[69291,69292],[69372,69375],[69446,69456],[69506,69509],[69633,69633],[69688,69702],[69744,69744],[69747,69748],[69759,69761],[69811,69814],[69817,69818],[69826,69826],[69888,69890],[69927,69931],[69933,69940],[70003,70003],[70016,70017],[70070,70078],[70080,70080],[70089,70092],[70095,70095],[70191,70193],[70196,70199],[70206,70206],[70209,70209],[70367,70367],[70371,70378],[70400,70401],[70459,70460],[70462,70462],[70464,70464],[70477,70477],[70487,70487],[70502,70508],[70512,70516],[70584,70584],[70587,70592],[70594,70594],[70597,70597],[70599,70601],[70606,70608],[70610,70610],[70625,70626],[70712,70719],[70722,70724],[70726,70726],[70750,70750],[70832,70832],[70835,70840],[70842,70842],[70845,70845],[70847,70848],[70850,70851],[71087,71087],[71090,71093],[71100,71101],[71103,71104],[71132,71133],[71219,71226],[71229,71229],[71231,71232],[71339,71339],[71341,71341],[71344,71351],[71453,71453],[71455,71455],[71458,71461],[71463,71467],[71727,71735],[71737,71738],[71984,71984],[71995,71998],[72003,72003],[72148,72151],[72154,72155],[72160,72160],[72193,72202],[72243,72248],[72251,72254],[72263,72263],[72273,72278],[72281,72283],[72330,72342],[72344,72345],[72752,72758],[72760,72765],[72767,72767],[72850,72871],[72874,72880],[72882,72883],[72885,72886],[73009,73014],[73018,73018],[73020,73021],[73023,73029],[73031,73031],[73104,73105],[73109,73109],[73111,73111],[73459,73460],[73472,73473],[73526,73530],[73536,73538],[73562,73562],[78912,78912],[78919,78933],[90398,90409],[90413,90415],[92912,92916],[92976,92982],[94031,94031],[94095,94098],[94180,94180],[94192,94193],[113821,113822],[118528,118573],[118576,118598],[119141,119145],[119149,119154],[119163,119170],[119173,119179],[119210,119213],[119362,119364],[121344,121398],[121403,121452],[121461,121461],[121476,121476],[121499,121503],[121505,121519],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[123023,123023],[123184,123190],[123566,123566],[123628,123631],[124140,124143],[124398,124399],[125136,125142],[125252,125258],[917536,917631],[917760,917999]],"Binary_Property/Bidi_Control":[[1564,1564],[8206,8207],[8234,8238],[8294,8297]],"Binary_Property/Sentence_Terminal":[[33,33],[46,46],[63,63],[1417,1417],[1565,1567],[1748,1748],[1792,1794],[2041,2041],[2103,2103],[2105,2105],[2109,2110],[2404,2405],[4170,4171],[4962,4962],[4967,4968],[5742,5742],[5941,5942],[6100,6101],[6147,6147],[6153,6153],[6468,6469],[6824,6827],[6990,6991],[7002,7003],[7006,7007],[7037,7039],[7227,7228],[7294,7295],[8228,8228],[8252,8253],[8263,8265],[11513,11515],[11822,11822],[11836,11836],[11859,11860],[12290,12290],[42239,42239],[42510,42511],[42739,42739],[42743,42743],[43126,43127],[43214,43215],[43311,43311],[43464,43465],[43613,43615],[43760,43761],[44011,44011],[65042,65042],[65045,65046],[65106,65106],[65110,65111],[65281,65281],[65294,65294],[65311,65311],[65377,65377],[68182,68183],[69461,69465],[69510,69513],[69703,69704],[69822,69825],[69953,69955],[70085,70086],[70093,70093],[70110,70111],[70200,70201],[70203,70204],[70313,70313],[70612,70613],[70731,70732],[71106,71107],[71113,71127],[71233,71234],[71484,71486],[72004,72004],[72006,72006],[72258,72259],[72347,72348],[72769,72770],[73463,73464],[73539,73540],[92782,92783],[92917,92917],[92983,92984],[92996,92996],[93550,93551],[93848,93848],[113823,113823],[121480,121480]],"Binary_Property/Emoji":[[35,35],[42,42],[48,57],[169,169],[174,174],[8252,8252],[8265,8265],[8482,8482],[8505,8505],[8596,8601],[8617,8618],[8986,8987],[9000,9000],[9167,9167],[9193,9203],[9208,9210],[9410,9410],[9642,9643],[9654,9654],[9664,9664],[9723,9726],[9728,9732],[9742,9742],[9745,9745],[9748,9749],[9752,9752],[9757,9757],[9760,9760],[9762,9763],[9766,9766],[9770,9770],[9774,9775],[9784,9786],[9792,9792],[9794,9794],[9800,9811],[9823,9824],[9827,9827],[9829,9830],[9832,9832],[9851,9851],[9854,9855],[9874,9879],[9881,9881],[9883,9884],[9888,9889],[9895,9895],[9898,9899],[9904,9905],[9917,9918],[9924,9925],[9928,9928],[9934,9935],[9937,9937],[9939,9940],[9961,9962],[9968,9973],[9975,9978],[9981,9981],[9986,9986],[9989,9989],[9992,9997],[9999,9999],[10002,10002],[10004,10004],[10006,10006],[10013,10013],[10017,10017],[10024,10024],[10035,10036],[10052,10052],[10055,10055],[10060,10060],[10062,10062],[10067,10069],[10071,10071],[10083,10084],[10133,10135],[10145,10145],[10160,10160],[10175,10175],[10548,10549],[11013,11015],[11035,11036],[11088,11088],[11093,11093],[12336,12336],[12349,12349],[12951,12951],[12953,12953],[126980,126980],[127183,127183],[127344,127345],[127358,127359],[127374,127374],[127377,127386],[127462,127487],[127489,127490],[127514,127514],[127535,127535],[127538,127546],[127568,127569],[127744,127777],[127780,127891],[127894,127895],[127897,127899],[127902,127984],[127987,127989],[127991,128253],[128255,128317],[128329,128334],[128336,128359],[128367,128368],[128371,128378],[128391,128391],[128394,128397],[128400,128400],[128405,128406],[128420,128421],[128424,128424],[128433,128434],[128444,128444],[128450,128452],[128465,128467],[128476,128478],[128481,128481],[128483,128483],[128488,128488],[128495,128495],[128499,128499],[128506,128591],[128640,128709],[128715,128722],[128725,128727],[128732,128741],[128745,128745],[128747,128748],[128752,128752],[128755,128764],[128992,129003],[129008,129008],[129292,129338],[129340,129349],[129351,129535],[129648,129660],[129664,129673],[129679,129734],[129742,129756],[129759,129769],[129776,129784]],"Binary_Property/Ideographic":[[12294,12295],[12321,12329],[12344,12346],[13312,19903],[19968,40959],[63744,64109],[64112,64217],[94180,94180],[94208,100343],[100352,101589],[101631,101640],[110960,111355],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"Binary_Property/Extender":[[183,183],[720,721],[1600,1600],[2042,2042],[2673,2673],[2811,2811],[2901,2901],[3654,3654],[3782,3782],[6154,6154],[6211,6211],[6823,6823],[7222,7222],[7291,7291],[12293,12293],[12337,12341],[12445,12446],[12540,12542],[40981,40981],[42508,42508],[43471,43471],[43494,43494],[43632,43632],[43741,43741],[43763,43764],[65392,65392],[67457,67458],[68942,68942],[68970,68970],[68975,68975],[70199,70199],[70493,70493],[70610,70611],[71110,71112],[72344,72344],[92994,92995],[94176,94177],[94179,94179],[123196,123197],[124399,124399],[125252,125254]],"Binary_Property/ID_Compat_Math_Continue":[[178,179],[185,185],[8304,8304],[8308,8318],[8320,8334],[8706,8706],[8711,8711],[8734,8734],[120513,120513],[120539,120539],[120571,120571],[120597,120597],[120629,120629],[120655,120655],[120687,120687],[120713,120713],[120745,120745],[120771,120771]],"Binary_Property/Prepended_Concatenation_Mark":[[1536,1541],[1757,1757],[1807,1807],[2192,2193],[2274,2274],[69821,69821],[69837,69837]],"Binary_Property/Other_Grapheme_Extend":[[2494,2494],[2519,2519],[2878,2878],[2903,2903],[3006,3006],[3031,3031],[3264,3264],[3266,3266],[3271,3272],[3274,3275],[3285,3286],[3390,3390],[3415,3415],[3535,3535],[3551,3551],[5909,5909],[5940,5940],[6965,6965],[6971,6971],[6973,6973],[6979,6980],[7082,7082],[7154,7155],[8204,8204],[12334,12335],[43347,43347],[43456,43456],[65438,65439],[70080,70080],[70197,70197],[70462,70462],[70477,70477],[70487,70487],[70584,70584],[70594,70594],[70597,70597],[70599,70601],[70607,70607],[70832,70832],[70845,70845],[71087,71087],[71350,71350],[71984,71984],[71997,71997],[73537,73537],[94192,94193],[119141,119142],[119149,119154],[917536,917631]],"Binary_Property/Lowercase":[[97,122],[170,170],[181,181],[186,186],[223,246],[248,255],[257,257],[259,259],[261,261],[263,263],[265,265],[267,267],[269,269],[271,271],[273,273],[275,275],[277,277],[279,279],[281,281],[283,283],[285,285],[287,287],[289,289],[291,291],[293,293],[295,295],[297,297],[299,299],[301,301],[303,303],[305,305],[307,307],[309,309],[311,312],[314,314],[316,316],[318,318],[320,320],[322,322],[324,324],[326,326],[328,329],[331,331],[333,333],[335,335],[337,337],[339,339],[341,341],[343,343],[345,345],[347,347],[349,349],[351,351],[353,353],[355,355],[357,357],[359,359],[361,361],[363,363],[365,365],[367,367],[369,369],[371,371],[373,373],[375,375],[378,378],[380,380],[382,384],[387,387],[389,389],[392,392],[396,397],[402,402],[405,405],[409,411],[414,414],[417,417],[419,419],[421,421],[424,424],[426,427],[429,429],[432,432],[436,436],[438,438],[441,442],[445,447],[454,454],[457,457],[460,460],[462,462],[464,464],[466,466],[468,468],[470,470],[472,472],[474,474],[476,477],[479,479],[481,481],[483,483],[485,485],[487,487],[489,489],[491,491],[493,493],[495,496],[499,499],[501,501],[505,505],[507,507],[509,509],[511,511],[513,513],[515,515],[517,517],[519,519],[521,521],[523,523],[525,525],[527,527],[529,529],[531,531],[533,533],[535,535],[537,537],[539,539],[541,541],[543,543],[545,545],[547,547],[549,549],[551,551],[553,553],[555,555],[557,557],[559,559],[561,561],[563,569],[572,572],[575,576],[578,578],[583,583],[585,585],[587,587],[589,589],[591,659],[661,696],[704,705],[736,740],[837,837],[881,881],[883,883],[887,887],[890,893],[912,912],[940,974],[976,977],[981,983],[985,985],[987,987],[989,989],[991,991],[993,993],[995,995],[997,997],[999,999],[1001,1001],[1003,1003],[1005,1005],[1007,1011],[1013,1013],[1016,1016],[1019,1020],[1072,1119],[1121,1121],[1123,1123],[1125,1125],[1127,1127],[1129,1129],[1131,1131],[1133,1133],[1135,1135],[1137,1137],[1139,1139],[1141,1141],[1143,1143],[1145,1145],[1147,1147],[1149,1149],[1151,1151],[1153,1153],[1163,1163],[1165,1165],[1167,1167],[1169,1169],[1171,1171],[1173,1173],[1175,1175],[1177,1177],[1179,1179],[1181,1181],[1183,1183],[1185,1185],[1187,1187],[1189,1189],[1191,1191],[1193,1193],[1195,1195],[1197,1197],[1199,1199],[1201,1201],[1203,1203],[1205,1205],[1207,1207],[1209,1209],[1211,1211],[1213,1213],[1215,1215],[1218,1218],[1220,1220],[1222,1222],[1224,1224],[1226,1226],[1228,1228],[1230,1231],[1233,1233],[1235,1235],[1237,1237],[1239,1239],[1241,1241],[1243,1243],[1245,1245],[1247,1247],[1249,1249],[1251,1251],[1253,1253],[1255,1255],[1257,1257],[1259,1259],[1261,1261],[1263,1263],[1265,1265],[1267,1267],[1269,1269],[1271,1271],[1273,1273],[1275,1275],[1277,1277],[1279,1279],[1281,1281],[1283,1283],[1285,1285],[1287,1287],[1289,1289],[1291,1291],[1293,1293],[1295,1295],[1297,1297],[1299,1299],[1301,1301],[1303,1303],[1305,1305],[1307,1307],[1309,1309],[1311,1311],[1313,1313],[1315,1315],[1317,1317],[1319,1319],[1321,1321],[1323,1323],[1325,1325],[1327,1327],[1376,1416],[4304,4346],[4348,4351],[5112,5117],[7296,7304],[7306,7306],[7424,7615],[7681,7681],[7683,7683],[7685,7685],[7687,7687],[7689,7689],[7691,7691],[7693,7693],[7695,7695],[7697,7697],[7699,7699],[7701,7701],[7703,7703],[7705,7705],[7707,7707],[7709,7709],[7711,7711],[7713,7713],[7715,7715],[7717,7717],[7719,7719],[7721,7721],[7723,7723],[7725,7725],[7727,7727],[7729,7729],[7731,7731],[7733,7733],[7735,7735],[7737,7737],[7739,7739],[7741,7741],[7743,7743],[7745,7745],[7747,7747],[7749,7749],[7751,7751],[7753,7753],[7755,7755],[7757,7757],[7759,7759],[7761,7761],[7763,7763],[7765,7765],[7767,7767],[7769,7769],[7771,7771],[7773,7773],[7775,7775],[7777,7777],[7779,7779],[7781,7781],[7783,7783],[7785,7785],[7787,7787],[7789,7789],[7791,7791],[7793,7793],[7795,7795],[7797,7797],[7799,7799],[7801,7801],[7803,7803],[7805,7805],[7807,7807],[7809,7809],[7811,7811],[7813,7813],[7815,7815],[7817,7817],[7819,7819],[7821,7821],[7823,7823],[7825,7825],[7827,7827],[7829,7837],[7839,7839],[7841,7841],[7843,7843],[7845,7845],[7847,7847],[7849,7849],[7851,7851],[7853,7853],[7855,7855],[7857,7857],[7859,7859],[7861,7861],[7863,7863],[7865,7865],[7867,7867],[7869,7869],[7871,7871],[7873,7873],[7875,7875],[7877,7877],[7879,7879],[7881,7881],[7883,7883],[7885,7885],[7887,7887],[7889,7889],[7891,7891],[7893,7893],[7895,7895],[7897,7897],[7899,7899],[7901,7901],[7903,7903],[7905,7905],[7907,7907],[7909,7909],[7911,7911],[7913,7913],[7915,7915],[7917,7917],[7919,7919],[7921,7921],[7923,7923],[7925,7925],[7927,7927],[7929,7929],[7931,7931],[7933,7933],[7935,7943],[7952,7957],[7968,7975],[7984,7991],[8000,8005],[8016,8023],[8032,8039],[8048,8061],[8064,8071],[8080,8087],[8096,8103],[8112,8116],[8118,8119],[8126,8126],[8130,8132],[8134,8135],[8144,8147],[8150,8151],[8160,8167],[8178,8180],[8182,8183],[8305,8305],[8319,8319],[8336,8348],[8458,8458],[8462,8463],[8467,8467],[8495,8495],[8500,8500],[8505,8505],[8508,8509],[8518,8521],[8526,8526],[8560,8575],[8580,8580],[9424,9449],[11312,11359],[11361,11361],[11365,11366],[11368,11368],[11370,11370],[11372,11372],[11377,11377],[11379,11380],[11382,11389],[11393,11393],[11395,11395],[11397,11397],[11399,11399],[11401,11401],[11403,11403],[11405,11405],[11407,11407],[11409,11409],[11411,11411],[11413,11413],[11415,11415],[11417,11417],[11419,11419],[11421,11421],[11423,11423],[11425,11425],[11427,11427],[11429,11429],[11431,11431],[11433,11433],[11435,11435],[11437,11437],[11439,11439],[11441,11441],[11443,11443],[11445,11445],[11447,11447],[11449,11449],[11451,11451],[11453,11453],[11455,11455],[11457,11457],[11459,11459],[11461,11461],[11463,11463],[11465,11465],[11467,11467],[11469,11469],[11471,11471],[11473,11473],[11475,11475],[11477,11477],[11479,11479],[11481,11481],[11483,11483],[11485,11485],[11487,11487],[11489,11489],[11491,11492],[11500,11500],[11502,11502],[11507,11507],[11520,11557],[11559,11559],[11565,11565],[42561,42561],[42563,42563],[42565,42565],[42567,42567],[42569,42569],[42571,42571],[42573,42573],[42575,42575],[42577,42577],[42579,42579],[42581,42581],[42583,42583],[42585,42585],[42587,42587],[42589,42589],[42591,42591],[42593,42593],[42595,42595],[42597,42597],[42599,42599],[42601,42601],[42603,42603],[42605,42605],[42625,42625],[42627,42627],[42629,42629],[42631,42631],[42633,42633],[42635,42635],[42637,42637],[42639,42639],[42641,42641],[42643,42643],[42645,42645],[42647,42647],[42649,42649],[42651,42653],[42787,42787],[42789,42789],[42791,42791],[42793,42793],[42795,42795],[42797,42797],[42799,42801],[42803,42803],[42805,42805],[42807,42807],[42809,42809],[42811,42811],[42813,42813],[42815,42815],[42817,42817],[42819,42819],[42821,42821],[42823,42823],[42825,42825],[42827,42827],[42829,42829],[42831,42831],[42833,42833],[42835,42835],[42837,42837],[42839,42839],[42841,42841],[42843,42843],[42845,42845],[42847,42847],[42849,42849],[42851,42851],[42853,42853],[42855,42855],[42857,42857],[42859,42859],[42861,42861],[42863,42872],[42874,42874],[42876,42876],[42879,42879],[42881,42881],[42883,42883],[42885,42885],[42887,42887],[42892,42892],[42894,42894],[42897,42897],[42899,42901],[42903,42903],[42905,42905],[42907,42907],[42909,42909],[42911,42911],[42913,42913],[42915,42915],[42917,42917],[42919,42919],[42921,42921],[42927,42927],[42933,42933],[42935,42935],[42937,42937],[42939,42939],[42941,42941],[42943,42943],[42945,42945],[42947,42947],[42952,42952],[42954,42954],[42957,42957],[42961,42961],[42963,42963],[42965,42965],[42967,42967],[42969,42969],[42971,42971],[42994,42996],[42998,42998],[43000,43002],[43824,43866],[43868,43881],[43888,43967],[64256,64262],[64275,64279],[65345,65370],[66600,66639],[66776,66811],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67456,67456],[67459,67461],[67463,67504],[67506,67514],[68800,68850],[68976,68997],[71872,71903],[93792,93823],[119834,119859],[119886,119892],[119894,119911],[119938,119963],[119990,119993],[119995,119995],[119997,120003],[120005,120015],[120042,120067],[120094,120119],[120146,120171],[120198,120223],[120250,120275],[120302,120327],[120354,120379],[120406,120431],[120458,120485],[120514,120538],[120540,120545],[120572,120596],[120598,120603],[120630,120654],[120656,120661],[120688,120712],[120714,120719],[120746,120770],[120772,120777],[120779,120779],[122624,122633],[122635,122654],[122661,122666],[122928,122989],[125218,125251]],"Binary_Property/Other_ID_Continue":[[183,183],[903,903],[4969,4977],[6618,6618],[8204,8205],[12539,12539],[65381,65381]],"Binary_Property/XID_Continue":[[48,57],[65,90],[95,95],[97,122],[170,170],[181,181],[183,183],[186,186],[192,214],[216,246],[248,705],[710,721],[736,740],[748,748],[750,750],[768,884],[886,887],[891,893],[895,895],[902,906],[908,908],[910,929],[931,1013],[1015,1153],[1155,1159],[1162,1327],[1329,1366],[1369,1369],[1376,1416],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1488,1514],[1519,1522],[1552,1562],[1568,1641],[1646,1747],[1749,1756],[1759,1768],[1770,1788],[1791,1791],[1808,1866],[1869,1969],[1984,2037],[2042,2042],[2045,2045],[2048,2093],[2112,2139],[2144,2154],[2160,2183],[2185,2190],[2199,2273],[2275,2403],[2406,2415],[2417,2435],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2492,2500],[2503,2504],[2507,2510],[2519,2519],[2524,2525],[2527,2531],[2534,2545],[2556,2556],[2558,2558],[2561,2563],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2620,2620],[2622,2626],[2631,2632],[2635,2637],[2641,2641],[2649,2652],[2654,2654],[2662,2677],[2689,2691],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2748,2757],[2759,2761],[2763,2765],[2768,2768],[2784,2787],[2790,2799],[2809,2815],[2817,2819],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2876,2884],[2887,2888],[2891,2893],[2901,2903],[2908,2909],[2911,2915],[2918,2927],[2929,2929],[2946,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3006,3010],[3014,3016],[3018,3021],[3024,3024],[3031,3031],[3046,3055],[3072,3084],[3086,3088],[3090,3112],[3114,3129],[3132,3140],[3142,3144],[3146,3149],[3157,3158],[3160,3162],[3165,3165],[3168,3171],[3174,3183],[3200,3203],[3205,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3260,3268],[3270,3272],[3274,3277],[3285,3286],[3293,3294],[3296,3299],[3302,3311],[3313,3315],[3328,3340],[3342,3344],[3346,3396],[3398,3400],[3402,3406],[3412,3415],[3423,3427],[3430,3439],[3450,3455],[3457,3459],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3530,3530],[3535,3540],[3542,3542],[3544,3551],[3558,3567],[3570,3571],[3585,3642],[3648,3662],[3664,3673],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3773],[3776,3780],[3782,3782],[3784,3790],[3792,3801],[3804,3807],[3840,3840],[3864,3865],[3872,3881],[3893,3893],[3895,3895],[3897,3897],[3902,3911],[3913,3948],[3953,3972],[3974,3991],[3993,4028],[4038,4038],[4096,4169],[4176,4253],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4348,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4957,4959],[4969,4977],[4992,5007],[5024,5109],[5112,5117],[5121,5740],[5743,5759],[5761,5786],[5792,5866],[5870,5880],[5888,5909],[5919,5940],[5952,5971],[5984,5996],[5998,6000],[6002,6003],[6016,6099],[6103,6103],[6108,6109],[6112,6121],[6155,6157],[6159,6169],[6176,6264],[6272,6314],[6320,6389],[6400,6430],[6432,6443],[6448,6459],[6470,6509],[6512,6516],[6528,6571],[6576,6601],[6608,6618],[6656,6683],[6688,6750],[6752,6780],[6783,6793],[6800,6809],[6823,6823],[6832,6845],[6847,6862],[6912,6988],[6992,7001],[7019,7027],[7040,7155],[7168,7223],[7232,7241],[7245,7293],[7296,7306],[7312,7354],[7357,7359],[7376,7378],[7380,7418],[7424,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8204,8205],[8255,8256],[8276,8276],[8305,8305],[8319,8319],[8336,8348],[8400,8412],[8417,8417],[8421,8432],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8472,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8505],[8508,8511],[8517,8521],[8526,8526],[8544,8584],[11264,11492],[11499,11507],[11520,11557],[11559,11559],[11565,11565],[11568,11623],[11631,11631],[11647,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[11744,11775],[12293,12295],[12321,12335],[12337,12341],[12344,12348],[12353,12438],[12441,12442],[12445,12447],[12449,12543],[12549,12591],[12593,12686],[12704,12735],[12784,12799],[13312,19903],[19968,42124],[42192,42237],[42240,42508],[42512,42539],[42560,42607],[42612,42621],[42623,42737],[42775,42783],[42786,42888],[42891,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43047],[43052,43052],[43072,43123],[43136,43205],[43216,43225],[43232,43255],[43259,43259],[43261,43309],[43312,43347],[43360,43388],[43392,43456],[43471,43481],[43488,43518],[43520,43574],[43584,43597],[43600,43609],[43616,43638],[43642,43714],[43739,43741],[43744,43759],[43762,43766],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43866],[43868,43881],[43888,44010],[44012,44013],[44016,44025],[44032,55203],[55216,55238],[55243,55291],[63744,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64296],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64605],[64612,64829],[64848,64911],[64914,64967],[65008,65017],[65024,65039],[65056,65071],[65075,65076],[65101,65103],[65137,65137],[65139,65139],[65143,65143],[65145,65145],[65147,65147],[65149,65149],[65151,65276],[65296,65305],[65313,65338],[65343,65343],[65345,65370],[65381,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65856,65908],[66045,66045],[66176,66204],[66208,66256],[66272,66272],[66304,66335],[66349,66378],[66384,66426],[66432,66461],[66464,66499],[66504,66511],[66513,66517],[66560,66717],[66720,66729],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67680,67702],[67712,67742],[67808,67826],[67828,67829],[67840,67861],[67872,67897],[67968,68023],[68030,68031],[68096,68099],[68101,68102],[68108,68115],[68117,68119],[68121,68149],[68152,68154],[68159,68159],[68192,68220],[68224,68252],[68288,68295],[68297,68326],[68352,68405],[68416,68437],[68448,68466],[68480,68497],[68608,68680],[68736,68786],[68800,68850],[68864,68903],[68912,68921],[68928,68965],[68969,68973],[68975,68997],[69248,69289],[69291,69292],[69296,69297],[69314,69316],[69372,69404],[69415,69415],[69424,69456],[69488,69509],[69552,69572],[69600,69622],[69632,69702],[69734,69749],[69759,69818],[69826,69826],[69840,69864],[69872,69881],[69888,69940],[69942,69951],[69956,69959],[69968,70003],[70006,70006],[70016,70084],[70089,70092],[70094,70106],[70108,70108],[70144,70161],[70163,70199],[70206,70209],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70312],[70320,70378],[70384,70393],[70400,70403],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70459,70468],[70471,70472],[70475,70477],[70480,70480],[70487,70487],[70493,70499],[70502,70508],[70512,70516],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70592],[70594,70594],[70597,70597],[70599,70602],[70604,70611],[70625,70626],[70656,70730],[70736,70745],[70750,70753],[70784,70853],[70855,70855],[70864,70873],[71040,71093],[71096,71104],[71128,71133],[71168,71232],[71236,71236],[71248,71257],[71296,71352],[71360,71369],[71376,71395],[71424,71450],[71453,71467],[71472,71481],[71488,71494],[71680,71738],[71840,71913],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71989],[71991,71992],[71995,72003],[72016,72025],[72096,72103],[72106,72151],[72154,72161],[72163,72164],[72192,72254],[72263,72263],[72272,72345],[72349,72349],[72368,72440],[72640,72672],[72688,72697],[72704,72712],[72714,72758],[72760,72768],[72784,72793],[72818,72847],[72850,72871],[72873,72886],[72960,72966],[72968,72969],[72971,73014],[73018,73018],[73020,73021],[73023,73031],[73040,73049],[73056,73061],[73063,73064],[73066,73102],[73104,73105],[73107,73112],[73120,73129],[73440,73462],[73472,73488],[73490,73530],[73534,73538],[73552,73562],[73648,73648],[73728,74649],[74752,74862],[74880,75075],[77712,77808],[77824,78895],[78912,78933],[78944,82938],[82944,83526],[90368,90425],[92160,92728],[92736,92766],[92768,92777],[92784,92862],[92864,92873],[92880,92909],[92912,92916],[92928,92982],[92992,92995],[93008,93017],[93027,93047],[93053,93071],[93504,93548],[93552,93561],[93760,93823],[93952,94026],[94031,94087],[94095,94111],[94176,94177],[94179,94180],[94192,94193],[94208,100343],[100352,101589],[101631,101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[113821,113822],[118000,118009],[118528,118573],[118576,118598],[119141,119145],[119149,119154],[119163,119170],[119173,119179],[119210,119213],[119362,119364],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[120782,120831],[121344,121398],[121403,121452],[121461,121461],[121476,121476],[121499,121503],[121505,121519],[122624,122654],[122661,122666],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[122928,122989],[123023,123023],[123136,123180],[123184,123197],[123200,123209],[123214,123214],[123536,123566],[123584,123641],[124112,124153],[124368,124410],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125136,125142],[125184,125259],[125264,125273],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[130032,130041],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743],[917760,917999]],"Binary_Property/Pattern_Syntax":[[33,47],[58,64],[91,94],[96,96],[123,126],[161,167],[169,169],[171,172],[174,174],[176,177],[182,182],[187,187],[191,191],[215,215],[247,247],[8208,8231],[8240,8254],[8257,8275],[8277,8286],[8592,9311],[9472,10101],[10132,11263],[11776,11903],[12289,12291],[12296,12320],[12336,12336],[64830,64831],[65093,65094]],"Binary_Property/Default_Ignorable_Code_Point":[[173,173],[847,847],[1564,1564],[4447,4448],[6068,6069],[6155,6159],[8203,8207],[8234,8238],[8288,8303],[12644,12644],[65024,65039],[65279,65279],[65440,65440],[65520,65528],[113824,113827],[119155,119162],[917504,921599]],"Binary_Property/NFKC_Simple_Casefold":[[65,90],[160,160],[168,168],[170,170],[173,173],[175,175],[178,181],[184,186],[188,190],[192,214],[216,222],[256,256],[258,258],[260,260],[262,262],[264,264],[266,266],[268,268],[270,270],[272,272],[274,274],[276,276],[278,278],[280,280],[282,282],[284,284],[286,286],[288,288],[290,290],[292,292],[294,294],[296,296],[298,298],[300,300],[302,302],[306,308],[310,310],[313,313],[315,315],[317,317],[319,321],[323,323],[325,325],[327,327],[329,330],[332,332],[334,334],[336,336],[338,338],[340,340],[342,342],[344,344],[346,346],[348,348],[350,350],[352,352],[354,354],[356,356],[358,358],[360,360],[362,362],[364,364],[366,366],[368,368],[370,370],[372,372],[374,374],[376,377],[379,379],[381,381],[383,383],[385,386],[388,388],[390,391],[393,395],[398,401],[403,404],[406,408],[412,413],[415,416],[418,418],[420,420],[422,423],[425,425],[428,428],[430,431],[433,435],[437,437],[439,440],[444,444],[452,461],[463,463],[465,465],[467,467],[469,469],[471,471],[473,473],[475,475],[478,478],[480,480],[482,482],[484,484],[486,486],[488,488],[490,490],[492,492],[494,494],[497,500],[502,504],[506,506],[508,508],[510,510],[512,512],[514,514],[516,516],[518,518],[520,520],[522,522],[524,524],[526,526],[528,528],[530,530],[532,532],[534,534],[536,536],[538,538],[540,540],[542,542],[544,544],[546,546],[548,548],[550,550],[552,552],[554,554],[556,556],[558,558],[560,560],[562,562],[570,571],[573,574],[577,577],[579,582],[584,584],[586,586],[588,588],[590,590],[688,696],[728,733],[736,740],[832,833],[835,837],[847,847],[880,880],[882,882],[884,884],[886,886],[890,890],[894,895],[900,906],[908,908],[910,911],[913,929],[931,939],[962,962],[975,982],[984,984],[986,986],[988,988],[990,990],[992,992],[994,994],[996,996],[998,998],[1000,1000],[1002,1002],[1004,1004],[1006,1006],[1008,1010],[1012,1013],[1015,1015],[1017,1018],[1021,1071],[1120,1120],[1122,1122],[1124,1124],[1126,1126],[1128,1128],[1130,1130],[1132,1132],[1134,1134],[1136,1136],[1138,1138],[1140,1140],[1142,1142],[1144,1144],[1146,1146],[1148,1148],[1150,1150],[1152,1152],[1162,1162],[1164,1164],[1166,1166],[1168,1168],[1170,1170],[1172,1172],[1174,1174],[1176,1176],[1178,1178],[1180,1180],[1182,1182],[1184,1184],[1186,1186],[1188,1188],[1190,1190],[1192,1192],[1194,1194],[1196,1196],[1198,1198],[1200,1200],[1202,1202],[1204,1204],[1206,1206],[1208,1208],[1210,1210],[1212,1212],[1214,1214],[1216,1217],[1219,1219],[1221,1221],[1223,1223],[1225,1225],[1227,1227],[1229,1229],[1232,1232],[1234,1234],[1236,1236],[1238,1238],[1240,1240],[1242,1242],[1244,1244],[1246,1246],[1248,1248],[1250,1250],[1252,1252],[1254,1254],[1256,1256],[1258,1258],[1260,1260],[1262,1262],[1264,1264],[1266,1266],[1268,1268],[1270,1270],[1272,1272],[1274,1274],[1276,1276],[1278,1278],[1280,1280],[1282,1282],[1284,1284],[1286,1286],[1288,1288],[1290,1290],[1292,1292],[1294,1294],[1296,1296],[1298,1298],[1300,1300],[1302,1302],[1304,1304],[1306,1306],[1308,1308],[1310,1310],[1312,1312],[1314,1314],[1316,1316],[1318,1318],[1320,1320],[1322,1322],[1324,1324],[1326,1326],[1329,1366],[1415,1415],[1564,1564],[1653,1656],[2392,2399],[2524,2525],[2527,2527],[2611,2611],[2614,2614],[2649,2651],[2654,2654],[2908,2909],[3635,3635],[3763,3763],[3804,3805],[3852,3852],[3907,3907],[3917,3917],[3922,3922],[3927,3927],[3932,3932],[3945,3945],[3955,3955],[3957,3961],[3969,3969],[3987,3987],[3997,3997],[4002,4002],[4007,4007],[4012,4012],[4025,4025],[4256,4293],[4295,4295],[4301,4301],[4348,4348],[4447,4448],[5112,5117],[6068,6069],[6155,6159],[7296,7305],[7312,7354],[7357,7359],[7468,7470],[7472,7482],[7484,7501],[7503,7530],[7544,7544],[7579,7615],[7680,7680],[7682,7682],[7684,7684],[7686,7686],[7688,7688],[7690,7690],[7692,7692],[7694,7694],[7696,7696],[7698,7698],[7700,7700],[7702,7702],[7704,7704],[7706,7706],[7708,7708],[7710,7710],[7712,7712],[7714,7714],[7716,7716],[7718,7718],[7720,7720],[7722,7722],[7724,7724],[7726,7726],[7728,7728],[7730,7730],[7732,7732],[7734,7734],[7736,7736],[7738,7738],[7740,7740],[7742,7742],[7744,7744],[7746,7746],[7748,7748],[7750,7750],[7752,7752],[7754,7754],[7756,7756],[7758,7758],[7760,7760],[7762,7762],[7764,7764],[7766,7766],[7768,7768],[7770,7770],[7772,7772],[7774,7774],[7776,7776],[7778,7778],[7780,7780],[7782,7782],[7784,7784],[7786,7786],[7788,7788],[7790,7790],[7792,7792],[7794,7794],[7796,7796],[7798,7798],[7800,7800],[7802,7802],[7804,7804],[7806,7806],[7808,7808],[7810,7810],[7812,7812],[7814,7814],[7816,7816],[7818,7818],[7820,7820],[7822,7822],[7824,7824],[7826,7826],[7828,7828],[7834,7835],[7838,7838],[7840,7840],[7842,7842],[7844,7844],[7846,7846],[7848,7848],[7850,7850],[7852,7852],[7854,7854],[7856,7856],[7858,7858],[7860,7860],[7862,7862],[7864,7864],[7866,7866],[7868,7868],[7870,7870],[7872,7872],[7874,7874],[7876,7876],[7878,7878],[7880,7880],[7882,7882],[7884,7884],[7886,7886],[7888,7888],[7890,7890],[7892,7892],[7894,7894],[7896,7896],[7898,7898],[7900,7900],[7902,7902],[7904,7904],[7906,7906],[7908,7908],[7910,7910],[7912,7912],[7914,7914],[7916,7916],[7918,7918],[7920,7920],[7922,7922],[7924,7924],[7926,7926],[7928,7928],[7930,7930],[7932,7932],[7934,7934],[7944,7951],[7960,7965],[7976,7983],[7992,7999],[8008,8013],[8025,8025],[8027,8027],[8029,8029],[8031,8031],[8040,8047],[8049,8049],[8051,8051],[8053,8053],[8055,8055],[8057,8057],[8059,8059],[8061,8061],[8072,8079],[8088,8095],[8104,8111],[8120,8129],[8136,8143],[8147,8147],[8152,8155],[8157,8159],[8163,8163],[8168,8175],[8184,8190],[8192,8207],[8209,8209],[8215,8215],[8228,8230],[8234,8239],[8243,8244],[8246,8247],[8252,8252],[8254,8254],[8263,8265],[8279,8279],[8287,8305],[8308,8334],[8336,8348],[8360,8360],[8448,8451],[8453,8455],[8457,8467],[8469,8470],[8473,8477],[8480,8482],[8484,8484],[8486,8486],[8488,8488],[8490,8493],[8495,8505],[8507,8512],[8517,8521],[8528,8575],[8579,8579],[8585,8585],[8748,8749],[8751,8752],[9001,9002],[9312,9450],[10764,10764],[10868,10870],[10972,10972],[11264,11311],[11360,11360],[11362,11364],[11367,11367],[11369,11369],[11371,11371],[11373,11376],[11378,11378],[11381,11381],[11388,11392],[11394,11394],[11396,11396],[11398,11398],[11400,11400],[11402,11402],[11404,11404],[11406,11406],[11408,11408],[11410,11410],[11412,11412],[11414,11414],[11416,11416],[11418,11418],[11420,11420],[11422,11422],[11424,11424],[11426,11426],[11428,11428],[11430,11430],[11432,11432],[11434,11434],[11436,11436],[11438,11438],[11440,11440],[11442,11442],[11444,11444],[11446,11446],[11448,11448],[11450,11450],[11452,11452],[11454,11454],[11456,11456],[11458,11458],[11460,11460],[11462,11462],[11464,11464],[11466,11466],[11468,11468],[11470,11470],[11472,11472],[11474,11474],[11476,11476],[11478,11478],[11480,11480],[11482,11482],[11484,11484],[11486,11486],[11488,11488],[11490,11490],[11499,11499],[11501,11501],[11506,11506],[11631,11631],[11935,11935],[12019,12019],[12032,12245],[12288,12288],[12342,12342],[12344,12346],[12443,12444],[12447,12447],[12543,12543],[12593,12686],[12690,12703],[12800,12830],[12832,12871],[12880,12926],[12928,13311],[42560,42560],[42562,42562],[42564,42564],[42566,42566],[42568,42568],[42570,42570],[42572,42572],[42574,42574],[42576,42576],[42578,42578],[42580,42580],[42582,42582],[42584,42584],[42586,42586],[42588,42588],[42590,42590],[42592,42592],[42594,42594],[42596,42596],[42598,42598],[42600,42600],[42602,42602],[42604,42604],[42624,42624],[42626,42626],[42628,42628],[42630,42630],[42632,42632],[42634,42634],[42636,42636],[42638,42638],[42640,42640],[42642,42642],[42644,42644],[42646,42646],[42648,42648],[42650,42650],[42652,42653],[42786,42786],[42788,42788],[42790,42790],[42792,42792],[42794,42794],[42796,42796],[42798,42798],[42802,42802],[42804,42804],[42806,42806],[42808,42808],[42810,42810],[42812,42812],[42814,42814],[42816,42816],[42818,42818],[42820,42820],[42822,42822],[42824,42824],[42826,42826],[42828,42828],[42830,42830],[42832,42832],[42834,42834],[42836,42836],[42838,42838],[42840,42840],[42842,42842],[42844,42844],[42846,42846],[42848,42848],[42850,42850],[42852,42852],[42854,42854],[42856,42856],[42858,42858],[42860,42860],[42862,42862],[42864,42864],[42873,42873],[42875,42875],[42877,42878],[42880,42880],[42882,42882],[42884,42884],[42886,42886],[42891,42891],[42893,42893],[42896,42896],[42898,42898],[42902,42902],[42904,42904],[42906,42906],[42908,42908],[42910,42910],[42912,42912],[42914,42914],[42916,42916],[42918,42918],[42920,42920],[42922,42926],[42928,42932],[42934,42934],[42936,42936],[42938,42938],[42940,42940],[42942,42942],[42944,42944],[42946,42946],[42948,42951],[42953,42953],[42955,42956],[42960,42960],[42966,42966],[42968,42968],[42970,42970],[42972,42972],[42994,42997],[43000,43001],[43868,43871],[43881,43881],[43888,43967],[63744,64013],[64016,64016],[64018,64018],[64021,64030],[64032,64032],[64034,64034],[64037,64038],[64042,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64285],[64287,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64829],[64848,64911],[64914,64967],[65008,65020],[65024,65049],[65072,65092],[65095,65106],[65108,65126],[65128,65131],[65136,65138],[65140,65140],[65142,65276],[65279,65279],[65281,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65504,65510],[65512,65518],[65520,65528],[66560,66599],[66736,66771],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[67457,67461],[67463,67504],[67506,67514],[68736,68786],[68944,68965],[71840,71871],[93760,93791],[113824,113827],[117974,118009],[119134,119140],[119155,119162],[119227,119232],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120779],[120782,120831],[122928,122989],[125184,125217],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[127232,127242],[127248,127278],[127280,127311],[127338,127340],[127376,127376],[127488,127490],[127504,127547],[127552,127560],[127568,127569],[130032,130041],[194560,195101],[917504,921599]],"Binary_Property/Other_ID_Start":[[6277,6278],[8472,8472],[8494,8494],[12443,12444]],"Binary_Property/Quotation_Mark":[[34,34],[39,39],[171,171],[187,187],[8216,8223],[8249,8250],[11842,11842],[12300,12303],[12317,12319],[65089,65092],[65282,65282],[65287,65287],[65378,65379]],"Binary_Property/IDS_Binary_Operator":[[12272,12273],[12276,12285],[12783,12783]],"Binary_Property/Case_Ignorable":[[39,39],[46,46],[58,58],[94,94],[96,96],[168,168],[173,173],[175,175],[180,180],[183,184],[688,879],[884,885],[890,890],[900,901],[903,903],[1155,1161],[1369,1369],[1375,1375],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1524,1524],[1536,1541],[1552,1562],[1564,1564],[1600,1600],[1611,1631],[1648,1648],[1750,1757],[1759,1768],[1770,1773],[1807,1807],[1809,1809],[1840,1866],[1958,1968],[2027,2037],[2042,2042],[2045,2045],[2070,2093],[2137,2139],[2184,2184],[2192,2193],[2199,2207],[2249,2306],[2362,2362],[2364,2364],[2369,2376],[2381,2381],[2385,2391],[2402,2403],[2417,2417],[2433,2433],[2492,2492],[2497,2500],[2509,2509],[2530,2531],[2558,2558],[2561,2562],[2620,2620],[2625,2626],[2631,2632],[2635,2637],[2641,2641],[2672,2673],[2677,2677],[2689,2690],[2748,2748],[2753,2757],[2759,2760],[2765,2765],[2786,2787],[2810,2815],[2817,2817],[2876,2876],[2879,2879],[2881,2884],[2893,2893],[2901,2902],[2914,2915],[2946,2946],[3008,3008],[3021,3021],[3072,3072],[3076,3076],[3132,3132],[3134,3136],[3142,3144],[3146,3149],[3157,3158],[3170,3171],[3201,3201],[3260,3260],[3263,3263],[3270,3270],[3276,3277],[3298,3299],[3328,3329],[3387,3388],[3393,3396],[3405,3405],[3426,3427],[3457,3457],[3530,3530],[3538,3540],[3542,3542],[3633,3633],[3636,3642],[3654,3662],[3761,3761],[3764,3772],[3782,3782],[3784,3790],[3864,3865],[3893,3893],[3895,3895],[3897,3897],[3953,3966],[3968,3972],[3974,3975],[3981,3991],[3993,4028],[4038,4038],[4141,4144],[4146,4151],[4153,4154],[4157,4158],[4184,4185],[4190,4192],[4209,4212],[4226,4226],[4229,4230],[4237,4237],[4253,4253],[4348,4348],[4957,4959],[5906,5908],[5938,5939],[5970,5971],[6002,6003],[6068,6069],[6071,6077],[6086,6086],[6089,6099],[6103,6103],[6109,6109],[6155,6159],[6211,6211],[6277,6278],[6313,6313],[6432,6434],[6439,6440],[6450,6450],[6457,6459],[6679,6680],[6683,6683],[6742,6742],[6744,6750],[6752,6752],[6754,6754],[6757,6764],[6771,6780],[6783,6783],[6823,6823],[6832,6862],[6912,6915],[6964,6964],[6966,6970],[6972,6972],[6978,6978],[7019,7027],[7040,7041],[7074,7077],[7080,7081],[7083,7085],[7142,7142],[7144,7145],[7149,7149],[7151,7153],[7212,7219],[7222,7223],[7288,7293],[7376,7378],[7380,7392],[7394,7400],[7405,7405],[7412,7412],[7416,7417],[7468,7530],[7544,7544],[7579,7679],[8125,8125],[8127,8129],[8141,8143],[8157,8159],[8173,8175],[8189,8190],[8203,8207],[8216,8217],[8228,8228],[8231,8231],[8234,8238],[8288,8292],[8294,8303],[8305,8305],[8319,8319],[8336,8348],[8400,8432],[11388,11389],[11503,11505],[11631,11631],[11647,11647],[11744,11775],[11823,11823],[12293,12293],[12330,12333],[12337,12341],[12347,12347],[12441,12446],[12540,12542],[40981,40981],[42232,42237],[42508,42508],[42607,42610],[42612,42621],[42623,42623],[42652,42655],[42736,42737],[42752,42785],[42864,42864],[42888,42890],[42994,42996],[43000,43001],[43010,43010],[43014,43014],[43019,43019],[43045,43046],[43052,43052],[43204,43205],[43232,43249],[43263,43263],[43302,43309],[43335,43345],[43392,43394],[43443,43443],[43446,43449],[43452,43453],[43471,43471],[43493,43494],[43561,43566],[43569,43570],[43573,43574],[43587,43587],[43596,43596],[43632,43632],[43644,43644],[43696,43696],[43698,43700],[43703,43704],[43710,43711],[43713,43713],[43741,43741],[43756,43757],[43763,43764],[43766,43766],[43867,43871],[43881,43883],[44005,44005],[44008,44008],[44013,44013],[64286,64286],[64434,64450],[65024,65039],[65043,65043],[65056,65071],[65106,65106],[65109,65109],[65279,65279],[65287,65287],[65294,65294],[65306,65306],[65342,65342],[65344,65344],[65392,65392],[65438,65439],[65507,65507],[65529,65531],[66045,66045],[66272,66272],[66422,66426],[67456,67461],[67463,67504],[67506,67514],[68097,68099],[68101,68102],[68108,68111],[68152,68154],[68159,68159],[68325,68326],[68900,68903],[68942,68942],[68969,68973],[68975,68975],[69291,69292],[69372,69375],[69446,69456],[69506,69509],[69633,69633],[69688,69702],[69744,69744],[69747,69748],[69759,69761],[69811,69814],[69817,69818],[69821,69821],[69826,69826],[69837,69837],[69888,69890],[69927,69931],[69933,69940],[70003,70003],[70016,70017],[70070,70078],[70089,70092],[70095,70095],[70191,70193],[70196,70196],[70198,70199],[70206,70206],[70209,70209],[70367,70367],[70371,70378],[70400,70401],[70459,70460],[70464,70464],[70502,70508],[70512,70516],[70587,70592],[70606,70606],[70608,70608],[70610,70610],[70625,70626],[70712,70719],[70722,70724],[70726,70726],[70750,70750],[70835,70840],[70842,70842],[70847,70848],[70850,70851],[71090,71093],[71100,71101],[71103,71104],[71132,71133],[71219,71226],[71229,71229],[71231,71232],[71339,71339],[71341,71341],[71344,71349],[71351,71351],[71453,71453],[71455,71455],[71458,71461],[71463,71467],[71727,71735],[71737,71738],[71995,71996],[71998,71998],[72003,72003],[72148,72151],[72154,72155],[72160,72160],[72193,72202],[72243,72248],[72251,72254],[72263,72263],[72273,72278],[72281,72283],[72330,72342],[72344,72345],[72752,72758],[72760,72765],[72767,72767],[72850,72871],[72874,72880],[72882,72883],[72885,72886],[73009,73014],[73018,73018],[73020,73021],[73023,73029],[73031,73031],[73104,73105],[73109,73109],[73111,73111],[73459,73460],[73472,73473],[73526,73530],[73536,73536],[73538,73538],[73562,73562],[78896,78912],[78919,78933],[90398,90409],[90413,90415],[92912,92916],[92976,92982],[92992,92995],[93504,93506],[93547,93548],[94031,94031],[94095,94111],[94176,94177],[94179,94180],[110576,110579],[110581,110587],[110589,110590],[113821,113822],[113824,113827],[118528,118573],[118576,118598],[119143,119145],[119155,119170],[119173,119179],[119210,119213],[119362,119364],[121344,121398],[121403,121452],[121461,121461],[121476,121476],[121499,121503],[121505,121519],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[122928,122989],[123023,123023],[123184,123197],[123566,123566],[123628,123631],[124139,124143],[124398,124399],[125136,125142],[125252,125259],[127995,127999],[917505,917505],[917536,917631],[917760,917999]],"Binary_Property/Expands_On_NFKC":[[168,168],[175,175],[180,180],[184,184],[188,190],[306,307],[319,320],[329,329],[452,460],[497,499],[728,733],[836,836],[890,890],[900,901],[1415,1415],[1653,1656],[2392,2399],[2524,2525],[2527,2527],[2611,2611],[2614,2614],[2649,2651],[2654,2654],[2908,2909],[3635,3635],[3763,3763],[3804,3805],[3907,3907],[3917,3917],[3922,3922],[3927,3927],[3932,3932],[3945,3945],[3955,3955],[3957,3961],[3969,3969],[3987,3987],[3997,3997],[4002,4002],[4007,4007],[4012,4012],[4025,4025],[7834,7834],[8125,8125],[8127,8129],[8141,8143],[8157,8159],[8173,8174],[8189,8190],[8215,8215],[8229,8230],[8243,8244],[8246,8247],[8252,8252],[8254,8254],[8263,8265],[8279,8279],[8360,8360],[8448,8449],[8451,8451],[8453,8454],[8457,8457],[8470,8470],[8480,8482],[8507,8507],[8528,8543],[8545,8547],[8549,8552],[8554,8555],[8561,8563],[8565,8568],[8570,8571],[8585,8585],[8748,8749],[8751,8752],[9321,9397],[10764,10764],[10868,10870],[10972,10972],[12443,12444],[12447,12447],[12543,12543],[12800,12830],[12832,12867],[12880,12895],[12924,12925],[12977,13007],[13055,13311],[64256,64262],[64275,64279],[64285,64285],[64287,64287],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64335],[64477,64477],[64490,64507],[64512,64829],[64848,64911],[64914,64967],[65008,65020],[65049,65049],[65072,65072],[65097,65100],[65136,65138],[65140,65140],[65142,65151],[65269,65276],[65507,65507],[119134,119140],[119227,119232],[127232,127242],[127248,127274],[127277,127278],[127306,127311],[127338,127340],[127376,127376],[127488,127489],[127552,127560]],"Binary_Property/Assigned":[[0,887],[890,895],[900,906],[908,908],[910,929],[931,1327],[1329,1366],[1369,1418],[1421,1423],[1425,1479],[1488,1514],[1519,1524],[1536,1805],[1807,1866],[1869,1969],[1984,2042],[2045,2093],[2096,2110],[2112,2139],[2142,2142],[2144,2154],[2160,2190],[2192,2193],[2199,2435],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2492,2500],[2503,2504],[2507,2510],[2519,2519],[2524,2525],[2527,2531],[2534,2558],[2561,2563],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2620,2620],[2622,2626],[2631,2632],[2635,2637],[2641,2641],[2649,2652],[2654,2654],[2662,2678],[2689,2691],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2748,2757],[2759,2761],[2763,2765],[2768,2768],[2784,2787],[2790,2801],[2809,2815],[2817,2819],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2876,2884],[2887,2888],[2891,2893],[2901,2903],[2908,2909],[2911,2915],[2918,2935],[2946,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3006,3010],[3014,3016],[3018,3021],[3024,3024],[3031,3031],[3046,3066],[3072,3084],[3086,3088],[3090,3112],[3114,3129],[3132,3140],[3142,3144],[3146,3149],[3157,3158],[3160,3162],[3165,3165],[3168,3171],[3174,3183],[3191,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3260,3268],[3270,3272],[3274,3277],[3285,3286],[3293,3294],[3296,3299],[3302,3311],[3313,3315],[3328,3340],[3342,3344],[3346,3396],[3398,3400],[3402,3407],[3412,3427],[3430,3455],[3457,3459],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3530,3530],[3535,3540],[3542,3542],[3544,3551],[3558,3567],[3570,3572],[3585,3642],[3647,3675],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3773],[3776,3780],[3782,3782],[3784,3790],[3792,3801],[3804,3807],[3840,3911],[3913,3948],[3953,3991],[3993,4028],[4030,4044],[4046,4058],[4096,4293],[4295,4295],[4301,4301],[4304,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4957,4988],[4992,5017],[5024,5109],[5112,5117],[5120,5788],[5792,5880],[5888,5909],[5919,5942],[5952,5971],[5984,5996],[5998,6000],[6002,6003],[6016,6109],[6112,6121],[6128,6137],[6144,6169],[6176,6264],[6272,6314],[6320,6389],[6400,6430],[6432,6443],[6448,6459],[6464,6464],[6468,6509],[6512,6516],[6528,6571],[6576,6601],[6608,6618],[6622,6683],[6686,6750],[6752,6780],[6783,6793],[6800,6809],[6816,6829],[6832,6862],[6912,6988],[6990,7155],[7164,7223],[7227,7241],[7245,7306],[7312,7354],[7357,7367],[7376,7418],[7424,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8132],[8134,8147],[8150,8155],[8157,8175],[8178,8180],[8182,8190],[8192,8292],[8294,8305],[8308,8334],[8336,8348],[8352,8384],[8400,8432],[8448,8587],[8592,9257],[9280,9290],[9312,11123],[11126,11157],[11159,11507],[11513,11557],[11559,11559],[11565,11565],[11568,11623],[11631,11632],[11647,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[11744,11869],[11904,11929],[11931,12019],[12032,12245],[12272,12351],[12353,12438],[12441,12543],[12549,12591],[12593,12686],[12688,12773],[12783,12830],[12832,42124],[42128,42182],[42192,42539],[42560,42743],[42752,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43052],[43056,43065],[43072,43127],[43136,43205],[43214,43225],[43232,43347],[43359,43388],[43392,43469],[43471,43481],[43486,43518],[43520,43574],[43584,43597],[43600,43609],[43612,43714],[43739,43766],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43883],[43888,44013],[44016,44025],[44032,55203],[55216,55238],[55243,55291],[55296,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64450],[64467,64911],[64914,64967],[64975,64975],[65008,65049],[65056,65106],[65108,65126],[65128,65131],[65136,65140],[65142,65276],[65279,65279],[65281,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65504,65510],[65512,65518],[65529,65533],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65792,65794],[65799,65843],[65847,65934],[65936,65948],[65952,65952],[66000,66045],[66176,66204],[66208,66256],[66272,66299],[66304,66339],[66349,66378],[66384,66426],[66432,66461],[66463,66499],[66504,66517],[66560,66717],[66720,66729],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66927,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67671,67742],[67751,67759],[67808,67826],[67828,67829],[67835,67867],[67871,67897],[67903,67903],[67968,68023],[68028,68047],[68050,68099],[68101,68102],[68108,68115],[68117,68119],[68121,68149],[68152,68154],[68159,68168],[68176,68184],[68192,68255],[68288,68326],[68331,68342],[68352,68405],[68409,68437],[68440,68466],[68472,68497],[68505,68508],[68521,68527],[68608,68680],[68736,68786],[68800,68850],[68858,68903],[68912,68921],[68928,68965],[68969,68997],[69006,69007],[69216,69246],[69248,69289],[69291,69293],[69296,69297],[69314,69316],[69372,69415],[69424,69465],[69488,69513],[69552,69579],[69600,69622],[69632,69709],[69714,69749],[69759,69826],[69837,69837],[69840,69864],[69872,69881],[69888,69940],[69942,69959],[69968,70006],[70016,70111],[70113,70132],[70144,70161],[70163,70209],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70313],[70320,70378],[70384,70393],[70400,70403],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70459,70468],[70471,70472],[70475,70477],[70480,70480],[70487,70487],[70493,70499],[70502,70508],[70512,70516],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70592],[70594,70594],[70597,70597],[70599,70602],[70604,70613],[70615,70616],[70625,70626],[70656,70747],[70749,70753],[70784,70855],[70864,70873],[71040,71093],[71096,71133],[71168,71236],[71248,71257],[71264,71276],[71296,71353],[71360,71369],[71376,71395],[71424,71450],[71453,71467],[71472,71494],[71680,71739],[71840,71922],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71989],[71991,71992],[71995,72006],[72016,72025],[72096,72103],[72106,72151],[72154,72164],[72192,72263],[72272,72354],[72368,72440],[72448,72457],[72640,72673],[72688,72697],[72704,72712],[72714,72758],[72760,72773],[72784,72812],[72816,72847],[72850,72871],[72873,72886],[72960,72966],[72968,72969],[72971,73014],[73018,73018],[73020,73021],[73023,73031],[73040,73049],[73056,73061],[73063,73064],[73066,73102],[73104,73105],[73107,73112],[73120,73129],[73440,73464],[73472,73488],[73490,73530],[73534,73562],[73648,73648],[73664,73713],[73727,74649],[74752,74862],[74864,74868],[74880,75075],[77712,77810],[77824,78933],[78944,82938],[82944,83526],[90368,90425],[92160,92728],[92736,92766],[92768,92777],[92782,92862],[92864,92873],[92880,92909],[92912,92917],[92928,92997],[93008,93017],[93019,93025],[93027,93047],[93053,93071],[93504,93561],[93760,93850],[93952,94026],[94031,94087],[94095,94111],[94176,94180],[94192,94193],[94208,100343],[100352,101589],[101631,101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[113820,113827],[117760,118009],[118016,118451],[118528,118573],[118576,118598],[118608,118723],[118784,119029],[119040,119078],[119081,119274],[119296,119365],[119488,119507],[119520,119539],[119552,119638],[119648,119672],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120779],[120782,121483],[121499,121503],[121505,121519],[122624,122654],[122661,122666],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[122928,122989],[123023,123023],[123136,123180],[123184,123197],[123200,123209],[123214,123215],[123536,123566],[123584,123641],[123647,123647],[124112,124153],[124368,124410],[124415,124415],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125127,125142],[125184,125259],[125264,125273],[125278,125279],[126065,126132],[126209,126269],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[126704,126705],[126976,127019],[127024,127123],[127136,127150],[127153,127167],[127169,127183],[127185,127221],[127232,127405],[127462,127490],[127504,127547],[127552,127560],[127568,127569],[127584,127589],[127744,128727],[128732,128748],[128752,128764],[128768,128886],[128891,128985],[128992,129003],[129008,129008],[129024,129035],[129040,129095],[129104,129113],[129120,129159],[129168,129197],[129200,129211],[129216,129217],[129280,129619],[129632,129645],[129648,129660],[129664,129673],[129679,129734],[129742,129756],[129759,129769],[129776,129784],[129792,129938],[129940,130041],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743],[917505,917505],[917536,917631],[917760,917999],[983040,1048573],[1048576,1114109]],"Binary_Property/Emoji_Modifier":[[127995,127999]],"Binary_Property/Noncharacter_Code_Point":[[64976,65007],[65534,65535],[131070,131071],[196606,196607],[262142,262143],[327678,327679],[393214,393215],[458750,458751],[524286,524287],[589822,589823],[655358,655359],[720894,720895],[786430,786431],[851966,851967],[917502,917503],[983038,983039],[1048574,1048575],[1114110,1114111]],"Binary_Property/Other_Alphabetic":[[837,837],[867,879],[1456,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1552,1562],[1611,1623],[1625,1631],[1648,1648],[1750,1756],[1761,1764],[1767,1768],[1773,1773],[1809,1809],[1840,1855],[1958,1968],[2070,2071],[2075,2083],[2085,2087],[2089,2092],[2199,2199],[2260,2271],[2275,2281],[2288,2307],[2362,2363],[2366,2380],[2382,2383],[2389,2391],[2402,2403],[2433,2435],[2494,2500],[2503,2504],[2507,2508],[2519,2519],[2530,2531],[2561,2563],[2622,2626],[2631,2632],[2635,2636],[2641,2641],[2672,2673],[2677,2677],[2689,2691],[2750,2757],[2759,2761],[2763,2764],[2786,2787],[2810,2812],[2817,2819],[2878,2884],[2887,2888],[2891,2892],[2902,2903],[2914,2915],[2946,2946],[3006,3010],[3014,3016],[3018,3020],[3031,3031],[3072,3076],[3134,3140],[3142,3144],[3146,3148],[3157,3158],[3170,3171],[3201,3203],[3262,3268],[3270,3272],[3274,3276],[3285,3286],[3298,3299],[3315,3315],[3328,3331],[3390,3396],[3398,3400],[3402,3404],[3415,3415],[3426,3427],[3457,3459],[3535,3540],[3542,3542],[3544,3551],[3570,3571],[3633,3633],[3636,3642],[3661,3661],[3761,3761],[3764,3769],[3771,3772],[3789,3789],[3953,3971],[3981,3991],[3993,4028],[4139,4150],[4152,4152],[4155,4158],[4182,4185],[4190,4192],[4194,4196],[4199,4205],[4209,4212],[4226,4237],[4239,4239],[4250,4253],[5906,5907],[5938,5939],[5970,5971],[6002,6003],[6070,6088],[6277,6278],[6313,6313],[6432,6443],[6448,6456],[6679,6683],[6741,6750],[6753,6772],[6847,6848],[6860,6862],[6912,6916],[6965,6979],[7040,7042],[7073,7081],[7084,7085],[7143,7153],[7204,7222],[7635,7668],[9398,9449],[11744,11775],[42612,42619],[42654,42655],[43010,43010],[43019,43019],[43043,43047],[43136,43137],[43188,43203],[43205,43205],[43263,43263],[43302,43306],[43335,43346],[43392,43395],[43444,43455],[43493,43493],[43561,43574],[43587,43587],[43596,43597],[43643,43645],[43696,43696],[43698,43700],[43703,43704],[43710,43710],[43755,43759],[43765,43765],[44003,44010],[64286,64286],[66422,66426],[68097,68099],[68101,68102],[68108,68111],[68900,68903],[68969,68969],[69291,69292],[69372,69372],[69632,69634],[69688,69701],[69747,69748],[69760,69762],[69808,69816],[69826,69826],[69888,69890],[69927,69938],[69957,69958],[70016,70018],[70067,70079],[70094,70095],[70188,70196],[70199,70199],[70206,70206],[70209,70209],[70367,70376],[70400,70403],[70462,70468],[70471,70472],[70475,70476],[70487,70487],[70498,70499],[70584,70592],[70594,70594],[70597,70597],[70599,70602],[70604,70605],[70709,70721],[70723,70725],[70832,70849],[71087,71093],[71096,71102],[71132,71133],[71216,71230],[71232,71232],[71339,71349],[71453,71466],[71724,71736],[71984,71989],[71991,71992],[71995,71996],[72000,72000],[72002,72002],[72145,72151],[72154,72159],[72164,72164],[72193,72202],[72245,72249],[72251,72254],[72273,72283],[72330,72343],[72751,72758],[72760,72766],[72850,72871],[72873,72886],[73009,73014],[73018,73018],[73020,73021],[73023,73025],[73027,73027],[73031,73031],[73098,73102],[73104,73105],[73107,73110],[73459,73462],[73472,73473],[73475,73475],[73524,73530],[73534,73536],[90398,90414],[94031,94031],[94033,94087],[94095,94098],[94192,94193],[113822,113822],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[123023,123023],[125255,125255],[127280,127305],[127312,127337],[127344,127369]],"Binary_Property/IDS_Unary_Operator":[[12286,12287]],"Binary_Property/ID_Compat_Math_Start":[[8706,8706],[8711,8711],[8734,8734],[120513,120513],[120539,120539],[120571,120571],[120597,120597],[120629,120629],[120655,120655],[120687,120687],[120713,120713],[120745,120745],[120771,120771]],"Binary_Property/Regional_Indicator":[[127462,127487]],"Binary_Property/Cased":[[65,90],[97,122],[170,170],[181,181],[186,186],[192,214],[216,246],[248,442],[444,447],[452,659],[661,696],[704,705],[736,740],[837,837],[880,883],[886,887],[890,893],[895,895],[902,902],[904,906],[908,908],[910,929],[931,1013],[1015,1153],[1162,1327],[1329,1366],[1376,1416],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4348,4351],[5024,5109],[5112,5117],[7296,7306],[7312,7354],[7357,7359],[7424,7615],[7680,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8305,8305],[8319,8319],[8336,8348],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8473,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8493],[8495,8500],[8505,8505],[8508,8511],[8517,8521],[8526,8526],[8544,8575],[8579,8580],[9398,9449],[11264,11492],[11499,11502],[11506,11507],[11520,11557],[11559,11559],[11565,11565],[42560,42605],[42624,42653],[42786,42887],[42891,42894],[42896,42957],[42960,42961],[42963,42963],[42965,42972],[42994,42998],[43000,43002],[43824,43866],[43868,43881],[43888,43967],[64256,64262],[64275,64279],[65313,65338],[65345,65370],[66560,66639],[66736,66771],[66776,66811],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67456,67456],[67459,67461],[67463,67504],[67506,67514],[68736,68786],[68800,68850],[68944,68965],[68976,68997],[71840,71903],[93760,93823],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[122624,122633],[122635,122654],[122661,122666],[122928,122989],[125184,125251],[127280,127305],[127312,127337],[127344,127369]],"Binary_Property/IDS_Trinary_Operator":[[12274,12275]],"Binary_Property/Expands_On_NFKD":[[168,168],[175,175],[180,180],[184,184],[188,190],[192,197],[199,207],[209,214],[217,221],[224,229],[231,239],[241,246],[249,253],[255,271],[274,293],[296,304],[306,311],[313,320],[323,329],[332,337],[340,357],[360,382],[416,417],[431,432],[452,476],[478,483],[486,501],[504,539],[542,543],[550,563],[728,733],[836,836],[890,890],[900,902],[904,906],[908,908],[910,912],[938,944],[970,974],[979,980],[1024,1025],[1027,1027],[1031,1031],[1036,1038],[1049,1049],[1081,1081],[1104,1105],[1107,1107],[1111,1111],[1116,1118],[1142,1143],[1217,1218],[1232,1235],[1238,1239],[1242,1247],[1250,1255],[1258,1269],[1272,1273],[1415,1415],[1570,1574],[1653,1656],[1728,1728],[1730,1730],[1747,1747],[2345,2345],[2353,2353],[2356,2356],[2392,2399],[2507,2508],[2524,2525],[2527,2527],[2611,2611],[2614,2614],[2649,2651],[2654,2654],[2888,2888],[2891,2892],[2908,2909],[2964,2964],[3018,3020],[3144,3144],[3264,3264],[3271,3272],[3274,3275],[3402,3404],[3546,3546],[3548,3550],[3635,3635],[3763,3763],[3804,3805],[3907,3907],[3917,3917],[3922,3922],[3927,3927],[3932,3932],[3945,3945],[3955,3955],[3957,3961],[3969,3969],[3987,3987],[3997,3997],[4002,4002],[4007,4007],[4012,4012],[4025,4025],[4134,4134],[6918,6918],[6920,6920],[6922,6922],[6924,6924],[6926,6926],[6930,6930],[6971,6971],[6973,6973],[6976,6977],[6979,6979],[7680,7835],[7840,7929],[7936,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8125],[8127,8132],[8134,8147],[8150,8155],[8157,8174],[8178,8180],[8182,8190],[8215,8215],[8229,8230],[8243,8244],[8246,8247],[8252,8252],[8254,8254],[8263,8265],[8279,8279],[8360,8360],[8448,8449],[8451,8451],[8453,8454],[8457,8457],[8470,8470],[8480,8482],[8491,8491],[8507,8507],[8528,8543],[8545,8547],[8549,8552],[8554,8555],[8561,8563],[8565,8568],[8570,8571],[8585,8585],[8602,8603],[8622,8622],[8653,8655],[8708,8708],[8713,8713],[8716,8716],[8740,8740],[8742,8742],[8748,8749],[8751,8752],[8769,8769],[8772,8772],[8775,8775],[8777,8777],[8800,8800],[8802,8802],[8813,8817],[8820,8821],[8824,8825],[8832,8833],[8836,8837],[8840,8841],[8876,8879],[8928,8931],[8938,8941],[9321,9397],[10764,10764],[10868,10870],[10972,10972],[12364,12364],[12366,12366],[12368,12368],[12370,12370],[12372,12372],[12374,12374],[12376,12376],[12378,12378],[12380,12380],[12382,12382],[12384,12384],[12386,12386],[12389,12389],[12391,12391],[12393,12393],[12400,12401],[12403,12404],[12406,12407],[12409,12410],[12412,12413],[12436,12436],[12443,12444],[12446,12447],[12460,12460],[12462,12462],[12464,12464],[12466,12466],[12468,12468],[12470,12470],[12472,12472],[12474,12474],[12476,12476],[12478,12478],[12480,12480],[12482,12482],[12485,12485],[12487,12487],[12489,12489],[12496,12497],[12499,12500],[12502,12503],[12505,12506],[12508,12509],[12532,12532],[12535,12538],[12542,12543],[12800,12830],[12832,12867],[12880,12895],[12910,12926],[12977,13007],[13055,13311],[44032,55203],[64256,64262],[64275,64279],[64285,64285],[64287,64287],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64335],[64420,64421],[64432,64433],[64477,64477],[64490,64507],[64512,64829],[64848,64911],[64914,64967],[65008,65020],[65049,65049],[65072,65072],[65097,65100],[65136,65138],[65140,65140],[65142,65151],[65153,65164],[65269,65276],[65507,65507],[67017,67017],[67044,67044],[69786,69786],[69788,69788],[69803,69803],[69934,69935],[70475,70476],[70531,70531],[70533,70533],[70542,70542],[70545,70545],[70597,70597],[70599,70600],[70843,70844],[70846,70846],[71098,71099],[71992,71992],[90401,90408],[93544,93546],[119134,119140],[119227,119232],[127232,127242],[127248,127274],[127277,127278],[127306,127311],[127338,127340],[127376,127376],[127488,127489],[127507,127507],[127552,127560]],"Binary_Property/Grapheme_Base":[[32,126],[160,172],[174,767],[880,887],[890,895],[900,906],[908,908],[910,929],[931,1154],[1162,1327],[1329,1366],[1369,1418],[1421,1423],[1470,1470],[1472,1472],[1475,1475],[1478,1478],[1488,1514],[1519,1524],[1542,1551],[1563,1563],[1565,1610],[1632,1647],[1649,1749],[1758,1758],[1765,1766],[1769,1769],[1774,1805],[1808,1808],[1810,1839],[1869,1957],[1969,1969],[1984,2026],[2036,2042],[2046,2069],[2074,2074],[2084,2084],[2088,2088],[2096,2110],[2112,2136],[2142,2142],[2144,2154],[2160,2190],[2208,2249],[2307,2361],[2363,2363],[2365,2368],[2377,2380],[2382,2384],[2392,2401],[2404,2432],[2434,2435],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2493,2493],[2495,2496],[2503,2504],[2507,2508],[2510,2510],[2524,2525],[2527,2529],[2534,2557],[2563,2563],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2622,2624],[2649,2652],[2654,2654],[2662,2671],[2674,2676],[2678,2678],[2691,2691],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2749,2752],[2761,2761],[2763,2764],[2768,2768],[2784,2785],[2790,2801],[2809,2809],[2818,2819],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2877,2877],[2880,2880],[2887,2888],[2891,2892],[2908,2909],[2911,2913],[2918,2935],[2947,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3007,3007],[3009,3010],[3014,3016],[3018,3020],[3024,3024],[3046,3066],[3073,3075],[3077,3084],[3086,3088],[3090,3112],[3114,3129],[3133,3133],[3137,3140],[3160,3162],[3165,3165],[3168,3169],[3174,3183],[3191,3200],[3202,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3261,3262],[3265,3265],[3267,3268],[3293,3294],[3296,3297],[3302,3311],[3313,3315],[3330,3340],[3342,3344],[3346,3386],[3389,3389],[3391,3392],[3398,3400],[3402,3404],[3406,3407],[3412,3414],[3416,3425],[3430,3455],[3458,3459],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3536,3537],[3544,3550],[3558,3567],[3570,3572],[3585,3632],[3634,3635],[3647,3654],[3663,3675],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3760],[3762,3763],[3773,3773],[3776,3780],[3782,3782],[3792,3801],[3804,3807],[3840,3863],[3866,3892],[3894,3894],[3896,3896],[3898,3911],[3913,3948],[3967,3967],[3973,3973],[3976,3980],[4030,4037],[4039,4044],[4046,4058],[4096,4140],[4145,4145],[4152,4152],[4155,4156],[4159,4183],[4186,4189],[4193,4208],[4213,4225],[4227,4228],[4231,4236],[4238,4252],[4254,4293],[4295,4295],[4301,4301],[4304,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4960,4988],[4992,5017],[5024,5109],[5112,5117],[5120,5788],[5792,5880],[5888,5905],[5919,5937],[5941,5942],[5952,5969],[5984,5996],[5998,6000],[6016,6067],[6070,6070],[6078,6085],[6087,6088],[6100,6108],[6112,6121],[6128,6137],[6144,6154],[6160,6169],[6176,6264],[6272,6276],[6279,6312],[6314,6314],[6320,6389],[6400,6430],[6435,6438],[6441,6443],[6448,6449],[6451,6456],[6464,6464],[6468,6509],[6512,6516],[6528,6571],[6576,6601],[6608,6618],[6622,6678],[6681,6682],[6686,6741],[6743,6743],[6753,6753],[6755,6756],[6765,6770],[6784,6793],[6800,6809],[6816,6829],[6916,6963],[6974,6977],[6981,6988],[6990,7018],[7028,7039],[7042,7073],[7078,7079],[7086,7141],[7143,7143],[7146,7148],[7150,7150],[7164,7211],[7220,7221],[7227,7241],[7245,7306],[7312,7354],[7357,7367],[7379,7379],[7393,7393],[7401,7404],[7406,7411],[7413,7415],[7418,7418],[7424,7615],[7680,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8132],[8134,8147],[8150,8155],[8157,8175],[8178,8180],[8182,8190],[8192,8202],[8208,8231],[8239,8287],[8304,8305],[8308,8334],[8336,8348],[8352,8384],[8448,8587],[8592,9257],[9280,9290],[9312,11123],[11126,11157],[11159,11502],[11506,11507],[11513,11557],[11559,11559],[11565,11565],[11568,11623],[11631,11632],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[11776,11869],[11904,11929],[11931,12019],[12032,12245],[12272,12329],[12336,12351],[12353,12438],[12443,12543],[12549,12591],[12593,12686],[12688,12773],[12783,12830],[12832,42124],[42128,42182],[42192,42539],[42560,42606],[42611,42611],[42622,42653],[42656,42735],[42738,42743],[42752,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43009],[43011,43013],[43015,43018],[43020,43044],[43047,43051],[43056,43065],[43072,43127],[43136,43203],[43214,43225],[43250,43262],[43264,43301],[43310,43334],[43346,43346],[43359,43388],[43395,43442],[43444,43445],[43450,43451],[43454,43455],[43457,43469],[43471,43481],[43486,43492],[43494,43518],[43520,43560],[43567,43568],[43571,43572],[43584,43586],[43588,43595],[43597,43597],[43600,43609],[43612,43643],[43645,43695],[43697,43697],[43701,43702],[43705,43709],[43712,43712],[43714,43714],[43739,43755],[43758,43765],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43883],[43888,44004],[44006,44007],[44009,44012],[44016,44025],[44032,55203],[55216,55238],[55243,55291],[63744,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64285],[64287,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64450],[64467,64911],[64914,64967],[64975,64975],[65008,65023],[65040,65049],[65072,65106],[65108,65126],[65128,65131],[65136,65140],[65142,65276],[65281,65437],[65440,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65504,65510],[65512,65518],[65532,65533],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65792,65794],[65799,65843],[65847,65934],[65936,65948],[65952,65952],[66000,66044],[66176,66204],[66208,66256],[66273,66299],[66304,66339],[66349,66378],[66384,66421],[66432,66461],[66463,66499],[66504,66517],[66560,66717],[66720,66729],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66927,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67671,67742],[67751,67759],[67808,67826],[67828,67829],[67835,67867],[67871,67897],[67903,67903],[67968,68023],[68028,68047],[68050,68096],[68112,68115],[68117,68119],[68121,68149],[68160,68168],[68176,68184],[68192,68255],[68288,68324],[68331,68342],[68352,68405],[68409,68437],[68440,68466],[68472,68497],[68505,68508],[68521,68527],[68608,68680],[68736,68786],[68800,68850],[68858,68899],[68912,68921],[68928,68965],[68974,68997],[69006,69007],[69216,69246],[69248,69289],[69293,69293],[69296,69297],[69314,69316],[69376,69415],[69424,69445],[69457,69465],[69488,69505],[69510,69513],[69552,69579],[69600,69622],[69632,69632],[69634,69687],[69703,69709],[69714,69743],[69745,69746],[69749,69749],[69762,69810],[69815,69816],[69819,69820],[69822,69825],[69840,69864],[69872,69881],[69891,69926],[69932,69932],[69942,69959],[69968,70002],[70004,70006],[70018,70069],[70079,70079],[70081,70088],[70093,70094],[70096,70111],[70113,70132],[70144,70161],[70163,70190],[70194,70195],[70200,70205],[70207,70208],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70313],[70320,70366],[70368,70370],[70384,70393],[70402,70403],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70461,70461],[70463,70463],[70465,70468],[70471,70472],[70475,70476],[70480,70480],[70493,70499],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70583],[70585,70586],[70602,70602],[70604,70605],[70609,70609],[70611,70613],[70615,70616],[70656,70711],[70720,70721],[70725,70725],[70727,70747],[70749,70749],[70751,70753],[70784,70831],[70833,70834],[70841,70841],[70843,70844],[70846,70846],[70849,70849],[70852,70855],[70864,70873],[71040,71086],[71088,71089],[71096,71099],[71102,71102],[71105,71131],[71168,71218],[71227,71228],[71230,71230],[71233,71236],[71248,71257],[71264,71276],[71296,71338],[71340,71340],[71342,71343],[71352,71353],[71360,71369],[71376,71395],[71424,71450],[71454,71454],[71456,71457],[71462,71462],[71472,71494],[71680,71726],[71736,71736],[71739,71739],[71840,71922],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71983],[71985,71989],[71991,71992],[71999,72002],[72004,72006],[72016,72025],[72096,72103],[72106,72147],[72156,72159],[72161,72164],[72192,72192],[72203,72242],[72249,72250],[72255,72262],[72272,72272],[72279,72280],[72284,72329],[72343,72343],[72346,72354],[72368,72440],[72448,72457],[72640,72673],[72688,72697],[72704,72712],[72714,72751],[72766,72766],[72768,72773],[72784,72812],[72816,72847],[72873,72873],[72881,72881],[72884,72884],[72960,72966],[72968,72969],[72971,73008],[73030,73030],[73040,73049],[73056,73061],[73063,73064],[73066,73102],[73107,73108],[73110,73110],[73112,73112],[73120,73129],[73440,73458],[73461,73464],[73474,73488],[73490,73525],[73534,73535],[73539,73561],[73648,73648],[73664,73713],[73727,74649],[74752,74862],[74864,74868],[74880,75075],[77712,77810],[77824,78895],[78913,78918],[78944,82938],[82944,83526],[90368,90397],[90410,90412],[90416,90425],[92160,92728],[92736,92766],[92768,92777],[92782,92862],[92864,92873],[92880,92909],[92917,92917],[92928,92975],[92983,92997],[93008,93017],[93019,93025],[93027,93047],[93053,93071],[93504,93561],[93760,93850],[93952,94026],[94032,94087],[94099,94111],[94176,94179],[94208,100343],[100352,101589],[101631,101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[113820,113820],[113823,113823],[117760,118009],[118016,118451],[118608,118723],[118784,119029],[119040,119078],[119081,119140],[119146,119148],[119171,119172],[119180,119209],[119214,119274],[119296,119361],[119365,119365],[119488,119507],[119520,119539],[119552,119638],[119648,119672],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120779],[120782,121343],[121399,121402],[121453,121460],[121462,121475],[121477,121483],[122624,122654],[122661,122666],[122928,122989],[123136,123180],[123191,123197],[123200,123209],[123214,123215],[123536,123565],[123584,123627],[123632,123641],[123647,123647],[124112,124139],[124144,124153],[124368,124397],[124400,124410],[124415,124415],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125127,125135],[125184,125251],[125259,125259],[125264,125273],[125278,125279],[126065,126132],[126209,126269],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[126704,126705],[126976,127019],[127024,127123],[127136,127150],[127153,127167],[127169,127183],[127185,127221],[127232,127405],[127462,127490],[127504,127547],[127552,127560],[127568,127569],[127584,127589],[127744,128727],[128732,128748],[128752,128764],[128768,128886],[128891,128985],[128992,129003],[129008,129008],[129024,129035],[129040,129095],[129104,129113],[129120,129159],[129168,129197],[129200,129211],[129216,129217],[129280,129619],[129632,129645],[129648,129660],[129664,129673],[129679,129734],[129742,129756],[129759,129769],[129776,129784],[129792,129938],[129940,130041],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"Binary_Property/Expands_On_NFD":[[192,197],[199,207],[209,214],[217,221],[224,229],[231,239],[241,246],[249,253],[255,271],[274,293],[296,304],[308,311],[313,318],[323,328],[332,337],[340,357],[360,382],[416,417],[431,432],[461,476],[478,483],[486,496],[500,501],[504,539],[542,543],[550,563],[836,836],[901,902],[904,906],[908,908],[910,912],[938,944],[970,974],[979,980],[1024,1025],[1027,1027],[1031,1031],[1036,1038],[1049,1049],[1081,1081],[1104,1105],[1107,1107],[1111,1111],[1116,1118],[1142,1143],[1217,1218],[1232,1235],[1238,1239],[1242,1247],[1250,1255],[1258,1269],[1272,1273],[1570,1574],[1728,1728],[1730,1730],[1747,1747],[2345,2345],[2353,2353],[2356,2356],[2392,2399],[2507,2508],[2524,2525],[2527,2527],[2611,2611],[2614,2614],[2649,2651],[2654,2654],[2888,2888],[2891,2892],[2908,2909],[2964,2964],[3018,3020],[3144,3144],[3264,3264],[3271,3272],[3274,3275],[3402,3404],[3546,3546],[3548,3550],[3907,3907],[3917,3917],[3922,3922],[3927,3927],[3932,3932],[3945,3945],[3955,3955],[3957,3958],[3960,3960],[3969,3969],[3987,3987],[3997,3997],[4002,4002],[4007,4007],[4012,4012],[4025,4025],[4134,4134],[6918,6918],[6920,6920],[6922,6922],[6924,6924],[6926,6926],[6930,6930],[6971,6971],[6973,6973],[6976,6977],[6979,6979],[7680,7833],[7835,7835],[7840,7929],[7936,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8129,8132],[8134,8147],[8150,8155],[8157,8174],[8178,8180],[8182,8188],[8491,8491],[8602,8603],[8622,8622],[8653,8655],[8708,8708],[8713,8713],[8716,8716],[8740,8740],[8742,8742],[8769,8769],[8772,8772],[8775,8775],[8777,8777],[8800,8800],[8802,8802],[8813,8817],[8820,8821],[8824,8825],[8832,8833],[8836,8837],[8840,8841],[8876,8879],[8928,8931],[8938,8941],[10972,10972],[12364,12364],[12366,12366],[12368,12368],[12370,12370],[12372,12372],[12374,12374],[12376,12376],[12378,12378],[12380,12380],[12382,12382],[12384,12384],[12386,12386],[12389,12389],[12391,12391],[12393,12393],[12400,12401],[12403,12404],[12406,12407],[12409,12410],[12412,12413],[12436,12436],[12446,12446],[12460,12460],[12462,12462],[12464,12464],[12466,12466],[12468,12468],[12470,12470],[12472,12472],[12474,12474],[12476,12476],[12478,12478],[12480,12480],[12482,12482],[12485,12485],[12487,12487],[12489,12489],[12496,12497],[12499,12500],[12502,12503],[12505,12506],[12508,12509],[12532,12532],[12535,12538],[12542,12542],[44032,55203],[64285,64285],[64287,64287],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64334],[67017,67017],[67044,67044],[69786,69786],[69788,69788],[69803,69803],[69934,69935],[70475,70476],[70531,70531],[70533,70533],[70542,70542],[70545,70545],[70597,70597],[70599,70600],[70843,70844],[70846,70846],[71098,71099],[71992,71992],[90401,90408],[93544,93546],[119134,119140],[119227,119232]],"Binary_Property/Other_Default_Ignorable_Code_Point":[[847,847],[4447,4448],[6068,6069],[8293,8293],[12644,12644],[65440,65440],[65520,65528],[917504,917504],[917506,917535],[917632,917759],[918000,921599]],"Binary_Property/ASCII_Hex_Digit":[[48,57],[65,70],[97,102]],"Binary_Property/White_Space":[[9,13],[32,32],[133,133],[160,160],[5760,5760],[8192,8202],[8232,8233],[8239,8239],[8287,8287],[12288,12288]],"Binary_Property/Changes_When_Uppercased":[[97,122],[181,181],[223,246],[248,255],[257,257],[259,259],[261,261],[263,263],[265,265],[267,267],[269,269],[271,271],[273,273],[275,275],[277,277],[279,279],[281,281],[283,283],[285,285],[287,287],[289,289],[291,291],[293,293],[295,295],[297,297],[299,299],[301,301],[303,303],[305,305],[307,307],[309,309],[311,311],[314,314],[316,316],[318,318],[320,320],[322,322],[324,324],[326,326],[328,329],[331,331],[333,333],[335,335],[337,337],[339,339],[341,341],[343,343],[345,345],[347,347],[349,349],[351,351],[353,353],[355,355],[357,357],[359,359],[361,361],[363,363],[365,365],[367,367],[369,369],[371,371],[373,373],[375,375],[378,378],[380,380],[382,384],[387,387],[389,389],[392,392],[396,396],[402,402],[405,405],[409,411],[414,414],[417,417],[419,419],[421,421],[424,424],[429,429],[432,432],[436,436],[438,438],[441,441],[445,445],[447,447],[453,454],[456,457],[459,460],[462,462],[464,464],[466,466],[468,468],[470,470],[472,472],[474,474],[476,477],[479,479],[481,481],[483,483],[485,485],[487,487],[489,489],[491,491],[493,493],[495,496],[498,499],[501,501],[505,505],[507,507],[509,509],[511,511],[513,513],[515,515],[517,517],[519,519],[521,521],[523,523],[525,525],[527,527],[529,529],[531,531],[533,533],[535,535],[537,537],[539,539],[541,541],[543,543],[547,547],[549,549],[551,551],[553,553],[555,555],[557,557],[559,559],[561,561],[563,563],[572,572],[575,576],[578,578],[583,583],[585,585],[587,587],[589,589],[591,596],[598,599],[601,601],[603,604],[608,609],[611,614],[616,620],[623,623],[625,626],[629,629],[637,637],[640,640],[642,643],[647,652],[658,658],[669,670],[837,837],[881,881],[883,883],[887,887],[891,893],[912,912],[940,974],[976,977],[981,983],[985,985],[987,987],[989,989],[991,991],[993,993],[995,995],[997,997],[999,999],[1001,1001],[1003,1003],[1005,1005],[1007,1011],[1013,1013],[1016,1016],[1019,1019],[1072,1119],[1121,1121],[1123,1123],[1125,1125],[1127,1127],[1129,1129],[1131,1131],[1133,1133],[1135,1135],[1137,1137],[1139,1139],[1141,1141],[1143,1143],[1145,1145],[1147,1147],[1149,1149],[1151,1151],[1153,1153],[1163,1163],[1165,1165],[1167,1167],[1169,1169],[1171,1171],[1173,1173],[1175,1175],[1177,1177],[1179,1179],[1181,1181],[1183,1183],[1185,1185],[1187,1187],[1189,1189],[1191,1191],[1193,1193],[1195,1195],[1197,1197],[1199,1199],[1201,1201],[1203,1203],[1205,1205],[1207,1207],[1209,1209],[1211,1211],[1213,1213],[1215,1215],[1218,1218],[1220,1220],[1222,1222],[1224,1224],[1226,1226],[1228,1228],[1230,1231],[1233,1233],[1235,1235],[1237,1237],[1239,1239],[1241,1241],[1243,1243],[1245,1245],[1247,1247],[1249,1249],[1251,1251],[1253,1253],[1255,1255],[1257,1257],[1259,1259],[1261,1261],[1263,1263],[1265,1265],[1267,1267],[1269,1269],[1271,1271],[1273,1273],[1275,1275],[1277,1277],[1279,1279],[1281,1281],[1283,1283],[1285,1285],[1287,1287],[1289,1289],[1291,1291],[1293,1293],[1295,1295],[1297,1297],[1299,1299],[1301,1301],[1303,1303],[1305,1305],[1307,1307],[1309,1309],[1311,1311],[1313,1313],[1315,1315],[1317,1317],[1319,1319],[1321,1321],[1323,1323],[1325,1325],[1327,1327],[1377,1415],[4304,4346],[4349,4351],[5112,5117],[7296,7304],[7306,7306],[7545,7545],[7549,7549],[7566,7566],[7681,7681],[7683,7683],[7685,7685],[7687,7687],[7689,7689],[7691,7691],[7693,7693],[7695,7695],[7697,7697],[7699,7699],[7701,7701],[7703,7703],[7705,7705],[7707,7707],[7709,7709],[7711,7711],[7713,7713],[7715,7715],[7717,7717],[7719,7719],[7721,7721],[7723,7723],[7725,7725],[7727,7727],[7729,7729],[7731,7731],[7733,7733],[7735,7735],[7737,7737],[7739,7739],[7741,7741],[7743,7743],[7745,7745],[7747,7747],[7749,7749],[7751,7751],[7753,7753],[7755,7755],[7757,7757],[7759,7759],[7761,7761],[7763,7763],[7765,7765],[7767,7767],[7769,7769],[7771,7771],[7773,7773],[7775,7775],[7777,7777],[7779,7779],[7781,7781],[7783,7783],[7785,7785],[7787,7787],[7789,7789],[7791,7791],[7793,7793],[7795,7795],[7797,7797],[7799,7799],[7801,7801],[7803,7803],[7805,7805],[7807,7807],[7809,7809],[7811,7811],[7813,7813],[7815,7815],[7817,7817],[7819,7819],[7821,7821],[7823,7823],[7825,7825],[7827,7827],[7829,7835],[7841,7841],[7843,7843],[7845,7845],[7847,7847],[7849,7849],[7851,7851],[7853,7853],[7855,7855],[7857,7857],[7859,7859],[7861,7861],[7863,7863],[7865,7865],[7867,7867],[7869,7869],[7871,7871],[7873,7873],[7875,7875],[7877,7877],[7879,7879],[7881,7881],[7883,7883],[7885,7885],[7887,7887],[7889,7889],[7891,7891],[7893,7893],[7895,7895],[7897,7897],[7899,7899],[7901,7901],[7903,7903],[7905,7905],[7907,7907],[7909,7909],[7911,7911],[7913,7913],[7915,7915],[7917,7917],[7919,7919],[7921,7921],[7923,7923],[7925,7925],[7927,7927],[7929,7929],[7931,7931],[7933,7933],[7935,7943],[7952,7957],[7968,7975],[7984,7991],[8000,8005],[8016,8023],[8032,8039],[8048,8061],[8064,8116],[8118,8119],[8124,8124],[8126,8126],[8130,8132],[8134,8135],[8140,8140],[8144,8147],[8150,8151],[8160,8167],[8178,8180],[8182,8183],[8188,8188],[8526,8526],[8560,8575],[8580,8580],[9424,9449],[11312,11359],[11361,11361],[11365,11366],[11368,11368],[11370,11370],[11372,11372],[11379,11379],[11382,11382],[11393,11393],[11395,11395],[11397,11397],[11399,11399],[11401,11401],[11403,11403],[11405,11405],[11407,11407],[11409,11409],[11411,11411],[11413,11413],[11415,11415],[11417,11417],[11419,11419],[11421,11421],[11423,11423],[11425,11425],[11427,11427],[11429,11429],[11431,11431],[11433,11433],[11435,11435],[11437,11437],[11439,11439],[11441,11441],[11443,11443],[11445,11445],[11447,11447],[11449,11449],[11451,11451],[11453,11453],[11455,11455],[11457,11457],[11459,11459],[11461,11461],[11463,11463],[11465,11465],[11467,11467],[11469,11469],[11471,11471],[11473,11473],[11475,11475],[11477,11477],[11479,11479],[11481,11481],[11483,11483],[11485,11485],[11487,11487],[11489,11489],[11491,11491],[11500,11500],[11502,11502],[11507,11507],[11520,11557],[11559,11559],[11565,11565],[42561,42561],[42563,42563],[42565,42565],[42567,42567],[42569,42569],[42571,42571],[42573,42573],[42575,42575],[42577,42577],[42579,42579],[42581,42581],[42583,42583],[42585,42585],[42587,42587],[42589,42589],[42591,42591],[42593,42593],[42595,42595],[42597,42597],[42599,42599],[42601,42601],[42603,42603],[42605,42605],[42625,42625],[42627,42627],[42629,42629],[42631,42631],[42633,42633],[42635,42635],[42637,42637],[42639,42639],[42641,42641],[42643,42643],[42645,42645],[42647,42647],[42649,42649],[42651,42651],[42787,42787],[42789,42789],[42791,42791],[42793,42793],[42795,42795],[42797,42797],[42799,42799],[42803,42803],[42805,42805],[42807,42807],[42809,42809],[42811,42811],[42813,42813],[42815,42815],[42817,42817],[42819,42819],[42821,42821],[42823,42823],[42825,42825],[42827,42827],[42829,42829],[42831,42831],[42833,42833],[42835,42835],[42837,42837],[42839,42839],[42841,42841],[42843,42843],[42845,42845],[42847,42847],[42849,42849],[42851,42851],[42853,42853],[42855,42855],[42857,42857],[42859,42859],[42861,42861],[42863,42863],[42874,42874],[42876,42876],[42879,42879],[42881,42881],[42883,42883],[42885,42885],[42887,42887],[42892,42892],[42897,42897],[42899,42900],[42903,42903],[42905,42905],[42907,42907],[42909,42909],[42911,42911],[42913,42913],[42915,42915],[42917,42917],[42919,42919],[42921,42921],[42933,42933],[42935,42935],[42937,42937],[42939,42939],[42941,42941],[42943,42943],[42945,42945],[42947,42947],[42952,42952],[42954,42954],[42957,42957],[42961,42961],[42967,42967],[42969,42969],[42971,42971],[42998,42998],[43859,43859],[43888,43967],[64256,64262],[64275,64279],[65345,65370],[66600,66639],[66776,66811],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[68800,68850],[68976,68997],[71872,71903],[93792,93823],[125218,125251]],"Binary_Property/Other_Uppercase":[[8544,8559],[9398,9423],[127280,127305],[127312,127337],[127344,127369]],"Binary_Property/Alphabetic":[[65,90],[97,122],[170,170],[181,181],[186,186],[192,214],[216,246],[248,705],[710,721],[736,740],[748,748],[750,750],[837,837],[867,884],[886,887],[890,893],[895,895],[902,902],[904,906],[908,908],[910,929],[931,1013],[1015,1153],[1162,1327],[1329,1366],[1369,1369],[1376,1416],[1456,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1488,1514],[1519,1522],[1552,1562],[1568,1623],[1625,1631],[1646,1747],[1749,1756],[1761,1768],[1773,1775],[1786,1788],[1791,1791],[1808,1855],[1869,1969],[1994,2026],[2036,2037],[2042,2042],[2048,2071],[2074,2092],[2112,2136],[2144,2154],[2160,2183],[2185,2190],[2199,2199],[2208,2249],[2260,2271],[2275,2281],[2288,2363],[2365,2380],[2382,2384],[2389,2403],[2417,2435],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2493,2500],[2503,2504],[2507,2508],[2510,2510],[2519,2519],[2524,2525],[2527,2531],[2544,2545],[2556,2556],[2561,2563],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2622,2626],[2631,2632],[2635,2636],[2641,2641],[2649,2652],[2654,2654],[2672,2677],[2689,2691],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2749,2757],[2759,2761],[2763,2764],[2768,2768],[2784,2787],[2809,2812],[2817,2819],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2877,2884],[2887,2888],[2891,2892],[2902,2903],[2908,2909],[2911,2915],[2929,2929],[2946,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3006,3010],[3014,3016],[3018,3020],[3024,3024],[3031,3031],[3072,3084],[3086,3088],[3090,3112],[3114,3129],[3133,3140],[3142,3144],[3146,3148],[3157,3158],[3160,3162],[3165,3165],[3168,3171],[3200,3203],[3205,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3261,3268],[3270,3272],[3274,3276],[3285,3286],[3293,3294],[3296,3299],[3313,3315],[3328,3340],[3342,3344],[3346,3386],[3389,3396],[3398,3400],[3402,3404],[3406,3406],[3412,3415],[3423,3427],[3450,3455],[3457,3459],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3535,3540],[3542,3542],[3544,3551],[3570,3571],[3585,3642],[3648,3654],[3661,3661],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3769],[3771,3773],[3776,3780],[3782,3782],[3789,3789],[3804,3807],[3840,3840],[3904,3911],[3913,3948],[3953,3971],[3976,3991],[3993,4028],[4096,4150],[4152,4152],[4155,4159],[4176,4239],[4250,4253],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4348,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4992,5007],[5024,5109],[5112,5117],[5121,5740],[5743,5759],[5761,5786],[5792,5866],[5870,5880],[5888,5907],[5919,5939],[5952,5971],[5984,5996],[5998,6000],[6002,6003],[6016,6067],[6070,6088],[6103,6103],[6108,6108],[6176,6264],[6272,6314],[6320,6389],[6400,6430],[6432,6443],[6448,6456],[6480,6509],[6512,6516],[6528,6571],[6576,6601],[6656,6683],[6688,6750],[6753,6772],[6823,6823],[6847,6848],[6860,6862],[6912,6963],[6965,6979],[6981,6988],[7040,7081],[7084,7087],[7098,7141],[7143,7153],[7168,7222],[7245,7247],[7258,7293],[7296,7306],[7312,7354],[7357,7359],[7401,7404],[7406,7411],[7413,7414],[7418,7418],[7424,7615],[7635,7668],[7680,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8305,8305],[8319,8319],[8336,8348],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8473,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8493],[8495,8505],[8508,8511],[8517,8521],[8526,8526],[8544,8584],[9398,9449],[11264,11492],[11499,11502],[11506,11507],[11520,11557],[11559,11559],[11565,11565],[11568,11623],[11631,11631],[11648,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[11744,11775],[11823,11823],[12293,12295],[12321,12329],[12337,12341],[12344,12348],[12353,12438],[12445,12447],[12449,12538],[12540,12543],[12549,12591],[12593,12686],[12704,12735],[12784,12799],[13312,19903],[19968,42124],[42192,42237],[42240,42508],[42512,42527],[42538,42539],[42560,42606],[42612,42619],[42623,42735],[42775,42783],[42786,42888],[42891,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43013],[43015,43047],[43072,43123],[43136,43203],[43205,43205],[43250,43255],[43259,43259],[43261,43263],[43274,43306],[43312,43346],[43360,43388],[43392,43442],[43444,43455],[43471,43471],[43488,43503],[43514,43518],[43520,43574],[43584,43597],[43616,43638],[43642,43710],[43712,43712],[43714,43714],[43739,43741],[43744,43759],[43762,43765],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43866],[43868,43881],[43888,44010],[44032,55203],[55216,55238],[55243,55291],[63744,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64296],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64829],[64848,64911],[64914,64967],[65008,65019],[65136,65140],[65142,65276],[65313,65338],[65345,65370],[65382,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65856,65908],[66176,66204],[66208,66256],[66304,66335],[66349,66378],[66384,66426],[66432,66461],[66464,66499],[66504,66511],[66513,66517],[66560,66717],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67680,67702],[67712,67742],[67808,67826],[67828,67829],[67840,67861],[67872,67897],[67968,68023],[68030,68031],[68096,68099],[68101,68102],[68108,68115],[68117,68119],[68121,68149],[68192,68220],[68224,68252],[68288,68295],[68297,68324],[68352,68405],[68416,68437],[68448,68466],[68480,68497],[68608,68680],[68736,68786],[68800,68850],[68864,68903],[68938,68965],[68969,68969],[68975,68997],[69248,69289],[69291,69292],[69296,69297],[69314,69316],[69372,69372],[69376,69404],[69415,69415],[69424,69445],[69488,69505],[69552,69572],[69600,69622],[69632,69701],[69745,69749],[69760,69816],[69826,69826],[69840,69864],[69888,69938],[69956,69959],[69968,70002],[70006,70006],[70016,70079],[70081,70084],[70094,70095],[70106,70106],[70108,70108],[70144,70161],[70163,70196],[70199,70199],[70206,70209],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70312],[70320,70376],[70400,70403],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70461,70468],[70471,70472],[70475,70476],[70480,70480],[70487,70487],[70493,70499],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70592],[70594,70594],[70597,70597],[70599,70602],[70604,70605],[70609,70609],[70611,70611],[70656,70721],[70723,70725],[70727,70730],[70751,70753],[70784,70849],[70852,70853],[70855,70855],[71040,71093],[71096,71102],[71128,71133],[71168,71230],[71232,71232],[71236,71236],[71296,71349],[71352,71352],[71424,71450],[71453,71466],[71488,71494],[71680,71736],[71840,71903],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71989],[71991,71992],[71995,71996],[71999,72002],[72096,72103],[72106,72151],[72154,72159],[72161,72161],[72163,72164],[72192,72242],[72245,72254],[72272,72343],[72349,72349],[72368,72440],[72640,72672],[72704,72712],[72714,72758],[72760,72766],[72768,72768],[72818,72847],[72850,72871],[72873,72886],[72960,72966],[72968,72969],[72971,73014],[73018,73018],[73020,73021],[73023,73025],[73027,73027],[73030,73031],[73056,73061],[73063,73064],[73066,73102],[73104,73105],[73107,73110],[73112,73112],[73440,73462],[73472,73488],[73490,73530],[73534,73536],[73648,73648],[73728,74649],[74752,74862],[74880,75075],[77712,77808],[77824,78895],[78913,78918],[78944,82938],[82944,83526],[90368,90414],[92160,92728],[92736,92766],[92784,92862],[92880,92909],[92928,92975],[92992,92995],[93027,93047],[93053,93071],[93504,93548],[93760,93823],[93952,94026],[94031,94087],[94095,94111],[94176,94177],[94179,94179],[94192,94193],[94208,100343],[100352,101589],[101631,101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[113822,113822],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[122624,122654],[122661,122666],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[122928,122989],[123023,123023],[123136,123180],[123191,123197],[123214,123214],[123536,123565],[123584,123627],[124112,124139],[124368,124397],[124400,124400],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125184,125251],[125255,125255],[125259,125259],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[127280,127305],[127312,127337],[127344,127369],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743]],"Binary_Property/Composition_Exclusion":[[2392,2399],[2524,2525],[2527,2527],[2611,2611],[2614,2614],[2649,2651],[2654,2654],[2908,2909],[3907,3907],[3917,3917],[3922,3922],[3927,3927],[3932,3932],[3945,3945],[3958,3958],[3960,3960],[3987,3987],[3997,3997],[4002,4002],[4007,4007],[4012,4012],[4025,4025],[10972,10972],[64285,64285],[64287,64287],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64334],[119134,119140],[119227,119232]],"Binary_Property/Variation_Selector":[[6155,6157],[6159,6159],[65024,65039],[917760,917999]],"Binary_Property/Other_Math":[[94,94],[976,978],[981,981],[1008,1009],[1012,1013],[8214,8214],[8242,8244],[8256,8256],[8289,8292],[8317,8318],[8333,8334],[8400,8412],[8417,8417],[8421,8422],[8427,8431],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8473,8477],[8484,8484],[8488,8489],[8492,8493],[8495,8497],[8499,8504],[8508,8511],[8517,8521],[8597,8601],[8604,8607],[8609,8610],[8612,8613],[8615,8615],[8617,8621],[8624,8625],[8630,8631],[8636,8653],[8656,8657],[8659,8659],[8661,8667],[8669,8669],[8676,8677],[8968,8971],[9140,9141],[9143,9143],[9168,9168],[9186,9186],[9632,9633],[9646,9654],[9660,9664],[9670,9671],[9674,9675],[9679,9683],[9698,9698],[9700,9700],[9703,9708],[9733,9734],[9792,9792],[9794,9794],[9824,9827],[9837,9838],[10181,10182],[10214,10223],[10627,10648],[10712,10715],[10748,10749],[65121,65121],[65123,65123],[65128,65128],[65340,65340],[65342,65342],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[120782,120831],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651]],"Binary_Property/Dash":[[45,45],[1418,1418],[1470,1470],[5120,5120],[6150,6150],[8208,8213],[8275,8275],[8315,8315],[8331,8331],[8722,8722],[11799,11799],[11802,11802],[11834,11835],[11840,11840],[11869,11869],[12316,12316],[12336,12336],[12448,12448],[65073,65074],[65112,65112],[65123,65123],[65293,65293],[68974,68974],[69293,69293]],"Binary_Property/ID_Continue":[[48,57],[65,90],[95,95],[97,122],[170,170],[181,181],[183,183],[186,186],[192,214],[216,246],[248,705],[710,721],[736,740],[748,748],[750,750],[768,884],[886,887],[890,893],[895,895],[902,906],[908,908],[910,929],[931,1013],[1015,1153],[1155,1159],[1162,1327],[1329,1366],[1369,1369],[1376,1416],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1488,1514],[1519,1522],[1552,1562],[1568,1641],[1646,1747],[1749,1756],[1759,1768],[1770,1788],[1791,1791],[1808,1866],[1869,1969],[1984,2037],[2042,2042],[2045,2045],[2048,2093],[2112,2139],[2144,2154],[2160,2183],[2185,2190],[2199,2273],[2275,2403],[2406,2415],[2417,2435],[2437,2444],[2447,2448],[2451,2472],[2474,2480],[2482,2482],[2486,2489],[2492,2500],[2503,2504],[2507,2510],[2519,2519],[2524,2525],[2527,2531],[2534,2545],[2556,2556],[2558,2558],[2561,2563],[2565,2570],[2575,2576],[2579,2600],[2602,2608],[2610,2611],[2613,2614],[2616,2617],[2620,2620],[2622,2626],[2631,2632],[2635,2637],[2641,2641],[2649,2652],[2654,2654],[2662,2677],[2689,2691],[2693,2701],[2703,2705],[2707,2728],[2730,2736],[2738,2739],[2741,2745],[2748,2757],[2759,2761],[2763,2765],[2768,2768],[2784,2787],[2790,2799],[2809,2815],[2817,2819],[2821,2828],[2831,2832],[2835,2856],[2858,2864],[2866,2867],[2869,2873],[2876,2884],[2887,2888],[2891,2893],[2901,2903],[2908,2909],[2911,2915],[2918,2927],[2929,2929],[2946,2947],[2949,2954],[2958,2960],[2962,2965],[2969,2970],[2972,2972],[2974,2975],[2979,2980],[2984,2986],[2990,3001],[3006,3010],[3014,3016],[3018,3021],[3024,3024],[3031,3031],[3046,3055],[3072,3084],[3086,3088],[3090,3112],[3114,3129],[3132,3140],[3142,3144],[3146,3149],[3157,3158],[3160,3162],[3165,3165],[3168,3171],[3174,3183],[3200,3203],[3205,3212],[3214,3216],[3218,3240],[3242,3251],[3253,3257],[3260,3268],[3270,3272],[3274,3277],[3285,3286],[3293,3294],[3296,3299],[3302,3311],[3313,3315],[3328,3340],[3342,3344],[3346,3396],[3398,3400],[3402,3406],[3412,3415],[3423,3427],[3430,3439],[3450,3455],[3457,3459],[3461,3478],[3482,3505],[3507,3515],[3517,3517],[3520,3526],[3530,3530],[3535,3540],[3542,3542],[3544,3551],[3558,3567],[3570,3571],[3585,3642],[3648,3662],[3664,3673],[3713,3714],[3716,3716],[3718,3722],[3724,3747],[3749,3749],[3751,3773],[3776,3780],[3782,3782],[3784,3790],[3792,3801],[3804,3807],[3840,3840],[3864,3865],[3872,3881],[3893,3893],[3895,3895],[3897,3897],[3902,3911],[3913,3948],[3953,3972],[3974,3991],[3993,4028],[4038,4038],[4096,4169],[4176,4253],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4348,4680],[4682,4685],[4688,4694],[4696,4696],[4698,4701],[4704,4744],[4746,4749],[4752,4784],[4786,4789],[4792,4798],[4800,4800],[4802,4805],[4808,4822],[4824,4880],[4882,4885],[4888,4954],[4957,4959],[4969,4977],[4992,5007],[5024,5109],[5112,5117],[5121,5740],[5743,5759],[5761,5786],[5792,5866],[5870,5880],[5888,5909],[5919,5940],[5952,5971],[5984,5996],[5998,6000],[6002,6003],[6016,6099],[6103,6103],[6108,6109],[6112,6121],[6155,6157],[6159,6169],[6176,6264],[6272,6314],[6320,6389],[6400,6430],[6432,6443],[6448,6459],[6470,6509],[6512,6516],[6528,6571],[6576,6601],[6608,6618],[6656,6683],[6688,6750],[6752,6780],[6783,6793],[6800,6809],[6823,6823],[6832,6845],[6847,6862],[6912,6988],[6992,7001],[7019,7027],[7040,7155],[7168,7223],[7232,7241],[7245,7293],[7296,7306],[7312,7354],[7357,7359],[7376,7378],[7380,7418],[7424,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8204,8205],[8255,8256],[8276,8276],[8305,8305],[8319,8319],[8336,8348],[8400,8412],[8417,8417],[8421,8432],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8472,8477],[8484,8484],[8486,8486],[8488,8488],[8490,8505],[8508,8511],[8517,8521],[8526,8526],[8544,8584],[11264,11492],[11499,11507],[11520,11557],[11559,11559],[11565,11565],[11568,11623],[11631,11631],[11647,11670],[11680,11686],[11688,11694],[11696,11702],[11704,11710],[11712,11718],[11720,11726],[11728,11734],[11736,11742],[11744,11775],[12293,12295],[12321,12335],[12337,12341],[12344,12348],[12353,12438],[12441,12447],[12449,12543],[12549,12591],[12593,12686],[12704,12735],[12784,12799],[13312,19903],[19968,42124],[42192,42237],[42240,42508],[42512,42539],[42560,42607],[42612,42621],[42623,42737],[42775,42783],[42786,42888],[42891,42957],[42960,42961],[42963,42963],[42965,42972],[42994,43047],[43052,43052],[43072,43123],[43136,43205],[43216,43225],[43232,43255],[43259,43259],[43261,43309],[43312,43347],[43360,43388],[43392,43456],[43471,43481],[43488,43518],[43520,43574],[43584,43597],[43600,43609],[43616,43638],[43642,43714],[43739,43741],[43744,43759],[43762,43766],[43777,43782],[43785,43790],[43793,43798],[43808,43814],[43816,43822],[43824,43866],[43868,43881],[43888,44010],[44012,44013],[44016,44025],[44032,55203],[55216,55238],[55243,55291],[63744,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64296],[64298,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64829],[64848,64911],[64914,64967],[65008,65019],[65024,65039],[65056,65071],[65075,65076],[65101,65103],[65136,65140],[65142,65276],[65296,65305],[65313,65338],[65343,65343],[65345,65370],[65381,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65536,65547],[65549,65574],[65576,65594],[65596,65597],[65599,65613],[65616,65629],[65664,65786],[65856,65908],[66045,66045],[66176,66204],[66208,66256],[66272,66272],[66304,66335],[66349,66378],[66384,66426],[66432,66461],[66464,66499],[66504,66511],[66513,66517],[66560,66717],[66720,66729],[66736,66771],[66776,66811],[66816,66855],[66864,66915],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[67008,67059],[67072,67382],[67392,67413],[67424,67431],[67456,67461],[67463,67504],[67506,67514],[67584,67589],[67592,67592],[67594,67637],[67639,67640],[67644,67644],[67647,67669],[67680,67702],[67712,67742],[67808,67826],[67828,67829],[67840,67861],[67872,67897],[67968,68023],[68030,68031],[68096,68099],[68101,68102],[68108,68115],[68117,68119],[68121,68149],[68152,68154],[68159,68159],[68192,68220],[68224,68252],[68288,68295],[68297,68326],[68352,68405],[68416,68437],[68448,68466],[68480,68497],[68608,68680],[68736,68786],[68800,68850],[68864,68903],[68912,68921],[68928,68965],[68969,68973],[68975,68997],[69248,69289],[69291,69292],[69296,69297],[69314,69316],[69372,69404],[69415,69415],[69424,69456],[69488,69509],[69552,69572],[69600,69622],[69632,69702],[69734,69749],[69759,69818],[69826,69826],[69840,69864],[69872,69881],[69888,69940],[69942,69951],[69956,69959],[69968,70003],[70006,70006],[70016,70084],[70089,70092],[70094,70106],[70108,70108],[70144,70161],[70163,70199],[70206,70209],[70272,70278],[70280,70280],[70282,70285],[70287,70301],[70303,70312],[70320,70378],[70384,70393],[70400,70403],[70405,70412],[70415,70416],[70419,70440],[70442,70448],[70450,70451],[70453,70457],[70459,70468],[70471,70472],[70475,70477],[70480,70480],[70487,70487],[70493,70499],[70502,70508],[70512,70516],[70528,70537],[70539,70539],[70542,70542],[70544,70581],[70583,70592],[70594,70594],[70597,70597],[70599,70602],[70604,70611],[70625,70626],[70656,70730],[70736,70745],[70750,70753],[70784,70853],[70855,70855],[70864,70873],[71040,71093],[71096,71104],[71128,71133],[71168,71232],[71236,71236],[71248,71257],[71296,71352],[71360,71369],[71376,71395],[71424,71450],[71453,71467],[71472,71481],[71488,71494],[71680,71738],[71840,71913],[71935,71942],[71945,71945],[71948,71955],[71957,71958],[71960,71989],[71991,71992],[71995,72003],[72016,72025],[72096,72103],[72106,72151],[72154,72161],[72163,72164],[72192,72254],[72263,72263],[72272,72345],[72349,72349],[72368,72440],[72640,72672],[72688,72697],[72704,72712],[72714,72758],[72760,72768],[72784,72793],[72818,72847],[72850,72871],[72873,72886],[72960,72966],[72968,72969],[72971,73014],[73018,73018],[73020,73021],[73023,73031],[73040,73049],[73056,73061],[73063,73064],[73066,73102],[73104,73105],[73107,73112],[73120,73129],[73440,73462],[73472,73488],[73490,73530],[73534,73538],[73552,73562],[73648,73648],[73728,74649],[74752,74862],[74880,75075],[77712,77808],[77824,78895],[78912,78933],[78944,82938],[82944,83526],[90368,90425],[92160,92728],[92736,92766],[92768,92777],[92784,92862],[92864,92873],[92880,92909],[92912,92916],[92928,92982],[92992,92995],[93008,93017],[93027,93047],[93053,93071],[93504,93548],[93552,93561],[93760,93823],[93952,94026],[94031,94087],[94095,94111],[94176,94177],[94179,94180],[94192,94193],[94208,100343],[100352,101589],[101631,101640],[110576,110579],[110581,110587],[110589,110590],[110592,110882],[110898,110898],[110928,110930],[110933,110933],[110948,110951],[110960,111355],[113664,113770],[113776,113788],[113792,113800],[113808,113817],[113821,113822],[118000,118009],[118528,118573],[118576,118598],[119141,119145],[119149,119154],[119163,119170],[119173,119179],[119210,119213],[119362,119364],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120512],[120514,120538],[120540,120570],[120572,120596],[120598,120628],[120630,120654],[120656,120686],[120688,120712],[120714,120744],[120746,120770],[120772,120779],[120782,120831],[121344,121398],[121403,121452],[121461,121461],[121476,121476],[121499,121503],[121505,121519],[122624,122654],[122661,122666],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[122928,122989],[123023,123023],[123136,123180],[123184,123197],[123200,123209],[123214,123214],[123536,123566],[123584,123641],[124112,124153],[124368,124410],[124896,124902],[124904,124907],[124909,124910],[124912,124926],[124928,125124],[125136,125142],[125184,125259],[125264,125273],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[130032,130041],[131072,173791],[173824,177977],[177984,178205],[178208,183969],[183984,191456],[191472,192093],[194560,195101],[196608,201546],[201552,205743],[917760,917999]],"Binary_Property/Math":[[43,43],[60,62],[94,94],[124,124],[126,126],[172,172],[177,177],[215,215],[247,247],[976,978],[981,981],[1008,1009],[1012,1014],[1542,1544],[8214,8214],[8242,8244],[8256,8256],[8260,8260],[8274,8274],[8289,8292],[8314,8318],[8330,8334],[8400,8412],[8417,8417],[8421,8422],[8427,8431],[8450,8450],[8455,8455],[8458,8467],[8469,8469],[8472,8477],[8484,8484],[8488,8489],[8492,8493],[8495,8497],[8499,8504],[8508,8521],[8523,8523],[8592,8615],[8617,8622],[8624,8625],[8630,8631],[8636,8667],[8669,8669],[8676,8677],[8692,8959],[8968,8971],[8992,8993],[9084,9084],[9115,9141],[9143,9143],[9168,9168],[9180,9186],[9632,9633],[9646,9655],[9660,9665],[9670,9671],[9674,9675],[9679,9683],[9698,9698],[9700,9700],[9703,9708],[9720,9727],[9733,9734],[9792,9792],[9794,9794],[9824,9827],[9837,9839],[10176,10239],[10496,11007],[11056,11076],[11079,11084],[64297,64297],[65121,65126],[65128,65128],[65291,65291],[65308,65310],[65340,65340],[65342,65342],[65372,65372],[65374,65374],[65506,65506],[65513,65516],[69006,69007],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120779],[120782,120831],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[126704,126705]],"Binary_Property/Bidi_Mirrored":[[40,41],[60,60],[62,62],[91,91],[93,93],[123,123],[125,125],[171,171],[187,187],[3898,3901],[5787,5788],[8249,8250],[8261,8262],[8317,8318],[8333,8334],[8512,8512],[8705,8708],[8712,8717],[8721,8721],[8725,8726],[8730,8733],[8735,8738],[8740,8740],[8742,8742],[8747,8755],[8761,8761],[8763,8780],[8786,8789],[8799,8800],[8802,8802],[8804,8811],[8813,8844],[8847,8850],[8856,8856],[8866,8867],[8870,8888],[8894,8895],[8905,8909],[8912,8913],[8918,8941],[8944,8959],[8968,8971],[8992,8993],[9001,9002],[10088,10101],[10176,10176],[10179,10182],[10184,10185],[10187,10189],[10195,10198],[10204,10206],[10210,10223],[10627,10648],[10651,10656],[10658,10671],[10680,10680],[10688,10693],[10697,10697],[10702,10706],[10708,10709],[10712,10716],[10721,10721],[10723,10725],[10728,10729],[10740,10745],[10748,10749],[10762,10780],[10782,10785],[10788,10788],[10790,10790],[10793,10793],[10795,10798],[10804,10805],[10812,10814],[10839,10840],[10852,10853],[10858,10861],[10863,10864],[10867,10868],[10873,10915],[10918,10925],[10927,10966],[10972,10972],[10974,10974],[10978,10982],[10988,10990],[10995,10995],[10999,11003],[11005,11005],[11262,11262],[11778,11781],[11785,11786],[11788,11789],[11804,11805],[11808,11817],[11861,11868],[12296,12305],[12308,12315],[65113,65118],[65124,65125],[65288,65289],[65308,65308],[65310,65310],[65339,65339],[65341,65341],[65371,65371],[65373,65373],[65375,65376],[65378,65379],[120539,120539],[120597,120597],[120655,120655],[120713,120713],[120771,120771]],"Binary_Property/Terminal_Punctuation":[[33,33],[44,44],[46,46],[58,59],[63,63],[894,894],[903,903],[1417,1417],[1475,1475],[1548,1548],[1563,1563],[1565,1567],[1748,1748],[1792,1802],[1804,1804],[2040,2041],[2096,2101],[2103,2110],[2142,2142],[2404,2405],[3674,3675],[3848,3848],[3853,3858],[4170,4171],[4961,4968],[5742,5742],[5867,5869],[5941,5942],[6100,6102],[6106,6106],[6146,6149],[6152,6153],[6468,6469],[6824,6827],[6990,6991],[7002,7003],[7005,7007],[7037,7039],[7227,7231],[7294,7295],[8228,8228],[8252,8253],[8263,8265],[11513,11515],[11822,11822],[11836,11836],[11841,11841],[11852,11852],[11854,11855],[11859,11860],[12289,12290],[42238,42239],[42509,42511],[42739,42743],[43126,43127],[43214,43215],[43311,43311],[43463,43465],[43613,43615],[43743,43743],[43760,43761],[44011,44011],[65042,65042],[65045,65046],[65104,65106],[65108,65111],[65281,65281],[65292,65292],[65294,65294],[65306,65307],[65311,65311],[65377,65377],[65380,65380],[66463,66463],[66512,66512],[67671,67671],[67871,67871],[68182,68183],[68336,68341],[68410,68415],[68505,68508],[69461,69465],[69510,69513],[69703,69709],[69822,69825],[69953,69955],[70085,70086],[70093,70093],[70110,70111],[70200,70204],[70313,70313],[70612,70613],[70731,70733],[70746,70747],[71106,71109],[71113,71127],[71233,71234],[71484,71486],[72004,72004],[72006,72006],[72258,72259],[72347,72348],[72353,72354],[72769,72771],[72817,72817],[73463,73464],[73539,73540],[74864,74868],[92782,92783],[92917,92917],[92983,92985],[92996,92996],[93550,93551],[93847,93848],[113823,113823],[121479,121482]],"Binary_Property/Emoji_Presentation":[[8986,8987],[9193,9196],[9200,9200],[9203,9203],[9725,9726],[9748,9749],[9800,9811],[9855,9855],[9875,9875],[9889,9889],[9898,9899],[9917,9918],[9924,9925],[9934,9934],[9940,9940],[9962,9962],[9970,9971],[9973,9973],[9978,9978],[9981,9981],[9989,9989],[9994,9995],[10024,10024],[10060,10060],[10062,10062],[10067,10069],[10071,10071],[10133,10135],[10160,10160],[10175,10175],[11035,11036],[11088,11088],[11093,11093],[126980,126980],[127183,127183],[127374,127374],[127377,127386],[127462,127487],[127489,127489],[127514,127514],[127535,127535],[127538,127542],[127544,127546],[127568,127569],[127744,127776],[127789,127797],[127799,127868],[127870,127891],[127904,127946],[127951,127955],[127968,127984],[127988,127988],[127992,128062],[128064,128064],[128066,128252],[128255,128317],[128331,128334],[128336,128359],[128378,128378],[128405,128406],[128420,128420],[128507,128591],[128640,128709],[128716,128716],[128720,128722],[128725,128727],[128732,128735],[128747,128748],[128756,128764],[128992,129003],[129008,129008],[129292,129338],[129340,129349],[129351,129535],[129648,129660],[129664,129673],[129679,129734],[129742,129756],[129759,129769],[129776,129784]],"Binary_Property/Deprecated":[[329,329],[1651,1651],[3959,3959],[3961,3961],[6051,6052],[8298,8303],[9001,9002],[917505,917505]],"Binary_Property/Changes_When_Casemapped":[[65,90],[97,122],[181,181],[192,214],[216,246],[248,311],[313,396],[398,425],[428,441],[444,445],[447,447],[452,544],[546,563],[570,596],[598,599],[601,601],[603,604],[608,609],[611,614],[616,620],[623,623],[625,626],[629,629],[637,637],[640,640],[642,643],[647,652],[658,658],[669,670],[837,837],[880,883],[886,887],[891,893],[895,895],[902,902],[904,906],[908,908],[910,929],[931,977],[981,1013],[1015,1019],[1021,1153],[1162,1327],[1329,1366],[1377,1415],[4256,4293],[4295,4295],[4301,4301],[4304,4346],[4349,4351],[5024,5109],[5112,5117],[7296,7306],[7312,7354],[7357,7359],[7545,7545],[7549,7549],[7566,7566],[7680,7835],[7838,7838],[7840,7957],[7960,7965],[7968,8005],[8008,8013],[8016,8023],[8025,8025],[8027,8027],[8029,8029],[8031,8061],[8064,8116],[8118,8124],[8126,8126],[8130,8132],[8134,8140],[8144,8147],[8150,8155],[8160,8172],[8178,8180],[8182,8188],[8486,8486],[8490,8491],[8498,8498],[8526,8526],[8544,8575],[8579,8580],[9398,9449],[11264,11376],[11378,11379],[11381,11382],[11390,11491],[11499,11502],[11506,11507],[11520,11557],[11559,11559],[11565,11565],[42560,42605],[42624,42651],[42786,42799],[42802,42863],[42873,42887],[42891,42893],[42896,42900],[42902,42926],[42928,42957],[42960,42961],[42966,42972],[42997,42998],[43859,43859],[43888,43967],[64256,64262],[64275,64279],[65313,65338],[65345,65370],[66560,66639],[66736,66771],[66776,66811],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[66967,66977],[66979,66993],[66995,67001],[67003,67004],[68736,68786],[68800,68850],[68944,68965],[68976,68997],[71840,71903],[93760,93823],[125184,125251]],"Binary_Property/Changes_When_NFKC_Casefolded":[[65,90],[160,160],[168,168],[170,170],[173,173],[175,175],[178,181],[184,186],[188,190],[192,214],[216,223],[256,256],[258,258],[260,260],[262,262],[264,264],[266,266],[268,268],[270,270],[272,272],[274,274],[276,276],[278,278],[280,280],[282,282],[284,284],[286,286],[288,288],[290,290],[292,292],[294,294],[296,296],[298,298],[300,300],[302,302],[304,304],[306,308],[310,310],[313,313],[315,315],[317,317],[319,321],[323,323],[325,325],[327,327],[329,330],[332,332],[334,334],[336,336],[338,338],[340,340],[342,342],[344,344],[346,346],[348,348],[350,350],[352,352],[354,354],[356,356],[358,358],[360,360],[362,362],[364,364],[366,366],[368,368],[370,370],[372,372],[374,374],[376,377],[379,379],[381,381],[383,383],[385,386],[388,388],[390,391],[393,395],[398,401],[403,404],[406,408],[412,413],[415,416],[418,418],[420,420],[422,423],[425,425],[428,428],[430,431],[433,435],[437,437],[439,440],[444,444],[452,461],[463,463],[465,465],[467,467],[469,469],[471,471],[473,473],[475,475],[478,478],[480,480],[482,482],[484,484],[486,486],[488,488],[490,490],[492,492],[494,494],[497,500],[502,504],[506,506],[508,508],[510,510],[512,512],[514,514],[516,516],[518,518],[520,520],[522,522],[524,524],[526,526],[528,528],[530,530],[532,532],[534,534],[536,536],[538,538],[540,540],[542,542],[544,544],[546,546],[548,548],[550,550],[552,552],[554,554],[556,556],[558,558],[560,560],[562,562],[570,571],[573,574],[577,577],[579,582],[584,584],[586,586],[588,588],[590,590],[688,696],[728,733],[736,740],[832,833],[835,837],[847,847],[880,880],[882,882],[884,884],[886,886],[890,890],[894,895],[900,906],[908,908],[910,911],[913,929],[931,939],[962,962],[975,982],[984,984],[986,986],[988,988],[990,990],[992,992],[994,994],[996,996],[998,998],[1000,1000],[1002,1002],[1004,1004],[1006,1006],[1008,1010],[1012,1013],[1015,1015],[1017,1018],[1021,1071],[1120,1120],[1122,1122],[1124,1124],[1126,1126],[1128,1128],[1130,1130],[1132,1132],[1134,1134],[1136,1136],[1138,1138],[1140,1140],[1142,1142],[1144,1144],[1146,1146],[1148,1148],[1150,1150],[1152,1152],[1162,1162],[1164,1164],[1166,1166],[1168,1168],[1170,1170],[1172,1172],[1174,1174],[1176,1176],[1178,1178],[1180,1180],[1182,1182],[1184,1184],[1186,1186],[1188,1188],[1190,1190],[1192,1192],[1194,1194],[1196,1196],[1198,1198],[1200,1200],[1202,1202],[1204,1204],[1206,1206],[1208,1208],[1210,1210],[1212,1212],[1214,1214],[1216,1217],[1219,1219],[1221,1221],[1223,1223],[1225,1225],[1227,1227],[1229,1229],[1232,1232],[1234,1234],[1236,1236],[1238,1238],[1240,1240],[1242,1242],[1244,1244],[1246,1246],[1248,1248],[1250,1250],[1252,1252],[1254,1254],[1256,1256],[1258,1258],[1260,1260],[1262,1262],[1264,1264],[1266,1266],[1268,1268],[1270,1270],[1272,1272],[1274,1274],[1276,1276],[1278,1278],[1280,1280],[1282,1282],[1284,1284],[1286,1286],[1288,1288],[1290,1290],[1292,1292],[1294,1294],[1296,1296],[1298,1298],[1300,1300],[1302,1302],[1304,1304],[1306,1306],[1308,1308],[1310,1310],[1312,1312],[1314,1314],[1316,1316],[1318,1318],[1320,1320],[1322,1322],[1324,1324],[1326,1326],[1329,1366],[1415,1415],[1564,1564],[1653,1656],[2392,2399],[2524,2525],[2527,2527],[2611,2611],[2614,2614],[2649,2651],[2654,2654],[2908,2909],[3635,3635],[3763,3763],[3804,3805],[3852,3852],[3907,3907],[3917,3917],[3922,3922],[3927,3927],[3932,3932],[3945,3945],[3955,3955],[3957,3961],[3969,3969],[3987,3987],[3997,3997],[4002,4002],[4007,4007],[4012,4012],[4025,4025],[4256,4293],[4295,4295],[4301,4301],[4348,4348],[4447,4448],[5112,5117],[6068,6069],[6155,6159],[7296,7305],[7312,7354],[7357,7359],[7468,7470],[7472,7482],[7484,7501],[7503,7530],[7544,7544],[7579,7615],[7680,7680],[7682,7682],[7684,7684],[7686,7686],[7688,7688],[7690,7690],[7692,7692],[7694,7694],[7696,7696],[7698,7698],[7700,7700],[7702,7702],[7704,7704],[7706,7706],[7708,7708],[7710,7710],[7712,7712],[7714,7714],[7716,7716],[7718,7718],[7720,7720],[7722,7722],[7724,7724],[7726,7726],[7728,7728],[7730,7730],[7732,7732],[7734,7734],[7736,7736],[7738,7738],[7740,7740],[7742,7742],[7744,7744],[7746,7746],[7748,7748],[7750,7750],[7752,7752],[7754,7754],[7756,7756],[7758,7758],[7760,7760],[7762,7762],[7764,7764],[7766,7766],[7768,7768],[7770,7770],[7772,7772],[7774,7774],[7776,7776],[7778,7778],[7780,7780],[7782,7782],[7784,7784],[7786,7786],[7788,7788],[7790,7790],[7792,7792],[7794,7794],[7796,7796],[7798,7798],[7800,7800],[7802,7802],[7804,7804],[7806,7806],[7808,7808],[7810,7810],[7812,7812],[7814,7814],[7816,7816],[7818,7818],[7820,7820],[7822,7822],[7824,7824],[7826,7826],[7828,7828],[7834,7835],[7838,7838],[7840,7840],[7842,7842],[7844,7844],[7846,7846],[7848,7848],[7850,7850],[7852,7852],[7854,7854],[7856,7856],[7858,7858],[7860,7860],[7862,7862],[7864,7864],[7866,7866],[7868,7868],[7870,7870],[7872,7872],[7874,7874],[7876,7876],[7878,7878],[7880,7880],[7882,7882],[7884,7884],[7886,7886],[7888,7888],[7890,7890],[7892,7892],[7894,7894],[7896,7896],[7898,7898],[7900,7900],[7902,7902],[7904,7904],[7906,7906],[7908,7908],[7910,7910],[7912,7912],[7914,7914],[7916,7916],[7918,7918],[7920,7920],[7922,7922],[7924,7924],[7926,7926],[7928,7928],[7930,7930],[7932,7932],[7934,7934],[7944,7951],[7960,7965],[7976,7983],[7992,7999],[8008,8013],[8025,8025],[8027,8027],[8029,8029],[8031,8031],[8040,8047],[8049,8049],[8051,8051],[8053,8053],[8055,8055],[8057,8057],[8059,8059],[8061,8061],[8064,8111],[8114,8116],[8119,8132],[8135,8143],[8147,8147],[8152,8155],[8157,8159],[8163,8163],[8168,8175],[8178,8180],[8183,8190],[8192,8207],[8209,8209],[8215,8215],[8228,8230],[8234,8239],[8243,8244],[8246,8247],[8252,8252],[8254,8254],[8263,8265],[8279,8279],[8287,8305],[8308,8334],[8336,8348],[8360,8360],[8448,8451],[8453,8455],[8457,8467],[8469,8470],[8473,8477],[8480,8482],[8484,8484],[8486,8486],[8488,8488],[8490,8493],[8495,8505],[8507,8512],[8517,8521],[8528,8575],[8579,8579],[8585,8585],[8748,8749],[8751,8752],[9001,9002],[9312,9450],[10764,10764],[10868,10870],[10972,10972],[11264,11311],[11360,11360],[11362,11364],[11367,11367],[11369,11369],[11371,11371],[11373,11376],[11378,11378],[11381,11381],[11388,11392],[11394,11394],[11396,11396],[11398,11398],[11400,11400],[11402,11402],[11404,11404],[11406,11406],[11408,11408],[11410,11410],[11412,11412],[11414,11414],[11416,11416],[11418,11418],[11420,11420],[11422,11422],[11424,11424],[11426,11426],[11428,11428],[11430,11430],[11432,11432],[11434,11434],[11436,11436],[11438,11438],[11440,11440],[11442,11442],[11444,11444],[11446,11446],[11448,11448],[11450,11450],[11452,11452],[11454,11454],[11456,11456],[11458,11458],[11460,11460],[11462,11462],[11464,11464],[11466,11466],[11468,11468],[11470,11470],[11472,11472],[11474,11474],[11476,11476],[11478,11478],[11480,11480],[11482,11482],[11484,11484],[11486,11486],[11488,11488],[11490,11490],[11499,11499],[11501,11501],[11506,11506],[11631,11631],[11935,11935],[12019,12019],[12032,12245],[12288,12288],[12342,12342],[12344,12346],[12443,12444],[12447,12447],[12543,12543],[12593,12686],[12690,12703],[12800,12830],[12832,12871],[12880,12926],[12928,13311],[42560,42560],[42562,42562],[42564,42564],[42566,42566],[42568,42568],[42570,42570],[42572,42572],[42574,42574],[42576,42576],[42578,42578],[42580,42580],[42582,42582],[42584,42584],[42586,42586],[42588,42588],[42590,42590],[42592,42592],[42594,42594],[42596,42596],[42598,42598],[42600,42600],[42602,42602],[42604,42604],[42624,42624],[42626,42626],[42628,42628],[42630,42630],[42632,42632],[42634,42634],[42636,42636],[42638,42638],[42640,42640],[42642,42642],[42644,42644],[42646,42646],[42648,42648],[42650,42650],[42652,42653],[42786,42786],[42788,42788],[42790,42790],[42792,42792],[42794,42794],[42796,42796],[42798,42798],[42802,42802],[42804,42804],[42806,42806],[42808,42808],[42810,42810],[42812,42812],[42814,42814],[42816,42816],[42818,42818],[42820,42820],[42822,42822],[42824,42824],[42826,42826],[42828,42828],[42830,42830],[42832,42832],[42834,42834],[42836,42836],[42838,42838],[42840,42840],[42842,42842],[42844,42844],[42846,42846],[42848,42848],[42850,42850],[42852,42852],[42854,42854],[42856,42856],[42858,42858],[42860,42860],[42862,42862],[42864,42864],[42873,42873],[42875,42875],[42877,42878],[42880,42880],[42882,42882],[42884,42884],[42886,42886],[42891,42891],[42893,42893],[42896,42896],[42898,42898],[42902,42902],[42904,42904],[42906,42906],[42908,42908],[42910,42910],[42912,42912],[42914,42914],[42916,42916],[42918,42918],[42920,42920],[42922,42926],[42928,42932],[42934,42934],[42936,42936],[42938,42938],[42940,42940],[42942,42942],[42944,42944],[42946,42946],[42948,42951],[42953,42953],[42955,42956],[42960,42960],[42966,42966],[42968,42968],[42970,42970],[42972,42972],[42994,42997],[43000,43001],[43868,43871],[43881,43881],[43888,43967],[63744,64013],[64016,64016],[64018,64018],[64021,64030],[64032,64032],[64034,64034],[64037,64038],[64042,64109],[64112,64217],[64256,64262],[64275,64279],[64285,64285],[64287,64310],[64312,64316],[64318,64318],[64320,64321],[64323,64324],[64326,64433],[64467,64829],[64848,64911],[64914,64967],[65008,65020],[65024,65049],[65072,65092],[65095,65106],[65108,65126],[65128,65131],[65136,65138],[65140,65140],[65142,65276],[65279,65279],[65281,65470],[65474,65479],[65482,65487],[65490,65495],[65498,65500],[65504,65510],[65512,65518],[65520,65528],[66560,66599],[66736,66771],[66928,66938],[66940,66954],[66956,66962],[66964,66965],[67457,67461],[67463,67504],[67506,67514],[68736,68786],[68944,68965],[71840,71871],[93760,93791],[113824,113827],[117974,118009],[119134,119140],[119155,119162],[119227,119232],[119808,119892],[119894,119964],[119966,119967],[119970,119970],[119973,119974],[119977,119980],[119982,119993],[119995,119995],[119997,120003],[120005,120069],[120071,120074],[120077,120084],[120086,120092],[120094,120121],[120123,120126],[120128,120132],[120134,120134],[120138,120144],[120146,120485],[120488,120779],[120782,120831],[122928,122989],[125184,125217],[126464,126467],[126469,126495],[126497,126498],[126500,126500],[126503,126503],[126505,126514],[126516,126519],[126521,126521],[126523,126523],[126530,126530],[126535,126535],[126537,126537],[126539,126539],[126541,126543],[126545,126546],[126548,126548],[126551,126551],[126553,126553],[126555,126555],[126557,126557],[126559,126559],[126561,126562],[126564,126564],[126567,126570],[126572,126578],[126580,126583],[126585,126588],[126590,126590],[126592,126601],[126603,126619],[126625,126627],[126629,126633],[126635,126651],[127232,127242],[127248,127278],[127280,127311],[127338,127340],[127376,127376],[127488,127490],[127504,127547],[127552,127560],[127568,127569],[130032,130041],[194560,195101],[917504,921599]],"Binary_Property/Soft_Dotted":[[105,106],[303,303],[585,585],[616,616],[669,669],[690,690],[1011,1011],[1110,1110],[1112,1112],[7522,7522],[7574,7574],[7588,7588],[7592,7592],[7725,7725],[7883,7883],[8305,8305],[8520,8521],[11388,11388],[119842,119843],[119894,119895],[119946,119947],[119998,119999],[120050,120051],[120102,120103],[120154,120155],[120206,120207],[120258,120259],[120310,120311],[120362,120363],[120414,120415],[120466,120467],[122650,122650],[122956,122957],[122984,122984]],"Binary_Property/Extended_Pictographic":[[169,169],[174,174],[8252,8252],[8265,8265],[8482,8482],[8505,8505],[8596,8601],[8617,8618],[8986,8987],[9000,9000],[9096,9096],[9167,9167],[9193,9203],[9208,9210],[9410,9410],[9642,9643],[9654,9654],[9664,9664],[9723,9726],[9728,9733],[9735,9746],[9748,9861],[9872,9989],[9992,10002],[10004,10004],[10006,10006],[10013,10013],[10017,10017],[10024,10024],[10035,10036],[10052,10052],[10055,10055],[10060,10060],[10062,10062],[10067,10069],[10071,10071],[10083,10087],[10133,10135],[10145,10145],[10160,10160],[10175,10175],[10548,10549],[11013,11015],[11035,11036],[11088,11088],[11093,11093],[12336,12336],[12349,12349],[12951,12951],[12953,12953],[126976,127231],[127245,127247],[127279,127279],[127340,127345],[127358,127359],[127374,127374],[127377,127386],[127405,127461],[127489,127503],[127514,127514],[127535,127535],[127538,127546],[127548,127551],[127561,127994],[128000,128317],[128326,128591],[128640,128767],[128884,128895],[128981,129023],[129036,129039],[129096,129103],[129114,129119],[129160,129167],[129198,129279],[129292,129338],[129340,129349],[129351,129791],[130048,131069]],"Binary_Property/Diacritic":[[94,94],[96,96],[168,168],[175,175],[180,180],[183,184],[688,846],[848,855],[861,866],[884,885],[890,890],[900,901],[1155,1159],[1369,1369],[1425,1441],[1443,1469],[1471,1471],[1473,1474],[1476,1476],[1611,1618],[1623,1624],[1759,1760],[1765,1766],[1770,1772],[1840,1866],[1958,1968],[2027,2037],[2072,2073],[2200,2207],[2249,2258],[2275,2302],[2364,2364],[2381,2381],[2385,2388],[2417,2417],[2492,2492],[2509,2509],[2620,2620],[2637,2637],[2748,2748],[2765,2765],[2813,2815],[2876,2876],[2893,2893],[2901,2901],[3021,3021],[3132,3132],[3149,3149],[3260,3260],[3277,3277],[3387,3388],[3405,3405],[3530,3530],[3642,3642],[3655,3660],[3662,3662],[3770,3770],[3784,3788],[3864,3865],[3893,3893],[3895,3895],[3897,3897],[3902,3903],[3970,3972],[3974,3975],[4038,4038],[4151,4151],[4153,4154],[4195,4196],[4201,4205],[4231,4237],[4239,4239],[4250,4251],[4957,4959],[5908,5909],[5940,5940],[6089,6099],[6109,6109],[6457,6459],[6752,6752],[6773,6780],[6783,6783],[6832,6846],[6849,6859],[6964,6964],[6980,6980],[7019,7027],[7082,7083],[7142,7142],[7154,7155],[7222,7223],[7288,7293],[7376,7400],[7405,7405],[7412,7412],[7415,7417],[7468,7530],[7620,7631],[7669,7679],[8125,8125],[8127,8129],[8141,8143],[8157,8159],[8173,8175],[8189,8190],[11503,11505],[11823,11823],[12330,12335],[12441,12444],[12540,12540],[42607,42607],[42620,42621],[42623,42623],[42652,42653],[42736,42737],[42752,42785],[42888,42890],[43000,43001],[43014,43014],[43052,43052],[43204,43204],[43232,43249],[43307,43310],[43347,43347],[43443,43443],[43456,43456],[43493,43493],[43643,43645],[43711,43714],[43766,43766],[43867,43871],[43881,43883],[44012,44013],[64286,64286],[65056,65071],[65342,65342],[65344,65344],[65392,65392],[65438,65439],[65507,65507],[66272,66272],[67456,67461],[67463,67504],[67506,67514],[68152,68154],[68159,68159],[68325,68326],[68898,68903],[68942,68942],[68969,68973],[69373,69375],[69446,69456],[69506,69509],[69702,69702],[69744,69744],[69817,69818],[69939,69940],[70003,70003],[70080,70080],[70090,70092],[70197,70198],[70377,70378],[70459,70460],[70477,70477],[70502,70508],[70512,70516],[70606,70608],[70610,70611],[70625,70626],[70722,70722],[70726,70726],[70850,70851],[71103,71104],[71231,71231],[71350,71351],[71467,71467],[71737,71738],[71997,71998],[72003,72003],[72160,72160],[72244,72244],[72263,72263],[72345,72345],[72767,72767],[73026,73026],[73028,73029],[73111,73111],[73537,73538],[73562,73562],[78919,78933],[90415,90415],[92912,92916],[92976,92982],[93547,93548],[94095,94111],[94192,94193],[110576,110579],[110581,110587],[110589,110590],[118528,118573],[118576,118598],[119143,119145],[119149,119154],[119163,119170],[119173,119179],[119210,119213],[122928,122989],[123184,123190],[123566,123566],[123628,123631],[124398,124399],[125136,125142],[125252,125254],[125256,125258]],"Binary_Property/InCB":[[768,879],[1155,1161],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1552,1562],[1611,1631],[1648,1648],[1750,1756],[1759,1764],[1767,1768],[1770,1773],[1809,1809],[1840,1866],[1958,1968],[2027,2035],[2045,2045],[2070,2073],[2075,2083],[2085,2087],[2089,2093],[2137,2139],[2199,2207],[2250,2273],[2275,2306],[2325,2362],[2364,2364],[2369,2376],[2381,2381],[2385,2399],[2402,2403],[2424,2431],[2433,2433],[2453,2472],[2474,2480],[2482,2482],[2486,2489],[2492,2492],[2494,2494],[2497,2500],[2509,2509],[2519,2519],[2524,2525],[2527,2527],[2530,2531],[2544,2545],[2558,2558],[2561,2562],[2620,2620],[2625,2626],[2631,2632],[2635,2637],[2641,2641],[2672,2673],[2677,2677],[2689,2690],[2709,2728],[2730,2736],[2738,2739],[2741,2745],[2748,2748],[2753,2757],[2759,2760],[2765,2765],[2786,2787],[2809,2815],[2817,2817],[2837,2856],[2858,2864],[2866,2867],[2869,2873],[2876,2876],[2878,2879],[2881,2884],[2893,2893],[2901,2903],[2908,2909],[2911,2911],[2914,2915],[2929,2929],[2946,2946],[3006,3006],[3008,3008],[3021,3021],[3031,3031],[3072,3072],[3076,3076],[3093,3112],[3114,3129],[3132,3132],[3134,3136],[3142,3144],[3146,3149],[3157,3158],[3160,3162],[3170,3171],[3201,3201],[3260,3260],[3263,3264],[3266,3266],[3270,3272],[3274,3277],[3285,3286],[3298,3299],[3328,3329],[3349,3388],[3390,3390],[3393,3396],[3405,3405],[3415,3415],[3426,3427],[3457,3457],[3530,3530],[3535,3535],[3538,3540],[3542,3542],[3551,3551],[3633,3633],[3636,3642],[3655,3662],[3761,3761],[3764,3772],[3784,3790],[3864,3865],[3893,3893],[3895,3895],[3897,3897],[3953,3966],[3968,3972],[3974,3975],[3981,3991],[3993,4028],[4038,4038],[4141,4144],[4146,4151],[4153,4154],[4157,4158],[4184,4185],[4190,4192],[4209,4212],[4226,4226],[4229,4230],[4237,4237],[4253,4253],[4957,4959],[5906,5909],[5938,5940],[5970,5971],[6002,6003],[6068,6069],[6071,6077],[6086,6086],[6089,6099],[6109,6109],[6155,6157],[6159,6159],[6277,6278],[6313,6313],[6432,6434],[6439,6440],[6450,6450],[6457,6459],[6679,6680],[6683,6683],[6742,6742],[6744,6750],[6752,6752],[6754,6754],[6757,6764],[6771,6780],[6783,6783],[6832,6862],[6912,6915],[6964,6973],[6978,6980],[7019,7027],[7040,7041],[7074,7077],[7080,7085],[7142,7142],[7144,7145],[7149,7149],[7151,7155],[7212,7219],[7222,7223],[7376,7378],[7380,7392],[7394,7400],[7405,7405],[7412,7412],[7416,7417],[7616,7679],[8205,8205],[8400,8432],[11503,11505],[11647,11647],[11744,11775],[12330,12335],[12441,12442],[42607,42610],[42612,42621],[42654,42655],[42736,42737],[43010,43010],[43014,43014],[43019,43019],[43045,43046],[43052,43052],[43204,43205],[43232,43249],[43263,43263],[43302,43309],[43335,43345],[43347,43347],[43392,43394],[43443,43443],[43446,43449],[43452,43453],[43456,43456],[43493,43493],[43561,43566],[43569,43570],[43573,43574],[43587,43587],[43596,43596],[43644,43644],[43696,43696],[43698,43700],[43703,43704],[43710,43711],[43713,43713],[43756,43757],[43766,43766],[44005,44005],[44008,44008],[44013,44013],[64286,64286],[65024,65039],[65056,65071],[65438,65439],[66045,66045],[66272,66272],[66422,66426],[68097,68099],[68101,68102],[68108,68111],[68152,68154],[68159,68159],[68325,68326],[68900,68903],[68969,68973],[69291,69292],[69372,69375],[69446,69456],[69506,69509],[69633,69633],[69688,69702],[69744,69744],[69747,69748],[69759,69761],[69811,69814],[69817,69818],[69826,69826],[69888,69890],[69927,69931],[69933,69940],[70003,70003],[70016,70017],[70070,70078],[70080,70080],[70089,70092],[70095,70095],[70191,70193],[70196,70199],[70206,70206],[70209,70209],[70367,70367],[70371,70378],[70400,70401],[70459,70460],[70462,70462],[70464,70464],[70477,70477],[70487,70487],[70502,70508],[70512,70516],[70584,70584],[70587,70592],[70594,70594],[70597,70597],[70599,70601],[70606,70608],[70610,70610],[70625,70626],[70712,70719],[70722,70724],[70726,70726],[70750,70750],[70832,70832],[70835,70840],[70842,70842],[70845,70845],[70847,70848],[70850,70851],[71087,71087],[71090,71093],[71100,71101],[71103,71104],[71132,71133],[71219,71226],[71229,71229],[71231,71232],[71339,71339],[71341,71341],[71344,71351],[71453,71453],[71455,71455],[71458,71461],[71463,71467],[71727,71735],[71737,71738],[71984,71984],[71995,71998],[72003,72003],[72148,72151],[72154,72155],[72160,72160],[72193,72202],[72243,72248],[72251,72254],[72263,72263],[72273,72278],[72281,72283],[72330,72342],[72344,72345],[72752,72758],[72760,72765],[72767,72767],[72850,72871],[72874,72880],[72882,72883],[72885,72886],[73009,73014],[73018,73018],[73020,73021],[73023,73029],[73031,73031],[73104,73105],[73109,73109],[73111,73111],[73459,73460],[73472,73473],[73526,73530],[73536,73538],[73562,73562],[78912,78912],[78919,78933],[90398,90409],[90413,90415],[92912,92916],[92976,92982],[94031,94031],[94095,94098],[94180,94180],[94192,94193],[113821,113822],[118528,118573],[118576,118598],[119141,119145],[119149,119154],[119163,119170],[119173,119179],[119210,119213],[119362,119364],[121344,121398],[121403,121452],[121461,121461],[121476,121476],[121499,121503],[121505,121519],[122880,122886],[122888,122904],[122907,122913],[122915,122916],[122918,122922],[123023,123023],[123184,123190],[123566,123566],[123628,123631],[124140,124143],[124398,124399],[125136,125142],[125252,125258],[127995,127999],[917536,917631],[917760,917999]]};

var Basic_Emoji="⌚,⌛,⏩,⏪,⏫,⏬,⏰,⏳,◽,◾,☔,☕,♈,♉,♊,♋,♌,♍,♎,♏,♐,♑,♒,♓,♿,⚓,⚡,⚪,⚫,⚽,⚾,⛄,⛅,⛎,⛔,⛪,⛲,⛳,⛵,⛺,⛽,✅,✊,✋,✨,❌,❎,❓,❔,❕,❗,➕,➖,➗,➰,➿,⬛,⬜,⭐,⭕,🀄,🃏,🆎,🆑,🆒,🆓,🆔,🆕,🆖,🆗,🆘,🆙,🆚,🈁,🈚,🈯,🈲,🈳,🈴,🈵,🈶,🈸,🈹,🈺,🉐,🉑,🌀,🌁,🌂,🌃,🌄,🌅,🌆,🌇,🌈,🌉,🌊,🌋,🌌,🌍,🌎,🌏,🌐,🌑,🌒,🌓,🌔,🌕,🌖,🌗,🌘,🌙,🌚,🌛,🌜,🌝,🌞,🌟,🌠,🌭,🌮,🌯,🌰,🌱,🌲,🌳,🌴,🌵,🌷,🌸,🌹,🌺,🌻,🌼,🌽,🌾,🌿,🍀,🍁,🍂,🍃,🍄,🍅,🍆,🍇,🍈,🍉,🍊,🍋,🍌,🍍,🍎,🍏,🍐,🍑,🍒,🍓,🍔,🍕,🍖,🍗,🍘,🍙,🍚,🍛,🍜,🍝,🍞,🍟,🍠,🍡,🍢,🍣,🍤,🍥,🍦,🍧,🍨,🍩,🍪,🍫,🍬,🍭,🍮,🍯,🍰,🍱,🍲,🍳,🍴,🍵,🍶,🍷,🍸,🍹,🍺,🍻,🍼,🍾,🍿,🎀,🎁,🎂,🎃,🎄,🎅,🎆,🎇,🎈,🎉,🎊,🎋,🎌,🎍,🎎,🎏,🎐,🎑,🎒,🎓,🎠,🎡,🎢,🎣,🎤,🎥,🎦,🎧,🎨,🎩,🎪,🎫,🎬,🎭,🎮,🎯,🎰,🎱,🎲,🎳,🎴,🎵,🎶,🎷,🎸,🎹,🎺,🎻,🎼,🎽,🎾,🎿,🏀,🏁,🏂,🏃,🏄,🏅,🏆,🏇,🏈,🏉,🏊,🏏,🏐,🏑,🏒,🏓,🏠,🏡,🏢,🏣,🏤,🏥,🏦,🏧,🏨,🏩,🏪,🏫,🏬,🏭,🏮,🏯,🏰,🏴,🏸,🏹,🏺,🏻,🏼,🏽,🏾,🏿,🐀,🐁,🐂,🐃,🐄,🐅,🐆,🐇,🐈,🐉,🐊,🐋,🐌,🐍,🐎,🐏,🐐,🐑,🐒,🐓,🐔,🐕,🐖,🐗,🐘,🐙,🐚,🐛,🐜,🐝,🐞,🐟,🐠,🐡,🐢,🐣,🐤,🐥,🐦,🐧,🐨,🐩,🐪,🐫,🐬,🐭,🐮,🐯,🐰,🐱,🐲,🐳,🐴,🐵,🐶,🐷,🐸,🐹,🐺,🐻,🐼,🐽,🐾,👀,👂,👃,👄,👅,👆,👇,👈,👉,👊,👋,👌,👍,👎,👏,👐,👑,👒,👓,👔,👕,👖,👗,👘,👙,👚,👛,👜,👝,👞,👟,👠,👡,👢,👣,👤,👥,👦,👧,👨,👩,👪,👫,👬,👭,👮,👯,👰,👱,👲,👳,👴,👵,👶,👷,👸,👹,👺,👻,👼,👽,👾,👿,💀,💁,💂,💃,💄,💅,💆,💇,💈,💉,💊,💋,💌,💍,💎,💏,💐,💑,💒,💓,💔,💕,💖,💗,💘,💙,💚,💛,💜,💝,💞,💟,💠,💡,💢,💣,💤,💥,💦,💧,💨,💩,💪,💫,💬,💭,💮,💯,💰,💱,💲,💳,💴,💵,💶,💷,💸,💹,💺,💻,💼,💽,💾,💿,📀,📁,📂,📃,📄,📅,📆,📇,📈,📉,📊,📋,📌,📍,📎,📏,📐,📑,📒,📓,📔,📕,📖,📗,📘,📙,📚,📛,📜,📝,📞,📟,📠,📡,📢,📣,📤,📥,📦,📧,📨,📩,📪,📫,📬,📭,📮,📯,📰,📱,📲,📳,📴,📵,📶,📷,📸,📹,📺,📻,📼,📿,🔀,🔁,🔂,🔃,🔄,🔅,🔆,🔇,🔈,🔉,🔊,🔋,🔌,🔍,🔎,🔏,🔐,🔑,🔒,🔓,🔔,🔕,🔖,🔗,🔘,🔙,🔚,🔛,🔜,🔝,🔞,🔟,🔠,🔡,🔢,🔣,🔤,🔥,🔦,🔧,🔨,🔩,🔪,🔫,🔬,🔭,🔮,🔯,🔰,🔱,🔲,🔳,🔴,🔵,🔶,🔷,🔸,🔹,🔺,🔻,🔼,🔽,🕋,🕌,🕍,🕎,🕐,🕑,🕒,🕓,🕔,🕕,🕖,🕗,🕘,🕙,🕚,🕛,🕜,🕝,🕞,🕟,🕠,🕡,🕢,🕣,🕤,🕥,🕦,🕧,🕺,🖕,🖖,🖤,🗻,🗼,🗽,🗾,🗿,😀,😁,😂,😃,😄,😅,😆,😇,😈,😉,😊,😋,😌,😍,😎,😏,😐,😑,😒,😓,😔,😕,😖,😗,😘,😙,😚,😛,😜,😝,😞,😟,😠,😡,😢,😣,😤,😥,😦,😧,😨,😩,😪,😫,😬,😭,😮,😯,😰,😱,😲,😳,😴,😵,😶,😷,😸,😹,😺,😻,😼,😽,😾,😿,🙀,🙁,🙂,🙃,🙄,🙅,🙆,🙇,🙈,🙉,🙊,🙋,🙌,🙍,🙎,🙏,🚀,🚁,🚂,🚃,🚄,🚅,🚆,🚇,🚈,🚉,🚊,🚋,🚌,🚍,🚎,🚏,🚐,🚑,🚒,🚓,🚔,🚕,🚖,🚗,🚘,🚙,🚚,🚛,🚜,🚝,🚞,🚟,🚠,🚡,🚢,🚣,🚤,🚥,🚦,🚧,🚨,🚩,🚪,🚫,🚬,🚭,🚮,🚯,🚰,🚱,🚲,🚳,🚴,🚵,🚶,🚷,🚸,🚹,🚺,🚻,🚼,🚽,🚾,🚿,🛀,🛁,🛂,🛃,🛄,🛅,🛌,🛐,🛑,🛒,🛕,🛖,🛗,🛜,🛝,🛞,🛟,🛫,🛬,🛴,🛵,🛶,🛷,🛸,🛹,🛺,🛻,🛼,🟠,🟡,🟢,🟣,🟤,🟥,🟦,🟧,🟨,🟩,🟪,🟫,🟰,🤌,🤍,🤎,🤏,🤐,🤑,🤒,🤓,🤔,🤕,🤖,🤗,🤘,🤙,🤚,🤛,🤜,🤝,🤞,🤟,🤠,🤡,🤢,🤣,🤤,🤥,🤦,🤧,🤨,🤩,🤪,🤫,🤬,🤭,🤮,🤯,🤰,🤱,🤲,🤳,🤴,🤵,🤶,🤷,🤸,🤹,🤺,🤼,🤽,🤾,🤿,🥀,🥁,🥂,🥃,🥄,🥅,🥇,🥈,🥉,🥊,🥋,🥌,🥍,🥎,🥏,🥐,🥑,🥒,🥓,🥔,🥕,🥖,🥗,🥘,🥙,🥚,🥛,🥜,🥝,🥞,🥟,🥠,🥡,🥢,🥣,🥤,🥥,🥦,🥧,🥨,🥩,🥪,🥫,🥬,🥭,🥮,🥯,🥰,🥱,🥲,🥳,🥴,🥵,🥶,🥷,🥸,🥹,🥺,🥻,🥼,🥽,🥾,🥿,🦀,🦁,🦂,🦃,🦄,🦅,🦆,🦇,🦈,🦉,🦊,🦋,🦌,🦍,🦎,🦏,🦐,🦑,🦒,🦓,🦔,🦕,🦖,🦗,🦘,🦙,🦚,🦛,🦜,🦝,🦞,🦟,🦠,🦡,🦢,🦣,🦤,🦥,🦦,🦧,🦨,🦩,🦪,🦫,🦬,🦭,🦮,🦯,🦰,🦱,🦲,🦳,🦴,🦵,🦶,🦷,🦸,🦹,🦺,🦻,🦼,🦽,🦾,🦿,🧀,🧁,🧂,🧃,🧄,🧅,🧆,🧇,🧈,🧉,🧊,🧋,🧌,🧍,🧎,🧏,🧐,🧑,🧒,🧓,🧔,🧕,🧖,🧗,🧘,🧙,🧚,🧛,🧜,🧝,🧞,🧟,🧠,🧡,🧢,🧣,🧤,🧥,🧦,🧧,🧨,🧩,🧪,🧫,🧬,🧭,🧮,🧯,🧰,🧱,🧲,🧳,🧴,🧵,🧶,🧷,🧸,🧹,🧺,🧻,🧼,🧽,🧾,🧿,🩰,🩱,🩲,🩳,🩴,🩵,🩶,🩷,🩸,🩹,🩺,🩻,🩼,🪀,🪁,🪂,🪃,🪄,🪅,🪆,🪇,🪈,🪉,🪏,🪐,🪑,🪒,🪓,🪔,🪕,🪖,🪗,🪘,🪙,🪚,🪛,🪜,🪝,🪞,🪟,🪠,🪡,🪢,🪣,🪤,🪥,🪦,🪧,🪨,🪩,🪪,🪫,🪬,🪭,🪮,🪯,🪰,🪱,🪲,🪳,🪴,🪵,🪶,🪷,🪸,🪹,🪺,🪻,🪼,🪽,🪾,🪿,🫀,🫁,🫂,🫃,🫄,🫅,🫆,🫎,🫏,🫐,🫑,🫒,🫓,🫔,🫕,🫖,🫗,🫘,🫙,🫚,🫛,🫜,🫟,🫠,🫡,🫢,🫣,🫤,🫥,🫦,🫧,🫨,🫩,🫰,🫱,🫲,🫳,🫴,🫵,🫶,🫷,🫸,©️,®️,‼️,⁉️,™️,ℹ️,↔️,↕️,↖️,↗️,↘️,↙️,↩️,↪️,⌨️,⏏️,⏭️,⏮️,⏯️,⏱️,⏲️,⏸️,⏹️,⏺️,Ⓜ️,▪️,▫️,▶️,◀️,◻️,◼️,☀️,☁️,☂️,☃️,☄️,☎️,☑️,☘️,☝️,☠️,☢️,☣️,☦️,☪️,☮️,☯️,☸️,☹️,☺️,♀️,♂️,♟️,♠️,♣️,♥️,♦️,♨️,♻️,♾️,⚒️,⚔️,⚕️,⚖️,⚗️,⚙️,⚛️,⚜️,⚠️,⚧️,⚰️,⚱️,⛈️,⛏️,⛑️,⛓️,⛩️,⛰️,⛱️,⛴️,⛷️,⛸️,⛹️,✂️,✈️,✉️,✌️,✍️,✏️,✒️,✔️,✖️,✝️,✡️,✳️,✴️,❄️,❇️,❣️,❤️,➡️,⤴️,⤵️,⬅️,⬆️,⬇️,〰️,〽️,㊗️,㊙️,🅰️,🅱️,🅾️,🅿️,🈂️,🈷️,🌡️,🌤️,🌥️,🌦️,🌧️,🌨️,🌩️,🌪️,🌫️,🌬️,🌶️,🍽️,🎖️,🎗️,🎙️,🎚️,🎛️,🎞️,🎟️,🏋️,🏌️,🏍️,🏎️,🏔️,🏕️,🏖️,🏗️,🏘️,🏙️,🏚️,🏛️,🏜️,🏝️,🏞️,🏟️,🏳️,🏵️,🏷️,🐿️,👁️,📽️,🕉️,🕊️,🕯️,🕰️,🕳️,🕴️,🕵️,🕶️,🕷️,🕸️,🕹️,🖇️,🖊️,🖋️,🖌️,🖍️,🖐️,🖥️,🖨️,🖱️,🖲️,🖼️,🗂️,🗃️,🗄️,🗑️,🗒️,🗓️,🗜️,🗝️,🗞️,🗡️,🗣️,🗨️,🗯️,🗳️,🗺️,🛋️,🛍️,🛎️,🛏️,🛠️,🛡️,🛢️,🛣️,🛤️,🛥️,🛩️,🛰️,🛳️";var Emoji_Keycap_Sequence="#️⃣,*️⃣,0️⃣,1️⃣,2️⃣,3️⃣,4️⃣,5️⃣,6️⃣,7️⃣,8️⃣,9️⃣";var RGI_Emoji_Modifier_Sequence="☝🏻,☝🏼,☝🏽,☝🏾,☝🏿,⛹🏻,⛹🏼,⛹🏽,⛹🏾,⛹🏿,✊🏻,✊🏼,✊🏽,✊🏾,✊🏿,✋🏻,✋🏼,✋🏽,✋🏾,✋🏿,✌🏻,✌🏼,✌🏽,✌🏾,✌🏿,✍🏻,✍🏼,✍🏽,✍🏾,✍🏿,🎅🏻,🎅🏼,🎅🏽,🎅🏾,🎅🏿,🏂🏻,🏂🏼,🏂🏽,🏂🏾,🏂🏿,🏃🏻,🏃🏼,🏃🏽,🏃🏾,🏃🏿,🏄🏻,🏄🏼,🏄🏽,🏄🏾,🏄🏿,🏇🏻,🏇🏼,🏇🏽,🏇🏾,🏇🏿,🏊🏻,🏊🏼,🏊🏽,🏊🏾,🏊🏿,🏋🏻,🏋🏼,🏋🏽,🏋🏾,🏋🏿,🏌🏻,🏌🏼,🏌🏽,🏌🏾,🏌🏿,👂🏻,👂🏼,👂🏽,👂🏾,👂🏿,👃🏻,👃🏼,👃🏽,👃🏾,👃🏿,👆🏻,👆🏼,👆🏽,👆🏾,👆🏿,👇🏻,👇🏼,👇🏽,👇🏾,👇🏿,👈🏻,👈🏼,👈🏽,👈🏾,👈🏿,👉🏻,👉🏼,👉🏽,👉🏾,👉🏿,👊🏻,👊🏼,👊🏽,👊🏾,👊🏿,👋🏻,👋🏼,👋🏽,👋🏾,👋🏿,👌🏻,👌🏼,👌🏽,👌🏾,👌🏿,👍🏻,👍🏼,👍🏽,👍🏾,👍🏿,👎🏻,👎🏼,👎🏽,👎🏾,👎🏿,👏🏻,👏🏼,👏🏽,👏🏾,👏🏿,👐🏻,👐🏼,👐🏽,👐🏾,👐🏿,👦🏻,👦🏼,👦🏽,👦🏾,👦🏿,👧🏻,👧🏼,👧🏽,👧🏾,👧🏿,👨🏻,👨🏼,👨🏽,👨🏾,👨🏿,👩🏻,👩🏼,👩🏽,👩🏾,👩🏿,👫🏻,👫🏼,👫🏽,👫🏾,👫🏿,👬🏻,👬🏼,👬🏽,👬🏾,👬🏿,👭🏻,👭🏼,👭🏽,👭🏾,👭🏿,👮🏻,👮🏼,👮🏽,👮🏾,👮🏿,👰🏻,👰🏼,👰🏽,👰🏾,👰🏿,👱🏻,👱🏼,👱🏽,👱🏾,👱🏿,👲🏻,👲🏼,👲🏽,👲🏾,👲🏿,👳🏻,👳🏼,👳🏽,👳🏾,👳🏿,👴🏻,👴🏼,👴🏽,👴🏾,👴🏿,👵🏻,👵🏼,👵🏽,👵🏾,👵🏿,👶🏻,👶🏼,👶🏽,👶🏾,👶🏿,👷🏻,👷🏼,👷🏽,👷🏾,👷🏿,👸🏻,👸🏼,👸🏽,👸🏾,👸🏿,👼🏻,👼🏼,👼🏽,👼🏾,👼🏿,💁🏻,💁🏼,💁🏽,💁🏾,💁🏿,💂🏻,💂🏼,💂🏽,💂🏾,💂🏿,💃🏻,💃🏼,💃🏽,💃🏾,💃🏿,💅🏻,💅🏼,💅🏽,💅🏾,💅🏿,💆🏻,💆🏼,💆🏽,💆🏾,💆🏿,💇🏻,💇🏼,💇🏽,💇🏾,💇🏿,💏🏻,💏🏼,💏🏽,💏🏾,💏🏿,💑🏻,💑🏼,💑🏽,💑🏾,💑🏿,💪🏻,💪🏼,💪🏽,💪🏾,💪🏿,🕴🏻,🕴🏼,🕴🏽,🕴🏾,🕴🏿,🕵🏻,🕵🏼,🕵🏽,🕵🏾,🕵🏿,🕺🏻,🕺🏼,🕺🏽,🕺🏾,🕺🏿,🖐🏻,🖐🏼,🖐🏽,🖐🏾,🖐🏿,🖕🏻,🖕🏼,🖕🏽,🖕🏾,🖕🏿,🖖🏻,🖖🏼,🖖🏽,🖖🏾,🖖🏿,🙅🏻,🙅🏼,🙅🏽,🙅🏾,🙅🏿,🙆🏻,🙆🏼,🙆🏽,🙆🏾,🙆🏿,🙇🏻,🙇🏼,🙇🏽,🙇🏾,🙇🏿,🙋🏻,🙋🏼,🙋🏽,🙋🏾,🙋🏿,🙌🏻,🙌🏼,🙌🏽,🙌🏾,🙌🏿,🙍🏻,🙍🏼,🙍🏽,🙍🏾,🙍🏿,🙎🏻,🙎🏼,🙎🏽,🙎🏾,🙎🏿,🙏🏻,🙏🏼,🙏🏽,🙏🏾,🙏🏿,🚣🏻,🚣🏼,🚣🏽,🚣🏾,🚣🏿,🚴🏻,🚴🏼,🚴🏽,🚴🏾,🚴🏿,🚵🏻,🚵🏼,🚵🏽,🚵🏾,🚵🏿,🚶🏻,🚶🏼,🚶🏽,🚶🏾,🚶🏿,🛀🏻,🛀🏼,🛀🏽,🛀🏾,🛀🏿,🛌🏻,🛌🏼,🛌🏽,🛌🏾,🛌🏿,🤌🏻,🤌🏼,🤌🏽,🤌🏾,🤌🏿,🤏🏻,🤏🏼,🤏🏽,🤏🏾,🤏🏿,🤘🏻,🤘🏼,🤘🏽,🤘🏾,🤘🏿,🤙🏻,🤙🏼,🤙🏽,🤙🏾,🤙🏿,🤚🏻,🤚🏼,🤚🏽,🤚🏾,🤚🏿,🤛🏻,🤛🏼,🤛🏽,🤛🏾,🤛🏿,🤜🏻,🤜🏼,🤜🏽,🤜🏾,🤜🏿,🤝🏻,🤝🏼,🤝🏽,🤝🏾,🤝🏿,🤞🏻,🤞🏼,🤞🏽,🤞🏾,🤞🏿,🤟🏻,🤟🏼,🤟🏽,🤟🏾,🤟🏿,🤦🏻,🤦🏼,🤦🏽,🤦🏾,🤦🏿,🤰🏻,🤰🏼,🤰🏽,🤰🏾,🤰🏿,🤱🏻,🤱🏼,🤱🏽,🤱🏾,🤱🏿,🤲🏻,🤲🏼,🤲🏽,🤲🏾,🤲🏿,🤳🏻,🤳🏼,🤳🏽,🤳🏾,🤳🏿,🤴🏻,🤴🏼,🤴🏽,🤴🏾,🤴🏿,🤵🏻,🤵🏼,🤵🏽,🤵🏾,🤵🏿,🤶🏻,🤶🏼,🤶🏽,🤶🏾,🤶🏿,🤷🏻,🤷🏼,🤷🏽,🤷🏾,🤷🏿,🤸🏻,🤸🏼,🤸🏽,🤸🏾,🤸🏿,🤹🏻,🤹🏼,🤹🏽,🤹🏾,🤹🏿,🤽🏻,🤽🏼,🤽🏽,🤽🏾,🤽🏿,🤾🏻,🤾🏼,🤾🏽,🤾🏾,🤾🏿,🥷🏻,🥷🏼,🥷🏽,🥷🏾,🥷🏿,🦵🏻,🦵🏼,🦵🏽,🦵🏾,🦵🏿,🦶🏻,🦶🏼,🦶🏽,🦶🏾,🦶🏿,🦸🏻,🦸🏼,🦸🏽,🦸🏾,🦸🏿,🦹🏻,🦹🏼,🦹🏽,🦹🏾,🦹🏿,🦻🏻,🦻🏼,🦻🏽,🦻🏾,🦻🏿,🧍🏻,🧍🏼,🧍🏽,🧍🏾,🧍🏿,🧎🏻,🧎🏼,🧎🏽,🧎🏾,🧎🏿,🧏🏻,🧏🏼,🧏🏽,🧏🏾,🧏🏿,🧑🏻,🧑🏼,🧑🏽,🧑🏾,🧑🏿,🧒🏻,🧒🏼,🧒🏽,🧒🏾,🧒🏿,🧓🏻,🧓🏼,🧓🏽,🧓🏾,🧓🏿,🧔🏻,🧔🏼,🧔🏽,🧔🏾,🧔🏿,🧕🏻,🧕🏼,🧕🏽,🧕🏾,🧕🏿,🧖🏻,🧖🏼,🧖🏽,🧖🏾,🧖🏿,🧗🏻,🧗🏼,🧗🏽,🧗🏾,🧗🏿,🧘🏻,🧘🏼,🧘🏽,🧘🏾,🧘🏿,🧙🏻,🧙🏼,🧙🏽,🧙🏾,🧙🏿,🧚🏻,🧚🏼,🧚🏽,🧚🏾,🧚🏿,🧛🏻,🧛🏼,🧛🏽,🧛🏾,🧛🏿,🧜🏻,🧜🏼,🧜🏽,🧜🏾,🧜🏿,🧝🏻,🧝🏼,🧝🏽,🧝🏾,🧝🏿,🫃🏻,🫃🏼,🫃🏽,🫃🏾,🫃🏿,🫄🏻,🫄🏼,🫄🏽,🫄🏾,🫄🏿,🫅🏻,🫅🏼,🫅🏽,🫅🏾,🫅🏿,🫰🏻,🫰🏼,🫰🏽,🫰🏾,🫰🏿,🫱🏻,🫱🏼,🫱🏽,🫱🏾,🫱🏿,🫲🏻,🫲🏼,🫲🏽,🫲🏾,🫲🏿,🫳🏻,🫳🏼,🫳🏽,🫳🏾,🫳🏿,🫴🏻,🫴🏼,🫴🏽,🫴🏾,🫴🏿,🫵🏻,🫵🏼,🫵🏽,🫵🏾,🫵🏿,🫶🏻,🫶🏼,🫶🏽,🫶🏾,🫶🏿,🫷🏻,🫷🏼,🫷🏽,🫷🏾,🫷🏿,🫸🏻,🫸🏼,🫸🏽,🫸🏾,🫸🏿";var RGI_Emoji_Flag_Sequence="🇦🇨,🇦🇩,🇦🇪,🇦🇫,🇦🇬,🇦🇮,🇦🇱,🇦🇲,🇦🇴,🇦🇶,🇦🇷,🇦🇸,🇦🇹,🇦🇺,🇦🇼,🇦🇽,🇦🇿,🇧🇦,🇧🇧,🇧🇩,🇧🇪,🇧🇫,🇧🇬,🇧🇭,🇧🇮,🇧🇯,🇧🇱,🇧🇲,🇧🇳,🇧🇴,🇧🇶,🇧🇷,🇧🇸,🇧🇹,🇧🇻,🇧🇼,🇧🇾,🇧🇿,🇨🇦,🇨🇨,🇨🇩,🇨🇫,🇨🇬,🇨🇭,🇨🇮,🇨🇰,🇨🇱,🇨🇲,🇨🇳,🇨🇴,🇨🇵,🇨🇶,🇨🇷,🇨🇺,🇨🇻,🇨🇼,🇨🇽,🇨🇾,🇨🇿,🇩🇪,🇩🇬,🇩🇯,🇩🇰,🇩🇲,🇩🇴,🇩🇿,🇪🇦,🇪🇨,🇪🇪,🇪🇬,🇪🇭,🇪🇷,🇪🇸,🇪🇹,🇪🇺,🇫🇮,🇫🇯,🇫🇰,🇫🇲,🇫🇴,🇫🇷,🇬🇦,🇬🇧,🇬🇩,🇬🇪,🇬🇫,🇬🇬,🇬🇭,🇬🇮,🇬🇱,🇬🇲,🇬🇳,🇬🇵,🇬🇶,🇬🇷,🇬🇸,🇬🇹,🇬🇺,🇬🇼,🇬🇾,🇭🇰,🇭🇲,🇭🇳,🇭🇷,🇭🇹,🇭🇺,🇮🇨,🇮🇩,🇮🇪,🇮🇱,🇮🇲,🇮🇳,🇮🇴,🇮🇶,🇮🇷,🇮🇸,🇮🇹,🇯🇪,🇯🇲,🇯🇴,🇯🇵,🇰🇪,🇰🇬,🇰🇭,🇰🇮,🇰🇲,🇰🇳,🇰🇵,🇰🇷,🇰🇼,🇰🇾,🇰🇿,🇱🇦,🇱🇧,🇱🇨,🇱🇮,🇱🇰,🇱🇷,🇱🇸,🇱🇹,🇱🇺,🇱🇻,🇱🇾,🇲🇦,🇲🇨,🇲🇩,🇲🇪,🇲🇫,🇲🇬,🇲🇭,🇲🇰,🇲🇱,🇲🇲,🇲🇳,🇲🇴,🇲🇵,🇲🇶,🇲🇷,🇲🇸,🇲🇹,🇲🇺,🇲🇻,🇲🇼,🇲🇽,🇲🇾,🇲🇿,🇳🇦,🇳🇨,🇳🇪,🇳🇫,🇳🇬,🇳🇮,🇳🇱,🇳🇴,🇳🇵,🇳🇷,🇳🇺,🇳🇿,🇴🇲,🇵🇦,🇵🇪,🇵🇫,🇵🇬,🇵🇭,🇵🇰,🇵🇱,🇵🇲,🇵🇳,🇵🇷,🇵🇸,🇵🇹,🇵🇼,🇵🇾,🇶🇦,🇷🇪,🇷🇴,🇷🇸,🇷🇺,🇷🇼,🇸🇦,🇸🇧,🇸🇨,🇸🇩,🇸🇪,🇸🇬,🇸🇭,🇸🇮,🇸🇯,🇸🇰,🇸🇱,🇸🇲,🇸🇳,🇸🇴,🇸🇷,🇸🇸,🇸🇹,🇸🇻,🇸🇽,🇸🇾,🇸🇿,🇹🇦,🇹🇨,🇹🇩,🇹🇫,🇹🇬,🇹🇭,🇹🇯,🇹🇰,🇹🇱,🇹🇲,🇹🇳,🇹🇴,🇹🇷,🇹🇹,🇹🇻,🇹🇼,🇹🇿,🇺🇦,🇺🇬,🇺🇲,🇺🇳,🇺🇸,🇺🇾,🇺🇿,🇻🇦,🇻🇨,🇻🇪,🇻🇬,🇻🇮,🇻🇳,🇻🇺,🇼🇫,🇼🇸,🇽🇰,🇾🇪,🇾🇹,🇿🇦,🇿🇲,🇿🇼";var RGI_Emoji_Tag_Sequence="🏴󠁧󠁢󠁥󠁮󠁧󠁿,🏴󠁧󠁢󠁳󠁣󠁴󠁿,🏴󠁧󠁢󠁷󠁬󠁳󠁿";var RGI_Emoji_ZWJ_Sequence="👨‍❤️‍👨,👨‍❤️‍💋‍👨,👨‍👦,👨‍👦‍👦,👨‍👧,👨‍👧‍👦,👨‍👧‍👧,👨‍👨‍👦,👨‍👨‍👦‍👦,👨‍👨‍👧,👨‍👨‍👧‍👦,👨‍👨‍👧‍👧,👨‍👩‍👦,👨‍👩‍👦‍👦,👨‍👩‍👧,👨‍👩‍👧‍👦,👨‍👩‍👧‍👧,👨🏻‍❤️‍👨🏻,👨🏻‍❤️‍👨🏼,👨🏻‍❤️‍👨🏽,👨🏻‍❤️‍👨🏾,👨🏻‍❤️‍👨🏿,👨🏻‍❤️‍💋‍👨🏻,👨🏻‍❤️‍💋‍👨🏼,👨🏻‍❤️‍💋‍👨🏽,👨🏻‍❤️‍💋‍👨🏾,👨🏻‍❤️‍💋‍👨🏿,👨🏻‍🤝‍👨🏼,👨🏻‍🤝‍👨🏽,👨🏻‍🤝‍👨🏾,👨🏻‍🤝‍👨🏿,👨🏼‍❤️‍👨🏻,👨🏼‍❤️‍👨🏼,👨🏼‍❤️‍👨🏽,👨🏼‍❤️‍👨🏾,👨🏼‍❤️‍👨🏿,👨🏼‍❤️‍💋‍👨🏻,👨🏼‍❤️‍💋‍👨🏼,👨🏼‍❤️‍💋‍👨🏽,👨🏼‍❤️‍💋‍👨🏾,👨🏼‍❤️‍💋‍👨🏿,👨🏼‍🤝‍👨🏻,👨🏼‍🤝‍👨🏽,👨🏼‍🤝‍👨🏾,👨🏼‍🤝‍👨🏿,👨🏽‍❤️‍👨🏻,👨🏽‍❤️‍👨🏼,👨🏽‍❤️‍👨🏽,👨🏽‍❤️‍👨🏾,👨🏽‍❤️‍👨🏿,👨🏽‍❤️‍💋‍👨🏻,👨🏽‍❤️‍💋‍👨🏼,👨🏽‍❤️‍💋‍👨🏽,👨🏽‍❤️‍💋‍👨🏾,👨🏽‍❤️‍💋‍👨🏿,👨🏽‍🤝‍👨🏻,👨🏽‍🤝‍👨🏼,👨🏽‍🤝‍👨🏾,👨🏽‍🤝‍👨🏿,👨🏾‍❤️‍👨🏻,👨🏾‍❤️‍👨🏼,👨🏾‍❤️‍👨🏽,👨🏾‍❤️‍👨🏾,👨🏾‍❤️‍👨🏿,👨🏾‍❤️‍💋‍👨🏻,👨🏾‍❤️‍💋‍👨🏼,👨🏾‍❤️‍💋‍👨🏽,👨🏾‍❤️‍💋‍👨🏾,👨🏾‍❤️‍💋‍👨🏿,👨🏾‍🤝‍👨🏻,👨🏾‍🤝‍👨🏼,👨🏾‍🤝‍👨🏽,👨🏾‍🤝‍👨🏿,👨🏿‍❤️‍👨🏻,👨🏿‍❤️‍👨🏼,👨🏿‍❤️‍👨🏽,👨🏿‍❤️‍👨🏾,👨🏿‍❤️‍👨🏿,👨🏿‍❤️‍💋‍👨🏻,👨🏿‍❤️‍💋‍👨🏼,👨🏿‍❤️‍💋‍👨🏽,👨🏿‍❤️‍💋‍👨🏾,👨🏿‍❤️‍💋‍👨🏿,👨🏿‍🤝‍👨🏻,👨🏿‍🤝‍👨🏼,👨🏿‍🤝‍👨🏽,👨🏿‍🤝‍👨🏾,👩‍❤️‍👨,👩‍❤️‍👩,👩‍❤️‍💋‍👨,👩‍❤️‍💋‍👩,👩‍👦,👩‍👦‍👦,👩‍👧,👩‍👧‍👦,👩‍👧‍👧,👩‍👩‍👦,👩‍👩‍👦‍👦,👩‍👩‍👧,👩‍👩‍👧‍👦,👩‍👩‍👧‍👧,👩🏻‍❤️‍👨🏻,👩🏻‍❤️‍👨🏼,👩🏻‍❤️‍👨🏽,👩🏻‍❤️‍👨🏾,👩🏻‍❤️‍👨🏿,👩🏻‍❤️‍👩🏻,👩🏻‍❤️‍👩🏼,👩🏻‍❤️‍👩🏽,👩🏻‍❤️‍👩🏾,👩🏻‍❤️‍👩🏿,👩🏻‍❤️‍💋‍👨🏻,👩🏻‍❤️‍💋‍👨🏼,👩🏻‍❤️‍💋‍👨🏽,👩🏻‍❤️‍💋‍👨🏾,👩🏻‍❤️‍💋‍👨🏿,👩🏻‍❤️‍💋‍👩🏻,👩🏻‍❤️‍💋‍👩🏼,👩🏻‍❤️‍💋‍👩🏽,👩🏻‍❤️‍💋‍👩🏾,👩🏻‍❤️‍💋‍👩🏿,👩🏻‍🤝‍👨🏼,👩🏻‍🤝‍👨🏽,👩🏻‍🤝‍👨🏾,👩🏻‍🤝‍👨🏿,👩🏻‍🤝‍👩🏼,👩🏻‍🤝‍👩🏽,👩🏻‍🤝‍👩🏾,👩🏻‍🤝‍👩🏿,👩🏼‍❤️‍👨🏻,👩🏼‍❤️‍👨🏼,👩🏼‍❤️‍👨🏽,👩🏼‍❤️‍👨🏾,👩🏼‍❤️‍👨🏿,👩🏼‍❤️‍👩🏻,👩🏼‍❤️‍👩🏼,👩🏼‍❤️‍👩🏽,👩🏼‍❤️‍👩🏾,👩🏼‍❤️‍👩🏿,👩🏼‍❤️‍💋‍👨🏻,👩🏼‍❤️‍💋‍👨🏼,👩🏼‍❤️‍💋‍👨🏽,👩🏼‍❤️‍💋‍👨🏾,👩🏼‍❤️‍💋‍👨🏿,👩🏼‍❤️‍💋‍👩🏻,👩🏼‍❤️‍💋‍👩🏼,👩🏼‍❤️‍💋‍👩🏽,👩🏼‍❤️‍💋‍👩🏾,👩🏼‍❤️‍💋‍👩🏿,👩🏼‍🤝‍👨🏻,👩🏼‍🤝‍👨🏽,👩🏼‍🤝‍👨🏾,👩🏼‍🤝‍👨🏿,👩🏼‍🤝‍👩🏻,👩🏼‍🤝‍👩🏽,👩🏼‍🤝‍👩🏾,👩🏼‍🤝‍👩🏿,👩🏽‍❤️‍👨🏻,👩🏽‍❤️‍👨🏼,👩🏽‍❤️‍👨🏽,👩🏽‍❤️‍👨🏾,👩🏽‍❤️‍👨🏿,👩🏽‍❤️‍👩🏻,👩🏽‍❤️‍👩🏼,👩🏽‍❤️‍👩🏽,👩🏽‍❤️‍👩🏾,👩🏽‍❤️‍👩🏿,👩🏽‍❤️‍💋‍👨🏻,👩🏽‍❤️‍💋‍👨🏼,👩🏽‍❤️‍💋‍👨🏽,👩🏽‍❤️‍💋‍👨🏾,👩🏽‍❤️‍💋‍👨🏿,👩🏽‍❤️‍💋‍👩🏻,👩🏽‍❤️‍💋‍👩🏼,👩🏽‍❤️‍💋‍👩🏽,👩🏽‍❤️‍💋‍👩🏾,👩🏽‍❤️‍💋‍👩🏿,👩🏽‍🤝‍👨🏻,👩🏽‍🤝‍👨🏼,👩🏽‍🤝‍👨🏾,👩🏽‍🤝‍👨🏿,👩🏽‍🤝‍👩🏻,👩🏽‍🤝‍👩🏼,👩🏽‍🤝‍👩🏾,👩🏽‍🤝‍👩🏿,👩🏾‍❤️‍👨🏻,👩🏾‍❤️‍👨🏼,👩🏾‍❤️‍👨🏽,👩🏾‍❤️‍👨🏾,👩🏾‍❤️‍👨🏿,👩🏾‍❤️‍👩🏻,👩🏾‍❤️‍👩🏼,👩🏾‍❤️‍👩🏽,👩🏾‍❤️‍👩🏾,👩🏾‍❤️‍👩🏿,👩🏾‍❤️‍💋‍👨🏻,👩🏾‍❤️‍💋‍👨🏼,👩🏾‍❤️‍💋‍👨🏽,👩🏾‍❤️‍💋‍👨🏾,👩🏾‍❤️‍💋‍👨🏿,👩🏾‍❤️‍💋‍👩🏻,👩🏾‍❤️‍💋‍👩🏼,👩🏾‍❤️‍💋‍👩🏽,👩🏾‍❤️‍💋‍👩🏾,👩🏾‍❤️‍💋‍👩🏿,👩🏾‍🤝‍👨🏻,👩🏾‍🤝‍👨🏼,👩🏾‍🤝‍👨🏽,👩🏾‍🤝‍👨🏿,👩🏾‍🤝‍👩🏻,👩🏾‍🤝‍👩🏼,👩🏾‍🤝‍👩🏽,👩🏾‍🤝‍👩🏿,👩🏿‍❤️‍👨🏻,👩🏿‍❤️‍👨🏼,👩🏿‍❤️‍👨🏽,👩🏿‍❤️‍👨🏾,👩🏿‍❤️‍👨🏿,👩🏿‍❤️‍👩🏻,👩🏿‍❤️‍👩🏼,👩🏿‍❤️‍👩🏽,👩🏿‍❤️‍👩🏾,👩🏿‍❤️‍👩🏿,👩🏿‍❤️‍💋‍👨🏻,👩🏿‍❤️‍💋‍👨🏼,👩🏿‍❤️‍💋‍👨🏽,👩🏿‍❤️‍💋‍👨🏾,👩🏿‍❤️‍💋‍👨🏿,👩🏿‍❤️‍💋‍👩🏻,👩🏿‍❤️‍💋‍👩🏼,👩🏿‍❤️‍💋‍👩🏽,👩🏿‍❤️‍💋‍👩🏾,👩🏿‍❤️‍💋‍👩🏿,👩🏿‍🤝‍👨🏻,👩🏿‍🤝‍👨🏼,👩🏿‍🤝‍👨🏽,👩🏿‍🤝‍👨🏾,👩🏿‍🤝‍👩🏻,👩🏿‍🤝‍👩🏼,👩🏿‍🤝‍👩🏽,👩🏿‍🤝‍👩🏾,🧑‍🤝‍🧑,🧑‍🧑‍🧒,🧑‍🧑‍🧒‍🧒,🧑‍🧒,🧑‍🧒‍🧒,🧑🏻‍❤️‍💋‍🧑🏼,🧑🏻‍❤️‍💋‍🧑🏽,🧑🏻‍❤️‍💋‍🧑🏾,🧑🏻‍❤️‍💋‍🧑🏿,🧑🏻‍❤️‍🧑🏼,🧑🏻‍❤️‍🧑🏽,🧑🏻‍❤️‍🧑🏾,🧑🏻‍❤️‍🧑🏿,🧑🏻‍🤝‍🧑🏻,🧑🏻‍🤝‍🧑🏼,🧑🏻‍🤝‍🧑🏽,🧑🏻‍🤝‍🧑🏾,🧑🏻‍🤝‍🧑🏿,🧑🏼‍❤️‍💋‍🧑🏻,🧑🏼‍❤️‍💋‍🧑🏽,🧑🏼‍❤️‍💋‍🧑🏾,🧑🏼‍❤️‍💋‍🧑🏿,🧑🏼‍❤️‍🧑🏻,🧑🏼‍❤️‍🧑🏽,🧑🏼‍❤️‍🧑🏾,🧑🏼‍❤️‍🧑🏿,🧑🏼‍🤝‍🧑🏻,🧑🏼‍🤝‍🧑🏼,🧑🏼‍🤝‍🧑🏽,🧑🏼‍🤝‍🧑🏾,🧑🏼‍🤝‍🧑🏿,🧑🏽‍❤️‍💋‍🧑🏻,🧑🏽‍❤️‍💋‍🧑🏼,🧑🏽‍❤️‍💋‍🧑🏾,🧑🏽‍❤️‍💋‍🧑🏿,🧑🏽‍❤️‍🧑🏻,🧑🏽‍❤️‍🧑🏼,🧑🏽‍❤️‍🧑🏾,🧑🏽‍❤️‍🧑🏿,🧑🏽‍🤝‍🧑🏻,🧑🏽‍🤝‍🧑🏼,🧑🏽‍🤝‍🧑🏽,🧑🏽‍🤝‍🧑🏾,🧑🏽‍🤝‍🧑🏿,🧑🏾‍❤️‍💋‍🧑🏻,🧑🏾‍❤️‍💋‍🧑🏼,🧑🏾‍❤️‍💋‍🧑🏽,🧑🏾‍❤️‍💋‍🧑🏿,🧑🏾‍❤️‍🧑🏻,🧑🏾‍❤️‍🧑🏼,🧑🏾‍❤️‍🧑🏽,🧑🏾‍❤️‍🧑🏿,🧑🏾‍🤝‍🧑🏻,🧑🏾‍🤝‍🧑🏼,🧑🏾‍🤝‍🧑🏽,🧑🏾‍🤝‍🧑🏾,🧑🏾‍🤝‍🧑🏿,🧑🏿‍❤️‍💋‍🧑🏻,🧑🏿‍❤️‍💋‍🧑🏼,🧑🏿‍❤️‍💋‍🧑🏽,🧑🏿‍❤️‍💋‍🧑🏾,🧑🏿‍❤️‍🧑🏻,🧑🏿‍❤️‍🧑🏼,🧑🏿‍❤️‍🧑🏽,🧑🏿‍❤️‍🧑🏾,🧑🏿‍🤝‍🧑🏻,🧑🏿‍🤝‍🧑🏼,🧑🏿‍🤝‍🧑🏽,🧑🏿‍🤝‍🧑🏾,🧑🏿‍🤝‍🧑🏿,🫱🏻‍🫲🏼,🫱🏻‍🫲🏽,🫱🏻‍🫲🏾,🫱🏻‍🫲🏿,🫱🏼‍🫲🏻,🫱🏼‍🫲🏽,🫱🏼‍🫲🏾,🫱🏼‍🫲🏿,🫱🏽‍🫲🏻,🫱🏽‍🫲🏼,🫱🏽‍🫲🏾,🫱🏽‍🫲🏿,🫱🏾‍🫲🏻,🫱🏾‍🫲🏼,🫱🏾‍🫲🏽,🫱🏾‍🫲🏿,🫱🏿‍🫲🏻,🫱🏿‍🫲🏼,🫱🏿‍🫲🏽,🫱🏿‍🫲🏾,🏃‍➡️,🏃🏻‍➡️,🏃🏼‍➡️,🏃🏽‍➡️,🏃🏾‍➡️,🏃🏿‍➡️,👨‍⚕️,👨‍⚖️,👨‍✈️,👨‍🌾,👨‍🍳,👨‍🍼,👨‍🎓,👨‍🎤,👨‍🎨,👨‍🏫,👨‍🏭,👨‍💻,👨‍💼,👨‍🔧,👨‍🔬,👨‍🚀,👨‍🚒,👨‍🦯,👨‍🦯‍➡️,👨‍🦼,👨‍🦼‍➡️,👨‍🦽,👨‍🦽‍➡️,👨🏻‍⚕️,👨🏻‍⚖️,👨🏻‍✈️,👨🏻‍🌾,👨🏻‍🍳,👨🏻‍🍼,👨🏻‍🎓,👨🏻‍🎤,👨🏻‍🎨,👨🏻‍🏫,👨🏻‍🏭,👨🏻‍💻,👨🏻‍💼,👨🏻‍🔧,👨🏻‍🔬,👨🏻‍🚀,👨🏻‍🚒,👨🏻‍🦯,👨🏻‍🦯‍➡️,👨🏻‍🦼,👨🏻‍🦼‍➡️,👨🏻‍🦽,👨🏻‍🦽‍➡️,👨🏼‍⚕️,👨🏼‍⚖️,👨🏼‍✈️,👨🏼‍🌾,👨🏼‍🍳,👨🏼‍🍼,👨🏼‍🎓,👨🏼‍🎤,👨🏼‍🎨,👨🏼‍🏫,👨🏼‍🏭,👨🏼‍💻,👨🏼‍💼,👨🏼‍🔧,👨🏼‍🔬,👨🏼‍🚀,👨🏼‍🚒,👨🏼‍🦯,👨🏼‍🦯‍➡️,👨🏼‍🦼,👨🏼‍🦼‍➡️,👨🏼‍🦽,👨🏼‍🦽‍➡️,👨🏽‍⚕️,👨🏽‍⚖️,👨🏽‍✈️,👨🏽‍🌾,👨🏽‍🍳,👨🏽‍🍼,👨🏽‍🎓,👨🏽‍🎤,👨🏽‍🎨,👨🏽‍🏫,👨🏽‍🏭,👨🏽‍💻,👨🏽‍💼,👨🏽‍🔧,👨🏽‍🔬,👨🏽‍🚀,👨🏽‍🚒,👨🏽‍🦯,👨🏽‍🦯‍➡️,👨🏽‍🦼,👨🏽‍🦼‍➡️,👨🏽‍🦽,👨🏽‍🦽‍➡️,👨🏾‍⚕️,👨🏾‍⚖️,👨🏾‍✈️,👨🏾‍🌾,👨🏾‍🍳,👨🏾‍🍼,👨🏾‍🎓,👨🏾‍🎤,👨🏾‍🎨,👨🏾‍🏫,👨🏾‍🏭,👨🏾‍💻,👨🏾‍💼,👨🏾‍🔧,👨🏾‍🔬,👨🏾‍🚀,👨🏾‍🚒,👨🏾‍🦯,👨🏾‍🦯‍➡️,👨🏾‍🦼,👨🏾‍🦼‍➡️,👨🏾‍🦽,👨🏾‍🦽‍➡️,👨🏿‍⚕️,👨🏿‍⚖️,👨🏿‍✈️,👨🏿‍🌾,👨🏿‍🍳,👨🏿‍🍼,👨🏿‍🎓,👨🏿‍🎤,👨🏿‍🎨,👨🏿‍🏫,👨🏿‍🏭,👨🏿‍💻,👨🏿‍💼,👨🏿‍🔧,👨🏿‍🔬,👨🏿‍🚀,👨🏿‍🚒,👨🏿‍🦯,👨🏿‍🦯‍➡️,👨🏿‍🦼,👨🏿‍🦼‍➡️,👨🏿‍🦽,👨🏿‍🦽‍➡️,👩‍⚕️,👩‍⚖️,👩‍✈️,👩‍🌾,👩‍🍳,👩‍🍼,👩‍🎓,👩‍🎤,👩‍🎨,👩‍🏫,👩‍🏭,👩‍💻,👩‍💼,👩‍🔧,👩‍🔬,👩‍🚀,👩‍🚒,👩‍🦯,👩‍🦯‍➡️,👩‍🦼,👩‍🦼‍➡️,👩‍🦽,👩‍🦽‍➡️,👩🏻‍⚕️,👩🏻‍⚖️,👩🏻‍✈️,👩🏻‍🌾,👩🏻‍🍳,👩🏻‍🍼,👩🏻‍🎓,👩🏻‍🎤,👩🏻‍🎨,👩🏻‍🏫,👩🏻‍🏭,👩🏻‍💻,👩🏻‍💼,👩🏻‍🔧,👩🏻‍🔬,👩🏻‍🚀,👩🏻‍🚒,👩🏻‍🦯,👩🏻‍🦯‍➡️,👩🏻‍🦼,👩🏻‍🦼‍➡️,👩🏻‍🦽,👩🏻‍🦽‍➡️,👩🏼‍⚕️,👩🏼‍⚖️,👩🏼‍✈️,👩🏼‍🌾,👩🏼‍🍳,👩🏼‍🍼,👩🏼‍🎓,👩🏼‍🎤,👩🏼‍🎨,👩🏼‍🏫,👩🏼‍🏭,👩🏼‍💻,👩🏼‍💼,👩🏼‍🔧,👩🏼‍🔬,👩🏼‍🚀,👩🏼‍🚒,👩🏼‍🦯,👩🏼‍🦯‍➡️,👩🏼‍🦼,👩🏼‍🦼‍➡️,👩🏼‍🦽,👩🏼‍🦽‍➡️,👩🏽‍⚕️,👩🏽‍⚖️,👩🏽‍✈️,👩🏽‍🌾,👩🏽‍🍳,👩🏽‍🍼,👩🏽‍🎓,👩🏽‍🎤,👩🏽‍🎨,👩🏽‍🏫,👩🏽‍🏭,👩🏽‍💻,👩🏽‍💼,👩🏽‍🔧,👩🏽‍🔬,👩🏽‍🚀,👩🏽‍🚒,👩🏽‍🦯,👩🏽‍🦯‍➡️,👩🏽‍🦼,👩🏽‍🦼‍➡️,👩🏽‍🦽,👩🏽‍🦽‍➡️,👩🏾‍⚕️,👩🏾‍⚖️,👩🏾‍✈️,👩🏾‍🌾,👩🏾‍🍳,👩🏾‍🍼,👩🏾‍🎓,👩🏾‍🎤,👩🏾‍🎨,👩🏾‍🏫,👩🏾‍🏭,👩🏾‍💻,👩🏾‍💼,👩🏾‍🔧,👩🏾‍🔬,👩🏾‍🚀,👩🏾‍🚒,👩🏾‍🦯,👩🏾‍🦯‍➡️,👩🏾‍🦼,👩🏾‍🦼‍➡️,👩🏾‍🦽,👩🏾‍🦽‍➡️,👩🏿‍⚕️,👩🏿‍⚖️,👩🏿‍✈️,👩🏿‍🌾,👩🏿‍🍳,👩🏿‍🍼,👩🏿‍🎓,👩🏿‍🎤,👩🏿‍🎨,👩🏿‍🏫,👩🏿‍🏭,👩🏿‍💻,👩🏿‍💼,👩🏿‍🔧,👩🏿‍🔬,👩🏿‍🚀,👩🏿‍🚒,👩🏿‍🦯,👩🏿‍🦯‍➡️,👩🏿‍🦼,👩🏿‍🦼‍➡️,👩🏿‍🦽,👩🏿‍🦽‍➡️,🚶‍➡️,🚶🏻‍➡️,🚶🏼‍➡️,🚶🏽‍➡️,🚶🏾‍➡️,🚶🏿‍➡️,🧎‍➡️,🧎🏻‍➡️,🧎🏼‍➡️,🧎🏽‍➡️,🧎🏾‍➡️,🧎🏿‍➡️,🧑‍⚕️,🧑‍⚖️,🧑‍✈️,🧑‍🌾,🧑‍🍳,🧑‍🍼,🧑‍🎄,🧑‍🎓,🧑‍🎤,🧑‍🎨,🧑‍🏫,🧑‍🏭,🧑‍💻,🧑‍💼,🧑‍🔧,🧑‍🔬,🧑‍🚀,🧑‍🚒,🧑‍🦯,🧑‍🦯‍➡️,🧑‍🦼,🧑‍🦼‍➡️,🧑‍🦽,🧑‍🦽‍➡️,🧑🏻‍⚕️,🧑🏻‍⚖️,🧑🏻‍✈️,🧑🏻‍🌾,🧑🏻‍🍳,🧑🏻‍🍼,🧑🏻‍🎄,🧑🏻‍🎓,🧑🏻‍🎤,🧑🏻‍🎨,🧑🏻‍🏫,🧑🏻‍🏭,🧑🏻‍💻,🧑🏻‍💼,🧑🏻‍🔧,🧑🏻‍🔬,🧑🏻‍🚀,🧑🏻‍🚒,🧑🏻‍🦯,🧑🏻‍🦯‍➡️,🧑🏻‍🦼,🧑🏻‍🦼‍➡️,🧑🏻‍🦽,🧑🏻‍🦽‍➡️,🧑🏼‍⚕️,🧑🏼‍⚖️,🧑🏼‍✈️,🧑🏼‍🌾,🧑🏼‍🍳,🧑🏼‍🍼,🧑🏼‍🎄,🧑🏼‍🎓,🧑🏼‍🎤,🧑🏼‍🎨,🧑🏼‍🏫,🧑🏼‍🏭,🧑🏼‍💻,🧑🏼‍💼,🧑🏼‍🔧,🧑🏼‍🔬,🧑🏼‍🚀,🧑🏼‍🚒,🧑🏼‍🦯,🧑🏼‍🦯‍➡️,🧑🏼‍🦼,🧑🏼‍🦼‍➡️,🧑🏼‍🦽,🧑🏼‍🦽‍➡️,🧑🏽‍⚕️,🧑🏽‍⚖️,🧑🏽‍✈️,🧑🏽‍🌾,🧑🏽‍🍳,🧑🏽‍🍼,🧑🏽‍🎄,🧑🏽‍🎓,🧑🏽‍🎤,🧑🏽‍🎨,🧑🏽‍🏫,🧑🏽‍🏭,🧑🏽‍💻,🧑🏽‍💼,🧑🏽‍🔧,🧑🏽‍🔬,🧑🏽‍🚀,🧑🏽‍🚒,🧑🏽‍🦯,🧑🏽‍🦯‍➡️,🧑🏽‍🦼,🧑🏽‍🦼‍➡️,🧑🏽‍🦽,🧑🏽‍🦽‍➡️,🧑🏾‍⚕️,🧑🏾‍⚖️,🧑🏾‍✈️,🧑🏾‍🌾,🧑🏾‍🍳,🧑🏾‍🍼,🧑🏾‍🎄,🧑🏾‍🎓,🧑🏾‍🎤,🧑🏾‍🎨,🧑🏾‍🏫,🧑🏾‍🏭,🧑🏾‍💻,🧑🏾‍💼,🧑🏾‍🔧,🧑🏾‍🔬,🧑🏾‍🚀,🧑🏾‍🚒,🧑🏾‍🦯,🧑🏾‍🦯‍➡️,🧑🏾‍🦼,🧑🏾‍🦼‍➡️,🧑🏾‍🦽,🧑🏾‍🦽‍➡️,🧑🏿‍⚕️,🧑🏿‍⚖️,🧑🏿‍✈️,🧑🏿‍🌾,🧑🏿‍🍳,🧑🏿‍🍼,🧑🏿‍🎄,🧑🏿‍🎓,🧑🏿‍🎤,🧑🏿‍🎨,🧑🏿‍🏫,🧑🏿‍🏭,🧑🏿‍💻,🧑🏿‍💼,🧑🏿‍🔧,🧑🏿‍🔬,🧑🏿‍🚀,🧑🏿‍🚒,🧑🏿‍🦯,🧑🏿‍🦯‍➡️,🧑🏿‍🦼,🧑🏿‍🦼‍➡️,🧑🏿‍🦽,🧑🏿‍🦽‍➡️,⛹🏻‍♀️,⛹🏻‍♂️,⛹🏼‍♀️,⛹🏼‍♂️,⛹🏽‍♀️,⛹🏽‍♂️,⛹🏾‍♀️,⛹🏾‍♂️,⛹🏿‍♀️,⛹🏿‍♂️,⛹️‍♀️,⛹️‍♂️,🏃‍♀️,🏃‍♀️‍➡️,🏃‍♂️,🏃‍♂️‍➡️,🏃🏻‍♀️,🏃🏻‍♀️‍➡️,🏃🏻‍♂️,🏃🏻‍♂️‍➡️,🏃🏼‍♀️,🏃🏼‍♀️‍➡️,🏃🏼‍♂️,🏃🏼‍♂️‍➡️,🏃🏽‍♀️,🏃🏽‍♀️‍➡️,🏃🏽‍♂️,🏃🏽‍♂️‍➡️,🏃🏾‍♀️,🏃🏾‍♀️‍➡️,🏃🏾‍♂️,🏃🏾‍♂️‍➡️,🏃🏿‍♀️,🏃🏿‍♀️‍➡️,🏃🏿‍♂️,🏃🏿‍♂️‍➡️,🏄‍♀️,🏄‍♂️,🏄🏻‍♀️,🏄🏻‍♂️,🏄🏼‍♀️,🏄🏼‍♂️,🏄🏽‍♀️,🏄🏽‍♂️,🏄🏾‍♀️,🏄🏾‍♂️,🏄🏿‍♀️,🏄🏿‍♂️,🏊‍♀️,🏊‍♂️,🏊🏻‍♀️,🏊🏻‍♂️,🏊🏼‍♀️,🏊🏼‍♂️,🏊🏽‍♀️,🏊🏽‍♂️,🏊🏾‍♀️,🏊🏾‍♂️,🏊🏿‍♀️,🏊🏿‍♂️,🏋🏻‍♀️,🏋🏻‍♂️,🏋🏼‍♀️,🏋🏼‍♂️,🏋🏽‍♀️,🏋🏽‍♂️,🏋🏾‍♀️,🏋🏾‍♂️,🏋🏿‍♀️,🏋🏿‍♂️,🏋️‍♀️,🏋️‍♂️,🏌🏻‍♀️,🏌🏻‍♂️,🏌🏼‍♀️,🏌🏼‍♂️,🏌🏽‍♀️,🏌🏽‍♂️,🏌🏾‍♀️,🏌🏾‍♂️,🏌🏿‍♀️,🏌🏿‍♂️,🏌️‍♀️,🏌️‍♂️,👮‍♀️,👮‍♂️,👮🏻‍♀️,👮🏻‍♂️,👮🏼‍♀️,👮🏼‍♂️,👮🏽‍♀️,👮🏽‍♂️,👮🏾‍♀️,👮🏾‍♂️,👮🏿‍♀️,👮🏿‍♂️,👯‍♀️,👯‍♂️,👰‍♀️,👰‍♂️,👰🏻‍♀️,👰🏻‍♂️,👰🏼‍♀️,👰🏼‍♂️,👰🏽‍♀️,👰🏽‍♂️,👰🏾‍♀️,👰🏾‍♂️,👰🏿‍♀️,👰🏿‍♂️,👱‍♀️,👱‍♂️,👱🏻‍♀️,👱🏻‍♂️,👱🏼‍♀️,👱🏼‍♂️,👱🏽‍♀️,👱🏽‍♂️,👱🏾‍♀️,👱🏾‍♂️,👱🏿‍♀️,👱🏿‍♂️,👳‍♀️,👳‍♂️,👳🏻‍♀️,👳🏻‍♂️,👳🏼‍♀️,👳🏼‍♂️,👳🏽‍♀️,👳🏽‍♂️,👳🏾‍♀️,👳🏾‍♂️,👳🏿‍♀️,👳🏿‍♂️,👷‍♀️,👷‍♂️,👷🏻‍♀️,👷🏻‍♂️,👷🏼‍♀️,👷🏼‍♂️,👷🏽‍♀️,👷🏽‍♂️,👷🏾‍♀️,👷🏾‍♂️,👷🏿‍♀️,👷🏿‍♂️,💁‍♀️,💁‍♂️,💁🏻‍♀️,💁🏻‍♂️,💁🏼‍♀️,💁🏼‍♂️,💁🏽‍♀️,💁🏽‍♂️,💁🏾‍♀️,💁🏾‍♂️,💁🏿‍♀️,💁🏿‍♂️,💂‍♀️,💂‍♂️,💂🏻‍♀️,💂🏻‍♂️,💂🏼‍♀️,💂🏼‍♂️,💂🏽‍♀️,💂🏽‍♂️,💂🏾‍♀️,💂🏾‍♂️,💂🏿‍♀️,💂🏿‍♂️,💆‍♀️,💆‍♂️,💆🏻‍♀️,💆🏻‍♂️,💆🏼‍♀️,💆🏼‍♂️,💆🏽‍♀️,💆🏽‍♂️,💆🏾‍♀️,💆🏾‍♂️,💆🏿‍♀️,💆🏿‍♂️,💇‍♀️,💇‍♂️,💇🏻‍♀️,💇🏻‍♂️,💇🏼‍♀️,💇🏼‍♂️,💇🏽‍♀️,💇🏽‍♂️,💇🏾‍♀️,💇🏾‍♂️,💇🏿‍♀️,💇🏿‍♂️,🕵🏻‍♀️,🕵🏻‍♂️,🕵🏼‍♀️,🕵🏼‍♂️,🕵🏽‍♀️,🕵🏽‍♂️,🕵🏾‍♀️,🕵🏾‍♂️,🕵🏿‍♀️,🕵🏿‍♂️,🕵️‍♀️,🕵️‍♂️,🙅‍♀️,🙅‍♂️,🙅🏻‍♀️,🙅🏻‍♂️,🙅🏼‍♀️,🙅🏼‍♂️,🙅🏽‍♀️,🙅🏽‍♂️,🙅🏾‍♀️,🙅🏾‍♂️,🙅🏿‍♀️,🙅🏿‍♂️,🙆‍♀️,🙆‍♂️,🙆🏻‍♀️,🙆🏻‍♂️,🙆🏼‍♀️,🙆🏼‍♂️,🙆🏽‍♀️,🙆🏽‍♂️,🙆🏾‍♀️,🙆🏾‍♂️,🙆🏿‍♀️,🙆🏿‍♂️,🙇‍♀️,🙇‍♂️,🙇🏻‍♀️,🙇🏻‍♂️,🙇🏼‍♀️,🙇🏼‍♂️,🙇🏽‍♀️,🙇🏽‍♂️,🙇🏾‍♀️,🙇🏾‍♂️,🙇🏿‍♀️,🙇🏿‍♂️,🙋‍♀️,🙋‍♂️,🙋🏻‍♀️,🙋🏻‍♂️,🙋🏼‍♀️,🙋🏼‍♂️,🙋🏽‍♀️,🙋🏽‍♂️,🙋🏾‍♀️,🙋🏾‍♂️,🙋🏿‍♀️,🙋🏿‍♂️,🙍‍♀️,🙍‍♂️,🙍🏻‍♀️,🙍🏻‍♂️,🙍🏼‍♀️,🙍🏼‍♂️,🙍🏽‍♀️,🙍🏽‍♂️,🙍🏾‍♀️,🙍🏾‍♂️,🙍🏿‍♀️,🙍🏿‍♂️,🙎‍♀️,🙎‍♂️,🙎🏻‍♀️,🙎🏻‍♂️,🙎🏼‍♀️,🙎🏼‍♂️,🙎🏽‍♀️,🙎🏽‍♂️,🙎🏾‍♀️,🙎🏾‍♂️,🙎🏿‍♀️,🙎🏿‍♂️,🚣‍♀️,🚣‍♂️,🚣🏻‍♀️,🚣🏻‍♂️,🚣🏼‍♀️,🚣🏼‍♂️,🚣🏽‍♀️,🚣🏽‍♂️,🚣🏾‍♀️,🚣🏾‍♂️,🚣🏿‍♀️,🚣🏿‍♂️,🚴‍♀️,🚴‍♂️,🚴🏻‍♀️,🚴🏻‍♂️,🚴🏼‍♀️,🚴🏼‍♂️,🚴🏽‍♀️,🚴🏽‍♂️,🚴🏾‍♀️,🚴🏾‍♂️,🚴🏿‍♀️,🚴🏿‍♂️,🚵‍♀️,🚵‍♂️,🚵🏻‍♀️,🚵🏻‍♂️,🚵🏼‍♀️,🚵🏼‍♂️,🚵🏽‍♀️,🚵🏽‍♂️,🚵🏾‍♀️,🚵🏾‍♂️,🚵🏿‍♀️,🚵🏿‍♂️,🚶‍♀️,🚶‍♀️‍➡️,🚶‍♂️,🚶‍♂️‍➡️,🚶🏻‍♀️,🚶🏻‍♀️‍➡️,🚶🏻‍♂️,🚶🏻‍♂️‍➡️,🚶🏼‍♀️,🚶🏼‍♀️‍➡️,🚶🏼‍♂️,🚶🏼‍♂️‍➡️,🚶🏽‍♀️,🚶🏽‍♀️‍➡️,🚶🏽‍♂️,🚶🏽‍♂️‍➡️,🚶🏾‍♀️,🚶🏾‍♀️‍➡️,🚶🏾‍♂️,🚶🏾‍♂️‍➡️,🚶🏿‍♀️,🚶🏿‍♀️‍➡️,🚶🏿‍♂️,🚶🏿‍♂️‍➡️,🤦‍♀️,🤦‍♂️,🤦🏻‍♀️,🤦🏻‍♂️,🤦🏼‍♀️,🤦🏼‍♂️,🤦🏽‍♀️,🤦🏽‍♂️,🤦🏾‍♀️,🤦🏾‍♂️,🤦🏿‍♀️,🤦🏿‍♂️,🤵‍♀️,🤵‍♂️,🤵🏻‍♀️,🤵🏻‍♂️,🤵🏼‍♀️,🤵🏼‍♂️,🤵🏽‍♀️,🤵🏽‍♂️,🤵🏾‍♀️,🤵🏾‍♂️,🤵🏿‍♀️,🤵🏿‍♂️,🤷‍♀️,🤷‍♂️,🤷🏻‍♀️,🤷🏻‍♂️,🤷🏼‍♀️,🤷🏼‍♂️,🤷🏽‍♀️,🤷🏽‍♂️,🤷🏾‍♀️,🤷🏾‍♂️,🤷🏿‍♀️,🤷🏿‍♂️,🤸‍♀️,🤸‍♂️,🤸🏻‍♀️,🤸🏻‍♂️,🤸🏼‍♀️,🤸🏼‍♂️,🤸🏽‍♀️,🤸🏽‍♂️,🤸🏾‍♀️,🤸🏾‍♂️,🤸🏿‍♀️,🤸🏿‍♂️,🤹‍♀️,🤹‍♂️,🤹🏻‍♀️,🤹🏻‍♂️,🤹🏼‍♀️,🤹🏼‍♂️,🤹🏽‍♀️,🤹🏽‍♂️,🤹🏾‍♀️,🤹🏾‍♂️,🤹🏿‍♀️,🤹🏿‍♂️,🤼‍♀️,🤼‍♂️,🤽‍♀️,🤽‍♂️,🤽🏻‍♀️,🤽🏻‍♂️,🤽🏼‍♀️,🤽🏼‍♂️,🤽🏽‍♀️,🤽🏽‍♂️,🤽🏾‍♀️,🤽🏾‍♂️,🤽🏿‍♀️,🤽🏿‍♂️,🤾‍♀️,🤾‍♂️,🤾🏻‍♀️,🤾🏻‍♂️,🤾🏼‍♀️,🤾🏼‍♂️,🤾🏽‍♀️,🤾🏽‍♂️,🤾🏾‍♀️,🤾🏾‍♂️,🤾🏿‍♀️,🤾🏿‍♂️,🦸‍♀️,🦸‍♂️,🦸🏻‍♀️,🦸🏻‍♂️,🦸🏼‍♀️,🦸🏼‍♂️,🦸🏽‍♀️,🦸🏽‍♂️,🦸🏾‍♀️,🦸🏾‍♂️,🦸🏿‍♀️,🦸🏿‍♂️,🦹‍♀️,🦹‍♂️,🦹🏻‍♀️,🦹🏻‍♂️,🦹🏼‍♀️,🦹🏼‍♂️,🦹🏽‍♀️,🦹🏽‍♂️,🦹🏾‍♀️,🦹🏾‍♂️,🦹🏿‍♀️,🦹🏿‍♂️,🧍‍♀️,🧍‍♂️,🧍🏻‍♀️,🧍🏻‍♂️,🧍🏼‍♀️,🧍🏼‍♂️,🧍🏽‍♀️,🧍🏽‍♂️,🧍🏾‍♀️,🧍🏾‍♂️,🧍🏿‍♀️,🧍🏿‍♂️,🧎‍♀️,🧎‍♀️‍➡️,🧎‍♂️,🧎‍♂️‍➡️,🧎🏻‍♀️,🧎🏻‍♀️‍➡️,🧎🏻‍♂️,🧎🏻‍♂️‍➡️,🧎🏼‍♀️,🧎🏼‍♀️‍➡️,🧎🏼‍♂️,🧎🏼‍♂️‍➡️,🧎🏽‍♀️,🧎🏽‍♀️‍➡️,🧎🏽‍♂️,🧎🏽‍♂️‍➡️,🧎🏾‍♀️,🧎🏾‍♀️‍➡️,🧎🏾‍♂️,🧎🏾‍♂️‍➡️,🧎🏿‍♀️,🧎🏿‍♀️‍➡️,🧎🏿‍♂️,🧎🏿‍♂️‍➡️,🧏‍♀️,🧏‍♂️,🧏🏻‍♀️,🧏🏻‍♂️,🧏🏼‍♀️,🧏🏼‍♂️,🧏🏽‍♀️,🧏🏽‍♂️,🧏🏾‍♀️,🧏🏾‍♂️,🧏🏿‍♀️,🧏🏿‍♂️,🧔‍♀️,🧔‍♂️,🧔🏻‍♀️,🧔🏻‍♂️,🧔🏼‍♀️,🧔🏼‍♂️,🧔🏽‍♀️,🧔🏽‍♂️,🧔🏾‍♀️,🧔🏾‍♂️,🧔🏿‍♀️,🧔🏿‍♂️,🧖‍♀️,🧖‍♂️,🧖🏻‍♀️,🧖🏻‍♂️,🧖🏼‍♀️,🧖🏼‍♂️,🧖🏽‍♀️,🧖🏽‍♂️,🧖🏾‍♀️,🧖🏾‍♂️,🧖🏿‍♀️,🧖🏿‍♂️,🧗‍♀️,🧗‍♂️,🧗🏻‍♀️,🧗🏻‍♂️,🧗🏼‍♀️,🧗🏼‍♂️,🧗🏽‍♀️,🧗🏽‍♂️,🧗🏾‍♀️,🧗🏾‍♂️,🧗🏿‍♀️,🧗🏿‍♂️,🧘‍♀️,🧘‍♂️,🧘🏻‍♀️,🧘🏻‍♂️,🧘🏼‍♀️,🧘🏼‍♂️,🧘🏽‍♀️,🧘🏽‍♂️,🧘🏾‍♀️,🧘🏾‍♂️,🧘🏿‍♀️,🧘🏿‍♂️,🧙‍♀️,🧙‍♂️,🧙🏻‍♀️,🧙🏻‍♂️,🧙🏼‍♀️,🧙🏼‍♂️,🧙🏽‍♀️,🧙🏽‍♂️,🧙🏾‍♀️,🧙🏾‍♂️,🧙🏿‍♀️,🧙🏿‍♂️,🧚‍♀️,🧚‍♂️,🧚🏻‍♀️,🧚🏻‍♂️,🧚🏼‍♀️,🧚🏼‍♂️,🧚🏽‍♀️,🧚🏽‍♂️,🧚🏾‍♀️,🧚🏾‍♂️,🧚🏿‍♀️,🧚🏿‍♂️,🧛‍♀️,🧛‍♂️,🧛🏻‍♀️,🧛🏻‍♂️,🧛🏼‍♀️,🧛🏼‍♂️,🧛🏽‍♀️,🧛🏽‍♂️,🧛🏾‍♀️,🧛🏾‍♂️,🧛🏿‍♀️,🧛🏿‍♂️,🧜‍♀️,🧜‍♂️,🧜🏻‍♀️,🧜🏻‍♂️,🧜🏼‍♀️,🧜🏼‍♂️,🧜🏽‍♀️,🧜🏽‍♂️,🧜🏾‍♀️,🧜🏾‍♂️,🧜🏿‍♀️,🧜🏿‍♂️,🧝‍♀️,🧝‍♂️,🧝🏻‍♀️,🧝🏻‍♂️,🧝🏼‍♀️,🧝🏼‍♂️,🧝🏽‍♀️,🧝🏽‍♂️,🧝🏾‍♀️,🧝🏾‍♂️,🧝🏿‍♀️,🧝🏿‍♂️,🧞‍♀️,🧞‍♂️,🧟‍♀️,🧟‍♂️,👨‍🦰,👨‍🦱,👨‍🦲,👨‍🦳,👨🏻‍🦰,👨🏻‍🦱,👨🏻‍🦲,👨🏻‍🦳,👨🏼‍🦰,👨🏼‍🦱,👨🏼‍🦲,👨🏼‍🦳,👨🏽‍🦰,👨🏽‍🦱,👨🏽‍🦲,👨🏽‍🦳,👨🏾‍🦰,👨🏾‍🦱,👨🏾‍🦲,👨🏾‍🦳,👨🏿‍🦰,👨🏿‍🦱,👨🏿‍🦲,👨🏿‍🦳,👩‍🦰,👩‍🦱,👩‍🦲,👩‍🦳,👩🏻‍🦰,👩🏻‍🦱,👩🏻‍🦲,👩🏻‍🦳,👩🏼‍🦰,👩🏼‍🦱,👩🏼‍🦲,👩🏼‍🦳,👩🏽‍🦰,👩🏽‍🦱,👩🏽‍🦲,👩🏽‍🦳,👩🏾‍🦰,👩🏾‍🦱,👩🏾‍🦲,👩🏾‍🦳,👩🏿‍🦰,👩🏿‍🦱,👩🏿‍🦲,👩🏿‍🦳,🧑‍🦰,🧑‍🦱,🧑‍🦲,🧑‍🦳,🧑🏻‍🦰,🧑🏻‍🦱,🧑🏻‍🦲,🧑🏻‍🦳,🧑🏼‍🦰,🧑🏼‍🦱,🧑🏼‍🦲,🧑🏼‍🦳,🧑🏽‍🦰,🧑🏽‍🦱,🧑🏽‍🦲,🧑🏽‍🦳,🧑🏾‍🦰,🧑🏾‍🦱,🧑🏾‍🦲,🧑🏾‍🦳,🧑🏿‍🦰,🧑🏿‍🦱,🧑🏿‍🦲,🧑🏿‍🦳,⛓️‍💥,❤️‍🔥,❤️‍🩹,🍄‍🟫,🍋‍🟩,🏳️‍⚧️,🏳️‍🌈,🏴‍☠️,🐈‍⬛,🐕‍🦺,🐦‍⬛,🐦‍🔥,🐻‍❄️,👁️‍🗨️,😮‍💨,😵‍💫,😶‍🌫️,🙂‍↔️,🙂‍↕️";var RGI_Emoji="#️⃣,*️⃣,0️⃣,1️⃣,2️⃣,3️⃣,4️⃣,5️⃣,6️⃣,7️⃣,8️⃣,9️⃣,©️,®️,‼️,⁉️,™️,ℹ️,↔️,↕️,↖️,↗️,↘️,↙️,↩️,↪️,⌚,⌛,⌨️,⏏️,⏩,⏪,⏫,⏬,⏭️,⏮️,⏯️,⏰,⏱️,⏲️,⏳,⏸️,⏹️,⏺️,Ⓜ️,▪️,▫️,▶️,◀️,◻️,◼️,◽,◾,☀️,☁️,☂️,☃️,☄️,☎️,☑️,☔,☕,☘️,☝🏻,☝🏼,☝🏽,☝🏾,☝🏿,☝️,☠️,☢️,☣️,☦️,☪️,☮️,☯️,☸️,☹️,☺️,♀️,♂️,♈,♉,♊,♋,♌,♍,♎,♏,♐,♑,♒,♓,♟️,♠️,♣️,♥️,♦️,♨️,♻️,♾️,♿,⚒️,⚓,⚔️,⚕️,⚖️,⚗️,⚙️,⚛️,⚜️,⚠️,⚡,⚧️,⚪,⚫,⚰️,⚱️,⚽,⚾,⛄,⛅,⛈️,⛎,⛏️,⛑️,⛓️,⛓️‍💥,⛔,⛩️,⛪,⛰️,⛱️,⛲,⛳,⛴️,⛵,⛷️,⛸️,⛹🏻,⛹🏻‍♀️,⛹🏻‍♂️,⛹🏼,⛹🏼‍♀️,⛹🏼‍♂️,⛹🏽,⛹🏽‍♀️,⛹🏽‍♂️,⛹🏾,⛹🏾‍♀️,⛹🏾‍♂️,⛹🏿,⛹🏿‍♀️,⛹🏿‍♂️,⛹️,⛹️‍♀️,⛹️‍♂️,⛺,⛽,✂️,✅,✈️,✉️,✊,✊🏻,✊🏼,✊🏽,✊🏾,✊🏿,✋,✋🏻,✋🏼,✋🏽,✋🏾,✋🏿,✌🏻,✌🏼,✌🏽,✌🏾,✌🏿,✌️,✍🏻,✍🏼,✍🏽,✍🏾,✍🏿,✍️,✏️,✒️,✔️,✖️,✝️,✡️,✨,✳️,✴️,❄️,❇️,❌,❎,❓,❔,❕,❗,❣️,❤️,❤️‍🔥,❤️‍🩹,➕,➖,➗,➡️,➰,➿,⤴️,⤵️,⬅️,⬆️,⬇️,⬛,⬜,⭐,⭕,〰️,〽️,㊗️,㊙️,🀄,🃏,🅰️,🅱️,🅾️,🅿️,🆎,🆑,🆒,🆓,🆔,🆕,🆖,🆗,🆘,🆙,🆚,🇦🇨,🇦🇩,🇦🇪,🇦🇫,🇦🇬,🇦🇮,🇦🇱,🇦🇲,🇦🇴,🇦🇶,🇦🇷,🇦🇸,🇦🇹,🇦🇺,🇦🇼,🇦🇽,🇦🇿,🇧🇦,🇧🇧,🇧🇩,🇧🇪,🇧🇫,🇧🇬,🇧🇭,🇧🇮,🇧🇯,🇧🇱,🇧🇲,🇧🇳,🇧🇴,🇧🇶,🇧🇷,🇧🇸,🇧🇹,🇧🇻,🇧🇼,🇧🇾,🇧🇿,🇨🇦,🇨🇨,🇨🇩,🇨🇫,🇨🇬,🇨🇭,🇨🇮,🇨🇰,🇨🇱,🇨🇲,🇨🇳,🇨🇴,🇨🇵,🇨🇶,🇨🇷,🇨🇺,🇨🇻,🇨🇼,🇨🇽,🇨🇾,🇨🇿,🇩🇪,🇩🇬,🇩🇯,🇩🇰,🇩🇲,🇩🇴,🇩🇿,🇪🇦,🇪🇨,🇪🇪,🇪🇬,🇪🇭,🇪🇷,🇪🇸,🇪🇹,🇪🇺,🇫🇮,🇫🇯,🇫🇰,🇫🇲,🇫🇴,🇫🇷,🇬🇦,🇬🇧,🇬🇩,🇬🇪,🇬🇫,🇬🇬,🇬🇭,🇬🇮,🇬🇱,🇬🇲,🇬🇳,🇬🇵,🇬🇶,🇬🇷,🇬🇸,🇬🇹,🇬🇺,🇬🇼,🇬🇾,🇭🇰,🇭🇲,🇭🇳,🇭🇷,🇭🇹,🇭🇺,🇮🇨,🇮🇩,🇮🇪,🇮🇱,🇮🇲,🇮🇳,🇮🇴,🇮🇶,🇮🇷,🇮🇸,🇮🇹,🇯🇪,🇯🇲,🇯🇴,🇯🇵,🇰🇪,🇰🇬,🇰🇭,🇰🇮,🇰🇲,🇰🇳,🇰🇵,🇰🇷,🇰🇼,🇰🇾,🇰🇿,🇱🇦,🇱🇧,🇱🇨,🇱🇮,🇱🇰,🇱🇷,🇱🇸,🇱🇹,🇱🇺,🇱🇻,🇱🇾,🇲🇦,🇲🇨,🇲🇩,🇲🇪,🇲🇫,🇲🇬,🇲🇭,🇲🇰,🇲🇱,🇲🇲,🇲🇳,🇲🇴,🇲🇵,🇲🇶,🇲🇷,🇲🇸,🇲🇹,🇲🇺,🇲🇻,🇲🇼,🇲🇽,🇲🇾,🇲🇿,🇳🇦,🇳🇨,🇳🇪,🇳🇫,🇳🇬,🇳🇮,🇳🇱,🇳🇴,🇳🇵,🇳🇷,🇳🇺,🇳🇿,🇴🇲,🇵🇦,🇵🇪,🇵🇫,🇵🇬,🇵🇭,🇵🇰,🇵🇱,🇵🇲,🇵🇳,🇵🇷,🇵🇸,🇵🇹,🇵🇼,🇵🇾,🇶🇦,🇷🇪,🇷🇴,🇷🇸,🇷🇺,🇷🇼,🇸🇦,🇸🇧,🇸🇨,🇸🇩,🇸🇪,🇸🇬,🇸🇭,🇸🇮,🇸🇯,🇸🇰,🇸🇱,🇸🇲,🇸🇳,🇸🇴,🇸🇷,🇸🇸,🇸🇹,🇸🇻,🇸🇽,🇸🇾,🇸🇿,🇹🇦,🇹🇨,🇹🇩,🇹🇫,🇹🇬,🇹🇭,🇹🇯,🇹🇰,🇹🇱,🇹🇲,🇹🇳,🇹🇴,🇹🇷,🇹🇹,🇹🇻,🇹🇼,🇹🇿,🇺🇦,🇺🇬,🇺🇲,🇺🇳,🇺🇸,🇺🇾,🇺🇿,🇻🇦,🇻🇨,🇻🇪,🇻🇬,🇻🇮,🇻🇳,🇻🇺,🇼🇫,🇼🇸,🇽🇰,🇾🇪,🇾🇹,🇿🇦,🇿🇲,🇿🇼,🈁,🈂️,🈚,🈯,🈲,🈳,🈴,🈵,🈶,🈷️,🈸,🈹,🈺,🉐,🉑,🌀,🌁,🌂,🌃,🌄,🌅,🌆,🌇,🌈,🌉,🌊,🌋,🌌,🌍,🌎,🌏,🌐,🌑,🌒,🌓,🌔,🌕,🌖,🌗,🌘,🌙,🌚,🌛,🌜,🌝,🌞,🌟,🌠,🌡️,🌤️,🌥️,🌦️,🌧️,🌨️,🌩️,🌪️,🌫️,🌬️,🌭,🌮,🌯,🌰,🌱,🌲,🌳,🌴,🌵,🌶️,🌷,🌸,🌹,🌺,🌻,🌼,🌽,🌾,🌿,🍀,🍁,🍂,🍃,🍄,🍄‍🟫,🍅,🍆,🍇,🍈,🍉,🍊,🍋,🍋‍🟩,🍌,🍍,🍎,🍏,🍐,🍑,🍒,🍓,🍔,🍕,🍖,🍗,🍘,🍙,🍚,🍛,🍜,🍝,🍞,🍟,🍠,🍡,🍢,🍣,🍤,🍥,🍦,🍧,🍨,🍩,🍪,🍫,🍬,🍭,🍮,🍯,🍰,🍱,🍲,🍳,🍴,🍵,🍶,🍷,🍸,🍹,🍺,🍻,🍼,🍽️,🍾,🍿,🎀,🎁,🎂,🎃,🎄,🎅,🎅🏻,🎅🏼,🎅🏽,🎅🏾,🎅🏿,🎆,🎇,🎈,🎉,🎊,🎋,🎌,🎍,🎎,🎏,🎐,🎑,🎒,🎓,🎖️,🎗️,🎙️,🎚️,🎛️,🎞️,🎟️,🎠,🎡,🎢,🎣,🎤,🎥,🎦,🎧,🎨,🎩,🎪,🎫,🎬,🎭,🎮,🎯,🎰,🎱,🎲,🎳,🎴,🎵,🎶,🎷,🎸,🎹,🎺,🎻,🎼,🎽,🎾,🎿,🏀,🏁,🏂,🏂🏻,🏂🏼,🏂🏽,🏂🏾,🏂🏿,🏃,🏃‍♀️,🏃‍♀️‍➡️,🏃‍♂️,🏃‍♂️‍➡️,🏃‍➡️,🏃🏻,🏃🏻‍♀️,🏃🏻‍♀️‍➡️,🏃🏻‍♂️,🏃🏻‍♂️‍➡️,🏃🏻‍➡️,🏃🏼,🏃🏼‍♀️,🏃🏼‍♀️‍➡️,🏃🏼‍♂️,🏃🏼‍♂️‍➡️,🏃🏼‍➡️,🏃🏽,🏃🏽‍♀️,🏃🏽‍♀️‍➡️,🏃🏽‍♂️,🏃🏽‍♂️‍➡️,🏃🏽‍➡️,🏃🏾,🏃🏾‍♀️,🏃🏾‍♀️‍➡️,🏃🏾‍♂️,🏃🏾‍♂️‍➡️,🏃🏾‍➡️,🏃🏿,🏃🏿‍♀️,🏃🏿‍♀️‍➡️,🏃🏿‍♂️,🏃🏿‍♂️‍➡️,🏃🏿‍➡️,🏄,🏄‍♀️,🏄‍♂️,🏄🏻,🏄🏻‍♀️,🏄🏻‍♂️,🏄🏼,🏄🏼‍♀️,🏄🏼‍♂️,🏄🏽,🏄🏽‍♀️,🏄🏽‍♂️,🏄🏾,🏄🏾‍♀️,🏄🏾‍♂️,🏄🏿,🏄🏿‍♀️,🏄🏿‍♂️,🏅,🏆,🏇,🏇🏻,🏇🏼,🏇🏽,🏇🏾,🏇🏿,🏈,🏉,🏊,🏊‍♀️,🏊‍♂️,🏊🏻,🏊🏻‍♀️,🏊🏻‍♂️,🏊🏼,🏊🏼‍♀️,🏊🏼‍♂️,🏊🏽,🏊🏽‍♀️,🏊🏽‍♂️,🏊🏾,🏊🏾‍♀️,🏊🏾‍♂️,🏊🏿,🏊🏿‍♀️,🏊🏿‍♂️,🏋🏻,🏋🏻‍♀️,🏋🏻‍♂️,🏋🏼,🏋🏼‍♀️,🏋🏼‍♂️,🏋🏽,🏋🏽‍♀️,🏋🏽‍♂️,🏋🏾,🏋🏾‍♀️,🏋🏾‍♂️,🏋🏿,🏋🏿‍♀️,🏋🏿‍♂️,🏋️,🏋️‍♀️,🏋️‍♂️,🏌🏻,🏌🏻‍♀️,🏌🏻‍♂️,🏌🏼,🏌🏼‍♀️,🏌🏼‍♂️,🏌🏽,🏌🏽‍♀️,🏌🏽‍♂️,🏌🏾,🏌🏾‍♀️,🏌🏾‍♂️,🏌🏿,🏌🏿‍♀️,🏌🏿‍♂️,🏌️,🏌️‍♀️,🏌️‍♂️,🏍️,🏎️,🏏,🏐,🏑,🏒,🏓,🏔️,🏕️,🏖️,🏗️,🏘️,🏙️,🏚️,🏛️,🏜️,🏝️,🏞️,🏟️,🏠,🏡,🏢,🏣,🏤,🏥,🏦,🏧,🏨,🏩,🏪,🏫,🏬,🏭,🏮,🏯,🏰,🏳️,🏳️‍⚧️,🏳️‍🌈,🏴,🏴‍☠️,🏴󠁧󠁢󠁥󠁮󠁧󠁿,🏴󠁧󠁢󠁳󠁣󠁴󠁿,🏴󠁧󠁢󠁷󠁬󠁳󠁿,🏵️,🏷️,🏸,🏹,🏺,🏻,🏼,🏽,🏾,🏿,🐀,🐁,🐂,🐃,🐄,🐅,🐆,🐇,🐈,🐈‍⬛,🐉,🐊,🐋,🐌,🐍,🐎,🐏,🐐,🐑,🐒,🐓,🐔,🐕,🐕‍🦺,🐖,🐗,🐘,🐙,🐚,🐛,🐜,🐝,🐞,🐟,🐠,🐡,🐢,🐣,🐤,🐥,🐦,🐦‍⬛,🐦‍🔥,🐧,🐨,🐩,🐪,🐫,🐬,🐭,🐮,🐯,🐰,🐱,🐲,🐳,🐴,🐵,🐶,🐷,🐸,🐹,🐺,🐻,🐻‍❄️,🐼,🐽,🐾,🐿️,👀,👁️,👁️‍🗨️,👂,👂🏻,👂🏼,👂🏽,👂🏾,👂🏿,👃,👃🏻,👃🏼,👃🏽,👃🏾,👃🏿,👄,👅,👆,👆🏻,👆🏼,👆🏽,👆🏾,👆🏿,👇,👇🏻,👇🏼,👇🏽,👇🏾,👇🏿,👈,👈🏻,👈🏼,👈🏽,👈🏾,👈🏿,👉,👉🏻,👉🏼,👉🏽,👉🏾,👉🏿,👊,👊🏻,👊🏼,👊🏽,👊🏾,👊🏿,👋,👋🏻,👋🏼,👋🏽,👋🏾,👋🏿,👌,👌🏻,👌🏼,👌🏽,👌🏾,👌🏿,👍,👍🏻,👍🏼,👍🏽,👍🏾,👍🏿,👎,👎🏻,👎🏼,👎🏽,👎🏾,👎🏿,👏,👏🏻,👏🏼,👏🏽,👏🏾,👏🏿,👐,👐🏻,👐🏼,👐🏽,👐🏾,👐🏿,👑,👒,👓,👔,👕,👖,👗,👘,👙,👚,👛,👜,👝,👞,👟,👠,👡,👢,👣,👤,👥,👦,👦🏻,👦🏼,👦🏽,👦🏾,👦🏿,👧,👧🏻,👧🏼,👧🏽,👧🏾,👧🏿,👨,👨‍⚕️,👨‍⚖️,👨‍✈️,👨‍❤️‍👨,👨‍❤️‍💋‍👨,👨‍🌾,👨‍🍳,👨‍🍼,👨‍🎓,👨‍🎤,👨‍🎨,👨‍🏫,👨‍🏭,👨‍👦,👨‍👦‍👦,👨‍👧,👨‍👧‍👦,👨‍👧‍👧,👨‍👨‍👦,👨‍👨‍👦‍👦,👨‍👨‍👧,👨‍👨‍👧‍👦,👨‍👨‍👧‍👧,👨‍👩‍👦,👨‍👩‍👦‍👦,👨‍👩‍👧,👨‍👩‍👧‍👦,👨‍👩‍👧‍👧,👨‍💻,👨‍💼,👨‍🔧,👨‍🔬,👨‍🚀,👨‍🚒,👨‍🦯,👨‍🦯‍➡️,👨‍🦰,👨‍🦱,👨‍🦲,👨‍🦳,👨‍🦼,👨‍🦼‍➡️,👨‍🦽,👨‍🦽‍➡️,👨🏻,👨🏻‍⚕️,👨🏻‍⚖️,👨🏻‍✈️,👨🏻‍❤️‍👨🏻,👨🏻‍❤️‍👨🏼,👨🏻‍❤️‍👨🏽,👨🏻‍❤️‍👨🏾,👨🏻‍❤️‍👨🏿,👨🏻‍❤️‍💋‍👨🏻,👨🏻‍❤️‍💋‍👨🏼,👨🏻‍❤️‍💋‍👨🏽,👨🏻‍❤️‍💋‍👨🏾,👨🏻‍❤️‍💋‍👨🏿,👨🏻‍🌾,👨🏻‍🍳,👨🏻‍🍼,👨🏻‍🎓,👨🏻‍🎤,👨🏻‍🎨,👨🏻‍🏫,👨🏻‍🏭,👨🏻‍💻,👨🏻‍💼,👨🏻‍🔧,👨🏻‍🔬,👨🏻‍🚀,👨🏻‍🚒,👨🏻‍🤝‍👨🏼,👨🏻‍🤝‍👨🏽,👨🏻‍🤝‍👨🏾,👨🏻‍🤝‍👨🏿,👨🏻‍🦯,👨🏻‍🦯‍➡️,👨🏻‍🦰,👨🏻‍🦱,👨🏻‍🦲,👨🏻‍🦳,👨🏻‍🦼,👨🏻‍🦼‍➡️,👨🏻‍🦽,👨🏻‍🦽‍➡️,👨🏼,👨🏼‍⚕️,👨🏼‍⚖️,👨🏼‍✈️,👨🏼‍❤️‍👨🏻,👨🏼‍❤️‍👨🏼,👨🏼‍❤️‍👨🏽,👨🏼‍❤️‍👨🏾,👨🏼‍❤️‍👨🏿,👨🏼‍❤️‍💋‍👨🏻,👨🏼‍❤️‍💋‍👨🏼,👨🏼‍❤️‍💋‍👨🏽,👨🏼‍❤️‍💋‍👨🏾,👨🏼‍❤️‍💋‍👨🏿,👨🏼‍🌾,👨🏼‍🍳,👨🏼‍🍼,👨🏼‍🎓,👨🏼‍🎤,👨🏼‍🎨,👨🏼‍🏫,👨🏼‍🏭,👨🏼‍💻,👨🏼‍💼,👨🏼‍🔧,👨🏼‍🔬,👨🏼‍🚀,👨🏼‍🚒,👨🏼‍🤝‍👨🏻,👨🏼‍🤝‍👨🏽,👨🏼‍🤝‍👨🏾,👨🏼‍🤝‍👨🏿,👨🏼‍🦯,👨🏼‍🦯‍➡️,👨🏼‍🦰,👨🏼‍🦱,👨🏼‍🦲,👨🏼‍🦳,👨🏼‍🦼,👨🏼‍🦼‍➡️,👨🏼‍🦽,👨🏼‍🦽‍➡️,👨🏽,👨🏽‍⚕️,👨🏽‍⚖️,👨🏽‍✈️,👨🏽‍❤️‍👨🏻,👨🏽‍❤️‍👨🏼,👨🏽‍❤️‍👨🏽,👨🏽‍❤️‍👨🏾,👨🏽‍❤️‍👨🏿,👨🏽‍❤️‍💋‍👨🏻,👨🏽‍❤️‍💋‍👨🏼,👨🏽‍❤️‍💋‍👨🏽,👨🏽‍❤️‍💋‍👨🏾,👨🏽‍❤️‍💋‍👨🏿,👨🏽‍🌾,👨🏽‍🍳,👨🏽‍🍼,👨🏽‍🎓,👨🏽‍🎤,👨🏽‍🎨,👨🏽‍🏫,👨🏽‍🏭,👨🏽‍💻,👨🏽‍💼,👨🏽‍🔧,👨🏽‍🔬,👨🏽‍🚀,👨🏽‍🚒,👨🏽‍🤝‍👨🏻,👨🏽‍🤝‍👨🏼,👨🏽‍🤝‍👨🏾,👨🏽‍🤝‍👨🏿,👨🏽‍🦯,👨🏽‍🦯‍➡️,👨🏽‍🦰,👨🏽‍🦱,👨🏽‍🦲,👨🏽‍🦳,👨🏽‍🦼,👨🏽‍🦼‍➡️,👨🏽‍🦽,👨🏽‍🦽‍➡️,👨🏾,👨🏾‍⚕️,👨🏾‍⚖️,👨🏾‍✈️,👨🏾‍❤️‍👨🏻,👨🏾‍❤️‍👨🏼,👨🏾‍❤️‍👨🏽,👨🏾‍❤️‍👨🏾,👨🏾‍❤️‍👨🏿,👨🏾‍❤️‍💋‍👨🏻,👨🏾‍❤️‍💋‍👨🏼,👨🏾‍❤️‍💋‍👨🏽,👨🏾‍❤️‍💋‍👨🏾,👨🏾‍❤️‍💋‍👨🏿,👨🏾‍🌾,👨🏾‍🍳,👨🏾‍🍼,👨🏾‍🎓,👨🏾‍🎤,👨🏾‍🎨,👨🏾‍🏫,👨🏾‍🏭,👨🏾‍💻,👨🏾‍💼,👨🏾‍🔧,👨🏾‍🔬,👨🏾‍🚀,👨🏾‍🚒,👨🏾‍🤝‍👨🏻,👨🏾‍🤝‍👨🏼,👨🏾‍🤝‍👨🏽,👨🏾‍🤝‍👨🏿,👨🏾‍🦯,👨🏾‍🦯‍➡️,👨🏾‍🦰,👨🏾‍🦱,👨🏾‍🦲,👨🏾‍🦳,👨🏾‍🦼,👨🏾‍🦼‍➡️,👨🏾‍🦽,👨🏾‍🦽‍➡️,👨🏿,👨🏿‍⚕️,👨🏿‍⚖️,👨🏿‍✈️,👨🏿‍❤️‍👨🏻,👨🏿‍❤️‍👨🏼,👨🏿‍❤️‍👨🏽,👨🏿‍❤️‍👨🏾,👨🏿‍❤️‍👨🏿,👨🏿‍❤️‍💋‍👨🏻,👨🏿‍❤️‍💋‍👨🏼,👨🏿‍❤️‍💋‍👨🏽,👨🏿‍❤️‍💋‍👨🏾,👨🏿‍❤️‍💋‍👨🏿,👨🏿‍🌾,👨🏿‍🍳,👨🏿‍🍼,👨🏿‍🎓,👨🏿‍🎤,👨🏿‍🎨,👨🏿‍🏫,👨🏿‍🏭,👨🏿‍💻,👨🏿‍💼,👨🏿‍🔧,👨🏿‍🔬,👨🏿‍🚀,👨🏿‍🚒,👨🏿‍🤝‍👨🏻,👨🏿‍🤝‍👨🏼,👨🏿‍🤝‍👨🏽,👨🏿‍🤝‍👨🏾,👨🏿‍🦯,👨🏿‍🦯‍➡️,👨🏿‍🦰,👨🏿‍🦱,👨🏿‍🦲,👨🏿‍🦳,👨🏿‍🦼,👨🏿‍🦼‍➡️,👨🏿‍🦽,👨🏿‍🦽‍➡️,👩,👩‍⚕️,👩‍⚖️,👩‍✈️,👩‍❤️‍👨,👩‍❤️‍👩,👩‍❤️‍💋‍👨,👩‍❤️‍💋‍👩,👩‍🌾,👩‍🍳,👩‍🍼,👩‍🎓,👩‍🎤,👩‍🎨,👩‍🏫,👩‍🏭,👩‍👦,👩‍👦‍👦,👩‍👧,👩‍👧‍👦,👩‍👧‍👧,👩‍👩‍👦,👩‍👩‍👦‍👦,👩‍👩‍👧,👩‍👩‍👧‍👦,👩‍👩‍👧‍👧,👩‍💻,👩‍💼,👩‍🔧,👩‍🔬,👩‍🚀,👩‍🚒,👩‍🦯,👩‍🦯‍➡️,👩‍🦰,👩‍🦱,👩‍🦲,👩‍🦳,👩‍🦼,👩‍🦼‍➡️,👩‍🦽,👩‍🦽‍➡️,👩🏻,👩🏻‍⚕️,👩🏻‍⚖️,👩🏻‍✈️,👩🏻‍❤️‍👨🏻,👩🏻‍❤️‍👨🏼,👩🏻‍❤️‍👨🏽,👩🏻‍❤️‍👨🏾,👩🏻‍❤️‍👨🏿,👩🏻‍❤️‍👩🏻,👩🏻‍❤️‍👩🏼,👩🏻‍❤️‍👩🏽,👩🏻‍❤️‍👩🏾,👩🏻‍❤️‍👩🏿,👩🏻‍❤️‍💋‍👨🏻,👩🏻‍❤️‍💋‍👨🏼,👩🏻‍❤️‍💋‍👨🏽,👩🏻‍❤️‍💋‍👨🏾,👩🏻‍❤️‍💋‍👨🏿,👩🏻‍❤️‍💋‍👩🏻,👩🏻‍❤️‍💋‍👩🏼,👩🏻‍❤️‍💋‍👩🏽,👩🏻‍❤️‍💋‍👩🏾,👩🏻‍❤️‍💋‍👩🏿,👩🏻‍🌾,👩🏻‍🍳,👩🏻‍🍼,👩🏻‍🎓,👩🏻‍🎤,👩🏻‍🎨,👩🏻‍🏫,👩🏻‍🏭,👩🏻‍💻,👩🏻‍💼,👩🏻‍🔧,👩🏻‍🔬,👩🏻‍🚀,👩🏻‍🚒,👩🏻‍🤝‍👨🏼,👩🏻‍🤝‍👨🏽,👩🏻‍🤝‍👨🏾,👩🏻‍🤝‍👨🏿,👩🏻‍🤝‍👩🏼,👩🏻‍🤝‍👩🏽,👩🏻‍🤝‍👩🏾,👩🏻‍🤝‍👩🏿,👩🏻‍🦯,👩🏻‍🦯‍➡️,👩🏻‍🦰,👩🏻‍🦱,👩🏻‍🦲,👩🏻‍🦳,👩🏻‍🦼,👩🏻‍🦼‍➡️,👩🏻‍🦽,👩🏻‍🦽‍➡️,👩🏼,👩🏼‍⚕️,👩🏼‍⚖️,👩🏼‍✈️,👩🏼‍❤️‍👨🏻,👩🏼‍❤️‍👨🏼,👩🏼‍❤️‍👨🏽,👩🏼‍❤️‍👨🏾,👩🏼‍❤️‍👨🏿,👩🏼‍❤️‍👩🏻,👩🏼‍❤️‍👩🏼,👩🏼‍❤️‍👩🏽,👩🏼‍❤️‍👩🏾,👩🏼‍❤️‍👩🏿,👩🏼‍❤️‍💋‍👨🏻,👩🏼‍❤️‍💋‍👨🏼,👩🏼‍❤️‍💋‍👨🏽,👩🏼‍❤️‍💋‍👨🏾,👩🏼‍❤️‍💋‍👨🏿,👩🏼‍❤️‍💋‍👩🏻,👩🏼‍❤️‍💋‍👩🏼,👩🏼‍❤️‍💋‍👩🏽,👩🏼‍❤️‍💋‍👩🏾,👩🏼‍❤️‍💋‍👩🏿,👩🏼‍🌾,👩🏼‍🍳,👩🏼‍🍼,👩🏼‍🎓,👩🏼‍🎤,👩🏼‍🎨,👩🏼‍🏫,👩🏼‍🏭,👩🏼‍💻,👩🏼‍💼,👩🏼‍🔧,👩🏼‍🔬,👩🏼‍🚀,👩🏼‍🚒,👩🏼‍🤝‍👨🏻,👩🏼‍🤝‍👨🏽,👩🏼‍🤝‍👨🏾,👩🏼‍🤝‍👨🏿,👩🏼‍🤝‍👩🏻,👩🏼‍🤝‍👩🏽,👩🏼‍🤝‍👩🏾,👩🏼‍🤝‍👩🏿,👩🏼‍🦯,👩🏼‍🦯‍➡️,👩🏼‍🦰,👩🏼‍🦱,👩🏼‍🦲,👩🏼‍🦳,👩🏼‍🦼,👩🏼‍🦼‍➡️,👩🏼‍🦽,👩🏼‍🦽‍➡️,👩🏽,👩🏽‍⚕️,👩🏽‍⚖️,👩🏽‍✈️,👩🏽‍❤️‍👨🏻,👩🏽‍❤️‍👨🏼,👩🏽‍❤️‍👨🏽,👩🏽‍❤️‍👨🏾,👩🏽‍❤️‍👨🏿,👩🏽‍❤️‍👩🏻,👩🏽‍❤️‍👩🏼,👩🏽‍❤️‍👩🏽,👩🏽‍❤️‍👩🏾,👩🏽‍❤️‍👩🏿,👩🏽‍❤️‍💋‍👨🏻,👩🏽‍❤️‍💋‍👨🏼,👩🏽‍❤️‍💋‍👨🏽,👩🏽‍❤️‍💋‍👨🏾,👩🏽‍❤️‍💋‍👨🏿,👩🏽‍❤️‍💋‍👩🏻,👩🏽‍❤️‍💋‍👩🏼,👩🏽‍❤️‍💋‍👩🏽,👩🏽‍❤️‍💋‍👩🏾,👩🏽‍❤️‍💋‍👩🏿,👩🏽‍🌾,👩🏽‍🍳,👩🏽‍🍼,👩🏽‍🎓,👩🏽‍🎤,👩🏽‍🎨,👩🏽‍🏫,👩🏽‍🏭,👩🏽‍💻,👩🏽‍💼,👩🏽‍🔧,👩🏽‍🔬,👩🏽‍🚀,👩🏽‍🚒,👩🏽‍🤝‍👨🏻,👩🏽‍🤝‍👨🏼,👩🏽‍🤝‍👨🏾,👩🏽‍🤝‍👨🏿,👩🏽‍🤝‍👩🏻,👩🏽‍🤝‍👩🏼,👩🏽‍🤝‍👩🏾,👩🏽‍🤝‍👩🏿,👩🏽‍🦯,👩🏽‍🦯‍➡️,👩🏽‍🦰,👩🏽‍🦱,👩🏽‍🦲,👩🏽‍🦳,👩🏽‍🦼,👩🏽‍🦼‍➡️,👩🏽‍🦽,👩🏽‍🦽‍➡️,👩🏾,👩🏾‍⚕️,👩🏾‍⚖️,👩🏾‍✈️,👩🏾‍❤️‍👨🏻,👩🏾‍❤️‍👨🏼,👩🏾‍❤️‍👨🏽,👩🏾‍❤️‍👨🏾,👩🏾‍❤️‍👨🏿,👩🏾‍❤️‍👩🏻,👩🏾‍❤️‍👩🏼,👩🏾‍❤️‍👩🏽,👩🏾‍❤️‍👩🏾,👩🏾‍❤️‍👩🏿,👩🏾‍❤️‍💋‍👨🏻,👩🏾‍❤️‍💋‍👨🏼,👩🏾‍❤️‍💋‍👨🏽,👩🏾‍❤️‍💋‍👨🏾,👩🏾‍❤️‍💋‍👨🏿,👩🏾‍❤️‍💋‍👩🏻,👩🏾‍❤️‍💋‍👩🏼,👩🏾‍❤️‍💋‍👩🏽,👩🏾‍❤️‍💋‍👩🏾,👩🏾‍❤️‍💋‍👩🏿,👩🏾‍🌾,👩🏾‍🍳,👩🏾‍🍼,👩🏾‍🎓,👩🏾‍🎤,👩🏾‍🎨,👩🏾‍🏫,👩🏾‍🏭,👩🏾‍💻,👩🏾‍💼,👩🏾‍🔧,👩🏾‍🔬,👩🏾‍🚀,👩🏾‍🚒,👩🏾‍🤝‍👨🏻,👩🏾‍🤝‍👨🏼,👩🏾‍🤝‍👨🏽,👩🏾‍🤝‍👨🏿,👩🏾‍🤝‍👩🏻,👩🏾‍🤝‍👩🏼,👩🏾‍🤝‍👩🏽,👩🏾‍🤝‍👩🏿,👩🏾‍🦯,👩🏾‍🦯‍➡️,👩🏾‍🦰,👩🏾‍🦱,👩🏾‍🦲,👩🏾‍🦳,👩🏾‍🦼,👩🏾‍🦼‍➡️,👩🏾‍🦽,👩🏾‍🦽‍➡️,👩🏿,👩🏿‍⚕️,👩🏿‍⚖️,👩🏿‍✈️,👩🏿‍❤️‍👨🏻,👩🏿‍❤️‍👨🏼,👩🏿‍❤️‍👨🏽,👩🏿‍❤️‍👨🏾,👩🏿‍❤️‍👨🏿,👩🏿‍❤️‍👩🏻,👩🏿‍❤️‍👩🏼,👩🏿‍❤️‍👩🏽,👩🏿‍❤️‍👩🏾,👩🏿‍❤️‍👩🏿,👩🏿‍❤️‍💋‍👨🏻,👩🏿‍❤️‍💋‍👨🏼,👩🏿‍❤️‍💋‍👨🏽,👩🏿‍❤️‍💋‍👨🏾,👩🏿‍❤️‍💋‍👨🏿,👩🏿‍❤️‍💋‍👩🏻,👩🏿‍❤️‍💋‍👩🏼,👩🏿‍❤️‍💋‍👩🏽,👩🏿‍❤️‍💋‍👩🏾,👩🏿‍❤️‍💋‍👩🏿,👩🏿‍🌾,👩🏿‍🍳,👩🏿‍🍼,👩🏿‍🎓,👩🏿‍🎤,👩🏿‍🎨,👩🏿‍🏫,👩🏿‍🏭,👩🏿‍💻,👩🏿‍💼,👩🏿‍🔧,👩🏿‍🔬,👩🏿‍🚀,👩🏿‍🚒,👩🏿‍🤝‍👨🏻,👩🏿‍🤝‍👨🏼,👩🏿‍🤝‍👨🏽,👩🏿‍🤝‍👨🏾,👩🏿‍🤝‍👩🏻,👩🏿‍🤝‍👩🏼,👩🏿‍🤝‍👩🏽,👩🏿‍🤝‍👩🏾,👩🏿‍🦯,👩🏿‍🦯‍➡️,👩🏿‍🦰,👩🏿‍🦱,👩🏿‍🦲,👩🏿‍🦳,👩🏿‍🦼,👩🏿‍🦼‍➡️,👩🏿‍🦽,👩🏿‍🦽‍➡️,👪,👫,👫🏻,👫🏼,👫🏽,👫🏾,👫🏿,👬,👬🏻,👬🏼,👬🏽,👬🏾,👬🏿,👭,👭🏻,👭🏼,👭🏽,👭🏾,👭🏿,👮,👮‍♀️,👮‍♂️,👮🏻,👮🏻‍♀️,👮🏻‍♂️,👮🏼,👮🏼‍♀️,👮🏼‍♂️,👮🏽,👮🏽‍♀️,👮🏽‍♂️,👮🏾,👮🏾‍♀️,👮🏾‍♂️,👮🏿,👮🏿‍♀️,👮🏿‍♂️,👯,👯‍♀️,👯‍♂️,👰,👰‍♀️,👰‍♂️,👰🏻,👰🏻‍♀️,👰🏻‍♂️,👰🏼,👰🏼‍♀️,👰🏼‍♂️,👰🏽,👰🏽‍♀️,👰🏽‍♂️,👰🏾,👰🏾‍♀️,👰🏾‍♂️,👰🏿,👰🏿‍♀️,👰🏿‍♂️,👱,👱‍♀️,👱‍♂️,👱🏻,👱🏻‍♀️,👱🏻‍♂️,👱🏼,👱🏼‍♀️,👱🏼‍♂️,👱🏽,👱🏽‍♀️,👱🏽‍♂️,👱🏾,👱🏾‍♀️,👱🏾‍♂️,👱🏿,👱🏿‍♀️,👱🏿‍♂️,👲,👲🏻,👲🏼,👲🏽,👲🏾,👲🏿,👳,👳‍♀️,👳‍♂️,👳🏻,👳🏻‍♀️,👳🏻‍♂️,👳🏼,👳🏼‍♀️,👳🏼‍♂️,👳🏽,👳🏽‍♀️,👳🏽‍♂️,👳🏾,👳🏾‍♀️,👳🏾‍♂️,👳🏿,👳🏿‍♀️,👳🏿‍♂️,👴,👴🏻,👴🏼,👴🏽,👴🏾,👴🏿,👵,👵🏻,👵🏼,👵🏽,👵🏾,👵🏿,👶,👶🏻,👶🏼,👶🏽,👶🏾,👶🏿,👷,👷‍♀️,👷‍♂️,👷🏻,👷🏻‍♀️,👷🏻‍♂️,👷🏼,👷🏼‍♀️,👷🏼‍♂️,👷🏽,👷🏽‍♀️,👷🏽‍♂️,👷🏾,👷🏾‍♀️,👷🏾‍♂️,👷🏿,👷🏿‍♀️,👷🏿‍♂️,👸,👸🏻,👸🏼,👸🏽,👸🏾,👸🏿,👹,👺,👻,👼,👼🏻,👼🏼,👼🏽,👼🏾,👼🏿,👽,👾,👿,💀,💁,💁‍♀️,💁‍♂️,💁🏻,💁🏻‍♀️,💁🏻‍♂️,💁🏼,💁🏼‍♀️,💁🏼‍♂️,💁🏽,💁🏽‍♀️,💁🏽‍♂️,💁🏾,💁🏾‍♀️,💁🏾‍♂️,💁🏿,💁🏿‍♀️,💁🏿‍♂️,💂,💂‍♀️,💂‍♂️,💂🏻,💂🏻‍♀️,💂🏻‍♂️,💂🏼,💂🏼‍♀️,💂🏼‍♂️,💂🏽,💂🏽‍♀️,💂🏽‍♂️,💂🏾,💂🏾‍♀️,💂🏾‍♂️,💂🏿,💂🏿‍♀️,💂🏿‍♂️,💃,💃🏻,💃🏼,💃🏽,💃🏾,💃🏿,💄,💅,💅🏻,💅🏼,💅🏽,💅🏾,💅🏿,💆,💆‍♀️,💆‍♂️,💆🏻,💆🏻‍♀️,💆🏻‍♂️,💆🏼,💆🏼‍♀️,💆🏼‍♂️,💆🏽,💆🏽‍♀️,💆🏽‍♂️,💆🏾,💆🏾‍♀️,💆🏾‍♂️,💆🏿,💆🏿‍♀️,💆🏿‍♂️,💇,💇‍♀️,💇‍♂️,💇🏻,💇🏻‍♀️,💇🏻‍♂️,💇🏼,💇🏼‍♀️,💇🏼‍♂️,💇🏽,💇🏽‍♀️,💇🏽‍♂️,💇🏾,💇🏾‍♀️,💇🏾‍♂️,💇🏿,💇🏿‍♀️,💇🏿‍♂️,💈,💉,💊,💋,💌,💍,💎,💏,💏🏻,💏🏼,💏🏽,💏🏾,💏🏿,💐,💑,💑🏻,💑🏼,💑🏽,💑🏾,💑🏿,💒,💓,💔,💕,💖,💗,💘,💙,💚,💛,💜,💝,💞,💟,💠,💡,💢,💣,💤,💥,💦,💧,💨,💩,💪,💪🏻,💪🏼,💪🏽,💪🏾,💪🏿,💫,💬,💭,💮,💯,💰,💱,💲,💳,💴,💵,💶,💷,💸,💹,💺,💻,💼,💽,💾,💿,📀,📁,📂,📃,📄,📅,📆,📇,📈,📉,📊,📋,📌,📍,📎,📏,📐,📑,📒,📓,📔,📕,📖,📗,📘,📙,📚,📛,📜,📝,📞,📟,📠,📡,📢,📣,📤,📥,📦,📧,📨,📩,📪,📫,📬,📭,📮,📯,📰,📱,📲,📳,📴,📵,📶,📷,📸,📹,📺,📻,📼,📽️,📿,🔀,🔁,🔂,🔃,🔄,🔅,🔆,🔇,🔈,🔉,🔊,🔋,🔌,🔍,🔎,🔏,🔐,🔑,🔒,🔓,🔔,🔕,🔖,🔗,🔘,🔙,🔚,🔛,🔜,🔝,🔞,🔟,🔠,🔡,🔢,🔣,🔤,🔥,🔦,🔧,🔨,🔩,🔪,🔫,🔬,🔭,🔮,🔯,🔰,🔱,🔲,🔳,🔴,🔵,🔶,🔷,🔸,🔹,🔺,🔻,🔼,🔽,🕉️,🕊️,🕋,🕌,🕍,🕎,🕐,🕑,🕒,🕓,🕔,🕕,🕖,🕗,🕘,🕙,🕚,🕛,🕜,🕝,🕞,🕟,🕠,🕡,🕢,🕣,🕤,🕥,🕦,🕧,🕯️,🕰️,🕳️,🕴🏻,🕴🏼,🕴🏽,🕴🏾,🕴🏿,🕴️,🕵🏻,🕵🏻‍♀️,🕵🏻‍♂️,🕵🏼,🕵🏼‍♀️,🕵🏼‍♂️,🕵🏽,🕵🏽‍♀️,🕵🏽‍♂️,🕵🏾,🕵🏾‍♀️,🕵🏾‍♂️,🕵🏿,🕵🏿‍♀️,🕵🏿‍♂️,🕵️,🕵️‍♀️,🕵️‍♂️,🕶️,🕷️,🕸️,🕹️,🕺,🕺🏻,🕺🏼,🕺🏽,🕺🏾,🕺🏿,🖇️,🖊️,🖋️,🖌️,🖍️,🖐🏻,🖐🏼,🖐🏽,🖐🏾,🖐🏿,🖐️,🖕,🖕🏻,🖕🏼,🖕🏽,🖕🏾,🖕🏿,🖖,🖖🏻,🖖🏼,🖖🏽,🖖🏾,🖖🏿,🖤,🖥️,🖨️,🖱️,🖲️,🖼️,🗂️,🗃️,🗄️,🗑️,🗒️,🗓️,🗜️,🗝️,🗞️,🗡️,🗣️,🗨️,🗯️,🗳️,🗺️,🗻,🗼,🗽,🗾,🗿,😀,😁,😂,😃,😄,😅,😆,😇,😈,😉,😊,😋,😌,😍,😎,😏,😐,😑,😒,😓,😔,😕,😖,😗,😘,😙,😚,😛,😜,😝,😞,😟,😠,😡,😢,😣,😤,😥,😦,😧,😨,😩,😪,😫,😬,😭,😮,😮‍💨,😯,😰,😱,😲,😳,😴,😵,😵‍💫,😶,😶‍🌫️,😷,😸,😹,😺,😻,😼,😽,😾,😿,🙀,🙁,🙂,🙂‍↔️,🙂‍↕️,🙃,🙄,🙅,🙅‍♀️,🙅‍♂️,🙅🏻,🙅🏻‍♀️,🙅🏻‍♂️,🙅🏼,🙅🏼‍♀️,🙅🏼‍♂️,🙅🏽,🙅🏽‍♀️,🙅🏽‍♂️,🙅🏾,🙅🏾‍♀️,🙅🏾‍♂️,🙅🏿,🙅🏿‍♀️,🙅🏿‍♂️,🙆,🙆‍♀️,🙆‍♂️,🙆🏻,🙆🏻‍♀️,🙆🏻‍♂️,🙆🏼,🙆🏼‍♀️,🙆🏼‍♂️,🙆🏽,🙆🏽‍♀️,🙆🏽‍♂️,🙆🏾,🙆🏾‍♀️,🙆🏾‍♂️,🙆🏿,🙆🏿‍♀️,🙆🏿‍♂️,🙇,🙇‍♀️,🙇‍♂️,🙇🏻,🙇🏻‍♀️,🙇🏻‍♂️,🙇🏼,🙇🏼‍♀️,🙇🏼‍♂️,🙇🏽,🙇🏽‍♀️,🙇🏽‍♂️,🙇🏾,🙇🏾‍♀️,🙇🏾‍♂️,🙇🏿,🙇🏿‍♀️,🙇🏿‍♂️,🙈,🙉,🙊,🙋,🙋‍♀️,🙋‍♂️,🙋🏻,🙋🏻‍♀️,🙋🏻‍♂️,🙋🏼,🙋🏼‍♀️,🙋🏼‍♂️,🙋🏽,🙋🏽‍♀️,🙋🏽‍♂️,🙋🏾,🙋🏾‍♀️,🙋🏾‍♂️,🙋🏿,🙋🏿‍♀️,🙋🏿‍♂️,🙌,🙌🏻,🙌🏼,🙌🏽,🙌🏾,🙌🏿,🙍,🙍‍♀️,🙍‍♂️,🙍🏻,🙍🏻‍♀️,🙍🏻‍♂️,🙍🏼,🙍🏼‍♀️,🙍🏼‍♂️,🙍🏽,🙍🏽‍♀️,🙍🏽‍♂️,🙍🏾,🙍🏾‍♀️,🙍🏾‍♂️,🙍🏿,🙍🏿‍♀️,🙍🏿‍♂️,🙎,🙎‍♀️,🙎‍♂️,🙎🏻,🙎🏻‍♀️,🙎🏻‍♂️,🙎🏼,🙎🏼‍♀️,🙎🏼‍♂️,🙎🏽,🙎🏽‍♀️,🙎🏽‍♂️,🙎🏾,🙎🏾‍♀️,🙎🏾‍♂️,🙎🏿,🙎🏿‍♀️,🙎🏿‍♂️,🙏,🙏🏻,🙏🏼,🙏🏽,🙏🏾,🙏🏿,🚀,🚁,🚂,🚃,🚄,🚅,🚆,🚇,🚈,🚉,🚊,🚋,🚌,🚍,🚎,🚏,🚐,🚑,🚒,🚓,🚔,🚕,🚖,🚗,🚘,🚙,🚚,🚛,🚜,🚝,🚞,🚟,🚠,🚡,🚢,🚣,🚣‍♀️,🚣‍♂️,🚣🏻,🚣🏻‍♀️,🚣🏻‍♂️,🚣🏼,🚣🏼‍♀️,🚣🏼‍♂️,🚣🏽,🚣🏽‍♀️,🚣🏽‍♂️,🚣🏾,🚣🏾‍♀️,🚣🏾‍♂️,🚣🏿,🚣🏿‍♀️,🚣🏿‍♂️,🚤,🚥,🚦,🚧,🚨,🚩,🚪,🚫,🚬,🚭,🚮,🚯,🚰,🚱,🚲,🚳,🚴,🚴‍♀️,🚴‍♂️,🚴🏻,🚴🏻‍♀️,🚴🏻‍♂️,🚴🏼,🚴🏼‍♀️,🚴🏼‍♂️,🚴🏽,🚴🏽‍♀️,🚴🏽‍♂️,🚴🏾,🚴🏾‍♀️,🚴🏾‍♂️,🚴🏿,🚴🏿‍♀️,🚴🏿‍♂️,🚵,🚵‍♀️,🚵‍♂️,🚵🏻,🚵🏻‍♀️,🚵🏻‍♂️,🚵🏼,🚵🏼‍♀️,🚵🏼‍♂️,🚵🏽,🚵🏽‍♀️,🚵🏽‍♂️,🚵🏾,🚵🏾‍♀️,🚵🏾‍♂️,🚵🏿,🚵🏿‍♀️,🚵🏿‍♂️,🚶,🚶‍♀️,🚶‍♀️‍➡️,🚶‍♂️,🚶‍♂️‍➡️,🚶‍➡️,🚶🏻,🚶🏻‍♀️,🚶🏻‍♀️‍➡️,🚶🏻‍♂️,🚶🏻‍♂️‍➡️,🚶🏻‍➡️,🚶🏼,🚶🏼‍♀️,🚶🏼‍♀️‍➡️,🚶🏼‍♂️,🚶🏼‍♂️‍➡️,🚶🏼‍➡️,🚶🏽,🚶🏽‍♀️,🚶🏽‍♀️‍➡️,🚶🏽‍♂️,🚶🏽‍♂️‍➡️,🚶🏽‍➡️,🚶🏾,🚶🏾‍♀️,🚶🏾‍♀️‍➡️,🚶🏾‍♂️,🚶🏾‍♂️‍➡️,🚶🏾‍➡️,🚶🏿,🚶🏿‍♀️,🚶🏿‍♀️‍➡️,🚶🏿‍♂️,🚶🏿‍♂️‍➡️,🚶🏿‍➡️,🚷,🚸,🚹,🚺,🚻,🚼,🚽,🚾,🚿,🛀,🛀🏻,🛀🏼,🛀🏽,🛀🏾,🛀🏿,🛁,🛂,🛃,🛄,🛅,🛋️,🛌,🛌🏻,🛌🏼,🛌🏽,🛌🏾,🛌🏿,🛍️,🛎️,🛏️,🛐,🛑,🛒,🛕,🛖,🛗,🛜,🛝,🛞,🛟,🛠️,🛡️,🛢️,🛣️,🛤️,🛥️,🛩️,🛫,🛬,🛰️,🛳️,🛴,🛵,🛶,🛷,🛸,🛹,🛺,🛻,🛼,🟠,🟡,🟢,🟣,🟤,🟥,🟦,🟧,🟨,🟩,🟪,🟫,🟰,🤌,🤌🏻,🤌🏼,🤌🏽,🤌🏾,🤌🏿,🤍,🤎,🤏,🤏🏻,🤏🏼,🤏🏽,🤏🏾,🤏🏿,🤐,🤑,🤒,🤓,🤔,🤕,🤖,🤗,🤘,🤘🏻,🤘🏼,🤘🏽,🤘🏾,🤘🏿,🤙,🤙🏻,🤙🏼,🤙🏽,🤙🏾,🤙🏿,🤚,🤚🏻,🤚🏼,🤚🏽,🤚🏾,🤚🏿,🤛,🤛🏻,🤛🏼,🤛🏽,🤛🏾,🤛🏿,🤜,🤜🏻,🤜🏼,🤜🏽,🤜🏾,🤜🏿,🤝,🤝🏻,🤝🏼,🤝🏽,🤝🏾,🤝🏿,🤞,🤞🏻,🤞🏼,🤞🏽,🤞🏾,🤞🏿,🤟,🤟🏻,🤟🏼,🤟🏽,🤟🏾,🤟🏿,🤠,🤡,🤢,🤣,🤤,🤥,🤦,🤦‍♀️,🤦‍♂️,🤦🏻,🤦🏻‍♀️,🤦🏻‍♂️,🤦🏼,🤦🏼‍♀️,🤦🏼‍♂️,🤦🏽,🤦🏽‍♀️,🤦🏽‍♂️,🤦🏾,🤦🏾‍♀️,🤦🏾‍♂️,🤦🏿,🤦🏿‍♀️,🤦🏿‍♂️,🤧,🤨,🤩,🤪,🤫,🤬,🤭,🤮,🤯,🤰,🤰🏻,🤰🏼,🤰🏽,🤰🏾,🤰🏿,🤱,🤱🏻,🤱🏼,🤱🏽,🤱🏾,🤱🏿,🤲,🤲🏻,🤲🏼,🤲🏽,🤲🏾,🤲🏿,🤳,🤳🏻,🤳🏼,🤳🏽,🤳🏾,🤳🏿,🤴,🤴🏻,🤴🏼,🤴🏽,🤴🏾,🤴🏿,🤵,🤵‍♀️,🤵‍♂️,🤵🏻,🤵🏻‍♀️,🤵🏻‍♂️,🤵🏼,🤵🏼‍♀️,🤵🏼‍♂️,🤵🏽,🤵🏽‍♀️,🤵🏽‍♂️,🤵🏾,🤵🏾‍♀️,🤵🏾‍♂️,🤵🏿,🤵🏿‍♀️,🤵🏿‍♂️,🤶,🤶🏻,🤶🏼,🤶🏽,🤶🏾,🤶🏿,🤷,🤷‍♀️,🤷‍♂️,🤷🏻,🤷🏻‍♀️,🤷🏻‍♂️,🤷🏼,🤷🏼‍♀️,🤷🏼‍♂️,🤷🏽,🤷🏽‍♀️,🤷🏽‍♂️,🤷🏾,🤷🏾‍♀️,🤷🏾‍♂️,🤷🏿,🤷🏿‍♀️,🤷🏿‍♂️,🤸,🤸‍♀️,🤸‍♂️,🤸🏻,🤸🏻‍♀️,🤸🏻‍♂️,🤸🏼,🤸🏼‍♀️,🤸🏼‍♂️,🤸🏽,🤸🏽‍♀️,🤸🏽‍♂️,🤸🏾,🤸🏾‍♀️,🤸🏾‍♂️,🤸🏿,🤸🏿‍♀️,🤸🏿‍♂️,🤹,🤹‍♀️,🤹‍♂️,🤹🏻,🤹🏻‍♀️,🤹🏻‍♂️,🤹🏼,🤹🏼‍♀️,🤹🏼‍♂️,🤹🏽,🤹🏽‍♀️,🤹🏽‍♂️,🤹🏾,🤹🏾‍♀️,🤹🏾‍♂️,🤹🏿,🤹🏿‍♀️,🤹🏿‍♂️,🤺,🤼,🤼‍♀️,🤼‍♂️,🤽,🤽‍♀️,🤽‍♂️,🤽🏻,🤽🏻‍♀️,🤽🏻‍♂️,🤽🏼,🤽🏼‍♀️,🤽🏼‍♂️,🤽🏽,🤽🏽‍♀️,🤽🏽‍♂️,🤽🏾,🤽🏾‍♀️,🤽🏾‍♂️,🤽🏿,🤽🏿‍♀️,🤽🏿‍♂️,🤾,🤾‍♀️,🤾‍♂️,🤾🏻,🤾🏻‍♀️,🤾🏻‍♂️,🤾🏼,🤾🏼‍♀️,🤾🏼‍♂️,🤾🏽,🤾🏽‍♀️,🤾🏽‍♂️,🤾🏾,🤾🏾‍♀️,🤾🏾‍♂️,🤾🏿,🤾🏿‍♀️,🤾🏿‍♂️,🤿,🥀,🥁,🥂,🥃,🥄,🥅,🥇,🥈,🥉,🥊,🥋,🥌,🥍,🥎,🥏,🥐,🥑,🥒,🥓,🥔,🥕,🥖,🥗,🥘,🥙,🥚,🥛,🥜,🥝,🥞,🥟,🥠,🥡,🥢,🥣,🥤,🥥,🥦,🥧,🥨,🥩,🥪,🥫,🥬,🥭,🥮,🥯,🥰,🥱,🥲,🥳,🥴,🥵,🥶,🥷,🥷🏻,🥷🏼,🥷🏽,🥷🏾,🥷🏿,🥸,🥹,🥺,🥻,🥼,🥽,🥾,🥿,🦀,🦁,🦂,🦃,🦄,🦅,🦆,🦇,🦈,🦉,🦊,🦋,🦌,🦍,🦎,🦏,🦐,🦑,🦒,🦓,🦔,🦕,🦖,🦗,🦘,🦙,🦚,🦛,🦜,🦝,🦞,🦟,🦠,🦡,🦢,🦣,🦤,🦥,🦦,🦧,🦨,🦩,🦪,🦫,🦬,🦭,🦮,🦯,🦰,🦱,🦲,🦳,🦴,🦵,🦵🏻,🦵🏼,🦵🏽,🦵🏾,🦵🏿,🦶,🦶🏻,🦶🏼,🦶🏽,🦶🏾,🦶🏿,🦷,🦸,🦸‍♀️,🦸‍♂️,🦸🏻,🦸🏻‍♀️,🦸🏻‍♂️,🦸🏼,🦸🏼‍♀️,🦸🏼‍♂️,🦸🏽,🦸🏽‍♀️,🦸🏽‍♂️,🦸🏾,🦸🏾‍♀️,🦸🏾‍♂️,🦸🏿,🦸🏿‍♀️,🦸🏿‍♂️,🦹,🦹‍♀️,🦹‍♂️,🦹🏻,🦹🏻‍♀️,🦹🏻‍♂️,🦹🏼,🦹🏼‍♀️,🦹🏼‍♂️,🦹🏽,🦹🏽‍♀️,🦹🏽‍♂️,🦹🏾,🦹🏾‍♀️,🦹🏾‍♂️,🦹🏿,🦹🏿‍♀️,🦹🏿‍♂️,🦺,🦻,🦻🏻,🦻🏼,🦻🏽,🦻🏾,🦻🏿,🦼,🦽,🦾,🦿,🧀,🧁,🧂,🧃,🧄,🧅,🧆,🧇,🧈,🧉,🧊,🧋,🧌,🧍,🧍‍♀️,🧍‍♂️,🧍🏻,🧍🏻‍♀️,🧍🏻‍♂️,🧍🏼,🧍🏼‍♀️,🧍🏼‍♂️,🧍🏽,🧍🏽‍♀️,🧍🏽‍♂️,🧍🏾,🧍🏾‍♀️,🧍🏾‍♂️,🧍🏿,🧍🏿‍♀️,🧍🏿‍♂️,🧎,🧎‍♀️,🧎‍♀️‍➡️,🧎‍♂️,🧎‍♂️‍➡️,🧎‍➡️,🧎🏻,🧎🏻‍♀️,🧎🏻‍♀️‍➡️,🧎🏻‍♂️,🧎🏻‍♂️‍➡️,🧎🏻‍➡️,🧎🏼,🧎🏼‍♀️,🧎🏼‍♀️‍➡️,🧎🏼‍♂️,🧎🏼‍♂️‍➡️,🧎🏼‍➡️,🧎🏽,🧎🏽‍♀️,🧎🏽‍♀️‍➡️,🧎🏽‍♂️,🧎🏽‍♂️‍➡️,🧎🏽‍➡️,🧎🏾,🧎🏾‍♀️,🧎🏾‍♀️‍➡️,🧎🏾‍♂️,🧎🏾‍♂️‍➡️,🧎🏾‍➡️,🧎🏿,🧎🏿‍♀️,🧎🏿‍♀️‍➡️,🧎🏿‍♂️,🧎🏿‍♂️‍➡️,🧎🏿‍➡️,🧏,🧏‍♀️,🧏‍♂️,🧏🏻,🧏🏻‍♀️,🧏🏻‍♂️,🧏🏼,🧏🏼‍♀️,🧏🏼‍♂️,🧏🏽,🧏🏽‍♀️,🧏🏽‍♂️,🧏🏾,🧏🏾‍♀️,🧏🏾‍♂️,🧏🏿,🧏🏿‍♀️,🧏🏿‍♂️,🧐,🧑,🧑‍⚕️,🧑‍⚖️,🧑‍✈️,🧑‍🌾,🧑‍🍳,🧑‍🍼,🧑‍🎄,🧑‍🎓,🧑‍🎤,🧑‍🎨,🧑‍🏫,🧑‍🏭,🧑‍💻,🧑‍💼,🧑‍🔧,🧑‍🔬,🧑‍🚀,🧑‍🚒,🧑‍🤝‍🧑,🧑‍🦯,🧑‍🦯‍➡️,🧑‍🦰,🧑‍🦱,🧑‍🦲,🧑‍🦳,🧑‍🦼,🧑‍🦼‍➡️,🧑‍🦽,🧑‍🦽‍➡️,🧑‍🧑‍🧒,🧑‍🧑‍🧒‍🧒,🧑‍🧒,🧑‍🧒‍🧒,🧑🏻,🧑🏻‍⚕️,🧑🏻‍⚖️,🧑🏻‍✈️,🧑🏻‍❤️‍💋‍🧑🏼,🧑🏻‍❤️‍💋‍🧑🏽,🧑🏻‍❤️‍💋‍🧑🏾,🧑🏻‍❤️‍💋‍🧑🏿,🧑🏻‍❤️‍🧑🏼,🧑🏻‍❤️‍🧑🏽,🧑🏻‍❤️‍🧑🏾,🧑🏻‍❤️‍🧑🏿,🧑🏻‍🌾,🧑🏻‍🍳,🧑🏻‍🍼,🧑🏻‍🎄,🧑🏻‍🎓,🧑🏻‍🎤,🧑🏻‍🎨,🧑🏻‍🏫,🧑🏻‍🏭,🧑🏻‍💻,🧑🏻‍💼,🧑🏻‍🔧,🧑🏻‍🔬,🧑🏻‍🚀,🧑🏻‍🚒,🧑🏻‍🤝‍🧑🏻,🧑🏻‍🤝‍🧑🏼,🧑🏻‍🤝‍🧑🏽,🧑🏻‍🤝‍🧑🏾,🧑🏻‍🤝‍🧑🏿,🧑🏻‍🦯,🧑🏻‍🦯‍➡️,🧑🏻‍🦰,🧑🏻‍🦱,🧑🏻‍🦲,🧑🏻‍🦳,🧑🏻‍🦼,🧑🏻‍🦼‍➡️,🧑🏻‍🦽,🧑🏻‍🦽‍➡️,🧑🏼,🧑🏼‍⚕️,🧑🏼‍⚖️,🧑🏼‍✈️,🧑🏼‍❤️‍💋‍🧑🏻,🧑🏼‍❤️‍💋‍🧑🏽,🧑🏼‍❤️‍💋‍🧑🏾,🧑🏼‍❤️‍💋‍🧑🏿,🧑🏼‍❤️‍🧑🏻,🧑🏼‍❤️‍🧑🏽,🧑🏼‍❤️‍🧑🏾,🧑🏼‍❤️‍🧑🏿,🧑🏼‍🌾,🧑🏼‍🍳,🧑🏼‍🍼,🧑🏼‍🎄,🧑🏼‍🎓,🧑🏼‍🎤,🧑🏼‍🎨,🧑🏼‍🏫,🧑🏼‍🏭,🧑🏼‍💻,🧑🏼‍💼,🧑🏼‍🔧,🧑🏼‍🔬,🧑🏼‍🚀,🧑🏼‍🚒,🧑🏼‍🤝‍🧑🏻,🧑🏼‍🤝‍🧑🏼,🧑🏼‍🤝‍🧑🏽,🧑🏼‍🤝‍🧑🏾,🧑🏼‍🤝‍🧑🏿,🧑🏼‍🦯,🧑🏼‍🦯‍➡️,🧑🏼‍🦰,🧑🏼‍🦱,🧑🏼‍🦲,🧑🏼‍🦳,🧑🏼‍🦼,🧑🏼‍🦼‍➡️,🧑🏼‍🦽,🧑🏼‍🦽‍➡️,🧑🏽,🧑🏽‍⚕️,🧑🏽‍⚖️,🧑🏽‍✈️,🧑🏽‍❤️‍💋‍🧑🏻,🧑🏽‍❤️‍💋‍🧑🏼,🧑🏽‍❤️‍💋‍🧑🏾,🧑🏽‍❤️‍💋‍🧑🏿,🧑🏽‍❤️‍🧑🏻,🧑🏽‍❤️‍🧑🏼,🧑🏽‍❤️‍🧑🏾,🧑🏽‍❤️‍🧑🏿,🧑🏽‍🌾,🧑🏽‍🍳,🧑🏽‍🍼,🧑🏽‍🎄,🧑🏽‍🎓,🧑🏽‍🎤,🧑🏽‍🎨,🧑🏽‍🏫,🧑🏽‍🏭,🧑🏽‍💻,🧑🏽‍💼,🧑🏽‍🔧,🧑🏽‍🔬,🧑🏽‍🚀,🧑🏽‍🚒,🧑🏽‍🤝‍🧑🏻,🧑🏽‍🤝‍🧑🏼,🧑🏽‍🤝‍🧑🏽,🧑🏽‍🤝‍🧑🏾,🧑🏽‍🤝‍🧑🏿,🧑🏽‍🦯,🧑🏽‍🦯‍➡️,🧑🏽‍🦰,🧑🏽‍🦱,🧑🏽‍🦲,🧑🏽‍🦳,🧑🏽‍🦼,🧑🏽‍🦼‍➡️,🧑🏽‍🦽,🧑🏽‍🦽‍➡️,🧑🏾,🧑🏾‍⚕️,🧑🏾‍⚖️,🧑🏾‍✈️,🧑🏾‍❤️‍💋‍🧑🏻,🧑🏾‍❤️‍💋‍🧑🏼,🧑🏾‍❤️‍💋‍🧑🏽,🧑🏾‍❤️‍💋‍🧑🏿,🧑🏾‍❤️‍🧑🏻,🧑🏾‍❤️‍🧑🏼,🧑🏾‍❤️‍🧑🏽,🧑🏾‍❤️‍🧑🏿,🧑🏾‍🌾,🧑🏾‍🍳,🧑🏾‍🍼,🧑🏾‍🎄,🧑🏾‍🎓,🧑🏾‍🎤,🧑🏾‍🎨,🧑🏾‍🏫,🧑🏾‍🏭,🧑🏾‍💻,🧑🏾‍💼,🧑🏾‍🔧,🧑🏾‍🔬,🧑🏾‍🚀,🧑🏾‍🚒,🧑🏾‍🤝‍🧑🏻,🧑🏾‍🤝‍🧑🏼,🧑🏾‍🤝‍🧑🏽,🧑🏾‍🤝‍🧑🏾,🧑🏾‍🤝‍🧑🏿,🧑🏾‍🦯,🧑🏾‍🦯‍➡️,🧑🏾‍🦰,🧑🏾‍🦱,🧑🏾‍🦲,🧑🏾‍🦳,🧑🏾‍🦼,🧑🏾‍🦼‍➡️,🧑🏾‍🦽,🧑🏾‍🦽‍➡️,🧑🏿,🧑🏿‍⚕️,🧑🏿‍⚖️,🧑🏿‍✈️,🧑🏿‍❤️‍💋‍🧑🏻,🧑🏿‍❤️‍💋‍🧑🏼,🧑🏿‍❤️‍💋‍🧑🏽,🧑🏿‍❤️‍💋‍🧑🏾,🧑🏿‍❤️‍🧑🏻,🧑🏿‍❤️‍🧑🏼,🧑🏿‍❤️‍🧑🏽,🧑🏿‍❤️‍🧑🏾,🧑🏿‍🌾,🧑🏿‍🍳,🧑🏿‍🍼,🧑🏿‍🎄,🧑🏿‍🎓,🧑🏿‍🎤,🧑🏿‍🎨,🧑🏿‍🏫,🧑🏿‍🏭,🧑🏿‍💻,🧑🏿‍💼,🧑🏿‍🔧,🧑🏿‍🔬,🧑🏿‍🚀,🧑🏿‍🚒,🧑🏿‍🤝‍🧑🏻,🧑🏿‍🤝‍🧑🏼,🧑🏿‍🤝‍🧑🏽,🧑🏿‍🤝‍🧑🏾,🧑🏿‍🤝‍🧑🏿,🧑🏿‍🦯,🧑🏿‍🦯‍➡️,🧑🏿‍🦰,🧑🏿‍🦱,🧑🏿‍🦲,🧑🏿‍🦳,🧑🏿‍🦼,🧑🏿‍🦼‍➡️,🧑🏿‍🦽,🧑🏿‍🦽‍➡️,🧒,🧒🏻,🧒🏼,🧒🏽,🧒🏾,🧒🏿,🧓,🧓🏻,🧓🏼,🧓🏽,🧓🏾,🧓🏿,🧔,🧔‍♀️,🧔‍♂️,🧔🏻,🧔🏻‍♀️,🧔🏻‍♂️,🧔🏼,🧔🏼‍♀️,🧔🏼‍♂️,🧔🏽,🧔🏽‍♀️,🧔🏽‍♂️,🧔🏾,🧔🏾‍♀️,🧔🏾‍♂️,🧔🏿,🧔🏿‍♀️,🧔🏿‍♂️,🧕,🧕🏻,🧕🏼,🧕🏽,🧕🏾,🧕🏿,🧖,🧖‍♀️,🧖‍♂️,🧖🏻,🧖🏻‍♀️,🧖🏻‍♂️,🧖🏼,🧖🏼‍♀️,🧖🏼‍♂️,🧖🏽,🧖🏽‍♀️,🧖🏽‍♂️,🧖🏾,🧖🏾‍♀️,🧖🏾‍♂️,🧖🏿,🧖🏿‍♀️,🧖🏿‍♂️,🧗,🧗‍♀️,🧗‍♂️,🧗🏻,🧗🏻‍♀️,🧗🏻‍♂️,🧗🏼,🧗🏼‍♀️,🧗🏼‍♂️,🧗🏽,🧗🏽‍♀️,🧗🏽‍♂️,🧗🏾,🧗🏾‍♀️,🧗🏾‍♂️,🧗🏿,🧗🏿‍♀️,🧗🏿‍♂️,🧘,🧘‍♀️,🧘‍♂️,🧘🏻,🧘🏻‍♀️,🧘🏻‍♂️,🧘🏼,🧘🏼‍♀️,🧘🏼‍♂️,🧘🏽,🧘🏽‍♀️,🧘🏽‍♂️,🧘🏾,🧘🏾‍♀️,🧘🏾‍♂️,🧘🏿,🧘🏿‍♀️,🧘🏿‍♂️,🧙,🧙‍♀️,🧙‍♂️,🧙🏻,🧙🏻‍♀️,🧙🏻‍♂️,🧙🏼,🧙🏼‍♀️,🧙🏼‍♂️,🧙🏽,🧙🏽‍♀️,🧙🏽‍♂️,🧙🏾,🧙🏾‍♀️,🧙🏾‍♂️,🧙🏿,🧙🏿‍♀️,🧙🏿‍♂️,🧚,🧚‍♀️,🧚‍♂️,🧚🏻,🧚🏻‍♀️,🧚🏻‍♂️,🧚🏼,🧚🏼‍♀️,🧚🏼‍♂️,🧚🏽,🧚🏽‍♀️,🧚🏽‍♂️,🧚🏾,🧚🏾‍♀️,🧚🏾‍♂️,🧚🏿,🧚🏿‍♀️,🧚🏿‍♂️,🧛,🧛‍♀️,🧛‍♂️,🧛🏻,🧛🏻‍♀️,🧛🏻‍♂️,🧛🏼,🧛🏼‍♀️,🧛🏼‍♂️,🧛🏽,🧛🏽‍♀️,🧛🏽‍♂️,🧛🏾,🧛🏾‍♀️,🧛🏾‍♂️,🧛🏿,🧛🏿‍♀️,🧛🏿‍♂️,🧜,🧜‍♀️,🧜‍♂️,🧜🏻,🧜🏻‍♀️,🧜🏻‍♂️,🧜🏼,🧜🏼‍♀️,🧜🏼‍♂️,🧜🏽,🧜🏽‍♀️,🧜🏽‍♂️,🧜🏾,🧜🏾‍♀️,🧜🏾‍♂️,🧜🏿,🧜🏿‍♀️,🧜🏿‍♂️,🧝,🧝‍♀️,🧝‍♂️,🧝🏻,🧝🏻‍♀️,🧝🏻‍♂️,🧝🏼,🧝🏼‍♀️,🧝🏼‍♂️,🧝🏽,🧝🏽‍♀️,🧝🏽‍♂️,🧝🏾,🧝🏾‍♀️,🧝🏾‍♂️,🧝🏿,🧝🏿‍♀️,🧝🏿‍♂️,🧞,🧞‍♀️,🧞‍♂️,🧟,🧟‍♀️,🧟‍♂️,🧠,🧡,🧢,🧣,🧤,🧥,🧦,🧧,🧨,🧩,🧪,🧫,🧬,🧭,🧮,🧯,🧰,🧱,🧲,🧳,🧴,🧵,🧶,🧷,🧸,🧹,🧺,🧻,🧼,🧽,🧾,🧿,🩰,🩱,🩲,🩳,🩴,🩵,🩶,🩷,🩸,🩹,🩺,🩻,🩼,🪀,🪁,🪂,🪃,🪄,🪅,🪆,🪇,🪈,🪉,🪏,🪐,🪑,🪒,🪓,🪔,🪕,🪖,🪗,🪘,🪙,🪚,🪛,🪜,🪝,🪞,🪟,🪠,🪡,🪢,🪣,🪤,🪥,🪦,🪧,🪨,🪩,🪪,🪫,🪬,🪭,🪮,🪯,🪰,🪱,🪲,🪳,🪴,🪵,🪶,🪷,🪸,🪹,🪺,🪻,🪼,🪽,🪾,🪿,🫀,🫁,🫂,🫃,🫃🏻,🫃🏼,🫃🏽,🫃🏾,🫃🏿,🫄,🫄🏻,🫄🏼,🫄🏽,🫄🏾,🫄🏿,🫅,🫅🏻,🫅🏼,🫅🏽,🫅🏾,🫅🏿,🫆,🫎,🫏,🫐,🫑,🫒,🫓,🫔,🫕,🫖,🫗,🫘,🫙,🫚,🫛,🫜,🫟,🫠,🫡,🫢,🫣,🫤,🫥,🫦,🫧,🫨,🫩,🫰,🫰🏻,🫰🏼,🫰🏽,🫰🏾,🫰🏿,🫱,🫱🏻,🫱🏻‍🫲🏼,🫱🏻‍🫲🏽,🫱🏻‍🫲🏾,🫱🏻‍🫲🏿,🫱🏼,🫱🏼‍🫲🏻,🫱🏼‍🫲🏽,🫱🏼‍🫲🏾,🫱🏼‍🫲🏿,🫱🏽,🫱🏽‍🫲🏻,🫱🏽‍🫲🏼,🫱🏽‍🫲🏾,🫱🏽‍🫲🏿,🫱🏾,🫱🏾‍🫲🏻,🫱🏾‍🫲🏼,🫱🏾‍🫲🏽,🫱🏾‍🫲🏿,🫱🏿,🫱🏿‍🫲🏻,🫱🏿‍🫲🏼,🫱🏿‍🫲🏽,🫱🏿‍🫲🏾,🫲,🫲🏻,🫲🏼,🫲🏽,🫲🏾,🫲🏿,🫳,🫳🏻,🫳🏼,🫳🏽,🫳🏾,🫳🏿,🫴,🫴🏻,🫴🏼,🫴🏽,🫴🏾,🫴🏿,🫵,🫵🏻,🫵🏼,🫵🏽,🫵🏾,🫵🏿,🫶,🫶🏻,🫶🏼,🫶🏽,🫶🏾,🫶🏿,🫷,🫷🏻,🫷🏼,🫷🏽,🫷🏾,🫷🏿,🫸,🫸🏻,🫸🏼,🫸🏽,🫸🏾,🫸🏿";var SequenceProperties = {Basic_Emoji:Basic_Emoji,Emoji_Keycap_Sequence:Emoji_Keycap_Sequence,RGI_Emoji_Modifier_Sequence:RGI_Emoji_Modifier_Sequence,RGI_Emoji_Flag_Sequence:RGI_Emoji_Flag_Sequence,RGI_Emoji_Tag_Sequence:RGI_Emoji_Tag_Sequence,RGI_Emoji_ZWJ_Sequence:RGI_Emoji_ZWJ_Sequence,RGI_Emoji:RGI_Emoji};

const isLeadingSurrogate = cp => cp >= 0xD800 && cp <= 0xDBFF;
const isTrailingSurrogate = cp => cp >= 0xDC00 && cp <= 0xDFFF;
/** https://tc39.es/ecma262/#table-nonbinary-unicode-properties */
const Table69_NonbinaryUnicodeProperties = {
  General_Category: 'General_Category',
  gc: 'General_Category',
  Script: 'Script',
  sc: 'Script',
  Script_Extensions: 'Script_Extensions',
  scx: 'Script_Extensions'
};
Object.setPrototypeOf(Table69_NonbinaryUnicodeProperties, null);
/** https://tc39.es/ecma262/#table-binary-unicode-properties */
const Table70_BinaryUnicodeProperties = {
  ASCII: 'ASCII',
  ASCII_Hex_Digit: 'ASCII_Hex_Digit',
  AHex: 'ASCII_Hex_Digit',
  Alphabetic: 'Alphabetic',
  Alpha: 'Alphabetic',
  Any: 'Any',
  Assigned: 'Assigned',
  Bidi_Control: 'Bidi_Control',
  Bidi_C: 'Bidi_Control',
  Bidi_Mirrored: 'Bidi_Mirrored',
  Bidi_M: 'Bidi_Mirrored',
  Case_Ignorable: 'Case_Ignorable',
  CI: 'Case_Ignorable',
  Cased: 'Cased',
  Changes_When_Casefolded: 'Changes_When_Casefolded',
  CWCF: 'Changes_When_Casefolded',
  Changes_When_Casemapped: 'Changes_When_Casemapped',
  CWCM: 'Changes_When_Casemapped',
  Changes_When_Lowercased: 'Changes_When_Lowercased',
  CWL: 'Changes_When_Lowercased',
  Changes_When_NFKC_Casefolded: 'Changes_When_NFKC_Casefolded',
  CWKCF: 'Changes_When_NFKC_Casefolded',
  Changes_When_Titlecased: 'Changes_When_Titlecased',
  CWT: 'Changes_When_Titlecased',
  Changes_When_Uppercased: 'Changes_When_Uppercased',
  CWU: 'Changes_When_Uppercased',
  Dash: 'Dash',
  Default_Ignorable_Code_Point: 'Default_Ignorable_Code_Point',
  DI: 'Default_Ignorable_Code_Point',
  Deprecated: 'Deprecated',
  Dep: 'Deprecated',
  Diacritic: 'Diacritic',
  Dia: 'Diacritic',
  Emoji: 'Emoji',
  Emoji_Component: 'Emoji_Component',
  EComp: 'Emoji_Component',
  Emoji_Modifier: 'Emoji_Modifier',
  EMod: 'Emoji_Modifier',
  Emoji_Modifier_Base: 'Emoji_Modifier_Base',
  EBase: 'Emoji_Modifier_Base',
  Emoji_Presentation: 'Emoji_Presentation',
  EPres: 'Emoji_Presentation',
  Extended_Pictographic: 'Extended_Pictographic',
  ExtPict: 'Extended_Pictographic',
  Extender: 'Extender',
  Ext: 'Extender',
  Grapheme_Base: 'Grapheme_Base',
  Gr_Base: 'Grapheme_Base',
  Grapheme_Extend: 'Grapheme_Extend',
  Gr_Ext: 'Grapheme_Extend',
  Hex_Digit: 'Hex_Digit',
  Hex: 'Hex_Digit',
  IDS_Binary_Operator: 'IDS_Binary_Operator',
  IDSB: 'IDS_Binary_Operator',
  IDS_Trinary_Operator: 'IDS_Trinary_Operator',
  IDST: 'IDS_Trinary_Operator',
  ID_Continue: 'ID_Continue',
  IDC: 'ID_Continue',
  ID_Start: 'ID_Start',
  IDS: 'ID_Start',
  Ideographic: 'Ideographic',
  Ideo: 'Ideographic',
  Join_Control: 'Join_Control',
  Join_C: 'Join_Control',
  Logical_Order_Exception: 'Logical_Order_Exception',
  LOE: 'Logical_Order_Exception',
  Lowercase: 'Lowercase',
  Lower: 'Lowercase',
  Math: 'Math',
  Noncharacter_Code_Point: 'Noncharacter_Code_Point',
  NChar: 'Noncharacter_Code_Point',
  Pattern_Syntax: 'Pattern_Syntax',
  Pat_Syn: 'Pattern_Syntax',
  Pattern_White_Space: 'Pattern_White_Space',
  Pat_WS: 'Pattern_White_Space',
  Quotation_Mark: 'Quotation_Mark',
  QMark: 'Quotation_Mark',
  Radical: 'Radical',
  Regional_Indicator: 'Regional_Indicator',
  RI: 'Regional_Indicator',
  Sentence_Terminal: 'Sentence_Terminal',
  STerm: 'Sentence_Terminal',
  Soft_Dotted: 'Soft_Dotted',
  SD: 'Soft_Dotted',
  Terminal_Punctuation: 'Terminal_Punctuation',
  Term: 'Terminal_Punctuation',
  Unified_Ideograph: 'Unified_Ideograph',
  UIdeo: 'Unified_Ideograph',
  Uppercase: 'Uppercase',
  Upper: 'Uppercase',
  Variation_Selector: 'Variation_Selector',
  VS: 'Variation_Selector',
  White_Space: 'White_Space',
  space: 'White_Space',
  XID_Continue: 'XID_Continue',
  XIDC: 'XID_Continue',
  XID_Start: 'XID_Start',
  XIDS: 'XID_Start'
};
Object.setPrototypeOf(Table70_BinaryUnicodeProperties, null);

/** https://tc39.es/ecma262/#table-binary-unicode-properties-of-strings */
const Table71_BinaryPropertyOfStrings = {
  Basic_Emoji: 'Basic_Emoji',
  Emoji_Keycap_Sequence: 'Emoji_Keycap_Sequence',
  RGI_Emoji_Modifier_Sequence: 'RGI_Emoji_Modifier_Sequence',
  RGI_Emoji_Flag_Sequence: 'RGI_Emoji_Flag_Sequence',
  RGI_Emoji_Tag_Sequence: 'RGI_Emoji_Tag_Sequence',
  RGI_Emoji_ZWJ_Sequence: 'RGI_Emoji_ZWJ_Sequence',
  RGI_Emoji: 'RGI_Emoji'
};
Object.setPrototypeOf(Table71_BinaryPropertyOfStrings, null);
const canonicalizeUnicodePropertyCache = {
  __proto__: null
};
const stringPropertySetCache = {};
const Unicode = {
  toUppercase(ch) {
    return String.fromCodePoint(ch).toUpperCase().codePointAt(0);
  },
  toCodePoint(ch) {
    return ch.codePointAt(0);
  },
  toCharacter(ch) {
    return String.fromCodePoint(ch);
  },
  isCharacter(ch) {
    return ch.length === 1 || [...ch].length === 1;
  },
  toCodeUnit(ch) {
    const codePoint = ch.charCodeAt(0);
    const codePoint2 = ch.charCodeAt(1);
    return [codePoint, Number.isNaN(codePoint2) ? codePoint2 : undefined];
  },
  iterateByCodePoint(x) {
    return Array.from(x);
  },
  characterMatchPropertyValue(ch, property, value, rer) {
    if (!Unicode.isCharacter(ch)) {
      return false;
    }
    let path = value ? `${property}/${value}` : `Binary_Property/${property}`;
    const cp = ch.codePointAt(0);
    // https://www.unicode.org/reports/tr24/#Script_Values
    // Unknown is: Unused, private use or surrogate code points.
    if ((property === 'Script' || property === 'Script_Extensions') && (value === 'Unknown' || value === 'Zzzz')) {
      // https://www.unicode.org/faq/private_use.html
      if (cp >= 0xE000 && cp <= 0xF8FF || cp >= 0xF0000 && cp <= 0xFFFFD || cp >= 0x100000 && cp <= 0x10FFFD) {
        return true;
      }
      // Non characters
      if (cp >= 0xFDD0 && cp <= 0xFDEF || cp === 0xFFFE || cp === 0xFFFF || cp.toString(16).match(/^(?:[0-9a-f]|10)fff[fe]$/i)) {
        return true;
      }
      if (isLeadingSurrogate(cp) || isTrailingSurrogate(cp)) {
        return true;
      }
      path = 'General_Category/Unassigned';
    }
    if (!(path in UnicodeSets)) {
      throw new Assert.Error(`Unicode property "${path}" not found in UnicodeSets.`);
    }
    if (rer) {
      const cacheKey = JSON.stringify([rer, path]);
      if (!canonicalizeUnicodePropertyCache[cacheKey]) {
        const excludeSet = new Set();
        const includeSet = new Set();
        for (const [from, to] of UnicodeSets[path]) {
          for (let index = from; index <= to; index += 1) {
            const char = String.fromCodePoint(index);
            const ch2 = Canonicalize(rer, char);
            if (char !== ch2) {
              excludeSet.add(char);
              includeSet.add(ch2);
            }
          }
        }
        canonicalizeUnicodePropertyCache[cacheKey] = [excludeSet, includeSet];
      }
      const [excludeSet, includeSet] = canonicalizeUnicodePropertyCache[cacheKey];
      if (excludeSet.has(ch)) {
        return false;
      }
      if (includeSet.has(ch)) {
        return true;
      }
    }
    return !!UnicodeSets[path].find(([from, to]) => from <= cp && cp <= to);
  },
  getStringPropertySet(property) {
    stringPropertySetCache[property] ??= SequenceProperties[property].split(',');
    return stringPropertySetCache[property];
  },
  /** https://www.unicode.org/reports/tr44/#Simple_Case_Folding */
  // TODO: scf() in spec means Simple Case Folding or Simple + Common Case Folding?
  // https://github.com/tc39/ecma262/issues/3594
  // SimpleCaseFoldingMapping(ch: Character): Character {
  //   // Note: The case foldings are omitted in the data file if they are the same as the code point itself.
  //   return (unicodeCaseFoldingSimple.get(ch) || ch) as Character;
  // },
  SimpleOrCommonCaseFoldingMapping(ch) {
    if (unicodeCaseFoldingCommon.has(ch)) {
      return unicodeCaseFoldingCommon.get(ch);
    }
    if (unicodeCaseFoldingSimple.has(ch)) {
      return unicodeCaseFoldingSimple.get(ch);
    }
    return ch;
  },
  iterateCharacterByCodePoint(string) {
    return string[Symbol.iterator]();
  }
};

/** https://tc39.es/ecma262/#sec-pattern-semantics */

/** https://tc39.es/ecma262/#sec-pattern-semantics */

/** https://tc39.es/ecma262/#sec-pattern-semantics */

/* List of BMPCharacter (non Unicode mode) or list of CodePoint. */

/** https://developer.mozilla.org/en-US/docs/Glossary/Code_point */

/** https://developer.mozilla.org/en-US/docs/Glossary/Code_unit */

/** https://tc39.es/ecma262/#sec-privateelement-specification-type */
class PrivateElementRecord {
  Key;
  Kind;
  Value;
  Get;
  Set;
  constructor(init) {
    this.Key = init.Key;
    this.Kind = init.Kind;
    this.Value = init.Value;
    this.Get = init.Get;
    this.Set = init.Set;
  }
}

/** https://tc39.es/ecma262/#sec-definemethodproperty */
function* DefineMethodProperty(key, homeObject, closure, enumerable) {
  // 1. If key is a Private Name, then
  if (key instanceof PrivateName) {
    // a. Return PrivateElement { [[Key]]: key, [[Kind]]: method, [[Value]]: closure }.
    return new PrivateElementRecord({
      Key: key,
      Kind: 'method',
      Value: closure
    });
  } else {
    // 2. Else,
    // a. Let desc be the PropertyDescriptor { [[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }.
    const desc = _Descriptor({
      Value: closure,
      Writable: Value.true,
      Enumerable: enumerable,
      Configurable: Value.true
    });
    // b. Perform ? DefinePropertyOrThrow(homeObject, key, desc).
    /* ReturnIfAbrupt */
    let _temp = yield* DefinePropertyOrThrow(homeObject, key, desc);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // c. Return empty.
    return undefined;
  }
}
DefineMethodProperty.section = 'https://tc39.es/ecma262/#sec-definemethodproperty'; // MethodDefinition :
//   ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
//   `get` ClassElementName `(` `)` `{` FunctionBody `}`
//   `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
function* MethodDefinitionEvaluation_MethodDefinition(MethodDefinition, object, enumerable) {
  switch (true) {
    case !!MethodDefinition.UniqueFormalParameters:
      {
        /* ReturnIfAbrupt */
        let _temp2 = yield* DefineMethod(MethodDefinition, object);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        // 1. Let methodDef be ? DefineMethod of MethodDefinition with argument object.
        const methodDef = _temp2;
        // 2. Perform ! SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]).
        /* X */
        let _temp3 = SetFunctionName(methodDef.Closure, methodDef.Key);
        /* node:coverage ignore next */
        if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionName(methodDef.Closure, methodDef.Key) returned an abrupt completion", {
          cause: _temp3
        });
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        // 3. Return ? DefineMethodProperty(methodDef.[[Key]], object, methodDef.[[Closure]], enumerable).
        return yield* DefineMethodProperty(methodDef.Key, object, methodDef.Closure, enumerable);
      }
    case !!MethodDefinition.PropertySetParameterList:
      {
        const {
          ClassElementName,
          PropertySetParameterList,
          FunctionBody
        } = MethodDefinition;
        // 1. Let propKey be the result of evaluating ClassElementName.
        // 2. ReturnIfAbrupt(propKey).
        /* ReturnIfAbrupt */
        let _temp4 = yield* Evaluate_PropertyName(ClassElementName);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        const propKey = _temp4;
        // 3. Let scope be the running execution context's LexicalEnvironment.
        const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
        // 4. Let privateScope be the running execution context's PrivateEnvironment.
        const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
        // 5. Let sourceText be the source text matched by MethodDefinition.
        const sourceText = sourceTextMatchedBy(MethodDefinition);
        // 6. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, PropertySetParameterList, FunctionBody, non-lexical-this, scope, privateScope).
        const closure = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, PropertySetParameterList, FunctionBody, 'non-lexical-this', scope, privateScope);
        // 7. Perform MakeMethod(closure, object).
        MakeMethod(closure, object);
        // 8. Perform SetFunctionName(closure, propKey, "get").
        SetFunctionName(closure, propKey, Value('set'));
        // 9. If propKey is a Private Name, then
        if (propKey instanceof PrivateName) {
          // a. Return PrivateElement { [[Key]]: propKey, [[Kind]]: accessor, [[Get]]: undefined, [[Set]]: closure }.
          return new PrivateElementRecord({
            Key: propKey,
            Kind: 'accessor',
            Get: Value.undefined,
            Set: closure
          });
        } else {
          // 10. Else,
          // a. Let desc be the PropertyDescriptor { [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.
          const desc = _Descriptor({
            Set: closure,
            Enumerable: enumerable,
            Configurable: Value.true
          });
          // b. Perform ? DefinePropertyOrThrow(object, propKey, desc).
          /* ReturnIfAbrupt */
          let _temp5 = yield* DefinePropertyOrThrow(object, propKey, desc);
          /* node:coverage ignore next */
          if (_temp5 instanceof AbruptCompletion) return _temp5;
          /* node:coverage ignore next */
          if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
          // c. Return empty.
          return undefined;
        }
      }
    case !MethodDefinition.UniqueFormalParameters && !MethodDefinition.PropertySetParameterList:
      {
        const {
          ClassElementName,
          FunctionBody
        } = MethodDefinition;
        // 1. Let propKey be the result of evaluating ClassElementName.
        // 2. ReturnIfAbrupt(propKey).
        /* ReturnIfAbrupt */
        let _temp6 = yield* Evaluate_PropertyName(ClassElementName);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        const propKey = _temp6;
        // 3. Let scope be the running execution context's LexicalEnvironment.
        const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
        // 4. Let privateScope be the running execution context's PrivateEnvironment.
        const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
        // 5. Let formalParameterList be an instance of the production FormalParameters : [empty].
        const formalParameterList = [];
        // 6. Let sourceText be the source text matched by MethodDefinition.
        const sourceText = sourceTextMatchedBy(MethodDefinition);
        // 7. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameterList, FunctionBody, non-lexical-this, scope, privateScope).
        const closure = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, formalParameterList, FunctionBody, 'non-lexical-this', scope, privateScope);
        // 8. Perform MakeMethod(closure, object).
        MakeMethod(closure, object);
        // 9. Perform SetFunctionName(closure, propKey, "get").
        SetFunctionName(closure, propKey, Value('get'));
        // 10. If propKey is a Private Name, then
        if (propKey instanceof PrivateName) {
          return new PrivateElementRecord({
            Key: propKey,
            Kind: 'accessor',
            Get: closure,
            Set: Value.undefined
          });
        } else {
          // 11. Else,
          // a. Let desc be the PropertyDescriptor { [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.
          const desc = _Descriptor({
            Get: closure,
            Enumerable: enumerable,
            Configurable: Value.true
          });
          // b. Perform ? DefinePropertyOrThrow(object, propKey, desc).
          /* ReturnIfAbrupt */
          let _temp7 = yield* DefinePropertyOrThrow(object, propKey, desc);
          /* node:coverage ignore next */
          if (_temp7 instanceof AbruptCompletion) return _temp7;
          /* node:coverage ignore next */
          if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
          // c. Return empty.
          return undefined;
        }
      }
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('MethodDefinitionEvaluation_MethodDefinition', MethodDefinition);
  }
}

/** https://tc39.es/ecma262/#sec-async-function-definitions-MethodDefinitionEvaluation */
//   AsyncMethod :
//     `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncBody `}`
function* MethodDefinitionEvaluation_AsyncMethod(AsyncMethod, object, enumerable) {
  const {
    ClassElementName,
    UniqueFormalParameters,
    AsyncBody
  } = AsyncMethod;
  // 1. Let propKey be the result of evaluating ClassElementName.
  // 2. ReturnIfAbrupt(propKey).
  /* ReturnIfAbrupt */
  let _temp8 = yield* Evaluate_PropertyName(ClassElementName);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const propKey = _temp8;
  // 3. Let scope be the LexicalEnvironment of the running execution context.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 4. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 5. Let sourceText be the source text matched by AsyncMethod.
  const sourceText = sourceTextMatchedBy(AsyncMethod);
  // 6. Let closure be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, UniqueFormalParameters, AsyncBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp9 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), sourceText, UniqueFormalParameters, AsyncBody, 'non-lexical-this', scope, privateScope);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), sourceText, UniqueFormalParameters, AsyncBody, 'non-lexical-this', scope, privateScope) returned an abrupt completion", {
    cause: _temp9
  });
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const closure = _temp9;
  // 7. Perform ! MakeMethod(closure, object).
  /* X */
  let _temp10 = MakeMethod(closure, object);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! MakeMethod(closure, object) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  // 8. Perform ! SetFunctionName(closure, propKey).
  /* X */
  let _temp11 = SetFunctionName(closure, propKey);
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionName(closure, propKey) returned an abrupt completion", {
    cause: _temp11
  });
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  // 9. Return ? DefineMethodProperty(propKey, object, closure, enumerable).
  return yield* DefineMethodProperty(propKey, object, closure, enumerable);
}
MethodDefinitionEvaluation_AsyncMethod.section = 'https://tc39.es/ecma262/#sec-async-function-definitions-MethodDefinitionEvaluation';
/** https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation */
//   GeneratorMethod :
//     `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`
function* MethodDefinitionEvaluation_GeneratorMethod(GeneratorMethod, object, enumerable) {
  const {
    ClassElementName,
    UniqueFormalParameters,
    GeneratorBody
  } = GeneratorMethod;
  // 1. Let propKey be the result of evaluating ClassElementName.
  let propKey = yield* Evaluate_PropertyName(ClassElementName);
  // 2. ReturnIfAbrupt(propKey).
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (propKey && typeof propKey === 'object' && 'next' in propKey) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (propKey instanceof AbruptCompletion) return propKey;
  /* node:coverage ignore next */
  if (propKey instanceof Completion) propKey = propKey.Value;
  propKey = propKey;
  // 3. Let scope be the LexicalEnvironment of the running execution context.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 4. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 5. Let sourceText be the source text matched by GeneratorMethod.
  const sourceText = sourceTextMatchedBy(GeneratorMethod);
  // 6. Let closure be ! OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, UniqueFormalParameters, AsyncBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp12 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype%'), sourceText, UniqueFormalParameters, GeneratorBody, 'non-lexical-this', scope, privateScope);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype%'), sourceText, UniqueFormalParameters, GeneratorBody, 'non-lexical-this', scope, privateScope) returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  const closure = _temp12;
  // 7. Perform ! MakeMethod(closure, object).
  /* X */
  let _temp13 = MakeMethod(closure, object);
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! MakeMethod(closure, object) returned an abrupt completion", {
    cause: _temp13
  });
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  // 8. Perform ! SetFunctionName(closure, propKey).
  /* X */
  let _temp14 = SetFunctionName(closure, propKey);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionName(closure, propKey) returned an abrupt completion", {
    cause: _temp14
  });
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  // 9. Let prototype be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
  const prototype = OrdinaryObjectCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype%'));
  // 10. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
  /* X */
  let _temp15 = DefinePropertyOrThrow(closure, Value('prototype'), _Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(closure, Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp15
  });
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  // 11. Return ? DefineMethodProperty(propKey, object, closure, enumerable).
  return yield* DefineMethodProperty(propKey, object, closure, enumerable);
}
MethodDefinitionEvaluation_GeneratorMethod.section = 'https://tc39.es/ecma262/#sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation';
/** https://tc39.es/ecma262/#sec-asyncgenerator-definitions-propertydefinitionevaluation */
//   AsyncGeneratorMethod :
//     `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
function* MethodDefinitionEvaluation_AsyncGeneratorMethod(AsyncGeneratorMethod, object, enumerable) {
  const {
    ClassElementName,
    UniqueFormalParameters,
    AsyncGeneratorBody
  } = AsyncGeneratorMethod;
  // 1. Let propKey be the result of evaluating ClassElementName.
  let propKey = yield* Evaluate_PropertyName(ClassElementName);
  // 2. ReturnIfAbrupt(propKey).
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (propKey && typeof propKey === 'object' && 'next' in propKey) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (propKey instanceof AbruptCompletion) return propKey;
  /* node:coverage ignore next */
  if (propKey instanceof Completion) propKey = propKey.Value;
  propKey = propKey;
  // 3. Let scope be the LexicalEnvironment of the running execution context.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 4. Let privateScope be the running execution context's PrivateEnvironment.
  const privateEnv = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 5. Let sourceText be the source text matched by AsyncGeneratorMethod.
  const sourceText = sourceTextMatchedBy(AsyncGeneratorMethod);
  // 6. Let closure be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, UniqueFormalParameters, AsyncGeneratorBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp16 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), sourceText, UniqueFormalParameters, AsyncGeneratorBody, 'non-lexical-this', scope, privateEnv);
  /* node:coverage ignore next */
  if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), sourceText, UniqueFormalParameters, AsyncGeneratorBody, 'non-lexical-this', scope, privateEnv) returned an abrupt completion", {
    cause: _temp16
  });
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  const closure = _temp16;
  // 7. Perform ! MakeMethod(closure, object).
  /* X */
  let _temp17 = MakeMethod(closure, object);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! MakeMethod(closure, object) returned an abrupt completion", {
    cause: _temp17
  });
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  // 9. Perform ! SetFunctionName(closure, propKey).
  /* X */
  let _temp18 = SetFunctionName(closure, propKey);
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionName(closure, propKey) returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  // 9. Let prototype be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
  const prototype = OrdinaryObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype.prototype%'));
  // 10. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
  /* X */
  let _temp19 = DefinePropertyOrThrow(closure, Value('prototype'), _Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(closure, Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp19
  });
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  // 11. Return ? DefineMethodProperty(propKey, object, closure, enumerable).
  return yield* DefineMethodProperty(propKey, object, closure, enumerable);
}
MethodDefinitionEvaluation_AsyncGeneratorMethod.section = 'https://tc39.es/ecma262/#sec-asyncgenerator-definitions-propertydefinitionevaluation';
function MethodDefinitionEvaluation(node, object, enumerable) {
  switch (node.type) {
    case 'MethodDefinition':
      return MethodDefinitionEvaluation_MethodDefinition(node, object, enumerable);
    case 'AsyncMethod':
      return MethodDefinitionEvaluation_AsyncMethod(node, object, enumerable);
    case 'GeneratorMethod':
      return MethodDefinitionEvaluation_GeneratorMethod(node, object, enumerable);
    case 'AsyncGeneratorMethod':
      return MethodDefinitionEvaluation_AsyncGeneratorMethod(node, object, enumerable);
    /* node:coverage ignore next */default:
      /* node:coverage ignore next */
      throw new OutOfRange$1('MethodDefinitionEvaluation', node);
  }
}

class ClassFieldDefinitionRecord {
  Name;
  Initializer;
  constructor(init) {
    this.Name = init.Name;
    this.Initializer = init.Initializer;
  }
}
function* ClassFieldDefinitionEvaluation(FieldDefinition, homeObject) {
  const {
    ClassElementName,
    Initializer
  } = FieldDefinition;
  // 1. Let name be the result of evaluating ClassElementName.
  // 2. ReturnIfAbrupt(name).
  /* ReturnIfAbrupt */
  let _temp = yield* Evaluate_PropertyName(ClassElementName);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const name = _temp;
  // 3. If Initializer is present, then
  let initializer;
  if (Initializer) {
    // a. Let formalParameterList be an instance of the production FormalParameters : [empty].
    const formalParameterList = [];
    // b. Let scope be the LexicalEnvironment of the running execution context.
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    // c. Let privateScope be the running execution context's PrivateEnvironment.
    const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
    // d. Let sourceText be the empty sequence of Unicode code points.
    const sourceText = '';
    // e. Let initializer be ! OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameterList, Initializer, non-lexical-this, scope, privateScope).
    /* X */
    let _temp2 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, formalParameterList, Initializer, 'non-lexical-this', scope, privateScope);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(\n      surroundingAgent.intrinsic('%Function.prototype%'),\n      sourceText,\n      formalParameterList,\n      Initializer,\n      'non-lexical-this',\n      scope,\n      privateScope,\n    ) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    initializer = _temp2;
    // f. Perform MakeMethod(initializer, homeObject).
    MakeMethod(initializer, homeObject);
    // g. Set initializer.[[ClassFieldInitializerName]] to name.
    initializer.ClassFieldInitializerName = name;
  } else {
    // 4. Else,
    // a. Let initializer be empty.
    initializer = undefined;
  }
  // 5. Return the ClassFieldDefinition Record { [[Name]]: name, [[Initializer]]: initializer }.
  return new ClassFieldDefinitionRecord({
    Name: name,
    Initializer: initializer
  });
}

/** https://tc39.es/ecma262/#sec-runtime-semantics-instantiateordinaryfunctionexpression */
//   FunctionExpression :
//     `function` `(` FormalParameters `)` `{` FunctionBody `}`
//     `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
function InstantiateOrdinaryFunctionExpression(FunctionExpression, name) {
  const {
    BindingIdentifier,
    FormalParameters,
    FunctionBody
  } = FunctionExpression;
  if (BindingIdentifier) {
    // 1. Assert: name is not present.
    Assert(name === undefined, "name === undefined");
    // 2. Set name to StringValue of BindingIdentifier.
    name = StringValue(BindingIdentifier);
    // 3. Let scope be the running execution context's LexicalEnvironment.
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    // 4. Let funcEnv be NewDeclarativeEnvironment(scope).
    const funcEnv = new DeclarativeEnvironmentRecord(scope);
    // 5. Perform funcEnv.CreateImmutableBinding(name, false).
    funcEnv.CreateImmutableBinding(name, Value.false);
    // 6. Let privateScope be the running execution context's PrivateEnvironment.
    const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
    // 7. Let sourceText be the source text matched by FunctionExpression.
    const sourceText = sourceTextMatchedBy(FunctionExpression);
    // 8. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody, non-lexical-this, funcEnv, privateScope).
    const closure = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, FormalParameters, FunctionBody, 'non-lexical-this', funcEnv, privateScope);
    // 9. Perform SetFunctionName(closure, name).
    SetFunctionName(closure, name);
    // 10. Perform MakeConstructor(closure).
    MakeConstructor(closure);
    // 11. Perform funcEnv.InitializeBinding(name, closure).
    /* X */
    let _temp = funcEnv.InitializeBinding(name, closure);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! funcEnv.InitializeBinding(name, closure) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // 12. Return closure.
    return closure;
  }
  // 1. If name is not present, set name to "".
  if (name === undefined) {
    name = Value('');
  }
  // 2. Let scope be the running execution context's LexicalEnvironment.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 3. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 4. Let sourceText be the source text matched by FunctionExpression.
  const sourceText = sourceTextMatchedBy(FunctionExpression);
  // 5. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody, non-lexical-this, scope, privateScope).
  const closure = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, FormalParameters, FunctionBody, 'non-lexical-this', scope, privateScope);
  // 6. Perform SetFunctionName(closure, name).
  SetFunctionName(closure, name);
  // 7. Perform MakeConstructor(closure).
  MakeConstructor(closure);
  // 8. Return closure.
  return closure;
}
InstantiateOrdinaryFunctionExpression.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-instantiateordinaryfunctionexpression';

/** https://tc39.es/ecma262/#sec-runtime-semantics-instantiategeneratorfunctionexpression */
//   GeneratorExpression :
//     `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
//     `function` `* `BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
function InstantiateGeneratorFunctionExpression(GeneratorExpression, name) {
  const {
    BindingIdentifier,
    FormalParameters,
    GeneratorBody
  } = GeneratorExpression;
  if (BindingIdentifier) {
    // 1. Assert: name is not present.
    Assert(name === undefined, "name === undefined");
    // 2. Set name to StringValue of BindingIdentifier.
    name = StringValue(BindingIdentifier);
    // 3. Let scope be the running execution context's LexicalEnvironment.
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    // 4. Let funcEnv be NewDeclarativeEnvironment(scope).
    const funcEnv = new DeclarativeEnvironmentRecord(scope);
    // 5. Perform funcEnv.CreateImmutableBinding(name, false).
    funcEnv.CreateImmutableBinding(name, Value.false);
    // 6. Let privateScope be the running execution context's PrivateEnvironment.
    const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
    // 7. Let sourceText be the source text matched by GeneratorExpression.
    const sourceText = sourceTextMatchedBy(GeneratorExpression);
    // 8. Let closure be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, FormalParameters, GeneratorBody, non-lexical-this, funcEnv, privateScope).
    const closure = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype%'), sourceText, FormalParameters, GeneratorBody, 'non-lexical-this', funcEnv, privateScope);
    // 9. Perform SetFunctionName(closure, name).
    SetFunctionName(closure, name);
    // 10. Let prototype be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
    /* X */
    let _temp = OrdinaryObjectCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype%'));
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype%')) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const prototype = _temp;
    // 11. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
    /* X */
    let _temp2 = DefinePropertyOrThrow(closure, Value('prototype'), new _Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(closure, Value('prototype'), new Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    })) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // 12. Perform funcEnv.InitializeBinding(name, closure).
    /* X */
    let _temp3 = funcEnv.InitializeBinding(name, closure);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! funcEnv.InitializeBinding(name, closure) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // 13. Return closure.
    return closure;
  }
  // 1. If name is not present, set name to "".
  if (name === undefined) {
    name = Value('');
  }
  // 2. Let scope be the running execution context's LexicalEnvironment.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 3. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 4. Let sourceText be the source text matched by GeneratorExpression.
  const sourceText = sourceTextMatchedBy(GeneratorExpression);
  // 5. Let closure be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, FormalParameters, GeneratorBody, non-lexical-this, scope, privateScope).
  const closure = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype%'), sourceText, FormalParameters, GeneratorBody, 'non-lexical-this', scope, privateScope);
  // 6. Perform SetFunctionName(closure, name).
  SetFunctionName(closure, name);
  // 7. Let prototype be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
  /* X */
  let _temp4 = OrdinaryObjectCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype%'));
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype%')) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const prototype = _temp4;
  // 8. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
  /* X */
  let _temp5 = DefinePropertyOrThrow(closure, Value('prototype'), new _Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(closure, Value('prototype'), new Descriptor({\n    Value: prototype,\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 9. Return closure.
  return closure;
}
InstantiateGeneratorFunctionExpression.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-instantiategeneratorfunctionexpression';

/** https://tc39.es/ecma262/#sec-runtime-semantics-instantiatearrowfunctionexpression */
// ArrowFunction : ArrowParameters `=>` ConciseBody
function InstantiateArrowFunctionExpression(ArrowFunction, name) {
  const {
    ArrowParameters,
    ConciseBody
  } = ArrowFunction;
  // 1. If name is not present, set name to "".
  if (name === undefined) {
    name = Value('');
  }
  // 2. Let scope be the LexicalEnvironment of the running execution context.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 3. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 4. Let sourceText be the source text matched by ArrowFunction.
  const sourceText = sourceTextMatchedBy(ArrowFunction);
  // 5. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, ArrowParameters, ConciseBody, lexical-this, scope, privateScope).
  const closure = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, ArrowParameters, ConciseBody, 'lexical-this', scope, privateScope);
  // 6. Perform SetFunctionName(closure, name).
  SetFunctionName(closure, name);
  // 7. Return closure.
  return closure;
}
InstantiateArrowFunctionExpression.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-instantiatearrowfunctionexpression';

/** https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncarrowfunctionexpression */
// AsyncArrowFunction : ArrowParameters `=>` AsyncConciseBody
function InstantiateAsyncArrowFunctionExpression(AsyncArrowFunction, name) {
  const {
    ArrowParameters,
    AsyncConciseBody
  } = AsyncArrowFunction;
  // 1. If name is not present, set name to "".
  if (name === undefined) {
    name = Value('');
  }
  // 2. Let scope be the LexicalEnvironment of the running execution context.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 3. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 4. Let sourceText be the source text matched by AsyncArrowFunction.
  const sourceText = sourceTextMatchedBy(AsyncArrowFunction);
  // 5. Let parameters be AsyncArrowBindingIdentifier.
  const parameters = ArrowParameters;
  // 6. Let closure be OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, ArrowParameters, AsyncConciseBody, lexical-this, scope, privateScope).
  const closure = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), sourceText, parameters, AsyncConciseBody, 'lexical-this', scope, privateScope);
  // 7. Perform SetFunctionName(closure, name).
  SetFunctionName(closure, name);
  // 8. Return closure.
  return closure;
}
InstantiateAsyncArrowFunctionExpression.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncarrowfunctionexpression';

/** https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncfunctionexpression */
function InstantiateAsyncFunctionExpression(AsyncFunctionExpression, name) {
  const {
    BindingIdentifier,
    FormalParameters,
    AsyncBody
  } = AsyncFunctionExpression;
  if (BindingIdentifier) {
    // 1. Assert: name is not present.
    Assert(name === undefined, "name === undefined");
    // 2. Set name to StringValue of BindingIdentifier.
    name = StringValue(BindingIdentifier);
    // 3. Let scope be the LexicalEnvironment of the running execution context.
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    // 4. Let funcEnv be ! NewDeclarativeEnvironment(scope).
    /* X */
    let _temp = new DeclarativeEnvironmentRecord(scope);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! new DeclarativeEnvironmentRecord(scope) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const funcEnv = _temp;
    // 5. Perform ! funcEnv.CreateImmutableBinding(name, false).
    /* X */
    let _temp2 = funcEnv.CreateImmutableBinding(name, Value.false);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! funcEnv.CreateImmutableBinding(name, Value.false) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // 6. Let privateScope be the running execution context's PrivateEnvironment.
    const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
    // 7. Let sourceText be the source text matched by AsyncFunctionExpression.
    const sourceText = sourceTextMatchedBy(AsyncFunctionExpression);
    // 8. Let closure be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, FormalParameters, AsyncBody, non-lexical-this, funcEnv, privateScope).
    /* X */
    let _temp3 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), sourceText, FormalParameters, AsyncBody, 'non-lexical-this', funcEnv, privateScope);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(\n      surroundingAgent.intrinsic('%AsyncFunction.prototype%'),\n      sourceText,\n      FormalParameters,\n      AsyncBody,\n      'non-lexical-this',\n      funcEnv,\n      privateScope,\n    ) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const closure = _temp3;
    // 9. Perform ! SetFunctionName(closure, name).
    /* X */
    let _temp4 = SetFunctionName(closure, name);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionName(closure, name) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // 10. Perform ! funcEnv.InitializeBinding(name, closure).
    /* X */
    let _temp5 = funcEnv.InitializeBinding(name, closure);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! funcEnv.InitializeBinding(name, closure) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // 11. Return closure.
    return closure;
  }
  // 1. If name is not present, set name to "".
  if (name === undefined) {
    name = Value('');
  }
  // 2. Let scope be the LexicalEnvironment of the running execution context.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 3. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 4. Let sourceText be the source text matched by AsyncFunctionExpression.
  const sourceText = sourceTextMatchedBy(AsyncFunctionExpression);
  // 5. Let closure be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, FormalParameters, AsyncBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp6 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncFunction.prototype%'), sourceText, FormalParameters, AsyncBody, 'non-lexical-this', scope, privateScope);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(\n    surroundingAgent.intrinsic('%AsyncFunction.prototype%'),\n    sourceText,\n    FormalParameters,\n    AsyncBody,\n    'non-lexical-this',\n    scope,\n    privateScope,\n  ) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const closure = _temp6;
  // 6. Perform SetFunctionName(closure, name).
  SetFunctionName(closure, name);
  // 7. Return closure.
  return closure;
}
InstantiateAsyncFunctionExpression.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncfunctionexpression';

/** https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression */
//   AsyncGeneratorExpression :
//     `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
//     `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
function InstantiateAsyncGeneratorFunctionExpression(AsyncGeneratorExpression, name) {
  const {
    BindingIdentifier,
    FormalParameters,
    AsyncGeneratorBody
  } = AsyncGeneratorExpression;
  if (BindingIdentifier) {
    // 1. Assert: name is not present.
    Assert(name === undefined, "name === undefined");
    // 2. Set name to StringValue of BindingIdentifier.
    name = StringValue(BindingIdentifier);
    // 3. Let scope be the running execution context's LexicalEnvironment.
    const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
    // 4. Let funcEnv be NewDeclarativeEnvironment(scope).
    const funcEnv = new DeclarativeEnvironmentRecord(scope);
    // 5. Perform funcEnv.CreateImmutableBinding(name, false).
    funcEnv.CreateImmutableBinding(name, Value.false);
    // 6. Let privateScope be the running execution context's PrivateEnvironment.
    const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
    // 7. Let source text be the source textmatched by AsyncGeneratorExpression.
    const sourceText = sourceTextMatchedBy(AsyncGeneratorExpression);
    // 8. Let closure be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, FormalParameters, AsyncGeneratorBody, non-lexical-this, funcEnv, privateScope).
    /* X */
    let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), sourceText, FormalParameters, AsyncGeneratorBody, 'non-lexical-this', funcEnv, privateScope);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), sourceText, FormalParameters, AsyncGeneratorBody, 'non-lexical-this', funcEnv, privateScope) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const closure = _temp;
    // 9. Perform SetFunctionName(closure, name).
    SetFunctionName(closure, name);
    // 10. Let prototype be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
    const prototype = OrdinaryObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype.prototype%'));
    // 11. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
    /* X */
    let _temp2 = DefinePropertyOrThrow(closure, Value('prototype'), _Descriptor({
      Value: prototype,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(\n      closure,\n      Value('prototype'),\n      Descriptor({\n        Value: prototype,\n        Writable: Value.true,\n        Enumerable: Value.false,\n        Configurable: Value.false,\n      }),\n    ) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // 12. Perform funcEnv.InitializeBinding(name, closure).
    /* X */
    let _temp3 = funcEnv.InitializeBinding(name, closure);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! funcEnv.InitializeBinding(name, closure) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // 13. Return closure.
    return closure;
  }
  // 1. If name is not present, set name to "".
  if (name === undefined) {
    name = Value('');
  }
  // 2. Let scope be the LexicalEnvironment of the running execution context.
  const scope = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 3. Let privateScope be the running execution context's PrivateEnvironment.
  const privateScope = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 4. Let sourceText be the source text matched by AsyncGeneratorExpression.
  const sourceText = sourceTextMatchedBy(AsyncGeneratorExpression);
  // 5. Let closure be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, FormalParameters, AsyncGeneratorBody, non-lexical-this, scope, privateScope).
  /* X */
  let _temp4 = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), sourceText, FormalParameters, AsyncGeneratorBody, 'non-lexical-this', scope, privateScope);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype%'), sourceText, FormalParameters, AsyncGeneratorBody, 'non-lexical-this', scope, privateScope) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const closure = _temp4;
  // 6. Perform SetFunctionName(closure, name).
  SetFunctionName(closure, name);
  // 7. Let prototype be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
  const prototype = OrdinaryObjectCreate(surroundingAgent.intrinsic('%AsyncGeneratorFunction.prototype.prototype%'));
  // 8. Perform ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
  /* X */
  let _temp5 = DefinePropertyOrThrow(closure, Value('prototype'), _Descriptor({
    Value: prototype,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(\n    closure,\n    Value('prototype'),\n    Descriptor({\n      Value: prototype,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    }),\n  ) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 9. Return closure.
  return closure;
}
InstantiateAsyncGeneratorFunctionExpression.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression';

class ClassStaticBlockDefinitionRecord {
  BodyFunction;
  constructor({
    BodyFunction
  }) {
    this.BodyFunction = BodyFunction;
  }
}

/** https://tc39.es/ecma262/#sec-runtime-semantics-classstaticblockdefinitionevaluation */
//    ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`
function ClassStaticBlockDefinitionEvaluation({
  ClassStaticBlockBody
}, homeObject) {
  // 1. Let lex be the running execution context's LexicalEnvironment.
  const lex = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 2. Let privateEnv be the running execution context's PrivateEnvironment.
  const privateEnv = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 3. Let sourceText be the empty sequence of Unicode code points.
  const sourceText = '';
  // 4. Let formalParameters be an instance of the production FormalParameters : [empty] .
  const formalParameters = [];
  // 5. Let bodyFunction be OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameters, ClassStaticBlockBody, non-lexical-this, lex, privateEnv).
  /* X */
  let _temp = OrdinaryFunctionCreate(surroundingAgent.intrinsic('%Function.prototype%'), sourceText, formalParameters, ClassStaticBlockBody, 'non-lexical-this', lex, privateEnv);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryFunctionCreate(\n    surroundingAgent.intrinsic('%Function.prototype%'),\n    sourceText,\n    formalParameters,\n    ClassStaticBlockBody,\n    'non-lexical-this',\n    lex,\n    privateEnv,\n  ) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const bodyFunction = _temp;
  // 6. Perform MakeMethod(bodyFunction, homeObject).
  /* X */
  let _temp2 = MakeMethod(bodyFunction, homeObject);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! MakeMethod(bodyFunction, homeObject) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 7. Return the ClassStaticBlockDefinition Record { [[BodyFunction]]: bodyFunction }.
  return new ClassStaticBlockDefinitionRecord({
    BodyFunction: bodyFunction
  });
}
ClassStaticBlockDefinitionEvaluation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-classstaticblockdefinitionevaluation';

const ShouldSkipStepIn = ['NumericLiteral', 'NullLiteral', 'StringLiteral', 'BooleanLiteral', 'RegularExpressionLiteral', 'CallExpression', 'Block'];
function shouldStepOnNode() {
  const type = surroundingAgent.runningExecutionContext.callSite.lastNode?.type;
  if (type && !type.endsWith('Statement') && !type.endsWith('Declaration') && !ShouldSkipStepIn.includes(type)) {
    return true;
  }
  return false;
}

const FEATURES = [{
  name: 'FinalizationRegistry.prototype.cleanupSome',
  flag: 'cleanup-some',
  url: 'https://github.com/tc39/proposal-cleanup-some'
}, {
  name: 'Uint8Array to/from base64 and hex',
  flag: 'uint8array-base64',
  url: 'https://tc39.es/proposal-arraybuffer-base64/'
}];
Object.freeze(FEATURES);
FEATURES.forEach(Object.freeze);
class ExecutionContextStack extends Array {
  // This ensures that only the length taking overload is supported.
  // This is necessary to support `ArraySpeciesCreate`, which invokes
  // the constructor with argument `length`:
  constructor(length = 0) {
    super(+length);
  }

  // @ts-expect-error
  pop(ctx) {
    if (!ctx.poppedForTailCall) {
      const popped = super.pop();
      Assert(popped === ctx, "popped === ctx");
    }
  }
}
let agentSignifier = 0;
/** https://tc39.es/ecma262/#sec-agents */
class Agent {
  AgentRecord;

  // #execution-context-stack
  executionContextStack = new ExecutionContextStack();

  // NON-SPEC
  jobQueue = [];
  scheduledForCleanup = new Set();
  hostDefinedOptions;
  constructor(options = {}) {
    // #table-agent-record
    const Signifier = agentSignifier;
    agentSignifier += 1;
    this.AgentRecord = {
      LittleEndian: Value.true,
      CanBlock: Value.true,
      Signifier,
      IsLockFree1: Value.true,
      IsLockFree2: Value.true,
      CandidateExecution: undefined,
      KeptAlive: new Set(),
      ModuleAsyncEvaluationCount: 0
    };
    this.hostDefinedOptions = {
      ...options,
      features: options.features
    };
  }

  // #running-execution-context
  get runningExecutionContext() {
    return this.executionContextStack[this.executionContextStack.length - 1];
  }

  // #current-realm
  get currentRealmRecord() {
    return this.runningExecutionContext.Realm;
  }

  // #active-function-object
  get activeFunctionObject() {
    return this.runningExecutionContext.Function;
  }

  // Get an intrinsic by name for the current realm
  intrinsic(name) {
    return this.currentRealmRecord.Intrinsics[name];
  }

  // Generate a throw completion using message templates
  Throw(type, template, ...templateArgs) {
    if (type instanceof Value) {
      return ThrowCompletion(type);
    }
    const error = this.NewError(type, template, ...templateArgs);
    return ThrowCompletion(error);
  }
  NewError(type, template, ...templateArgs) {
    const message = messages[template](...templateArgs);
    const cons = this.currentRealmRecord.Intrinsics[`%${type}%`];
    let error;
    if (type === 'AggregateError') {
      /* X */
      let _temp2 = CreateArrayFromList([]);
      /* node:coverage ignore next */
      if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList([]) returned an abrupt completion", {
        cause: _temp2
      });
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      /* X */
      let _temp = Construct(cons, [_temp2, Value(message)]);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! Construct(cons, [\n        X(CreateArrayFromList([])),\n        Value(message),\n      ]) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      error = _temp;
    } else {
      /* X */
      let _temp3 = Construct(cons, [Value(message)]);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! Construct(cons, [Value(message)]) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      error = _temp3;
    }
    return error;
  }
  queueJob(queueName, job) {
    const callerContext = this.runningExecutionContext;
    const callerRealm = callerContext.Realm;
    const callerScriptOrModule = GetActiveScriptOrModule();
    const pending = {
      queueName,
      job,
      callerRealm,
      callerScriptOrModule
    };
    this.jobQueue.push(pending);
  }

  // NON-SPEC: Check if a feature is enabled in this agent.
  feature(name) {
    return !!this.hostDefinedOptions.features?.includes(name);
  }

  // NON-SPEC
  mark(m) {
    this.AgentRecord.KeptAlive.forEach(m);
    this.executionContextStack.forEach(m);
    this.jobQueue.forEach(j => {
      m(j.callerRealm);
      m(j.callerScriptOrModule);
    });
  }

  // NON-SPEC
  // #region Step-by-step evaluation
  #pausedEvaluator;
  #onEvaluatorFin;

  // NON-SPEC
  /** This function will synchronously return a completion if this is a nested evaluation and debugger cannot be triggered. */
  evaluate(evaluator, onFinished) {
    if (this.#pausedEvaluator) {
      const result = EnsureCompletion(skipDebugger(evaluator));
      // only the top evaluator can be evaluted step by step.
      onFinished(result);
      return result;
    }
    this.#pausedEvaluator = evaluator;
    this.#onEvaluatorFin = onFinished;
    return undefined;
  }
  resumeEvaluate(options) {
    const {
      noBreakpoint
    } = options || {};
    if (!this.#pausedEvaluator) {
      throw new Error('No paused evaluator');
    }
    let nextLocation;
    if (options?.pauseAt === 'step-over') {
      nextLocation = this.runningExecutionContext.callSite.nextNode;
    } else if (options?.pauseAt === 'step-out') {
      nextLocation = this.executionContextStack[this.executionContextStack.length - 2].callSite.lastCallNode;
    }
    let debuggerStatementCompletion = options?.debuggerStatementCompletion;
    while (true) {
      const state = this.#pausedEvaluator.next({
        type: 'debugger-resume',
        value: debuggerStatementCompletion
      });
      debuggerStatementCompletion = undefined;
      if (!noBreakpoint && this.hostDefinedOptions.onDebugger && !this.debugger_isPreviewing && !state.done) {
        if (state.value.type === 'debugger') {
          this.hostDefinedOptions.onDebugger();
          return {
            done: false,
            value: undefined
          };
        } else if (state.value.type === 'potential-debugger') {
          if (options?.pauseAt === 'step-in' && shouldStepOnNode()) {
            this.hostDefinedOptions.onDebugger();
            return {
              done: false,
              value: undefined
            };
          }
          const callSite = surroundingAgent.runningExecutionContext.callSite;
          if (nextLocation && (callSite.lastNode === nextLocation || callSite.lastCallNode === nextLocation)) {
            this.hostDefinedOptions.onDebugger();
            return {
              done: false,
              value: undefined
            };
          }
        }
      }
      if (state.done) {
        this.#pausedEvaluator = undefined;
        this.#onEvaluatorFin(EnsureCompletion(state.value));
        this.#onEvaluatorFin = undefined;
        return state;
      }
    }
  }
  // #endregion

  // NON-SPEC
  // #region parsed scripts/modules
  #script_id = 0;
  parsedSources = new Map();
  addParsedSource(source) {
    const id = `${this.#script_id}`;
    if (source.HostDefined) {
      source.HostDefined.scriptId = id;
    }
    this.hostDefinedOptions.onScriptParsed?.(source, id);
    this.parsedSources.set(id, source);
    this.#script_id += 1;
  }
  // #endregion

  #breakpoints = new Set();
  addBreakpoint(breakpoint) {
    this.#breakpoints.add(breakpoint);
  }

  // #region side-effect free evaluator
  #debugger_previewing = false;
  #debugger_objectsCreatedDuringPreview = new Set();
  get debugger_isPreviewing() {
    return this.#debugger_previewing;
  }
  get debugger_cannotPreview() {
    if (this.#debugger_previewing) {
      /* X */
      let _temp4 = Construct(this.currentRealmRecord.Intrinsics['%EvalError%'], [Value('Preview evaluator cannot evaluate side-effecting code')]);
      /* node:coverage ignore next */
      if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! Construct(this.currentRealmRecord.Intrinsics['%EvalError%'], [Value('Preview evaluator cannot evaluate side-effecting code')]) returned an abrupt completion", {
        cause: _temp4
      });
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      return ThrowCompletion(_temp4);
    }
    return undefined;
  }
  debugger_tryTouchDuringPreview(object) {
    if (this.#debugger_previewing && !this.#debugger_objectsCreatedDuringPreview.has(object)) {
      return this.debugger_cannotPreview;
    }
    return undefined;
  }
  debugger_markObjectCreated(object) {
    if (!this.#debugger_previewing) {
      return;
    }
    this.#debugger_objectsCreatedDuringPreview.add(object);
  }
  debugger_scopePreview(cb) {
    if (!cb) {
      const old = this.#debugger_previewing;
      this.#debugger_previewing = true;
      return {
        [Symbol.dispose]: () => {
          this.#debugger_previewing = old;
          this.#debugger_objectsCreatedDuringPreview.clear();
        }
      };
    } else {
      const old = this.#debugger_previewing;
      this.#debugger_previewing = true;
      try {
        const res = cb();
        return res;
      } finally {
        this.#debugger_previewing = old;
        if (!old) {
          this.#debugger_objectsCreatedDuringPreview.clear();
        }
      }
    }
  }
  // #endregion
}

// https://tc39.es/ecma262/#sec-IncrementModuleAsyncEvaluationCount
function IncrementModuleAsyncEvaluationCount() {
  const AR = surroundingAgent.AgentRecord;
  const count = AR.ModuleAsyncEvaluationCount;
  AR.ModuleAsyncEvaluationCount = count + 1;
  return count;
}
IncrementModuleAsyncEvaluationCount.section = 'https://tc39.es/ecma262/#sec-IncrementModuleAsyncEvaluationCount';
let surroundingAgent;
function setSurroundingAgent(a) {
  surroundingAgent = a;
}

/** https://tc39.es/ecma262/#sec-execution-contexts */
class ExecutionContext {
  codeEvaluationState;
  Function = Value.null;
  Generator;
  ScriptOrModule = Value.null;
  VariableEnvironment;
  LexicalEnvironment;
  PrivateEnvironment = Value.null;
  HostDefined;

  // NON-SPEC
  callSite = new CallSite(this);
  promiseCapability;
  poppedForTailCall = false;
  Realm;
  copy() {
    const e = new ExecutionContext();
    e.codeEvaluationState = this.codeEvaluationState;
    e.Function = this.Function;
    e.Realm = this.Realm;
    e.ScriptOrModule = this.ScriptOrModule;
    e.VariableEnvironment = this.VariableEnvironment;
    e.LexicalEnvironment = this.LexicalEnvironment;
    e.PrivateEnvironment = this.PrivateEnvironment;
    e.callSite = this.callSite.clone(e);
    e.promiseCapability = this.promiseCapability;
    return e;
  }

  // NON-SPEC
  mark(m) {
    m(this.Function);
    m(this.Realm);
    m(this.ScriptOrModule);
    m(this.VariableEnvironment);
    m(this.LexicalEnvironment);
    m(this.PrivateEnvironment);
    m(this.promiseCapability);
  }
}

/** https://tc39.es/ecma262/#sec-runtime-semantics-scriptevaluation */
function* ScriptEvaluation(scriptRecord) {
  const globalEnv = scriptRecord.Realm.GlobalEnv;
  const scriptContext = new ExecutionContext();
  scriptContext.Function = Value.null;
  scriptContext.Realm = scriptRecord.Realm;
  scriptContext.ScriptOrModule = scriptRecord;
  scriptContext.VariableEnvironment = globalEnv;
  scriptContext.LexicalEnvironment = globalEnv;
  scriptContext.PrivateEnvironment = Value.null;
  scriptContext.HostDefined = scriptRecord.HostDefined;
  // Suspend runningExecutionContext
  surroundingAgent.executionContextStack.push(scriptContext);
  const scriptBody = scriptRecord.ECMAScriptCode;
  let result = EnsureCompletion(yield* GlobalDeclarationInstantiation(scriptBody, globalEnv));
  if (result.Type === 'normal') {
    result = EnsureCompletion(yield* Evaluate(scriptBody));
    if (result.Type === 'normal' && !result.Value) {
      result = NormalCompletion(Value.undefined);
    }
  }

  // Suspend scriptCtx
  surroundingAgent.executionContextStack.pop(scriptContext);
  // Resume(surroundingAgent.runningExecutionContext);

  return result;
}
ScriptEvaluation.section = 'https://tc39.es/ecma262/#sec-runtime-semantics-scriptevaluation';
/** https://tc39.es/ecma262/#sec-hostenqueuepromisejob */
function HostEnqueuePromiseJob(job, _realm) {
  if (surroundingAgent.debugger_isPreviewing) {
    return;
  }
  surroundingAgent.queueJob('PromiseJobs', job);
}
HostEnqueuePromiseJob.section = 'https://tc39.es/ecma262/#sec-hostenqueuepromisejob';
/** https://tc39.es/ecma262/#sec-agentsignifier */
function AgentSignifier() {
  // 1. Let AR be the Agent Record of the surrounding agent.
  const AR = surroundingAgent.AgentRecord;
  // 2. Return AR.[[Signifier]].
  return AR.Signifier;
}
AgentSignifier.section = 'https://tc39.es/ecma262/#sec-agentsignifier';
function HostEnsureCanCompileStrings(callerRealm, calleeRealm) {
  if (surroundingAgent.hostDefinedOptions.ensureCanCompileStrings !== undefined) {
    /* ReturnIfAbrupt */
    let _temp5 = surroundingAgent.hostDefinedOptions.ensureCanCompileStrings(callerRealm, calleeRealm);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  }
  return NormalCompletion(undefined);
}
function HostPromiseRejectionTracker(promise, operation) {
  if (surroundingAgent.debugger_isPreviewing) {
    return;
  }
  const realm = surroundingAgent.currentRealmRecord;
  if (realm && realm.HostDefined.promiseRejectionTracker) {
    /* X */
    let _temp6 = realm.HostDefined.promiseRejectionTracker(promise, operation);
    /* node:coverage ignore next */
    if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! realm.HostDefined.promiseRejectionTracker(promise, operation) returned an abrupt completion", {
      cause: _temp6
    });
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  }
}
function HostHasSourceTextAvailable(func) {
  if (surroundingAgent.hostDefinedOptions.hasSourceTextAvailable) {
    /* X */
    let _temp7 = surroundingAgent.hostDefinedOptions.hasSourceTextAvailable(func);
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! surroundingAgent.hostDefinedOptions.hasSourceTextAvailable(func) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    return _temp7;
  }
  return Value.true;
}
function HostGetSupportedImportAttributes() {
  if (surroundingAgent.hostDefinedOptions.supportedImportAttributes) {
    return surroundingAgent.hostDefinedOptions.supportedImportAttributes;
  }
  return [];
}

// #sec-HostLoadImportedModule
function HostLoadImportedModule(referrer, moduleRequest, hostDefined, payload) {
  if (surroundingAgent.hostDefinedOptions.loadImportedModule) {
    const executionContext = surroundingAgent.runningExecutionContext;
    let result;
    let sync = true;
    const attributes = new Map(moduleRequest.Attributes.map(({
      Key,
      Value
    }) => [Key.stringValue(), Value.stringValue()]));
    surroundingAgent.hostDefinedOptions.loadImportedModule(referrer, moduleRequest.Specifier.stringValue(), attributes, hostDefined, res => {
      result = res;
      if (!sync) {
        // If this callback has been called asynchronously, restore the correct execution context and enqueue a job.
        surroundingAgent.executionContextStack.push(executionContext);
        surroundingAgent.queueJob('FinishLoadingImportedModule', () => {
          result = EnsureCompletion(result);
          Assert(!!result && (result.Type === 'normal' || result.Type === 'throw'), "!!result && (result.Type === 'normal' || result.Type === 'throw')");
          FinishLoadingImportedModule(referrer, moduleRequest, result, payload);
        });
        surroundingAgent.executionContextStack.pop(executionContext);
        runJobQueue();
      }
    });
    sync = false;
    if (result !== undefined) {
      result = EnsureCompletion(result);
      Assert(result.Type === 'normal' || result.Type === 'throw', "result.Type === 'normal' || result.Type === 'throw'");
      FinishLoadingImportedModule(referrer, moduleRequest, result, payload);
    }
  } else {
    FinishLoadingImportedModule(referrer, moduleRequest, surroundingAgent.Throw('Error', 'CouldNotResolveModule', moduleRequest.Specifier), payload);
  }
}
HostLoadImportedModule.section = 'https://tc39.es/ecma262/#sec-HostLoadImportedModule';
/** https://tc39.es/ecma262/#sec-hostgetimportmetaproperties */
function HostGetImportMetaProperties(moduleRecord) {
  const realm = surroundingAgent.currentRealmRecord;
  if (realm.HostDefined.getImportMetaProperties) {
    /* X */
    let _temp8 = realm.HostDefined.getImportMetaProperties(moduleRecord.HostDefined.public);
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! realm.HostDefined.getImportMetaProperties(moduleRecord.HostDefined.public) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    return _temp8;
  }
  return [];
}
HostGetImportMetaProperties.section = 'https://tc39.es/ecma262/#sec-hostgetimportmetaproperties';
/** https://tc39.es/ecma262/#sec-hostfinalizeimportmeta */
function HostFinalizeImportMeta(importMeta, moduleRecord) {
  const realm = surroundingAgent.currentRealmRecord;
  if (realm.HostDefined.finalizeImportMeta) {
    /* X */
    let _temp9 = realm.HostDefined.finalizeImportMeta(importMeta, moduleRecord.HostDefined.public);
    /* node:coverage ignore next */
    if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! realm.HostDefined.finalizeImportMeta(importMeta, moduleRecord.HostDefined.public) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    return _temp9;
  }
  return Value.undefined;
}
HostFinalizeImportMeta.section = 'https://tc39.es/ecma262/#sec-hostfinalizeimportmeta';
/** https://tc39.es/ecma262/#sec-host-cleanup-finalization-registry */
function HostEnqueueFinalizationRegistryCleanupJob(fg) {
  if (surroundingAgent.hostDefinedOptions.cleanupFinalizationRegistry !== undefined) {
    /* ReturnIfAbrupt */
    let _temp10 = surroundingAgent.hostDefinedOptions.cleanupFinalizationRegistry(fg);
    /* node:coverage ignore next */
    if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) return _temp10;
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  } else {
    if (!surroundingAgent.scheduledForCleanup.has(fg)) {
      surroundingAgent.scheduledForCleanup.add(fg);
      surroundingAgent.queueJob('FinalizationCleanup', () => {
        surroundingAgent.scheduledForCleanup.delete(fg);
        // TODO: remove skipDebugger
        skipDebugger(CleanupFinalizationRegistry(fg));
      });
    }
  }
  return NormalCompletion(undefined);
}
HostEnqueueFinalizationRegistryCleanupJob.section = 'https://tc39.es/ecma262/#sec-host-cleanup-finalization-registry';
/** https://tc39.es/ecma262/#sec-hostmakejobcallback */
function HostMakeJobCallback(callback) {
  // 1. Assert: IsCallable(callback) is true.
  Assert(IsCallable(callback), "IsCallable(callback)");
  // 2. Return the JobCallback Record { [[Callback]]: callback, [[HostDefined]]: empty }.
  return {
    Callback: callback,
    HostDefined: undefined
  };
}
HostMakeJobCallback.section = 'https://tc39.es/ecma262/#sec-hostmakejobcallback';
/** https://tc39.es/ecma262/#sec-hostcalljobcallback */
function* HostCallJobCallback(jobCallback, V, argumentsList) {
  // 1. Assert: IsCallable(jobCallback.[[Callback]]) is true.
  Assert(IsCallable(jobCallback.Callback), "IsCallable(jobCallback.Callback)");
  // 1. Return ? Call(jobCallback.[[Callback]], V, argumentsList).
  return yield* Call(jobCallback.Callback, V, argumentsList);
}
HostCallJobCallback.section = 'https://tc39.es/ecma262/#sec-hostcalljobcallback';

var _CompletionImpl2;
let _initClass, _initClass2, _initClass3, _initClass4;
let createNormalCompletion;
let createBreakCompletion;
let createContinueCompletion;
let createReturnCompletion;
let createThrowCompletion;
let _CompletionImpl;
new class extends _identity {
  static [class CompletionImpl {
    static {
      [_CompletionImpl, _initClass] = _applyDecs2311(this, [callable((_target, _thisArg, [completionRecord]) => {
        // 1. Assert: completionRecord is a Completion Record.
        Assert(completionRecord instanceof Completion, "completionRecord instanceof Completion");
        // 2. Return completionRecord as the Completion Record of this abstract operation.
        return completionRecord;
      })], []).c;
    }
    Value;
    Target;
    constructor(init) {
      if (new.target === _CompletionImpl) {
        switch (init.Type) {
          case 'normal':
            return createNormalCompletion(init);
          case 'break':
            return createBreakCompletion(init);
          case 'continue':
            return createContinueCompletion(init);
          case 'return':
            return createReturnCompletion(init);
          case 'throw':
            return createThrowCompletion(init);
          /* node:coverage ignore next */default:
            /* node:coverage ignore next */
            throw new OutOfRange$1('new Completion', init);
        }
      }
      const {
        Type,
        Value,
        Target
      } = init;
      Assert(new.target.prototype.Type === Type, "new.target.prototype.Type === Type");
      this.Value = Value;
      this.Target = Target;
    }

    // NON-SPEC
    mark(m) {
      m(this.Value);
    }
  }];
  constructor() {
    super(_CompletionImpl), (() => {
      Object.defineProperty(this, 'name', {
        value: 'Completion'
      });
    })(), _initClass();
  }
}();
/** https://tc39.es/ecma262/#sec-completion-record-specification-type */
/**
 * A NON-SPEC shorthand to notate "returns either a normal completion containing an ECMAScript language value or a throw completion".
 */
// export type ValueEvaluator<T extends Value = Value> = T | NormalCompletion<T> | ThrowCompletion;
/**
 * A NON-SPEC shorthand to notate "returns either a normal completion containing ... or a throw completion".
 *
 * If the T is an ECMAScript language value, use ExpressionCompletion<T>.
 */
/** https://tc39.es/ecma262/#sec-completion-ao */
const Completion = _CompletionImpl;
let _NormalCompletionImpl;
new class extends _identity {
  static [class NormalCompletionImpl extends (_CompletionImpl2 = _CompletionImpl) {
    static {
      [_NormalCompletionImpl, _initClass2] = _applyDecs2311(this, [callable((_target, _thisArg, [value]) => {
        // eslint-disable-line arrow-body-style -- Preserve algorithm steps comments
        // 1. Return Completion { [[Type]]: normal, [[Value]]: value, [[Target]]: empty }.
        return new Completion({
          Type: 'normal',
          Value: value,
          Target: undefined
        });
      })], [], 0, void 0, _CompletionImpl2).c;
    }
    constructor(init) {
      // eslint-disable-line no-useless-constructor -- Sets privacy for constructor
      super(init);
    }
  }];
  constructor() {
    super(_NormalCompletionImpl), (() => {
      Object.defineProperty(this, 'name', {
        value: 'NormalCompletion'
      });
      Object.defineProperty(this.prototype, 'Type', {
        value: 'normal'
      });
      createNormalCompletion = init => new _NormalCompletionImpl(init);
    })(), _initClass2();
  }
}();
/** https://tc39.es/ecma262/#sec-completion-record-specification-type */
/** https://tc39.es/ecma262/#sec-normalcompletion */
const NormalCompletion = _NormalCompletionImpl;

/** https://tc39.es/ecma262/#sec-completion-record-specification-type */

/** https://tc39.es/ecma262/#sec-completion-record-specification-type */
const AbruptCompletion = (() => {
  class AbruptCompletion extends _CompletionImpl {
    constructor(init) {
      // eslint-disable-line no-useless-constructor -- Sets privacy for constructor
      super(init);
    }
    static {
      Object.defineProperty(this, 'name', {
        value: 'AbruptCompletion'
      });
    }
  }
  return AbruptCompletion;
})();

/** https://tc39.es/ecma262/#sec-completion-record-specification-type */
class BreakCompletion extends AbruptCompletion {
  constructor(init) {
    // eslint-disable-line no-useless-constructor -- Sets privacy for constructor
    super(init);
  }
  static {
    Object.defineProperty(this, 'name', {
      value: 'BreakCompletion'
    });
    Object.defineProperty(this.prototype, 'Type', {
      value: 'break'
    });
    createBreakCompletion = init => new BreakCompletion(init);
  }
}

/** https://tc39.es/ecma262/#sec-completion-record-specification-type */
class ContinueCompletion extends AbruptCompletion {
  constructor(init) {
    // eslint-disable-line no-useless-constructor -- Sets privacy for constructor
    super(init);
  }
  static {
    Object.defineProperty(this, 'name', {
      value: 'ContinueCompletion'
    });
    Object.defineProperty(this.prototype, 'Type', {
      value: 'continue'
    });
    createContinueCompletion = init => new ContinueCompletion(init);
  }
}
let _ReturnCompletion_;
new class extends _identity {
  static [class ReturnCompletion_ extends AbruptCompletion {
    static {
      [_ReturnCompletion_, _initClass3] = _applyDecs2311(this, [callable((_target, _thisArg, [value]) => {
        Assert(value instanceof Value, "value instanceof Value");
        // 1. Return Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
        return new Completion({
          Type: 'return',
          Value: value,
          Target: undefined
        });
      })], [], 0, void 0, AbruptCompletion).c;
    }
    constructor(init) {
      // eslint-disable-line no-useless-constructor -- Sets privacy for constructor
      super(init);
    }
  }];
  constructor() {
    super(_ReturnCompletion_), (() => {
      Object.defineProperty(this, 'name', {
        value: 'ReturnCompletion'
      });
      Object.defineProperty(this.prototype, 'Type', {
        value: 'return'
      });
      createReturnCompletion = init => new ReturnCompletion(init);
    })(), _initClass3();
  }
}();
/** https://tc39.es/ecma262/#sec-completion-record-specification-type */
/** https://tc39.es/ecma262/#sec-throwcompletion */
const ReturnCompletion = _ReturnCompletion_;
let _ThrowCompletion_;
new class extends _identity {
  static [class ThrowCompletion_ extends AbruptCompletion {
    static {
      [_ThrowCompletion_, _initClass4] = _applyDecs2311(this, [callable((_target, _thisArg, [value]) => {
        Assert(value instanceof Value, "value instanceof Value");
        // 1. Return Completion { [[Type]]: throw, [[Value]]: value, [[Target]]: empty }.
        return new Completion({
          Type: 'throw',
          Value: value,
          Target: undefined
        });
      })], [], 0, void 0, AbruptCompletion).c;
    }
    stack = undefined;
    constructor(init) {
      // eslint-disable-line no-useless-constructor -- Sets privacy for constructor
      super(init);
    }
  }];
  constructor() {
    super(_ThrowCompletion_), (() => {
      Object.defineProperty(this, 'name', {
        value: 'ThrowCompletion'
      });
      Object.defineProperty(this.prototype, 'Type', {
        value: 'throw'
      });
      createThrowCompletion = init => new _ThrowCompletion_(init);
    })(), _initClass4();
  }
}();
/** https://tc39.es/ecma262/#sec-completion-record-specification-type */
/** https://tc39.es/ecma262/#sec-throwcompletion */
const ThrowCompletion = _ThrowCompletion_;

/** https://tc39.es/ecma262/#sec-updateempty */

/** https://tc39.es/ecma262/#sec-updateempty */

function UpdateEmpty(completionRecord, value) {
  // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
  Assert(!(completionRecord.Type === 'return' || completionRecord.Type === 'throw') || completionRecord.Value !== undefined, "!(completionRecord.Type === 'return' || completionRecord.Type === 'throw') || completionRecord.Value !== undefined");
  // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
  if (completionRecord.Value !== undefined) {
    return Completion(completionRecord);
  }
  // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
  return new _CompletionImpl({
    Type: completionRecord.Type,
    Value: value,
    Target: completionRecord.Target
  }); // NOTE: unsound cast
}

/** https://tc39.es/ecma262/#sec-returnifabrupt */

/**
 * https://tc39.es/ecma262/#sec-returnifabrupt
 * https://tc39.es/ecma262/#sec-returnifabrupt-shorthands ? OperationName()
 */
function ReturnIfAbrupt(_completion) {
  /* node:coverage ignore next */
  throw new TypeError('ReturnIfAbrupt requires build');
}
ReturnIfAbrupt.section = 'https://tc39.es/ecma262/#sec-returnifabrupt';
function ReturnIfAbruptRuntime(completion) {
  /* node:coverage ignore next 3 */
  if (typeof completion === 'object' && completion && 'next' in completion) {
    throw new TypeError('Forgot to yield* on the completion.');
  }
  const c = EnsureCompletion(completion);
  if (c.Type === 'normal') {
    return c.Value;
  }
  throw c;
}

/** https://tc39.es/ecma262/#sec-returnifabrupt-shorthands ! OperationName() */
function X(_completion) {
  /* node:coverage ignore next */
  throw new TypeError('X() requires build');
}
X.section = 'https://tc39.es/ecma262/#sec-returnifabrupt-shorthands';
function unwrapCompletion(completion) {
  /* node:coverage ignore next 3 */
  if (typeof completion === 'object' && completion && 'next' in completion) {
    completion = skipDebugger(completion);
  }
  const c = EnsureCompletion(completion);
  if (c instanceof NormalCompletion) {
    return c.Value;
  }
  /* node:coverage ignore next */
  throw new Assert.Error('Unexpected AbruptCompletion.', {
    cause: c
  });
}

/** https://tc39.es/ecma262/#sec-ifabruptcloseiterator */
function IfAbruptCloseIterator(_value, _iteratorRecord) {
  /* node:coverage ignore next */
  throw new TypeError('IfAbruptCloseIterator() requires build');
}
IfAbruptCloseIterator.section = 'https://tc39.es/ecma262/#sec-ifabruptcloseiterator';
/** https://tc39.es/ecma262/#sec-ifabruptrejectpromise */
function IfAbruptRejectPromise(_value, _capability) {
  /* node:coverage ignore next */
  throw new TypeError('IfAbruptRejectPromise requires build');
}
IfAbruptRejectPromise.section = 'https://tc39.es/ecma262/#sec-ifabruptrejectpromise';
/**
 * This is a util for code that cannot use Q() or X() marco to emulate this behaviour.
 *
 * @example
 * import { evalQ } from '...'
 * evalQ((Q) => {
 *     let val = Q(operation);
 * });
 */
function evalQ(callback) {
  try {
    const result = callback(ReturnIfAbruptRuntime, unwrapCompletion);
    if (result instanceof Promise) {
      return result.then(EnsureCompletion, error => {
        if (error instanceof ThrowCompletion) {
          return error;
        }
        throw error;
      });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return EnsureCompletion(result);
  } catch (error) {
    if (error instanceof ThrowCompletion) {
      return error;
    }
    // a real error
    throw error;
  }
}

// Distribute over `T`s that are `Completion`s, but don't distribute over `T`s that aren't `Completion`s

/** https://tc39.es/ecma262/#sec-implicit-normal-completion */

function EnsureCompletion(val) {
  if (val instanceof Completion) {
    return val;
  }
  return NormalCompletion(val);
}
function ValueOfNormalCompletion(value) {
  return value instanceof NormalCompletion ? value.Value : value;
}
function* Await(value) {
  // 1. Let asyncContext be the running execution context.
  const asyncContext = surroundingAgent.runningExecutionContext;
  // 2. Let promise be ? PromiseResolve(%Promise%, value).
  /* ReturnIfAbrupt */
  let _temp = yield* PromiseResolve(surroundingAgent.intrinsic('%Promise%'), value);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const promise = _temp;
  // 3. Let fulfilledClosure be a new Abstract Closure with parameters (value) that captures asyncContext and performs the following steps when called:
  const fulfilledClosure = function* fulfilledClosure([valueInner = Value.undefined]) {
    // a. Let prevContext be the running execution context.
    const prevContext = surroundingAgent.runningExecutionContext;
    // b. Suspend prevContext.
    // c. Push asyncContext onto the execution context stack; asyncContext is now the running execution context.
    surroundingAgent.executionContextStack.push(asyncContext);
    // d. Resume the suspended evaluation of asyncContext using NormalCompletion(value) as the result of the operation that suspended it.
    yield* resume(asyncContext, {
      type: 'await-resume',
      value: NormalCompletion(valueInner)
    });
    // e. Assert: When we reach this step, asyncContext has already been removed from the execution context stack and prevContext is the currently running execution context.
    Assert(surroundingAgent.runningExecutionContext === prevContext, "surroundingAgent.runningExecutionContext === prevContext");
    // f. Return undefined.
    return Value.undefined;
  };
  // 4. Let onFulfilled be ! CreateBuiltinFunction(fulfilledClosure, 1, "", « »).
  /* X */
  let _temp2 = CreateBuiltinFunction(fulfilledClosure, 1, Value(''), []);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(fulfilledClosure, 1, Value(''), []) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const onFulfilled = _temp2;
  // @ts-expect-error TODO(ts): CreateBuiltinFunction should return a specalized type FunctionObjectValue that has a kAsyncContext on it.
  onFulfilled[kAsyncContext] = asyncContext;
  // 5. Let rejectedClosure be a new Abstract Closure with parameters (reason) that captures asyncContext and performs the following steps when called:
  const rejectedClosure = function* rejectedClosure([reason = Value.undefined]) {
    // a. Let prevContext be the running execution context.
    const prevContext = surroundingAgent.runningExecutionContext;
    // b. Suspend prevContext.
    // c. Push asyncContext onto the execution context stack; asyncContext is now the running execution context.
    surroundingAgent.executionContextStack.push(asyncContext);
    // d. Resume the suspended evaluation of asyncContext using ThrowCompletion(reason) as the result of the operation that suspended it.
    yield* resume(asyncContext, {
      type: 'await-resume',
      value: ThrowCompletion(reason)
    });
    // e. Assert: When we reach this step, asyncContext has already been removed from the execution context stack and prevContext is the currently running execution context.
    Assert(surroundingAgent.runningExecutionContext === prevContext, "surroundingAgent.runningExecutionContext === prevContext");
    // f. Return undefined.
    return Value.undefined;
  };
  // 6. Let onRejected be ! CreateBuiltinFunction(rejectedClosure, 1, "", « »).
  /* X */
  let _temp3 = CreateBuiltinFunction(rejectedClosure, 1, Value(''), []);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(rejectedClosure, 1, Value(''), []) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const onRejected = _temp3;
  // @ts-expect-error TODO(ts): CreateBuiltinFunction should return a specalized type FunctionObjectValue that has a kAsyncContext on it.
  onRejected[kAsyncContext] = asyncContext;
  // 7. Perform ! PerformPromiseThen(promise, onFulfilled, onRejected).
  /* X */
  let _temp4 = PerformPromiseThen(promise, onFulfilled, onRejected);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! PerformPromiseThen(promise, onFulfilled, onRejected) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 8. Remove asyncContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
  surroundingAgent.executionContextStack.pop(asyncContext);
  // 9. Set the code evaluation state of asyncContext such that when evaluation is resumed with a Completion completion, the following steps of the algorithm that invoked Await will be performed, with completion available.
  const completion = yield {
    type: 'await'
  };
  Assert(completion.type === 'await-resume', "completion.type === 'await-resume'");
  // 10. Return.
  return completion.value;
  // 11. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of asyncContext.
}

const typedArrayInfoByName = {
  Int8Array: {
    IntrinsicName: '%Int8Array%',
    ElementType: 'Int8',
    ElementSize: 1,
    ConversionOperation: ToInt8
  },
  Uint8Array: {
    IntrinsicName: '%Uint8Array%',
    ElementType: 'Uint8',
    ElementSize: 1,
    ConversionOperation: ToUint8
  },
  Uint8ClampedArray: {
    IntrinsicName: '%Uint8ClampedArray%',
    ElementType: 'Uint8C',
    ElementSize: 1,
    ConversionOperation: ToUint8Clamp
  },
  Int16Array: {
    IntrinsicName: '%Int16Array%',
    ElementType: 'Int16',
    ElementSize: 2,
    ConversionOperation: ToInt16
  },
  Uint16Array: {
    IntrinsicName: '%Uint16Array%',
    ElementType: 'Uint16',
    ElementSize: 2,
    ConversionOperation: ToUint16
  },
  Int32Array: {
    IntrinsicName: '%Int32Array%',
    ElementType: 'Int32',
    ElementSize: 4,
    ConversionOperation: ToInt32
  },
  Uint32Array: {
    IntrinsicName: '%Uint32Array%',
    ElementType: 'Uint32',
    ElementSize: 4,
    ConversionOperation: ToUint32
  },
  BigInt64Array: {
    IntrinsicName: '%BigInt64Array%',
    ElementType: 'BigInt64',
    ElementSize: 8,
    ConversionOperation: ToBigInt64
  },
  BigUint64Array: {
    IntrinsicName: '%BigUint64Array%',
    ElementType: 'BigUint64',
    ElementSize: 8,
    ConversionOperation: ToBigUint64
  },
  Float32Array: {
    IntrinsicName: '%Float32Array%',
    ElementType: 'Float32',
    ElementSize: 4,
    ConversionOperation: undefined
  },
  Float64Array: {
    IntrinsicName: '%Float64Array%',
    ElementType: 'Float64',
    ElementSize: 8,
    ConversionOperation: undefined
  }
};
const typedArrayInfoByType = {
  Int8: typedArrayInfoByName.Int8Array,
  Uint8: typedArrayInfoByName.Uint8Array,
  Uint8C: typedArrayInfoByName.Uint8ClampedArray,
  Int16: typedArrayInfoByName.Int16Array,
  Uint16: typedArrayInfoByName.Uint16Array,
  Int32: typedArrayInfoByName.Int32Array,
  Uint32: typedArrayInfoByName.Uint32Array,
  BigInt64: typedArrayInfoByName.BigInt64Array,
  BigUint64: typedArrayInfoByName.BigUint64Array,
  Float32: typedArrayInfoByName.Float32Array,
  Float64: typedArrayInfoByName.Float64Array
};
function isTypedArrayObject(value) {
  return 'TypedArrayName' in value;
}

/** https://tc39.es/ecma262/#typedarray-species-create */
function* TypedArraySpeciesCreate(exemplar, argumentList) {
  // 1. Assert: exemplar is an Object that has [[TypedArrayName]] and [[ContentType]] internal slots.
  Assert(exemplar instanceof ObjectValue && 'TypedArrayName' in exemplar && 'ContentType' in exemplar, "exemplar instanceof ObjectValue\n    && 'TypedArrayName' in exemplar\n    && 'ContentType' in exemplar");
  // 2. Let defaultConstructor be the intrinsic object listed in column one of Table 61 for exemplar.[[TypedArrayName]].
  const defaultConstructor = surroundingAgent.intrinsic(typedArrayInfoByName[exemplar.TypedArrayName.stringValue()].IntrinsicName);
  // 3. Let constructor be ? SpeciesConstructor(exemplar, defaultConstructor).
  /* ReturnIfAbrupt */
  let _temp = yield* SpeciesConstructor(exemplar, defaultConstructor);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const constructor = _temp;
  // 4. Let result be ? TypedArrayCreate(constructor, argumentList).
  /* ReturnIfAbrupt */
  let _temp2 = yield* TypedArrayCreateFromConstructor(constructor, argumentList);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const result = _temp2;
  // 5. Assert: result has [[TypedArrayName]] and [[ContentType]] internal slots.
  Assert('TypedArrayName' in result && 'ContentType' in result, "'TypedArrayName' in result && 'ContentType' in result");
  // 6. If result.[[ContentType]] is not equal to exemplar.[[ContentType]], throw a TypeError exception.
  if (result.ContentType !== exemplar.ContentType) {
    return surroundingAgent.Throw('TypeError', 'BufferContentTypeMismatch');
  }
  // 7. Return result.
  return result;
}

/** https://tc39.es/ecma262/#sec-typedarraycreatefromconstructor */
function* TypedArrayCreateFromConstructor(constructor, argumentList) {
  /* ReturnIfAbrupt */
  let _temp3 = yield* Construct(constructor, argumentList);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const newTypedArray = _temp3;
  /* ReturnIfAbrupt */
  let _temp4 = ValidateTypedArray(newTypedArray);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const taRecord = _temp4;
  if (argumentList.length === 1 && argumentList[0] instanceof NumberValue) {
    if (IsTypedArrayOutOfBounds(taRecord)) {
      // TODO: error message
      return surroundingAgent.Throw('TypeError', 'Raw', 'TypedArrayCreateFromConstructor:IsTypedArrayOutOfBounds');
    }
    const length = TypedArrayLength(taRecord);
    if (length < R(argumentList[0])) {
      return surroundingAgent.Throw('TypeError', 'TypedArrayTooSmall');
    }
  }
  return newTypedArray;
}
TypedArrayCreateFromConstructor.section = 'https://tc39.es/ecma262/#sec-typedarraycreatefromconstructor';
/** https://tc39.es/ecma262/#sec-typedarray-create-same-type */
function* TypedArrayCreateSameType(exemplar, argumentList) {
  const constructor = surroundingAgent.intrinsic(typedArrayInfoByName[exemplar.TypedArrayName.stringValue()].IntrinsicName);
  /* ReturnIfAbrupt */
  let _temp5 = yield* TypedArrayCreateFromConstructor(constructor, argumentList);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const result = _temp5;
  Assert('TypedArrayName' in result && 'ContentType' in result, "'TypedArrayName' in result && 'ContentType' in result");
  Assert(result.ContentType === exemplar.ContentType, "result.ContentType === exemplar.ContentType");
  return result;
}
TypedArrayCreateSameType.section = 'https://tc39.es/ecma262/#sec-typedarray-create-same-type';
/** https://tc39.es/ecma262/#sec-validatetypedarray */
function ValidateTypedArray(O, order) {
  /* ReturnIfAbrupt */
  let _temp6 = RequireInternalSlot(O, 'TypedArrayName');
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOutOfBounds');
  }
  return taRecord;
}
ValidateTypedArray.section = 'https://tc39.es/ecma262/#sec-validatetypedarray';
/** https://tc39.es/ecma262/#sec-typedarrayelementsize */
function TypedArrayElementSize(O) {
  const type = O.TypedArrayName.stringValue();
  return typedArrayInfoByName[type].ElementSize;
}
TypedArrayElementSize.section = 'https://tc39.es/ecma262/#sec-typedarrayelementsize';
/** https://tc39.es/ecma262/#sec-typedarrayelementtype */
function TypedArrayElementType(O) {
  const type = O.TypedArrayName.stringValue();
  return typedArrayInfoByName[type].ElementType;
}
TypedArrayElementType.section = 'https://tc39.es/ecma262/#sec-typedarrayelementtype';
/** https://tc39.es/ecma262/#sec-comparetypedarrayelements */
function* CompareTypedArrayElements(x, y, comparator) {
  Assert(x instanceof NumberValue && y instanceof NumberValue || x instanceof BigIntValue && y instanceof BigIntValue, "(x instanceof NumberValue && y instanceof NumberValue)\n    || (x instanceof BigIntValue && y instanceof BigIntValue)");
  if (!(comparator instanceof UndefinedValue)) {
    /* ReturnIfAbrupt */
    let _temp8 = yield* Call(comparator, Value.undefined, [x, y]);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    /* ReturnIfAbrupt */
    let _temp7 = yield* ToNumber(_temp8);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const v = _temp7;
    if (v.isNaN()) {
      return F(0);
    }
    return v;
  }
  if (x.isNaN() && y.isNaN()) {
    return F(0);
  }
  if (x.isNaN()) {
    return F(1);
  }
  if (y.isNaN()) {
    return F(-1);
  }
  if (x.value < y.value) {
    return F(-1);
  }
  if (x.value > y.value) {
    return F(1);
  }
  if (Object.is(-0, x.value) && Object.is(0, y.value)) {
    return F(-1);
  }
  if (Object.is(0, x.value) && Object.is(-0, y.value)) {
    return F(1);
  }
  return F(0);
}
CompareTypedArrayElements.section = 'https://tc39.es/ecma262/#sec-comparetypedarrayelements';
/** https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object */
function TypedArrayConstructor() {
  // 1. Throw a TypeError exception.
  return surroundingAgent.Throw('TypeError', 'NotAConstructor', this);
}
TypedArrayConstructor.section = 'https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object';
/** https://tc39.es/ecma262/#sec-allocatetypedarray */
function* AllocateTypedArray(constructorName, newTarget, defaultProto, length) {
  /* ReturnIfAbrupt */
  let _temp9 = yield* GetPrototypeFromConstructor(newTarget, defaultProto);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  // 1. Let proto be ? GetPrototypeFromConstructor(newTarget, defaultProto).
  const proto = _temp9;
  // 2. Let obj be TypedArrayCreate(proto).
  const obj = TypedArrayCreate(proto);
  // 3. Assert: obj.[[ViewedArrayBuffer]] is undefined.
  Assert(obj.ViewedArrayBuffer === Value.undefined, "obj.ViewedArrayBuffer === Value.undefined");
  // 4. Set obj.[[TypedArrayName]] to constructorName.
  obj.TypedArrayName = constructorName;
  // 5. If constructorName is "BigInt64Array" or "BigUint64Array", set obj.[[ContentType]] to BigInt.
  // 6. Otherwise, set obj.[[ContentType]] to Number.
  if (constructorName.stringValue() === 'BigInt64Array' || constructorName.stringValue() === 'BigUint64Array') {
    obj.ContentType = 'BigInt';
  } else {
    obj.ContentType = 'Number';
  }
  // 7. If length is not present, then
  if (length === undefined) {
    // 1. Set obj.[[ByteLength]] to 0.
    obj.ByteLength = 0;
    // 1. Set obj.[[ByteOffset]] to 0.
    obj.ByteOffset = 0;
    // 1. Set obj.[[ArrayLength]] to 0.
    obj.ArrayLength = 0;
  } else {
    /* ReturnIfAbrupt */
    let _temp10 = yield* AllocateTypedArrayBuffer(obj, length);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) return _temp10;
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  }
  // 9. Return obj.
  return obj;
}
AllocateTypedArray.section = 'https://tc39.es/ecma262/#sec-allocatetypedarray';
/** https://tc39.es/ecma262/#sec-initializetypedarrayfromtypedarray */
function* InitializeTypedArrayFromTypedArray(O, srcArray) {
  const srcData = srcArray.ViewedArrayBuffer;
  const elementType = TypedArrayElementType(O);
  const elementSize = TypedArrayElementSize(O);
  const srcType = TypedArrayElementType(srcArray);
  const srcElementSize = TypedArrayElementSize(srcArray);
  const srcByteOffset = srcArray.ByteOffset;
  const srcRecord = MakeTypedArrayWithBufferWitnessRecord(srcArray);
  if (IsTypedArrayOutOfBounds(srcRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOutOfBounds');
  }
  const elementLength = TypedArrayLength(srcRecord);
  const byteLength = elementSize * elementLength;
  let data;
  if (elementType === srcType) {
    /* ReturnIfAbrupt */
    let _temp11 = yield* CloneArrayBuffer(srcData, srcByteOffset, byteLength);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) return _temp11;
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    data = _temp11;
  } else {
    /* ReturnIfAbrupt */
    let _temp12 = yield* AllocateArrayBuffer(surroundingAgent.intrinsic('%ArrayBuffer%'), byteLength);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) return _temp12;
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    data = _temp12;
    if (srcArray.ContentType !== O.ContentType) {
      return surroundingAgent.Throw('TypeError', 'BufferContentTypeMismatch');
    }
    let srcByteIndex = srcByteOffset;
    let targetByteIndex = 0;
    let count = elementLength;
    while (count > 0) {
      const value = GetValueFromBuffer(srcData, srcByteIndex, srcType);
      /* ReturnIfAbrupt */
      let _temp13 = yield* SetValueInBuffer(data, targetByteIndex, elementType, value);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      srcByteIndex += srcElementSize;
      targetByteIndex += elementSize;
      count -= 1;
    }
  }
  O.ViewedArrayBuffer = data;
  O.ByteLength = byteLength;
  O.ByteOffset = 0;
  O.ArrayLength = elementLength;
}
InitializeTypedArrayFromTypedArray.section = 'https://tc39.es/ecma262/#sec-initializetypedarrayfromtypedarray';
/** https://tc39.es/ecma262/#sec-initializetypedarrayfromarraybuffer */
function* InitializeTypedArrayFromArrayBuffer(O, buffer, byteOffset, length) {
  const elementSize = TypedArrayElementSize(O);
  /* ReturnIfAbrupt */
  let _temp14 = yield* ToIndex(byteOffset);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const offset = _temp14;
  if (offset % elementSize !== 0) {
    return surroundingAgent.Throw('RangeError', 'TypedArrayOffsetAlignment', offset, elementSize);
  }
  const bufferIsFixedLength = IsFixedLengthArrayBuffer(buffer);
  let newLength;
  if (length !== Value.undefined) {
    /* ReturnIfAbrupt */
    let _temp15 = yield* ToIndex(length);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) return _temp15;
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    newLength = _temp15;
  }
  if (IsDetachedBuffer(buffer) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }
  const bufferByteLength = ArrayBufferByteLength(buffer);
  if (length === Value.undefined && !bufferIsFixedLength) {
    if (offset > bufferByteLength) {
      return surroundingAgent.Throw('RangeError', 'TypedArrayCreationOOB');
    }
    O.ByteLength = 'auto';
    O.ArrayLength = 'auto';
  } else {
    let newByteLength;
    if (length === Value.undefined) {
      if (bufferByteLength % elementSize !== 0) {
        return surroundingAgent.Throw('RangeError', 'TypedArrayLengthAlignment', bufferByteLength, elementSize);
      }
      newByteLength = bufferByteLength - offset;
      if (newByteLength < 0) {
        return surroundingAgent.Throw('RangeError', 'TypedArrayCreationOOB');
      }
    } else {
      Assert(newLength !== undefined, "newLength !== undefined");
      newByteLength = newLength * elementSize;
      if (offset + newByteLength > bufferByteLength) {
        return surroundingAgent.Throw('RangeError', 'TypedArrayCreationOOB');
      }
    }
    O.ByteLength = newByteLength;
    O.ArrayLength = newByteLength / elementSize;
  }
  O.ViewedArrayBuffer = buffer;
  O.ByteOffset = offset;
}
InitializeTypedArrayFromArrayBuffer.section = 'https://tc39.es/ecma262/#sec-initializetypedarrayfromarraybuffer';
/** https://tc39.es/ecma262/#sec-initializetypedarrayfromlist */
function* InitializeTypedArrayFromList(O, value) {
  const len = value.length;
  /* ReturnIfAbrupt */
  let _temp16 = yield* AllocateTypedArrayBuffer(O, len);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  let k = 0;
  while (k < len) {
    /* X */
    let _temp17 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp17
    });
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    const Pk = _temp17;
    const kValue = value.shift();
    /* ReturnIfAbrupt */
    let _temp18 = yield* Set$1(O, Pk, kValue, Value.true);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) return _temp18;
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    k += 1;
  }
  Assert(value.length === 0, "value.length === 0");
}
InitializeTypedArrayFromList.section = 'https://tc39.es/ecma262/#sec-initializetypedarrayfromlist';
/** https://tc39.es/ecma262/#sec-initializetypedarrayfromarraylike */
function* InitializeTypedArrayFromArrayLike(O, arrayLike) {
  /* ReturnIfAbrupt */
  let _temp19 = yield* LengthOfArrayLike(arrayLike);
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) return _temp19;
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  const len = _temp19;
  /* ReturnIfAbrupt */
  let _temp20 = yield* AllocateTypedArrayBuffer(O, len);
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  let k = 0;
  while (k < len) {
    /* X */
    let _temp21 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) _temp21 = skipDebugger(_temp21);
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp21
    });
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    const Pk = _temp21;
    /* ReturnIfAbrupt */
    let _temp22 = yield* Get(arrayLike, Pk);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    const kValue = _temp22;
    /* ReturnIfAbrupt */
    let _temp23 = yield* Set$1(O, Pk, kValue, Value.true);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    k += 1;
  }
}
InitializeTypedArrayFromArrayLike.section = 'https://tc39.es/ecma262/#sec-initializetypedarrayfromarraylike';
/** https://tc39.es/ecma262/#sec-allocatetypedarraybuffer */
function* AllocateTypedArrayBuffer(O, length) {
  // 1. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
  Assert(O instanceof ObjectValue && 'ViewedArrayBuffer' in O, "O instanceof ObjectValue && 'ViewedArrayBuffer' in O");
  // 2. Assert: O.[[ViewedArrayBuffer]] is undefined.
  Assert(O.ViewedArrayBuffer === Value.undefined, "O.ViewedArrayBuffer === Value.undefined");
  // 3. Assert: length is a non-negative integer.
  Assert(isNonNegativeInteger(length), "isNonNegativeInteger(length)");
  // 4. Let constructorName be the String value of O.[[TypedArrayName]].
  const constructorName = O.TypedArrayName.stringValue();
  // 5. Let elementSize be the Element Size value specified in Table 61 for constructorName.
  const elementSize = typedArrayInfoByName[constructorName].ElementSize;
  // 6. Let byteLength be elementSize × length.
  const byteLength = elementSize * length;
  // 7. Let data be ? AllocateArrayBuffer(%ArrayBuffer%, byteLength).
  /* ReturnIfAbrupt */
  let _temp24 = yield* AllocateArrayBuffer(surroundingAgent.intrinsic('%ArrayBuffer%'), byteLength);
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) return _temp24;
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  const data = _temp24;
  // 8. Set O.[[ViewedArrayBuffer]] to data.
  O.ViewedArrayBuffer = data;
  O.ByteLength = byteLength;
  // 10. Set O.[[ByteOffset]] to 0.
  O.ByteOffset = 0;
  // 11. Set O.[[ArrayLength]] to length.
  O.ArrayLength = length;
  // 12. Return O.
  return O;
}
AllocateTypedArrayBuffer.section = 'https://tc39.es/ecma262/#sec-allocatetypedarraybuffer';
/** https://tc39.es/ecma262/#sec-%typedarray%.from */
function* TypedArray_from([source = Value.undefined, mapper = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  // 1. Let C be the this value.
  const C = thisValue;
  // 2. If IsConstructor(C) is false, throw a TypeError exception.
  if (!IsConstructor(C)) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', C);
  }
  // 3. If mapfn is undefined, let mapping be false.
  let mapping;
  if (mapper === Value.undefined) {
    mapping = false;
  } else {
    // a. If IsCallable(mapfn) is false, throw a TypeError exception.
    if (!IsCallable(mapper)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', mapper);
    }
    // b. Let mapping be true.
    mapping = true;
  }
  // 5. Let usingIterator be ? GetMethod(source, @@iterator).
  /* ReturnIfAbrupt */
  let _temp25 = yield* GetMethod(source, wellKnownSymbols.iterator);
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  const usingIterator = _temp25;
  // 6. If usingIterator is not undefined, then
  if (!(usingIterator instanceof UndefinedValue)) {
    /* ReturnIfAbrupt */
    let _temp31 = yield* GetIteratorFromMethod(source, usingIterator);
    /* node:coverage ignore next */
    if (_temp31 instanceof AbruptCompletion) return _temp31;
    /* node:coverage ignore next */
    if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
    /* ReturnIfAbrupt */
    let _temp26 = yield* IteratorToList(_temp31);
    /* node:coverage ignore next */
    if (_temp26 instanceof AbruptCompletion) return _temp26;
    /* node:coverage ignore next */
    if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
    const values = _temp26;
    const len = values.length;
    /* ReturnIfAbrupt */
    let _temp27 = yield* TypedArrayCreateFromConstructor(C, [F(len)]);
    /* node:coverage ignore next */
    if (_temp27 instanceof AbruptCompletion) return _temp27;
    /* node:coverage ignore next */
    if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
    const targetObj = _temp27;
    let k = 0;
    while (k < len) {
      /* X */
      let _temp28 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) _temp28 = skipDebugger(_temp28);
      /* node:coverage ignore next */
      if (_temp28 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp28
      });
      /* node:coverage ignore next */
      if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
      const Pk = _temp28;
      const kValue = values.shift();
      let mappedValue;
      if (mapping) {
        /* ReturnIfAbrupt */
        let _temp29 = yield* Call(mapper, thisArg, [kValue, F(k)]);
        /* node:coverage ignore next */
        if (_temp29 instanceof AbruptCompletion) return _temp29;
        /* node:coverage ignore next */
        if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
        mappedValue = _temp29;
      } else {
        mappedValue = kValue;
      }
      /* ReturnIfAbrupt */
      let _temp30 = yield* Set$1(targetObj, Pk, mappedValue, Value.true);
      /* node:coverage ignore next */
      if (_temp30 instanceof AbruptCompletion) return _temp30;
      /* node:coverage ignore next */
      if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
      k += 1;
    }
    Assert(values.length === 0, "values.length === 0");
    return targetObj;
  }
  // 7. NOTE: source is not an Iterable so assume it is already an array-like object.
  // 8. Let arrayLike be ! ToObject(source).
  /* X */
  let _temp32 = ToObject(source);
  /* node:coverage ignore next */
  if (_temp32 && typeof _temp32 === 'object' && 'next' in _temp32) _temp32 = skipDebugger(_temp32);
  /* node:coverage ignore next */
  if (_temp32 instanceof AbruptCompletion) throw new Assert.Error("! ToObject(source) returned an abrupt completion", {
    cause: _temp32
  });
  /* node:coverage ignore next */
  if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
  const arrayLike = _temp32;
  // 9. Let len be ? LengthOfArrayLike(arrayLike).
  /* ReturnIfAbrupt */
  let _temp33 = yield* LengthOfArrayLike(arrayLike);
  /* node:coverage ignore next */
  if (_temp33 instanceof AbruptCompletion) return _temp33;
  /* node:coverage ignore next */
  if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
  const len = _temp33;
  // 10. Let targetObj be ? TypedArrayCreate(C, « 𝔽(len) »).
  /* ReturnIfAbrupt */
  let _temp34 = yield* TypedArrayCreateFromConstructor(C, [F(len)]);
  /* node:coverage ignore next */
  if (_temp34 instanceof AbruptCompletion) return _temp34;
  /* node:coverage ignore next */
  if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
  const targetObj = _temp34;
  // 11. Let k be 0.
  let k = 0;
  // 12. Repeat, while k < len
  while (k < len) {
    /* X */
    let _temp35 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp35 && typeof _temp35 === 'object' && 'next' in _temp35) _temp35 = skipDebugger(_temp35);
    /* node:coverage ignore next */
    if (_temp35 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp35
    });
    /* node:coverage ignore next */
    if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
    // a. Let Pk be ! ToString(𝔽(k)).
    const Pk = _temp35;
    // b. Let kValue be ? Get(arrayLike, Pk).
    /* ReturnIfAbrupt */
    let _temp36 = yield* Get(arrayLike, Pk);
    /* node:coverage ignore next */
    if (_temp36 instanceof AbruptCompletion) return _temp36;
    /* node:coverage ignore next */
    if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
    const kValue = _temp36;
    let mappedValue;
    // c. If mapping is true, then
    if (mapping) {
      /* ReturnIfAbrupt */
      let _temp37 = yield* Call(mapper, thisArg, [kValue, F(k)]);
      /* node:coverage ignore next */
      if (_temp37 instanceof AbruptCompletion) return _temp37;
      /* node:coverage ignore next */
      if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
      // i. Let mappedValue be ? Call(mapfn, thisArg, « kValue, 𝔽(k) »).
      mappedValue = _temp37;
    } else {
      // d. Else, let mappedValue be kValue.
      mappedValue = kValue;
    }
    // e. Perform ? Set(targetObj, Pk, mappedValue, true).
    /* ReturnIfAbrupt */
    let _temp38 = yield* Set$1(targetObj, Pk, mappedValue, Value.true);
    /* node:coverage ignore next */
    if (_temp38 instanceof AbruptCompletion) return _temp38;
    /* node:coverage ignore next */
    if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
    // f. Set k to k + 1.
    k += 1;
  }
  // 13. Return targetObj.
  return targetObj;
}
TypedArray_from.section = 'https://tc39.es/ecma262/#sec-%typedarray%.from';
/** https://tc39.es/ecma262/#sec-%typedarray%.of */
function* TypedArray_of(items, {
  thisValue
}) {
  // 1. Let len be the actual number of arguments passed to this function.
  // 2. Let items be the List of arguments passed to this function.
  const len = items.length;
  // 3. Let C be the this value.
  const C = thisValue;
  // 4. If IsConstructor(C) is false, throw a TypeError exception.
  if (!IsConstructor(C)) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', C);
  }
  // 5. Let newObj be ? TypedArrayCreate(C, « 𝔽(len) »).
  /* ReturnIfAbrupt */
  let _temp39 = yield* TypedArrayCreateFromConstructor(C, [F(len)]);
  /* node:coverage ignore next */
  if (_temp39 instanceof AbruptCompletion) return _temp39;
  /* node:coverage ignore next */
  if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
  const newObj = _temp39;
  // 6. Let k be 0.
  let k = 0;
  // 7. Repeat, while k < len
  while (k < len) {
    // a. Let kValue be items[k].
    const kValue = items[k];
    // b. Let Pk be ! ToString(𝔽(k)).
    /* X */
    let _temp40 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp40 && typeof _temp40 === 'object' && 'next' in _temp40) _temp40 = skipDebugger(_temp40);
    /* node:coverage ignore next */
    if (_temp40 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp40
    });
    /* node:coverage ignore next */
    if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
    const Pk = _temp40;
    // c. Perform ? Set(newObj, Pk, kValue, true).
    /* ReturnIfAbrupt */
    let _temp41 = yield* Set$1(newObj, Pk, kValue, Value.true);
    /* node:coverage ignore next */
    if (_temp41 instanceof AbruptCompletion) return _temp41;
    /* node:coverage ignore next */
    if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
    // d. Set k to k + 1.
    k += 1;
  }
  // 8. Return newObj.
  return newObj;
}
TypedArray_of.section = 'https://tc39.es/ecma262/#sec-%typedarray%.of';
/** https://tc39.es/ecma262/#sec-get-%typedarray%-@@species */
function TypedArray_speciesGetter(_args, {
  thisValue
}) {
  return thisValue;
}
TypedArray_speciesGetter.section = 'https://tc39.es/ecma262/#sec-get-%typedarray%-@@species';
function bootstrapTypedArray(realmRec) {
  const typedArrayConstructor = bootstrapConstructor(realmRec, TypedArrayConstructor, 'TypedArray', 0, realmRec.Intrinsics['%TypedArray.prototype%'], [['from', TypedArray_from, 1], ['of', TypedArray_of, 0], [wellKnownSymbols.species, [TypedArray_speciesGetter]]]);
  realmRec.Intrinsics['%TypedArray%'] = typedArrayConstructor;
}

function isArrayBufferObject(o) {
  return 'ArrayBufferDetachKey' in o;
}

/** https://tc39.es/ecma262/#sec-allocatearraybuffer */
function* AllocateArrayBuffer(constructor, byteLength, maxByteLength) {
  const slots = ['ArrayBufferData', 'ArrayBufferByteLength', 'ArrayBufferDetachKey'];
  let allocatingResizableBuffer;
  if (maxByteLength !== undefined) {
    allocatingResizableBuffer = true;
  } else {
    allocatingResizableBuffer = false;
  }
  if (allocatingResizableBuffer) {
    if (byteLength > maxByteLength) {
      return surroundingAgent.Throw('RangeError', 'ResizableBufferInvalidMaxByteLength');
    }
    slots.push('ArrayBufferMaxByteLength');
  }
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(constructor, '%ArrayBuffer.prototype%', slots);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const obj = _temp;
  // 2. Assert: byteLength is a non-negative integer.
  Assert(isNonNegativeInteger(byteLength), "isNonNegativeInteger(byteLength)");
  // 3. Let block be ? CreateByteDataBlock(byteLength).
  /* ReturnIfAbrupt */
  let _temp2 = CreateByteDataBlock(byteLength);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const block = _temp2;
  // 4. Set obj.[[ArrayBufferData]] to block.
  obj.ArrayBufferData = block;
  // 5. Set obj.[[ArrayBufferByteLength]] to byteLength.
  obj.ArrayBufferByteLength = byteLength;
  // 6. Return obj.
  if (allocatingResizableBuffer) {
    obj.ArrayBufferMaxByteLength = maxByteLength;
  }
  return obj;
}
AllocateArrayBuffer.section = 'https://tc39.es/ecma262/#sec-allocatearraybuffer';
/** https://tc39.es/ecma262/#sec-isdetachedbuffer */
function IsDetachedBuffer(arrayBuffer) {
  if (arrayBuffer.ArrayBufferData === Value.null) {
    return Value.true;
  }
  return Value.false;
}
IsDetachedBuffer.section = 'https://tc39.es/ecma262/#sec-isdetachedbuffer';
/** https://tc39.es/ecma262/#sec-detacharraybuffer */
function DetachArrayBuffer(arrayBuffer, key) {
  // 2. Assert: IsSharedArrayBuffer(arrayBuffer) is false.
  Assert(IsSharedArrayBuffer() === Value.false, "IsSharedArrayBuffer(arrayBuffer) === Value.false");
  // 3. If key is not present, set key to undefined.
  if (key === undefined) {
    key = Value.undefined;
  }
  // 4. If SameValue(arrayBuffer.[[ArrayBufferDetachKey]], key) is false, throw a TypeError exception.
  if (SameValue(arrayBuffer.ArrayBufferDetachKey, key) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'BufferDetachKeyMismatch', key, arrayBuffer);
  }
  /* ReturnIfAbrupt */
  let _temp3 = surroundingAgent.debugger_tryTouchDuringPreview(arrayBuffer);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 5. Set arrayBuffer.[[ArrayBufferData]] to null.
  arrayBuffer.ArrayBufferData = Value.null;
  // 6. Set arrayBuffer.[[ArrayBufferByteLength]] to 0.
  arrayBuffer.ArrayBufferByteLength = 0;
  return undefined;
}
DetachArrayBuffer.section = 'https://tc39.es/ecma262/#sec-detacharraybuffer';
/** https://tc39.es/ecma262/#sec-issharedarraybuffer */
function IsSharedArrayBuffer(_obj) {
  return Value.false;
}
IsSharedArrayBuffer.section = 'https://tc39.es/ecma262/#sec-issharedarraybuffer';
function* CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength) {
  Assert(IsDetachedBuffer(srcBuffer) === Value.false, "IsDetachedBuffer(srcBuffer) === Value.false");
  /* ReturnIfAbrupt */
  let _temp4 = yield* AllocateArrayBuffer(surroundingAgent.intrinsic('%ArrayBuffer%'), srcLength);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const targetBuffer = _temp4;
  const srcBlock = srcBuffer.ArrayBufferData;
  const targetBlock = targetBuffer.ArrayBufferData;
  CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength);
  return targetBuffer;
}

/** https://tc39.es/ecma262/#sec-isbigintelementtype */
function IsBigIntElementType(type) {
  // 1. If type is BigUint64 or BigInt64, return true.
  if (type === 'BigUint64' || type === 'BigInt64') {
    return Value.true;
  }
  // 2. Return false
  return Value.false;
}
IsBigIntElementType.section = 'https://tc39.es/ecma262/#sec-isbigintelementtype';
const throwawayBuffer = new ArrayBuffer(8);
const throwawayDataView = new DataView(throwawayBuffer);
const throwawayArray = new Uint8Array(throwawayBuffer);

/** https://tc39.es/ecma262/#sec-rawbytestonumeric */
function RawBytesToNumeric(type, rawBytes, isLittleEndian) {
  // 1. Let elementSize be the Element Size value specified in Table 61 for Element Type type.
  const elementSize = typedArrayInfoByType[type].ElementSize;
  Assert(elementSize === rawBytes.length, "elementSize === rawBytes.length");
  const dataViewType = type === 'Uint8C' ? 'Uint8' : type;
  Object.assign(throwawayArray, rawBytes);
  const result = throwawayDataView[`get${dataViewType}`](0, isLittleEndian === Value.true);
  return IsBigIntElementType(type) === Value.true ? Z(result) : F(result);
}
RawBytesToNumeric.section = 'https://tc39.es/ecma262/#sec-rawbytestonumeric';
/** https://tc39.es/ecma262/#sec-getvaluefrombuffer */
function GetValueFromBuffer(arrayBuffer, byteIndex, type, _isTypedArray, _order, isLittleEndian) {
  // 1. Assert: IsDetachedBuffer(arrayBuffer) is false.
  Assert(IsDetachedBuffer(arrayBuffer) === Value.false, "IsDetachedBuffer(arrayBuffer) === Value.false");
  // 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.
  // 3. Assert: byteIndex is a non-negative integer.
  Assert(isNonNegativeInteger(byteIndex), "isNonNegativeInteger(byteIndex)");
  // 4. Let block be arrayBuffer.[[ArrayBufferData]].
  const block = arrayBuffer.ArrayBufferData;
  // 5. Let elementSize be the Element Size value specified in Table 61 for Element Type type.
  const elementSize = typedArrayInfoByType[type].ElementSize;
  // 6. If IsSharedArrayBuffer(arrayBuffer) is true, then
  if (IsSharedArrayBuffer() === Value.true) {
    Assert(false, "false");
  }
  // 7. Else, let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
  const rawValue = [...block.subarray(byteIndex, byteIndex + elementSize)];
  // 8. If isLittleEndian is not present, set isLittleEndian to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
  if (isLittleEndian === undefined) {
    isLittleEndian = surroundingAgent.AgentRecord.LittleEndian;
  }
  // 9. Return RawBytesToNumeric(type, rawValue, isLittleEndian).
  return RawBytesToNumeric(type, rawValue, isLittleEndian);
}
GetValueFromBuffer.section = 'https://tc39.es/ecma262/#sec-getvaluefrombuffer';
const float32NaNLE = Object.freeze([0, 0, 192, 127]);
const float32NaNBE = Object.freeze([127, 192, 0, 0]);
const float64NaNLE = Object.freeze([0, 0, 0, 0, 0, 0, 248, 127]);
const float64NaNBE = Object.freeze([127, 248, 0, 0, 0, 0, 0, 0]);

/** https://tc39.es/ecma262/#sec-numerictorawbytes */
function NumericToRawBytes(type, value, _isLittleEndian) {
  Assert(_isLittleEndian instanceof BooleanValue, "_isLittleEndian instanceof BooleanValue");
  const isLittleEndian = _isLittleEndian === Value.true;
  let rawBytes;
  // One day, we will write our own IEEE 754 and two's complement encoder…
  if (type === 'Float32') {
    if (Number.isNaN(R(value))) {
      rawBytes = isLittleEndian ? [...float32NaNLE] : [...float32NaNBE];
    } else {
      throwawayDataView.setFloat32(0, R(value), isLittleEndian);
      rawBytes = [...throwawayArray.subarray(0, 4)];
    }
  } else if (type === 'Float64') {
    if (Number.isNaN(R(value))) {
      rawBytes = isLittleEndian ? [...float64NaNLE] : [...float64NaNBE];
    } else {
      throwawayDataView.setFloat64(0, R(value), isLittleEndian);
      rawBytes = [...throwawayArray.subarray(0, 8)];
    }
  } else {
    // a. Let n be the Element Size value specified in Table 61 for Element Type type.
    const n = typedArrayInfoByType[type].ElementSize;
    // b. Let convOp be the abstract operation named in the Conversion Operation column in Table 61 for Element Type type.
    const convOp = typedArrayInfoByType[type].ConversionOperation;
    // c. Let intValue be convOp(value) treated as a mathematical value, whether the result is a BigInt or Number.
    /* X */
    let _temp5 = convOp(value);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! convOp(value) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    const intValue = _temp5;
    const dataViewType = type === 'Uint8C' ? 'Uint8' : type;
    throwawayDataView[`set${dataViewType}`](0, R(intValue), isLittleEndian);
    rawBytes = [...throwawayArray.subarray(0, n)];
  }
  return rawBytes;
}
NumericToRawBytes.section = 'https://tc39.es/ecma262/#sec-numerictorawbytes';
/** https://tc39.es/ecma262/#sec-setvalueinbuffer */
function* SetValueInBuffer(arrayBuffer, byteIndex, type, value, _isTypedArray, _order, isLittleEndian) {
  // 1. Assert: IsDetachedBuffer(arrayBuffer) is false.
  Assert(IsDetachedBuffer(arrayBuffer) === Value.false, "IsDetachedBuffer(arrayBuffer) === Value.false");
  // 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.
  // 3. Assert: byteIndex is a non-negative integer.
  Assert(isNonNegativeInteger(byteIndex), "isNonNegativeInteger(byteIndex)");
  // 4. Assert: Type(value) is BigInt if IsBigIntElementType(type) is true; otherwise, Type(value) is Number.
  if (IsBigIntElementType(type) === Value.true) {
    Assert(value instanceof BigIntValue, "value instanceof BigIntValue");
  } else {
    Assert(value instanceof NumberValue, "value instanceof NumberValue");
  }
  // 5. Let block be arrayBuffer.[[ArrayBufferData]].
  const block = arrayBuffer.ArrayBufferData;
  // 6. Let elementSize be the Element Size value specified in Table 61 for Element Type type.
  // const elementSize = typedArrayInfoByType[type].ElementSize;
  // 7. If isLittleEndian is not present, set isLittleEndian to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
  if (isLittleEndian === undefined) {
    isLittleEndian = surroundingAgent.AgentRecord.LittleEndian;
  }
  // 8. Let rawBytes be NumericToRawBytes(type, value, isLittleEndian).
  const rawBytes = NumericToRawBytes(type, value, isLittleEndian);
  // 9. If IsSharedArrayBuffer(arrayBuffer) is true, then
  if (IsSharedArrayBuffer() === Value.true) {
    Assert(false, "false");
  }
  // 10. Else, store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
  /* ReturnIfAbrupt */
  let _temp6 = surroundingAgent.debugger_tryTouchDuringPreview(arrayBuffer);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  rawBytes.forEach((byte, i) => {
    block[byteIndex + i] = byte;
  });
  // 11. Return NormalCompletion(undefined).
  return NormalCompletion(Value.undefined);
}
SetValueInBuffer.section = 'https://tc39.es/ecma262/#sec-setvalueinbuffer';
/** https://tc39.es/ecma262/#sec-arraybufferbytelength */
function ArrayBufferByteLength(arrayBuffer, _order) {
  if (IsSharedArrayBuffer() === Value.true) {
    Assert(false, "false");
  }
  Assert(IsDetachedBuffer(arrayBuffer) === Value.false, "IsDetachedBuffer(arrayBuffer) === Value.false");
  return arrayBuffer.ArrayBufferByteLength;
}
ArrayBufferByteLength.section = 'https://tc39.es/ecma262/#sec-arraybufferbytelength';
/** https://tc39.es/ecma262/#sec-isfixedlengtharraybuffer */
function IsFixedLengthArrayBuffer(arrayBuffer) {
  return !('ArrayBufferMaxByteLength' in arrayBuffer);
}
IsFixedLengthArrayBuffer.section = 'https://tc39.es/ecma262/#sec-isfixedlengtharraybuffer';

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-async-function-objects */

/** https://tc39.es/ecma262/#sec-asyncblockstart */
function* AsyncBlockStart(promiseCapability, asyncBody, asyncContext) {
  asyncContext.promiseCapability = promiseCapability;
  const runningContext = surroundingAgent.runningExecutionContext;
  asyncContext.codeEvaluationState = function* resumer() {
    const result = EnsureCompletion(yield* Evaluate(asyncBody));
    // Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.
    surroundingAgent.executionContextStack.pop(asyncContext);
    if (result.Type === 'normal') {
      /* X */
      let _temp = Call(promiseCapability.Resolve, Value.undefined, [Value.undefined]);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Resolve, Value.undefined, [Value.undefined]) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
    } else if (result.Type === 'return') {
      /* X */
      let _temp2 = Call(promiseCapability.Resolve, Value.undefined, [result.Value]);
      /* node:coverage ignore next */
      if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Resolve, Value.undefined, [result.Value]) returned an abrupt completion", {
        cause: _temp2
      });
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    } else {
      Assert(result.Type === 'throw', "result.Type === 'throw'");
      /* X */
      let _temp3 = Call(promiseCapability.Reject, Value.undefined, [result.Value]);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [result.Value]) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    }
    return Value.undefined;
  }();
  surroundingAgent.executionContextStack.push(asyncContext);
  const result = EnsureCompletion(yield* resume(asyncContext, {
    type: 'await-resume',
    value: Value.undefined
  }));
  Assert(surroundingAgent.runningExecutionContext === runningContext, "surroundingAgent.runningExecutionContext === runningContext");
  Assert(result.Type === 'normal' && result.Value === Value.undefined, "result.Type === 'normal' && result.Value === Value.undefined");
  return Value.undefined;
}
AsyncBlockStart.section = 'https://tc39.es/ecma262/#sec-async-function-objects';
/** https://tc39.es/ecma262/#sec-async-functions-abstract-operations-async-function-start */
function* AsyncFunctionStart(promiseCapability, asyncFunctionBody) {
  const runningContext = surroundingAgent.runningExecutionContext;
  const asyncContext = runningContext.copy();
  /* X */
  let _temp4 = yield* AsyncBlockStart(promiseCapability, asyncFunctionBody, asyncContext);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! yield* AsyncBlockStart(promiseCapability, asyncFunctionBody, asyncContext) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
}
AsyncFunctionStart.section = 'https://tc39.es/ecma262/#sec-async-functions-abstract-operations-async-function-start';

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-asyncgenerator-objects */

/** https://tc39.es/ecma262/#sec-asyncgeneratorrequest-records */
class AsyncGeneratorRequestRecord {
  Completion;
  Capability;
  constructor(completion, promiseCapability) {
    this.Completion = completion;
    this.Capability = promiseCapability;
  }
}
/** https://tc39.es/ecma262/#sec-asyncgeneratorstart */
function AsyncGeneratorStart(generator, generatorBody) {
  // 1. Assert: generator.[[AsyncGeneratorState]] is undefined.
  Assert(generator.AsyncGeneratorState === Value.undefined, "generator.AsyncGeneratorState === Value.undefined");
  // 2. Let genContext be the running execution context.
  const genContext = surroundingAgent.runningExecutionContext;
  // 3. Set the Generator component of genContext to generator.
  genContext.Generator = generator;
  // 4. Set the code evaluation state of genContext such that when evaluation
  //    is resumed for that execution context the following steps will be performed:
  genContext.codeEvaluationState = function* resumer() {
    // a. If generatorBody is a Parse Node, then
    //     i. Let result be the result of evaluating generatorBody.
    // b. Else,
    //     i. Assert: generatorBody is an Abstract Closure.
    //     ii. Let result be generatorBody().
    let result = EnsureCompletion(
    // Note: Engine262 can only perform the "If generatorBody is an Abstract Closure" check:
    yield* typeof generatorBody === 'function' ? generatorBody() : Evaluate(generatorBody));
    // c. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.
    // d. Remove genContext from the execution context stack and restore the execution context
    //    that is at the top of the execution context stack as the running execution context.
    surroundingAgent.executionContextStack.pop(genContext);
    // e. Set generator.[[AsyncGeneratorState]] to completed.
    generator.AsyncGeneratorState = 'completed';
    // f. If result.[[Type]] is normal, set result to NormalCompletion(undefined).
    if (result.Type === 'normal') {
      result = NormalCompletion(Value.undefined);
    }
    // g. If result.[[Type]] is return, set result to NormalCompletion(result.[[Value]]).
    if (result.Type === 'return') {
      result = NormalCompletion(result.Value);
    }
    // h. Perform ! AsyncGeneratorCompleteStep(generator, result, true).
    /* X */
    let _temp = AsyncGeneratorCompleteStep(generator, result, Value.true);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorCompleteStep(generator, result as ThrowCompletion, Value.true) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // i. Perform ! AsyncGeneratorDrainQueue(generator).
    /* X */
    let _temp2 = AsyncGeneratorDrainQueue(generator);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorDrainQueue(generator) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // j. Return undefined.
    return Value.undefined;
  }();
  // 5. Set generator.[[AsyncGeneratorContext]] to genContext.
  generator.AsyncGeneratorContext = genContext;
  // 6. Set generator.[[AsyncGeneratorState]] to suspendedStart.
  generator.AsyncGeneratorState = 'suspendedStart';
  // 7. Set generator.[[AsyncGeneratorQueue]] to a new empty List.
  generator.AsyncGeneratorQueue = [];
  // 8. Return undefined.
  return Value.undefined;
}
AsyncGeneratorStart.section = 'https://tc39.es/ecma262/#sec-asyncgeneratorstart';
/** https://tc39.es/ecma262/#sec-asyncgeneratorvalidate */
function AsyncGeneratorValidate(generator, generatorBrand) {
  /* ReturnIfAbrupt */
  let _temp3 = RequireInternalSlot(generator, 'AsyncGeneratorContext');
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 2. Perform ? RequireInternalSlot(generator, [[AsyncGeneratorState]]).
  /* ReturnIfAbrupt */
  let _temp4 = RequireInternalSlot(generator, 'AsyncGeneratorState');
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 3. Perform ? RequireInternalSlot(generator, [[AsyncGeneratorQueue]]).
  /* ReturnIfAbrupt */
  let _temp5 = RequireInternalSlot(generator, 'AsyncGeneratorQueue');
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 4. If generator.[[GeneratorBrand]] is not the same value as generatorBrand, throw a TypeError exception.
  const brand = generator.GeneratorBrand;
  if (brand === undefined || generatorBrand === undefined ? brand !== generatorBrand : SameValue(brand, generatorBrand) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', generatorBrandToErrorMessageType(generatorBrand) || 'AsyncGenerator', generator);
  }
  return undefined;
}
AsyncGeneratorValidate.section = 'https://tc39.es/ecma262/#sec-asyncgeneratorvalidate';
/** https://tc39.es/ecma262/#sec-asyncgeneratorenqueue */
function AsyncGeneratorEnqueue(generator, completion, promiseCapability) {
  // 1. Let request be AsyncGeneratorRequest { [[Completion]]: completion, [[Capability]]: promiseCapability }.
  const request = new AsyncGeneratorRequestRecord(completion, promiseCapability);
  // 2. Append request to the end of generator.[[AsyncGeneratorQueue]].
  generator.AsyncGeneratorQueue.push(request);
}
AsyncGeneratorEnqueue.section = 'https://tc39.es/ecma262/#sec-asyncgeneratorenqueue';
/** https://tc39.es/ecma262/#sec-asyncgeneratorcompletestep */
function AsyncGeneratorCompleteStep(generator, completion, done, realm) {
  // 1. Let queue be generator.[[AsyncGeneratorQueue]].
  const queue = generator.AsyncGeneratorQueue;
  // 2. Assert: queue is not empty.
  Assert(queue.length > 0, "queue.length > 0");
  // 3. Let next be the first element of queue.
  // 4. Remove the first element from queue.
  const next = queue.shift();
  // 5. Let promiseCapability be next.[[Capability]].
  const promiseCapability = next.Capability;
  // 6. Let value be completion.[[Value]].
  const value = completion.Value;
  // 7. If completion.[[Type]] is throw, then
  if (completion.Type === 'throw') {
    /* X */
    let _temp6 = Call(promiseCapability.Reject, Value.undefined, [value]);
    /* node:coverage ignore next */
    if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [value]) returned an abrupt completion", {
      cause: _temp6
    });
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  } else {
    // 8. Else,
    // a. Assert: completion.[[Type]] is normal.
    Assert(completion.Type === 'normal', "completion.Type === 'normal'");
    let iteratorResult;
    // b. If realm is present, then
    if (realm !== undefined) {
      // i. Let oldRealm be the running execution context's Realm.
      const oldRealm = surroundingAgent.runningExecutionContext.Realm;
      // ii. Set the running execution context's Realm to realm.
      surroundingAgent.runningExecutionContext.Realm = realm;
      // iii. Let iteratorResult be ! CreateIteratorResultObject(value, done).
      /* X */
      let _temp7 = CreateIteratorResultObject(value, done);
      /* node:coverage ignore next */
      if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
      /* node:coverage ignore next */
      if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorResultObject(value, done) returned an abrupt completion", {
        cause: _temp7
      });
      /* node:coverage ignore next */
      if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
      iteratorResult = _temp7;
      // iv. Set the running execution context's Realm to oldRealm.
      surroundingAgent.runningExecutionContext.Realm = oldRealm;
    } else {
      /* X */
      let _temp8 = CreateIteratorResultObject(value, done);
      /* node:coverage ignore next */
      if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorResultObject(value, done) returned an abrupt completion", {
        cause: _temp8
      });
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
      // c. Else,
      // i. Let iteratorResult be ! CreateIteratorResultObject(value, done).
      iteratorResult = _temp8;
    }
    // d. Perform ! Call(promiseCapability.[[Resolve]], undefined, « iteratorResult »).
    /* X */
    let _temp9 = Call(promiseCapability.Resolve, Value.undefined, [iteratorResult]);
    /* node:coverage ignore next */
    if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Resolve, Value.undefined, [iteratorResult]) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  }
}
AsyncGeneratorCompleteStep.section = 'https://tc39.es/ecma262/#sec-asyncgeneratorcompletestep';
/** https://tc39.es/ecma262/#sec-asyncgeneratorresume */
function* AsyncGeneratorResume(generator, completion) {
  // 1. Assert: generator.[[AsyncGeneratorState]] is either suspendedStart or suspendedYield.
  Assert(generator.AsyncGeneratorState === 'suspendedStart' || generator.AsyncGeneratorState === 'suspendedYield', "generator.AsyncGeneratorState === 'suspendedStart' || generator.AsyncGeneratorState === 'suspendedYield'");
  // 2. Let genContext be generator.[[AsyncGeneratorContext]].
  const genContext = generator.AsyncGeneratorContext;
  // 3. Let callerContext be the running execution context.
  const callerContext = surroundingAgent.runningExecutionContext;
  // 4. Suspend callerContext.
  // 5. Set generator.[[AsyncGeneratorState]] to executing.
  generator.AsyncGeneratorState = 'executing';
  // 6. Push genContext onto the execution context stack; genContext is now the running execution context.
  surroundingAgent.executionContextStack.push(genContext);
  // 7. Resume the suspended evaluation of genContext using completion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.
  const result = yield* resume(genContext, {
    type: 'async-generator-resume',
    value: completion
  });
  // 8. Assert: result is never an abrupt completion.
  Assert(!(result instanceof AbruptCompletion), "!(result instanceof AbruptCompletion)");
  // 9. Assert: When we return here, genContext has already been removed from the execution context stack and callerContext is the currently running execution context.
  Assert(surroundingAgent.runningExecutionContext === callerContext, "surroundingAgent.runningExecutionContext === callerContext");
}
AsyncGeneratorResume.section = 'https://tc39.es/ecma262/#sec-asyncgeneratorresume';
/** https://tc39.es/ecma262/#sec-asyncgeneratorunwrapyieldresumption */
function* AsyncGeneratorUnwrapYieldResumption(resumptionValue) {
  // 1. If resumptionValue.[[Type]] is not return, return Completion(resumptionValue).
  if (resumptionValue.Type !== 'return') {
    return resumptionValue;
  }
  // 2. Let awaited be Await(resumptionValue.[[Value]]).
  const awaited = EnsureCompletion(yield* Await(resumptionValue.Value));
  // 3. If awaited.[[Type]] is throw, return Completion(awaited).
  if (awaited.Type === 'throw') {
    return awaited;
  }
  // 4. Assert: awaited.[[Type]] is normal.
  Assert(awaited.Type === 'normal', "awaited.Type === 'normal'");
  // 5. Return Completion { [[Type]]: return, [[Value]]: awaited.[[Value]], [[Target]]: empty }.
  return new Completion({
    Type: 'return',
    Value: awaited.Value,
    Target: undefined
  });
}
AsyncGeneratorUnwrapYieldResumption.section = 'https://tc39.es/ecma262/#sec-asyncgeneratorunwrapyieldresumption';
/** https://tc39.es/ecma262/#sec-asyncgeneratoryield */
function* AsyncGeneratorYield(value) {
  // 1. Let genContext be the running execution context.
  const genContext = surroundingAgent.runningExecutionContext;
  // 2. Assert: genContext is the execution context of a generator.
  Assert(!!genContext.Generator, "!!genContext.Generator");
  // 3. Let generator be the value of the Generator component of genContext.
  const generator = genContext.Generator;
  // 4. Assert: GetGeneratorKind() is async.
  Assert(GetGeneratorKind() === 'async', "GetGeneratorKind() === 'async'");
  // 5. Let completion be NormalCompletion(value).
  const completion = NormalCompletion(value);
  // 6. Assert: The execution context stack has at least two elements.
  Assert(surroundingAgent.executionContextStack.length >= 2, "surroundingAgent.executionContextStack.length >= 2");
  // 7. Let previousContext be the second to top element of the execution context stack.
  const previousContext = surroundingAgent.executionContextStack[surroundingAgent.executionContextStack.length - 2];
  // 8. Let previousRealm be previousContext's Realm.
  const previousRealm = previousContext.Realm;
  // 9. Perform ! AsyncGeneratorCompleteStep(generator, completion, false, previousRealm).
  /* X */
  let _temp10 = AsyncGeneratorCompleteStep(generator, completion, Value.false, previousRealm);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorCompleteStep(generator, completion, Value.false, previousRealm) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  // 10. Let queue be generator.[[AsyncGeneratorQueue]].
  const queue = generator.AsyncGeneratorQueue;
  // 11. If queue is not empty, then
  if (queue.length > 0) {
    // a. NOTE: Execution continues without suspending the generator.
    // b. Let toYield be the first element of queue.
    const toYield = queue[0];
    // c. Let resumptionValue be toYield.[[Completion]].
    const resumptionValue = toYield.Completion;
    // d. Return AsyncGeneratorUnwrapYieldResumption(resumptionValue).
    return yield* AsyncGeneratorUnwrapYieldResumption(resumptionValue);
  } else {
    // 12. Else,
    // a. Set generator.[[AsyncGeneratorState]] to suspendedYield.
    generator.AsyncGeneratorState = 'suspendedYield';
    // b. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
    surroundingAgent.executionContextStack.pop(genContext);
    // c. Set the code evaluation state of genContext such that when evaluation is resumed with a Completion resumptionValue the following steps will be performed:
    const resumptionValue = yield {
      type: 'async-generator-yield'
    };
    Assert(resumptionValue.type === 'async-generator-resume', "resumptionValue.type === 'async-generator-resume'");
    // i. Return AsyncGeneratorUnwrapYieldResumption(resumptionValue).
    return yield* AsyncGeneratorUnwrapYieldResumption(EnsureCompletion(resumptionValue.value));
    // ii. NOTE: When the above step returns, it returns to the evaluation of the YieldExpression production that originally called this abstract operation.

    // d. Return undefined.
    // e. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of genContext.
  }
}
AsyncGeneratorYield.section = 'https://tc39.es/ecma262/#sec-asyncgeneratoryield';
/** https://tc39.es/ecma262/#sec-asyncgeneratorawaitreturn */
function* AsyncGeneratorAwaitReturn(generator) {
  // 1. Let queue be generator.[[AsyncGeneratorQueue]].
  const queue = generator.AsyncGeneratorQueue;
  // 2. Assert: queue is not empty.
  Assert(queue.length > 0, "queue.length > 0");
  // 3. Let next be the first element of queue.
  const next = queue[0];
  // 4. Let completion be next.[[Completion]].
  const completion = next.Completion;
  // 5. Assert: completion.[[Type]] is return.
  Assert(completion.Type === 'return', "completion.Type === 'return'");
  // 6. Let promise be ? PromiseResolve(%Promise%, completion.[[Value]]).
  /* ReturnIfAbrupt */
  let _temp11 = yield* PromiseResolve(surroundingAgent.intrinsic('%Promise%'), completion.Value);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const promise = _temp11;
  // 7. Let fulfilledClosure be a new Abstract Closure with parameters (value) that captures generator and performs the following steps when called:
  const fulfilledClosure = ([value = Value.undefined]) => {
    // a. Set generator.[[AsyncGeneratorState]] to completed.
    generator.AsyncGeneratorState = 'completed';
    // b. Let result be NormalCompletion(value).
    const result = NormalCompletion(value);
    // c. Perform ! AsyncGeneratorCompleteStep(generator, result, true).
    /* X */
    let _temp12 = AsyncGeneratorCompleteStep(generator, result, Value.true);
    /* node:coverage ignore next */
    if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorCompleteStep(generator, result, Value.true) returned an abrupt completion", {
      cause: _temp12
    });
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    // d. Perform ! AsyncGeneratorDrainQueue(generator).
    /* X */
    let _temp13 = AsyncGeneratorDrainQueue(generator);
    /* node:coverage ignore next */
    if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorDrainQueue(generator) returned an abrupt completion", {
      cause: _temp13
    });
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    // e. Return undefined.
    return Value.undefined;
  };
  // 8. Let onFulfilled be ! CreateBuiltinFunction(fulfilledClosure, 1, "", « »).
  /* X */
  let _temp14 = CreateBuiltinFunction(fulfilledClosure, 1, Value(''), []);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(fulfilledClosure, 1, Value(''), []) returned an abrupt completion", {
    cause: _temp14
  });
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const onFulfilled = _temp14;
  // 9. Let rejectedClosure be a new Abstract Closure with parameters (reason) that captures generator and performs the following steps when called:
  const rejectedClosure = ([reason = Value.undefined]) => {
    // a. Set generator.[[AsyncGeneratorState]] to completed.
    generator.AsyncGeneratorState = 'completed';
    // b. Let result be ThrowCompletion(reason).
    const result = ThrowCompletion(reason);
    // c. Perform ! AsyncGeneratorCompleteStep(generator, result, true).
    /* X */
    let _temp15 = AsyncGeneratorCompleteStep(generator, result, Value.true);
    /* node:coverage ignore next */
    if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorCompleteStep(generator, result, Value.true) returned an abrupt completion", {
      cause: _temp15
    });
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    // d. Perform ! AsyncGeneratorDrainQueue(generator).
    /* X */
    let _temp16 = AsyncGeneratorDrainQueue(generator);
    /* node:coverage ignore next */
    if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorDrainQueue(generator) returned an abrupt completion", {
      cause: _temp16
    });
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    // e. Return undefined.
    return Value.undefined;
  };
  // 10. Let onRejected be ! CreateBuiltinFunction(rejectedClosure, 1, "", « »).
  /* X */
  let _temp17 = CreateBuiltinFunction(rejectedClosure, 1, Value(''), []);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(rejectedClosure, 1, Value(''), []) returned an abrupt completion", {
    cause: _temp17
  });
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  const onRejected = _temp17;
  // 11. Perform ! PerformPromiseThen(promise, onFulfilled, onRejected).
  /* X */
  let _temp18 = PerformPromiseThen(promise, onFulfilled, onRejected);
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! PerformPromiseThen(promise, onFulfilled, onRejected) returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
}
AsyncGeneratorAwaitReturn.section = 'https://tc39.es/ecma262/#sec-asyncgeneratorawaitreturn';
/** https://tc39.es/ecma262/#sec-asyncgeneratordrainqueue */
function AsyncGeneratorDrainQueue(generator) {
  // 1. Assert: generator.[[AsyncGeneratorState]] is completed.
  Assert(generator.AsyncGeneratorState === 'completed', "generator.AsyncGeneratorState === 'completed'");
  // 2. Let queue be generator.[[AsyncGeneratorQueue]].
  const queue = generator.AsyncGeneratorQueue;
  // 3. If queue is empty, return.
  if (queue.length === 0) {
    return;
  }
  // 4. Let done be false.
  let done = false;
  // 5. Repeat, while done is false,
  while (done === false) {
    // a. Let next be the first element of queue.
    const next = queue[0];
    // b. Let completion be next.[[Completion]].
    let completion = next.Completion;
    // c. If completion.[[Type]] is return, then
    if (completion.Type === 'return') {
      // i. Set generator.[[AsyncGeneratorState]] to awaiting-return.
      generator.AsyncGeneratorState = 'awaiting-return';
      // ii. Perform ! AsyncGeneratorAwaitReturn(generator).
      /* X */
      let _temp19 = AsyncGeneratorAwaitReturn(generator);
      /* node:coverage ignore next */
      if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
      /* node:coverage ignore next */
      if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorAwaitReturn(generator) returned an abrupt completion", {
        cause: _temp19
      });
      /* node:coverage ignore next */
      if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
      // iii. Set done to true.
      done = true;
    } else {
      // d. Else,
      // i. If completion.[[Type]] is normal, then
      if (completion.Type === 'normal') {
        // 1. Set completion to NormalCompletion(undefined).
        completion = NormalCompletion(Value.undefined);
      }
      // ii. Perform ! AsyncGeneratorCompleteStep(generator, completion, true).
      /* X */
      let _temp20 = AsyncGeneratorCompleteStep(generator, completion, Value.true);
      /* node:coverage ignore next */
      if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) _temp20 = skipDebugger(_temp20);
      /* node:coverage ignore next */
      if (_temp20 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorCompleteStep(generator, completion, Value.true) returned an abrupt completion", {
        cause: _temp20
      });
      /* node:coverage ignore next */
      if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
      // iii. If queue is empty, set done to true.
      if (queue.length === 0) {
        done = true;
      }
    }
  }
}
AsyncGeneratorDrainQueue.section = 'https://tc39.es/ecma262/#sec-asyncgeneratordrainqueue';
/** https://tc39.es/ecma262/#sec-createasynciteratorfromclosure */
function CreateAsyncIteratorFromClosure(closure, generatorBrand, generatorPrototype) {
  Assert(typeof closure === 'function', "typeof closure === 'function'");
  // 1. NOTE: closure can contain uses of the Await shorthand, and uses of the Yield shorthand to yield an IteratorResult object.
  // 2. Let internalSlotsList be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ».
  const internalSlotsList = ['AsyncGeneratorState', 'AsyncGeneratorContext', 'AsyncGeneratorQueue', 'GeneratorBrand'];
  // 3. Let generator be ! OrdinaryObjectCreate(generatorPrototype, internalSlotsList).
  /* X */
  let _temp21 = OrdinaryObjectCreate(generatorPrototype, internalSlotsList);
  /* node:coverage ignore next */
  if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) _temp21 = skipDebugger(_temp21);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(generatorPrototype, internalSlotsList) returned an abrupt completion", {
    cause: _temp21
  });
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  const generator = _temp21;
  // 4. Set generator.[[GeneratorBrand]] to generatorBrand.
  generator.GeneratorBrand = generatorBrand;
  // 5. Set generator.[[AsyncGeneratorState]] to undefined.
  generator.AsyncGeneratorState = Value.undefined;
  // 6. Perform ? AsyncGeneratorStart(generator, closure, generatorBrand).
  /* ReturnIfAbrupt */
  let _temp22 = AsyncGeneratorStart(generator, closure);
  /* node:coverage ignore next */
  if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) return _temp22;
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  // 7. Return generator.
  return generator;
}
CreateAsyncIteratorFromClosure.section = 'https://tc39.es/ecma262/#sec-createasynciteratorfromclosure';

// This file covers predicates defined in
/** https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values */

// 6.1.7 #integer-index
function isIntegerIndex(V) {
  if (!(V instanceof JSStringValue)) {
    return false;
  }
  /* X */
  let _temp = CanonicalNumericIndexString(V);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! CanonicalNumericIndexString(V) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const numeric = _temp;
  if (numeric instanceof UndefinedValue) {
    return false;
  }
  if (Object.is(R(numeric), 0)) {
    return true;
  }
  return R(numeric) > 0 && Number.isSafeInteger(R(numeric));
}
isIntegerIndex.section = 'https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values'; // 6.1.7 #array-index
function isArrayIndex(V) {
  if (!(V instanceof JSStringValue)) {
    return false;
  }
  /* X */
  let _temp2 = CanonicalNumericIndexString(V);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! CanonicalNumericIndexString(V) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const numeric = _temp2;
  if (numeric instanceof UndefinedValue) {
    return false;
  }
  if (!Number.isInteger(R(numeric))) {
    return false;
  }
  if (Object.is(R(numeric), 0)) {
    return true;
  }
  return R(numeric) > 0 && R(numeric) < 2 ** 32 - 1;
}
function isNonNegativeInteger(argument) {
  return Number.isInteger(argument) && argument >= 0;
}

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-dataview-objects */

/** https://tc39.es/ecma262/#sec-dataview-with-buffer-witness-records */

/** https://tc39.es/ecma262/#sec-makedataviewwithbufferwitnessrecord */
function MakeDataViewWithBufferWitnessRecord(obj, order) {
  const buffer = obj.ViewedArrayBuffer;
  let byteLength;
  if (IsDetachedBuffer(buffer) === Value.true) {
    byteLength = 'detached';
  } else {
    byteLength = ArrayBufferByteLength(buffer);
  }
  return {
    Object: obj,
    CachedBufferByteLength: byteLength
  };
}
MakeDataViewWithBufferWitnessRecord.section = 'https://tc39.es/ecma262/#sec-makedataviewwithbufferwitnessrecord';
/** https://tc39.es/ecma262/#sec-getviewbytelength */
function GetViewByteLength(viewRecord) {
  Assert(!IsViewOutOfBounds(viewRecord), "!IsViewOutOfBounds(viewRecord)");
  const view = viewRecord.Object;
  // @ts-expect-error
  if (view.ByteLength !== 'auto') {
    return view.ByteLength;
  }
  Assert(!IsFixedLengthArrayBuffer(view.ViewedArrayBuffer), "!IsFixedLengthArrayBuffer(view.ViewedArrayBuffer as ArrayBufferObject)");
  const byteOffset = view.ByteOffset;
  const byteLength = viewRecord.CachedBufferByteLength;
  Assert(byteLength !== 'detached', "byteLength !== 'detached'");
  return byteLength - byteOffset;
}
GetViewByteLength.section = 'https://tc39.es/ecma262/#sec-getviewbytelength';
/** https://tc39.es/ecma262/#sec-isviewoutofbounds */
function IsViewOutOfBounds(viewRecord) {
  const view = viewRecord.Object;
  const bufferByteLength = viewRecord.CachedBufferByteLength;
  Assert(IsDetachedBuffer(view.ViewedArrayBuffer) === Value.true && bufferByteLength === 'detached' || IsDetachedBuffer(view.ViewedArrayBuffer) === Value.false && bufferByteLength !== 'detached', "(IsDetachedBuffer(view.ViewedArrayBuffer as ArrayBufferObject) === Value.true && bufferByteLength === 'detached')\n    || (IsDetachedBuffer(view.ViewedArrayBuffer as ArrayBufferObject) === Value.false && bufferByteLength !== 'detached')");
  if (bufferByteLength === 'detached') {
    return true;
  }
  const byteOffsetStart = view.ByteOffset;
  let byteOffsetEnd;
  // @ts-expect-error
  if (view.ByteLength === 'auto') {
    byteOffsetEnd = bufferByteLength;
  } else {
    byteOffsetEnd = byteOffsetStart + view.ByteLength;
  }
  if (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {
    return true;
  }
  return false;
}
IsViewOutOfBounds.section = 'https://tc39.es/ecma262/#sec-isviewoutofbounds';
/** https://tc39.es/ecma262/#sec-getviewvalue */
function* GetViewValue(view, requestIndex, isLittleEndian, type) {
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(view, 'DataView');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 2. Assert: view has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in view, "'ViewedArrayBuffer' in view");
  // 3. Let getIndex be ? ToIndex(requestIndex).
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToIndex(requestIndex);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const getIndex = _temp2;
  // 4. Set isLittleEndian to ToBoolean(isLittleEndian).
  isLittleEndian = ToBoolean(isLittleEndian);
  // 7. Let viewOffset be view.[[ByteOffset]].
  const viewOffset = view.ByteOffset;
  const viewRecord = MakeDataViewWithBufferWitnessRecord(view);
  if (IsViewOutOfBounds(viewRecord)) {
    return surroundingAgent.Throw('TypeError', 'DataViewOOB');
  }
  const viewSize = GetViewByteLength(viewRecord);
  // 9. Let elementSize be the Element Size value specified in Table 61 for Element Type type.
  const elementSize = typedArrayInfoByType[type].ElementSize;
  // 10. If getIndex + elementSize > viewSize, throw a RangeError exception.
  if (getIndex + elementSize > viewSize) {
    return surroundingAgent.Throw('RangeError', 'DataViewOOB');
  }
  // 11. Let bufferIndex be getIndex + viewOffset.
  const bufferIndex = getIndex + viewOffset;
  // 12. Return GetValueFromBuffer(buffer, bufferIndex, type, false, Unordered, isLittleEndian).
  return GetValueFromBuffer(view.ViewedArrayBuffer, bufferIndex, type, false, 'unordered', isLittleEndian);
}
GetViewValue.section = 'https://tc39.es/ecma262/#sec-getviewvalue';
/** https://tc39.es/ecma262/#sec-setviewvalue */
function* SetViewValue(view, requestIndex, isLittleEndian, type, value) {
  /* ReturnIfAbrupt */
  let _temp3 = RequireInternalSlot(view, 'DataView');
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 2. Assert: view has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in view, "'ViewedArrayBuffer' in view");
  // 3. Let getIndex be ? ToIndex(requestIndex).
  /* ReturnIfAbrupt */
  let _temp4 = yield* ToIndex(requestIndex);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const getIndex = _temp4;
  // 4. If IsBigIntElementType(type) is true, let numberValue be ? ToBigInt(value).
  // 5. Otherwise, let numberValue be ? ToNumber(value).
  let numberValue;
  if (IsBigIntElementType(type) === Value.true) {
    /* ReturnIfAbrupt */
    let _temp5 = yield* ToBigInt(value);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    numberValue = _temp5;
  } else {
    /* ReturnIfAbrupt */
    let _temp6 = yield* ToNumber(value);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    numberValue = _temp6;
  }
  // 6. Set isLittleEndian to ToBoolean(isLittleEndian).
  isLittleEndian = ToBoolean(isLittleEndian);
  // 9. Let viewOffset be view.[[ByteOffset]].
  const viewOffset = view.ByteOffset;
  const viewRecord = MakeDataViewWithBufferWitnessRecord(view);
  if (IsViewOutOfBounds(viewRecord)) {
    return surroundingAgent.Throw('TypeError', 'DataViewOOB');
  }
  const viewSize = GetViewByteLength(viewRecord);
  // 11. Let elementSize be the Element Size value specified in Table 61 for Element Type type.
  const elementSize = typedArrayInfoByType[type].ElementSize;
  // 12. If getIndex + elementSize > viewSize, throw a RangeError exception.
  if (getIndex + elementSize > viewSize) {
    return surroundingAgent.Throw('RangeError', 'DataViewOOB');
  }
  // 13. Let bufferIndex be getIndex + viewOffset.
  const bufferIndex = getIndex + viewOffset;
  // 14. Perform ? SetValueInBuffer(buffer, bufferIndex, type, numberValue, false, Unordered, isLittleEndian).
  /* ReturnIfAbrupt */
  let _temp7 = yield* SetValueInBuffer(view.ViewedArrayBuffer, bufferIndex, type, numberValue, false, 'unordered', isLittleEndian);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  return Value.undefined;
}
SetViewValue.section = 'https://tc39.es/ecma262/#sec-setviewvalue';

const mod$1 = (n, m) => {
  const r = n % m;
  return Math.floor(r >= 0 ? r : r + m);
};
const HoursPerDay = 24;
const MinutesPerHour = 60;
const SecondsPerMinute = 60;
const msPerSecond = 1000;
const msPerMinute = msPerSecond * SecondsPerMinute;
const msPerHour = msPerMinute * MinutesPerHour;
const msPerDay = msPerHour * HoursPerDay;

/** https://tc39.es/ecma262/#sec-day-number-and-time-within-day */
function Day(t) {
  return F(Math.floor(R(t) / msPerDay));
}
Day.section = 'https://tc39.es/ecma262/#sec-day-number-and-time-within-day';
function TimeWithinDay(t) {
  return F(mod$1(R(t), msPerDay));
}

/** https://tc39.es/ecma262/#sec-year-number */
function DaysInYear(y) {
  const ry = R(y);
  if (mod$1(ry, 400) === 0) {
    return F(366);
  }
  if (mod$1(ry, 100) === 0) {
    return F(365);
  }
  if (mod$1(ry, 4) === 0) {
    return F(366);
  }
  return F(365);
}
DaysInYear.section = 'https://tc39.es/ecma262/#sec-year-number';
function DayFromYear(_y) {
  const y = R(_y);
  return F(365 * (y - 1970) + Math.floor((y - 1969) / 4) - Math.floor((y - 1901) / 100) + Math.floor((y - 1601) / 400));
}
function TimeFromYear(y) {
  return F(msPerDay * R(DayFromYear(y)));
}
const msPerAverageYear = 12 * 30.436875 * msPerDay;
function YearFromTime(_t) {
  const t = R(_t);
  let year = Math.floor((t + msPerAverageYear / 2) / msPerAverageYear) + 1970;
  if (R(TimeFromYear(F(year))) > t) {
    year -= 1;
  }
  return F(year);
}
function InLeapYear(t) {
  if (R(DaysInYear(YearFromTime(t))) === 366) {
    return F(1);
  }
  return F(0);
}

/** https://tc39.es/ecma262/#sec-month-number */
function MonthFromTime(t) {
  const inLeapYear = R(InLeapYear(t));
  const dayWithinYear = R(DayWithinYear(t));
  if (dayWithinYear < 31) {
    return F(0);
  }
  if (dayWithinYear < 59 + inLeapYear) {
    return F(1);
  }
  if (dayWithinYear < 90 + inLeapYear) {
    return F(2);
  }
  if (dayWithinYear < 120 + inLeapYear) {
    return F(3);
  }
  if (dayWithinYear < 151 + inLeapYear) {
    return F(4);
  }
  if (dayWithinYear < 181 + inLeapYear) {
    return F(5);
  }
  if (dayWithinYear < 212 + inLeapYear) {
    return F(6);
  }
  if (dayWithinYear < 243 + inLeapYear) {
    return F(7);
  }
  if (dayWithinYear < 273 + inLeapYear) {
    return F(8);
  }
  if (dayWithinYear < 304 + inLeapYear) {
    return F(9);
  }
  if (dayWithinYear < 334 + inLeapYear) {
    return F(10);
  }
  Assert(dayWithinYear < 365 + inLeapYear, "dayWithinYear < 365 + inLeapYear");
  return F(11);
}
MonthFromTime.section = 'https://tc39.es/ecma262/#sec-month-number';
function DayWithinYear(t) {
  return F(R(Day(t)) - R(DayFromYear(YearFromTime(t))));
}

/** https://tc39.es/ecma262/#sec-date-number */
function DateFromTime(t) {
  const inLeapYear = R(InLeapYear(t));
  const dayWithinYear = R(DayWithinYear(t));
  const month = R(MonthFromTime(t));
  switch (month) {
    case 0:
      return F(dayWithinYear + 1);
    case 1:
      return F(dayWithinYear - 30);
    case 2:
      return F(dayWithinYear - 58 - inLeapYear);
    case 3:
      return F(dayWithinYear - 89 - inLeapYear);
    case 4:
      return F(dayWithinYear - 119 - inLeapYear);
    case 5:
      return F(dayWithinYear - 150 - inLeapYear);
    case 6:
      return F(dayWithinYear - 180 - inLeapYear);
    case 7:
      return F(dayWithinYear - 211 - inLeapYear);
    case 8:
      return F(dayWithinYear - 242 - inLeapYear);
    case 9:
      return F(dayWithinYear - 272 - inLeapYear);
    case 10:
      return F(dayWithinYear - 303 - inLeapYear);
  }
  Assert(month === 11, "month === 11");
  return F(dayWithinYear - 333 - inLeapYear);
}
DateFromTime.section = 'https://tc39.es/ecma262/#sec-date-number';
/** https://tc39.es/ecma262/#sec-week-day */
function WeekDay(t) {
  return F(mod$1(R(Day(t)) + 4, 7));
}
WeekDay.section = 'https://tc39.es/ecma262/#sec-week-day';
/** https://tc39.es/ecma262/#sec-local-time-zone-adjustment */
function LocalTZA(_t, _isUTC) {
  // TODO: implement this function properly.
  return 0;
}
LocalTZA.section = 'https://tc39.es/ecma262/#sec-local-time-zone-adjustment';
/** https://tc39.es/ecma262/#sec-localtime */
function LocalTime(t) {
  return F(R(t) + LocalTZA());
}
LocalTime.section = 'https://tc39.es/ecma262/#sec-localtime';
/** https://tc39.es/ecma262/#sec-utc-t */
function UTC(t) {
  return F(R(t) - LocalTZA());
}
UTC.section = 'https://tc39.es/ecma262/#sec-utc-t';
/** https://tc39.es/ecma262/#sec-hours-minutes-second-and-milliseconds */
function HourFromTime(t) {
  return F(mod$1(Math.floor(R(t) / msPerHour), HoursPerDay));
}
HourFromTime.section = 'https://tc39.es/ecma262/#sec-hours-minutes-second-and-milliseconds';
function MinFromTime(t) {
  return F(mod$1(Math.floor(R(t) / msPerMinute), MinutesPerHour));
}
function SecFromTime(t) {
  return F(mod$1(Math.floor(R(t) / msPerSecond), SecondsPerMinute));
}
function msFromTime(t) {
  return F(mod$1(R(t), msPerSecond));
}

/** https://tc39.es/ecma262/#sec-maketime */
function MakeTime(hour, min, sec, ms) {
  if (!Number.isFinite(R(hour)) || !Number.isFinite(R(min)) || !Number.isFinite(R(sec)) || !Number.isFinite(R(ms))) {
    return F(NaN);
  }
  /* X */
  let _temp = ToIntegerOrInfinity(hour);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(hour) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const h = _temp;
  /* X */
  let _temp2 = ToIntegerOrInfinity(min);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(min) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const m = _temp2;
  /* X */
  let _temp3 = ToIntegerOrInfinity(sec);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(sec) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const s = _temp3;
  /* X */
  let _temp4 = ToIntegerOrInfinity(ms);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(ms) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const milli = _temp4;
  const t = h * msPerHour + m * msPerMinute + s * msPerSecond + milli;
  return F(t);
}
MakeTime.section = 'https://tc39.es/ecma262/#sec-maketime';
const daysWithinYearToEndOfMonth = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

/** https://tc39.es/ecma262/#sec-makeday */
function MakeDay(year, month, date) {
  if (!Number.isFinite(R(year)) || !Number.isFinite(R(month)) || !Number.isFinite(R(date))) {
    return F(NaN);
  }
  /* X */
  let _temp5 = ToIntegerOrInfinity(year);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(year) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const y = _temp5;
  /* X */
  let _temp6 = ToIntegerOrInfinity(month);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(month) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const m = _temp6;
  /* X */
  let _temp7 = ToIntegerOrInfinity(date);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(date) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const dt = _temp7;
  const ym = y + Math.floor(m / 12);
  const mn = mod$1(m, 12);
  const ymday = R(DayFromYear(F(ym + (mn > 1 ? 1 : 0)))) - 365 * (mn > 1 ? 1 : 0) + daysWithinYearToEndOfMonth[mn];
  const t = F(ymday * msPerDay);
  return F(R(Day(t)) + dt - 1);
}
MakeDay.section = 'https://tc39.es/ecma262/#sec-makeday';
/** https://tc39.es/ecma262/#sec-makedate */
function MakeDate(day, time) {
  if (!Number.isFinite(R(day)) || !Number.isFinite(R(time))) {
    return F(NaN);
  }
  return F(R(day) * msPerDay + R(time));
}
MakeDate.section = 'https://tc39.es/ecma262/#sec-makedate';
/** https://tc39.es/ecma262/#sec-timeclip */
function TimeClip(time) {
  // 1. If time is not finite, return NaN.
  if (!time.isFinite()) {
    return F(NaN);
  }
  // 2. If abs(ℝ(time)) > 8.64 × 1015, return NaN.
  if (Math.abs(R(time)) > 8.64e15) {
    return F(NaN);
  }
  // 3. Return 𝔽(! ToIntegerOrInfinity(time)).
  /* X */
  let _temp8 = ToIntegerOrInfinity(time);
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(time) returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  return F(_temp8);
}
TimeClip.section = 'https://tc39.es/ecma262/#sec-timeclip';

/** https://tc39.es/ecma262/#sec-errorobjects-install-error-cause */
function* InstallErrorCause(O, options) {
  // 1. If Type(options) is Object and ? HasProperty(options, "cause") is true, then
  if (options instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp = yield* HasProperty(options, Value('cause'));
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // nested if statement due to macro expansion
    if (_temp === Value.true) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* Get(options, Value('cause'));
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      // a. Let cause be ? Get(options, "cause").
      const cause = _temp2;
      // b. Perform ! CreateNonEnumerableDataPropertyOrThrow(O, "cause", cause).
      /* X */
      let _temp3 = DefinePropertyOrThrow(O, Value('cause'), _Descriptor({
        Value: cause,
        Writable: Value.true,
        Enumerable: Value.false,
        Configurable: Value.true
      }));
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(O, Value('cause'), Descriptor({\n        Value: cause,\n        Writable: Value.true,\n        Enumerable: Value.false,\n        Configurable: Value.true,\n      })) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    }
  }
  // 2. Return NormalCompletion(undefined).
  return NormalCompletion(Value.undefined);
}
InstallErrorCause.section = 'https://tc39.es/ecma262/#sec-errorobjects-install-error-cause';
/** https://tc39.es/proposal-is-error/#sec-iserror */
function IsError(argument) {
  if (!(argument instanceof ObjectValue)) {
    return false;
  }
  if ('ErrorData' in argument) {
    return true;
  }
  return false;
}
IsError.section = 'https://tc39.es/proposal-is-error/#sec-iserror';

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-execution-contexts */

/** https://tc39.es/ecma262/#sec-getactivescriptormodule */
function GetActiveScriptOrModule() {
  for (let i = surroundingAgent.executionContextStack.length - 1; i >= 0; i -= 1) {
    const e = surroundingAgent.executionContextStack[i];
    if (e.ScriptOrModule !== Value.null) {
      return e.ScriptOrModule;
    }
  }
  return Value.null;
}
GetActiveScriptOrModule.section = 'https://tc39.es/ecma262/#sec-execution-contexts';
/** https://tc39.es/ecma262/#sec-resolvebinding */
function ResolveBinding(name, env, strict) {
  // 1. If env is not present or if env is undefined, then
  if (env === undefined || env === Value.undefined) {
    // a. Set env to the running execution context's LexicalEnvironment.
    env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  }
  // 2. Assert: env is an Environment Record.
  Assert(env instanceof EnvironmentRecord, "env instanceof EnvironmentRecord");
  // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true; else let strict be false.
  // 4. Return ? GetIdentifierReference(env, name, strict).
  return GetIdentifierReference(env, name, strict ? Value.true : Value.false);
}
ResolveBinding.section = 'https://tc39.es/ecma262/#sec-resolvebinding';
/** https://tc39.es/ecma262/#sec-getthisenvironment */
function GetThisEnvironment() {
  // 1. Let env be the running execution context's LexicalEnvironment.
  let env = surroundingAgent.runningExecutionContext.LexicalEnvironment;
  // 2. Repeat,
  while (true) {
    // a. Let exists be env.HasThisBinding().
    const exists = env.HasThisBinding();
    // b. If exists is true, return envRec.
    if (exists === Value.true) {
      return env;
    }
    // c. Let outer be env.[[OuterEnv]].
    const outer = env.OuterEnv;
    // d. Assert: outer is not null.
    Assert(!(outer instanceof NullValue), "!(outer instanceof NullValue)");
    // e. Set env to outer.
    env = outer;
  }
}
GetThisEnvironment.section = 'https://tc39.es/ecma262/#sec-getthisenvironment';
/** https://tc39.es/ecma262/#sec-resolvethisbinding */
function ResolveThisBinding() {
  const envRec = GetThisEnvironment();
  return envRec.GetThisBinding();
}
ResolveThisBinding.section = 'https://tc39.es/ecma262/#sec-resolvethisbinding';
/** https://tc39.es/ecma262/#sec-getnewtarget */
function GetNewTarget() {
  const envRec = GetThisEnvironment();
  Assert('NewTarget' in envRec, "'NewTarget' in envRec");
  return envRec.NewTarget;
}
GetNewTarget.section = 'https://tc39.es/ecma262/#sec-getnewtarget';
/** https://tc39.es/ecma262/#sec-getglobalobject */
function GetGlobalObject() {
  const currentRealm = surroundingAgent.currentRealmRecord;
  return currentRealm.GlobalObject;
}
GetGlobalObject.section = 'https://tc39.es/ecma262/#sec-getglobalobject';

function isBoundFunctionObject(object) {
  return 'BoundTargetFunction' in object;
}

/** https://tc39.es/ecma262/#sec-properties-of-the-function-prototype-object */
function FunctionProto() {
  // * accepts any arguments and returns undefined when invoked.
  return Value.undefined;
}
FunctionProto.section = 'https://tc39.es/ecma262/#sec-properties-of-the-function-prototype-object';
/** https://tc39.es/ecma262/#sec-function.prototype.apply */
function* FunctionProto_apply([thisArg = Value.undefined, argArray = Value.undefined], {
  thisValue
}) {
  // 1. Let func be the this value.
  const func = thisValue;
  // 2. If IsCallable(func) is false, throw a TypeError exception.
  if (!IsCallable(func)) {
    return surroundingAgent.Throw('TypeError', 'ThisNotAFunction', func);
  }
  // 3. If argArray is undefined or null, then
  if (argArray === Value.undefined || argArray === Value.null) {
    // a. Perform PrepareForTailCall().
    PrepareForTailCall();
    // b. Return ? Call(func, thisArg).
    return yield* Call(func, thisArg);
  }
  // 4. Let argList be ? CreateListFromArrayLike(argArray).
  /* ReturnIfAbrupt */
  let _temp = yield* CreateListFromArrayLike(argArray);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const argList = _temp;
  // 5. Perform PrepareForTailCall().
  PrepareForTailCall();
  // 6. Return ? Call(func, thisArg, argList).
  return yield* Call(func, thisArg, argList);
}
FunctionProto_apply.section = 'https://tc39.es/ecma262/#sec-function.prototype.apply';
function* BoundFunctionExoticObjectCall(_thisArgument, argumentsList) {
  const F = this;
  const target = F.BoundTargetFunction;
  const boundThis = F.BoundThis;
  const boundArgs = F.BoundArguments;
  const args = [...boundArgs, ...argumentsList];
  return yield* Call(target, boundThis, args);
}
function* BoundFunctionExoticObjectConstruct(argumentsList, newTarget) {
  const F = this;
  const target = F.BoundTargetFunction;
  Assert(IsConstructor(target), "IsConstructor(target)");
  const boundArgs = F.BoundArguments;
  const args = [...boundArgs, ...argumentsList];
  if (SameValue(F, newTarget) === Value.true) {
    newTarget = target;
  }
  return yield* Construct(target, args, newTarget);
}

/** https://tc39.es/ecma262/#sec-boundfunctioncreate */
function* BoundFunctionCreate(targetFunction, boundThis, boundArgs) {
  // 1. Assert: Type(targetFunction) is Object.
  Assert(targetFunction instanceof ObjectValue, "targetFunction instanceof ObjectValue");
  // 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().
  /* ReturnIfAbrupt */
  let _temp2 = yield* targetFunction.GetPrototypeOf();
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const proto = _temp2;
  // 3. Let internalSlotsList be the internal slots listed in Table 30, plus [[Prototype]] and [[Extensible]].
  const internalSlotsList = ['BoundTargetFunction', 'BoundThis', 'BoundArguments', 'Prototype', 'Extensible'];
  // 4. Let obj be ! MakeBasicObject(internalSlotsList).
  /* X */
  let _temp3 = MakeBasicObject(internalSlotsList);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! MakeBasicObject(internalSlotsList) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const obj = _temp3;
  // 5. Set obj.[[Prototype]] to proto.
  obj.Prototype = proto;
  // 6. Set obj.[[Call]] as described in 9.4.1.1.
  obj.Call = BoundFunctionExoticObjectCall;
  // 7. If IsConstructor(targetFunction) is true, then
  if (IsConstructor(targetFunction)) {
    // a. Set obj.[[Construct]] as described in 9.4.1.2.
    obj.Construct = BoundFunctionExoticObjectConstruct;
  }
  // 8. Set obj.[[BoundTargetFunction]] to targetFunction.
  obj.BoundTargetFunction = targetFunction;
  // 9. Set obj.[[BoundThis]] to boundThis.
  obj.BoundThis = boundThis;
  // 10. Set obj.[[BoundArguments]] to boundArguments.
  obj.BoundArguments = boundArgs;
  // 11. Return obj.
  return obj;
}
BoundFunctionCreate.section = 'https://tc39.es/ecma262/#sec-boundfunctioncreate';
/** https://tc39.es/ecma262/#sec-function.prototype.bind */
function* FunctionProto_bind([thisArg = Value.undefined, ...args], {
  thisValue
}) {
  // 1. Let Target be the this value.
  const Target = thisValue;
  // 2. If IsCallable(Target) is false, throw a TypeError exception.
  if (!IsCallable(Target)) {
    return surroundingAgent.Throw('TypeError', 'ThisNotAFunction', Target);
  }
  // 3. Let F be ? BoundFunctionCreate(Target, thisArg, args).
  /* ReturnIfAbrupt */
  let _temp4 = yield* BoundFunctionCreate(Target, thisArg, args);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const F = _temp4;
  // 4. Let L be 0.
  let L = 0;
  // 5. Let targetHasLength be ? HasOwnProperty(Target, "length").
  /* ReturnIfAbrupt */
  let _temp5 = yield* HasOwnProperty(Target, Value('length'));
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const targetHasLength = _temp5;
  // 6. If targetHasLength is true, then
  if (targetHasLength === Value.true) {
    /* ReturnIfAbrupt */
    let _temp6 = yield* Get(Target, Value('length'));
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    // a. Let targetLen be ? Get(Target, "length").
    const targetLen = _temp6;
    // b. If Type(targetLen) is Number, then
    if (targetLen instanceof NumberValue) {
      // i. If targetLen is +∞𝔽, set L to +∞.
      if (R(targetLen) === +Infinity) {
        L = +Infinity;
      } else if (R(targetLen) === -Infinity) {
        // ii. Else if targetLen is -∞𝔽, set L to 0.
        L = 0;
      } else {
        /* ReturnIfAbrupt */
        let _temp7 = yield* ToIntegerOrInfinity(targetLen);
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) return _temp7;
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        // iii. Else,
        // 1. Set targetLen to ! ToIntegerOrInfinity(targetLen).
        const targetLenAsInt = _temp7;
        // 2. Assert: targetLenAsInt is finite.
        Assert(Number.isFinite(targetLenAsInt), "Number.isFinite(targetLenAsInt)");
        // 3. Let argCount be the number of elements in args.
        const argCount = args.length;
        // 4. Set L to max(targetLenAsInt - argCount, 0).
        L = Math.max(targetLenAsInt - argCount, 0);
      }
    }
  }
  // 7. Perform ! SetFunctionLength(F, L).
  /* X */
  let _temp8 = SetFunctionLength(F, L);
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionLength(F, L) returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 8. Let targetName be ? Get(Target, "name").
  /* ReturnIfAbrupt */
  let _temp9 = yield* Get(Target, Value('name'));
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  let targetName = _temp9;
  // 9. If Type(targetName) is not String, set targetName to the empty String.
  if (!(targetName instanceof JSStringValue)) {
    targetName = Value('');
  }
  // 10. Perform SetFunctionName(F, targetName, "bound").
  SetFunctionName(F, targetName, Value('bound'));
  // 11. Return F.
  return F;
}
FunctionProto_bind.section = 'https://tc39.es/ecma262/#sec-function.prototype.bind';
/** https://tc39.es/ecma262/#sec-function.prototype.call */
function* FunctionProto_call([thisArg = Value.undefined, ...args], {
  thisValue
}) {
  // 1. Let func be the this value.
  const func = thisValue;
  // 2. If IsCallable(func) is false, throw a TypeError exception.
  if (!IsCallable(func)) {
    return surroundingAgent.Throw('TypeError', 'ThisNotAFunction', func);
  }
  // 3. Let argList be a new empty List.
  const argList = [];
  // 4. If this method was called with more than one argument, then in left to right order, starting with the second argument, append each argument as the last element of argList.
  for (const arg of args) {
    argList.push(arg);
  }
  // 5. Perform PrepareForTailCall().
  PrepareForTailCall();
  // 6. Return ? Call(func, thisArg, argList).
  return yield* Call(func, thisArg, argList);
}
FunctionProto_call.section = 'https://tc39.es/ecma262/#sec-function.prototype.call';
/** https://tc39.es/ecma262/#sec-function.prototype.tostring */
function FunctionProto_toString(_args, {
  thisValue
}) {
  // 1. Let func be the this value.
  const func = thisValue;
  // 2. If Type(func) is Object and func has a [[SourceText]] internal slot and func.[[SourceText]]
  //    is a sequence of Unicode code points and ! HostHasSourceTextAvailable(func) is true, then
  /* X */
  let _temp10 = HostHasSourceTextAvailable(func);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! HostHasSourceTextAvailable(func) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  if (isECMAScriptFunctionObject(func) && _temp10 === Value.true) {
    // Return ! UTF16Encode(func.[[SourceText]]).
    return Value(func.SourceText);
  }
  // 3. If func is a built-in function object, then return an implementation-defined
  //    String source code representation of func. The representation must have the
  //    syntax of a NativeFunction. Additionally, if func has an [[InitialName]] internal
  //    slot and func.[[InitialName]] is a String, the portion of the returned String
  //    that would be matched by `NativeFunctionAccessor? PropertyName` must be the
  //    value of func.[[InitialName]].
  if (isBuiltinFunctionObject(func)) {
    if (func.InitialName instanceof JSStringValue) {
      return Value(`function ${func.InitialName.stringValue()}() { [native code] }`);
    }
    return Value('function() { [native code] }');
  }
  // 4. If Type(func) is Object and IsCallable(func) is true, then return an implementation
  //    dependent String source code representation of func. The representation must have
  //    the syntax of a NativeFunction.
  if (func instanceof ObjectValue && IsCallable(func)) {
    return Value('function() { [native code] }');
  }
  // 5. Throw a TypeError exception.
  return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
}
FunctionProto_toString.section = 'https://tc39.es/ecma262/#sec-function.prototype.tostring';
/** https://tc39.es/ecma262/#sec-function.prototype-@@hasinstance */
function* FunctionProto_hasInstance([V = Value.undefined], {
  thisValue
}) {
  // 1. Let F be this value.
  const F = thisValue;
  // 2. Return ? OrdinaryHasInstance(F, V).
  return yield* OrdinaryHasInstance(F, V);
}
FunctionProto_hasInstance.section = 'https://tc39.es/ecma262/#sec-function.prototype-@@hasinstance';
function bootstrapFunctionPrototype(realmRec) {
  const proto = CreateBuiltinFunction(FunctionProto, 0, Value(''), [], realmRec, realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Function.prototype%'] = proto;
  const readonly = {
    Writable: Value.false,
    Configurable: Value.false
  };
  assignProps(realmRec, proto, [['apply', FunctionProto_apply, 2], ['bind', FunctionProto_bind, 1], ['call', FunctionProto_call, 1], ['toString', FunctionProto_toString, 0], [wellKnownSymbols.hasInstance, FunctionProto_hasInstance, 1, readonly]]);
}

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-ecmascript-function-objects */
/** https://tc39.es/ecma262/#sec-built-in-function-objects */
// and
/** https://tc39.es/ecma262/#sec-tail-position-calls */

function isECMAScriptFunctionObject(O) {
  return !!O && 'SourceText' in O && typeof O.SourceText === 'string';
}
isECMAScriptFunctionObject.section = 'https://tc39.es/ecma262/#sec-ecmascript-function-objects';
function isBuiltinFunctionObject(O) {
  return !!O && 'nativeFunction' in O;
}
function isFunctionObject(O) {
  return 'Call' in O;
}

/** https://tc39.es/ecma262/#sec-prepareforordinarycall */
function PrepareForOrdinaryCall(F, newTarget) {
  // 1. Assert: Type(newTarget) is Undefined or Object.
  Assert(newTarget instanceof UndefinedValue || newTarget instanceof ObjectValue, "newTarget instanceof UndefinedValue || newTarget instanceof ObjectValue");
  // 2. Let callerContext be the running execution context.
  // const callerContext = surroundingAgent.runningExecutionContext;
  // 3. Let calleeContext be a new ECMAScript code execution context.
  const calleeContext = new ExecutionContext();
  // 4. Set the Function of calleeContext to F.
  calleeContext.Function = F;
  // 5. Let calleeRealm be F.[[Realm]].
  const calleeRealm = F.Realm;
  // 6. Set the Realm of calleeContext to calleeRealm.
  calleeContext.Realm = calleeRealm;
  // 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
  calleeContext.ScriptOrModule = F.ScriptOrModule;
  // 8. Let localEnv be NewFunctionEnvironment(F, newTarget).
  const localEnv = new FunctionEnvironmentRecord(F, newTarget);
  // 9. Set the LexicalEnvironment of calleeContext to localEnv.
  calleeContext.LexicalEnvironment = localEnv;
  // 10. Set the VariableEnvironment of calleeContext to localEnv.
  calleeContext.VariableEnvironment = localEnv;
  // 11. Set the PrivateEnvironment of calleeContext to F.[[PrivateEnvironment]].
  calleeContext.PrivateEnvironment = F.PrivateEnvironment;
  // 12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
  surroundingAgent.executionContextStack.push(calleeContext);
  // 13. NOTE: Any exception objects produced after this point are associated with calleeRealm.
  // 14. Return calleeContext.
  return calleeContext;
}
PrepareForOrdinaryCall.section = 'https://tc39.es/ecma262/#sec-prepareforordinarycall';
/** https://tc39.es/ecma262/#sec-ordinarycallbindthis */
function OrdinaryCallBindThis(F, calleeContext, thisArgument) {
  // 1. Let thisMode be F.[[ThisMode]].
  const thisMode = F.ThisMode;
  // 2. If thisMode is lexical, return NormalCompletion(undefined).
  if (thisMode === 'lexical') {
    return NormalCompletion(undefined);
  }
  // 3. Let calleeRealm be F.[[Realm]].
  const calleeRealm = F.Realm;
  // 4. Let localEnv be the LexicalEnvironment of calleeContext.
  const localEnv = calleeContext.LexicalEnvironment;
  let thisValue;
  // 5. If thisMode is strict, let thisValue be thisArgument.
  if (thisMode === 'strict') {
    thisValue = thisArgument;
  } else {
    // 6. Else,
    // a. If thisArgument is undefined or null, then
    if (thisArgument === Value.undefined || thisArgument === Value.null) {
      // i. Let globalEnv be calleeRealm.[[GlobalEnv]].
      const globalEnv = calleeRealm.GlobalEnv;
      // ii. Assert: globalEnv is a global Environment Record.
      Assert(globalEnv instanceof GlobalEnvironmentRecord, "globalEnv instanceof GlobalEnvironmentRecord");
      // iii. Let thisValue be globalEnv.[[GlobalThisValue]].
      thisValue = globalEnv.GlobalThisValue;
    } else {
      /* X */
      let _temp = ToObject(thisArgument);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ToObject(thisArgument) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      // b. Else,
      // i. Let thisValue be ! ToObject(thisArgument).
      thisValue = _temp;
      // ii. NOTE: ToObject produces wrapper objects using calleeRealm.
    }
  }
  // 7. Assert: localEnv is a function Environment Record.
  Assert(localEnv instanceof FunctionEnvironmentRecord, "localEnv instanceof FunctionEnvironmentRecord");
  // 8. Assert: The next step never returns an abrupt completion because localEnv.[[ThisBindingStatus]] is not initialized.
  Assert(localEnv.ThisBindingStatus !== 'initialized', "localEnv.ThisBindingStatus !== 'initialized'");
  // 10. Return localEnv.BindThisValue(thisValue).
  /* ReturnIfAbrupt */
  let _temp2 = localEnv.BindThisValue(thisValue);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
}
OrdinaryCallBindThis.section = 'https://tc39.es/ecma262/#sec-ordinarycallbindthis';
/** https://tc39.es/ecma262/#sec-ordinarycallevaluatebody */
function* OrdinaryCallEvaluateBody(F, argumentsList) {
  // 1. Return the result of EvaluateBody of the parsed code that is F.[[ECMAScriptCode]] passing F and argumentsList as the arguments.
  return EnsureCompletion(yield* EvaluateBody(F.ECMAScriptCode, F, argumentsList));
}
OrdinaryCallEvaluateBody.section = 'https://tc39.es/ecma262/#sec-ordinarycallevaluatebody';
/** https://tc39.es/ecma262/#sec-definefield */
function* DefineField(receiver, fieldRecord) {
  // 1. Let fieldName be fieldRecord.[[Name]].
  const fieldName = fieldRecord.Name;
  // 2. Let initializer be fieldRecord.[[Initializer]].
  const initializer = fieldRecord.Initializer;
  // 3. If initializer is not empty, then
  let initValue;
  if (initializer !== undefined) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* Call(initializer, receiver);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // a. Let initValue be ? Call(initializer, receiver).
    initValue = _temp3;
  } else {
    // 4. Else, let initValue be undefined.
    initValue = Value.undefined;
  }
  // 5. If fieldName is a Private Name, then
  if (fieldName instanceof PrivateName) {
    /* ReturnIfAbrupt */
    let _temp4 = PrivateFieldAdd(fieldName, receiver, initValue);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  } else {
    /* X */
    let _temp5 = IsPropertyKey(fieldName);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! IsPropertyKey(fieldName) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // 6. Else,
    // a. Assert: ! IsPropertyKey(fieldName) is true.
    Assert(_temp5, "X(IsPropertyKey(fieldName))");
    // b. Perform ? CreateDataPropertyOrThrow(receiver, fieldName, initValue).
    /* ReturnIfAbrupt */
    let _temp6 = yield* CreateDataPropertyOrThrow(receiver, fieldName, initValue);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  }
}
DefineField.section = 'https://tc39.es/ecma262/#sec-definefield';
/** https://tc39.es/ecma262/#sec-initializeinstanceelements */
function* InitializeInstanceElements(O, constructor) {
  // 1. Let methods be the value of constructor.[[PrivateMethods]].
  const methods = constructor.PrivateMethods;
  // 2. For each PrivateElement method of methods, do
  for (const method of methods) {
    /* ReturnIfAbrupt */
    let _temp7 = PrivateMethodOrAccessorAdd(method, O);
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  }
  // 3. Let fields be the value of constructor.[[Fields]].
  const fields = constructor.Fields;
  // 4. For each element fieldRecord of fields, do
  for (const fieldRecord of fields) {
    /* ReturnIfAbrupt */
    let _temp8 = yield* DefineField(O, fieldRecord);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  }
}
InitializeInstanceElements.section = 'https://tc39.es/ecma262/#sec-initializeinstanceelements';
/** https://tc39.es/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist */
function* FunctionCallSlot(thisArgument, argumentsList) {
  const F = this;

  // 1. Assert: F is an ECMAScript function object.
  Assert(isECMAScriptFunctionObject(F), "isECMAScriptFunctionObject(F)");
  // 2. Let callerContext be the running execution context.
  // 3. Let calleeContext be PrepareForOrdinaryCall(F, undefined).
  const calleeContext = PrepareForOrdinaryCall(F, Value.undefined);
  // 4. Assert: calleeContext is now the running execution context.
  Assert(surroundingAgent.runningExecutionContext === calleeContext, "surroundingAgent.runningExecutionContext === calleeContext");
  // 5. If F.[[IsClassConstructor]] is true, then
  if (F.IsClassConstructor === Value.true) {
    // a. Let error be a newly created TypeError object.
    const error = surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', F);
    // b. NOTE: _error_ is created in _calleeContext_ with _F_'s associated Realm Record.
    // c. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
    surroundingAgent.executionContextStack.pop(calleeContext);
    // d. Return ThrowCompletion(_error_).
    return error;
  }
  // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
  OrdinaryCallBindThis(F, calleeContext, thisArgument);
  // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).
  let result = yield* OrdinaryCallEvaluateBody(F, argumentsList);
  // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
  surroundingAgent.executionContextStack.pop(calleeContext);
  // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).
  if (result.Type === 'return') {
    return NormalCompletion(result.Value);
  }
  // 10. ReturnIfAbrupt(result).
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (result && typeof result === 'object' && 'next' in result) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (result instanceof AbruptCompletion) return result;
  /* node:coverage ignore next */
  if (result instanceof Completion) result = result.Value;
  // 11. Return NormalCompletion(undefined).
  return NormalCompletion(Value.undefined);
}
FunctionCallSlot.section = 'https://tc39.es/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist';
/** https://tc39.es/ecma262/#sec-ecmascript-function-objects-construct-argumentslist-newtarget */
function* FunctionConstructSlot(argumentsList, newTarget) {
  const F = this;

  // 1. Assert: F is an ECMAScript function object.
  Assert(isECMAScriptFunctionObject(F), "isECMAScriptFunctionObject(F)");
  // 2. Assert: Type(newTarget) is Object.
  Assert(newTarget instanceof ObjectValue, "newTarget instanceof ObjectValue");
  // 3. Let callerContext be the running execution context.
  // 4. Let kind be F.[[ConstructorKind]].
  const kind = F.ConstructorKind;
  let thisArgument;
  // 5. If kind is base, then
  if (kind === 'base') {
    /* ReturnIfAbrupt */
    let _temp9 = yield* OrdinaryCreateFromConstructor(newTarget, '%Object.prototype%');
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    // a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, "%Object.prototype%").
    thisArgument = _temp9;
  }
  // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).
  const calleeContext = PrepareForOrdinaryCall(F, newTarget);
  // 7. Assert: calleeContext is now the running execution context.
  Assert(surroundingAgent.runningExecutionContext === calleeContext, "surroundingAgent.runningExecutionContext === calleeContext");
  surroundingAgent.runningExecutionContext.callSite.constructCall = true;
  // 8. If kind is base, then
  if (kind === 'base') {
    // a. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
    OrdinaryCallBindThis(F, calleeContext, thisArgument);
    // b. Let initializeResult be InitializeInstanceElements(thisArgument, F).
    const initializeResult = yield* InitializeInstanceElements(thisArgument, F);
    // c. If initializeResult is an abrupt completion, then
    if (initializeResult instanceof AbruptCompletion) {
      // i. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
      surroundingAgent.executionContextStack.pop(calleeContext);
      // ii. Return Completion(initializeResult).
      return Completion(initializeResult);
    }
  }
  // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.
  const constructorEnv = calleeContext.LexicalEnvironment;
  // 10. Let result be OrdinaryCallEvaluateBody(F, argumentsList).
  let result = yield* OrdinaryCallEvaluateBody(F, argumentsList);
  // 11. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
  surroundingAgent.executionContextStack.pop(calleeContext);
  // 12. If result.[[Type]] is return, then
  if (result.Type === 'return') {
    // a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).
    if (result.Value instanceof ObjectValue) {
      return NormalCompletion(result.Value);
    }
    // b. If kind is base, return NormalCompletion(thisArgument).
    if (kind === 'base') {
      return NormalCompletion(thisArgument);
    }
    // c. If result.[[Value]] is not undefined, throw a TypeError exception.
    if (result.Value !== Value.undefined) {
      return surroundingAgent.Throw('TypeError', 'DerivedConstructorReturnedNonObject');
    }
  } else {
    /* ReturnIfAbrupt */
    /* node:coverage ignore next */
    if (result && typeof result === 'object' && 'next' in result) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (result instanceof AbruptCompletion) return result;
    /* node:coverage ignore next */
    if (result instanceof Completion) result = result.Value;
  }
  // 14. Return ? constructorEnv.GetThisBinding().
  return constructorEnv.GetThisBinding();
}
FunctionConstructSlot.section = 'https://tc39.es/ecma262/#sec-ecmascript-function-objects-construct-argumentslist-newtarget';
/** https://tc39.es/ecma262/#sec-functionallocate */
function OrdinaryFunctionCreate(functionPrototype, sourceText, ParameterList, Body, thisMode, Scope, PrivateEnv) {
  // 1. Assert: Type(functionPrototype) is Object.
  Assert(functionPrototype instanceof ObjectValue, "functionPrototype instanceof ObjectValue");
  // 2. Let internalSlotsList be the internal slots listed in Table 33.
  const internalSlotsList = ['Environment', 'PrivateEnvironment', 'FormalParameters', 'ECMAScriptCode', 'ConstructorKind', 'Realm', 'ScriptOrModule', 'ThisMode', 'Strict', 'HomeObject', 'SourceText', 'Fields', 'PrivateMethods', 'ClassFieldInitializerName', 'IsClassConstructor', 'HostInitialName'];
  // 3. Let F be ! OrdinaryObjectCreate(functionPrototype, internalSlotsList).
  /* X */
  let _temp10 = OrdinaryObjectCreate(functionPrototype, internalSlotsList);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(functionPrototype, internalSlotsList) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const F = _temp10;
  // 4. Set F.[[Call]] to the definition specified in 10.2.1.
  F.Call = FunctionCallSlot;
  // 5. Set F.[[SourceText]] to sourceText.
  F.SourceText = sourceText;
  // 6. Set F.[[FormalParameters]] to ParameterList.
  F.FormalParameters = ParameterList;
  // 7. Set F.[[ECMAScriptCode]] to Body.
  F.ECMAScriptCode = Body;
  // 8. If the source text matching Body is strict mode code, let Strict be true; else let Strict be false.
  const Strict = isStrictModeCode(Body);
  // 9. Set F.[[Strict]] to Strict.
  F.Strict = Strict;
  // 10. If thisMode is lexical-this, set F.[[ThisMode]] to lexical.
  if (thisMode === 'lexical-this') {
    F.ThisMode = 'lexical';
  } else if (Strict) {
    // 11. Else if Strict is true, set F.[[ThisMode]] to strict.
    F.ThisMode = 'strict';
  } else {
    // 12. Else, set F.[[ThisMode]] to global.
    F.ThisMode = 'global';
  }
  // 13. Set F.[[IsClassConstructor]] to false.
  F.IsClassConstructor = Value.false;
  // 14. Set F.[[Environment]] to Scope.
  F.Environment = Scope;
  // 15. Set F.[[PrivateEnvironment]] to PrivateScope.
  Assert(!!PrivateEnv, "!!PrivateEnv");
  F.PrivateEnvironment = PrivateEnv;
  // 16. Set F.[[ScriptOrModule]] to GetActiveScriptOrModule().
  F.ScriptOrModule = GetActiveScriptOrModule();
  // 17. Set F.[[Realm]] to the current Realm Record.
  F.Realm = surroundingAgent.currentRealmRecord;
  // 18. Set F.[[HomeObject]] to undefined.
  F.HomeObject = Value.undefined;
  // 19. Set F.[[ClassFieldInitializerName]] to empty.
  F.ClassFieldInitializerName = undefined;
  F.PrivateMethods = [];
  F.Fields = [];
  // 20. Let len be the ExpectedArgumentCount of ParameterList.
  const len = ExpectedArgumentCount(ParameterList);
  // 21. Perform ! SetFunctionLength(F, len).
  /* X */
  let _temp11 = SetFunctionLength(F, len);
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionLength(F, len) returned an abrupt completion", {
    cause: _temp11
  });
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  // 22. Return F.
  return F;
}
OrdinaryFunctionCreate.section = 'https://tc39.es/ecma262/#sec-functionallocate';
/** https://tc39.es/ecma262/#sec-makeconstructor */
function MakeConstructor(F, writablePrototype, prototype) {
  Assert(isECMAScriptFunctionObject(F) || F.Call === BuiltinFunctionCall, "isECMAScriptFunctionObject(F) || F.Call === BuiltinFunctionCall");
  if (isECMAScriptFunctionObject(F)) {
    // Assert(!IsConstructor(F)); but not applying type assertion
    Assert(![IsConstructor(F)][0], "![IsConstructor(F)][0]");
    /* X */
    let _temp12 = IsExtensible(F);
    /* node:coverage ignore next */
    if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! IsExtensible(F) returned an abrupt completion", {
      cause: _temp12
    });
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    /* X */
    let _temp13 = HasOwnProperty(F, Value('prototype'));
    /* node:coverage ignore next */
    if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! HasOwnProperty(F, Value('prototype')) returned an abrupt completion", {
      cause: _temp13
    });
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    Assert(_temp12 === Value.true && _temp13 === Value.false, "X(IsExtensible(F)) === Value.true && X(HasOwnProperty(F, Value('prototype'))) === Value.false");
    F.Construct = FunctionConstructSlot;
  }
  F.ConstructorKind = 'base';
  if (writablePrototype === undefined) {
    writablePrototype = Value.true;
  }
  if (prototype === undefined) {
    prototype = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
    /* X */
    let _temp14 = DefinePropertyOrThrow(prototype, Value('constructor'), _Descriptor({
      Value: F,
      Writable: writablePrototype,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    /* node:coverage ignore next */
    if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(prototype, Value('constructor'), Descriptor({\n      Value: F,\n      Writable: writablePrototype,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    })) returned an abrupt completion", {
      cause: _temp14
    });
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  }
  /* X */
  let _temp15 = DefinePropertyOrThrow(F, Value('prototype'), _Descriptor({
    Value: prototype,
    Writable: writablePrototype,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('prototype'), Descriptor({\n    Value: prototype,\n    Writable: writablePrototype,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp15
  });
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
}
MakeConstructor.section = 'https://tc39.es/ecma262/#sec-makeconstructor';
/** https://tc39.es/ecma262/#sec-makeclassconstructor */
function MakeClassConstructor(F) {
  Assert(isECMAScriptFunctionObject(F), "isECMAScriptFunctionObject(F)");
  Assert(F.IsClassConstructor === Value.false, "F.IsClassConstructor === Value.false");
  F.IsClassConstructor = Value.true;
}
MakeClassConstructor.section = 'https://tc39.es/ecma262/#sec-makeclassconstructor';
/** https://tc39.es/ecma262/#sec-makemethod */
function MakeMethod(F, homeObject) {
  Assert(isECMAScriptFunctionObject(F), "isECMAScriptFunctionObject(F)");
  Assert(homeObject instanceof ObjectValue, "homeObject instanceof ObjectValue");
  F.HomeObject = homeObject;
}
MakeMethod.section = 'https://tc39.es/ecma262/#sec-makemethod';
/** https://tc39.es/ecma262/#sec-setfunctionname */
function SetFunctionName(F, name, prefix) {
  // 1. Assert: F is an extensible object that does not have a "name" own property.
  Assert(skipDebugger(IsExtensible(F)) === Value.true && skipDebugger(HasOwnProperty(F, Value('name'))) === Value.false, "skipDebugger(IsExtensible(F)) === Value.true && skipDebugger(HasOwnProperty(F, Value('name'))) === Value.false");
  // 2. If Type(name) is Symbol, then
  if (name instanceof SymbolValue) {
    // a. Let description be name's [[Description]] value.
    const description = name.Description;
    // b. If description is undefined, set name to the empty String.
    if (description === Value.undefined) {
      name = Value('');
    } else {
      // c. Else, set name to the string-concatenation of "[", description, and "]".
      name = Value(`[${description.stringValue()}]`);
    }
  } else if (name instanceof PrivateName) {
    // 3. Else if name is a Private Name, then
    // a. Set name to name.[[Description]].
    name = name.Description;
  }
  // 4. If F has an [[InitialName]] internal slot, then
  if ('InitialName' in F) {
    // a. Set F.[[InitialName]] to name.
    F.InitialName = name;
  }
  if ('HostInitialName' in F) {
    // a. Set F.[[InitialName]] to name.
    F.HostInitialName = name.stringValue();
  }
  // 5. If prefix is present, then
  if (prefix !== undefined) {
    // a. Set name to the string-concatenation of prefix, the code unit 0x0020 (SPACE), and name.
    name = Value(`${prefix.stringValue()} ${name.stringValue()}`);
  }
  // 6. Return ! DefinePropertyOrThrow(F, "name", PropertyDescriptor { [[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
  /* X */
  let _temp16 = DefinePropertyOrThrow(F, Value('name'), _Descriptor({
    Value: name,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('name'), Descriptor({\n    Value: name,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp16
  });
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
}
SetFunctionName.section = 'https://tc39.es/ecma262/#sec-setfunctionname';
/** https://tc39.es/ecma262/#sec-setfunctionlength */
function SetFunctionLength(F$1, length) {
  Assert(isNonNegativeInteger(length) || length === Infinity, "isNonNegativeInteger(length) || length === Infinity");
  // 1. Assert: F is an extensible object that does not have a "length" own property.
  Assert(skipDebugger(IsExtensible(F$1)) === Value.true && skipDebugger(HasOwnProperty(F$1, Value('length'))) === Value.false, "skipDebugger(IsExtensible(F)) === Value.true && skipDebugger(HasOwnProperty(F, Value('length'))) === Value.false");
  // 2. Return ! DefinePropertyOrThrow(F, "length", PropertyDescriptor { [[Value]]: 𝔽(length), [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
  /* X */
  let _temp17 = DefinePropertyOrThrow(F$1, Value('length'), _Descriptor({
    Value: F(length),
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('length'), Descriptor({\n    Value: toNumberValue(length),\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp17
  });
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
}
SetFunctionLength.section = 'https://tc39.es/ecma262/#sec-setfunctionlength';
function nativeCall(F, argumentsList, thisArgument, newTarget) {
  return F.nativeFunction(argumentsList, {
    thisValue: thisArgument || Value.undefined,
    NewTarget: newTarget || Value.undefined
  });
  // by this notation we can keep the F.nativeFunction name in the stack trace
  // return Reflect['apply'](F.nativeFunction, F, [argumentsList, {
  //   thisValue: thisArgument || Value.undefined,
  //   NewTarget: newTarget || Value.undefined,
  // }]);
}
function* BuiltinFunctionCall(thisArgument, argumentsList) {
  const F = this;

  // const callerContext = surroundingAgent.runningExecutionContext;
  // If callerContext is not already suspended, suspend callerContext.
  const calleeContext = new ExecutionContext();
  calleeContext.Function = F;
  const calleeRealm = F.Realm;
  calleeContext.Realm = calleeRealm;
  calleeContext.ScriptOrModule = F.ScriptOrModule;
  // 8. Perform any necessary implementation-defined initialization of calleeContext.
  surroundingAgent.executionContextStack.push(calleeContext);
  let result = nativeCall(F, argumentsList, thisArgument, Value.undefined);
  if (result && 'next' in result) {
    result = yield* result;
  }
  // Remove calleeContext from the execution context stack and
  // restore callerContext as the running execution context.
  surroundingAgent.executionContextStack.pop(calleeContext);
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (result && typeof result === 'object' && 'next' in result) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (result instanceof AbruptCompletion) return result;
  /* node:coverage ignore next */
  if (result instanceof Completion) result = result.Value;
  return result || Value.undefined;
}
function* BuiltinFunctionConstruct(argumentsList, newTarget) {
  const F = this;

  // const callerContext = surroundingAgent.runningExecutionContext;
  // If callerContext is not already suspended, suspend callerContext.
  const calleeContext = new ExecutionContext();
  calleeContext.Function = F;
  const calleeRealm = F.Realm;
  calleeContext.Realm = calleeRealm;
  calleeContext.ScriptOrModule = F.ScriptOrModule;
  // 8. Perform any necessary implementation-defined initialization of calleeContext.
  surroundingAgent.executionContextStack.push(calleeContext);
  surroundingAgent.runningExecutionContext.callSite.constructCall = true;
  let result = nativeCall(F, argumentsList, undefined, newTarget);
  if (result && 'next' in result) {
    result = yield* result;
  }
  // Remove calleeContext from the execution context stack and
  // restore callerContext as the running execution context.
  surroundingAgent.executionContextStack.pop(calleeContext);
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (result && typeof result === 'object' && 'next' in result) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (result instanceof AbruptCompletion) return result;
  /* node:coverage ignore next */
  if (result instanceof Completion) result = result.Value;
  Assert(result instanceof ObjectValue, "result instanceof ObjectValue");
  return result;
}

/** https://tc39.es/ecma262/#sec-createbuiltinfunction */
function CreateBuiltinFunction(steps, length, name, internalSlotsList, realm, prototype, prefix, isConstructor = Value.false) {
  // 1. Assert: steps is either a set of algorithm steps or other definition of a function's behaviour provided in this specification.
  Assert(typeof steps === 'function', "typeof steps === 'function'");
  // 2. If realm is not present, set realm to the current Realm Record.
  if (realm === undefined) {
    realm = surroundingAgent.currentRealmRecord;
  }
  // 3. Assert: realm is a Realm Record.
  Assert(realm instanceof Realm, "realm instanceof Realm");
  // 4. If prototype is not present, set prototype to realm.[[Intrinsics]].[[%Function.prototype%]].
  if (prototype === undefined) {
    prototype = realm.Intrinsics['%Function.prototype%'];
  }
  // 5. Let func be a new built-in function object that when called performs the action described by steps. The new function object has internal slots whose names are the elements of internalSlotsList.
  /* X */
  let _temp18 = MakeBasicObject(['Prototype', 'Extensible', 'Realm', 'ScriptOrModule', 'InitialName'].concat(internalSlotsList));
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! MakeBasicObject(['Prototype', 'Extensible', 'Realm', 'ScriptOrModule', 'InitialName'].concat(internalSlotsList)) returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  const func = _temp18;
  func.Call = BuiltinFunctionCall;
  if (isConstructor === Value.true) {
    func.Construct = BuiltinFunctionConstruct;
  }
  func.nativeFunction = steps;
  // 6. Set func.[[Realm]] to realm.
  func.Realm = realm;
  // 7. Set func.[[Prototype]] to prototype.
  func.Prototype = prototype;
  // 8. Set func.[[Extensible]] to true.
  func.Extensible = Value.true;
  // 9. Set func.[[ScriptOrModule]] to null.
  func.ScriptOrModule = Value.null;
  // 10. Set func.[[InitialName]] to null.
  func.InitialName = Value.null;
  // 11. Perform ! SetFunctionLength(func, length).
  /* X */
  let _temp19 = SetFunctionLength(func, length);
  /* node:coverage ignore next */
  if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionLength(func, length) returned an abrupt completion", {
    cause: _temp19
  });
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  // 12. If prefix is not present, then
  if (prefix === undefined) {
    /* X */
    let _temp20 = SetFunctionName(func, name);
    /* node:coverage ignore next */
    if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) _temp20 = skipDebugger(_temp20);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionName(func, name) returned an abrupt completion", {
      cause: _temp20
    });
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  } else {
    /* X */
    let _temp21 = SetFunctionName(func, name, prefix);
    /* node:coverage ignore next */
    if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) _temp21 = skipDebugger(_temp21);
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! SetFunctionName(func, name, prefix) returned an abrupt completion", {
      cause: _temp21
    });
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  }
  // 13. Return func.
  return func;
}
CreateBuiltinFunction.section = 'https://tc39.es/ecma262/#sec-createbuiltinfunction';
/** This is a helper function to define non-spec host functions. */
CreateBuiltinFunction.from = (steps, name = steps.name) => CreateBuiltinFunction(Reflect.apply.bind(null, steps, null), steps.length, Value(name), []);

/** https://tc39.es/ecma262/#sec-preparefortailcall */
function PrepareForTailCall() {
  // 1. Let leafContext be the running execution context.
  const leafContext = surroundingAgent.runningExecutionContext;
  // 2. Suspend leafContext.
  // 3. Pop leafContext from the execution context stack. The execution context now on the top of the stack becomes the running execution context.
  surroundingAgent.executionContextStack.pop(leafContext);
  // 4. Assert: leafContext has no further use. It will never be activated as the running execution context.
  leafContext.poppedForTailCall = true;
}
PrepareForTailCall.section = 'https://tc39.es/ecma262/#sec-preparefortailcall';
/** NON-SPEC */
function IntrinsicsFunctionToString(F) {
  /* X */
  let _temp22 = FunctionProto_toString([], {
    thisValue: F,
    NewTarget: Value.undefined
  });
  /* node:coverage ignore next */
  if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) _temp22 = skipDebugger(_temp22);
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) throw new Assert.Error("! FunctionProto_toString([], { thisValue: F, NewTarget: Value.undefined }) returned an abrupt completion", {
    cause: _temp22
  });
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  return _temp22.stringValue();
}

/** https://tc39.es/ecma262/#sec-generator-objects */

/** https://tc39.es/ecma262/#sec-generatorstart */
function GeneratorStart(generator, generatorBody) {
  // 1. Assert: The value of generator.[[GeneratorState]] is suspended-start.
  Assert(generator.GeneratorState === 'suspendedStart', "generator.GeneratorState === 'suspendedStart'");
  // 2. Let genContext be the running execution context.
  const genContext = surroundingAgent.runningExecutionContext;
  // 3. Set the Generator component of genContext to generator.
  genContext.Generator = generator;
  // 4. Let closure be a new Abstract Closure with no parameters that captures generatorBody
  //    and performs the following steps when called:
  const closure = function* closure() {
    // a. Let acGenContext be the running execution context.
    const acGenContext = surroundingAgent.runningExecutionContext;
    // b. Let acGenerator be the Generator component of acGenContext.
    const acGenerator = acGenContext.Generator;
    // c. If generatorBody is a Parse Node, then
    //   i. Let result be Completion(Evaluation of generatorBody).
    // d. Else,
    //   i. Assert: generatorBody is an Abstract Closure with no parameters.
    //   ii. Let result be generatorBody().
    const result = EnsureCompletion(
    // Note: Engine262 can only perform the "If generatorBody is an Abstract Closure" check:
    yield* typeof generatorBody === 'function' ? generatorBody() : Evaluate(generatorBody));
    // e. Assert: If we return here, the generator either threw an exception or performed either
    //    an implicit or explicit return.
    // f. Remove acGenContext from the execution context stack and restore the execution context
    //    that is at the top of the execution context stack as the running execution context.
    surroundingAgent.executionContextStack.pop(acGenContext);
    // g. Set acGenerator.[[GeneratorState]] to completed.
    acGenerator.GeneratorState = 'completed';
    // h. NOTE: Once a generator enters the completed state it never leaves it and its associated execution context is never resumed. Any execution state associated with acGenerator can be discarded at this point.

    let resultValue;
    if (result instanceof NormalCompletion) {
      // i. If result is a normal completion, then
      //   i. Let resultValue be undefined.
      resultValue = Value.undefined;
    } else if (result instanceof ReturnCompletion) {
      // j. Else if result is a return completion, then
      //   i. Let resultValue be result.[[Value]].
      resultValue = result.Value;
    } else {
      // k. Else,
      //   i. Assert: result is a throw completion.
      //   ii. Return ? result.
      Assert(result instanceof ThrowCompletion, "result instanceof ThrowCompletion");
      return result;
    }
    // l. Return CreateIteratorResultObject(resultValue, true).
    return CreateIteratorResultObject(resultValue, Value.true);
  };

  // 5. Set the code evaluation state of genContext such that when evaluation is resumed
  //    for that execution context, closure will be called with no arguments.
  genContext.codeEvaluationState = function* resumer() {
    return yield* closure();
  }();

  // 6. Set generator.[[GeneratorContext]] to genContext.
  generator.GeneratorContext = genContext;
  // 7. Return unused.
}
GeneratorStart.section = 'https://tc39.es/ecma262/#sec-generatorstart';
function generatorBrandToErrorMessageType(generatorBrand) {
  let expectedType;
  if (generatorBrand !== undefined) {
    expectedType = generatorBrand.stringValue();
    if (expectedType.startsWith('%') && expectedType.endsWith('Prototype%')) {
      expectedType = expectedType.slice(1, -10).trim();
      if (expectedType.endsWith('Iterator')) {
        expectedType = `${expectedType.slice(0, -8).trim()} Iterator`;
      }
    }
  }
  return expectedType;
}

/** https://tc39.es/ecma262/#sec-generatorvalidate */
function GeneratorValidate(generator, generatorBrand) {
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(generator, 'GeneratorState');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 2. Perform ? RequireInternalSlot(generator, [[GeneratorBrand]]).
  /* ReturnIfAbrupt */
  let _temp2 = RequireInternalSlot(generator, 'GeneratorBrand');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 3. If generator.[[GeneratorBrand]] is not the same value as generatorBrand, throw a TypeError exception.
  const brand = generator.GeneratorBrand;
  if (brand === undefined || generatorBrand === undefined ? brand !== generatorBrand : SameValue(brand, generatorBrand) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', generatorBrandToErrorMessageType(generatorBrand) || 'Generator', generator);
  }
  // 4. Assert: generator also has a [[GeneratorContext]] internal slot.
  Assert('GeneratorContext' in generator, "'GeneratorContext' in generator");
  // 5. Let state be generator.[[GeneratorState]].
  const state = generator.GeneratorState;
  // 6. If state is executing, throw a TypeError exception.
  if (state === 'executing') {
    return surroundingAgent.Throw('TypeError', 'GeneratorRunning');
  }
  // 7. Return state.
  return state;
}
GeneratorValidate.section = 'https://tc39.es/ecma262/#sec-generatorvalidate';
/** https://tc39.es/ecma262/#sec-generatorresume */
function* GeneratorResume(generator, value, generatorBrand) {
  /* ReturnIfAbrupt */
  let _temp3 = GeneratorValidate(generator, generatorBrand);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 1. Let state be ? GeneratorValidate(generator, generatorBrand).
  const state = _temp3;
  // 2. If state is completed, return CreateIteratorResultObject(undefined, true).
  if (state === 'completed') {
    /* X */
    let _temp4 = CreateIteratorResultObject(Value.undefined, Value.true);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorResultObject(Value.undefined, Value.true) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    return _temp4;
  }
  // 3. Assert: state is either suspendedStart or suspendedYield.
  Assert(state === 'suspendedStart' || state === 'suspendedYield', "state === 'suspendedStart' || state === 'suspendedYield'");
  // 4. Let genContext be generator.[[GeneratorContext]].
  const genContext = generator.GeneratorContext;
  // 5. Let methodContext be the running execution context.
  // 6. Suspend methodContext.
  const methodContext = surroundingAgent.runningExecutionContext;
  // 7. Set generator.[[GeneratorState]] to executing.
  generator.GeneratorState = 'executing';
  // 8. Push genContext onto the execution context stack.
  surroundingAgent.executionContextStack.push(genContext);
  // 9. Resume the suspended evaluation of genContext using NormalCompletion(value) as
  //    the result of the operation that suspended it. Let result be the value returned by
  //    the resumed computation.
  const result = EnsureCompletion(yield* resume(genContext, {
    type: 'generator-resume',
    value: NormalCompletion(value || Value.undefined)
  }));
  // 10. Assert: When we return here, genContext has already been removed from the execution
  //     context stack and methodContext is the currently running execution context.
  Assert(surroundingAgent.runningExecutionContext === methodContext, "surroundingAgent.runningExecutionContext === methodContext");
  // 11. Return Completion(result).
  return Completion(result);
}
GeneratorResume.section = 'https://tc39.es/ecma262/#sec-generatorresume';
/** https://tc39.es/ecma262/#sec-generatorresumeabrupt */
function* GeneratorResumeAbrupt(generator, abruptCompletion, generatorBrand) {
  /* ReturnIfAbrupt */
  let _temp5 = GeneratorValidate(generator, generatorBrand);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 1. Let state be ? GeneratorValidate(generator, generatorBrand).
  let state = _temp5;
  // 2. If state is suspendedStart, then
  if (state === 'suspendedStart') {
    // a. Set generator.[[GeneratorState]] to completed.
    generator.GeneratorState = 'completed';
    // b. Once a generator enters the completed state it never leaves it and its
    //    associated execution context is never resumed. Any execution state associate
    //    with generator can be discarded at this point.
    generator.GeneratorContext = null;
    // c. Set state to completed.
    state = 'completed';
  }
  // 3. If state is completed, then
  if (state === 'completed') {
    // a. If abruptCompletion.[[Type]] is return, then
    if (abruptCompletion.Type === 'return') {
      /* X */
      let _temp6 = CreateIteratorResultObject(abruptCompletion.Value, Value.true);
      /* node:coverage ignore next */
      if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorResultObject(abruptCompletion.Value, Value.true) returned an abrupt completion", {
        cause: _temp6
      });
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      // i. Return CreateIteratorResultObject(abruptCompletion.[[Value]], true).
      return _temp6;
    }
    // b. Return Completion(abruptCompletion).
    return Completion(abruptCompletion);
  }
  // 4. Assert: state is suspendedYield.
  Assert(state === 'suspendedYield', "state === 'suspendedYield'");
  // 5. Let genContext be generator.[[GeneratorContext]].
  const genContext = generator.GeneratorContext;
  // 6. Let methodContext be the running execution context.
  // 7. Suspend methodContext.
  const methodContext = surroundingAgent.runningExecutionContext;
  // 8. Set generator.[[GeneratorState]] to executing.
  generator.GeneratorState = 'executing';
  // 9. Push genContext onto the execution context stack.
  surroundingAgent.executionContextStack.push(genContext);
  // 10. Resume the suspended evaluation of genContext using abruptCompletion as the
  //     result of the operation that suspended it. Let result be the completion record
  //     returned by the resumed computation.
  const result = EnsureCompletion(yield* resume(genContext, {
    type: 'generator-resume',
    value: abruptCompletion
  }));
  // 11. Assert: When we return here, genContext has already been removed from the
  //     execution context stack and methodContext is the currently running execution context.
  Assert(surroundingAgent.runningExecutionContext === methodContext, "surroundingAgent.runningExecutionContext === methodContext");
  // 12. Return Completion(result).
  return Completion(result);
}
GeneratorResumeAbrupt.section = 'https://tc39.es/ecma262/#sec-generatorresumeabrupt';
/** https://tc39.es/ecma262/#sec-getgeneratorkind */
function GetGeneratorKind() {
  // 1. Let genContext be the running execution context.
  const genContext = surroundingAgent.runningExecutionContext;
  // 2. If genContext does not have a Generator component, return non-generator.
  if (!genContext.Generator) {
    return 'non-generator';
  }
  // 3. Let generator be the Generator component of genContext.
  const generator = genContext.Generator;
  // 4. If generator has an [[AsyncGeneratorState]] internal slot, return async.
  if ('AsyncGeneratorState' in generator) {
    return 'async';
  }
  // 5. Else, return sync.
  return 'sync';
}
GetGeneratorKind.section = 'https://tc39.es/ecma262/#sec-getgeneratorkind';
/** https://tc39.es/ecma262/#sec-generatoryield */
function* GeneratorYield(iterNextObj) {
  // 1. Assert: iterNextObj is an Object that implements the IteratorResult interface.
  // 2. Let genContext be the running execution context.
  const genContext = surroundingAgent.runningExecutionContext;
  // 3. Assert: genContext is the execution context of a generator.
  Assert(genContext.Generator !== undefined, "genContext.Generator !== undefined");
  // 4. Let generator be the value of the Generator component of genContext.
  const generator = genContext.Generator;
  // 5. Assert: GetGeneratorKind is sync.
  Assert(GetGeneratorKind() === 'sync', "GetGeneratorKind() === 'sync'");
  // 6. Set generator.GeneratorState to suspendedYield.
  generator.GeneratorState = 'suspendedYield';
  // 7. Remove genContext from the execution context stack.
  surroundingAgent.executionContextStack.pop(genContext);
  // 8. Set the code evaluation state of genContext such that when evaluation is resumed with
  //    a Completion resumptionValue the following steps will be performed:
  //      a. Return resumptionValue
  const resumptionValue = yield {
    type: 'yield',
    value: iterNextObj
  };
  Assert(resumptionValue.type === 'generator-resume', "resumptionValue.type === 'generator-resume'");
  // 9. Return NormalCompletion(iterNextObj).
  return resumptionValue.value;
  // 10. NOTE: this returns to the evaluation of the operation that had most previously resumed evaluation of genContext.
}
GeneratorYield.section = 'https://tc39.es/ecma262/#sec-generatoryield';
/** https://tc39.es/ecma262/#sec-yield */
function* Yield(value) {
  // 1. Let generatorKind be GetGeneratorKind().
  const generatorKind = GetGeneratorKind();
  // 2. If generatorKind is async, return ? AsyncGeneratorYield(? Await(value)).
  if (generatorKind === 'async') {
    /* ReturnIfAbrupt */
    let _temp7 = yield* Await(value);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    return yield* AsyncGeneratorYield(_temp7);
  }
  // 3. Otherwise, return ? GeneratorYield(CreateIteratorResultObject(value, false)).
  return yield* GeneratorYield(CreateIteratorResultObject(value, Value.false));
}
Yield.section = 'https://tc39.es/ecma262/#sec-yield';
/** https://tc39.es/ecma262/#sec-createiteratorfromclosure */
function CreateIteratorFromClosure(closure, generatorBrand, generatorPrototype, extraSlots, enclosedValues) {
  Assert(typeof closure === 'function', "typeof closure === 'function'");
  // 1. NOTE: closure can contain uses of the Yield shorthand to yield an IteratorResult object.
  // 2. If extraSlots is not present, set extraSlots to a new empty List.
  extraSlots ??= [];
  // 3. Let internalSlotsList be the list-concatenation of extraSlots and « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ».
  const internalSlotsList = extraSlots.concat(['GeneratorState', 'GeneratorContext', 'GeneratorBrand']);
  // 4. Let generator be OrdinaryObjectCreate(generatorPrototype, internalSlotsList).
  const generator = OrdinaryObjectCreate(generatorPrototype, internalSlotsList);
  // 5. Set generator.[[GeneratorBrand]] to generatorBrand.
  generator.GeneratorBrand = generatorBrand;
  // 6. Set generator.[[GeneratorState]] to suspended-start.
  generator.GeneratorState = 'suspendedStart';

  // NON-SPEC
  if (enclosedValues && extraSlots.includes('HostCapturedValues')) {
    generator.HostCapturedValues = enclosedValues.slice();
  }

  // 7. Let callerContext be the running execution context.
  const callerContext = surroundingAgent.runningExecutionContext;
  // 8. Let calleeContext be a new execution context.
  const calleeContext = new ExecutionContext();
  // 9. Set the Function of calleeContext to null.
  calleeContext.Function = Value.null;
  // 10. Set the Realm of calleeContext to the current Realm Record.
  calleeContext.Realm = surroundingAgent.currentRealmRecord;
  // 11. Set the ScriptOrModule of calleeContext to callerContext's ScriptOrModule.
  calleeContext.ScriptOrModule = callerContext.ScriptOrModule;
  // 12. If callerContext is not already suspended, suspend callerContext.
  // 13. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
  surroundingAgent.executionContextStack.push(calleeContext);
  // 14. Perform GeneratorStart(generator, closure).
  GeneratorStart(generator, closure);
  // 15. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
  surroundingAgent.executionContextStack.pop(calleeContext);
  // 16. Return generator.
  return generator;
}
CreateIteratorFromClosure.section = 'https://tc39.es/ecma262/#sec-createiteratorfromclosure';

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-global-object */

/** https://tc39.es/ecma262/#sec-performeval */
function* PerformEval(x, callerRealm, strictCaller, direct) {
  // 1. Assert: If direct is false, then strictCaller is also false.
  if (direct === false) {
    Assert(strictCaller === false, "strictCaller === false");
  }
  // 2. If Type(x) is not String, return x.
  if (!(x instanceof JSStringValue)) {
    return x;
  }
  // 3. Let evalRealm be the current Realm Record.
  const evalRealm = surroundingAgent.currentRealmRecord;
  // 4. Perform ? HostEnsureCanCompileStrings(callerRealm, evalRealm).
  /* ReturnIfAbrupt */
  let _temp = HostEnsureCanCompileStrings(callerRealm, evalRealm);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 5. Let inFunction be false.
  let inFunction = false;
  // 6. Let inMethod be false.
  let inMethod = false;
  // 7. Let inDerivedConstructor be false.
  let inDerivedConstructor = false;
  // 8. Let inClassFieldInitializer be false.
  let inClassFieldInitializer = false;
  // 9. If direct is true, then
  if (direct === true) {
    /* X */
    let _temp2 = GetThisEnvironment();
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! GetThisEnvironment() returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // a. Let thisEnv be ! GetThisEnvironment().
    const thisEnv = _temp2;
    // b. If thisEnv is a function Environment Record, then
    if (thisEnv instanceof FunctionEnvironmentRecord) {
      // i. Let F be thisEnv.[[FunctionObject]].
      const F = thisEnv.FunctionObject;
      // ii. Let inFunction be true.
      inFunction = true;
      // iii. Let inMethod be thisEnv.HasSuperBinding().
      inMethod = thisEnv.HasSuperBinding() === Value.true;
      // iv. If F.[[ConstructorKind]] is derived, set inDerivedConstructor to true.
      if (F.ConstructorKind === 'derived') {
        inDerivedConstructor = true;
      }
      // v. Let classFieldInitializerName be F.[[ClassFieldInitializerName]].
      const classFieldInitializerName = F.ClassFieldInitializerName;
      // vi. If classFieldInitializerName is not empty, set inClassFieldInitializer to true.
      if (classFieldInitializerName !== undefined) {
        inClassFieldInitializer = true;
      }
    }
  }
  // 10. Perform the following substeps in an implementation-dependent order, possibly interleaving parsing and error detection:
  //   a. Let script be ParseText(! StringToCodePoints(x), Script).
  //   b. If script is a List of errors, throw a SyntaxError exception.
  //   c. If script Contains ScriptBody is false, return undefined.
  //   d. Let body be the ScriptBody of script.
  //   e. If inFunction is false, and body Contains NewTarget, throw a SyntaxError exception.
  //   f. If inMethod is false, and body Contains SuperProperty, throw a SyntaxError exception.
  //   g. If inDerivedConstructor is false, and body Contains SuperCall, throw a SyntaxError exception.
  //   h. If inClassFieldInitializer is true, and ContainsArguments of body is true, throw a SyntaxError exception.
  const privateIdentifiers = [];
  let pointer = direct ? surroundingAgent.runningExecutionContext.PrivateEnvironment : Value.null;
  while (!(pointer instanceof NullValue)) {
    for (const binding of pointer.Names) {
      privateIdentifiers.push(binding.Description.stringValue());
    }
    pointer = pointer.OuterPrivateEnvironment;
  }
  const script = wrappedParse({
    source: x.stringValue()
  }, parser => parser.scope.with({
    strict: strictCaller,
    newTarget: inFunction,
    superProperty: inMethod,
    superCall: inDerivedConstructor,
    private: privateIdentifiers.length > 0
  }, () => {
    privateIdentifiers.forEach(name => {
      parser.scope.privateScope.names.set(name, new Set(['field']));
    });
    return parser.parseScript();
  }));
  if (Array.isArray(script)) {
    return ThrowCompletion(script[0]);
  }
  if (!script.ScriptBody) {
    return Value.undefined;
  }
  const body = script.ScriptBody;
  if (inClassFieldInitializer && ContainsArguments(body)) {
    return surroundingAgent.Throw('SyntaxError', 'UnexpectedToken');
  }
  // 11. If strictCaller is true, let strictEval be true.
  // 12. Else, let strictEval be IsStrict of script.
  let strictEval;
  if (strictCaller === true) {
    strictEval = true;
  } else {
    strictEval = IsStrict(script);
  }
  // 13. Let runningContext be the running execution context.
  const runningContext = surroundingAgent.runningExecutionContext;
  let lexEnv;
  let varEnv;
  let privateEnv;
  // 14. NOTE: If direct is true, runningContext will be the execution context that performed the direct eval.
  //     If direct is false, runningContext will be the execution context for the invocation of the eval function.
  // 15. If direct is true, then
  if (direct === true) {
    // a. Let lexEnv be NewDeclarativeEnvironment(runningContext's LexicalEnvironment).
    lexEnv = new DeclarativeEnvironmentRecord(runningContext.LexicalEnvironment);
    // b. Let varEnv be runningContext's VariableEnvironment.
    varEnv = runningContext.VariableEnvironment;
    // c. Let privateEnv be runningContext's PrivateEnvironment.
    privateEnv = runningContext.PrivateEnvironment;
  } else {
    // 16. Else,
    // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).
    lexEnv = new DeclarativeEnvironmentRecord(evalRealm.GlobalEnv);
    // b. Let varEnv be evalRealm.[[GlobalEnv]].
    varEnv = evalRealm.GlobalEnv;
    // c. Let privateEnv be null.
    privateEnv = Value.null;
  }
  // 17. If strictEval is true, set varEnv to lexEnv.
  if (strictEval === true) {
    varEnv = lexEnv;
  }
  // 18. If runningContext is not already suspended, suspend runningContext.
  // 19. Let evalContext be a new ECMAScript code execution context.
  const evalContext = new ExecutionContext();
  // 20. Set evalContext's Function to null.
  evalContext.Function = Value.null;
  // 21. Set evalContext's Realm to evalRealm.
  evalContext.Realm = evalRealm;
  // 22. Set evalContext's ScriptOrModule to runningContext's ScriptOrModule.
  evalContext.ScriptOrModule = runningContext.ScriptOrModule;
  // 23. Set evalContext's VariableEnvironment to varEnv.
  evalContext.VariableEnvironment = varEnv;
  // 24. Set evalContext's LexicalEnvironment to lexEnv.
  evalContext.LexicalEnvironment = lexEnv;
  // 25. Set evalContext's PrivateEnvironment to privateEnv.
  evalContext.PrivateEnvironment = privateEnv;
  // 26. Push evalContext onto the execution context stack.
  surroundingAgent.executionContextStack.push(evalContext);
  // 27. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, privateEnv, strictEval).
  let result = EnsureCompletion(yield* EvalDeclarationInstantiation(body, varEnv, lexEnv, privateEnv, strictEval));
  // 28. If result.[[Type]] is normal, then
  if (result.Type === 'normal') {
    // a. Set result to the result of evaluating body.
    result = EnsureCompletion(yield* Evaluate(body));
  }
  // 29. If result.[[Type]] is normal and result.[[Value]] is empty, then
  if (result.Type === 'normal' && result.Value === undefined) {
    // a. Set result to NormalCompletion(undefined).
    result = NormalCompletion(Value.undefined);
  }
  // 30. Suspend evalContext and remove it from the execution context stack.
  // 31. Resume the context that is now on the top of the execution context stack as the running execution context.
  surroundingAgent.executionContextStack.pop(evalContext);
  // 32. Return Completion(result).
  return result;
}
PerformEval.section = 'https://tc39.es/ecma262/#sec-global-object';
/** https://tc39.es/ecma262/#sec-evaldeclarationinstantiation */
function* EvalDeclarationInstantiation(body, varEnv, lexEnv, privateEnv, strict) {
  // 1. Let varNames be the VarDeclaredNames of body.
  const varNames = VarDeclaredNames(body);
  // 2. Let varDeclarations be the VarScopedDeclarations of body.
  const varDeclarations = VarScopedDeclarations(body);
  // 3. If strict is false, then
  if (strict === false) {
    // a. If varEnv is a global Environment Record, then
    if (varEnv instanceof GlobalEnvironmentRecord) {
      // i. For each name in varNames, do
      for (const name of varNames) {
        // 1. If varEnv.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
        if ((yield* varEnv.HasLexicalDeclaration(name)) === Value.true) {
          return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
        }
        // 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.
      }
    }
    // b. Let thisLex be lexEnv.
    let thisEnv = lexEnv;
    // c. Assert: The following loop will terminate.
    // d. Repeat, while thisEnv is not the same as varEnv,
    while (thisEnv !== varEnv) {
      // i. If thisEnv is not an object Environment Record, then
      if (!(thisEnv instanceof ObjectEnvironmentRecord)) {
        // 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.
        // 2. For each name in varNames, do
        for (const name of varNames) {
          // a. If thisEnv.HasBinding(name) is true, then
          if ((yield* thisEnv.HasBinding(name)) === Value.true) {
            // i. Throw a SyntaxError exception.
            return surroundingAgent.Throw('SyntaxError', 'AlreadyDeclared', name);
            // ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.
          }
          // b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration
        }
      }
      // ii. Set thisEnv to thisEnv.[[OuterEnv]].
      thisEnv = thisEnv.OuterEnv;
    }
  }
  // 4. Let privateIdentifiers be a new empty List.
  const privateIdentifiers = [];
  // 5. Let pointer be privateEnv.
  let pointer = privateEnv;
  // 6. Repeat, while pointer is not null,
  while (!(pointer instanceof NullValue)) {
    // a. For each Private Name binding of pointer.[[Names]], do
    for (const binding of pointer.Names) {
      // i. If privateIdentifiers does not contain binding.[[Description]], append binding.[[Description]] to privateIdentifiers.
      privateIdentifiers.push(binding.Description);
    }
    // b. Set pointer to pointer.[[OuterPrivateEnvironment]].
    pointer = pointer.OuterPrivateEnvironment;
  }
  // 7. If AllPrivateIdentifiersValid of body with argument privateIdentifiers is false, throw a SyntaxError exception.
  Assert(true, "true");
  // 8. Let functionsToInitialize be a new empty List.
  const functionsToInitialize = [];
  // 9. Let declaredFunctionNames be a new empty List.
  const declaredFunctionNames = new JSStringSet();
  // 10. For each d in varDeclarations, in reverse list order, do
  for (const d of [...varDeclarations].reverse()) {
    // a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
    if (d.type !== 'VariableDeclaration' && d.type !== 'ForBinding' && d.type !== 'BindingIdentifier') {
      // i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.
      Assert(d.type === 'FunctionDeclaration' || d.type === 'GeneratorDeclaration' || d.type === 'AsyncFunctionDeclaration' || d.type === 'AsyncGeneratorDeclaration', "d.type === 'FunctionDeclaration'\n             || d.type === 'GeneratorDeclaration'\n             || d.type === 'AsyncFunctionDeclaration'\n             || d.type === 'AsyncGeneratorDeclaration'");
      // ii. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
      // iii. Let fn be the sole element of the BoundNames of d.
      const fn = BoundNames(d)[0];
      // iv. If fn is not an element of declaredFunctionNames, then
      if (!declaredFunctionNames.has(fn)) {
        // 1. If varEnv is a global Environment Record, then
        if (varEnv instanceof GlobalEnvironmentRecord) {
          /* ReturnIfAbrupt */
          let _temp3 = yield* varEnv.CanDeclareGlobalFunction(fn);
          /* node:coverage ignore next */
          if (_temp3 instanceof AbruptCompletion) return _temp3;
          /* node:coverage ignore next */
          if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
          // a. Let fnDefinable be ? varEnv.CanDeclareGlobalFunction(fn).
          const fnDefinable = _temp3;
          // b. Let fnDefinable be ? varEnv.CanDeclareGlobalFunction(fn).
          if (fnDefinable === Value.false) {
            return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', fn);
          }
        }
        // 2. Append fn to declaredFunctionNames.
        declaredFunctionNames.add(fn);
        // 3. Insert d as the first element of functionsToInitialize.
        functionsToInitialize.unshift(d);
      }
    }
  }
  // 11. NOTE: Annex B.3.3.3 adds additional steps at this point.
  // 12. Let declaredVarNames be a new empty List.
  const declaredVarNames = new JSStringSet();
  // 13. For each d in varDeclarations, do
  for (const d of varDeclarations) {
    // a. If d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, then
    if (d.type === 'VariableDeclaration' || d.type === 'ForBinding' || d.type === 'BindingIdentifier') {
      // i. For each String vn in the BoundNames of d, do
      for (const vn of BoundNames(d)) {
        // 1. If vn is not an element of declaredFunctionNames, then
        if (!declaredFunctionNames.has(vn)) {
          // a. If varEnv is a global Environment Record, then
          if (varEnv instanceof GlobalEnvironmentRecord) {
            /* ReturnIfAbrupt */
            let _temp4 = yield* varEnv.CanDeclareGlobalVar(vn);
            /* node:coverage ignore next */
            if (_temp4 instanceof AbruptCompletion) return _temp4;
            /* node:coverage ignore next */
            if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
            // i. Let vnDefinable be ? varEnv.CanDeclareGlobalVar(vn).
            const vnDefinable = _temp4;
            // ii. If vnDefinable is false, throw a TypeError exception.
            if (vnDefinable === Value.false) {
              return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', vn);
            }
          }
          // b. If vn is not an element of declaredVarNames, then
          if (!declaredVarNames.has(vn)) {
            // i. Append vn to declaredVarNames.
            declaredVarNames.add(vn);
          }
        }
      }
    }
  }
  // 14. NOTE: No abnormal terminations occur after this algorithm step unless
  //     varEnv is a global Environment Record and the global object is a Proxy exotic object.
  // 15. Let lexDeclarations be the LexicallyScopedDeclarations of body.
  const lexDeclarations = LexicallyScopedDeclarations(body);
  // 16. For each element d in lexDeclarations, do
  for (const d of lexDeclarations) {
    // a. NOTE: Lexically declared names are only instantiated here but not initialized.
    // b. For each element dn of the BoundNames of d, do
    for (const dn of BoundNames(d)) {
      // i. If IsConstantDeclaration of d is true, then
      if (IsConstantDeclaration(d)) {
        /* ReturnIfAbrupt */
        let _temp5 = lexEnv.CreateImmutableBinding(dn, Value.true);
        /* node:coverage ignore next */
        if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) return _temp5;
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      } else {
        /* ReturnIfAbrupt */
        let _temp6 = yield* lexEnv.CreateMutableBinding(dn, Value.false);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      }
    }
  }
  // 17. For each Parse Node f in functionsToInitialize, do
  for (const f of functionsToInitialize) {
    // a. Let fn be the sole element of the BoundNames of f.
    const fn = BoundNames(f)[0];
    // b. Let fn be the sole element of the BoundNames of f.
    const fo = InstantiateFunctionObject(f, lexEnv, privateEnv);
    // c. If varEnv is a global Environment Record, then
    if (varEnv instanceof GlobalEnvironmentRecord) {
      /* ReturnIfAbrupt */
      let _temp7 = yield* varEnv.CreateGlobalFunctionBinding(fn, fo, Value.true);
      /* node:coverage ignore next */
      if (_temp7 instanceof AbruptCompletion) return _temp7;
      /* node:coverage ignore next */
      if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    } else {
      // d. Else,
      // i. Let bindingExists be varEnv.HasBinding(fn).
      const bindingExists = yield* varEnv.HasBinding(fn);
      // ii. If bindingExists is false, then
      if (bindingExists === Value.false) {
        /* X */
        let _temp8 = varEnv.CreateMutableBinding(fn, Value.true);
        /* node:coverage ignore next */
        if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
        /* node:coverage ignore next */
        if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! varEnv.CreateMutableBinding(fn, Value.true) returned an abrupt completion", {
          cause: _temp8
        });
        /* node:coverage ignore next */
        if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        // 3. Perform ! varEnv.InitializeBinding(fn, fo).
        /* X */
        let _temp9 = varEnv.InitializeBinding(fn, fo);
        /* node:coverage ignore next */
        if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
        /* node:coverage ignore next */
        if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! varEnv.InitializeBinding(fn, fo) returned an abrupt completion", {
          cause: _temp9
        });
        /* node:coverage ignore next */
        if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
      } else {
        /* X */
        let _temp10 = varEnv.SetMutableBinding(fn, fo, Value.false);
        /* node:coverage ignore next */
        if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
        /* node:coverage ignore next */
        if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! varEnv.SetMutableBinding(fn, fo, Value.false) returned an abrupt completion", {
          cause: _temp10
        });
        /* node:coverage ignore next */
        if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
      }
    }
  }
  // 18. For each String vn in declaredVarNames, in list order, do
  for (const vn of declaredVarNames) {
    // a. If varEnv is a global Environment Record, then
    if (varEnv instanceof GlobalEnvironmentRecord) {
      /* ReturnIfAbrupt */
      let _temp11 = yield* varEnv.CreateGlobalVarBinding(vn, Value.true);
      /* node:coverage ignore next */
      if (_temp11 instanceof AbruptCompletion) return _temp11;
      /* node:coverage ignore next */
      if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    } else {
      // b. Else,
      // i. Let bindingExists be varEnv.HasBinding(vn).
      const bindingExists = yield* varEnv.HasBinding(vn);
      // ii. If bindingExists is false, then
      if (bindingExists === Value.false) {
        /* X */
        let _temp12 = varEnv.CreateMutableBinding(vn, Value.true);
        /* node:coverage ignore next */
        if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
        /* node:coverage ignore next */
        if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! varEnv.CreateMutableBinding(vn, Value.true) returned an abrupt completion", {
          cause: _temp12
        });
        /* node:coverage ignore next */
        if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
        // 3. Perform ! varEnv.InitializeBinding(vn, undefined).
        /* X */
        let _temp13 = varEnv.InitializeBinding(vn, Value.undefined);
        /* node:coverage ignore next */
        if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
        /* node:coverage ignore next */
        if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! varEnv.InitializeBinding(vn, Value.undefined) returned an abrupt completion", {
          cause: _temp13
        });
        /* node:coverage ignore next */
        if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      }
    }
  }
  // 19. Return NormalCompletion(empty).
  return NormalCompletion(undefined);
}
EvalDeclarationInstantiation.section = 'https://tc39.es/ecma262/#sec-evaldeclarationinstantiation';

/** https://tc39.es/ecma262/#sec-set-immutable-prototype */
function* SetImmutablePrototype(O, V) {
  // 1. Assert: Either Type(V) is Object or Type(V) is Null.
  Assert(V instanceof ObjectValue || V instanceof NullValue, "V instanceof ObjectValue || V instanceof NullValue");
  // 2. Let current be ? O.[[GetPrototypeOf]]().
  /* ReturnIfAbrupt */
  let _temp = yield* O.GetPrototypeOf();
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const current = _temp;
  // 3. If SameValue(V, current) is true, return true.
  if (SameValue(V, current) === Value.true) {
    return Value.true;
  }
  // 4. Return false.
  return Value.false;
}
SetImmutablePrototype.section = 'https://tc39.es/ecma262/#sec-set-immutable-prototype';

/** https://tc39.es/ecma262/#sec-ContinueDynamicImport */
function ContinueDynamicImport(promiseCapability, moduleCompletion) {
  // 1. If moduleCompletion is an abrupt completion, then
  if (moduleCompletion instanceof AbruptCompletion) {
    /* X */
    let _temp = Call(promiseCapability.Reject, Value.undefined, [moduleCompletion.Value]);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [moduleCompletion.Value]) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // b. Return unused.
    return;
  }
  // 2. Let module be moduleCompletion.[[Value]].
  const module = ValueOfNormalCompletion(moduleCompletion);

  // 3. Let loadPromise be module.LoadRequestedModules().
  const loadPromise = module.LoadRequestedModules();

  // 4. Let rejectedClosure be a new Abstract Closure with parameters (reason) that captures promiseCapability and performs the following steps when called:
  const rejectedClosure = ([reason = Value.undefined]) => {
    /* X */
    let _temp2 = Call(promiseCapability.Reject, Value.undefined, [reason]);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [reason]) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // b. Return unused.
  };
  // 5. Let onRejected be CreateBuiltinFunction(rejectedClosure, 1, "", « »).
  const onRejected = CreateBuiltinFunction(rejectedClosure, 1, Value(''), []);

  // 6. Let linkAndEvaluateClosure be a new Abstract Closure with no parameters that captures module, promiseCapability, and onRejected and performs the following steps when called:
  function* linkAndEvaluateClosure() {
    // a. Let link be Completion(module.Link()).
    const link = module.Link();
    // b. If link is an abrupt completion, then
    if (link instanceof AbruptCompletion) {
      /* X */
      let _temp3 = Call(promiseCapability.Reject, Value.undefined, [link.Value]);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [link.Value]) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // ii. Return unused.
      return;
    }

    // c. Let evaluatePromise be module.Evaluate().
    const evaluatePromise = yield* module.Evaluate();

    // d. Let fulfilledClosure be a new Abstract Closure with no parameters that captures module and promiseCapability and performs the following steps when called:
    const fulfilledClosure = () => {
      // i. Let namespace be GetModuleNamespace(module).
      const namespace = GetModuleNamespace(module);
      // ii. Perform ! Call(promiseCapability.[[Resolve]], undefined, « namespace »).
      /* X */
      let _temp4 = Call(promiseCapability.Resolve, Value.undefined, [namespace]);
      /* node:coverage ignore next */
      if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Resolve, Value.undefined, [namespace]) returned an abrupt completion", {
        cause: _temp4
      });
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      // iii. Return unused.
    };
    // e. Let onFulfilled be CreateBuiltinFunction(fulfilledClosure, 0, "", « »).
    const onFulfilled = CreateBuiltinFunction(fulfilledClosure, 0, Value(''), []);

    // f. Perform PerformPromiseThen(evaluatePromise, onFulfilled, onRejected).
    PerformPromiseThen(evaluatePromise, onFulfilled, onRejected);
    // g. Return unused.
  }
  // 7. Let linkAndEvaluate be CreateBuiltinFunction(linkAndEvaluateClosure, 0, "", « »).
  const linkAndEvaluate = CreateBuiltinFunction(linkAndEvaluateClosure, 0, Value(''), []);

  // 8. Perform PerformPromiseThen(loadPromise, linkAndEvaluate, onRejected).
  PerformPromiseThen(loadPromise, linkAndEvaluate, onRejected);
  // 9. Return unused.
}
ContinueDynamicImport.section = 'https://tc39.es/ecma262/#sec-ContinueDynamicImport';

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-operations-on-iterator-objects */
// and
/** https://tc39.es/ecma262/#sec-iteration */

/** https://tc39.es/ecma262/#sec-getiteratordirect */
function* GetIteratorDirect(obj) {
  /* ReturnIfAbrupt */
  let _temp = yield* Get(obj, Value('next'));
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const nextMethod = _temp;
  const iteratorRecord = {
    Iterator: obj,
    NextMethod: nextMethod,
    Done: Value.false
  };
  return iteratorRecord;
}
GetIteratorDirect.section = 'https://tc39.es/ecma262/#sec-getiteratordirect';
/** https://tc39.es/ecma262/#sec-getiteratorfrommethod */
function* GetIteratorFromMethod(obj, method) {
  /* ReturnIfAbrupt */
  let _temp2 = yield* Call(method, obj);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const iterator = _temp2;
  if (!(iterator instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', iterator);
  }
  return yield* GetIteratorDirect(iterator);
}
GetIteratorFromMethod.section = 'https://tc39.es/ecma262/#sec-getiteratorfrommethod';
/** https://tc39.es/ecma262/#sec-getiterator */
function* GetIterator(obj, kind) {
  let method;
  if (kind === 'async') {
    /* ReturnIfAbrupt */
    let _temp3 = yield* GetMethod(obj, wellKnownSymbols.asyncIterator);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    method = _temp3;
    if (method === Value.undefined) {
      /* ReturnIfAbrupt */
      let _temp4 = yield* GetMethod(obj, wellKnownSymbols.iterator);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      const syncMethod = _temp4;
      if (syncMethod instanceof UndefinedValue) {
        return surroundingAgent.Throw('TypeError', 'NotIterable', obj);
      }
      /* ReturnIfAbrupt */
      let _temp5 = yield* GetIteratorFromMethod(obj, syncMethod);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) return _temp5;
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      const syncIteratorRecord = _temp5;
      return CreateAsyncFromSyncIterator(syncIteratorRecord);
    }
  } else {
    /* ReturnIfAbrupt */
    let _temp6 = yield* GetMethod(obj, wellKnownSymbols.iterator);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    method = _temp6;
  }
  if (method instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'NotIterable', obj);
  }
  return yield* GetIteratorFromMethod(obj, method);
}
GetIterator.section = 'https://tc39.es/ecma262/#sec-getiterator';
function* GetIteratorFlattenable(obj, primitiveHandling) {
  if (!(obj instanceof ObjectValue)) {
    if (primitiveHandling === 'reject-primitives') {
      return surroundingAgent.Throw('TypeError', 'NotAnObject', obj);
    }
    Assert(primitiveHandling === 'iterate-string-primitives', "primitiveHandling === 'iterate-string-primitives'");
    if (!(obj instanceof JSStringValue)) {
      return surroundingAgent.Throw('TypeError', 'NotAString', obj);
    }
  }
  /* ReturnIfAbrupt */
  let _temp7 = yield* GetMethod(obj, wellKnownSymbols.iterator);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const method = _temp7;
  let iterator;
  if (method instanceof UndefinedValue) {
    iterator = obj;
  } else {
    /* ReturnIfAbrupt */
    let _temp8 = yield* Call(method, obj);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    iterator = _temp8;
  }
  if (!(iterator instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', iterator);
  }
  return yield* GetIteratorDirect(iterator);
}

/** https://tc39.es/ecma262/#sec-iteratornext */
function* IteratorNext(iteratorRecord, value) {
  let result;
  if (!value) {
    result = EnsureCompletion(yield* Call(iteratorRecord.NextMethod, iteratorRecord.Iterator));
  } else {
    result = EnsureCompletion(yield* Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, [value]));
  }
  if (result instanceof ThrowCompletion) {
    iteratorRecord.Done = Value.true;
    return result;
  }
  /* X */
  let _temp9 = result;
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! result returned an abrupt completion", {
    cause: _temp9
  });
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  result = _temp9;
  if (!(result instanceof ObjectValue)) {
    iteratorRecord.Done = Value.true;
    return surroundingAgent.Throw('TypeError', 'NotAnObject', result);
  }
  return result;
}
IteratorNext.section = 'https://tc39.es/ecma262/#sec-iteratornext';
/** https://tc39.es/ecma262/#sec-iteratorcomplete */
function* IteratorComplete(iteratorResult) {
  /* ReturnIfAbrupt */
  let _temp10 = yield* Get(iteratorResult, Value('done'));
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  return ToBoolean(_temp10);
}
IteratorComplete.section = 'https://tc39.es/ecma262/#sec-iteratorcomplete';
/** https://tc39.es/ecma262/#sec-iteratorvalue */
function IteratorValue(iterResult) {
  return Get(iterResult, Value('value'));
}
IteratorValue.section = 'https://tc39.es/ecma262/#sec-iteratorvalue';
/** https://tc39.es/ecma262/#sec-iteratorstep */
function* IteratorStep(iteratorRecord) {
  /* ReturnIfAbrupt */
  let _temp11 = yield* IteratorNext(iteratorRecord);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const result = _temp11;
  let done = EnsureCompletion(yield* IteratorComplete(result));
  if (done instanceof ThrowCompletion) {
    iteratorRecord.Done = Value.true;
    return done;
  }
  /* X */
  let _temp12 = done;
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! done returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  done = _temp12;
  if (done === Value.true) {
    iteratorRecord.Done = Value.true;
    return 'done';
  }
  return result;
}
IteratorStep.section = 'https://tc39.es/ecma262/#sec-iteratorstep';
/** https://tc39.es/ecma262/#sec-iteratorstepvalue */
function* IteratorStepValue(iteratorRecord) {
  /* ReturnIfAbrupt */
  let _temp13 = yield* IteratorStep(iteratorRecord);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  const result = _temp13;
  if (result === 'done') {
    return 'done';
  }
  const value = EnsureCompletion(yield* IteratorValue(result));
  if (value instanceof ThrowCompletion) {
    iteratorRecord.Done = Value.true;
  }
  return value;
}
IteratorStepValue.section = 'https://tc39.es/ecma262/#sec-iteratorstepvalue';
/** https://tc39.es/ecma262/#sec-iteratorclose */
function* IteratorClose(iteratorRecord, completion) {
  Assert(iteratorRecord.Iterator instanceof ObjectValue, "iteratorRecord.Iterator instanceof ObjectValue");
  const iterator = iteratorRecord.Iterator;
  let innerResult = EnsureCompletion(yield* GetMethod(iterator, Value('return')));
  if (innerResult instanceof NormalCompletion) {
    const ret = innerResult.Value;
    if (ret === Value.undefined) {
      return completion;
    }
    innerResult = EnsureCompletion(yield* Call(ret, iterator));
  }
  if (completion instanceof ThrowCompletion) {
    return completion;
  }
  if (innerResult instanceof ThrowCompletion) {
    return innerResult;
  }
  if (!(innerResult.Value instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', innerResult.Value);
  }
  return completion;
}
IteratorClose.section = 'https://tc39.es/ecma262/#sec-iteratorclose';
/** https://tc39.es/ecma262/#sec-asynciteratorclose */
function* AsyncIteratorClose(iteratorRecord, completion) {
  Assert(iteratorRecord.Iterator instanceof ObjectValue, "iteratorRecord.Iterator instanceof ObjectValue");
  const iterator = iteratorRecord.Iterator;
  let innerResult = EnsureCompletion(yield* GetMethod(iterator, Value('return')));
  if (innerResult instanceof NormalCompletion) {
    const ret = innerResult.Value;
    if (ret instanceof UndefinedValue) {
      return completion;
    }
    innerResult = EnsureCompletion(yield* Call(ret, iterator));
    if (innerResult instanceof NormalCompletion) {
      innerResult = EnsureCompletion(yield* Await(innerResult.Value));
    }
  }
  if (completion instanceof ThrowCompletion) {
    return completion;
  }
  if (innerResult instanceof ThrowCompletion) {
    return innerResult;
  }
  if (!(innerResult.Value instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', innerResult.Value);
  }
  return completion;
}
AsyncIteratorClose.section = 'https://tc39.es/ecma262/#sec-asynciteratorclose';
/** https://tc39.es/ecma262/#sec-createiterresultobject */
function CreateIteratorResultObject(value, done) {
  const obj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* X */
  let _temp14 = CreateDataPropertyOrThrow(obj, Value('value'), value);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(obj, Value('value'), value) returned an abrupt completion", {
    cause: _temp14
  });
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  /* X */
  let _temp15 = CreateDataPropertyOrThrow(obj, Value('done'), done);
  /* node:coverage ignore next */
  if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(obj, Value('done'), done) returned an abrupt completion", {
    cause: _temp15
  });
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  return obj;
}
CreateIteratorResultObject.section = 'https://tc39.es/ecma262/#sec-createiterresultobject';
/** https://tc39.es/ecma262/#sec-createlistiteratorRecord */
function CreateListIteratorRecord(list) {
  const closure = function* closure() {
    for (const E of list) {
      /* ReturnIfAbrupt */
      let _temp16 = yield* GeneratorYield(CreateIteratorResultObject(E, Value.false));
      /* node:coverage ignore next */
      if (_temp16 instanceof AbruptCompletion) return _temp16;
      /* node:coverage ignore next */
      if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    }
    return NormalCompletion(Value.undefined);
  };
  const iterator = CreateIteratorFromClosure(closure, undefined, surroundingAgent.intrinsic('%Iterator.prototype%'));
  return {
    Iterator: iterator,
    NextMethod: surroundingAgent.intrinsic('%GeneratorFunction.prototype.prototype.next%'),
    Done: Value.false
  };
}
CreateListIteratorRecord.section = 'https://tc39.es/ecma262/#sec-createlistiteratorRecord';
/** https://tc39.es/ecma262/#sec-iteratortolist */
function* IteratorToList(iteratorRecord) {
  const list = [];
  while (true) {
    /* ReturnIfAbrupt */
    let _temp17 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    const next = _temp17;
    if (next === 'done') {
      return list;
    }
    list.push(next);
  }
}
IteratorToList.section = 'https://tc39.es/ecma262/#sec-iteratortolist';
/** https://tc39.es/ecma262/#sec-createasyncfromsynciterator */
function CreateAsyncFromSyncIterator(syncIteratorRecord) {
  const asyncIterator = OrdinaryObjectCreate(surroundingAgent.intrinsic('%AsyncFromSyncIteratorPrototype%'), ['SyncIteratorRecord']);
  asyncIterator.SyncIteratorRecord = syncIteratorRecord;
  /* X */
  let _temp18 = Get(asyncIterator, Value('next'));
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! Get(asyncIterator, Value('next')) returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  const nextMethod = _temp18;
  return {
    Iterator: asyncIterator,
    NextMethod: nextMethod,
    Done: Value.false
  };
}
CreateAsyncFromSyncIterator.section = 'https://tc39.es/ecma262/#sec-createasyncfromsynciterator';
/** https://tc39.es/ecma262/#sec-asyncfromsynciteratorcontinuation */
function* AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, closeOnRejection) {
  let done = yield* IteratorComplete(result);
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (done instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [done.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (done instanceof Completion) done = done.Value;
  let value = yield* IteratorValue(result);
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (value instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [value.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (value instanceof Completion) value = value.Value;
  let valueWrapper = yield* PromiseResolve(surroundingAgent.intrinsic('%Promise%'), value);
  if (valueWrapper instanceof AbruptCompletion && done === Value.false && closeOnRejection === Value.true) {
    valueWrapper = yield* IteratorClose(syncIteratorRecord, valueWrapper);
  }
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (valueWrapper instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [valueWrapper.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (valueWrapper instanceof Completion) valueWrapper = valueWrapper.Value;
  const unwrap = ([v]) => CreateIteratorResultObject(v, done);
  const onFullfilled = CreateBuiltinFunction(unwrap, 1, Value(''), []);
  let onRejected;
  if (done === Value.true || closeOnRejection === Value.false) {
    onRejected = Value.undefined;
  } else {
    const closeIterator = ([error]) => IteratorClose(syncIteratorRecord, ThrowCompletion(error));
    onRejected = CreateBuiltinFunction(closeIterator, 1, Value(''), []);
  }
  PerformPromiseThen(valueWrapper, onFullfilled, onRejected, promiseCapability);
  return promiseCapability.Promise;
}
AsyncFromSyncIteratorContinuation.section = 'https://tc39.es/ecma262/#sec-asyncfromsynciteratorcontinuation';

// This file covers abstract operations defined in
// https://tc39.es/ecma262/#sec-abstract-operations-for-keyed-collections

/** https://tc39.es/ecma262/#sec-canonicalizekeyedcollectionkey */
function CanonicalizeKeyedCollectionKey(key) {
  // 1. If key is -0𝔽, return +0𝔽.
  if (key instanceof NumberValue && Object.is(R(key), -0)) {
    key = F(0);
  }
  // 2. Return key.
  return key;
}
CanonicalizeKeyedCollectionKey.section = 'https://tc39.es/ecma262/#sec-abstract-operations-for-keyed-collections';

function isModuleNamespaceObject(V) {
  return V instanceof ObjectValue && 'Module' in V;
}
const InternalMethods$4 = {
  *GetPrototypeOf() {
    return Value.null;
  },
  *SetPrototypeOf(V) {
    return yield* SetImmutablePrototype(this, V);
  },
  *IsExtensible() {
    return Value.false;
  },
  *PreventExtensions() {
    return Value.true;
  },
  *GetOwnProperty(P) {
    const O = this;
    if (P instanceof SymbolValue) {
      return OrdinaryGetOwnProperty(O, P);
    }
    const exports = O.Exports;
    if (!exports.has(P)) {
      return Value.undefined;
    }
    /* ReturnIfAbrupt */
    let _temp = yield* O.Get(P, O);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const value = _temp;
    return _Descriptor({
      Value: value,
      Writable: Value.true,
      Enumerable: Value.true,
      Configurable: Value.false
    });
  },
  *DefineOwnProperty(P, Desc) {
    const O = this;
    if (P instanceof SymbolValue) {
      return yield* OrdinaryDefineOwnProperty(O, P, Desc);
    }
    /* ReturnIfAbrupt */
    let _temp2 = yield* O.GetOwnProperty(P);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const current = _temp2;
    if (current instanceof UndefinedValue) {
      return Value.false;
    }
    if (IsAccessorDescriptor(Desc)) {
      return Value.false;
    }
    if (Desc.Writable !== undefined && Desc.Writable === Value.false) {
      return Value.false;
    }
    if (Desc.Enumerable !== undefined && Desc.Enumerable === Value.false) {
      return Value.false;
    }
    if (Desc.Configurable !== undefined && Desc.Configurable === Value.true) {
      return Value.false;
    }
    if (Desc.Value !== undefined) {
      return SameValue(Desc.Value, current.Value);
    }
    return Value.true;
  },
  *HasProperty(P) {
    const O = this;
    if (P instanceof SymbolValue) {
      return yield* OrdinaryHasProperty(O, P);
    }
    const exports = O.Exports;
    if (exports.has(P)) {
      return Value.true;
    }
    return Value.false;
  },
  /** https://tc39.es/ecma262/#sec-module-namespace-exotic-objects-get-p-receiver */
  *Get(P, Receiver) {
    const O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    // 2. If Type(P) is Symbol, then
    if (P instanceof SymbolValue) {
      // a. Return ? OrdinaryGet(O, P, Receiver).
      return yield* OrdinaryGet(O, P, Receiver);
    }
    // 3. Let exports be O.[[Exports]].
    const exports = O.Exports;
    // 4. If P is not an element of exports, return undefined.
    if (!exports.has(P)) {
      return Value.undefined;
    }
    // 5. Let m be O.[[Module]].
    const m = O.Module;
    // 6. Let binding be ! m.ResolveExport(P).
    const binding = m.ResolveExport(P);
    // 7. Assert: binding is a ResolvedBinding Record.
    Assert(binding instanceof ResolvedBindingRecord, "binding instanceof ResolvedBindingRecord");
    // 8. Let targetModule be binding.[[Module]].
    const targetModule = binding.Module;
    // 9. Assert: targetModule is not undefined.
    Assert(!(targetModule instanceof UndefinedValue), "!(targetModule instanceof UndefinedValue)");
    // 10. If binding.[[BindingName]] is ~namespace~, then
    if (binding.BindingName === 'namespace') {
      // a. Return ? GetModuleNamespace(targetModule).
      return GetModuleNamespace(targetModule);
    }
    // 11. Let targetEnv be targetModule.[[Environment]].
    const targetEnv = targetModule.Environment;
    // 12. If targetEnv is undefined, throw a ReferenceError exception.
    if (!targetEnv) {
      return surroundingAgent.Throw('ReferenceError', 'NotDefined', P);
    }
    // 13. Return ? targetEnv.GetBindingValue(binding.[[BindingName]], true).
    return yield* targetEnv.GetBindingValue(binding.BindingName, Value.true);
  },
  *Set() {
    return Value.false;
  },
  *Delete(P) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    if (P instanceof SymbolValue) {
      return yield* OrdinaryDelete(O, P);
    }
    const exports = O.Exports;
    if (exports.has(P)) {
      return Value.false;
    }
    return Value.true;
  },
  *OwnPropertyKeys() {
    const O = this;
    const exports = [...O.Exports];
    /* X */
    let _temp3 = OrdinaryOwnPropertyKeys(O);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryOwnPropertyKeys(O) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const symbolKeys = _temp3;
    exports.push(...symbolKeys);
    return exports;
  }
};

/** https://tc39.es/ecma262/#sec-modulenamespacecreate */
function ModuleNamespaceCreate(module, exports) {
  // 1. Assert: module.[[Namespace]] is EMPTY.
  Assert(module.Namespace instanceof UndefinedValue, "module.Namespace instanceof UndefinedValue");
  // 2. Let internalSlotsList be the internal slots listed in Table 31.
  const internalSlotsList = ['Module', 'Exports'];
  // 3. Let M be MakeBasicObject(internalSlotsList).
  const M = MakeBasicObject(internalSlotsList);
  // 4. Set M's essential internal methods to the definitions specified in 10.4.6.
  /** https://tc39.es/ecma262/#sec-module-namespace-exotic-objects */
  M.GetPrototypeOf = InternalMethods$4.GetPrototypeOf;
  M.SetPrototypeOf = InternalMethods$4.SetPrototypeOf;
  M.IsExtensible = InternalMethods$4.IsExtensible;
  M.PreventExtensions = InternalMethods$4.PreventExtensions;
  M.GetOwnProperty = InternalMethods$4.GetOwnProperty;
  M.DefineOwnProperty = InternalMethods$4.DefineOwnProperty;
  M.HasProperty = InternalMethods$4.HasProperty;
  M.Get = InternalMethods$4.Get;
  M.Set = InternalMethods$4.Set;
  M.Delete = InternalMethods$4.Delete;
  M.OwnPropertyKeys = InternalMethods$4.OwnPropertyKeys;
  // 5. Set M.[[Module]] to module.
  M.Module = module;
  // 6. Let sortedExports be a List whose elements are the elements of exports, sorted according to lexicographic code unit order.
  const sortedExports = [...exports].sort((x, y) => {
    /* X */
    let _temp4 = CompareArrayElements(x, y, Value.undefined);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! CompareArrayElements(x, y, Value.undefined) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    const result = _temp4;
    return R(result);
  });
  // 7. Set M.[[Exports]] to sortedExports.
  M.Exports = new JSStringSet(sortedExports);
  // 8. Create own properties of M corresponding to the definitions in 26.3.
  M.properties.set(wellKnownSymbols.toStringTag, _Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false,
    Value: Value('Module')
  }));
  // 9. Set module.[[Namespace]] to M.
  module.Namespace = M;
  // 10. Return M.
  return M;
}
ModuleNamespaceCreate.section = 'https://tc39.es/ecma262/#sec-modulenamespacecreate';

/** https://tc39.es/ecma262/#graphloadingstate-record */
class GraphLoadingState {
  PromiseCapability;
  HostDefined;
  IsLoading = true;
  Visited = new Set();
  PendingModules = 1;
  constructor({
    PromiseCapability,
    HostDefined
  }) {
    this.PromiseCapability = PromiseCapability;
    this.HostDefined = HostDefined;
  }
}

/** https://tc39.es/ecma262/#sec-InnerModuleLoading */
function InnerModuleLoading(state, module) {
  // 1. Assert: state.[[IsLoading]] is true.
  Assert(Boolean(state.IsLoading === true), "Boolean(state.IsLoading === true)"); // this Boolean() is let step 2.d.iii not having a type error.

  // 2. If module is a Cyclic Module Record, module.[[Status]] is new, and state.[[Visited]] does not contain module, then
  if (module instanceof CyclicModuleRecord && module.Status === 'new' && !state.Visited.has(module)) {
    // a. Append module to state.[[Visited]].
    state.Visited.add(module);
    // b. Let requestedModulesCount be the number of elements in module.[[RequestedModules]].
    const requestedModulesCout = module.RequestedModules.length;
    // c. Set state.[[PendingModulesCount]] to state.[[PendingModulesCount]] + requestedModulesCount.
    state.PendingModules += requestedModulesCout;
    // d. For each ModuleRequest Record request of module.[[RequestedModules]], do
    for (const request of module.RequestedModules) {
      // i. If AllImportAttributesSupported(request.[[Attributes]]) is false, then
      const invalidAttributeKey = AllImportAttributesSupported(request.Attributes);
      if (invalidAttributeKey) {
        // 1. Let error be ThrowCompletion(a newly created SyntaxError object).
        const error = surroundingAgent.Throw('SyntaxError', 'UnsupportedImportAttribute', invalidAttributeKey);
        // 2. Perform ContinueModuleLoading(state, error).
        ContinueModuleLoading(state, error);
      } else {
        // ii. Else if module.[[LoadedModules]] contains a LoadedModuleRequest Record record such that ModuleRequestsEqual(record, request) is true, then
        const record = getRecordWithSpecifier(module.LoadedModules, request);
        if (record !== undefined) {
          // 1. Perform InnerModuleLoading(state, record.[[Module]]).
          InnerModuleLoading(state, record.Module);
        } else {
          // iii. Else,
          // 1. Perform HostLoadImportedModule(module, request, state.[[HostDefined]], state).
          HostLoadImportedModule(module, request, state.HostDefined, state);
        }
      }

      // iii. If state.[[IsLoading]] is false, return unused.
      if (state.IsLoading === false) {
        return;
      }
    }
  }

  // 3. Assert: state.[[PendingModulesCount]] ≥ 1.
  Assert(state.PendingModules >= 1, "state.PendingModules >= 1");
  // 4. Set state.[[PendingModulesCount]] to state.[[PendingModulesCount]] - 1.
  state.PendingModules -= 1;
  // 5. If state.[[PendingModulesCount]] = 0, then
  if (state.PendingModules === 0) {
    // a. Set state.[[IsLoading]] to false.
    state.IsLoading = false;
    // b. For each Cyclic Module Record loaded of state.[[Visited]], do
    for (const loaded of state.Visited) {
      // i. If loaded.[[Status]] is new, set loaded.[[Status]] to unlinked.
      if (loaded.Status === 'new') {
        loaded.Status = 'unlinked';
      }
    }
    // c. Perform ! Call(state.[[PromiseCapability]].[[Resolve]], undefined, « undefined »).
    /* X */
    let _temp = Call(state.PromiseCapability.Resolve, Value.undefined, [Value.undefined]);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! Call(state.PromiseCapability.Resolve, Value.undefined, [Value.undefined]) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
  }

  // 6. Return unused.
}
InnerModuleLoading.section = 'https://tc39.es/ecma262/#sec-InnerModuleLoading';
/** https://tc39.es/ecma262/#sec-ContinueModuleLoading */
function ContinueModuleLoading(state, result) {
  // 1. If state.[[IsLoading]] is false, return unused.
  if (state.IsLoading === false) {
    return;
  }
  result = EnsureCompletion(result);
  // 2. If moduleCompletion is a normal completion, then
  if (result instanceof NormalCompletion) {
    // a. Perform InnerModuleLoading(state, moduleCompletion.[[Value]]).
    InnerModuleLoading(state, result.Value);
    // 3. Else,
  } else {
    // a. Set state.[[IsLoading]] to false.
    state.IsLoading = false;
    // b. Perform ! Call(state.[[PromiseCapability]].[[Reject]], undefined, « moduleCompletion.[[Value]] »).
    /* X */
    let _temp2 = Call(state.PromiseCapability.Reject, Value.undefined, [result.Value]);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! Call(state.PromiseCapability.Reject, Value.undefined, [result.Value]) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  }

  // 4. Return unused.
}
ContinueModuleLoading.section = 'https://tc39.es/ecma262/#sec-ContinueModuleLoading';
/** https://tc39.es/ecma262/#sec-InnerModuleLinking */
function InnerModuleLinking(module, stack, index) {
  if (!(module instanceof CyclicModuleRecord)) {
    /* ReturnIfAbrupt */
    let _temp3 = module.Link();
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    return index;
  }
  if (module.Status === 'linking' || module.Status === 'linked' || module.Status === 'evaluating-async' || module.Status === 'evaluated') {
    return index;
  }
  Assert(module.Status === 'unlinked', "module.Status === 'unlinked'");
  module.Status = 'linking';
  module.DFSIndex = index;
  module.DFSAncestorIndex = index;
  index += 1;
  stack.push(module);
  for (const required of module.RequestedModules) {
    const requiredModule = GetImportedModule(module, required);
    /* ReturnIfAbrupt */
    let _temp4 = InnerModuleLinking(requiredModule, stack, index);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    index = _temp4;
    if (requiredModule instanceof CyclicModuleRecord) {
      Assert(requiredModule.Status === 'linking' || requiredModule.Status === 'linked' || requiredModule.Status === 'evaluating-async' || requiredModule.Status === 'evaluated', "requiredModule.Status === 'linking' || requiredModule.Status === 'linked' || requiredModule.Status === 'evaluating-async' || requiredModule.Status === 'evaluated'");
      Assert(requiredModule.Status === 'linking' === stack.includes(requiredModule), "(requiredModule.Status === 'linking') === stack.includes(requiredModule)");
      if (requiredModule.Status === 'linking') {
        module.DFSAncestorIndex = Math.min(module.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
      }
    }
  }
  /* ReturnIfAbrupt */
  let _temp5 = module.InitializeEnvironment();
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  Assert(stack.indexOf(module) === stack.lastIndexOf(module), "stack.indexOf(module) === stack.lastIndexOf(module)");
  Assert(module.DFSAncestorIndex <= module.DFSIndex, "module.DFSAncestorIndex <= module.DFSIndex");
  if (module.DFSAncestorIndex === module.DFSIndex) {
    let done = false;
    while (done === false) {
      const requiredModule = stack.pop();
      Assert(requiredModule instanceof CyclicModuleRecord, "requiredModule instanceof CyclicModuleRecord");
      requiredModule.Status = 'linked';
      if (requiredModule === module) {
        done = true;
      }
    }
  }
  return index;
}
InnerModuleLinking.section = 'https://tc39.es/ecma262/#sec-InnerModuleLinking';
/** https://tc39.es/ecma262/#sec-EvaluateModuleSync */
function* EvaluateModuleSync(module) {
  // 1. Assert: module is not a Cyclic Module Record.
  Assert(!(module instanceof CyclicModuleRecord), "!(module instanceof CyclicModuleRecord)");
  // 2. Let promise be module.Evaluate()./
  const promise = yield* module.Evaluate();
  // 3. Assert: promise.[[PromiseState]] is either fulfilled or rejected.
  Assert(promise.PromiseState === 'fulfilled' || promise.PromiseState === 'rejected', "promise.PromiseState === 'fulfilled' || promise.PromiseState === 'rejected'");
  // 4. If promise.[[PromiseState]] is rejected, then
  if (promise.PromiseState === 'rejected') {
    // a. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, "handle").
    if (promise.PromiseIsHandled === Value.false) {
      HostPromiseRejectionTracker(promise, 'handle');
    }
    // b. Set promise.[[PromiseIsHandled]] to true.
    promise.PromiseIsHandled = Value.true;
    // c. Return ThrowCompletion(promise.[[PromiseResult]]).
    return ThrowCompletion(promise.PromiseResult);
  }
  // 5. Return unused.
  return undefined;
}
EvaluateModuleSync.section = 'https://tc39.es/ecma262/#sec-EvaluateModuleSync';
/** https://tc39.es/ecma262/#sec-innermoduleevaluation */
function* InnerModuleEvaluation(module, stack, index) {
  if (!(module instanceof CyclicModuleRecord)) {
    /* ReturnIfAbrupt */
    let _temp6 = yield* EvaluateModuleSync(module);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    return NormalCompletion(index);
  }
  if (module.Status === 'evaluating-async' || module.Status === 'evaluated') {
    if (module.EvaluationError === undefined) {
      return NormalCompletion(index);
    } else {
      return module.EvaluationError;
    }
  }
  if (module.Status === 'evaluating') {
    return NormalCompletion(index);
  }
  Assert(module.Status === 'linked', "module.Status === 'linked'");
  module.Status = 'evaluating';
  module.DFSIndex = index;
  module.DFSAncestorIndex = index;
  module.PendingAsyncDependencies = 0;
  module.AsyncParentModules = [];
  index += 1;
  stack.push(module);
  for (const required of module.RequestedModules) {
    let requiredModule = GetImportedModule(module, required);
    /* ReturnIfAbrupt */
    let _temp7 = yield* InnerModuleEvaluation(requiredModule, stack, index);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    index = _temp7;
    if (requiredModule instanceof CyclicModuleRecord) {
      Assert(requiredModule.Status === 'evaluating' || requiredModule.Status === 'evaluating-async' || requiredModule.Status === 'evaluated', "requiredModule.Status === 'evaluating' || requiredModule.Status === 'evaluating-async' || requiredModule.Status === 'evaluated'");
      Assert(requiredModule.Status === 'evaluating' === stack.includes(requiredModule), "(requiredModule.Status === 'evaluating') === stack.includes(requiredModule)");
      if (requiredModule.Status === 'evaluating') {
        module.DFSAncestorIndex = Math.min(module.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
      } else {
        requiredModule = requiredModule.CycleRoot;
        Assert(requiredModule.Status === 'evaluating-async' || requiredModule.Status === 'evaluated', "requiredModule.Status === 'evaluating-async' || requiredModule.Status === 'evaluated'");
        if (requiredModule.EvaluationError !== undefined) {
          return EnsureCompletion(requiredModule.EvaluationError);
        }
      }
      if (typeof requiredModule.AsyncEvaluationOrder === 'number') {
        module.PendingAsyncDependencies += 1;
        requiredModule.AsyncParentModules.push(module);
      }
    }
  }
  if (module.PendingAsyncDependencies > 0 || module.HasTLA === Value.true) {
    Assert(module.AsyncEvaluationOrder === 'unset', "module.AsyncEvaluationOrder === 'unset'");
    module.AsyncEvaluationOrder = IncrementModuleAsyncEvaluationCount();
    if (module.PendingAsyncDependencies === 0) {
      /* X */
      let _temp8 = yield* ExecuteAsyncModule(module);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! yield* ExecuteAsyncModule(module) returned an abrupt completion", {
        cause: _temp8
      });
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    }
  } else {
    /* ReturnIfAbrupt */
    let _temp9 = yield* module.ExecuteModule();
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  }
  Assert(stack.indexOf(module) === stack.lastIndexOf(module), "stack.indexOf(module) === stack.lastIndexOf(module)");
  Assert(module.DFSAncestorIndex <= module.DFSIndex, "module.DFSAncestorIndex <= module.DFSIndex");
  if (module.DFSAncestorIndex === module.DFSIndex) {
    let done = false;
    while (done === false) {
      const requiredModule = stack.pop();
      Assert(requiredModule instanceof CyclicModuleRecord, "requiredModule instanceof CyclicModuleRecord");
      Assert(typeof requiredModule.AsyncEvaluationOrder === 'number' || requiredModule.AsyncEvaluationOrder === 'unset', "typeof requiredModule.AsyncEvaluationOrder === 'number' || requiredModule.AsyncEvaluationOrder === 'unset'");
      if (requiredModule.AsyncEvaluationOrder === 'unset') {
        requiredModule.Status = 'evaluated';
      } else {
        requiredModule.Status = 'evaluating-async';
      }
      if (requiredModule === module) {
        done = true;
      }
      requiredModule.CycleRoot = module;
    }
  }
  return index;
}
InnerModuleEvaluation.section = 'https://tc39.es/ecma262/#sec-innermoduleevaluation';
/** https://tc39.es/ecma262/#sec-execute-async-module */
function* ExecuteAsyncModule(module) {
  // 1. Assert: module.[[Status]] is evaluating or evaluating-async.
  Assert(module.Status === 'evaluating' || module.Status === 'evaluating-async', "module.Status === 'evaluating' || module.Status === 'evaluating-async'");
  // 2. Assert: module.[[HasTLA]] is true.
  Assert(module.HasTLA === Value.true, "module.HasTLA === Value.true");
  // 3. Let capability be ! NewPromiseCapability(%Promise%).
  /* X */
  let _temp10 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const capability = _temp10;
  // 4. Let fulfilledClosure be a new Abstract Closure with no parameters that captures module and performs the following steps when called:
  function* fulfilledClosure() {
    /* X */
    let _temp11 = yield* AsyncModuleExecutionFulfilled(module);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! yield* AsyncModuleExecutionFulfilled(module) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    // b. Return undefined.
    return Value.undefined;
  }
  // 5. Let onFulfilled be ! CreateBuiltinFunction(fulfilledClosure, 0, "", « »).
  const onFulfilled = CreateBuiltinFunction(fulfilledClosure, 0, Value(''), ['Module']);
  // 6. Let rejectedClosure be a new Abstract Closure with parameters (error) that captures module and performs the following steps when called:
  const rejectedClosure = ([error = Value.undefined]) => {
    /* X */
    let _temp12 = AsyncModuleExecutionRejected(module, error);
    /* node:coverage ignore next */
    if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! AsyncModuleExecutionRejected(module, error) returned an abrupt completion", {
      cause: _temp12
    });
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    // b. Return undefined.
    return Value.undefined;
  };
  // 7. Let onRejected be ! CreateBuiltinFunction(rejectedClosure, 0, "", « »).
  const onRejected = CreateBuiltinFunction(rejectedClosure, 0, Value(''), ['Module']);
  // 8. Perform ! PerformPromiseThen(capability.[[Promise]], onFulfilled, onRejected).
  /* X */
  let _temp13 = PerformPromiseThen(capability.Promise, onFulfilled, onRejected);
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! PerformPromiseThen(capability.Promise, onFulfilled, onRejected) returned an abrupt completion", {
    cause: _temp13
  });
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  // 9. Perform ! module.ExecuteModule(capability).
  /* X */
  let _temp14 = yield* module.ExecuteModule(capability);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! yield* module.ExecuteModule(capability) returned an abrupt completion", {
    cause: _temp14
  });
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  // 10. Return.
  return Value.undefined;
}
ExecuteAsyncModule.section = 'https://tc39.es/ecma262/#sec-execute-async-module';
/** https://tc39.es/ecma262/#sec-gather-available-ancestors */
function GatherAvailableAncestors(module, execList) {
  for (const m of module.AsyncParentModules) {
    if (!execList.includes(m) && m.CycleRoot.EvaluationError === undefined) {
      Assert(m.Status === 'evaluating-async', "m.Status === 'evaluating-async'");
      Assert(m.EvaluationError === undefined, "m.EvaluationError === undefined");
      Assert(typeof m.AsyncEvaluationOrder === 'number', "typeof m.AsyncEvaluationOrder === 'number'");
      Assert(m.PendingAsyncDependencies > 0, "m.PendingAsyncDependencies! > 0");
      m.PendingAsyncDependencies -= 1;
      if (m.PendingAsyncDependencies === 0) {
        execList.push(m);
        if (m.HasTLA === Value.false) {
          GatherAvailableAncestors(m, execList);
        }
      }
    }
  }
}
GatherAvailableAncestors.section = 'https://tc39.es/ecma262/#sec-gather-available-ancestors';
/** https://tc39.es/ecma262/#sec-asyncmodulexecutionfulfilled */
function* AsyncModuleExecutionFulfilled(module) {
  if (module.Status === 'evaluated') {
    Assert(module.EvaluationError !== undefined, "module.EvaluationError !== undefined");
    return;
  }
  Assert(module.Status === 'evaluating-async', "module.Status === 'evaluating-async'");
  Assert(typeof module.AsyncEvaluationOrder === 'number', "typeof module.AsyncEvaluationOrder === 'number'");
  Assert(module.EvaluationError === undefined, "module.EvaluationError === undefined");
  module.AsyncEvaluationOrder = 'done';
  module.Status = 'evaluated';
  if (module.TopLevelCapability !== undefined) {
    Assert(module.CycleRoot === module, "module.CycleRoot === module");
    /* X */
    let _temp15 = Call(module.TopLevelCapability.Resolve, Value.undefined, [Value.undefined]);
    /* node:coverage ignore next */
    if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! Call(module.TopLevelCapability.Resolve, Value.undefined, [Value.undefined]) returned an abrupt completion", {
      cause: _temp15
    });
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  }
  const execList = [];
  GatherAvailableAncestors(module, execList);
  Assert(execList.every(m => typeof m.AsyncEvaluationOrder === 'number' && m.PendingAsyncDependencies === 0 && m.EvaluationError === undefined), "execList.every((m) => typeof m.AsyncEvaluationOrder === 'number' && m.PendingAsyncDependencies === 0 && m.EvaluationError === undefined)");
  const sortedExecList = execList.toSorted((m1, m2) => m1.AsyncEvaluationOrder - m2.AsyncEvaluationOrder);
  for (const m of sortedExecList) {
    if (m.Status === 'evaluated') {
      Assert(m.EvaluationError !== undefined, "m.EvaluationError !== undefined");
    } else if (m.HasTLA === Value.true) {
      /* X */
      let _temp16 = yield* ExecuteAsyncModule(m);
      /* node:coverage ignore next */
      if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! yield* ExecuteAsyncModule(m) returned an abrupt completion", {
        cause: _temp16
      });
      /* node:coverage ignore next */
      if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    } else {
      const result = yield* m.ExecuteModule();
      if (result instanceof AbruptCompletion) {
        /* X */
        let _temp17 = AsyncModuleExecutionRejected(m, result.Value);
        /* node:coverage ignore next */
        if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
        /* node:coverage ignore next */
        if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! AsyncModuleExecutionRejected(m, result.Value) returned an abrupt completion", {
          cause: _temp17
        });
        /* node:coverage ignore next */
        if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
      } else {
        m.AsyncEvaluationOrder = 'done';
        m.Status = 'evaluated';
        if (m.TopLevelCapability !== undefined) {
          Assert(m.CycleRoot === m, "m.CycleRoot === m");
          /* X */
          let _temp18 = Call(m.TopLevelCapability.Resolve, Value.undefined, [Value.undefined]);
          /* node:coverage ignore next */
          if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
          /* node:coverage ignore next */
          if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! Call(m.TopLevelCapability.Resolve, Value.undefined, [Value.undefined]) returned an abrupt completion", {
            cause: _temp18
          });
          /* node:coverage ignore next */
          if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
        }
      }
    }
  }
}
AsyncModuleExecutionFulfilled.section = 'https://tc39.es/ecma262/#sec-asyncmodulexecutionfulfilled';
/** https://tc39.es/ecma262/#sec-AsyncModuleExecutionRejected */
function AsyncModuleExecutionRejected(module, error) {
  if (module.Status === 'evaluated') {
    Assert(module.EvaluationError !== undefined, "module.EvaluationError !== undefined");
    return;
  }
  Assert(module.Status === 'evaluating-async', "module.Status === 'evaluating-async'");
  Assert(typeof module.AsyncEvaluationOrder === 'number', "typeof module.AsyncEvaluationOrder === 'number'");
  Assert(module.EvaluationError === undefined, "module.EvaluationError === undefined");
  module.EvaluationError = ThrowCompletion(error);
  module.Status = 'evaluated';
  module.AsyncEvaluationOrder = 'done';
  for (const m of module.AsyncParentModules) {
    AsyncModuleExecutionRejected(m, error);
  }
  if (module.TopLevelCapability !== undefined) {
    Assert(module.DFSIndex === module.DFSAncestorIndex, "module.DFSIndex === module.DFSAncestorIndex");
    /* X */
    let _temp19 = Call(module.TopLevelCapability.Reject, Value.undefined, [error]);
    /* node:coverage ignore next */
    if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! Call(module.TopLevelCapability.Reject, Value.undefined, [error]) returned an abrupt completion", {
      cause: _temp19
    });
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  }
}
AsyncModuleExecutionRejected.section = 'https://tc39.es/ecma262/#sec-AsyncModuleExecutionRejected';
function getRecordWithSpecifier(loadedModules, request) {
  const records = loadedModules.filter(r => ModuleRequestsEqual(r, request));
  Assert(records.length <= 1, "records.length <= 1");
  return records.length === 1 ? records[0] : undefined;
}

/** https://tc39.es/ecma262/#sec-GetImportedModule */
function GetImportedModule(referrer, request) {
  const record = getRecordWithSpecifier(referrer.LoadedModules, request);
  Assert(record !== undefined, "record !== undefined");
  return record.Module;
}
GetImportedModule.section = 'https://tc39.es/ecma262/#sec-GetImportedModule';
/** https://tc39.es/ecma262/#sec-FinishLoadingImportedModule */
function FinishLoadingImportedModule(referrer, moduleRequest, result, state) {
  result = EnsureCompletion(result);
  // 1. If result is a normal completion, then
  if (result.Type === 'normal') {
    // a. If referrer.[[LoadedModules]] contains a LoadedModuleRequest Record record such that ModuleRequestsEqual(record, moduleRequest) is true, then
    const record = getRecordWithSpecifier(referrer.LoadedModules, moduleRequest);
    if (record !== undefined) {
      // i. Assert: That Record's [[Module]] is result.[[Value]].
      Assert(record.Module === result.Value, "record.Module === result.Value");
    } else {
      // b. Else,
      //  i. Append the LoadedModuleRequest Record { [[Specifier]]: moduleRequest.[[Specifier]], [[Attributes]]: moduleRequest.[[Attributes]], [[Module]]: result.[[Value]] } to referrer.[[LoadedModules]].
      referrer.LoadedModules.push({
        Specifier: moduleRequest.Specifier,
        Attributes: moduleRequest.Attributes,
        Module: result.Value
      });
    }
  }

  // 2. If payload is a GraphLoadingState Record, then
  if (state instanceof GraphLoadingState) {
    // a. Perform ContinueModuleLoading(payload, result).
    ContinueModuleLoading(state, result);
    // 3. Else,
  } else {
    // a. Perform ContinueDynamicImport(payload, result).
    ContinueDynamicImport(state, result);
  }

  // 4. Return unused.
}
FinishLoadingImportedModule.section = 'https://tc39.es/ecma262/#sec-FinishLoadingImportedModule';
/** https://tc39.es/ecma262/#sec-AllImportAttributesSupported */
function AllImportAttributesSupported(attributes) {
  // Note: This function is meant to return a boolean. Instead, we return:
  // - instead of *false*, the key of the unsupported attribute
  // - instead of *true*, undefined

  const supported = HostGetSupportedImportAttributes();
  for (const attribute of attributes) {
    if (!supported.includes(attribute.Key.stringValue())) {
      return attribute.Key;
    }
  }
  return undefined;
}
AllImportAttributesSupported.section = 'https://tc39.es/ecma262/#sec-AllImportAttributesSupported';
/** https://tc39.es/ecma262/#sec-getmodulenamespace */
function GetModuleNamespace(module) {
  // 1. Assert: If module is a Cyclic Module Record, then module.[[Status]] is not new or unlinked.
  if (module instanceof CyclicModuleRecord) {
    Assert(module.Status !== 'new' && module.Status !== 'unlinked', "module.Status !== 'new' && module.Status !== 'unlinked'");
  }
  // 2. Let namespace be module.[[Namespace]].
  let namespace = module.Namespace;
  // 3. If namespace is empty, then
  if (namespace instanceof UndefinedValue) {
    // a. Let exportedNames be module.GetExportedNames().
    const exportedNames = module.GetExportedNames();
    // b. Let unambiguousNames be a new empty List.
    const unambiguousNames = [];
    // c. For each element name of exportedNames, do
    for (const name of exportedNames) {
      // i. Let resolution be module.ResolveExport(name).
      const resolution = module.ResolveExport(name);
      // ii. If resolution is a ResolvedBinding Record, append name to unambiguousNames.
      if (resolution instanceof ResolvedBindingRecord) {
        unambiguousNames.push(name);
      }
    }
    // d. Set namespace to ModuleNamespaceCreate(module, unambiguousNames).
    namespace = ModuleNamespaceCreate(module, unambiguousNames);
  }
  // 4. Return namespace.
  return namespace;
}
GetModuleNamespace.section = 'https://tc39.es/ecma262/#sec-getmodulenamespace';
function CreateSyntheticModule(exportNames, evaluationSteps, realm, hostDefined) {
  // 1. Return Synthetic Module Record {
  //      [[Realm]]: realm,
  //      [[Environment]]: undefined,
  //      [[Namespace]]: undefined,
  //      [[HostDefined]]: hostDefined,
  //      [[ExportNames]]: exportNames,
  //      [[EvaluationSteps]]: evaluationSteps
  //    }.
  return new SyntheticModuleRecord({
    Realm: realm,
    Environment: undefined,
    Namespace: Value.undefined,
    HostDefined: hostDefined,
    ExportNames: exportNames,
    EvaluationSteps: evaluationSteps
  });
}

/** https://tc39.es/ecma262/#sec-create-default-export-synthetic-module */
function CreateDefaultExportSyntheticModule(defaultExport, realm, hostDefined) {
  // 1. Let closure be the a Abstract Closure with parameters (module) that captures defaultExport and performs the following steps when called:
  const closure = function* closure(module) {
    /* ReturnIfAbrupt */
    let _temp20 = yield* module.SetSyntheticExport(Value('default'), defaultExport);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    return NormalCompletion(undefined);
  };
  // 2. Return CreateSyntheticModule(« "default" », closure, realm)
  return CreateSyntheticModule([Value('default')], closure, realm, hostDefined);
}
CreateDefaultExportSyntheticModule.section = 'https://tc39.es/ecma262/#sec-create-default-export-synthetic-module';

class AssertError extends Error {}
function Assert(invariant, source, completion) {
  /* node:coverage disable */
  if (!invariant) {
    throw new AssertError(source, {
      cause: completion
    });
  }
  /* node:coverage enable */
}
Assert.Error = AssertError;

/** https://tc39.es/ecma262/#sec-requireinternalslot */
function RequireInternalSlot(O, internalSlot) {
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  if (!(internalSlot in O)) {
    return surroundingAgent.Throw('TypeError', 'InternalSlotMissing', O, internalSlot);
  }
  return undefined;
}
RequireInternalSlot.section = 'https://tc39.es/ecma262/#sec-requireinternalslot';
function sourceTextMatchedBy(node) {
  return node.sourceText();
}

// An ECMAScript Script syntactic unit may be processed using either unrestricted or strict mode syntax and semantics.
// Code is interpreted as strict mode code in the following situations:
//
//  - Global code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive.
//
//  - Module code is always strict mode code.
//
//  - All parts of a ClassDeclaration or a ClassExpression are strict mode code.
//
//  - Eval code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive or
//    if the call to eval is a direct eval that is contained in strict mode code.
//
//  - Function code is strict mode code if the associated FunctionDeclaration, FunctionExpression, GeneratorDeclaration,
//    GeneratorExpression, AsyncFunctionDeclaration, AsyncFunctionExpression, AsyncGeneratorDeclaration,
//    AsyncGeneratorExpression, MethodDefinition, ArrowFunction, or AsyncArrowFunction is contained in strict mode code
//    or if the code that produces the value of the function's [[ECMAScriptCode]] internal slot begins with a Directive
//    Prologue that contains a Use Strict Directive.
//
//  - Function code that is supplied as the arguments to the built-in Function, Generator, AsyncFunction, and
//    AsyncGenerator constructors is strict mode code if the last argument is a String that when processed is a
//    FunctionBody that begins with a Directive Prologue that contains a Use Strict Directive.
function isStrictModeCode(node) {
  return node.strict;
}

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-operations-on-objects */

/** https://tc39.es/ecma262/#sec-makebasicobject */
function MakeBasicObject(internalSlotsList) {
  // 1.  Assert: internalSlotsList is a List of internal slot names.
  Assert(isArray(internalSlotsList), "isArray(internalSlotsList)");
  // 2.  Let obj be a newly created object with an internal slot for each name in internalSlotsList.
  // 3.  Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
  const obj = new ObjectValue(internalSlotsList);
  Object.assign(obj, internalSlotsList.reduce((extraFields, currentField) => {
    extraFields[currentField] = Value.undefined;
    return extraFields;
  }, {}));
  // 4.  Assert: If the caller will not be overriding both obj's [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then internalSlotsList contains [[Prototype]].
  // 5.  Assert: If the caller will not be overriding all of obj's [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then internalSlotsList contains [[Extensible]].
  // 6.  If internalSlotsList contains [[Extensible]], then set obj.[[Extensible]] to true.
  if (internalSlotsList.includes('Extensible')) {
    obj.Extensible = Value.true;
  }
  // 7.  Return obj.
  return obj;
}
MakeBasicObject.section = 'https://tc39.es/ecma262/#sec-operations-on-objects';
/** https://tc39.es/ecma262/#sec-get-o-p */
function* Get(O, P) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  return yield* O.Get(P, O);
}
Get.section = 'https://tc39.es/ecma262/#sec-get-o-p';
/** https://tc39.es/ecma262/#sec-getv */
function* GetV(V, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp = ToObject(V);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const O = _temp;
  return yield* O.Get(P, V);
}
GetV.section = 'https://tc39.es/ecma262/#sec-getv';
/** https://tc39.es/ecma262/#sec-set-o-p-v-throw */
function* Set$1(O, P, V, Throw) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  Assert(Throw instanceof BooleanValue, "Throw instanceof BooleanValue");
  /* ReturnIfAbrupt */
  let _temp2 = yield* O.Set(P, V, O);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const success = _temp2;
  if (success === Value.false && Throw === Value.true) {
    return surroundingAgent.Throw('TypeError', 'CannotSetProperty', P, O);
  }
  return success;
}
Set$1.section = 'https://tc39.es/ecma262/#sec-set-o-p-v-throw';
/** https://tc39.es/ecma262/#sec-createdataproperty */
function* CreateDataProperty(O, P, V) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  const newDesc = _Descriptor({
    Value: V,
    Writable: Value.true,
    Enumerable: Value.true,
    Configurable: Value.true
  });
  return yield* O.DefineOwnProperty(P, newDesc);
}
CreateDataProperty.section = 'https://tc39.es/ecma262/#sec-createdataproperty';
/** https://tc39.es/ecma262/#sec-createmethodproperty */
function* CreateMethodProperty(O, P, V) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  const newDesc = _Descriptor({
    Value: V,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  });
  return yield* O.DefineOwnProperty(P, newDesc);
}
CreateMethodProperty.section = 'https://tc39.es/ecma262/#sec-createmethodproperty';
/** https://tc39.es/ecma262/#sec-createdatapropertyorthrow */
function* CreateDataPropertyOrThrow(O, P, V) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp3 = yield* CreateDataProperty(O, P, V);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const success = _temp3;
  if (success === Value.false) {
    return surroundingAgent.Throw('TypeError', 'CannotDefineProperty', P);
  }
  return success;
}
CreateDataPropertyOrThrow.section = 'https://tc39.es/ecma262/#sec-createdatapropertyorthrow';
function CreateNonEnumerableDataPropertyOrThrow(O, P, V) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  const newDesc = _Descriptor({
    Value: V,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  });
  /* X */
  let _temp4 = DefinePropertyOrThrow(O, P, newDesc);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(O, P, newDesc) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
}

/** https://tc39.es/ecma262/#sec-definepropertyorthrow */
function* DefinePropertyOrThrow(O, P, desc) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp5 = yield* O.DefineOwnProperty(P, desc);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const success = _temp5;
  if (success === Value.false) {
    return surroundingAgent.Throw('TypeError', 'CannotDefineProperty', P);
  }
  return success;
}
DefinePropertyOrThrow.section = 'https://tc39.es/ecma262/#sec-definepropertyorthrow';
/** https://tc39.es/ecma262/#sec-deletepropertyorthrow */
function* DeletePropertyOrThrow(O, P) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp6 = yield* O.Delete(P);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const success = _temp6;
  if (success === Value.false) {
    return surroundingAgent.Throw('TypeError', 'CannotDeleteProperty', P);
  }
  return success;
}
DeletePropertyOrThrow.section = 'https://tc39.es/ecma262/#sec-deletepropertyorthrow';
/** https://tc39.es/ecma262/#sec-getmethod */
function* GetMethod(V, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp7 = yield* GetV(V, P);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const func = _temp7;
  if (func === Value.null || func === Value.undefined) {
    return Value.undefined;
  }
  if (!IsCallable(func)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', func);
  }
  return func;
}
GetMethod.section = 'https://tc39.es/ecma262/#sec-getmethod';
/** https://tc39.es/ecma262/#sec-hasproperty */
function* HasProperty(O, P) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  return yield* O.HasProperty(P);
}
HasProperty.section = 'https://tc39.es/ecma262/#sec-hasproperty';
/** https://tc39.es/ecma262/#sec-hasownproperty */
function* HasOwnProperty(O, P) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp8 = yield* O.GetOwnProperty(P);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const desc = _temp8;
  if (desc === Value.undefined) {
    return Value.false;
  }
  return Value.true;
}
HasOwnProperty.section = 'https://tc39.es/ecma262/#sec-hasownproperty';
/** https://tc39.es/ecma262/#sec-call */
function* Call(F, V, argumentsList = []) {
  Assert(argumentsList.every(a => a instanceof Value), "argumentsList.every((a) => a instanceof Value)");
  if (!IsCallable(F)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', F);
  }
  /* ReturnIfAbrupt */
  let _temp9 = yield* F.Call(V, argumentsList);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  return EnsureCompletion(_temp9);
}
Call.section = 'https://tc39.es/ecma262/#sec-call';
/** https://tc39.es/ecma262/#sec-construct */
function* Construct(F, argumentsList = [], newTarget) {
  if (!newTarget) {
    newTarget = F;
  }
  Assert(IsConstructor(F), "IsConstructor(F)");
  Assert(IsConstructor(newTarget), "IsConstructor(newTarget)");
  return yield* F.Construct(argumentsList, newTarget);
}
Construct.section = 'https://tc39.es/ecma262/#sec-construct';
/** https://tc39.es/ecma262/#sec-setintegritylevel */
function* SetIntegrityLevel(O, level) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(level === 'sealed' || level === 'frozen', "level === 'sealed' || level === 'frozen'");
  /* ReturnIfAbrupt */
  let _temp10 = yield* O.PreventExtensions();
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const status = _temp10;
  if (status === Value.false) {
    return Value.false;
  }
  /* ReturnIfAbrupt */
  let _temp11 = yield* O.OwnPropertyKeys();
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const keys = _temp11;
  if (level === 'sealed') {
    for (const k of keys) {
      /* ReturnIfAbrupt */
      let _temp12 = yield* DefinePropertyOrThrow(O, k, _Descriptor({
        Configurable: Value.false
      }));
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    }
  } else if (level === 'frozen') {
    for (const k of keys) {
      /* ReturnIfAbrupt */
      let _temp13 = yield* O.GetOwnProperty(k);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      const currentDesc = _temp13;
      if (currentDesc !== Value.undefined) {
        let desc;
        if (IsAccessorDescriptor(currentDesc) === true) {
          desc = _Descriptor({
            Configurable: Value.false
          });
        } else {
          desc = _Descriptor({
            Configurable: Value.false,
            Writable: Value.false
          });
        }
        /* ReturnIfAbrupt */
        let _temp14 = yield* DefinePropertyOrThrow(O, k, desc);
        /* node:coverage ignore next */
        if (_temp14 instanceof AbruptCompletion) return _temp14;
        /* node:coverage ignore next */
        if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
      }
    }
  }
  return Value.true;
}
SetIntegrityLevel.section = 'https://tc39.es/ecma262/#sec-setintegritylevel';
/** https://tc39.es/ecma262/#sec-testintegritylevel */
function* TestIntegrityLevel(O, level) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  Assert(level === 'sealed' || level === 'frozen', "level === 'sealed' || level === 'frozen'");
  /* ReturnIfAbrupt */
  let _temp15 = yield* IsExtensible(O);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const extensible = _temp15;
  if (extensible === Value.true) {
    return Value.false;
  }
  /* ReturnIfAbrupt */
  let _temp16 = yield* O.OwnPropertyKeys();
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  const keys = _temp16;
  for (const k of keys) {
    /* ReturnIfAbrupt */
    let _temp17 = yield* O.GetOwnProperty(k);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    const currentDesc = _temp17;
    if (!(currentDesc instanceof UndefinedValue)) {
      if (currentDesc.Configurable === Value.true) {
        return Value.false;
      }
      if (level === 'frozen' && IsDataDescriptor(currentDesc)) {
        if (currentDesc.Writable === Value.true) {
          return Value.false;
        }
      }
    }
  }
  return Value.true;
}
TestIntegrityLevel.section = 'https://tc39.es/ecma262/#sec-testintegritylevel';
/** https://tc39.es/ecma262/#sec-createarrayfromlist */
function CreateArrayFromList(elements) {
  // 1. Assert: elements is a List whose elements are all ECMAScript language values.
  Assert(elements.every(e => e instanceof Value), "elements.every((e) => e instanceof Value)");
  // 2. Let array be ! ArrayCreate(0).
  /* X */
  let _temp18 = ArrayCreate(0);
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  const array = _temp18;
  // 3. Let n be 0.
  let n = 0;
  // 4. For each element e of elements, do
  for (const e of elements) {
    /* X */
    let _temp20 = ToString(F(n));
    /* node:coverage ignore next */
    if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) _temp20 = skipDebugger(_temp20);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) throw new Assert.Error("! ToString(toNumberValue(n)) returned an abrupt completion", {
      cause: _temp20
    });
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    /* X */
    let _temp19 = CreateDataPropertyOrThrow(array, _temp20, e);
    /* node:coverage ignore next */
    if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(array, X(ToString(toNumberValue(n))), e) returned an abrupt completion", {
      cause: _temp19
    });
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    // b. Set n to n + 1.
    n += 1;
  }
  // 5. Return array.
  return array;
}
CreateArrayFromList.section = 'https://tc39.es/ecma262/#sec-createarrayfromlist';
/** https://tc39.es/ecma262/#sec-lengthofarraylike */
function* LengthOfArrayLike(obj) {
  // 1. Assert: Type(obj) is Object.
  Assert(obj instanceof ObjectValue, "obj instanceof ObjectValue");
  // 2. Return ℝ(? ToLength(? Get(obj, "length"))).
  /* ReturnIfAbrupt */
  let _temp22 = yield* Get(obj, Value('length'));
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) return _temp22;
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  /* ReturnIfAbrupt */
  let _temp21 = yield* ToLength(_temp22);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  return R(_temp21);
}
LengthOfArrayLike.section = 'https://tc39.es/ecma262/#sec-lengthofarraylike';
/** https://tc39.es/ecma262/#sec-createlistfromarraylike */
function* CreateListFromArrayLike(obj, validElementTypes = 'all') {
  // 2. If Type(obj) is not Object, throw a TypeError exception.
  if (!(obj instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', obj);
  }
  // 3. Let len be ? LengthOfArrayLike(obj).
  /* ReturnIfAbrupt */
  let _temp23 = yield* LengthOfArrayLike(obj);
  /* node:coverage ignore next */
  if (_temp23 instanceof AbruptCompletion) return _temp23;
  /* node:coverage ignore next */
  if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
  const len = _temp23;
  // 4. Let list be a new empty List.
  const list = [];
  // 5. Let index be 0.
  let index = 0;
  // 6. Repeat, while index < len,
  while (index < len) {
    /* X */
    let _temp24 = ToString(F(index));
    /* node:coverage ignore next */
    if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) _temp24 = skipDebugger(_temp24);
    /* node:coverage ignore next */
    if (_temp24 instanceof AbruptCompletion) throw new Assert.Error("! ToString(toNumberValue(index)) returned an abrupt completion", {
      cause: _temp24
    });
    /* node:coverage ignore next */
    if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
    // a. Let indexName be ! ToString(𝔽(index)).
    const indexName = _temp24;
    // b. Let next be ? Get(obj, indexName).
    /* ReturnIfAbrupt */
    let _temp25 = yield* Get(obj, indexName);
    /* node:coverage ignore next */
    if (_temp25 instanceof AbruptCompletion) return _temp25;
    /* node:coverage ignore next */
    if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
    const next = _temp25;
    // c. If Type(next) is not an element of elementTypes, throw a TypeError exception.
    if (validElementTypes === 'property-key' && !IsPropertyKey(next)) {
      return surroundingAgent.Throw('TypeError', 'NotPropertyName', next);
    }
    // d. Append next as the last element of list.
    list.push(next);
    // e. Set index to index + 1.
    index += 1;
  }
  // 7. Return list.
  return list;
}

/** https://tc39.es/ecma262/#sec-invoke */
function* Invoke(V, P, argumentsList = []) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp26 = yield* GetV(V, P);
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  const func = _temp26;
  return yield* Call(func, V, argumentsList);
}
Invoke.section = 'https://tc39.es/ecma262/#sec-invoke';
/** https://tc39.es/ecma262/#sec-ordinaryhasinstance */
function* OrdinaryHasInstance(C, O) {
  if (!IsCallable(C)) {
    return Value.false;
  }
  if (isBoundFunctionObject(C)) {
    const BC = C.BoundTargetFunction;
    return yield* InstanceofOperator(O, BC);
  }
  if (!(O instanceof ObjectValue)) {
    return Value.false;
  }
  /* ReturnIfAbrupt */
  let _temp27 = yield* Get(C, Value('prototype'));
  /* node:coverage ignore next */
  if (_temp27 instanceof AbruptCompletion) return _temp27;
  /* node:coverage ignore next */
  if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
  const P = _temp27;
  if (!(P instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', P);
  }
  while (true) {
    /* ReturnIfAbrupt */
    let _temp28 = yield* O.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) return _temp28;
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    O = _temp28;
    if (O instanceof NullValue) {
      return Value.false;
    }
    if (SameValue(P, O) === Value.true) {
      return Value.true;
    }
  }
}
OrdinaryHasInstance.section = 'https://tc39.es/ecma262/#sec-ordinaryhasinstance';
/** https://tc39.es/ecma262/#sec-speciesconstructor */
function* SpeciesConstructor(O, defaultConstructor) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  /* ReturnIfAbrupt */
  let _temp29 = yield* Get(O, Value('constructor'));
  /* node:coverage ignore next */
  if (_temp29 instanceof AbruptCompletion) return _temp29;
  /* node:coverage ignore next */
  if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
  const C = _temp29;
  if (C === Value.undefined) {
    return defaultConstructor;
  }
  if (!(C instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', C);
  }
  /* ReturnIfAbrupt */
  let _temp30 = yield* Get(C, wellKnownSymbols.species);
  /* node:coverage ignore next */
  if (_temp30 instanceof AbruptCompletion) return _temp30;
  /* node:coverage ignore next */
  if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
  const S = _temp30;
  if (S === Value.undefined || S === Value.null) {
    return defaultConstructor;
  }
  if (IsConstructor(S)) {
    return S;
  }
  return surroundingAgent.Throw('TypeError', 'SpeciesNotConstructor');
}
SpeciesConstructor.section = 'https://tc39.es/ecma262/#sec-speciesconstructor';
/** https://tc39.es/ecma262/#sec-enumerableownpropertynames */
function* EnumerableOwnPropertyNames(O, kind) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  /* ReturnIfAbrupt */
  let _temp31 = yield* O.OwnPropertyKeys();
  /* node:coverage ignore next */
  if (_temp31 instanceof AbruptCompletion) return _temp31;
  /* node:coverage ignore next */
  if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
  const ownKeys = _temp31;
  const properties = [];
  for (const key of ownKeys) {
    if (key instanceof JSStringValue) {
      /* ReturnIfAbrupt */
      let _temp32 = yield* O.GetOwnProperty(key);
      /* node:coverage ignore next */
      if (_temp32 instanceof AbruptCompletion) return _temp32;
      /* node:coverage ignore next */
      if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
      const desc = _temp32;
      if (!(desc instanceof UndefinedValue) && desc.Enumerable === Value.true) {
        if (kind === 'key') {
          properties.push(key);
        } else {
          /* ReturnIfAbrupt */
          let _temp33 = yield* Get(O, key);
          /* node:coverage ignore next */
          if (_temp33 instanceof AbruptCompletion) return _temp33;
          /* node:coverage ignore next */
          if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
          const value = _temp33;
          if (kind === 'value') {
            properties.push(value);
          } else {
            Assert(kind === 'key+value', "kind === 'key+value'");
            /* X */
            let _temp34 = CreateArrayFromList([key, value]);
            /* node:coverage ignore next */
            if (_temp34 && typeof _temp34 === 'object' && 'next' in _temp34) _temp34 = skipDebugger(_temp34);
            /* node:coverage ignore next */
            if (_temp34 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList([key, value]) returned an abrupt completion", {
              cause: _temp34
            });
            /* node:coverage ignore next */
            if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
            const entry = _temp34;
            properties.push(entry);
          }
        }
      }
    }
  }
  return properties;
}

/** https://tc39.es/ecma262/#sec-getfunctionrealm */
function GetFunctionRealm(obj) {
  Assert(IsCallable(obj), "IsCallable(obj)");
  if ('Realm' in obj) {
    return obj.Realm;
  }
  if (isBoundFunctionObject(obj)) {
    const target = obj.BoundTargetFunction;
    return GetFunctionRealm(target);
  }
  if (isProxyExoticObject(obj)) {
    if (obj.ProxyHandler instanceof NullValue) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'GetFunctionRealm');
    }
    const proxyTarget = obj.ProxyTarget;
    return GetFunctionRealm(proxyTarget);
  }
  return surroundingAgent.currentRealmRecord;
}
GetFunctionRealm.section = 'https://tc39.es/ecma262/#sec-getfunctionrealm';
/** https://tc39.es/ecma262/#sec-copydataproperties */
function* CopyDataProperties(target, source, excludedItems) {
  Assert(target instanceof ObjectValue, "target instanceof ObjectValue");
  Assert(excludedItems.every(i => IsPropertyKey(i)), "excludedItems.every((i) => IsPropertyKey(i))");
  if (source === Value.undefined || source === Value.null) {
    return target;
  }
  /* X */
  let _temp35 = ToObject(source);
  /* node:coverage ignore next */
  if (_temp35 && typeof _temp35 === 'object' && 'next' in _temp35) _temp35 = skipDebugger(_temp35);
  /* node:coverage ignore next */
  if (_temp35 instanceof AbruptCompletion) throw new Assert.Error("! ToObject(source) returned an abrupt completion", {
    cause: _temp35
  });
  /* node:coverage ignore next */
  if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
  const from = _temp35;
  /* ReturnIfAbrupt */
  let _temp36 = yield* from.OwnPropertyKeys();
  /* node:coverage ignore next */
  if (_temp36 instanceof AbruptCompletion) return _temp36;
  /* node:coverage ignore next */
  if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
  const keys = _temp36;
  for (const nextKey of keys) {
    let excluded = false;
    for (const e of excludedItems) {
      if (SameValue(e, nextKey) === Value.true) {
        excluded = true;
      }
    }
    if (excluded === false) {
      /* ReturnIfAbrupt */
      let _temp37 = yield* from.GetOwnProperty(nextKey);
      /* node:coverage ignore next */
      if (_temp37 instanceof AbruptCompletion) return _temp37;
      /* node:coverage ignore next */
      if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
      const desc = _temp37;
      if (!(desc instanceof UndefinedValue) && desc.Enumerable === Value.true) {
        /* ReturnIfAbrupt */
        let _temp38 = yield* Get(from, nextKey);
        /* node:coverage ignore next */
        if (_temp38 instanceof AbruptCompletion) return _temp38;
        /* node:coverage ignore next */
        if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
        const propValue = _temp38;
        /* X */
        let _temp39 = CreateDataProperty(target, nextKey, propValue);
        /* node:coverage ignore next */
        if (_temp39 && typeof _temp39 === 'object' && 'next' in _temp39) _temp39 = skipDebugger(_temp39);
        /* node:coverage ignore next */
        if (_temp39 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(target, nextKey, propValue) returned an abrupt completion", {
          cause: _temp39
        });
        /* node:coverage ignore next */
        if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
      }
    }
  }
  return target;
}
CopyDataProperties.section = 'https://tc39.es/ecma262/#sec-copydataproperties';
/** https://tc39.es/ecma262/#sec-SetterThatIgnoresPrototypeProperties */
function* SetterThatIgnoresPrototypeProperties(thisValue, home, p, v) {
  // 1. If thisValue is not an Object, then
  if (!(thisValue instanceof ObjectValue)) {
    // a. Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'NotAnObject', thisValue);
  }
  // 2. If SameValue(thisValue, home) is true, then
  if (SameValue(thisValue, home) === Value.true) {
    // a. NOTE: Throwing here emulates assignment to a non-writable data property on the home object in strict mode code.
    // b. Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotSetProperty', p, thisValue);
  }
  // 3. Let desc be ? thisValue.[[GetOwnProperty]](p).
  /* ReturnIfAbrupt */
  let _temp40 = yield* thisValue.GetOwnProperty(p);
  /* node:coverage ignore next */
  if (_temp40 instanceof AbruptCompletion) return _temp40;
  /* node:coverage ignore next */
  if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
  const desc = _temp40;
  // 4. If desc is undefined, then
  if (desc === Value.undefined) {
    /* ReturnIfAbrupt */
    let _temp41 = yield* CreateDataPropertyOrThrow(thisValue, p, v);
    /* node:coverage ignore next */
    if (_temp41 instanceof AbruptCompletion) return _temp41;
    /* node:coverage ignore next */
    if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
  } else {
    /* ReturnIfAbrupt */
    let _temp42 = yield* Set$1(thisValue, p, v, Value.true);
    /* node:coverage ignore next */
    if (_temp42 instanceof AbruptCompletion) return _temp42;
    /* node:coverage ignore next */
    if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
  }
  // 6. Return unused.
  return undefined;
}
SetterThatIgnoresPrototypeProperties.section = 'https://tc39.es/ecma262/#sec-SetterThatIgnoresPrototypeProperties';

// TODO: ban other direct extension from ObjectValue in the linter

// 9.1.1.1 OrdinaryGetPrototypeOf
function OrdinaryGetPrototypeOf(O) {
  return O.Prototype;
}

// 9.1.2.1 OrdinarySetPrototypeOf
function OrdinarySetPrototypeOf(O, V) {
  Assert(V instanceof ObjectValue || V instanceof NullValue, "V instanceof ObjectValue || V instanceof NullValue");
  const current = O.Prototype;
  if (SameValue(V, current) === Value.true) {
    return Value.true;
  }
  const extensible = O.Extensible;
  if (extensible === Value.false) {
    return Value.false;
  }
  let p = V;
  let done = false;
  while (done === false) {
    if (p instanceof NullValue) {
      done = true;
    } else if (SameValue(p, O) === Value.true) {
      return Value.false;
    } else if (p.GetPrototypeOf !== ObjectValue.prototype.GetPrototypeOf) {
      done = true;
    } else {
      p = p.Prototype;
    }
  }
  O.Prototype = V;
  return Value.true;
}

// 9.1.3.1 OrdinaryIsExtensible
function OrdinaryIsExtensible(O) {
  return O.Extensible;
}

// 9.1.4.1 OrdinaryPreventExtensions
function OrdinaryPreventExtensions(O) {
  O.Extensible = Value.false;
  return Value.true;
}

// 9.1.5.1 OrdinaryGetOwnProperty
function OrdinaryGetOwnProperty(O, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  if (!O.properties.has(P)) {
    return Value.undefined;
  }
  const D = {};
  const x = O.properties.get(P);
  if (IsDataDescriptor(x)) {
    D.Value = x.Value;
    D.Writable = x.Writable;
  } else if (IsAccessorDescriptor(x)) {
    D.Get = x.Get;
    D.Set = x.Set;
  }
  D.Enumerable = x.Enumerable;
  D.Configurable = x.Configurable;
  return _Descriptor(D);
}

// 9.1.6.1 OrdinaryDefineOwnProperty
function* OrdinaryDefineOwnProperty(O, P, Desc) {
  /* ReturnIfAbrupt */
  let _temp = yield* O.GetOwnProperty(P);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const current = _temp;
  /* ReturnIfAbrupt */
  let _temp2 = yield* IsExtensible(O);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const extensible = _temp2;
  return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
}

/** https://tc39.es/ecma262/#sec-iscompatiblepropertydescriptor */
function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
  return ValidateAndApplyPropertyDescriptor(Value.undefined, Value.undefined, Extensible, Desc, Current);
}
IsCompatiblePropertyDescriptor.section = 'https://tc39.es/ecma262/#sec-iscompatiblepropertydescriptor'; // 9.1.6.3 ValidateAndApplyPropertyDescriptor
function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
  Assert(O === Value.undefined || IsPropertyKey(P), "O === Value.undefined || IsPropertyKey(P)");
  if (current === Value.undefined) {
    if (extensible === Value.false) {
      return Value.false;
    }
    Assert(extensible === Value.true, "extensible === Value.true");
    if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
      if (!(O instanceof UndefinedValue)) {
        O.properties.set(P, _Descriptor({
          Value: Desc.Value === undefined ? Value.undefined : Desc.Value,
          Writable: Desc.Writable === undefined ? Value.false : Desc.Writable,
          Enumerable: Desc.Enumerable === undefined ? Value.false : Desc.Enumerable,
          Configurable: Desc.Configurable === undefined ? Value.false : Desc.Configurable
        }));
      }
    } else {
      Assert(IsAccessorDescriptor(Desc), "IsAccessorDescriptor(Desc)");
      if (!(O instanceof UndefinedValue)) {
        O.properties.set(P, _Descriptor({
          Get: Desc.Get === undefined ? Value.undefined : Desc.Get,
          Set: Desc.Set === undefined ? Value.undefined : Desc.Set,
          Enumerable: Desc.Enumerable === undefined ? Value.false : Desc.Enumerable,
          Configurable: Desc.Configurable === undefined ? Value.false : Desc.Configurable
        }));
      }
    }
    return Value.true;
  }
  if (Desc.everyFieldIsAbsent()) {
    return Value.true;
  }
  if (current.Configurable === Value.false) {
    if (Desc.Configurable !== undefined && Desc.Configurable === Value.true) {
      return Value.false;
    }
    if (Desc.Enumerable !== undefined && Desc.Enumerable !== current.Enumerable) {
      return Value.false;
    }
  }
  if (IsGenericDescriptor(Desc)) ; else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
    if (current.Configurable === Value.false) {
      return Value.false;
    }
    if (IsDataDescriptor(current)) {
      if (!(O instanceof UndefinedValue)) {
        const entry = {
          ...O.properties.get(P)
        };
        entry.Value = undefined;
        entry.Writable = undefined;
        entry.Get = Value.undefined;
        entry.Set = Value.undefined;
        O.properties.set(P, _Descriptor(entry));
      }
    } else {
      if (!(O instanceof UndefinedValue)) {
        const entry = {
          ...O.properties.get(P)
        };
        entry.Get = undefined;
        entry.Set = undefined;
        entry.Value = Value.undefined;
        entry.Writable = Value.false;
        O.properties.set(P, _Descriptor(entry));
      }
    }
  } else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
    if (current.Configurable === Value.false && current.Writable === Value.false) {
      if (Desc.Writable !== undefined && Desc.Writable === Value.true) {
        return Value.false;
      }
      if (Desc.Value !== undefined && SameValue(Desc.Value, current.Value) === Value.false) {
        return Value.false;
      }
      return Value.true;
    }
  } else {
    Assert(IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc), "IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)");
    if (current.Configurable === Value.false) {
      if (Desc.Set !== undefined && SameValue(Desc.Set, current.Set) === Value.false) {
        return Value.false;
      }
      if (Desc.Get !== undefined && SameValue(Desc.Get, current.Get) === Value.false) {
        return Value.false;
      }
      return Value.true;
    }
  }
  if (!(O instanceof UndefinedValue)) {
    const target = {
      ...O.properties.get(P)
    };
    if (Desc.Value !== undefined) {
      target.Value = Desc.Value;
    }
    if (Desc.Writable !== undefined) {
      target.Writable = Desc.Writable;
    }
    if (Desc.Get !== undefined) {
      target.Get = Desc.Get;
    }
    if (Desc.Set !== undefined) {
      target.Set = Desc.Set;
    }
    if (Desc.Enumerable !== undefined) {
      target.Enumerable = Desc.Enumerable;
    }
    if (Desc.Configurable !== undefined) {
      target.Configurable = Desc.Configurable;
    }
    O.properties.set(P, _Descriptor(target));
  }
  return Value.true;
}

// 9.1.7.1 OrdinaryHasProperty
function* OrdinaryHasProperty(O, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp3 = yield* O.GetOwnProperty(P);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const hasOwn = _temp3;
  if (!(hasOwn instanceof UndefinedValue)) {
    return Value.true;
  }
  /* ReturnIfAbrupt */
  let _temp4 = yield* O.GetPrototypeOf();
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const parent = _temp4;
  if (!(parent instanceof NullValue)) {
    return yield* parent.HasProperty(P);
  }
  return Value.false;
}

// 9.1.8.1
function* OrdinaryGet(O, P, Receiver) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp5 = yield* O.GetOwnProperty(P);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const desc = _temp5;
  if (desc instanceof UndefinedValue) {
    /* ReturnIfAbrupt */
    let _temp6 = yield* O.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    const parent = _temp6;
    if (parent instanceof NullValue) {
      return Value.undefined;
    }
    return yield* parent.Get(P, Receiver);
  }
  if (IsDataDescriptor(desc)) {
    return desc.Value;
  }
  Assert(IsAccessorDescriptor(desc), "IsAccessorDescriptor(desc)");
  const getter = desc.Get;
  if (getter instanceof UndefinedValue) {
    return Value.undefined;
  }
  return yield* Call(getter, Receiver);
}

// 9.1.9.1 OrdinarySet
function* OrdinarySet(O, P, V, Receiver) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp7 = yield* O.GetOwnProperty(P);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const ownDesc = _temp7;
  return yield* OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc);
}

// 9.1.9.2 OrdinarySetWithOwnDescriptor
function* OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  if (ownDesc instanceof UndefinedValue) {
    /* ReturnIfAbrupt */
    let _temp8 = yield* O.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    const parent = _temp8;
    if (!(parent instanceof NullValue)) {
      return yield* parent.Set(P, V, Receiver);
    }
    ownDesc = _Descriptor({
      Value: Value.undefined,
      Writable: Value.true,
      Enumerable: Value.true,
      Configurable: Value.true
    });
  }
  if (IsDataDescriptor(ownDesc)) {
    if (ownDesc.Writable !== undefined && ownDesc.Writable === Value.false) {
      return Value.false;
    }
    if (!(Receiver instanceof ObjectValue)) {
      return Value.false;
    }
    /* ReturnIfAbrupt */
    let _temp9 = yield* Receiver.GetOwnProperty(P);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    const existingDescriptor = _temp9;
    if (!(existingDescriptor instanceof UndefinedValue)) {
      if (IsAccessorDescriptor(existingDescriptor)) {
        return Value.false;
      }
      if (existingDescriptor.Writable === Value.false) {
        return Value.false;
      }
      const valueDesc = _Descriptor({
        Value: V
      });
      return yield* Receiver.DefineOwnProperty(P, valueDesc);
    }
    return yield* CreateDataProperty(Receiver, P, V);
  }
  Assert(IsAccessorDescriptor(ownDesc), "IsAccessorDescriptor(ownDesc)");
  const setter = ownDesc.Set;
  if (setter === undefined || setter instanceof UndefinedValue) {
    return Value.false;
  }
  /* ReturnIfAbrupt */
  let _temp10 = yield* Call(setter, Receiver, [V]);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  return Value.true;
}

// 9.1.10.1 OrdinaryDelete
function* OrdinaryDelete(O, P) {
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  /* ReturnIfAbrupt */
  let _temp11 = yield* O.GetOwnProperty(P);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const desc = _temp11;
  if (desc instanceof UndefinedValue) {
    return Value.true;
  }
  if (desc.Configurable === Value.true) {
    O.properties.delete(P);
    return Value.true;
  }
  return Value.false;
}

// 9.1.11.1
function OrdinaryOwnPropertyKeys(O) {
  const keys = [];

  // For each own property key P of O that is an array index, in ascending numeric index order, do
  //   Add P as the last element of keys.
  for (const P of O.properties.keys()) {
    if (isArrayIndex(P)) {
      keys.push(P);
    }
  }
  keys.sort((a, b) => Number.parseInt(a.stringValue(), 10) - Number.parseInt(b.stringValue(), 10));

  // For each own property key P of O such that Type(P) is String and
  // P is not an array index, in ascending chronological order of property creation, do
  //   Add P as the last element of keys.
  for (const P of O.properties.keys()) {
    if (P instanceof JSStringValue && isArrayIndex(P) === false) {
      keys.push(P);
    }
  }

  // For each own property key P of O such that Type(P) is Symbol,
  // in ascending chronological order of property creation, do
  //   Add P as the last element of keys.
  for (const P of O.properties.keys()) {
    if (P instanceof SymbolValue) {
      keys.push(P);
    }
  }
  return keys;
}

/** https://tc39.es/ecma262/#sec-ordinaryobjectcreate */
function OrdinaryObjectCreate(proto, additionalInternalSlotsList) {
  Assert(!!proto, "!!proto");
  // 1. Let internalSlotsList be « [[Prototype]], [[Extensible]] ».
  const internalSlotsList = ['Prototype', 'Extensible'];
  // 2. If additionalInternalSlotsList is present, append each of its elements to internalSlotsList.
  if (additionalInternalSlotsList !== undefined) {
    internalSlotsList.push(...additionalInternalSlotsList);
  }
  // 3. Let O be ! MakeBasicObject(internalSlotsList).
  /* X */
  let _temp12 = MakeBasicObject(internalSlotsList);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! MakeBasicObject(internalSlotsList) returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  const O = _temp12;
  // 4. Set O.[[Prototype]] to proto.
  O.Prototype = proto;
  // 5. Return O.
  return O;
}
OrdinaryObjectCreate.section = 'https://tc39.es/ecma262/#sec-ordinaryobjectcreate';
/** This is a helper function to define non-spec host objects. */
OrdinaryObjectCreate.from = (object, proto) => {
  const O = OrdinaryObjectCreate(proto || surroundingAgent.intrinsic('%Object.prototype%'));
  for (const key in object) {
    if (Object.hasOwn(object, key)) {
      const value = object[key];
      /* X */
      let _temp13 = CreateDataProperty(O, Value(key), value instanceof Value ? value : CreateBuiltinFunction.from(value, key));
      /* node:coverage ignore next */
      if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(O, Value(key), value instanceof Value ? value : CreateBuiltinFunction.from(value, key)) returned an abrupt completion", {
        cause: _temp13
      });
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    }
  }
  return O;
};

// 9.1.13 OrdinaryCreateFromConstructor
function* OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto, internalSlotsList) {
  /* ReturnIfAbrupt */
  let _temp14 = yield* GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  // Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object.
  const proto = _temp14;
  return OrdinaryObjectCreate(proto, internalSlotsList);
}

// 9.1.14 GetPrototypeFromConstructor
function* GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
  // Assert: intrinsicDefaultProto is a String value that
  // is this specification's name of an intrinsic object.
  Assert(IsCallable(constructor), "IsCallable(constructor)");
  /* ReturnIfAbrupt */
  let _temp15 = yield* Get(constructor, Value('prototype'));
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  let proto = _temp15;
  if (!(proto instanceof ObjectValue)) {
    /* ReturnIfAbrupt */
    let _temp16 = GetFunctionRealm(constructor);
    /* node:coverage ignore next */
    if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) return _temp16;
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    const realm = _temp16;
    proto = realm.Intrinsics[intrinsicDefaultProto];
  }
  return proto;
}

/** https://tc39.es/ecma262/#sec-privateelementfind */
function PrivateElementFind(P, O) {
  const entry = O.PrivateElements.find(e => e.Key === P);
  // 1. If O.[[PrivateElements]] contains a PrivateElement whose [[Key]] is P, then
  if (entry) {
    // a. Let entry be that PrivateElement.
    // b. Return entry.
    return entry;
  }
  // 2. Return empty.
  return undefined;
}
PrivateElementFind.section = 'https://tc39.es/ecma262/#sec-privateelementfind';
/** https://tc39.es/ecma262/#sec-privateget */
function* PrivateGet(O, P) {
  /* X */
  let _temp = PrivateElementFind(P, O);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! PrivateElementFind(P, O) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let entry be ! PrivateElementFind(P, O).
  const entry = _temp;
  // 2. If entry is empty, throw a TypeError exception.
  if (entry === undefined) {
    return surroundingAgent.Throw('TypeError', 'UnknownPrivateName', O, P);
  }
  // 3. If entry.[[Kind]] is field or method, then
  if (entry.Kind === 'field' || entry.Kind === 'method') {
    // a. Return entry.[[Value]].
    return entry.Value;
  }
  // 4. Assert: entry.[[Kind]] is accessor.
  Assert(entry.Kind === 'accessor', "entry.Kind === 'accessor'");
  // 5. If entry.[[Get]] is undefined, throw a TypeError exception.
  if (entry.Get === Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'PrivateNameNoGetter', P);
  }
  // 6. Let getter be entry.[[Get]].
  const getter = entry.Get;
  // 7. Return ? Call(getter, O).
  return yield* Call(getter, O);
}
PrivateGet.section = 'https://tc39.es/ecma262/#sec-privateget';
function* PrivateSet(O, P, value) {
  /* X */
  let _temp2 = PrivateElementFind(P, O);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! PrivateElementFind(P, O) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Let entry be ! PrivateElementFind(P, O).
  const entry = _temp2;
  // 2. If entry is empty, throw a TypeError exception.
  if (entry === undefined) {
    return surroundingAgent.Throw('TypeError', 'UnknownPrivateName', O, P);
  }
  // 3. If entry.[[Kind]] is field, then
  if (entry.Kind === 'field') {
    // a. Set entry.[[Value]] to value.
    entry.Value = value;
  } else if (entry.Kind === 'method') {
    // 4. Else if entry.[[Kind]] is method, then
    // a. Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'PrivateNameIsMethod', P);
  } else {
    // 5. Else,
    // a. Assert: entry.[[Kind]] is accessor.
    Assert(entry.Kind === 'accessor', "entry.Kind === 'accessor'");
    // b. If entry.[[Set]] is undefined, throw a TypeError exception.
    if (entry.Set === Value.undefined) {
      return surroundingAgent.Throw('TypeError', 'PrivateNameNoSetter', P);
    }
    // c. Let setter be entry.[[Set]].
    const setter = entry.Set;
    // d. Perform ? Call(setter, O, « value »).
    /* ReturnIfAbrupt */
    let _temp3 = yield* Call(setter, O, [value]);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }
  return undefined;
}

/** https://tc39.es/ecma262/#sec-privatemethodoraccessoradd */
function PrivateMethodOrAccessorAdd(method, O) {
  // 1. Assert: method.[[Kind]] is either method or accessor.
  Assert(method.Kind === 'method' || method.Kind === 'accessor', "method.Kind === 'method' || method.Kind === 'accessor'");
  // 2. Let entry be ! PrivateElementFind(method.[[Key]], O).
  /* X */
  let _temp4 = PrivateElementFind(method.Key, O);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! PrivateElementFind(method.Key, O) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const entry = _temp4;
  // 3. If entry is not empty, throw a TypeError exception.
  if (entry !== undefined) {
    return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', method.Key);
  }
  // 4. Append method to O.[[PrivateElements]].
  O.PrivateElements.push(method);
  // 5. NOTE: The values for private methods and accessors are shared across instances.
  //          This step does not create a new copy of the method or accessor.
  return undefined;
}
PrivateMethodOrAccessorAdd.section = 'https://tc39.es/ecma262/#sec-privatemethodoraccessoradd';
/** https://tc39.es/ecma262/#sec-privatefieldadd */
function PrivateFieldAdd(P, O, value) {
  /* X */
  let _temp5 = PrivateElementFind(P, O);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! PrivateElementFind(P, O) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 1. Let entry be ! PrivateElementFind(P, O).
  const entry = _temp5;
  // 2. If entry is not empty, throw a TypeError exception.
  if (entry !== undefined) {
    return surroundingAgent.Throw('TypeError', 'AlreadyDeclared', P);
  }
  // 3. Append PrivateElement { [[Key]]: P, [[Kind]]: field, [[Value]]: value } to O.[[PrivateElements]].
  O.PrivateElements.push(new PrivateElementRecord({
    Key: P,
    Kind: 'field',
    Value: value
  }));
  return undefined;
}
PrivateFieldAdd.section = 'https://tc39.es/ecma262/#sec-privatefieldadd';

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-promise-objects */

/** https://tc39.es/ecma262/#sec-promise.all-resolve-element-functions */

/** https://tc39.es/ecma262/#sec-promise.any-reject-element-functions */

/** https://tc39.es/ecma262/#sec-promisecapability-records */
class PromiseCapabilityRecord {
  Promise;
  Resolve = Value.undefined;
  Reject = Value.undefined;
}

/** https://tc39.es/ecma262/#sec-promisereaction-records */
class PromiseReactionRecord {
  Capability;
  Type;
  Handler;
  constructor(O) {
    Assert(O.Capability instanceof PromiseCapabilityRecord || O.Capability === Value.undefined, "O.Capability instanceof PromiseCapabilityRecord\n        || O.Capability === Value.undefined");
    Assert(O.Type === 'Fulfill' || O.Type === 'Reject', "O.Type === 'Fulfill' || O.Type === 'Reject'");
    Assert(O.Handler === undefined || isFunctionObject(O.Handler.Callback), "O.Handler === undefined\n           || isFunctionObject(O.Handler.Callback)");
    this.Capability = O.Capability;
    this.Type = O.Type;
    this.Handler = O.Handler;
  }
}

/** https://tc39.es/ecma262/#sec-createresolvingfunctions */
function CreateResolvingFunctions(promise) {
  // 1. Let alreadyResolved be the Record { [[Value]]: false }.
  const alreadyResolved = {
    Value: false
  };
  // 2. Let stepsResolve be the algorithm steps defined in Promise Resolve Functions.
  const stepsResolve = PromiseResolveFunctions;
  // 3. Let lengthResolve be the number of non-optional parameters of the function definition in Promise Resolve Functions.
  const lengthResolve = 1;
  // 4. Let resolve be ! CreateBuiltinFunction(stepsResolve, lengthResolve, "", « [[Promise]], [[AlreadyResolved]] »).
  /* X */
  let _temp = CreateBuiltinFunction(stepsResolve, lengthResolve, Value(''), ['Promise', 'AlreadyResolved']);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(stepsResolve, lengthResolve, Value(''), ['Promise', 'AlreadyResolved']) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const resolve = _temp;
  // 5. Set resolve.[[Promise]] to promise.
  resolve.Promise = promise;
  // 6. Set resolve.[[AlreadyResolved]] to alreadyResolved.
  resolve.AlreadyResolved = alreadyResolved;
  // 7. Let stepsReject be the algorithm steps defined in Promise Reject Functions.
  const stepsReject = PromiseRejectFunctions;
  // 8. Let lengthReject be the number of non-optional parameters of the function definition in Promise Reject Functions.
  const lengthReject = 1;
  // 9. Let reject be ! CreateBuiltinFunction(stepsReject, lengthReject, "", « [[Promise]], [[AlreadyResolved]] »).
  /* X */
  let _temp2 = CreateBuiltinFunction(stepsReject, lengthReject, Value(''), ['Promise', 'AlreadyResolved']);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(stepsReject, lengthReject, Value(''), ['Promise', 'AlreadyResolved']) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const reject = _temp2;
  // 10. Set reject.[[Promise]] to promise.
  reject.Promise = promise;
  // 11. Set reject.[[AlreadyResolved]] to alreadyResolved.
  reject.AlreadyResolved = alreadyResolved;
  // 12. Return the Record { [[Resolve]]: resolve, [[Reject]]: reject }.
  return {
    Resolve: resolve,
    Reject: reject
  };
}
CreateResolvingFunctions.section = 'https://tc39.es/ecma262/#sec-createresolvingfunctions';
/** https://tc39.es/ecma262/#sec-promise-reject-functions */
function PromiseRejectFunctions([reason = Value.undefined]) {
  const F = this;
  Assert('Promise' in F && F.Promise instanceof ObjectValue, "'Promise' in F && F.Promise instanceof ObjectValue");
  const promise = F.Promise;
  const alreadyResolved = F.AlreadyResolved;
  if (alreadyResolved.Value === true) {
    return Value.undefined;
  }
  /* ReturnIfAbrupt */
  let _temp3 = surroundingAgent.debugger_tryTouchDuringPreview(promise);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  alreadyResolved.Value = true;
  return RejectPromise(promise, reason);
}
PromiseRejectFunctions.section = 'https://tc39.es/ecma262/#sec-promise-reject-functions';
/** https://tc39.es/ecma262/#sec-newpromiseresolvethenablejob */
function NewPromiseResolveThenableJob(promiseToResolve, thenable, then) {
  // 1. Let job be a new Job abstract closure with no parameters that captures
  //    promiseToResolve, thenable, and then and performs the following steps when called:
  function* job() {
    // a. Let resolvingFunctions be CreateResolvingFunctions(promiseToResolve).
    const resolvingFunctions = CreateResolvingFunctions(promiseToResolve);
    // b. Let thenCallResult be HostCallJobCallback(then, thenable, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »).
    const thenCallResult = yield* HostCallJobCallback(then, thenable, [resolvingFunctions.Resolve, resolvingFunctions.Reject]);
    // c. If thenCallResult is an abrupt completion, then
    if (thenCallResult instanceof AbruptCompletion) {
      // i .Let status be Call(resolvingFunctions.[[Reject]], undefined, « thenCallResult.[[Value]] »).
      const status = yield* Call(resolvingFunctions.Reject, Value.undefined, [thenCallResult.Value]);
      // ii. Return Completion(status).
      return status;
    }
    // d. Return Completion(thenCallResult).
    return EnsureCompletion(thenCallResult);
  }
  // 2. Let getThenRealmResult be GetFunctionRealm(then.[[Callback]]).
  const getThenRealmResult = EnsureCompletion(GetFunctionRealm(then.Callback));
  // 3. If getThenRealmResult is a normal completion, then let thenRealm be getThenRealmResult.[[Value]].
  let thenRealm;
  if (getThenRealmResult instanceof NormalCompletion) {
    thenRealm = getThenRealmResult.Value;
  } else {
    // 4. Else, let _thenRealm_ be the current Realm Record.
    thenRealm = surroundingAgent.currentRealmRecord;
  }
  // 5. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.
  // 6. Return { [[Job]]: job, [[Realm]]: thenRealm }.
  return {
    Job: job,
    Realm: thenRealm
  };
}
NewPromiseResolveThenableJob.section = 'https://tc39.es/ecma262/#sec-newpromiseresolvethenablejob';
/** https://tc39.es/ecma262/#sec-promise-resolve-functions */
function* PromiseResolveFunctions([resolution = Value.undefined]) {
  // 1. Let F be the active function object.
  const F = this;
  // 2. Assert: F has a [[Promise]] internal slot whose value is an Object.
  Assert('Promise' in F && F.Promise instanceof ObjectValue, "'Promise' in F && F.Promise instanceof ObjectValue");
  // 3. Let promise be F.[[Promise]].
  const promise = F.Promise;
  // 4. Let alreadyResolved be F.[[AlreadyResolved]].
  const alreadyResolved = F.AlreadyResolved;
  // 5. If alreadyResolved.[[Value]] is true, return undefined.
  if (alreadyResolved.Value === true) {
    return Value.undefined;
  }
  /* ReturnIfAbrupt */
  let _temp4 = surroundingAgent.debugger_tryTouchDuringPreview(promise);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 6. Set alreadyResolved.[[Value]] to true.
  alreadyResolved.Value = true;
  // 7. If SameValue(resolution, promise) is true, then
  if (SameValue(resolution, promise) === Value.true) {
    // a. Let selfResolutionError be a newly created TypeError object.
    const selfResolutionError = surroundingAgent.Throw('TypeError', 'CannotResolvePromiseWithItself').Value;
    // b. Return RejectPromise(promise, selfResolutionError).
    return RejectPromise(promise, selfResolutionError);
  }
  // 8. If Type(resolution) is not Object, then
  if (!(resolution instanceof ObjectValue)) {
    // a. Return FulfillPromise(promise, resolution).
    return FulfillPromise(promise, resolution);
  }
  // 9. Let then be Get(resolution, "then").
  const then = EnsureCompletion(yield* Get(resolution, Value('then')));
  // 10. If then is an abrupt completion, then
  if (then instanceof AbruptCompletion) {
    // a. Return RejectPromise(promise, then.[[Value]]).
    return RejectPromise(promise, then.Value);
  }
  // 11. Let thenAction be then.[[Value]].
  const thenAction = then.Value;
  // 12. If IsCallable(thenAction) is false, then
  if (!IsCallable(thenAction)) {
    // a. Return FulfillPromise(promise, resolution).
    return FulfillPromise(promise, resolution);
  }
  if (surroundingAgent.debugger_isPreviewing) {
    return Value.undefined;
  }
  // 13. Let thenJobCallback be HostMakeJobCallback(thenAction).
  const thenJobCallback = HostMakeJobCallback(thenAction);
  // 14. Let job be NewPromiseResolveThenableJob(promise, resolution, thenJobCallback).
  const job = NewPromiseResolveThenableJob(promise, resolution, thenJobCallback);
  // 15. Perform HostEnqueuePromiseJob(job.[[Job]], job.[[Realm]]).
  HostEnqueuePromiseJob(job.Job);
  // 16. Return undefined.
  return Value.undefined;
}
PromiseResolveFunctions.section = 'https://tc39.es/ecma262/#sec-promise-resolve-functions';
/** https://tc39.es/ecma262/#sec-fulfillpromise */
function FulfillPromise(promise, value) {
  Assert(promise.PromiseState === 'pending', "promise.PromiseState === 'pending'");
  const reactions = promise.PromiseFulfillReactions;
  promise.PromiseResult = value;
  promise.PromiseFulfillReactions = undefined;
  promise.PromiseRejectReactions = undefined;
  promise.PromiseState = 'fulfilled';
  return TriggerPromiseReactions(reactions, value);
}
FulfillPromise.section = 'https://tc39.es/ecma262/#sec-fulfillpromise';
/** https://tc39.es/ecma262/#sec-newpromisecapability */
function* NewPromiseCapability(C) {
  // 1. If IsConstructor(C) is false, throw a TypeError exception.
  if (!IsConstructor(C)) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', C);
  }
  // 2. NOTE: C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 26.2.3.1).
  // 3. Let promiseCapability be the PromiseCapability Record { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.
  const promiseCapability = new PromiseCapabilityRecord();
  // 4. Let executorClosure be a new Abstract Closure with parameters (resolve, reject) that captures promiseCapability and performs the following steps when called:
  const executorClosure = ([resolve = Value.undefined, reject = Value.undefined]) => {
    // a. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.
    if (!(promiseCapability.Resolve instanceof UndefinedValue)) {
      return surroundingAgent.Throw('TypeError', 'PromiseCapabilityFunctionAlreadySet', 'resolve');
    }
    // b. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.
    if (!(promiseCapability.Reject instanceof UndefinedValue)) {
      return surroundingAgent.Throw('TypeError', 'PromiseCapabilityFunctionAlreadySet', 'reject');
    }
    // c. Set promiseCapability.[[Resolve]] to resolve.
    promiseCapability.Resolve = resolve;
    // d. Set promiseCapability.[[Reject]] to reject.
    promiseCapability.Reject = reject;
    // e. Return undefined.
    return Value.undefined;
  };
  // 5. Let executor be ! CreateBuiltinFunction(executorClosure, 2, "", « »).
  /* X */
  let _temp5 = CreateBuiltinFunction(executorClosure, 2, Value(''), []);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(executorClosure, 2, Value(''), []) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const executor = _temp5;
  // 8. Let promise be ? Construct(C, « executor »).
  /* ReturnIfAbrupt */
  let _temp6 = yield* Construct(C, [executor]);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const promise = _temp6;
  // 9. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.
  if (!IsCallable(promiseCapability.Resolve)) {
    return surroundingAgent.Throw('TypeError', 'PromiseResolveFunction', promiseCapability.Resolve);
  }
  // 10. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.
  if (!IsCallable(promiseCapability.Reject)) {
    return surroundingAgent.Throw('TypeError', 'PromiseRejectFunction', promiseCapability.Reject);
  }
  // 11. Set promiseCapability.[[Promise]] to promise.
  promiseCapability.Promise = promise;
  // 12. Return promiseCapability.
  return NormalCompletion(promiseCapability);
}
NewPromiseCapability.section = 'https://tc39.es/ecma262/#sec-newpromisecapability';
/** https://tc39.es/ecma262/#sec-ispromise */
function IsPromise(x) {
  if (!(x instanceof ObjectValue)) {
    return Value.false;
  }
  if (!('PromiseState' in x)) {
    return Value.false;
  }
  return Value.true;
}
IsPromise.section = 'https://tc39.es/ecma262/#sec-ispromise';
/** https://tc39.es/ecma262/#sec-rejectpromise */
function RejectPromise(promise, reason) {
  Assert(promise.PromiseState === 'pending', "promise.PromiseState === 'pending'");
  const reactions = promise.PromiseRejectReactions;
  promise.PromiseResult = reason;
  promise.PromiseFulfillReactions = undefined;
  promise.PromiseRejectReactions = undefined;
  promise.PromiseState = 'rejected';
  if (promise.PromiseIsHandled === Value.false) {
    HostPromiseRejectionTracker(promise, 'reject');
  }
  return TriggerPromiseReactions(reactions, reason);
}
RejectPromise.section = 'https://tc39.es/ecma262/#sec-rejectpromise';
/** https://tc39.es/ecma262/#sec-triggerpromisereactions */
function TriggerPromiseReactions(reactions, argument) {
  // 1. For each reaction in reactions, do
  reactions.forEach(reaction => {
    // a. Let job be NewPromiseReactionJob(reaction, argument).
    const job = NewPromiseReactionJob(reaction, argument);
    // b. Perform HostEnqueuePromiseJob(job.[[Job]], job.[[Realm]]).
    HostEnqueuePromiseJob(job.Job);
  });
  // 2. Return undefined.
  return Value.undefined;
}
TriggerPromiseReactions.section = 'https://tc39.es/ecma262/#sec-triggerpromisereactions';
/** https://tc39.es/ecma262/#sec-promise-resolve */
function* PromiseResolve(C, x) {
  Assert(C instanceof ObjectValue, "C instanceof ObjectValue");
  if (IsPromise(x) === Value.true) {
    /* ReturnIfAbrupt */
    let _temp7 = yield* Get(x, Value('constructor'));
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const xConstructor = _temp7;
    if (SameValue(xConstructor, C) === Value.true) {
      return x;
    }
  }
  /* ReturnIfAbrupt */
  let _temp8 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const promiseCapability = _temp8;
  /* ReturnIfAbrupt */
  let _temp9 = yield* Call(promiseCapability.Resolve, Value.undefined, [x]);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  return promiseCapability.Promise;
}
PromiseResolve.section = 'https://tc39.es/ecma262/#sec-promise-resolve';
/** https://tc39.es/ecma262/#sec-newpromisereactionjob */
function NewPromiseReactionJob(reaction, argument) {
  // 1. Let job be a new Job abstract closure with no parameters that captures
  //    reaction and argument and performs the following steps when called:
  function* job() {
    // a. Assert: reaction is a PromiseReaction Record.
    Assert(reaction instanceof PromiseReactionRecord, "reaction instanceof PromiseReactionRecord");
    // b. Let promiseCapability be reaction.[[Capability]].
    const promiseCapability = reaction.Capability;
    // c. Let type be reaction.[[Type]].
    const type = reaction.Type;
    // d. Let handler be reaction.[[Handler]].
    const handler = reaction.Handler;
    let handlerResult;
    // e. If handler is empty, then
    if (handler === undefined) {
      // i. If type is Fulfill, let handlerResult be NormalCompletion(argument).
      if (type === 'Fulfill') {
        handlerResult = NormalCompletion(argument);
      } else {
        // 1. Assert: type is Reject.
        Assert(type === 'Reject', "type === 'Reject'");
        // 2. Let handlerResult be ThrowCompletion(argument).
        handlerResult = ThrowCompletion(argument);
      }
    } else {
      // f. Else, let handlerResult be HostCallJobCallback(handler, undefined, « argument »).
      handlerResult = yield* HostCallJobCallback(handler, Value.undefined, [argument]);
    }
    // g. If promiseCapability is undefined, then
    if (promiseCapability instanceof UndefinedValue) {
      // i. Assert: handlerResult is not an abrupt completion.
      Assert(!(handlerResult instanceof AbruptCompletion), "!(handlerResult instanceof AbruptCompletion)");
      // ii. Return NormalCompletion(empty).
      return NormalCompletion(undefined);
    }
    let status;
    // h. If handlerResult is an abrupt completion, then
    if (handlerResult instanceof AbruptCompletion) {
      // i. Let status be Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).
      status = yield* Call(promiseCapability.Reject, Value.undefined, [handlerResult.Value]);
    } else {
      /* X */
      let _temp10 = handlerResult;
      /* node:coverage ignore next */
      if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
      /* node:coverage ignore next */
      if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! handlerResult returned an abrupt completion", {
        cause: _temp10
      });
      /* node:coverage ignore next */
      if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
      // ii. Let status be Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »).
      status = yield* Call(promiseCapability.Resolve, Value.undefined, [_temp10]);
    }
    // j. Return Completion(status).
    return status;
  }
  // 2. Let handlerRealm be null.
  let handlerRealm = Value.null;
  // 3. If reaction.[[Handler]] is not empty, then
  if (reaction.Handler !== undefined) {
    // a. Let getHandlerRealmResult be GetFunctionRealm(reaction.[[Handler]].[[Callback]]).
    const getHandlerRealmResult = EnsureCompletion(GetFunctionRealm(reaction.Handler.Callback));
    // b. If getHandlerRealmResult is a normal completion, then set handlerRealm to getHandlerRealmResult.[[Value]].
    if (getHandlerRealmResult instanceof NormalCompletion) {
      handlerRealm = getHandlerRealmResult.Value;
    } else {
      // c. Else, set _handlerRealm_ to the current Realm Record.
      handlerRealm = surroundingAgent.currentRealmRecord;
    }
    // d. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler
    //    is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.
  }
  // 4. Return { [[Job]]: job, [[Realm]]: handlerRealm }.
  return {
    Job: job,
    Realm: handlerRealm
  };
}
NewPromiseReactionJob.section = 'https://tc39.es/ecma262/#sec-newpromisereactionjob';
/** https://tc39.es/ecma262/#sec-performpromisethen */
function PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability) {
  // 1. Assert: IsPromise(promise) is true.
  Assert(IsPromise(promise) === Value.true, "IsPromise(promise) === Value.true");
  // 2. If resultCapability is not present, then
  if (resultCapability === undefined) {
    // a. Set resultCapability to undefined.
    resultCapability = Value.undefined;
  }
  let onFulfilledJobCallback;
  // 3. If IsCallable(onFulfilled) is false, then
  if (!IsCallable(onFulfilled)) {
    // a. Let onFulfilledJobCallback be empty.
    onFulfilledJobCallback = undefined;
  } else {
    // 4. Else,
    // a. Let onFulfilledJobCallback be HostMakeJobCallback(onFulfilled).
    onFulfilledJobCallback = HostMakeJobCallback(onFulfilled);
  }
  let onRejectedJobCallback;
  // 5. If IsCallable(onRejected) is false, then
  if (!IsCallable(onRejected)) {
    // a. Let onRejectedJobCallback be empty.
    onRejectedJobCallback = undefined;
  } else {
    // 6. Else,
    onRejectedJobCallback = HostMakeJobCallback(onRejected);
  }
  // 7. Let fulfillReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: Fulfill, [[Handler]]: onFulfilled }.
  const fulfillReaction = new PromiseReactionRecord({
    Capability: resultCapability,
    Type: 'Fulfill',
    Handler: onFulfilledJobCallback
  });
  // 8. Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: Reject, [[Handler]]: onRejected }.
  const rejectReaction = new PromiseReactionRecord({
    Capability: resultCapability,
    Type: 'Reject',
    Handler: onRejectedJobCallback
  });
  // 9. If promise.[[PromiseState]] is pending, then
  if (promise.PromiseState === 'pending') {
    surroundingAgent.debugger_tryTouchDuringPreview(promise);
    // a. Append fulfillReaction as the last element of the List that is promise.[[PromiseFulfillReactions]].
    promise.PromiseFulfillReactions.push(fulfillReaction);
    // b. Append rejectReaction as the last element of the List that is promise.[[PromiseRejectReactions]].
    promise.PromiseRejectReactions.push(rejectReaction);
  } else if (promise.PromiseState === 'fulfilled') {
    // a. Let value be promise.[[PromiseResult]].
    const value = promise.PromiseResult;
    // b. Let fulfillJob be NewPromiseReactionJob(fulfillReaction, value).
    const fulfillJob = NewPromiseReactionJob(fulfillReaction, value);
    // c. Perform HostEnqueuePromiseJob(fulfillJob.[[Job]], fulfillJob.[[Realm]]).
    HostEnqueuePromiseJob(fulfillJob.Job);
  } else {
    // a. Assert: The value of promise.[[PromiseState]] is rejected.
    Assert(promise.PromiseState === 'rejected', "promise.PromiseState === 'rejected'");
    // b. Let reason be promise.[[PromiseResult]].
    const reason = promise.PromiseResult;
    // c. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, "handle").
    if (promise.PromiseIsHandled === Value.false) {
      HostPromiseRejectionTracker(promise, 'handle');
    }
    // d. Let rejectJob be NewPromiseReactionJob(rejectReaction, reason).
    const rejectJob = NewPromiseReactionJob(rejectReaction, reason);
    // e. Perform HostEnqueuePromiseJob(rejectJob.[[Job]], rejectJob.[[Realm]]).
    HostEnqueuePromiseJob(rejectJob.Job);
  }
  // 12. Set promise.[[PromiseIsHandled]] to true.
  promise.PromiseIsHandled = Value.true;
  // 13. If resultCapability is undefined, then
  if (resultCapability instanceof UndefinedValue) {
    // a. Return undefined.
    return Value.undefined;
  } else {
    // 14. Else,
    // a. Return resultCapability.[[Promise]].
    return resultCapability.Promise;
  }
}
PerformPromiseThen.section = 'https://tc39.es/ecma262/#sec-performpromisethen';

const InternalMethods$3 = {
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-getprototypeof */
  *GetPrototypeOf() {
    const O = this;
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'getPrototypeOf');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp = yield* GetMethod(handler, Value('getPrototypeOf'));
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const trap = _temp;
    if (trap === Value.undefined) {
      return yield* target.GetPrototypeOf();
    }
    /* ReturnIfAbrupt */
    let _temp2 = yield* Call(trap, handler, [target]);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const handlerProto = _temp2;
    if (!(handlerProto instanceof ObjectValue) && !(handlerProto instanceof NullValue)) {
      return surroundingAgent.Throw('TypeError', 'ProxyGetPrototypeOfInvalid');
    }
    /* ReturnIfAbrupt */
    let _temp3 = yield* IsExtensible(target);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const extensibleTarget = _temp3;
    if (extensibleTarget === Value.true) {
      return handlerProto;
    }
    /* ReturnIfAbrupt */
    let _temp4 = yield* target.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    const targetProto = _temp4;
    if (SameValue(handlerProto, targetProto) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyGetPrototypeOfNonExtensible');
    }
    return handlerProto;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v */
  *SetPrototypeOf(V) {
    const O = this;
    Assert(V instanceof ObjectValue || V instanceof NullValue, "V instanceof ObjectValue || V instanceof NullValue");
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'setPrototypeOf');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp5 = yield* GetMethod(handler, Value('setPrototypeOf'));
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    const trap = _temp5;
    if (trap === Value.undefined) {
      return yield* target.SetPrototypeOf(V);
    }
    /* ReturnIfAbrupt */
    let _temp6 = yield* Call(trap, handler, [target, V]);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    const booleanTrapResult = ToBoolean(_temp6);
    if (booleanTrapResult === Value.false) {
      return Value.false;
    }
    /* ReturnIfAbrupt */
    let _temp7 = yield* IsExtensible(target);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const extensibleTarget = _temp7;
    if (extensibleTarget === Value.true) {
      return Value.true;
    }
    /* ReturnIfAbrupt */
    let _temp8 = yield* target.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    const targetProto = _temp8;
    if (SameValue(V, targetProto) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxySetPrototypeOfNonExtensible');
    }
    return Value.true;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-isextensible */
  *IsExtensible() {
    const O = this;
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'isExtensible');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp9 = yield* GetMethod(handler, Value('isExtensible'));
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    const trap = _temp9;
    if (trap === Value.undefined) {
      return yield* IsExtensible(target);
    }
    /* ReturnIfAbrupt */
    let _temp10 = yield* Call(trap, handler, [target]);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) return _temp10;
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    const booleanTrapResult = ToBoolean(_temp10);
    /* ReturnIfAbrupt */
    let _temp11 = yield* IsExtensible(target);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) return _temp11;
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    const targetResult = _temp11;
    if (SameValue(booleanTrapResult, targetResult) === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyIsExtensibleInconsistent', targetResult);
    }
    return booleanTrapResult;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-preventextensions */
  *PreventExtensions() {
    const O = this;
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'preventExtensions');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp12 = yield* GetMethod(handler, Value('preventExtensions'));
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) return _temp12;
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    const trap = _temp12;
    if (trap === Value.undefined) {
      return yield* target.PreventExtensions();
    }
    /* ReturnIfAbrupt */
    let _temp13 = yield* Call(trap, handler, [target]);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) return _temp13;
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    const booleanTrapResult = ToBoolean(_temp13);
    if (booleanTrapResult === Value.true) {
      /* ReturnIfAbrupt */
      let _temp14 = yield* IsExtensible(target);
      /* node:coverage ignore next */
      if (_temp14 instanceof AbruptCompletion) return _temp14;
      /* node:coverage ignore next */
      if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
      const extensibleTarget = _temp14;
      if (extensibleTarget === Value.true) {
        return surroundingAgent.Throw('TypeError', 'ProxyPreventExtensionsExtensible');
      }
    }
    return booleanTrapResult;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p */
  *GetOwnProperty(P) {
    const O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    // 2. Let handler be O.[[ProxyHandler]].
    const handler = O.ProxyHandler;
    // 3. If handler is null, throw a TypeError exception.
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'getOwnPropertyDescriptor');
    }
    // 4. Assert: Type(Handler) is Object.
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    // 5. Let target be O.[[ProxyTarget]].
    const target = O.ProxyTarget;
    // 6. Let trap be ? Getmethod(handler, "getOwnPropertyDescriptor").
    /* ReturnIfAbrupt */
    let _temp15 = yield* GetMethod(handler, Value('getOwnPropertyDescriptor'));
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) return _temp15;
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    const trap = _temp15;
    // 7. If trap is undefined, then
    if (trap === Value.undefined) {
      // a. Return ? target.[[GetOwnProperty]](P).
      return yield* target.GetOwnProperty(P);
    }
    // 8. Let trapResultObj be ? Call(trap, handler, « target, P »).
    /* ReturnIfAbrupt */
    let _temp16 = yield* Call(trap, handler, [target, P]);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) return _temp16;
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    const trapResultObj = _temp16;
    // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.
    if (!(trapResultObj instanceof ObjectValue) && !(trapResultObj instanceof UndefinedValue)) {
      return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorInvalid', P);
    }
    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).
    /* ReturnIfAbrupt */
    let _temp17 = yield* target.GetOwnProperty(P);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    const targetDesc = _temp17;
    // 11. If trapResultObj is undefined, then
    if (trapResultObj === Value.undefined) {
      // a. If targetDesc is undefined, return undefined.
      if (targetDesc instanceof UndefinedValue) {
        return Value.undefined;
      }
      // b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.
      if (targetDesc.Configurable === Value.false) {
        return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorUndefined', P);
      }
      // c. Let extensibleTarget be ? IsExtensible(target).
      /* ReturnIfAbrupt */
      let _temp18 = yield* IsExtensible(target);
      /* node:coverage ignore next */
      if (_temp18 instanceof AbruptCompletion) return _temp18;
      /* node:coverage ignore next */
      if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
      const extensibleTarget = _temp18;
      // d. If extensibleTarget is false, throw a TypeError exception.
      if (extensibleTarget === Value.false) {
        return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorNonExtensible', P);
      }
      // e. Return undefined.
      return Value.undefined;
    }
    // 12. Let extensibleTarget be ? IsExtensible(target).
    /* ReturnIfAbrupt */
    let _temp19 = yield* IsExtensible(target);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) return _temp19;
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    const extensibleTarget = _temp19;
    // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).
    /* ReturnIfAbrupt */
    let _temp20 = yield* ToPropertyDescriptor(trapResultObj);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    const resultDesc = _temp20;
    // 14. Call CompletePropertyDescriptor(resultDesc).
    CompletePropertyDescriptor(resultDesc);
    // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).
    const valid = IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc);
    // 16. If valid is false, throw a TypeError exception.
    if (valid === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorIncompatible', P);
    }
    // 17. If resultDesc.[[Configurable]] is false, then
    if (resultDesc.Configurable === Value.false) {
      // a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then
      if (targetDesc instanceof UndefinedValue || targetDesc.Configurable === Value.true) {
        // i. Throw a TypeError exception.
        return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorNonConfigurable', P);
      }
      // b. If resultDesc has a [[Writable]] field and resultDesc.[[Writable]] is false, then
      if ('Writable' in resultDesc && resultDesc.Writable === Value.false) {
        // i. If targetDesc.[[Writable]] is true, throw a TypeError exception.
        if (targetDesc.Writable === Value.true) {
          return surroundingAgent.Throw('TypeError', 'ProxyGetOwnPropertyDescriptorNonConfigurableWritable', P);
        }
      }
    }
    // 18. Return resultDesc.
    return resultDesc;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc */
  *DefineOwnProperty(P, Desc) {
    const O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    // 2. Let handler be O.[[ProxyHandler]].
    const handler = O.ProxyHandler;
    // 3. If handler is null, throw a TypeError exception.
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'defineProperty');
    }
    // 4. Assert: Type(handler) is Object.
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    // 5. Let target be O.[[ProxyTarget]].
    const target = O.ProxyTarget;
    // 6. Let trap be ? GetMethod(handler, "defineProperty").
    /* ReturnIfAbrupt */
    let _temp21 = yield* GetMethod(handler, Value('defineProperty'));
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) return _temp21;
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    const trap = _temp21;
    // 7. If trap is undefined, then
    if (trap === Value.undefined) {
      // a. Return ? target.[[DefineOwnProperty]](P, Desc).
      return yield* target.DefineOwnProperty(P, Desc);
    }
    // 8. Let descObj be FromPropertyDescriptor(Desc).
    const descObj = FromPropertyDescriptor(Desc);
    // 9. Let booleanTrapResult be ! ToBoolean(? Call(trap, handler, « target, P, descObj »)).
    /* ReturnIfAbrupt */
    let _temp22 = yield* Call(trap, handler, [target, P, descObj]);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    const booleanTrapResult = ToBoolean(_temp22);
    // 10. If booleanTrapResult is false, return false.
    if (booleanTrapResult === Value.false) {
      return Value.false;
    }
    // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).
    /* ReturnIfAbrupt */
    let _temp23 = yield* target.GetOwnProperty(P);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    const targetDesc = _temp23;
    // 12. Let extensibleTarget be ? IsExtensible(target).
    /* ReturnIfAbrupt */
    let _temp24 = yield* IsExtensible(target);
    /* node:coverage ignore next */
    if (_temp24 instanceof AbruptCompletion) return _temp24;
    /* node:coverage ignore next */
    if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
    const extensibleTarget = _temp24;
    let settingConfigFalse;
    // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then
    if (Desc.Configurable !== undefined && Desc.Configurable === Value.false) {
      // a. Let settingConfigFalse be true.
      settingConfigFalse = true;
    } else {
      // Else, let settingConfigFalse be false.
      settingConfigFalse = false;
    }
    // 15. If targetDesc is undefined, then
    if (targetDesc instanceof UndefinedValue) {
      // a. If extensibleTarget is false, throw a TypeError exception.
      if (extensibleTarget === Value.false) {
        return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyNonExtensible', P);
      }
      // b. If settingConfigFalse is true, throw a TypeError exception.
      if (settingConfigFalse === true) {
        return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyNonConfigurable', P);
      }
    } else {
      // a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.
      if (IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) === Value.false) {
        return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyIncompatible', P);
      }
      // b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.
      if (settingConfigFalse === true && targetDesc.Configurable === Value.true) {
        return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyNonConfigurable', P);
      }
      // c. If IsDataDescriptor(targetDesc) is true, targetDesc.[[Configurable]] is false, and targetDesc.[[Writable]] is true, then
      if (IsDataDescriptor(targetDesc) && targetDesc.Configurable === Value.false && targetDesc.Writable === Value.true) {
        // i. If Desc has a [[Writable]] field and Desc.[[Writable]] is false, throw a TypeError exception.
        if ('Writable' in Desc && Desc.Writable === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxyDefinePropertyNonConfigurableWritable', P);
        }
      }
    }
    return Value.true;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p */
  *HasProperty(P) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'has');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp25 = yield* GetMethod(handler, Value('has'));
    /* node:coverage ignore next */
    if (_temp25 instanceof AbruptCompletion) return _temp25;
    /* node:coverage ignore next */
    if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
    const trap = _temp25;
    if (trap === Value.undefined) {
      return yield* target.HasProperty(P);
    }
    /* ReturnIfAbrupt */
    let _temp26 = yield* Call(trap, handler, [target, P]);
    /* node:coverage ignore next */
    if (_temp26 instanceof AbruptCompletion) return _temp26;
    /* node:coverage ignore next */
    if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
    const booleanTrapResult = ToBoolean(_temp26);
    if (booleanTrapResult === Value.false) {
      /* ReturnIfAbrupt */
      let _temp27 = yield* target.GetOwnProperty(P);
      /* node:coverage ignore next */
      if (_temp27 instanceof AbruptCompletion) return _temp27;
      /* node:coverage ignore next */
      if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
      const targetDesc = _temp27;
      if (!(targetDesc instanceof UndefinedValue)) {
        if (targetDesc.Configurable === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxyHasNonConfigurable', P);
        }
        /* ReturnIfAbrupt */
        let _temp28 = yield* IsExtensible(target);
        /* node:coverage ignore next */
        if (_temp28 instanceof AbruptCompletion) return _temp28;
        /* node:coverage ignore next */
        if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
        const extensibleTarget = _temp28;
        if (extensibleTarget === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxyHasNonExtensible', P);
        }
      }
    }
    return booleanTrapResult;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver */
  *Get(P, Receiver) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'get');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp29 = yield* GetMethod(handler, Value('get'));
    /* node:coverage ignore next */
    if (_temp29 instanceof AbruptCompletion) return _temp29;
    /* node:coverage ignore next */
    if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
    const trap = _temp29;
    if (trap === Value.undefined) {
      return yield* target.Get(P, Receiver);
    }
    /* ReturnIfAbrupt */
    let _temp30 = yield* Call(trap, handler, [target, P, Receiver]);
    /* node:coverage ignore next */
    if (_temp30 instanceof AbruptCompletion) return _temp30;
    /* node:coverage ignore next */
    if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
    const trapResult = _temp30;
    /* ReturnIfAbrupt */
    let _temp31 = yield* target.GetOwnProperty(P);
    /* node:coverage ignore next */
    if (_temp31 instanceof AbruptCompletion) return _temp31;
    /* node:coverage ignore next */
    if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
    const targetDesc = _temp31;
    if (!(targetDesc instanceof UndefinedValue) && targetDesc.Configurable === Value.false) {
      if (IsDataDescriptor(targetDesc) === true && targetDesc.Writable === Value.false) {
        if (SameValue(trapResult, targetDesc.Value) === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxyGetNonConfigurableData', P);
        }
      }
      if (IsAccessorDescriptor(targetDesc) === true && targetDesc.Get === Value.undefined) {
        if (trapResult !== Value.undefined) {
          return surroundingAgent.Throw('TypeError', 'ProxyGetNonConfigurableAccessor', P);
        }
      }
    }
    return trapResult;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver */
  *Set(P, V, Receiver) {
    const O = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'set');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp32 = yield* GetMethod(handler, Value('set'));
    /* node:coverage ignore next */
    if (_temp32 instanceof AbruptCompletion) return _temp32;
    /* node:coverage ignore next */
    if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
    const trap = _temp32;
    if (trap === Value.undefined) {
      return yield* target.Set(P, V, Receiver);
    }
    /* ReturnIfAbrupt */
    let _temp33 = yield* Call(trap, handler, [target, P, V, Receiver]);
    /* node:coverage ignore next */
    if (_temp33 instanceof AbruptCompletion) return _temp33;
    /* node:coverage ignore next */
    if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
    const booleanTrapResult = ToBoolean(_temp33);
    if (booleanTrapResult === Value.false) {
      return Value.false;
    }
    /* ReturnIfAbrupt */
    let _temp34 = yield* target.GetOwnProperty(P);
    /* node:coverage ignore next */
    if (_temp34 instanceof AbruptCompletion) return _temp34;
    /* node:coverage ignore next */
    if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
    const targetDesc = _temp34;
    if (!(targetDesc instanceof UndefinedValue) && targetDesc.Configurable === Value.false) {
      if (IsDataDescriptor(targetDesc) === true && targetDesc.Writable === Value.false) {
        if (SameValue(V, targetDesc.Value) === Value.false) {
          return surroundingAgent.Throw('TypeError', 'ProxySetFrozenData', P);
        }
      }
      if (IsAccessorDescriptor(targetDesc) === true) {
        if (targetDesc.Set === Value.undefined) {
          return surroundingAgent.Throw('TypeError', 'ProxySetFrozenAccessor', P);
        }
      }
    }
    return Value.true;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-delete-p */
  *Delete(P) {
    const O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    // 2. Let handler be O.[[ProxyHandler]].
    const handler = O.ProxyHandler;
    // 3. If handler is null, throw a TypeError exception.
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'deleteProperty');
    }
    // 4. Assert: Type(handler) is Object.
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    // 5. Let target be O.[[ProxyTarget]].
    const target = O.ProxyTarget;
    // 6. Let trap be ? GetMethod(handler, "deleteProperty").
    /* ReturnIfAbrupt */
    let _temp35 = yield* GetMethod(handler, Value('deleteProperty'));
    /* node:coverage ignore next */
    if (_temp35 instanceof AbruptCompletion) return _temp35;
    /* node:coverage ignore next */
    if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
    const trap = _temp35;
    // 7. If trap is undefined, then
    if (trap === Value.undefined) {
      // a. Return ? target.[[Delete]](P).
      return yield* target.Delete(P);
    }
    // 8. Let booleanTrapResult be ! ToBoolean(? Call(trap, handler, « target, P »)).
    /* ReturnIfAbrupt */
    let _temp36 = yield* Call(trap, handler, [target, P]);
    /* node:coverage ignore next */
    if (_temp36 instanceof AbruptCompletion) return _temp36;
    /* node:coverage ignore next */
    if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
    const booleanTrapResult = ToBoolean(_temp36);
    // 9. If booleanTrapResult is false, return false.
    if (booleanTrapResult === Value.false) {
      return Value.false;
    }
    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).
    /* ReturnIfAbrupt */
    let _temp37 = yield* target.GetOwnProperty(P);
    /* node:coverage ignore next */
    if (_temp37 instanceof AbruptCompletion) return _temp37;
    /* node:coverage ignore next */
    if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
    const targetDesc = _temp37;
    // 11. If targetDesc is undefined, return true.
    if (targetDesc instanceof UndefinedValue) {
      return Value.true;
    }
    // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.
    if (targetDesc.Configurable === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyDeletePropertyNonConfigurable', P);
    }
    // 13. Let extensibleTarget be ? IsExtensible(target).
    /* ReturnIfAbrupt */
    let _temp38 = yield* IsExtensible(target);
    /* node:coverage ignore next */
    if (_temp38 instanceof AbruptCompletion) return _temp38;
    /* node:coverage ignore next */
    if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
    const extensibleTarget = _temp38;
    // 14. If extensibleTarget is false, throw a TypeError exception.
    if (extensibleTarget === Value.false) {
      return surroundingAgent.Throw('TypeError', 'ProxyDeletePropertyNonExtensible', P);
    }
    // 15. Return true.
    return Value.true;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys */
  *OwnPropertyKeys() {
    const O = this;
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'ownKeys');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp39 = yield* GetMethod(handler, Value('ownKeys'));
    /* node:coverage ignore next */
    if (_temp39 instanceof AbruptCompletion) return _temp39;
    /* node:coverage ignore next */
    if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
    const trap = _temp39;
    if (trap === Value.undefined) {
      return yield* target.OwnPropertyKeys();
    }
    /* ReturnIfAbrupt */
    let _temp40 = yield* Call(trap, handler, [target]);
    /* node:coverage ignore next */
    if (_temp40 instanceof AbruptCompletion) return _temp40;
    /* node:coverage ignore next */
    if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
    const trapResultArray = _temp40;
    /* ReturnIfAbrupt */
    let _temp41 = yield* CreateListFromArrayLike(trapResultArray, 'property-key');
    /* node:coverage ignore next */
    if (_temp41 instanceof AbruptCompletion) return _temp41;
    /* node:coverage ignore next */
    if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
    const trapResult = _temp41;
    const noDuplicate = new PropertyKeyMap();
    trapResult.forEach(key => {
      noDuplicate.set(key, true);
    });
    if (noDuplicate.size !== trapResult.length) {
      return surroundingAgent.Throw('TypeError', 'ProxyOwnKeysDuplicateEntries');
    }
    /* ReturnIfAbrupt */
    let _temp42 = yield* IsExtensible(target);
    /* node:coverage ignore next */
    if (_temp42 instanceof AbruptCompletion) return _temp42;
    /* node:coverage ignore next */
    if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
    const extensibleTarget = _temp42;
    /* ReturnIfAbrupt */
    let _temp43 = yield* target.OwnPropertyKeys();
    /* node:coverage ignore next */
    if (_temp43 instanceof AbruptCompletion) return _temp43;
    /* node:coverage ignore next */
    if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
    const targetKeys = _temp43;
    // Assert: targetKeys is a List containing only String and Symbol values.
    // Assert: targetKeys contains no duplicate entries.
    const targetConfigurableKeys = [];
    const targetNonconfigurableKeys = [];
    for (const key of targetKeys) {
      /* ReturnIfAbrupt */
      let _temp44 = yield* target.GetOwnProperty(key);
      /* node:coverage ignore next */
      if (_temp44 instanceof AbruptCompletion) return _temp44;
      /* node:coverage ignore next */
      if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
      const desc = _temp44;
      if (!(desc instanceof UndefinedValue) && desc.Configurable === Value.false) {
        targetNonconfigurableKeys.push(key);
      } else {
        targetConfigurableKeys.push(key);
      }
    }
    if (extensibleTarget === Value.true && targetNonconfigurableKeys.length === 0) {
      return trapResult;
    }
    const uncheckedResultKeys = new PropertyKeyMap();
    trapResult.forEach(key => {
      uncheckedResultKeys.set(key, true);
    });
    for (const key of targetNonconfigurableKeys) {
      if (!uncheckedResultKeys.has(key)) {
        return surroundingAgent.Throw('TypeError', 'ProxyOwnKeysMissing', 'non-configurable key');
      }
      uncheckedResultKeys.delete(key);
    }
    if (extensibleTarget === Value.true) {
      return trapResult;
    }
    for (const key of targetConfigurableKeys) {
      if (!uncheckedResultKeys.has(key)) {
        return surroundingAgent.Throw('TypeError', 'ProxyOwnKeysMissing', 'configurable key');
      }
      uncheckedResultKeys.delete(key);
    }
    if (uncheckedResultKeys.size > 0) {
      return surroundingAgent.Throw('TypeError', 'ProxyOwnKeysNonExtensible');
    }
    return trapResult;
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist */
  *Call(thisArgument, argumentsList) {
    const O = this;
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'apply');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    /* ReturnIfAbrupt */
    let _temp45 = yield* GetMethod(handler, Value('apply'));
    /* node:coverage ignore next */
    if (_temp45 instanceof AbruptCompletion) return _temp45;
    /* node:coverage ignore next */
    if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
    const trap = _temp45;
    if (trap === Value.undefined) {
      return yield* Call(target, thisArgument, argumentsList);
    }
    /* X */
    let _temp46 = CreateArrayFromList(argumentsList);
    /* node:coverage ignore next */
    if (_temp46 && typeof _temp46 === 'object' && 'next' in _temp46) _temp46 = skipDebugger(_temp46);
    /* node:coverage ignore next */
    if (_temp46 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList(argumentsList) returned an abrupt completion", {
      cause: _temp46
    });
    /* node:coverage ignore next */
    if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
    const argArray = _temp46;
    return yield* Call(trap, handler, [target, thisArgument, argArray]);
  },
  /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget */
  *Construct(argumentsList, newTarget) {
    const O = this;
    const handler = O.ProxyHandler;
    if (handler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'construct');
    }
    Assert(handler instanceof ObjectValue, "handler instanceof ObjectValue");
    const target = O.ProxyTarget;
    Assert(IsConstructor(target), "IsConstructor(target)");
    /* ReturnIfAbrupt */
    let _temp47 = yield* GetMethod(handler, Value('construct'));
    /* node:coverage ignore next */
    if (_temp47 instanceof AbruptCompletion) return _temp47;
    /* node:coverage ignore next */
    if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
    const trap = _temp47;
    if (trap === Value.undefined) {
      return yield* Construct(target, argumentsList, newTarget);
    }
    /* X */
    let _temp48 = CreateArrayFromList(argumentsList);
    /* node:coverage ignore next */
    if (_temp48 && typeof _temp48 === 'object' && 'next' in _temp48) _temp48 = skipDebugger(_temp48);
    /* node:coverage ignore next */
    if (_temp48 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList(argumentsList) returned an abrupt completion", {
      cause: _temp48
    });
    /* node:coverage ignore next */
    if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
    const argArray = _temp48;
    /* ReturnIfAbrupt */
    let _temp49 = yield* Call(trap, handler, [target, argArray, newTarget]);
    /* node:coverage ignore next */
    if (_temp49 instanceof AbruptCompletion) return _temp49;
    /* node:coverage ignore next */
    if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
    const newObj = _temp49;
    if (!(newObj instanceof ObjectValue)) {
      return surroundingAgent.Throw('TypeError', 'NotAnObject', newObj);
    }
    return newObj;
  }
};

/** https://tc39.es/ecma262/#sec-proxycreate */
function ProxyCreate(target, handler) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'CannotCreateProxyWith', 'non-object', 'target');
  }
  // 2. If Type(handler) is not Object, throw a TypeError exception.
  if (!(handler instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'CannotCreateProxyWith', 'non-object', 'handler');
  }
  // 3. Let P be ! MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »).
  /* X */
  let _temp50 = MakeBasicObject(['ProxyHandler', 'ProxyTarget']);
  /* node:coverage ignore next */
  if (_temp50 && typeof _temp50 === 'object' && 'next' in _temp50) _temp50 = skipDebugger(_temp50);
  /* node:coverage ignore next */
  if (_temp50 instanceof AbruptCompletion) throw new Assert.Error("! MakeBasicObject(['ProxyHandler', 'ProxyTarget']) returned an abrupt completion", {
    cause: _temp50
  });
  /* node:coverage ignore next */
  if (_temp50 instanceof Completion) _temp50 = _temp50.Value;
  const P = _temp50;
  // 4. Set P's essential internal methods, except for [[Call]] and [[Construct]], to the definitions specified in 9.5.
  P.GetPrototypeOf = InternalMethods$3.GetPrototypeOf;
  P.SetPrototypeOf = InternalMethods$3.SetPrototypeOf;
  P.IsExtensible = InternalMethods$3.IsExtensible;
  P.PreventExtensions = InternalMethods$3.PreventExtensions;
  P.GetOwnProperty = InternalMethods$3.GetOwnProperty;
  P.DefineOwnProperty = InternalMethods$3.DefineOwnProperty;
  P.HasProperty = InternalMethods$3.HasProperty;
  P.Get = InternalMethods$3.Get;
  P.Set = InternalMethods$3.Set;
  P.Delete = InternalMethods$3.Delete;
  P.OwnPropertyKeys = InternalMethods$3.OwnPropertyKeys;
  // 5. If IsCallable(target) is true, then
  if (IsCallable(target)) {
    /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist. */
    P.Call = InternalMethods$3.Call;
    // b. If IsConstructor(target) is true, then
    if (IsConstructor(target)) {
      /** https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget. */
      P.Construct = InternalMethods$3.Construct;
    }
  }
  // 6. Set P.[[ProxyTarget]] to target.
  P.ProxyTarget = target;
  // 7. Set P.[[ProxyHandler]] to handler.
  P.ProxyHandler = handler;
  // 8. Return P.
  return P;
}
ProxyCreate.section = 'https://tc39.es/ecma262/#sec-proxycreate';

/** https://tc39.es/ecma262/#sec-object.prototype.hasownproperty */
function* ObjectProto_hasOwnProperty([V = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* ToPropertyKey(V);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let P be ? ToPropertyKey(V).
  const P = _temp;
  // 2. Let O be ? ToObject(this value).
  /* ReturnIfAbrupt */
  let _temp2 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const O = _temp2;
  // 3. Return ? HasOwnProperty(O, P).
  return yield* HasOwnProperty(O, P);
}
ObjectProto_hasOwnProperty.section = 'https://tc39.es/ecma262/#sec-object.prototype.hasownproperty';
/** https://tc39.es/ecma262/#sec-object.prototype.isprototypeof */
function* ObjectProto_isPrototypeOf([V = Value.undefined], {
  thisValue
}) {
  // 1. If Type(V) is not Object, return false.
  if (!(V instanceof ObjectValue)) {
    return Value.false;
  }
  // 2. Let O be ? ToObject(this value).
  /* ReturnIfAbrupt */
  let _temp3 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const O = _temp3;
  // 3. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp4 = yield* V.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // a. Set V to ? V.[[GetPrototypeOf]]().
    V = _temp4;
    // b. If V is null, return false.
    if (V === Value.null) {
      return Value.false;
    }
    // c. If SameValue(O, V) is true, return true.
    if (SameValue(O, V) === Value.true) {
      return Value.true;
    }
  }
}
ObjectProto_isPrototypeOf.section = 'https://tc39.es/ecma262/#sec-object.prototype.isprototypeof';
/** https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable */
function* ObjectProto_propertyIsEnumerable([V = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp5 = yield* ToPropertyKey(V);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 1. Let P be ? ToPropertyKey(V).
  const P = _temp5;
  // 2. Let O be ? ToObject(this value).
  /* ReturnIfAbrupt */
  let _temp6 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const O = _temp6;
  // 3. Let desc be ? O.[[GetOwnProperty]](P).
  /* ReturnIfAbrupt */
  let _temp7 = yield* O.GetOwnProperty(P);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const desc = _temp7;
  // 4. If desc is undefined, return false.
  if (desc instanceof UndefinedValue) {
    return Value.false;
  }
  // 5. Return desc.[[Enumerable]].
  return desc.Enumerable;
}
ObjectProto_propertyIsEnumerable.section = 'https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable';
/** https://tc39.es/ecma262/#sec-object.prototype.tolocalestring */
function* ObjectProto_toLocaleString(_argList, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Return ? Invoke(O, "toString").
  return yield* Invoke(O, Value('toString'));
}
ObjectProto_toLocaleString.section = 'https://tc39.es/ecma262/#sec-object.prototype.tolocalestring';
/** https://tc39.es/ecma262/#sec-object.prototype.tostring */
function* ObjectProto_toString(_argList, {
  thisValue
}) {
  // 1. If the this value is undefined, return "[object Undefined]".
  if (thisValue === Value.undefined) {
    return Value('[object Undefined]');
  }
  // 2. If the this value is null, return "[object Null]".
  if (thisValue === Value.null) {
    return Value('[object Null]');
  }
  // 3. Let O be ! ToObject(this value).
  /* X */
  let _temp8 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! ToObject(thisValue) returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const O = _temp8;
  // 4. Let isArray be ? IsArray(O).
  /* ReturnIfAbrupt */
  let _temp9 = IsArray(O);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const isArray = _temp9;
  let builtinTag;
  // 5. If isArray is true, let builtinTag be "Array".
  if (isArray === Value.true) {
    builtinTag = 'Array';
  } else if ('ParameterMap' in O) {
    // 6. Else if O has a [[ParameterMap]] internal slot, let builtinTag be "Arguments".
    builtinTag = 'Arguments';
  } else if ('Call' in O) {
    // 7. Else if O has a [[Call]] internal method, let builtinTag be "Function".
    builtinTag = 'Function';
  } else if ('ErrorData' in O) {
    // 8. Else if O has an [[ErrorData]] internal slot, let builtinTag be "Error".
    builtinTag = 'Error';
  } else if ('BooleanData' in O) {
    // 9. Else if O has a [[BooleanData]] internal slot, let builtinTag be "Boolean".
    builtinTag = 'Boolean';
  } else if ('NumberData' in O) {
    // 10. Else if O has a [[NumberData]] internal slot, let builtinTag be "Number".
    builtinTag = 'Number';
  } else if ('StringData' in O) {
    // 11. Else if O has a [[StringData]] internal slot, let builtinTag be "String".
    builtinTag = 'String';
  } else if ('DateValue' in O) {
    // 12. Else if O has a [[DateValue]] internal slot, let builtinTag be "Date".
    builtinTag = 'Date';
  } else if ('RegExpMatcher' in O) {
    // 13. Else if O has a [[RegExpMatcher]] internal slot, let builtinTag be "RegExp".
    builtinTag = 'RegExp';
  } else {
    // 14. Else, let builtinTag be "Object".
    builtinTag = 'Object';
  }
  // 15. Let tag be ? Get(O, @@toStringTag).
  /* ReturnIfAbrupt */
  let _temp10 = yield* Get(O, wellKnownSymbols.toStringTag);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const tag = _temp10;
  let tagStr;
  // 16. If Type(tag) is not String, set tag to builtinTag.
  if (!(tag instanceof JSStringValue)) {
    tagStr = builtinTag;
  } else {
    tagStr = tag.stringValue();
  }
  // 17. Return the string-concatenation of "[object ", tag, and "]".
  return Value(`[object ${tagStr}]`);
}
ObjectProto_toString.section = 'https://tc39.es/ecma262/#sec-object.prototype.tostring';
/** https://tc39.es/ecma262/#sec-object.prototype.valueof */
function ObjectProto_valueOf(_argList, {
  thisValue
}) {
  // 1. Return ? ToObject(this value).
  return ToObject(thisValue);
}
ObjectProto_valueOf.section = 'https://tc39.es/ecma262/#sec-object.prototype.valueof';
/** https://tc39.es/ecma262/#sec-object.prototype.__defineGetter__ */
function* ObjectProto__defineGetter__([P = Value.undefined, getter = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp11 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  // 1. Let O be ? ToObject(this value).
  const O = _temp11;
  // 2. If IsCallable(getter) is false, throw a TypeError exception.
  if (!IsCallable(getter)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', getter);
  }
  // 3. Let desc be PropertyDescriptor { [[Get]]: getter, [[Enumerable]]: true, [[Configurable]]: true }.
  const desc = _Descriptor({
    Get: getter,
    Enumerable: Value.true,
    Configurable: Value.true
  });
  // 4. Let key be ? ToPropertyKey(P).
  /* ReturnIfAbrupt */
  let _temp12 = yield* ToPropertyKey(P);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  const key = _temp12;
  // 5. Perform ? DefinePropertyOrThrow(O, key, desc).
  /* ReturnIfAbrupt */
  let _temp13 = yield* DefinePropertyOrThrow(O, key, desc);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  // 6. Return undefined.
  return Value.undefined;
}
ObjectProto__defineGetter__.section = 'https://tc39.es/ecma262/#sec-object.prototype.__defineGetter__';
/** https://tc39.es/ecma262/#sec-object.prototype.__defineSetter__ */
function* ObjectProto__defineSetter__([P = Value.undefined, setter = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp14 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  // 1. Let O be ? ToObject(this value).
  const O = _temp14;
  // 2. If IsCallable(setter) is false, throw a TypeError exception.
  if (!IsCallable(setter)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', setter);
  }
  // 3. Let desc be PropertyDescriptor { [[Set]]: setter, [[Enumerable]]: true, [[Configurable]]: true }.
  const desc = _Descriptor({
    Set: setter,
    Enumerable: Value.true,
    Configurable: Value.true
  });
  // 4. Let key be ? ToPropertyKey(P).
  /* ReturnIfAbrupt */
  let _temp15 = yield* ToPropertyKey(P);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const key = _temp15;
  // 5. Perform ? DefinePropertyOrThrow(O, key, desc).
  /* ReturnIfAbrupt */
  let _temp16 = yield* DefinePropertyOrThrow(O, key, desc);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  // 6. Return undefined.
  return Value.undefined;
}
ObjectProto__defineSetter__.section = 'https://tc39.es/ecma262/#sec-object.prototype.__defineSetter__';
/** https://tc39.es/ecma262/#sec-object.prototype.__lookupGetter__ */
function* ObjectProto__lookupGetter__([P = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp17 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  // 1. Let O be ? ToObject(this value).
  let O = _temp17;
  // 2. Let key be ? ToPropertyKey(P).
  /* ReturnIfAbrupt */
  let _temp18 = yield* ToPropertyKey(P);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) return _temp18;
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  const key = _temp18;
  // 3. Repeat,
  while (true) {
    // a. Let desc be ? O.[[GetOwnProperty]](key).
    /* ReturnIfAbrupt */
    let _temp19 = yield* O.GetOwnProperty(key);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) return _temp19;
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    const desc = _temp19;
    // b. If desc is not undefined, then
    if (!(desc instanceof UndefinedValue)) {
      // i. If IsAccessorDescriptor(desc) is true, return desc.[[Get]].
      if (IsAccessorDescriptor(desc)) {
        return desc.Get;
      }
      // ii. Return undefined.
      return Value.undefined;
    }
    // c. Set O to ? O.[[GetPrototypeOf]]().
    /* ReturnIfAbrupt */
    let _temp20 = yield* O.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    O = _temp20;
    // d. If O is null, return undefined.
    if (O === Value.null) {
      return Value.undefined;
    }
  }
}
ObjectProto__lookupGetter__.section = 'https://tc39.es/ecma262/#sec-object.prototype.__lookupGetter__';
/** https://tc39.es/ecma262/#sec-object.prototype.__lookupSetter__ */
function* ObjectProto__lookupSetter__([P = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp21 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  // 1. Let O be ? ToObject(this value).
  let O = _temp21;
  // 2. Let key be ? ToPropertyKey(P).
  /* ReturnIfAbrupt */
  let _temp22 = yield* ToPropertyKey(P);
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) return _temp22;
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  const key = _temp22;
  // 3. Repeat,
  while (true) {
    // a. Let desc be ? O.[[GetOwnProperty]](key).
    /* ReturnIfAbrupt */
    let _temp23 = yield* O.GetOwnProperty(key);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    const desc = _temp23;
    // b. If desc is not undefined, then
    if (!(desc instanceof UndefinedValue)) {
      // i. If IsAccessorDescriptor(desc) is true, return desc.[[Set]].
      if (IsAccessorDescriptor(desc)) {
        return desc.Set;
      }
      // ii. Return undefined.
      return Value.undefined;
    }
    // c. Set O to ? O.[[GetPrototypeOf]]().
    /* ReturnIfAbrupt */
    let _temp24 = yield* O.GetPrototypeOf();
    /* node:coverage ignore next */
    if (_temp24 instanceof AbruptCompletion) return _temp24;
    /* node:coverage ignore next */
    if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
    O = _temp24;
    // d. If O is null, return undefined.
    if (O === Value.null) {
      return Value.undefined;
    }
  }
}
ObjectProto__lookupSetter__.section = 'https://tc39.es/ecma262/#sec-object.prototype.__lookupSetter__';
/** https://tc39.es/ecma262/#sec-get-object.prototype.__proto__ */
function* ObjectProto__proto__Get(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp25 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp25 && typeof _temp25 === 'object' && 'next' in _temp25) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  // 1. Let O be ? ToObject(this value).
  const O = _temp25;
  // 2. Return ? O.[[GetPrototypeOf]]().
  return yield* O.GetPrototypeOf();
}
ObjectProto__proto__Get.section = 'https://tc39.es/ecma262/#sec-get-object.prototype.__proto__';
/** https://tc39.es/ecma262/#sec-set-object.prototype.__proto__ */
function* ObjectProto__proto__Set([proto = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp26 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp26 && typeof _temp26 === 'object' && 'next' in _temp26) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  // 1. Let O be ? RequireObjectCoercible(this value).
  const O = _temp26;
  // 2. If Type(proto) is neither Object nor Null, return undefined.
  if (!(proto instanceof ObjectValue) && !(proto instanceof NullValue)) {
    return Value.undefined;
  }
  // 3. If Type(O) is not Object, return undefined.
  if (!(O instanceof ObjectValue)) {
    return Value.undefined;
  }
  // 4. Let status be ? O.[[SetPrototypeOf]](proto).
  /* ReturnIfAbrupt */
  let _temp27 = yield* O.SetPrototypeOf(proto);
  /* node:coverage ignore next */
  if (_temp27 instanceof AbruptCompletion) return _temp27;
  /* node:coverage ignore next */
  if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
  const status = _temp27;
  // 5. If status is false, throw a TypeError exception.
  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'ObjectSetPrototype');
  }
  // 6. Return undefined.
  return Value.undefined;
}
ObjectProto__proto__Set.section = 'https://tc39.es/ecma262/#sec-set-object.prototype.__proto__';
const InternalMethods$2 = {
  /** https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-immutable-prototype-exotic-objects-setprototypeof-v */
  *SetPrototypeOf(V) {
    // 1. Return ? SetImmutablePrototype(O, V).
    return yield* SetImmutablePrototype(this, V);
  }
};

/** https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-object-prototype-object */
function makeObjectPrototype(realmRec) {
  // The Object prototype object:
  const proto = MakeBasicObject(['Prototype', 'Extensible']);

  // * has an [[Extensible]] internal slot whose value is true.
  proto.Extensible = Value.true;

  // * has a [[Prototype]] internal slot whose value is null.
  proto.Prototype = Value.null;

  // * has the internal methods defined for ordinary objects, except for the [[SetPrototypeOf]] method, which is as defined in 10.4.7.1.
  //   (Thus, it is an immutable prototype exotic object.)
  proto.SetPrototypeOf = InternalMethods$2.SetPrototypeOf;

  // * is %Object.prototype%.
  realmRec.Intrinsics['%Object.prototype%'] = proto;
}
makeObjectPrototype.section = 'https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-object-prototype-object';
function bootstrapObjectPrototype(realmRec) {
  const proto = realmRec.Intrinsics['%Object.prototype%'];
  assignProps(realmRec, proto, [['hasOwnProperty', ObjectProto_hasOwnProperty, 1], ['isPrototypeOf', ObjectProto_isPrototypeOf, 1], ['propertyIsEnumerable', ObjectProto_propertyIsEnumerable, 1], ['toLocaleString', ObjectProto_toLocaleString, 0], ['toString', ObjectProto_toString, 0], ['valueOf', ObjectProto_valueOf, 0], ['__defineGetter__', ObjectProto__defineGetter__, 2], ['__defineSetter__', ObjectProto__defineSetter__, 2], ['__lookupGetter__', ObjectProto__lookupGetter__, 1], ['__lookupSetter__', ObjectProto__lookupSetter__, 1], ['__proto__', [ObjectProto__proto__Get, ObjectProto__proto__Set]]]);
  /* X */
  let _temp28 = Get(proto, Value('toString'));
  /* node:coverage ignore next */
  if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) _temp28 = skipDebugger(_temp28);
  /* node:coverage ignore next */
  if (_temp28 instanceof AbruptCompletion) throw new Assert.Error("! Get(proto, Value('toString')) returned an abrupt completion", {
    cause: _temp28
  });
  /* node:coverage ignore next */
  if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
  realmRec.Intrinsics['%Object.prototype.toString%'] = _temp28;
  /* X */
  let _temp29 = Get(proto, Value('valueOf'));
  /* node:coverage ignore next */
  if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) _temp29 = skipDebugger(_temp29);
  /* node:coverage ignore next */
  if (_temp29 instanceof AbruptCompletion) throw new Assert.Error("! Get(proto, Value('valueOf')) returned an abrupt completion", {
    cause: _temp29
  });
  /* node:coverage ignore next */
  if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
  realmRec.Intrinsics['%Object.prototype.valueOf%'] = _temp29;
}

function* AddEntriesFromIterable(target, iterable, adder) {
  Assert(iterable !== Value.undefined && iterable !== Value.null, "iterable !== Value.undefined && iterable !== Value.null");
  /* ReturnIfAbrupt */
  let _temp = yield* GetIterator(iterable, 'sync');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const iteratorRecord = _temp;
  while (true) {
    /* ReturnIfAbrupt */
    let _temp2 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const next = _temp2;
    if (next === 'done') {
      return target;
    }
    if (!(next instanceof ObjectValue)) {
      const error = surroundingAgent.Throw('TypeError', 'NotAnObject', next);
      return yield* IteratorClose(iteratorRecord, error);
    }
    // e. Let k be Get(nextItem, "0").
    let k = yield* Get(next, Value('0'));
    // f. IfAbruptCloseIterator(k, iteratorRecord).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (k instanceof AbruptCompletion) return skipDebugger(IteratorClose(iteratorRecord, k));
    /* node:coverage ignore next */
    if (k instanceof Completion) k = k.Value;
    // g. Let v be Get(nextItem, "1").
    let v = yield* Get(next, Value('1'));
    // h. IfAbruptCloseIterator(v, iteratorRecord).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (v instanceof AbruptCompletion) return skipDebugger(IteratorClose(iteratorRecord, v));
    /* node:coverage ignore next */
    if (v instanceof Completion) v = v.Value;
    // i. Let status be Call(adder, target, « k, v »).
    let status = yield* Call(adder, target, [k, v]);
    // j. IfAbruptCloseIterator(status, iteratorRecord).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (status instanceof AbruptCompletion) return skipDebugger(IteratorClose(iteratorRecord, status));
    /* node:coverage ignore next */
    if (status instanceof Completion) status = status.Value;
  }
}
function isMapObject(value) {
  return 'MapData' in value;
}
/** https://tc39.es/ecma262/#sec-map-iterable */
function* MapConstructor([iterable = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. Let map be ? OrdinaryCreateFromConstructor(NewTarget, "%Map.prototype%", « [[MapData]] »).
  /* ReturnIfAbrupt */
  let _temp3 = yield* OrdinaryCreateFromConstructor(NewTarget, '%Map.prototype%', ['MapData']);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const map = _temp3;
  // 3. Set map.[[MapData]] to a new empty List.
  map.MapData = [];
  // 4. If iterable is either undefined or null, return map.
  if (iterable === Value.undefined || iterable === Value.null) {
    return map;
  }
  // 5. Let adder be ? Get(map, "set").
  /* ReturnIfAbrupt */
  let _temp4 = yield* Get(map, Value('set'));
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const adder = _temp4;
  if (!IsCallable(adder)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', adder);
  }
  // 6. Return ? AddEntriesFromIterable(map, iterable, adder).
  return yield* AddEntriesFromIterable(map, iterable, adder);
}
MapConstructor.section = 'https://tc39.es/ecma262/#sec-map-iterable';
/** https://tc39.es/ecma262/#sec-get-map-@@species */
function Map_speciesGetter(_args, {
  thisValue
}) {
  // 1. Return the this value.
  return thisValue;
}
Map_speciesGetter.section = 'https://tc39.es/ecma262/#sec-get-map-@@species';
function bootstrapMap(realmRec) {
  const mapConstructor = bootstrapConstructor(realmRec, MapConstructor, 'Map', 0, realmRec.Intrinsics['%Map.prototype%'], [[wellKnownSymbols.species, [Map_speciesGetter]]]);
  realmRec.Intrinsics['%Map%'] = mapConstructor;
}

/** https://tc39.es/ecma262/#sec-object-value */
function* ObjectConstructor([value = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is neither undefined nor the active function, then
  if (NewTarget !== Value.undefined && NewTarget !== surroundingAgent.activeFunctionObject) {
    // a. Return ? OrdinaryCreateFromConstructor(NewTarget, "%Object.prototype%").
    return yield* OrdinaryCreateFromConstructor(NewTarget, '%Object.prototype%');
  }
  // 2. If value is undefined or null, return OrdinaryObjectCreate(%Object.prototype%).
  if (value === Value.null || value === Value.undefined) {
    return OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  }
  // 3. Return ! ToObject(value).
  /* X */
  let _temp = ToObject(value);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ToObject(value) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  return _temp;
}
ObjectConstructor.section = 'https://tc39.es/ecma262/#sec-object-value';
/** https://tc39.es/ecma262/#sec-object.assign */
function* Object_assign([target = Value.undefined, ...sources]) {
  /* ReturnIfAbrupt */
  let _temp2 = ToObject(target);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Let to be ? ToObject(target).
  const to = _temp2;
  // 2. If only one argument was passed, return to.
  if (sources.length === 0) {
    return to;
  }
  // 3. Let sources be the List of argument values starting with the second argument.
  // 4. For each element nextSource of sources, in ascending index order, do
  for (const nextSource of sources) {
    // a. If nextSource is neither undefined nor null, then
    if (nextSource !== Value.undefined && nextSource !== Value.null) {
      /* X */
      let _temp3 = ToObject(nextSource);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToObject(nextSource) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      // i. Let from be ! ToObject(nextSource).
      const from = _temp3;
      // ii. Let keys be ? from.[[OwnPropertyKeys]]().
      /* ReturnIfAbrupt */
      let _temp4 = yield* from.OwnPropertyKeys();
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      const keys = _temp4;
      // iii. For each element nextKey of keys in List order, do
      for (const nextKey of keys) {
        /* ReturnIfAbrupt */
        let _temp5 = yield* from.GetOwnProperty(nextKey);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) return _temp5;
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        // 1. Let desc be ? from.[[GetOwnProperty]](nextKey).
        const desc = _temp5;
        // 2. If desc is not undefined and desc.[[Enumerable]] is true, then
        if (!(desc instanceof UndefinedValue) && desc.Enumerable === Value.true) {
          /* ReturnIfAbrupt */
          let _temp6 = yield* Get(from, nextKey);
          /* node:coverage ignore next */
          if (_temp6 instanceof AbruptCompletion) return _temp6;
          /* node:coverage ignore next */
          if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
          // a. Let propValue be ? Get(from, nextKey).
          const propValue = _temp6;
          // b. Perform ? Set(to, nextKey, propValue, true).
          /* ReturnIfAbrupt */
          let _temp7 = yield* Set$1(to, nextKey, propValue, Value.true);
          /* node:coverage ignore next */
          if (_temp7 instanceof AbruptCompletion) return _temp7;
          /* node:coverage ignore next */
          if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        }
      }
    }
  }
  // 5. Return to.
  return to;
}
Object_assign.section = 'https://tc39.es/ecma262/#sec-object.assign';
/** https://tc39.es/ecma262/#sec-object.create */
function* Object_create([O = Value.undefined, Properties = Value.undefined]) {
  // 1. If Type(O) is neither Object nor Null, throw a TypeError exception.
  if (!(O instanceof ObjectValue) && !(O instanceof NullValue)) {
    return surroundingAgent.Throw('TypeError', 'ObjectPrototypeType');
  }
  // 2. Let obj be OrdinaryObjectCreate(O).
  const obj = OrdinaryObjectCreate(O);
  // 3. If Properties is not undefined, then
  if (Properties !== Value.undefined) {
    // a. Return ? ObjectDefineProperties(obj, Properties).
    return yield* ObjectDefineProperties(obj, Properties);
  }
  // 4. Return obj.
  return obj;
}
Object_create.section = 'https://tc39.es/ecma262/#sec-object.create';
/** https://tc39.es/ecma262/#sec-object.defineproperties */
function* Object_defineProperties([O = Value.undefined, Properties = Value.undefined]) {
  // 1. Return ? ObjectDefineProperties(O, Properties).
  return yield* ObjectDefineProperties(O, Properties);
}
Object_defineProperties.section = 'https://tc39.es/ecma262/#sec-object.defineproperties';
/** https://tc39.es/ecma262/#sec-objectdefineproperties ObjectDefineProperties */
function* ObjectDefineProperties(O, Properties) {
  // 1. If Type(O) is not Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 2. Let props be ? ToObject(Properties).
  /* ReturnIfAbrupt */
  let _temp8 = ToObject(Properties);
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const props = _temp8;
  // 3. Let keys be ? props.[[OwnPropertyKeys]]().
  /* ReturnIfAbrupt */
  let _temp9 = yield* props.OwnPropertyKeys();
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const keys = _temp9;
  // 4. Let descriptors be a new empty List.
  const descriptors = [];
  // 5. For each element nextKey of keys in List order, do
  for (const nextKey of keys) {
    /* ReturnIfAbrupt */
    let _temp10 = yield* props.GetOwnProperty(nextKey);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) return _temp10;
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    // a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).
    const propDesc = _temp10;
    // b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then
    if (!(propDesc instanceof UndefinedValue) && propDesc.Enumerable === Value.true) {
      /* ReturnIfAbrupt */
      let _temp11 = yield* Get(props, nextKey);
      /* node:coverage ignore next */
      if (_temp11 instanceof AbruptCompletion) return _temp11;
      /* node:coverage ignore next */
      if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
      // i. Let descObj be ? Get(props, nextKey).
      const descObj = _temp11;
      // ii. Let desc be ? ToPropertyDescriptor(descObj).
      /* ReturnIfAbrupt */
      let _temp12 = yield* ToPropertyDescriptor(descObj);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      const desc = _temp12;
      // iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.
      descriptors.push([nextKey, desc]);
    }
  }
  // 6. For each pair from descriptors in list order, do
  for (const pair of descriptors) {
    // a. Let P be the first element of pair.
    const P = pair[0];
    // b. Let desc be the second element of pair.
    const desc = pair[1];
    // c. Perform ? DefinePropertyOrThrow(O, P, desc).
    /* ReturnIfAbrupt */
    let _temp13 = yield* DefinePropertyOrThrow(O, P, desc);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) return _temp13;
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  }
  // 7. Return O.
  return O;
}
ObjectDefineProperties.section = 'https://tc39.es/ecma262/#sec-objectdefineproperties';
/** https://tc39.es/ecma262/#sec-object.defineproperty */
function* Object_defineProperty([O = Value.undefined, P = Value.undefined, Attributes = Value.undefined]) {
  // 1. If Type(O) is not Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 2. Let key be ? ToPropertyKey(P).
  /* ReturnIfAbrupt */
  let _temp14 = yield* ToPropertyKey(P);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const key = _temp14;
  // 3. Let desc be ? ToPropertyDescriptor(Attributes).
  /* ReturnIfAbrupt */
  let _temp15 = yield* ToPropertyDescriptor(Attributes);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const desc = _temp15;
  // 4. Perform ? DefinePropertyOrThrow(O, key, desc).
  /* ReturnIfAbrupt */
  let _temp16 = yield* DefinePropertyOrThrow(O, key, desc);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  // 5. Return O.
  return O;
}
Object_defineProperty.section = 'https://tc39.es/ecma262/#sec-object.defineproperty';
/** https://tc39.es/ecma262/#sec-object.entries */
function* Object_entries([O = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp17 = ToObject(O);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  // 1. Let obj be ? ToObject(O).
  const obj = _temp17;
  // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, key+value).
  /* ReturnIfAbrupt */
  let _temp18 = yield* EnumerableOwnPropertyNames(obj, 'key+value');
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) return _temp18;
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  const nameList = _temp18;
  // 3. Return CreateArrayFromList(nameList).
  return CreateArrayFromList(nameList);
}
Object_entries.section = 'https://tc39.es/ecma262/#sec-object.entries';
/** https://tc39.es/ecma262/#sec-object.freeze */
function* Object_freeze([O = Value.undefined]) {
  // 1. If Type(O) is not Object, return O.
  if (!(O instanceof ObjectValue)) {
    return O;
  }
  // 2. Let status be ? SetIntegrityLevel(O, frozen).
  /* ReturnIfAbrupt */
  let _temp19 = yield* SetIntegrityLevel(O, 'frozen');
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) return _temp19;
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  const status = _temp19;
  // 3. If status is false, throw a TypeError exception.
  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'UnableToFreeze', O);
  }
  // 4. Return O.
  return O;
}
Object_freeze.section = 'https://tc39.es/ecma262/#sec-object.freeze';
/** https://tc39.es/ecma262/#sec-object.fromentries */
function* Object_fromEntries([iterable = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp20 = RequireObjectCoercible(iterable);
  /* node:coverage ignore next */
  if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  // 2. Let obj be ! OrdinaryObjectCreate(%Object.prototype%).
  /* X */
  let _temp21 = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* node:coverage ignore next */
  if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) _temp21 = skipDebugger(_temp21);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%')) returned an abrupt completion", {
    cause: _temp21
  });
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  const obj = _temp21;
  // 3. Assert: obj is an extensible ordinary object with no own properties.
  Assert(obj.Extensible === Value.true && obj.properties.size === 0, "obj.Extensible === Value.true && obj.properties.size === 0");
  // 4. Let closure be a new Abstract Closure with parameters (key, value) that captures obj and performs the following steps when called:
  function* closure([key = Value.undefined, value = Value.undefined]) {
    /* ReturnIfAbrupt */
    let _temp22 = yield* ToPropertyKey(key);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    // a. Let propertyKey be ? ToPropertyKey(key).
    const propertyKey = _temp22;
    // b. Perform ! CreateDataPropertyOrThrow(obj, propertyKey, value).
    /* X */
    let _temp23 = CreateDataPropertyOrThrow(obj, propertyKey, value);
    /* node:coverage ignore next */
    if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) _temp23 = skipDebugger(_temp23);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(obj, propertyKey, value) returned an abrupt completion", {
      cause: _temp23
    });
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    // c. Return undefined.
    return Value.undefined;
  }
  // 5. Let adder be ! CreateBuiltinFunction(closure, 2, "", « »).
  /* X */
  let _temp24 = CreateBuiltinFunction(closure, 2, Value(''), []);
  /* node:coverage ignore next */
  if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) _temp24 = skipDebugger(_temp24);
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(closure, 2, Value(''), []) returned an abrupt completion", {
    cause: _temp24
  });
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  const adder = _temp24;
  // 6. Return ? AddEntriesFromIterable(obj, iterable, adder).
  return yield* AddEntriesFromIterable(obj, iterable, adder);
}
Object_fromEntries.section = 'https://tc39.es/ecma262/#sec-object.fromentries';
/** https://tc39.es/ecma262/#sec-object.getownpropertydescriptor */
function* Object_getOwnPropertyDescriptor([O = Value.undefined, P = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp25 = ToObject(O);
  /* node:coverage ignore next */
  if (_temp25 && typeof _temp25 === 'object' && 'next' in _temp25) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  // 1. Let obj be ? ToObject(O).
  const obj = _temp25;
  // 2. Let key be ? ToPropertyKey(P).
  /* ReturnIfAbrupt */
  let _temp26 = yield* ToPropertyKey(P);
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  const key = _temp26;
  // 3. Let desc be ? obj.[[GetOwnProperty]](key).
  /* ReturnIfAbrupt */
  let _temp27 = yield* obj.GetOwnProperty(key);
  /* node:coverage ignore next */
  if (_temp27 instanceof AbruptCompletion) return _temp27;
  /* node:coverage ignore next */
  if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
  const desc = _temp27;
  // 4. Return FromPropertyDescriptor(desc).
  return FromPropertyDescriptor(desc);
}
Object_getOwnPropertyDescriptor.section = 'https://tc39.es/ecma262/#sec-object.getownpropertydescriptor';
/** https://tc39.es/ecma262/#sec-object.getownpropertydescriptors */
function* Object_getOwnPropertyDescriptors([O = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp28 = ToObject(O);
  /* node:coverage ignore next */
  if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp28 instanceof AbruptCompletion) return _temp28;
  /* node:coverage ignore next */
  if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
  // 1. Let obj be ? ToObject(O).
  const obj = _temp28;
  // 2. Let ownKeys be ? obj.[[OwnPropertyKeys]]().
  /* ReturnIfAbrupt */
  let _temp29 = yield* obj.OwnPropertyKeys();
  /* node:coverage ignore next */
  if (_temp29 instanceof AbruptCompletion) return _temp29;
  /* node:coverage ignore next */
  if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
  const ownKeys = _temp29;
  // 3. Let descriptors be ! OrdinaryObjectCreate(%Object.prototype%).
  /* X */
  let _temp30 = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* node:coverage ignore next */
  if (_temp30 && typeof _temp30 === 'object' && 'next' in _temp30) _temp30 = skipDebugger(_temp30);
  /* node:coverage ignore next */
  if (_temp30 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%')) returned an abrupt completion", {
    cause: _temp30
  });
  /* node:coverage ignore next */
  if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
  const descriptors = _temp30;
  // 4. For each element key of ownKeys in List order, do
  for (const key of ownKeys) {
    /* ReturnIfAbrupt */
    let _temp31 = yield* obj.GetOwnProperty(key);
    /* node:coverage ignore next */
    if (_temp31 instanceof AbruptCompletion) return _temp31;
    /* node:coverage ignore next */
    if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
    // a. Let desc be ? obj.[[GetOwnProperty]](key).
    const desc = _temp31;
    // b. Let descriptor be ! FromPropertyDescriptor(desc).
    /* X */
    let _temp32 = FromPropertyDescriptor(desc);
    /* node:coverage ignore next */
    if (_temp32 && typeof _temp32 === 'object' && 'next' in _temp32) _temp32 = skipDebugger(_temp32);
    /* node:coverage ignore next */
    if (_temp32 instanceof AbruptCompletion) throw new Assert.Error("! FromPropertyDescriptor(desc) returned an abrupt completion", {
      cause: _temp32
    });
    /* node:coverage ignore next */
    if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
    const descriptor = _temp32;
    // c. If descriptor is not undefined, perform ! CreateDataPropertyOrThrow(descriptors, key, descriptor).
    if (descriptor !== Value.undefined) {
      /* X */
      let _temp33 = CreateDataProperty(descriptors, key, descriptor);
      /* node:coverage ignore next */
      if (_temp33 && typeof _temp33 === 'object' && 'next' in _temp33) _temp33 = skipDebugger(_temp33);
      /* node:coverage ignore next */
      if (_temp33 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(descriptors, key, descriptor) returned an abrupt completion", {
        cause: _temp33
      });
      /* node:coverage ignore next */
      if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
    }
  }
  // 5. Return descriptors.
  return descriptors;
}
Object_getOwnPropertyDescriptors.section = 'https://tc39.es/ecma262/#sec-object.getownpropertydescriptors';
/** https://tc39.es/ecma262/#sec-getownpropertykeys */
function* GetOwnPropertyKeys(O, type) {
  /* ReturnIfAbrupt */
  let _temp34 = ToObject(O);
  /* node:coverage ignore next */
  if (_temp34 && typeof _temp34 === 'object' && 'next' in _temp34) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp34 instanceof AbruptCompletion) return _temp34;
  /* node:coverage ignore next */
  if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
  // 1. Let obj be ? ToObject(O).
  const obj = _temp34;
  // 2. Let keys be ? obj.[[OwnPropertyKeys]]().
  /* ReturnIfAbrupt */
  let _temp35 = yield* obj.OwnPropertyKeys();
  /* node:coverage ignore next */
  if (_temp35 instanceof AbruptCompletion) return _temp35;
  /* node:coverage ignore next */
  if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
  const keys = _temp35;
  // 3. Let nameList be a new empty List.
  const nameList = [];
  // 4. For each element nextKey of keys in List order, do
  keys.forEach(nextKey => {
    // a. If nextKey is a Symbol and type is symbol, or if nextKey is a String and type is string, then
    if (type === 'Symbol' && nextKey instanceof SymbolValue || type === 'String' && nextKey instanceof JSStringValue) {
      // i. Append nextKey as the last element of nameList.
      nameList.push(nextKey);
    }
  });
  return CreateArrayFromList(nameList);
}
GetOwnPropertyKeys.section = 'https://tc39.es/ecma262/#sec-getownpropertykeys';
/** https://tc39.es/ecma262/#sec-object.getownpropertynames */
function* Object_getOwnPropertyNames([O = Value.undefined]) {
  // 1. Return ? GetOwnPropertyKeys(O, string).
  return yield* GetOwnPropertyKeys(O, 'String');
}
Object_getOwnPropertyNames.section = 'https://tc39.es/ecma262/#sec-object.getownpropertynames';
/** https://tc39.es/ecma262/#sec-object.getownpropertysymbols */
function* Object_getOwnPropertySymbols([O = Value.undefined]) {
  // 1. Return ? GetOwnPropertyKeys(O, symbol).
  return yield* GetOwnPropertyKeys(O, 'Symbol');
}
Object_getOwnPropertySymbols.section = 'https://tc39.es/ecma262/#sec-object.getownpropertysymbols';
/** https://tc39.es/ecma262/#sec-object.getprototypeof */
function* Object_getPrototypeOf([O = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp36 = ToObject(O);
  /* node:coverage ignore next */
  if (_temp36 && typeof _temp36 === 'object' && 'next' in _temp36) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp36 instanceof AbruptCompletion) return _temp36;
  /* node:coverage ignore next */
  if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
  // 1. Let obj be ? ToObject(O).
  const obj = _temp36;
  // 2. Return ? obj.[[GetPrototypeOf]]().
  return yield* obj.GetPrototypeOf();
}
Object_getPrototypeOf.section = 'https://tc39.es/ecma262/#sec-object.getprototypeof';
/** https://tc39.es/ecma262/#sec-object.hasown */
function* Object_hasOwn([O = Value.undefined, P = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp37 = ToObject(O);
  /* node:coverage ignore next */
  if (_temp37 && typeof _temp37 === 'object' && 'next' in _temp37) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp37 instanceof AbruptCompletion) return _temp37;
  /* node:coverage ignore next */
  if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
  // 1. Let obj be ? ToObject(O).
  const obj = _temp37;
  // 2. Let O be ? ToObject(this value).
  /* ReturnIfAbrupt */
  let _temp38 = yield* ToPropertyKey(P);
  /* node:coverage ignore next */
  if (_temp38 instanceof AbruptCompletion) return _temp38;
  /* node:coverage ignore next */
  if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
  const key = _temp38;
  // 3. Return ? HasOwnProperty(obj, key).
  return yield* HasOwnProperty(obj, key);
}
Object_hasOwn.section = 'https://tc39.es/ecma262/#sec-object.hasown';
/** https://tc39.es/ecma262/#sec-object.is */
function Object_is([value1 = Value.undefined, value2 = Value.undefined]) {
  // 1. Return SameValue(value1, value2).
  return SameValue(value1, value2);
}
Object_is.section = 'https://tc39.es/ecma262/#sec-object.is';
/** https://tc39.es/ecma262/#sec-object.isextensible */
function* Object_isExtensible([O = Value.undefined]) {
  // 1. If Type(O) is not Object, return false.
  if (!(O instanceof ObjectValue)) {
    return Value.false;
  }
  // 2. Return ? IsExtensible(O).
  return yield* IsExtensible(O);
}
Object_isExtensible.section = 'https://tc39.es/ecma262/#sec-object.isextensible';
/** https://tc39.es/ecma262/#sec-object.isfrozen */
function* Object_isFrozen([O = Value.undefined]) {
  // 1. If Type(O) is not Object, return true.
  if (!(O instanceof ObjectValue)) {
    return Value.true;
  }
  // 2. Return ? TestIntegrityLevel(O, frozen).
  return yield* TestIntegrityLevel(O, 'frozen');
}
Object_isFrozen.section = 'https://tc39.es/ecma262/#sec-object.isfrozen';
/** https://tc39.es/ecma262/#sec-object.issealed */
function* Object_isSealed([O = Value.undefined]) {
  // 1. If Type(O) is not Object, return true.
  if (!(O instanceof ObjectValue)) {
    return Value.true;
  }
  // 2. Return ? TestIntegrityLevel(O, sealed).
  return yield* TestIntegrityLevel(O, 'sealed');
}
Object_isSealed.section = 'https://tc39.es/ecma262/#sec-object.issealed';
/** https://tc39.es/ecma262/#sec-object.keys */
function* Object_keys([O = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp39 = ToObject(O);
  /* node:coverage ignore next */
  if (_temp39 && typeof _temp39 === 'object' && 'next' in _temp39) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp39 instanceof AbruptCompletion) return _temp39;
  /* node:coverage ignore next */
  if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
  // 1. Let obj be ? ToObject(O).
  const obj = _temp39;
  // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, key).
  /* ReturnIfAbrupt */
  let _temp40 = yield* EnumerableOwnPropertyNames(obj, 'key');
  /* node:coverage ignore next */
  if (_temp40 instanceof AbruptCompletion) return _temp40;
  /* node:coverage ignore next */
  if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
  const nameList = _temp40;
  // 3. Return CreateArrayFromList(nameList).
  return CreateArrayFromList(nameList);
}
Object_keys.section = 'https://tc39.es/ecma262/#sec-object.keys';
/** https://tc39.es/ecma262/#sec-object.preventextensions */
function* Object_preventExtensions([O = Value.undefined]) {
  // 1. If Type(O) is not Object, return O.
  if (!(O instanceof ObjectValue)) {
    return O;
  }
  // 2. Let status be ? O.[[PreventExtensions]]().
  /* ReturnIfAbrupt */
  let _temp41 = yield* O.PreventExtensions();
  /* node:coverage ignore next */
  if (_temp41 instanceof AbruptCompletion) return _temp41;
  /* node:coverage ignore next */
  if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
  const status = _temp41;
  // 3. If status is false, throw a TypeError exception.
  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'UnableToPreventExtensions', O);
  }
  // 4. Return O.
  return O;
}
Object_preventExtensions.section = 'https://tc39.es/ecma262/#sec-object.preventextensions';
/** https://tc39.es/ecma262/#sec-object.seal */
function* Object_seal([O = Value.undefined]) {
  // 1. If Type(O) is not Object, return O.
  if (!(O instanceof ObjectValue)) {
    return O;
  }
  // 2. Let status be ? SetIntegrityLevel(O, sealed).
  /* ReturnIfAbrupt */
  let _temp42 = yield* SetIntegrityLevel(O, 'sealed');
  /* node:coverage ignore next */
  if (_temp42 instanceof AbruptCompletion) return _temp42;
  /* node:coverage ignore next */
  if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
  const status = _temp42;
  // 3. If status is false, throw a TypeError exception.
  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'UnableToSeal', O);
  }
  // 4. Return O.
  return O;
}
Object_seal.section = 'https://tc39.es/ecma262/#sec-object.seal';
/** https://tc39.es/ecma262/#sec-object.setprototypeof */
function* Object_setPrototypeOf([O = Value.undefined, proto = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp43 = RequireObjectCoercible(O);
  /* node:coverage ignore next */
  if (_temp43 && typeof _temp43 === 'object' && 'next' in _temp43) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp43 instanceof AbruptCompletion) return _temp43;
  /* node:coverage ignore next */
  if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
  // 1. Set O to ? RequireObjectCoercible(O).
  O = _temp43;
  // 2. If Type(proto) is neither Object nor Null, throw a TypeError exception.
  if (!(proto instanceof ObjectValue) && !(proto instanceof NullValue)) {
    return surroundingAgent.Throw('TypeError', 'ObjectPrototypeType');
  }
  // 3. If Type(O) is not Object, return O.
  if (!(O instanceof ObjectValue)) {
    return O;
  }
  // 4. Let status be ? O.[[SetPrototypeOf]](proto).
  /* ReturnIfAbrupt */
  let _temp44 = yield* O.SetPrototypeOf(proto);
  /* node:coverage ignore next */
  if (_temp44 instanceof AbruptCompletion) return _temp44;
  /* node:coverage ignore next */
  if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
  const status = _temp44;
  // 5. If status is false, throw a TypeError exception.
  if (status === Value.false) {
    return surroundingAgent.Throw('TypeError', 'ObjectSetPrototype');
  }
  // 6. Return O.
  return O;
}
Object_setPrototypeOf.section = 'https://tc39.es/ecma262/#sec-object.setprototypeof';
/** https://tc39.es/ecma262/#sec-object.values */
function* Object_values([O = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp45 = ToObject(O);
  /* node:coverage ignore next */
  if (_temp45 && typeof _temp45 === 'object' && 'next' in _temp45) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp45 instanceof AbruptCompletion) return _temp45;
  /* node:coverage ignore next */
  if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
  // 1. Let obj be ? ToObject(O).
  const obj = _temp45;
  // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, value).
  /* ReturnIfAbrupt */
  let _temp46 = yield* EnumerableOwnPropertyNames(obj, 'value');
  /* node:coverage ignore next */
  if (_temp46 instanceof AbruptCompletion) return _temp46;
  /* node:coverage ignore next */
  if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
  const nameList = _temp46;
  // 3. Return CreateArrayFromList(nameList).
  return CreateArrayFromList(nameList);
}
Object_values.section = 'https://tc39.es/ecma262/#sec-object.values';
function bootstrapObject(realmRec) {
  const objectConstructor = bootstrapConstructor(realmRec, ObjectConstructor, 'Object', 1, realmRec.Intrinsics['%Object.prototype%'], [['assign', Object_assign, 2], ['create', Object_create, 2], ['defineProperties', Object_defineProperties, 2], ['defineProperty', Object_defineProperty, 3], ['entries', Object_entries, 1], ['freeze', Object_freeze, 1], ['fromEntries', Object_fromEntries, 1], ['getOwnPropertyDescriptor', Object_getOwnPropertyDescriptor, 2], ['getOwnPropertyDescriptors', Object_getOwnPropertyDescriptors, 1], ['getOwnPropertyNames', Object_getOwnPropertyNames, 1], ['getOwnPropertySymbols', Object_getOwnPropertySymbols, 1], ['getPrototypeOf', Object_getPrototypeOf, 1], ['hasOwn', Object_hasOwn, 2], ['is', Object_is, 2], ['isExtensible', Object_isExtensible, 1], ['isFrozen', Object_isFrozen, 1], ['isSealed', Object_isSealed, 1], ['keys', Object_keys, 1], ['preventExtensions', Object_preventExtensions, 1], ['seal', Object_seal, 1], ['setPrototypeOf', Object_setPrototypeOf, 2], ['values', Object_values, 1]]);
  realmRec.Intrinsics['%Object%'] = objectConstructor;
}

// Algorithms and methods shared between %Array.prototype% and
// %TypedArray.prototype%.

/** https://tc39.es/ecma262/#sec-array.prototype.sort */
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort */
//
// If internalMethodsRestricted is true, then Asserts are used to ensure that
// "The only internal methods of the this object that the algorithm may call
// are [[Get]] and [[Set]]," a requirement of %TypedArray%.prototype.sort.
function* ArrayProto_sortBody(obj, len, SortCompare, internalMethodsRestricted = false) {
  const items = [];
  let k = 0;
  while (k < len) {
    /* X */
    let _temp = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const Pk = _temp;
    if (internalMethodsRestricted) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* Get(obj, Pk);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      items.push(_temp2);
    } else {
      /* ReturnIfAbrupt */
      let _temp3 = yield* HasProperty(obj, Pk);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      const kPresent = _temp3;
      if (kPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp4 = yield* Get(obj, Pk);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        const kValue = _temp4;
        items.push(kValue);
      }
    }
    k += 1;
  }
  const itemCount = items.length;

  // Mergesort.
  const lBuffer = [];
  const rBuffer = [];
  for (let step = 1; step < items.length; step *= 2) {
    for (let start = 0; start < items.length - 1; start += 2 * step) {
      const sizeLeft = step;
      const mid = start + sizeLeft;
      const sizeRight = Math.min(step, items.length - mid);
      if (sizeRight < 0) {
        continue;
      }

      // Merge.
      for (let l = 0; l < sizeLeft; l += 1) {
        lBuffer[l] = items[start + l];
      }
      for (let r = 0; r < sizeRight; r += 1) {
        rBuffer[r] = items[mid + r];
      }
      {
        let l = 0;
        let r = 0;
        let o = start;
        while (l < sizeLeft && r < sizeRight) {
          /* ReturnIfAbrupt */
          let _temp5 = yield* SortCompare(lBuffer[l], rBuffer[r]);
          /* node:coverage ignore next */
          if (_temp5 instanceof AbruptCompletion) return _temp5;
          /* node:coverage ignore next */
          if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
          const cmp = R(_temp5);
          if (cmp <= 0) {
            items[o] = lBuffer[l];
            o += 1;
            l += 1;
          } else {
            items[o] = rBuffer[r];
            o += 1;
            r += 1;
          }
        }
        while (l < sizeLeft) {
          items[o] = lBuffer[l];
          o += 1;
          l += 1;
        }
        while (r < sizeRight) {
          items[o] = rBuffer[r];
          o += 1;
          r += 1;
        }
      }
    }
  }
  let j = 0;
  while (j < itemCount) {
    /* X */
    let _temp7 = ToString(F(j));
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(j)) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    /* ReturnIfAbrupt */
    let _temp6 = yield* Set$1(obj, _temp7, items[j], Value.true);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    j += 1;
  }
  while (j < len) {
    /* X */
    let _temp9 = ToString(F(j));
    /* node:coverage ignore next */
    if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(j)) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    /* ReturnIfAbrupt */
    let _temp8 = yield* DeletePropertyOrThrow(obj, _temp9);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    j += 1;
  }
  return obj;
}
ArrayProto_sortBody.section = 'https://tc39.es/ecma262/#sec-array.prototype.sort';
/** https://tc39.es/ecma262/#sec-sortindexedproperties */
function* SortIndexedProperties(obj, len, SortCompare, holes) {
  const items = [];
  let k = 0;
  while (k < len) {
    /* X */
    let _temp10 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp10
    });
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    const Pk = _temp10;
    let kRead;
    if (holes === 'skip-holes') {
      /* ReturnIfAbrupt */
      let _temp11 = yield* HasProperty(obj, Pk);
      /* node:coverage ignore next */
      if (_temp11 instanceof AbruptCompletion) return _temp11;
      /* node:coverage ignore next */
      if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
      kRead = _temp11;
    } else {
      Assert(holes === 'read-through-holes', "holes === 'read-through-holes'");
      kRead = Value.true;
    }
    if (kRead === Value.true) {
      /* ReturnIfAbrupt */
      let _temp12 = yield* Get(obj, Pk);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      const kValue = _temp12;
      items.push(kValue);
    }
    k += 1;
  }
  let completion = NormalCompletion(Value(0));
  items.sort((a, b) => {
    if (completion instanceof ThrowCompletion) {
      return 0;
    }
    // TODO: remove skipDebugger
    completion = skipDebugger(SortCompare(a, b));
    if (completion instanceof ThrowCompletion) {
      return 0;
    }
    /* X */
    let _temp13 = completion;
    /* node:coverage ignore next */
    if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! completion returned an abrupt completion", {
      cause: _temp13
    });
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    const cmp = R(_temp13);
    return cmp;
  });
  if (completion instanceof ThrowCompletion) {
    return completion;
  }
  return items;
}
SortIndexedProperties.section = 'https://tc39.es/ecma262/#sec-sortindexedproperties';
function bootstrapArrayPrototypeShared(realmRec, proto, priorToEvaluatingAlgorithm, objectToLength) {
  /** https://tc39.es/ecma262/#sec-array.prototype.every */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.every */
  function* ArrayProto_every([callbackFn = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp14 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) return _temp14;
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    /* ReturnIfAbrupt */
    let _temp15 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) return _temp15;
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    const O = _temp15;
    /* ReturnIfAbrupt */
    let _temp16 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) return _temp16;
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    const len = _temp16;
    if (!IsCallable(callbackFn)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackFn);
    }
    let k = 0;
    while (k < len) {
      /* X */
      let _temp17 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
      /* node:coverage ignore next */
      if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp17
      });
      /* node:coverage ignore next */
      if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
      const Pk = _temp17;
      /* ReturnIfAbrupt */
      let _temp18 = yield* HasProperty(O, Pk);
      /* node:coverage ignore next */
      if (_temp18 instanceof AbruptCompletion) return _temp18;
      /* node:coverage ignore next */
      if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
      const kPresent = _temp18;
      if (kPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp19 = yield* Get(O, Pk);
        /* node:coverage ignore next */
        if (_temp19 instanceof AbruptCompletion) return _temp19;
        /* node:coverage ignore next */
        if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
        const kValue = _temp19;
        /* ReturnIfAbrupt */
        let _temp20 = yield* Call(callbackFn, thisArg, [kValue, F(k), O]);
        /* node:coverage ignore next */
        if (_temp20 instanceof AbruptCompletion) return _temp20;
        /* node:coverage ignore next */
        if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
        const testResult = ToBoolean(_temp20);
        if (testResult === Value.false) {
          return Value.false;
        }
      }
      k += 1;
    }
    return Value.true;
  }
  ArrayProto_every.section = 'https://tc39.es/ecma262/#sec-array.prototype.every';
  /** https://tc39.es/ecma262/#sec-array.prototype.find */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.find */
  function* ArrayProto_find([predicate = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp21 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) return _temp21;
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    /* ReturnIfAbrupt */
    let _temp22 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    const O = _temp22;
    /* ReturnIfAbrupt */
    let _temp23 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    const len = _temp23;
    if (!IsCallable(predicate)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    }
    let k = 0;
    while (k < len) {
      /* X */
      let _temp24 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) _temp24 = skipDebugger(_temp24);
      /* node:coverage ignore next */
      if (_temp24 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp24
      });
      /* node:coverage ignore next */
      if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
      const Pk = _temp24;
      /* ReturnIfAbrupt */
      let _temp25 = yield* Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp25 instanceof AbruptCompletion) return _temp25;
      /* node:coverage ignore next */
      if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
      const kValue = _temp25;
      /* ReturnIfAbrupt */
      let _temp26 = yield* Call(predicate, thisArg, [kValue, F(k), O]);
      /* node:coverage ignore next */
      if (_temp26 instanceof AbruptCompletion) return _temp26;
      /* node:coverage ignore next */
      if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
      const testResult = ToBoolean(_temp26);
      if (testResult === Value.true) {
        return kValue;
      }
      k += 1;
    }
    return Value.undefined;
  }
  ArrayProto_find.section = 'https://tc39.es/ecma262/#sec-array.prototype.find';
  /** https://tc39.es/ecma262/#sec-array.prototype.findindex */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex */
  function* ArrayProto_findIndex([predicate = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp27 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp27 && typeof _temp27 === 'object' && 'next' in _temp27) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp27 instanceof AbruptCompletion) return _temp27;
    /* node:coverage ignore next */
    if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
    /* ReturnIfAbrupt */
    let _temp28 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) return _temp28;
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    const O = _temp28;
    /* ReturnIfAbrupt */
    let _temp29 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp29 instanceof AbruptCompletion) return _temp29;
    /* node:coverage ignore next */
    if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
    const len = _temp29;
    if (!IsCallable(predicate)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    }
    let k = 0;
    while (k < len) {
      /* X */
      let _temp30 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp30 && typeof _temp30 === 'object' && 'next' in _temp30) _temp30 = skipDebugger(_temp30);
      /* node:coverage ignore next */
      if (_temp30 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp30
      });
      /* node:coverage ignore next */
      if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
      const Pk = _temp30;
      /* ReturnIfAbrupt */
      let _temp31 = yield* Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp31 instanceof AbruptCompletion) return _temp31;
      /* node:coverage ignore next */
      if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
      const kValue = _temp31;
      /* ReturnIfAbrupt */
      let _temp32 = yield* Call(predicate, thisArg, [kValue, F(k), O]);
      /* node:coverage ignore next */
      if (_temp32 instanceof AbruptCompletion) return _temp32;
      /* node:coverage ignore next */
      if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
      const testResult = ToBoolean(_temp32);
      if (testResult === Value.true) {
        return F(k);
      }
      k += 1;
    }
    return F(-1);
  }
  ArrayProto_findIndex.section = 'https://tc39.es/ecma262/#sec-array.prototype.findindex';
  /** https://tc39.es/ecma262/#sec-array.prototype.findlast */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.findlast */
  function* ArrayProto_findLast([predicate = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp33 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp33 && typeof _temp33 === 'object' && 'next' in _temp33) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp33 instanceof AbruptCompletion) return _temp33;
    /* node:coverage ignore next */
    if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
    // Let O be ? ToObject(this value).
    /* ReturnIfAbrupt */
    let _temp34 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp34 && typeof _temp34 === 'object' && 'next' in _temp34) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp34 instanceof AbruptCompletion) return _temp34;
    /* node:coverage ignore next */
    if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
    const O = _temp34;
    // 2. Let len be ? LengthOfArrayLike(O).
    /* ReturnIfAbrupt */
    let _temp35 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp35 && typeof _temp35 === 'object' && 'next' in _temp35) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp35 instanceof AbruptCompletion) return _temp35;
    /* node:coverage ignore next */
    if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
    const len = _temp35;
    // 3. If IsCallable(predicate) is false, throw a TypeError exception.
    if (!IsCallable(predicate)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    }
    // 4. Let k be len - 1.
    let k = len - 1;
    // 5. Repeat, while k ≥ 0,
    while (k >= 0) {
      /* X */
      let _temp36 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp36 && typeof _temp36 === 'object' && 'next' in _temp36) _temp36 = skipDebugger(_temp36);
      /* node:coverage ignore next */
      if (_temp36 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp36
      });
      /* node:coverage ignore next */
      if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
      // a. Let Pk be ! ToString(𝔽(k)).
      const Pk = _temp36;
      // b. Let kValue be ? Get(O, Pk).
      /* ReturnIfAbrupt */
      let _temp37 = yield* Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp37 instanceof AbruptCompletion) return _temp37;
      /* node:coverage ignore next */
      if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
      const kValue = _temp37;
      // c. Let testResult be ToBoolean(? Call(predicate, thisArg, « kValue, 𝔽(k), O »)).
      /* ReturnIfAbrupt */
      let _temp38 = yield* Call(predicate, thisArg, [kValue, F(k), O]);
      /* node:coverage ignore next */
      if (_temp38 instanceof AbruptCompletion) return _temp38;
      /* node:coverage ignore next */
      if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
      const testResult = ToBoolean(_temp38);
      // d. If testResult is true, return kValue.
      if (testResult === Value.true) {
        return kValue;
      }
      // e. Set k to k - 1.
      k -= 1;
    }
    // 6. Return undefined.
    return Value.undefined;
  }
  ArrayProto_findLast.section = 'https://tc39.es/ecma262/#sec-array.prototype.findlast';
  /** https://tc39.es/ecma262/#sec-array.prototype.findlastindex */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.findlastindex */
  function* ArrayProto_findLastIndex([predicate = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp39 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp39 && typeof _temp39 === 'object' && 'next' in _temp39) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp39 instanceof AbruptCompletion) return _temp39;
    /* node:coverage ignore next */
    if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
    // Let O be ? ToObject(this value).
    /* ReturnIfAbrupt */
    let _temp40 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp40 && typeof _temp40 === 'object' && 'next' in _temp40) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp40 instanceof AbruptCompletion) return _temp40;
    /* node:coverage ignore next */
    if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
    const O = _temp40;
    // 2. Let len be ? LengthOfArrayLike(O).
    /* ReturnIfAbrupt */
    let _temp41 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp41 && typeof _temp41 === 'object' && 'next' in _temp41) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp41 instanceof AbruptCompletion) return _temp41;
    /* node:coverage ignore next */
    if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
    const len = _temp41;
    // 3. If IsCallable(predicate) is false, throw a TypeError exception.
    if (!IsCallable(predicate)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    }
    // 4. Let k be len - 1.
    let k = len - 1;
    // 5. Repeat, while k ≥ 0,
    while (k >= 0) {
      /* X */
      let _temp42 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp42 && typeof _temp42 === 'object' && 'next' in _temp42) _temp42 = skipDebugger(_temp42);
      /* node:coverage ignore next */
      if (_temp42 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp42
      });
      /* node:coverage ignore next */
      if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
      // a. Let Pk be ! ToString(𝔽(k)).
      const Pk = _temp42;
      // b. Let kValue be ? Get(O, Pk).
      /* ReturnIfAbrupt */
      let _temp43 = yield* Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp43 instanceof AbruptCompletion) return _temp43;
      /* node:coverage ignore next */
      if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
      const kValue = _temp43;
      // c. Let testResult be ToBoolean(? Call(predicate, thisArg, « kValue, 𝔽(k), O »)).
      /* ReturnIfAbrupt */
      let _temp44 = yield* Call(predicate, thisArg, [kValue, F(k), O]);
      /* node:coverage ignore next */
      if (_temp44 instanceof AbruptCompletion) return _temp44;
      /* node:coverage ignore next */
      if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
      const testResult = ToBoolean(_temp44);
      // d. If testResult is true, return 𝔽(k).
      if (testResult === Value.true) {
        return F(k);
      }
      // e. Set k to k - 1.
      k -= 1;
    }
    // 6. Return Return -1𝔽.
    return F(-1);
  }
  ArrayProto_findLastIndex.section = 'https://tc39.es/ecma262/#sec-array.prototype.findlastindex';
  /** https://tc39.es/ecma262/#sec-array.prototype.foreach */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach */
  function* ArrayProto_forEach([callbackfn = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp45 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp45 && typeof _temp45 === 'object' && 'next' in _temp45) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp45 instanceof AbruptCompletion) return _temp45;
    /* node:coverage ignore next */
    if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
    /* ReturnIfAbrupt */
    let _temp46 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp46 && typeof _temp46 === 'object' && 'next' in _temp46) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp46 instanceof AbruptCompletion) return _temp46;
    /* node:coverage ignore next */
    if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
    const O = _temp46;
    /* ReturnIfAbrupt */
    let _temp47 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp47 && typeof _temp47 === 'object' && 'next' in _temp47) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp47 instanceof AbruptCompletion) return _temp47;
    /* node:coverage ignore next */
    if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
    const len = _temp47;
    if (!IsCallable(callbackfn)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
    }
    let k = 0;
    while (k < len) {
      /* X */
      let _temp48 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp48 && typeof _temp48 === 'object' && 'next' in _temp48) _temp48 = skipDebugger(_temp48);
      /* node:coverage ignore next */
      if (_temp48 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp48
      });
      /* node:coverage ignore next */
      if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
      const Pk = _temp48;
      /* ReturnIfAbrupt */
      let _temp49 = yield* HasProperty(O, Pk);
      /* node:coverage ignore next */
      if (_temp49 instanceof AbruptCompletion) return _temp49;
      /* node:coverage ignore next */
      if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
      const kPresent = _temp49;
      if (kPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp50 = yield* Get(O, Pk);
        /* node:coverage ignore next */
        if (_temp50 instanceof AbruptCompletion) return _temp50;
        /* node:coverage ignore next */
        if (_temp50 instanceof Completion) _temp50 = _temp50.Value;
        const kValue = _temp50;
        /* ReturnIfAbrupt */
        let _temp51 = yield* Call(callbackfn, thisArg, [kValue, F(k), O]);
        /* node:coverage ignore next */
        if (_temp51 instanceof AbruptCompletion) return _temp51;
        /* node:coverage ignore next */
        if (_temp51 instanceof Completion) _temp51 = _temp51.Value;
      }
      k += 1;
    }
    return Value.undefined;
  }
  ArrayProto_forEach.section = 'https://tc39.es/ecma262/#sec-array.prototype.foreach';
  /** https://tc39.es/ecma262/#sec-array.prototype.includes */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes */
  function* ArrayProto_includes([searchElement = Value.undefined, fromIndex = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp52 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp52 && typeof _temp52 === 'object' && 'next' in _temp52) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp52 instanceof AbruptCompletion) return _temp52;
    /* node:coverage ignore next */
    if (_temp52 instanceof Completion) _temp52 = _temp52.Value;
    /* ReturnIfAbrupt */
    let _temp53 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp53 && typeof _temp53 === 'object' && 'next' in _temp53) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp53 instanceof AbruptCompletion) return _temp53;
    /* node:coverage ignore next */
    if (_temp53 instanceof Completion) _temp53 = _temp53.Value;
    const O = _temp53;
    /* ReturnIfAbrupt */
    let _temp54 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp54 && typeof _temp54 === 'object' && 'next' in _temp54) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp54 instanceof AbruptCompletion) return _temp54;
    /* node:coverage ignore next */
    if (_temp54 instanceof Completion) _temp54 = _temp54.Value;
    const len = _temp54;
    if (len === 0) {
      return Value.false;
    }
    /* ReturnIfAbrupt */
    let _temp55 = yield* ToIntegerOrInfinity(fromIndex);
    /* node:coverage ignore next */
    if (_temp55 instanceof AbruptCompletion) return _temp55;
    /* node:coverage ignore next */
    if (_temp55 instanceof Completion) _temp55 = _temp55.Value;
    const n = _temp55;
    if (fromIndex === Value.undefined) {
      Assert(n === 0, "n === 0");
    }
    let k;
    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) {
        k = 0;
      }
    }
    while (k < len) {
      /* X */
      let _temp56 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp56 && typeof _temp56 === 'object' && 'next' in _temp56) _temp56 = skipDebugger(_temp56);
      /* node:coverage ignore next */
      if (_temp56 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp56
      });
      /* node:coverage ignore next */
      if (_temp56 instanceof Completion) _temp56 = _temp56.Value;
      const kStr = _temp56;
      /* ReturnIfAbrupt */
      let _temp57 = yield* Get(O, kStr);
      /* node:coverage ignore next */
      if (_temp57 instanceof AbruptCompletion) return _temp57;
      /* node:coverage ignore next */
      if (_temp57 instanceof Completion) _temp57 = _temp57.Value;
      const elementK = _temp57;
      if (SameValueZero(searchElement, elementK) === Value.true) {
        return Value.true;
      }
      k += 1;
    }
    return Value.false;
  }
  ArrayProto_includes.section = 'https://tc39.es/ecma262/#sec-array.prototype.includes';
  /** https://tc39.es/ecma262/#sec-array.prototype.indexof */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof */
  function* ArrayProto_indexOf([searchElement = Value.undefined, fromIndex = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp58 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp58 && typeof _temp58 === 'object' && 'next' in _temp58) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp58 instanceof AbruptCompletion) return _temp58;
    /* node:coverage ignore next */
    if (_temp58 instanceof Completion) _temp58 = _temp58.Value;
    /* ReturnIfAbrupt */
    let _temp59 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp59 && typeof _temp59 === 'object' && 'next' in _temp59) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp59 instanceof AbruptCompletion) return _temp59;
    /* node:coverage ignore next */
    if (_temp59 instanceof Completion) _temp59 = _temp59.Value;
    const O = _temp59;
    /* ReturnIfAbrupt */
    let _temp60 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp60 && typeof _temp60 === 'object' && 'next' in _temp60) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp60 instanceof AbruptCompletion) return _temp60;
    /* node:coverage ignore next */
    if (_temp60 instanceof Completion) _temp60 = _temp60.Value;
    const len = _temp60;
    if (len === 0) {
      return F(-1);
    }
    /* ReturnIfAbrupt */
    let _temp61 = yield* ToIntegerOrInfinity(fromIndex);
    /* node:coverage ignore next */
    if (_temp61 instanceof AbruptCompletion) return _temp61;
    /* node:coverage ignore next */
    if (_temp61 instanceof Completion) _temp61 = _temp61.Value;
    const n = _temp61;
    if (fromIndex === Value.undefined) {
      Assert(n === 0, "n === 0");
    }
    if (n >= len) {
      return F(-1);
    }
    let k;
    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) {
        k = 0;
      }
    }
    while (k < len) {
      /* X */
      let _temp62 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp62 && typeof _temp62 === 'object' && 'next' in _temp62) _temp62 = skipDebugger(_temp62);
      /* node:coverage ignore next */
      if (_temp62 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp62
      });
      /* node:coverage ignore next */
      if (_temp62 instanceof Completion) _temp62 = _temp62.Value;
      const kStr = _temp62;
      /* ReturnIfAbrupt */
      let _temp63 = yield* HasProperty(O, kStr);
      /* node:coverage ignore next */
      if (_temp63 instanceof AbruptCompletion) return _temp63;
      /* node:coverage ignore next */
      if (_temp63 instanceof Completion) _temp63 = _temp63.Value;
      const kPresent = _temp63;
      if (kPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp64 = yield* Get(O, kStr);
        /* node:coverage ignore next */
        if (_temp64 instanceof AbruptCompletion) return _temp64;
        /* node:coverage ignore next */
        if (_temp64 instanceof Completion) _temp64 = _temp64.Value;
        const elementK = _temp64;
        const same = IsStrictlyEqual(searchElement, elementK);
        if (same === Value.true) {
          return F(k);
        }
      }
      k += 1;
    }
    return F(-1);
  }
  ArrayProto_indexOf.section = 'https://tc39.es/ecma262/#sec-array.prototype.indexof';
  /** https://tc39.es/ecma262/#sec-array.prototype.join */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.join */
  function* ArrayProto_join([separator = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp65 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp65 && typeof _temp65 === 'object' && 'next' in _temp65) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp65 instanceof AbruptCompletion) return _temp65;
    /* node:coverage ignore next */
    if (_temp65 instanceof Completion) _temp65 = _temp65.Value;
    /* ReturnIfAbrupt */
    let _temp66 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp66 && typeof _temp66 === 'object' && 'next' in _temp66) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp66 instanceof AbruptCompletion) return _temp66;
    /* node:coverage ignore next */
    if (_temp66 instanceof Completion) _temp66 = _temp66.Value;
    const O = _temp66;
    /* ReturnIfAbrupt */
    let _temp67 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp67 && typeof _temp67 === 'object' && 'next' in _temp67) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp67 instanceof AbruptCompletion) return _temp67;
    /* node:coverage ignore next */
    if (_temp67 instanceof Completion) _temp67 = _temp67.Value;
    const len = _temp67;
    let sep;
    if (separator instanceof UndefinedValue) {
      sep = ',';
    } else {
      /* ReturnIfAbrupt */
      let _temp68 = yield* ToString(separator);
      /* node:coverage ignore next */
      if (_temp68 instanceof AbruptCompletion) return _temp68;
      /* node:coverage ignore next */
      if (_temp68 instanceof Completion) _temp68 = _temp68.Value;
      sep = _temp68.stringValue();
    }
    let R = '';
    let k = 0;
    while (k < len) {
      if (k > 0) {
        R = `${R}${sep}`;
      }
      /* X */
      let _temp69 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp69 && typeof _temp69 === 'object' && 'next' in _temp69) _temp69 = skipDebugger(_temp69);
      /* node:coverage ignore next */
      if (_temp69 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp69
      });
      /* node:coverage ignore next */
      if (_temp69 instanceof Completion) _temp69 = _temp69.Value;
      const kStr = _temp69;
      /* ReturnIfAbrupt */
      let _temp70 = yield* Get(O, kStr);
      /* node:coverage ignore next */
      if (_temp70 instanceof AbruptCompletion) return _temp70;
      /* node:coverage ignore next */
      if (_temp70 instanceof Completion) _temp70 = _temp70.Value;
      const element = _temp70;
      let next;
      if (element instanceof UndefinedValue || element instanceof NullValue) {
        next = '';
      } else {
        /* ReturnIfAbrupt */
        let _temp71 = yield* ToString(element);
        /* node:coverage ignore next */
        if (_temp71 instanceof AbruptCompletion) return _temp71;
        /* node:coverage ignore next */
        if (_temp71 instanceof Completion) _temp71 = _temp71.Value;
        next = _temp71.stringValue();
      }
      R = `${R}${next}`;
      k += 1;
    }
    return Value(R);
  }
  ArrayProto_join.section = 'https://tc39.es/ecma262/#sec-array.prototype.join';
  /** https://tc39.es/ecma262/#sec-array.prototype.lastindexof */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof */
  function* ArrayProto_lastIndexOf([searchElement = Value.undefined, fromIndex], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp72 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp72 && typeof _temp72 === 'object' && 'next' in _temp72) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp72 instanceof AbruptCompletion) return _temp72;
    /* node:coverage ignore next */
    if (_temp72 instanceof Completion) _temp72 = _temp72.Value;
    /* ReturnIfAbrupt */
    let _temp73 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp73 && typeof _temp73 === 'object' && 'next' in _temp73) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp73 instanceof AbruptCompletion) return _temp73;
    /* node:coverage ignore next */
    if (_temp73 instanceof Completion) _temp73 = _temp73.Value;
    const O = _temp73;
    /* ReturnIfAbrupt */
    let _temp74 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp74 && typeof _temp74 === 'object' && 'next' in _temp74) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp74 instanceof AbruptCompletion) return _temp74;
    /* node:coverage ignore next */
    if (_temp74 instanceof Completion) _temp74 = _temp74.Value;
    const len = _temp74;
    if (len === 0) {
      return F(-1);
    }
    let n;
    if (fromIndex !== undefined) {
      /* ReturnIfAbrupt */
      let _temp75 = yield* ToIntegerOrInfinity(fromIndex);
      /* node:coverage ignore next */
      if (_temp75 instanceof AbruptCompletion) return _temp75;
      /* node:coverage ignore next */
      if (_temp75 instanceof Completion) _temp75 = _temp75.Value;
      n = _temp75;
    } else {
      n = len - 1;
    }
    let k;
    if (n >= 0) {
      k = Math.min(n, len - 1);
    } else {
      k = len + n;
    }
    while (k >= 0) {
      /* X */
      let _temp76 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp76 && typeof _temp76 === 'object' && 'next' in _temp76) _temp76 = skipDebugger(_temp76);
      /* node:coverage ignore next */
      if (_temp76 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp76
      });
      /* node:coverage ignore next */
      if (_temp76 instanceof Completion) _temp76 = _temp76.Value;
      const kStr = _temp76;
      /* ReturnIfAbrupt */
      let _temp77 = yield* HasProperty(O, kStr);
      /* node:coverage ignore next */
      if (_temp77 instanceof AbruptCompletion) return _temp77;
      /* node:coverage ignore next */
      if (_temp77 instanceof Completion) _temp77 = _temp77.Value;
      const kPresent = _temp77;
      if (kPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp78 = yield* Get(O, kStr);
        /* node:coverage ignore next */
        if (_temp78 instanceof AbruptCompletion) return _temp78;
        /* node:coverage ignore next */
        if (_temp78 instanceof Completion) _temp78 = _temp78.Value;
        const elementK = _temp78;
        const same = IsStrictlyEqual(searchElement, elementK);
        if (same === Value.true) {
          return F(k);
        }
      }
      k -= 1;
    }
    return F(-1);
  }
  ArrayProto_lastIndexOf.section = 'https://tc39.es/ecma262/#sec-array.prototype.lastindexof';
  /** https://tc39.es/ecma262/#sec-array.prototype.reduce */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce */
  function* ArrayProto_reduce([callbackfn = Value.undefined, initialValue], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp79 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp79 && typeof _temp79 === 'object' && 'next' in _temp79) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp79 instanceof AbruptCompletion) return _temp79;
    /* node:coverage ignore next */
    if (_temp79 instanceof Completion) _temp79 = _temp79.Value;
    /* ReturnIfAbrupt */
    let _temp80 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp80 && typeof _temp80 === 'object' && 'next' in _temp80) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp80 instanceof AbruptCompletion) return _temp80;
    /* node:coverage ignore next */
    if (_temp80 instanceof Completion) _temp80 = _temp80.Value;
    const O = _temp80;
    /* ReturnIfAbrupt */
    let _temp81 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp81 && typeof _temp81 === 'object' && 'next' in _temp81) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp81 instanceof AbruptCompletion) return _temp81;
    /* node:coverage ignore next */
    if (_temp81 instanceof Completion) _temp81 = _temp81.Value;
    const len = _temp81;
    if (!IsCallable(callbackfn)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
    }
    if (len === 0 && initialValue === undefined) {
      return surroundingAgent.Throw('TypeError', 'ArrayEmptyReduce');
    }
    let k = 0;
    let accumulator = Value.undefined;
    if (initialValue !== undefined) {
      accumulator = initialValue;
    } else {
      let kPresent = false;
      while (kPresent === false && k < len) {
        /* X */
        let _temp82 = ToString(F(k));
        /* node:coverage ignore next */
        if (_temp82 && typeof _temp82 === 'object' && 'next' in _temp82) _temp82 = skipDebugger(_temp82);
        /* node:coverage ignore next */
        if (_temp82 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
          cause: _temp82
        });
        /* node:coverage ignore next */
        if (_temp82 instanceof Completion) _temp82 = _temp82.Value;
        const Pk = _temp82;
        /* ReturnIfAbrupt */
        let _temp83 = yield* HasProperty(O, Pk);
        /* node:coverage ignore next */
        if (_temp83 instanceof AbruptCompletion) return _temp83;
        /* node:coverage ignore next */
        if (_temp83 instanceof Completion) _temp83 = _temp83.Value;
        kPresent = _temp83 === Value.true;
        if (kPresent === true) {
          /* ReturnIfAbrupt */
          let _temp84 = yield* Get(O, Pk);
          /* node:coverage ignore next */
          if (_temp84 instanceof AbruptCompletion) return _temp84;
          /* node:coverage ignore next */
          if (_temp84 instanceof Completion) _temp84 = _temp84.Value;
          accumulator = _temp84;
        }
        k += 1;
      }
      if (kPresent === false) {
        return surroundingAgent.Throw('TypeError', 'ArrayEmptyReduce');
      }
    }
    while (k < len) {
      /* X */
      let _temp85 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp85 && typeof _temp85 === 'object' && 'next' in _temp85) _temp85 = skipDebugger(_temp85);
      /* node:coverage ignore next */
      if (_temp85 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp85
      });
      /* node:coverage ignore next */
      if (_temp85 instanceof Completion) _temp85 = _temp85.Value;
      const Pk = _temp85;
      /* ReturnIfAbrupt */
      let _temp86 = yield* HasProperty(O, Pk);
      /* node:coverage ignore next */
      if (_temp86 instanceof AbruptCompletion) return _temp86;
      /* node:coverage ignore next */
      if (_temp86 instanceof Completion) _temp86 = _temp86.Value;
      const kPresent = _temp86;
      if (kPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp87 = yield* Get(O, Pk);
        /* node:coverage ignore next */
        if (_temp87 instanceof AbruptCompletion) return _temp87;
        /* node:coverage ignore next */
        if (_temp87 instanceof Completion) _temp87 = _temp87.Value;
        const kValue = _temp87;
        /* ReturnIfAbrupt */
        let _temp88 = yield* Call(callbackfn, Value.undefined, [accumulator, kValue, F(k), O]);
        /* node:coverage ignore next */
        if (_temp88 instanceof AbruptCompletion) return _temp88;
        /* node:coverage ignore next */
        if (_temp88 instanceof Completion) _temp88 = _temp88.Value;
        accumulator = _temp88;
      }
      k += 1;
    }
    return accumulator;
  }
  ArrayProto_reduce.section = 'https://tc39.es/ecma262/#sec-array.prototype.reduce';
  /** https://tc39.es/ecma262/#sec-array.prototype.reduceright */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright */
  function* ArrayProto_reduceRight([callbackfn = Value.undefined, initialValue], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp89 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp89 && typeof _temp89 === 'object' && 'next' in _temp89) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp89 instanceof AbruptCompletion) return _temp89;
    /* node:coverage ignore next */
    if (_temp89 instanceof Completion) _temp89 = _temp89.Value;
    /* ReturnIfAbrupt */
    let _temp90 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp90 && typeof _temp90 === 'object' && 'next' in _temp90) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp90 instanceof AbruptCompletion) return _temp90;
    /* node:coverage ignore next */
    if (_temp90 instanceof Completion) _temp90 = _temp90.Value;
    const O = _temp90;
    /* ReturnIfAbrupt */
    let _temp91 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp91 && typeof _temp91 === 'object' && 'next' in _temp91) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp91 instanceof AbruptCompletion) return _temp91;
    /* node:coverage ignore next */
    if (_temp91 instanceof Completion) _temp91 = _temp91.Value;
    const len = _temp91;
    if (!IsCallable(callbackfn)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
    }
    if (len === 0 && initialValue === undefined) {
      return surroundingAgent.Throw('TypeError', 'ArrayEmptyReduce');
    }
    let k = len - 1;
    let accumulator = Value.undefined;
    if (initialValue !== undefined) {
      accumulator = initialValue;
    } else {
      let kPresent = false;
      while (kPresent === false && k >= 0) {
        /* X */
        let _temp92 = ToString(F(k));
        /* node:coverage ignore next */
        if (_temp92 && typeof _temp92 === 'object' && 'next' in _temp92) _temp92 = skipDebugger(_temp92);
        /* node:coverage ignore next */
        if (_temp92 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
          cause: _temp92
        });
        /* node:coverage ignore next */
        if (_temp92 instanceof Completion) _temp92 = _temp92.Value;
        const Pk = _temp92;
        /* ReturnIfAbrupt */
        let _temp93 = yield* HasProperty(O, Pk);
        /* node:coverage ignore next */
        if (_temp93 instanceof AbruptCompletion) return _temp93;
        /* node:coverage ignore next */
        if (_temp93 instanceof Completion) _temp93 = _temp93.Value;
        kPresent = _temp93 === Value.true;
        if (kPresent === true) {
          /* ReturnIfAbrupt */
          let _temp94 = yield* Get(O, Pk);
          /* node:coverage ignore next */
          if (_temp94 instanceof AbruptCompletion) return _temp94;
          /* node:coverage ignore next */
          if (_temp94 instanceof Completion) _temp94 = _temp94.Value;
          accumulator = _temp94;
        }
        k -= 1;
      }
      if (kPresent === false) {
        return surroundingAgent.Throw('TypeError', 'ArrayEmptyReduce');
      }
    }
    while (k >= 0) {
      /* X */
      let _temp95 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp95 && typeof _temp95 === 'object' && 'next' in _temp95) _temp95 = skipDebugger(_temp95);
      /* node:coverage ignore next */
      if (_temp95 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp95
      });
      /* node:coverage ignore next */
      if (_temp95 instanceof Completion) _temp95 = _temp95.Value;
      const Pk = _temp95;
      /* ReturnIfAbrupt */
      let _temp96 = yield* HasProperty(O, Pk);
      /* node:coverage ignore next */
      if (_temp96 instanceof AbruptCompletion) return _temp96;
      /* node:coverage ignore next */
      if (_temp96 instanceof Completion) _temp96 = _temp96.Value;
      const kPresent = _temp96;
      if (kPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp97 = yield* Get(O, Pk);
        /* node:coverage ignore next */
        if (_temp97 instanceof AbruptCompletion) return _temp97;
        /* node:coverage ignore next */
        if (_temp97 instanceof Completion) _temp97 = _temp97.Value;
        const kValue = _temp97;
        /* ReturnIfAbrupt */
        let _temp98 = yield* Call(callbackfn, Value.undefined, [accumulator, kValue, F(k), O]);
        /* node:coverage ignore next */
        if (_temp98 instanceof AbruptCompletion) return _temp98;
        /* node:coverage ignore next */
        if (_temp98 instanceof Completion) _temp98 = _temp98.Value;
        accumulator = _temp98;
      }
      k -= 1;
    }
    return accumulator;
  }
  ArrayProto_reduceRight.section = 'https://tc39.es/ecma262/#sec-array.prototype.reduceright';
  /** https://tc39.es/ecma262/#sec-array.prototype.reverse */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse */
  function* ArrayProto_reverse(_args, {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp99 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp99 && typeof _temp99 === 'object' && 'next' in _temp99) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp99 instanceof AbruptCompletion) return _temp99;
    /* node:coverage ignore next */
    if (_temp99 instanceof Completion) _temp99 = _temp99.Value;
    /* ReturnIfAbrupt */
    let _temp100 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp100 && typeof _temp100 === 'object' && 'next' in _temp100) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp100 instanceof AbruptCompletion) return _temp100;
    /* node:coverage ignore next */
    if (_temp100 instanceof Completion) _temp100 = _temp100.Value;
    const O = _temp100;
    /* ReturnIfAbrupt */
    let _temp101 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp101 && typeof _temp101 === 'object' && 'next' in _temp101) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp101 instanceof AbruptCompletion) return _temp101;
    /* node:coverage ignore next */
    if (_temp101 instanceof Completion) _temp101 = _temp101.Value;
    const len = _temp101;
    const middle = Math.floor(len / 2);
    let lower = 0;
    while (lower !== middle) {
      const upper = len - lower - 1;
      /* X */
      let _temp102 = ToString(F(upper));
      /* node:coverage ignore next */
      if (_temp102 && typeof _temp102 === 'object' && 'next' in _temp102) _temp102 = skipDebugger(_temp102);
      /* node:coverage ignore next */
      if (_temp102 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(upper)) returned an abrupt completion", {
        cause: _temp102
      });
      /* node:coverage ignore next */
      if (_temp102 instanceof Completion) _temp102 = _temp102.Value;
      const upperP = _temp102;
      /* X */
      let _temp103 = ToString(F(lower));
      /* node:coverage ignore next */
      if (_temp103 && typeof _temp103 === 'object' && 'next' in _temp103) _temp103 = skipDebugger(_temp103);
      /* node:coverage ignore next */
      if (_temp103 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(lower)) returned an abrupt completion", {
        cause: _temp103
      });
      /* node:coverage ignore next */
      if (_temp103 instanceof Completion) _temp103 = _temp103.Value;
      const lowerP = _temp103;
      /* ReturnIfAbrupt */
      let _temp104 = yield* HasProperty(O, lowerP);
      /* node:coverage ignore next */
      if (_temp104 instanceof AbruptCompletion) return _temp104;
      /* node:coverage ignore next */
      if (_temp104 instanceof Completion) _temp104 = _temp104.Value;
      const lowerExists = _temp104;
      let lowerValue;
      let upperValue;
      if (lowerExists === Value.true) {
        /* ReturnIfAbrupt */
        let _temp105 = yield* Get(O, lowerP);
        /* node:coverage ignore next */
        if (_temp105 instanceof AbruptCompletion) return _temp105;
        /* node:coverage ignore next */
        if (_temp105 instanceof Completion) _temp105 = _temp105.Value;
        lowerValue = _temp105;
      }
      /* ReturnIfAbrupt */
      let _temp106 = yield* HasProperty(O, upperP);
      /* node:coverage ignore next */
      if (_temp106 instanceof AbruptCompletion) return _temp106;
      /* node:coverage ignore next */
      if (_temp106 instanceof Completion) _temp106 = _temp106.Value;
      const upperExists = _temp106;
      if (upperExists === Value.true) {
        /* ReturnIfAbrupt */
        let _temp107 = yield* Get(O, upperP);
        /* node:coverage ignore next */
        if (_temp107 instanceof AbruptCompletion) return _temp107;
        /* node:coverage ignore next */
        if (_temp107 instanceof Completion) _temp107 = _temp107.Value;
        upperValue = _temp107;
      }
      if (lowerExists === Value.true && upperExists === Value.true) {
        /* ReturnIfAbrupt */
        let _temp108 = yield* Set$1(O, lowerP, upperValue, Value.true);
        /* node:coverage ignore next */
        if (_temp108 instanceof AbruptCompletion) return _temp108;
        /* node:coverage ignore next */
        if (_temp108 instanceof Completion) _temp108 = _temp108.Value;
        /* ReturnIfAbrupt */
        let _temp109 = yield* Set$1(O, upperP, lowerValue, Value.true);
        /* node:coverage ignore next */
        if (_temp109 instanceof AbruptCompletion) return _temp109;
        /* node:coverage ignore next */
        if (_temp109 instanceof Completion) _temp109 = _temp109.Value;
      } else if (lowerExists === Value.false && upperExists === Value.true) {
        /* ReturnIfAbrupt */
        let _temp110 = yield* Set$1(O, lowerP, upperValue, Value.true);
        /* node:coverage ignore next */
        if (_temp110 instanceof AbruptCompletion) return _temp110;
        /* node:coverage ignore next */
        if (_temp110 instanceof Completion) _temp110 = _temp110.Value;
        /* ReturnIfAbrupt */
        let _temp111 = yield* DeletePropertyOrThrow(O, upperP);
        /* node:coverage ignore next */
        if (_temp111 instanceof AbruptCompletion) return _temp111;
        /* node:coverage ignore next */
        if (_temp111 instanceof Completion) _temp111 = _temp111.Value;
      } else if (lowerExists === Value.true && upperExists === Value.false) {
        /* ReturnIfAbrupt */
        let _temp112 = yield* DeletePropertyOrThrow(O, lowerP);
        /* node:coverage ignore next */
        if (_temp112 instanceof AbruptCompletion) return _temp112;
        /* node:coverage ignore next */
        if (_temp112 instanceof Completion) _temp112 = _temp112.Value;
        /* ReturnIfAbrupt */
        let _temp113 = yield* Set$1(O, upperP, lowerValue, Value.true);
        /* node:coverage ignore next */
        if (_temp113 instanceof AbruptCompletion) return _temp113;
        /* node:coverage ignore next */
        if (_temp113 instanceof Completion) _temp113 = _temp113.Value;
      } else ;
      lower += 1;
    }
    return O;
  }
  ArrayProto_reverse.section = 'https://tc39.es/ecma262/#sec-array.prototype.reverse';
  /** https://tc39.es/ecma262/#sec-array.prototype.some */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.some */
  function* ArrayProto_some([callbackfn = Value.undefined, thisArg = Value.undefined], {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp114 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp114 && typeof _temp114 === 'object' && 'next' in _temp114) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp114 instanceof AbruptCompletion) return _temp114;
    /* node:coverage ignore next */
    if (_temp114 instanceof Completion) _temp114 = _temp114.Value;
    /* ReturnIfAbrupt */
    let _temp115 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp115 && typeof _temp115 === 'object' && 'next' in _temp115) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp115 instanceof AbruptCompletion) return _temp115;
    /* node:coverage ignore next */
    if (_temp115 instanceof Completion) _temp115 = _temp115.Value;
    const O = _temp115;
    /* ReturnIfAbrupt */
    let _temp116 = objectToLength(O);
    /* node:coverage ignore next */
    if (_temp116 && typeof _temp116 === 'object' && 'next' in _temp116) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp116 instanceof AbruptCompletion) return _temp116;
    /* node:coverage ignore next */
    if (_temp116 instanceof Completion) _temp116 = _temp116.Value;
    const len = _temp116;
    if (!IsCallable(callbackfn)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
    }
    let k = 0;
    while (k < len) {
      /* X */
      let _temp117 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp117 && typeof _temp117 === 'object' && 'next' in _temp117) _temp117 = skipDebugger(_temp117);
      /* node:coverage ignore next */
      if (_temp117 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp117
      });
      /* node:coverage ignore next */
      if (_temp117 instanceof Completion) _temp117 = _temp117.Value;
      const Pk = _temp117;
      /* ReturnIfAbrupt */
      let _temp118 = yield* HasProperty(O, Pk);
      /* node:coverage ignore next */
      if (_temp118 instanceof AbruptCompletion) return _temp118;
      /* node:coverage ignore next */
      if (_temp118 instanceof Completion) _temp118 = _temp118.Value;
      const kPresent = _temp118;
      if (kPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp119 = yield* Get(O, Pk);
        /* node:coverage ignore next */
        if (_temp119 instanceof AbruptCompletion) return _temp119;
        /* node:coverage ignore next */
        if (_temp119 instanceof Completion) _temp119 = _temp119.Value;
        const kValue = _temp119;
        /* ReturnIfAbrupt */
        let _temp120 = yield* Call(callbackfn, thisArg, [kValue, F(k), O]);
        /* node:coverage ignore next */
        if (_temp120 instanceof AbruptCompletion) return _temp120;
        /* node:coverage ignore next */
        if (_temp120 instanceof Completion) _temp120 = _temp120.Value;
        const testResult = ToBoolean(_temp120);
        if (testResult === Value.true) {
          return Value.true;
        }
      }
      k += 1;
    }
    return Value.false;
  }
  ArrayProto_some.section = 'https://tc39.es/ecma262/#sec-array.prototype.some';
  /** https://tc39.es/ecma262/#sec-array.prototype.tolocalestring */
  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring */
  function* ArrayProto_toLocaleString(_args, {
    thisValue
  }) {
    /* ReturnIfAbrupt */
    let _temp121 = priorToEvaluatingAlgorithm(thisValue);
    /* node:coverage ignore next */
    if (_temp121 && typeof _temp121 === 'object' && 'next' in _temp121) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp121 instanceof AbruptCompletion) return _temp121;
    /* node:coverage ignore next */
    if (_temp121 instanceof Completion) _temp121 = _temp121.Value;
    /* ReturnIfAbrupt */
    let _temp122 = ToObject(thisValue);
    /* node:coverage ignore next */
    if (_temp122 && typeof _temp122 === 'object' && 'next' in _temp122) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp122 instanceof AbruptCompletion) return _temp122;
    /* node:coverage ignore next */
    if (_temp122 instanceof Completion) _temp122 = _temp122.Value;
    const array = _temp122;
    /* ReturnIfAbrupt */
    let _temp123 = objectToLength(array);
    /* node:coverage ignore next */
    if (_temp123 && typeof _temp123 === 'object' && 'next' in _temp123) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp123 instanceof AbruptCompletion) return _temp123;
    /* node:coverage ignore next */
    if (_temp123 instanceof Completion) _temp123 = _temp123.Value;
    const len = _temp123;
    const separator = ', ';
    let R = '';
    let k = 0;
    while (k < len) {
      if (k > 0) {
        R = `${R}${separator}`;
      }
      /* X */
      let _temp124 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp124 && typeof _temp124 === 'object' && 'next' in _temp124) _temp124 = skipDebugger(_temp124);
      /* node:coverage ignore next */
      if (_temp124 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp124
      });
      /* node:coverage ignore next */
      if (_temp124 instanceof Completion) _temp124 = _temp124.Value;
      const kStr = _temp124;
      /* ReturnIfAbrupt */
      let _temp125 = yield* Get(array, kStr);
      /* node:coverage ignore next */
      if (_temp125 instanceof AbruptCompletion) return _temp125;
      /* node:coverage ignore next */
      if (_temp125 instanceof Completion) _temp125 = _temp125.Value;
      const nextElement = _temp125;
      if (nextElement !== Value.undefined && nextElement !== Value.null) {
        /* ReturnIfAbrupt */
        let _temp127 = yield* Invoke(nextElement, Value('toLocaleString'));
        /* node:coverage ignore next */
        if (_temp127 instanceof AbruptCompletion) return _temp127;
        /* node:coverage ignore next */
        if (_temp127 instanceof Completion) _temp127 = _temp127.Value;
        /* ReturnIfAbrupt */
        let _temp126 = yield* ToString(_temp127);
        /* node:coverage ignore next */
        if (_temp126 instanceof AbruptCompletion) return _temp126;
        /* node:coverage ignore next */
        if (_temp126 instanceof Completion) _temp126 = _temp126.Value;
        const S = _temp126.stringValue();
        R = `${R}${S}`;
      }
      k += 1;
    }
    return Value(R);
  }
  ArrayProto_toLocaleString.section = 'https://tc39.es/ecma262/#sec-array.prototype.tolocalestring';
  assignProps(realmRec, proto, [['every', ArrayProto_every, 1], ['find', ArrayProto_find, 1], ['findIndex', ArrayProto_findIndex, 1], ['findLast', ArrayProto_findLast, 1], ['findLastIndex', ArrayProto_findLastIndex, 1], ['forEach', ArrayProto_forEach, 1], ['includes', ArrayProto_includes, 1], ['indexOf', ArrayProto_indexOf, 1], ['join', ArrayProto_join, 1], ['lastIndexOf', ArrayProto_lastIndexOf, 1], ['reduce', ArrayProto_reduce, 1], ['reduceRight', ArrayProto_reduceRight, 1], ['reverse', ArrayProto_reverse, 0], ['some', ArrayProto_some, 1], ['toLocaleString', ArrayProto_toLocaleString, 0]]);
}

/** https://tc39.es/ecma262/#sec-array.prototype.concat */
function* ArrayProto_concat(args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const O = _temp;
  /* ReturnIfAbrupt */
  let _temp2 = yield* ArraySpeciesCreate(O, 0);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const A = _temp2;
  let n = 0;
  const items = [O, ...args];
  while (items.length > 0) {
    const E = items.shift();
    /* ReturnIfAbrupt */
    let _temp3 = yield* IsConcatSpreadable(E);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const spreadable = _temp3;
    if (spreadable === Value.true) {
      let k = 0;
      /* ReturnIfAbrupt */
      let _temp4 = yield* LengthOfArrayLike(E);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      const len = _temp4;
      if (n + len > 2 ** 53 - 1) {
        return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
      }
      while (k < len) {
        /* X */
        let _temp5 = ToString(F(k));
        /* node:coverage ignore next */
        if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
          cause: _temp5
        });
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        const P = _temp5;
        /* ReturnIfAbrupt */
        let _temp6 = yield* HasProperty(E, P);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        const exists = _temp6;
        if (exists === Value.true) {
          /* ReturnIfAbrupt */
          let _temp7 = yield* Get(E, P);
          /* node:coverage ignore next */
          if (_temp7 instanceof AbruptCompletion) return _temp7;
          /* node:coverage ignore next */
          if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
          const subElement = _temp7;
          /* X */
          let _temp8 = ToString(F(n));
          /* node:coverage ignore next */
          if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
          /* node:coverage ignore next */
          if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
            cause: _temp8
          });
          /* node:coverage ignore next */
          if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
          const nStr = _temp8;
          /* ReturnIfAbrupt */
          let _temp9 = yield* CreateDataPropertyOrThrow(A, nStr, subElement);
          /* node:coverage ignore next */
          if (_temp9 instanceof AbruptCompletion) return _temp9;
          /* node:coverage ignore next */
          if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
        }
        n += 1;
        k += 1;
      }
    } else {
      if (n >= 2 ** 53 - 1) {
        return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
      }
      /* X */
      let _temp10 = ToString(F(n));
      /* node:coverage ignore next */
      if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
      /* node:coverage ignore next */
      if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
        cause: _temp10
      });
      /* node:coverage ignore next */
      if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
      const nStr = _temp10;
      /* ReturnIfAbrupt */
      let _temp11 = yield* CreateDataPropertyOrThrow(A, nStr, E);
      /* node:coverage ignore next */
      if (_temp11 instanceof AbruptCompletion) return _temp11;
      /* node:coverage ignore next */
      if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
      n += 1;
    }
  }
  /* ReturnIfAbrupt */
  let _temp12 = yield* Set$1(A, Value('length'), F(n), Value.true);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  return A;
}
ArrayProto_concat.section = 'https://tc39.es/ecma262/#sec-array.prototype.concat';
/** https://tc39.es/ecma262/#sec-array.prototype.copywithin */
function* ArrayProto_copyWithin([target = Value.undefined, start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp13 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  const O = _temp13;
  /* ReturnIfAbrupt */
  let _temp14 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const len = _temp14;
  /* ReturnIfAbrupt */
  let _temp15 = yield* ToIntegerOrInfinity(target);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const relativeTarget = _temp15;
  let to;
  if (relativeTarget < 0) {
    to = Math.max(len + relativeTarget, 0);
  } else {
    to = Math.min(relativeTarget, len);
  }
  /* ReturnIfAbrupt */
  let _temp16 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  const relativeStart = _temp16;
  let from;
  if (relativeStart < 0) {
    from = Math.max(len + relativeStart, 0);
  } else {
    from = Math.min(relativeStart, len);
  }
  let relativeEnd;
  if (end === Value.undefined) {
    relativeEnd = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp17 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    relativeEnd = _temp17;
  }
  let final;
  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }
  let count = Math.min(final - from, len - to);
  let direction;
  if (from < to && to < from + count) {
    direction = -1;
    from += count - 1;
    to += count - 1;
  } else {
    direction = 1;
  }
  while (count > 0) {
    /* X */
    let _temp18 = ToString(F(from));
    /* node:coverage ignore next */
    if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(from)) returned an abrupt completion", {
      cause: _temp18
    });
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    const fromKey = _temp18;
    /* X */
    let _temp19 = ToString(F(to));
    /* node:coverage ignore next */
    if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(to)) returned an abrupt completion", {
      cause: _temp19
    });
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    const toKey = _temp19;
    /* ReturnIfAbrupt */
    let _temp20 = yield* HasProperty(O, fromKey);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    const fromPresent = _temp20;
    if (fromPresent === Value.true) {
      /* ReturnIfAbrupt */
      let _temp21 = yield* Get(O, fromKey);
      /* node:coverage ignore next */
      if (_temp21 instanceof AbruptCompletion) return _temp21;
      /* node:coverage ignore next */
      if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
      const fromVal = _temp21;
      /* ReturnIfAbrupt */
      let _temp22 = yield* Set$1(O, toKey, fromVal, Value.true);
      /* node:coverage ignore next */
      if (_temp22 instanceof AbruptCompletion) return _temp22;
      /* node:coverage ignore next */
      if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    } else {
      /* ReturnIfAbrupt */
      let _temp23 = yield* DeletePropertyOrThrow(O, toKey);
      /* node:coverage ignore next */
      if (_temp23 instanceof AbruptCompletion) return _temp23;
      /* node:coverage ignore next */
      if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    }
    from += direction;
    to += direction;
    count -= 1;
  }
  return O;
}
ArrayProto_copyWithin.section = 'https://tc39.es/ecma262/#sec-array.prototype.copywithin';
/** https://tc39.es/ecma262/#sec-array.prototype.entries */
function ArrayProto_entries(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp24 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) return _temp24;
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  const O = _temp24;
  return CreateArrayIterator(O, 'key+value');
}
ArrayProto_entries.section = 'https://tc39.es/ecma262/#sec-array.prototype.entries';
/** https://tc39.es/ecma262/#sec-array.prototype.fill */
function* ArrayProto_fill([value = Value.undefined, start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp25 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp25 && typeof _temp25 === 'object' && 'next' in _temp25) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  const O = _temp25;
  /* ReturnIfAbrupt */
  let _temp26 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  const len = _temp26;
  /* ReturnIfAbrupt */
  let _temp27 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp27 instanceof AbruptCompletion) return _temp27;
  /* node:coverage ignore next */
  if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
  const relativeStart = _temp27;
  let k;
  if (relativeStart < 0) {
    k = Math.max(len + relativeStart, 0);
  } else {
    k = Math.min(relativeStart, len);
  }
  let relativeEnd;
  if (end instanceof UndefinedValue) {
    relativeEnd = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp28 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) return _temp28;
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    relativeEnd = _temp28;
  }
  let final;
  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }
  while (k < final) {
    /* X */
    let _temp29 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) _temp29 = skipDebugger(_temp29);
    /* node:coverage ignore next */
    if (_temp29 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp29
    });
    /* node:coverage ignore next */
    if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
    const Pk = _temp29;
    /* ReturnIfAbrupt */
    let _temp30 = yield* Set$1(O, Pk, value, Value.true);
    /* node:coverage ignore next */
    if (_temp30 instanceof AbruptCompletion) return _temp30;
    /* node:coverage ignore next */
    if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
    k += 1;
  }
  return O;
}
ArrayProto_fill.section = 'https://tc39.es/ecma262/#sec-array.prototype.fill';
/** https://tc39.es/ecma262/#sec-array.prototype.filter */
function* ArrayProto_filter([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp31 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp31 && typeof _temp31 === 'object' && 'next' in _temp31) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp31 instanceof AbruptCompletion) return _temp31;
  /* node:coverage ignore next */
  if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
  const O = _temp31;
  /* ReturnIfAbrupt */
  let _temp32 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp32 instanceof AbruptCompletion) return _temp32;
  /* node:coverage ignore next */
  if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
  const len = _temp32;
  if (!IsCallable(callbackfn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }
  /* ReturnIfAbrupt */
  let _temp33 = yield* ArraySpeciesCreate(O, 0);
  /* node:coverage ignore next */
  if (_temp33 instanceof AbruptCompletion) return _temp33;
  /* node:coverage ignore next */
  if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
  const A = _temp33;
  let k = 0;
  let to = 0;
  while (k < len) {
    /* X */
    let _temp34 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp34 && typeof _temp34 === 'object' && 'next' in _temp34) _temp34 = skipDebugger(_temp34);
    /* node:coverage ignore next */
    if (_temp34 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp34
    });
    /* node:coverage ignore next */
    if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
    const Pk = _temp34;
    /* ReturnIfAbrupt */
    let _temp35 = yield* HasProperty(O, Pk);
    /* node:coverage ignore next */
    if (_temp35 instanceof AbruptCompletion) return _temp35;
    /* node:coverage ignore next */
    if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
    const kPresent = _temp35;
    if (kPresent === Value.true) {
      /* ReturnIfAbrupt */
      let _temp36 = yield* Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp36 instanceof AbruptCompletion) return _temp36;
      /* node:coverage ignore next */
      if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
      const kValue = _temp36;
      /* ReturnIfAbrupt */
      let _temp37 = yield* Call(callbackfn, thisArg, [kValue, F(k), O]);
      /* node:coverage ignore next */
      if (_temp37 instanceof AbruptCompletion) return _temp37;
      /* node:coverage ignore next */
      if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
      const selected = ToBoolean(_temp37);
      if (selected === Value.true) {
        /* X */
        let _temp39 = ToString(F(to));
        /* node:coverage ignore next */
        if (_temp39 && typeof _temp39 === 'object' && 'next' in _temp39) _temp39 = skipDebugger(_temp39);
        /* node:coverage ignore next */
        if (_temp39 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(to)) returned an abrupt completion", {
          cause: _temp39
        });
        /* node:coverage ignore next */
        if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
        /* ReturnIfAbrupt */
        let _temp38 = yield* CreateDataPropertyOrThrow(A, _temp39, kValue);
        /* node:coverage ignore next */
        if (_temp38 instanceof AbruptCompletion) return _temp38;
        /* node:coverage ignore next */
        if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
        to += 1;
      }
    }
    k += 1;
  }
  return A;
}
ArrayProto_filter.section = 'https://tc39.es/ecma262/#sec-array.prototype.filter';
/** https://tc39.es/ecma262/#sec-flattenintoarray */
function* FlattenIntoArray(target, source, sourceLen, start, depth, mapperFunction, thisArg) {
  Assert(target instanceof ObjectValue, "target instanceof ObjectValue");
  Assert(source instanceof ObjectValue, "source instanceof ObjectValue");
  Assert(sourceLen >= 0, "sourceLen >= 0");
  Assert(start >= 0, "start >= 0");
  // Assert: _depth_ is an integer Number, *+&infin;*, or *-&infin;*.
  // Assert(mapperFunction === undefined || (X(IsCallable(mapperFunction)) === Value.true && thisArg !== undefined && depth === 1));
  let targetIndex = start;
  let sourceIndex = 0;
  while (sourceIndex < sourceLen) {
    /* X */
    let _temp40 = ToString(F(sourceIndex));
    /* node:coverage ignore next */
    if (_temp40 && typeof _temp40 === 'object' && 'next' in _temp40) _temp40 = skipDebugger(_temp40);
    /* node:coverage ignore next */
    if (_temp40 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(sourceIndex)) returned an abrupt completion", {
      cause: _temp40
    });
    /* node:coverage ignore next */
    if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
    const P = _temp40;
    /* ReturnIfAbrupt */
    let _temp41 = yield* HasProperty(source, P);
    /* node:coverage ignore next */
    if (_temp41 instanceof AbruptCompletion) return _temp41;
    /* node:coverage ignore next */
    if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
    const exists = _temp41;
    if (exists === Value.true) {
      /* ReturnIfAbrupt */
      let _temp42 = yield* Get(source, P);
      /* node:coverage ignore next */
      if (_temp42 instanceof AbruptCompletion) return _temp42;
      /* node:coverage ignore next */
      if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
      let element = _temp42;
      if (mapperFunction) {
        Assert(!!thisArg, "!!thisArg");
        /* ReturnIfAbrupt */
        let _temp43 = yield* Call(mapperFunction, thisArg, [element, F(sourceIndex), source]);
        /* node:coverage ignore next */
        if (_temp43 instanceof AbruptCompletion) return _temp43;
        /* node:coverage ignore next */
        if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
        element = _temp43;
      }
      let shouldFlatten = Value.false;
      if (depth > 0) {
        /* ReturnIfAbrupt */
        let _temp44 = IsArray(element);
        /* node:coverage ignore next */
        if (_temp44 && typeof _temp44 === 'object' && 'next' in _temp44) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp44 instanceof AbruptCompletion) return _temp44;
        /* node:coverage ignore next */
        if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
        shouldFlatten = _temp44;
      }
      if (shouldFlatten === Value.true) {
        /* ReturnIfAbrupt */
        let _temp45 = yield* LengthOfArrayLike(element);
        /* node:coverage ignore next */
        if (_temp45 instanceof AbruptCompletion) return _temp45;
        /* node:coverage ignore next */
        if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
        const elementLen = _temp45;
        /* ReturnIfAbrupt */
        let _temp46 = yield* FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
        /* node:coverage ignore next */
        if (_temp46 instanceof AbruptCompletion) return _temp46;
        /* node:coverage ignore next */
        if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
        targetIndex = _temp46;
      } else {
        if (targetIndex >= 2 ** 53 - 1) {
          return surroundingAgent.Throw('TypeError', 'OutOfRange', targetIndex);
        }
        /* X */
        let _temp48 = ToString(F(targetIndex));
        /* node:coverage ignore next */
        if (_temp48 && typeof _temp48 === 'object' && 'next' in _temp48) _temp48 = skipDebugger(_temp48);
        /* node:coverage ignore next */
        if (_temp48 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(targetIndex)) returned an abrupt completion", {
          cause: _temp48
        });
        /* node:coverage ignore next */
        if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
        /* ReturnIfAbrupt */
        let _temp47 = yield* CreateDataPropertyOrThrow(target, _temp48, element);
        /* node:coverage ignore next */
        if (_temp47 instanceof AbruptCompletion) return _temp47;
        /* node:coverage ignore next */
        if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
        targetIndex += 1;
      }
    }
    sourceIndex += 1;
  }
  return targetIndex;
}
FlattenIntoArray.section = 'https://tc39.es/ecma262/#sec-flattenintoarray';
/** https://tc39.es/ecma262/#sec-array.prototype.flat */
function* ArrayProto_flat([depth = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp49 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp49 && typeof _temp49 === 'object' && 'next' in _temp49) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp49 instanceof AbruptCompletion) return _temp49;
  /* node:coverage ignore next */
  if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
  const O = _temp49;
  /* ReturnIfAbrupt */
  let _temp50 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp50 instanceof AbruptCompletion) return _temp50;
  /* node:coverage ignore next */
  if (_temp50 instanceof Completion) _temp50 = _temp50.Value;
  const sourceLen = _temp50;
  let depthNum = 1;
  if (depth !== Value.undefined) {
    /* ReturnIfAbrupt */
    let _temp51 = yield* ToIntegerOrInfinity(depth);
    /* node:coverage ignore next */
    if (_temp51 instanceof AbruptCompletion) return _temp51;
    /* node:coverage ignore next */
    if (_temp51 instanceof Completion) _temp51 = _temp51.Value;
    depthNum = _temp51;
  }
  /* ReturnIfAbrupt */
  let _temp52 = yield* ArraySpeciesCreate(O, 0);
  /* node:coverage ignore next */
  if (_temp52 instanceof AbruptCompletion) return _temp52;
  /* node:coverage ignore next */
  if (_temp52 instanceof Completion) _temp52 = _temp52.Value;
  const A = _temp52;
  /* ReturnIfAbrupt */
  let _temp53 = yield* FlattenIntoArray(A, O, sourceLen, 0, depthNum);
  /* node:coverage ignore next */
  if (_temp53 instanceof AbruptCompletion) return _temp53;
  /* node:coverage ignore next */
  if (_temp53 instanceof Completion) _temp53 = _temp53.Value;
  return A;
}
ArrayProto_flat.section = 'https://tc39.es/ecma262/#sec-array.prototype.flat';
/** https://tc39.es/ecma262/#sec-array.prototype.flatmap */
function* ArrayProto_flatMap([mapperFunction = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp54 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp54 && typeof _temp54 === 'object' && 'next' in _temp54) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp54 instanceof AbruptCompletion) return _temp54;
  /* node:coverage ignore next */
  if (_temp54 instanceof Completion) _temp54 = _temp54.Value;
  const O = _temp54;
  /* ReturnIfAbrupt */
  let _temp55 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp55 instanceof AbruptCompletion) return _temp55;
  /* node:coverage ignore next */
  if (_temp55 instanceof Completion) _temp55 = _temp55.Value;
  const sourceLen = _temp55;
  if (!IsCallable(mapperFunction)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', mapperFunction);
  }
  /* ReturnIfAbrupt */
  let _temp56 = yield* ArraySpeciesCreate(O, 0);
  /* node:coverage ignore next */
  if (_temp56 instanceof AbruptCompletion) return _temp56;
  /* node:coverage ignore next */
  if (_temp56 instanceof Completion) _temp56 = _temp56.Value;
  const A = _temp56;
  /* ReturnIfAbrupt */
  let _temp57 = yield* FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, thisArg);
  /* node:coverage ignore next */
  if (_temp57 instanceof AbruptCompletion) return _temp57;
  /* node:coverage ignore next */
  if (_temp57 instanceof Completion) _temp57 = _temp57.Value;
  return A;
}
ArrayProto_flatMap.section = 'https://tc39.es/ecma262/#sec-array.prototype.flatmap';
/** https://tc39.es/ecma262/#sec-array.prototype.keys */
function ArrayProto_keys(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp58 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp58 && typeof _temp58 === 'object' && 'next' in _temp58) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp58 instanceof AbruptCompletion) return _temp58;
  /* node:coverage ignore next */
  if (_temp58 instanceof Completion) _temp58 = _temp58.Value;
  const O = _temp58;
  return CreateArrayIterator(O, 'key');
}
ArrayProto_keys.section = 'https://tc39.es/ecma262/#sec-array.prototype.keys';
/** https://tc39.es/ecma262/#sec-array.prototype.map */
function* ArrayProto_map([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp59 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp59 && typeof _temp59 === 'object' && 'next' in _temp59) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp59 instanceof AbruptCompletion) return _temp59;
  /* node:coverage ignore next */
  if (_temp59 instanceof Completion) _temp59 = _temp59.Value;
  const O = _temp59;
  /* ReturnIfAbrupt */
  let _temp60 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp60 instanceof AbruptCompletion) return _temp60;
  /* node:coverage ignore next */
  if (_temp60 instanceof Completion) _temp60 = _temp60.Value;
  const len = _temp60;
  if (!IsCallable(callbackfn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }
  /* ReturnIfAbrupt */
  let _temp61 = yield* ArraySpeciesCreate(O, len);
  /* node:coverage ignore next */
  if (_temp61 instanceof AbruptCompletion) return _temp61;
  /* node:coverage ignore next */
  if (_temp61 instanceof Completion) _temp61 = _temp61.Value;
  const A = _temp61;
  let k = 0;
  while (k < len) {
    /* X */
    let _temp62 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp62 && typeof _temp62 === 'object' && 'next' in _temp62) _temp62 = skipDebugger(_temp62);
    /* node:coverage ignore next */
    if (_temp62 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp62
    });
    /* node:coverage ignore next */
    if (_temp62 instanceof Completion) _temp62 = _temp62.Value;
    const Pk = _temp62;
    /* ReturnIfAbrupt */
    let _temp63 = yield* HasProperty(O, Pk);
    /* node:coverage ignore next */
    if (_temp63 instanceof AbruptCompletion) return _temp63;
    /* node:coverage ignore next */
    if (_temp63 instanceof Completion) _temp63 = _temp63.Value;
    const kPresent = _temp63;
    if (kPresent === Value.true) {
      /* ReturnIfAbrupt */
      let _temp64 = yield* Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp64 instanceof AbruptCompletion) return _temp64;
      /* node:coverage ignore next */
      if (_temp64 instanceof Completion) _temp64 = _temp64.Value;
      const kValue = _temp64;
      /* ReturnIfAbrupt */
      let _temp65 = yield* Call(callbackfn, thisArg, [kValue, F(k), O]);
      /* node:coverage ignore next */
      if (_temp65 instanceof AbruptCompletion) return _temp65;
      /* node:coverage ignore next */
      if (_temp65 instanceof Completion) _temp65 = _temp65.Value;
      const mappedValue = _temp65;
      /* ReturnIfAbrupt */
      let _temp66 = yield* CreateDataPropertyOrThrow(A, Pk, mappedValue);
      /* node:coverage ignore next */
      if (_temp66 instanceof AbruptCompletion) return _temp66;
      /* node:coverage ignore next */
      if (_temp66 instanceof Completion) _temp66 = _temp66.Value;
    }
    k += 1;
  }
  return A;
}
ArrayProto_map.section = 'https://tc39.es/ecma262/#sec-array.prototype.map';
/** https://tc39.es/ecma262/#sec-array.prototype.pop */
function* ArrayProto_pop(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp67 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp67 && typeof _temp67 === 'object' && 'next' in _temp67) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp67 instanceof AbruptCompletion) return _temp67;
  /* node:coverage ignore next */
  if (_temp67 instanceof Completion) _temp67 = _temp67.Value;
  const O = _temp67;
  /* ReturnIfAbrupt */
  let _temp68 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp68 instanceof AbruptCompletion) return _temp68;
  /* node:coverage ignore next */
  if (_temp68 instanceof Completion) _temp68 = _temp68.Value;
  const len = _temp68;
  if (len === 0) {
    /* ReturnIfAbrupt */
    let _temp69 = yield* Set$1(O, Value('length'), F(0), Value.true);
    /* node:coverage ignore next */
    if (_temp69 instanceof AbruptCompletion) return _temp69;
    /* node:coverage ignore next */
    if (_temp69 instanceof Completion) _temp69 = _temp69.Value;
    return Value.undefined;
  } else {
    const newLen = len - 1;
    /* ReturnIfAbrupt */
    let _temp70 = yield* ToString(F(newLen));
    /* node:coverage ignore next */
    if (_temp70 instanceof AbruptCompletion) return _temp70;
    /* node:coverage ignore next */
    if (_temp70 instanceof Completion) _temp70 = _temp70.Value;
    const index = _temp70;
    /* ReturnIfAbrupt */
    let _temp71 = yield* Get(O, index);
    /* node:coverage ignore next */
    if (_temp71 instanceof AbruptCompletion) return _temp71;
    /* node:coverage ignore next */
    if (_temp71 instanceof Completion) _temp71 = _temp71.Value;
    const element = _temp71;
    /* ReturnIfAbrupt */
    let _temp72 = yield* DeletePropertyOrThrow(O, index);
    /* node:coverage ignore next */
    if (_temp72 instanceof AbruptCompletion) return _temp72;
    /* node:coverage ignore next */
    if (_temp72 instanceof Completion) _temp72 = _temp72.Value;
    /* ReturnIfAbrupt */
    let _temp73 = yield* Set$1(O, Value('length'), F(newLen), Value.true);
    /* node:coverage ignore next */
    if (_temp73 instanceof AbruptCompletion) return _temp73;
    /* node:coverage ignore next */
    if (_temp73 instanceof Completion) _temp73 = _temp73.Value;
    return element;
  }
}
ArrayProto_pop.section = 'https://tc39.es/ecma262/#sec-array.prototype.pop';
/** https://tc39.es/ecma262/#sec-array.prototype.push */
function* ArrayProto_push(_items, {
  thisValue
}) {
  const items = [..._items];
  /* ReturnIfAbrupt */
  let _temp74 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp74 && typeof _temp74 === 'object' && 'next' in _temp74) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp74 instanceof AbruptCompletion) return _temp74;
  /* node:coverage ignore next */
  if (_temp74 instanceof Completion) _temp74 = _temp74.Value;
  const O = _temp74;
  /* ReturnIfAbrupt */
  let _temp75 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp75 instanceof AbruptCompletion) return _temp75;
  /* node:coverage ignore next */
  if (_temp75 instanceof Completion) _temp75 = _temp75.Value;
  let len = _temp75;
  const argCount = items.length;
  if (len + argCount > 2 ** 53 - 1) {
    return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
  }
  while (items.length > 0) {
    const E = items.shift();
    /* X */
    let _temp77 = ToString(F(len));
    /* node:coverage ignore next */
    if (_temp77 && typeof _temp77 === 'object' && 'next' in _temp77) _temp77 = skipDebugger(_temp77);
    /* node:coverage ignore next */
    if (_temp77 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(len)) returned an abrupt completion", {
      cause: _temp77
    });
    /* node:coverage ignore next */
    if (_temp77 instanceof Completion) _temp77 = _temp77.Value;
    /* ReturnIfAbrupt */
    let _temp76 = yield* Set$1(O, _temp77, E, Value.true);
    /* node:coverage ignore next */
    if (_temp76 instanceof AbruptCompletion) return _temp76;
    /* node:coverage ignore next */
    if (_temp76 instanceof Completion) _temp76 = _temp76.Value;
    len += 1;
  }
  /* ReturnIfAbrupt */
  let _temp78 = yield* Set$1(O, Value('length'), F(len), Value.true);
  /* node:coverage ignore next */
  if (_temp78 instanceof AbruptCompletion) return _temp78;
  /* node:coverage ignore next */
  if (_temp78 instanceof Completion) _temp78 = _temp78.Value;
  return F(len);
}
ArrayProto_push.section = 'https://tc39.es/ecma262/#sec-array.prototype.push';
/** https://tc39.es/ecma262/#sec-array.prototype.shift */
function* ArrayProto_shift(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp79 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp79 && typeof _temp79 === 'object' && 'next' in _temp79) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp79 instanceof AbruptCompletion) return _temp79;
  /* node:coverage ignore next */
  if (_temp79 instanceof Completion) _temp79 = _temp79.Value;
  const O = _temp79;
  /* ReturnIfAbrupt */
  let _temp80 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp80 instanceof AbruptCompletion) return _temp80;
  /* node:coverage ignore next */
  if (_temp80 instanceof Completion) _temp80 = _temp80.Value;
  const len = _temp80;
  if (len === 0) {
    /* ReturnIfAbrupt */
    let _temp81 = yield* Set$1(O, Value('length'), F(0), Value.true);
    /* node:coverage ignore next */
    if (_temp81 instanceof AbruptCompletion) return _temp81;
    /* node:coverage ignore next */
    if (_temp81 instanceof Completion) _temp81 = _temp81.Value;
    return Value.undefined;
  }
  /* ReturnIfAbrupt */
  let _temp82 = yield* Get(O, Value('0'));
  /* node:coverage ignore next */
  if (_temp82 instanceof AbruptCompletion) return _temp82;
  /* node:coverage ignore next */
  if (_temp82 instanceof Completion) _temp82 = _temp82.Value;
  const first = _temp82;
  let k = 1;
  while (k < len) {
    /* X */
    let _temp83 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp83 && typeof _temp83 === 'object' && 'next' in _temp83) _temp83 = skipDebugger(_temp83);
    /* node:coverage ignore next */
    if (_temp83 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp83
    });
    /* node:coverage ignore next */
    if (_temp83 instanceof Completion) _temp83 = _temp83.Value;
    const from = _temp83;
    /* X */
    let _temp84 = ToString(F(k - 1));
    /* node:coverage ignore next */
    if (_temp84 && typeof _temp84 === 'object' && 'next' in _temp84) _temp84 = skipDebugger(_temp84);
    /* node:coverage ignore next */
    if (_temp84 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k - 1)) returned an abrupt completion", {
      cause: _temp84
    });
    /* node:coverage ignore next */
    if (_temp84 instanceof Completion) _temp84 = _temp84.Value;
    const to = _temp84;
    /* ReturnIfAbrupt */
    let _temp85 = yield* HasProperty(O, from);
    /* node:coverage ignore next */
    if (_temp85 instanceof AbruptCompletion) return _temp85;
    /* node:coverage ignore next */
    if (_temp85 instanceof Completion) _temp85 = _temp85.Value;
    const fromPresent = _temp85;
    if (fromPresent === Value.true) {
      /* ReturnIfAbrupt */
      let _temp86 = yield* Get(O, from);
      /* node:coverage ignore next */
      if (_temp86 instanceof AbruptCompletion) return _temp86;
      /* node:coverage ignore next */
      if (_temp86 instanceof Completion) _temp86 = _temp86.Value;
      const fromVal = _temp86;
      /* ReturnIfAbrupt */
      let _temp87 = yield* Set$1(O, to, fromVal, Value.true);
      /* node:coverage ignore next */
      if (_temp87 instanceof AbruptCompletion) return _temp87;
      /* node:coverage ignore next */
      if (_temp87 instanceof Completion) _temp87 = _temp87.Value;
    } else {
      /* ReturnIfAbrupt */
      let _temp88 = yield* DeletePropertyOrThrow(O, to);
      /* node:coverage ignore next */
      if (_temp88 instanceof AbruptCompletion) return _temp88;
      /* node:coverage ignore next */
      if (_temp88 instanceof Completion) _temp88 = _temp88.Value;
    }
    k += 1;
  }
  /* X */
  let _temp91 = ToString(F(len - 1));
  /* node:coverage ignore next */
  if (_temp91 && typeof _temp91 === 'object' && 'next' in _temp91) _temp91 = skipDebugger(_temp91);
  /* node:coverage ignore next */
  if (_temp91 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(len - 1)) returned an abrupt completion", {
    cause: _temp91
  });
  /* node:coverage ignore next */
  if (_temp91 instanceof Completion) _temp91 = _temp91.Value;
  /* ReturnIfAbrupt */
  let _temp89 = yield* DeletePropertyOrThrow(O, _temp91);
  /* node:coverage ignore next */
  if (_temp89 instanceof AbruptCompletion) return _temp89;
  /* node:coverage ignore next */
  if (_temp89 instanceof Completion) _temp89 = _temp89.Value;
  /* ReturnIfAbrupt */
  let _temp90 = yield* Set$1(O, Value('length'), F(len - 1), Value.true);
  /* node:coverage ignore next */
  if (_temp90 instanceof AbruptCompletion) return _temp90;
  /* node:coverage ignore next */
  if (_temp90 instanceof Completion) _temp90 = _temp90.Value;
  return first;
}
ArrayProto_shift.section = 'https://tc39.es/ecma262/#sec-array.prototype.shift';
/** https://tc39.es/ecma262/#sec-array.prototype.slice */
function* ArrayProto_slice([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp92 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp92 && typeof _temp92 === 'object' && 'next' in _temp92) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp92 instanceof AbruptCompletion) return _temp92;
  /* node:coverage ignore next */
  if (_temp92 instanceof Completion) _temp92 = _temp92.Value;
  const O = _temp92;
  /* ReturnIfAbrupt */
  let _temp93 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp93 instanceof AbruptCompletion) return _temp93;
  /* node:coverage ignore next */
  if (_temp93 instanceof Completion) _temp93 = _temp93.Value;
  const len = _temp93;
  /* ReturnIfAbrupt */
  let _temp94 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp94 instanceof AbruptCompletion) return _temp94;
  /* node:coverage ignore next */
  if (_temp94 instanceof Completion) _temp94 = _temp94.Value;
  const relativeStart = _temp94;
  let k;
  if (relativeStart < 0) {
    k = Math.max(len + relativeStart, 0);
  } else {
    k = Math.min(relativeStart, len);
  }
  let relativeEnd;
  if (end instanceof UndefinedValue) {
    relativeEnd = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp95 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp95 instanceof AbruptCompletion) return _temp95;
    /* node:coverage ignore next */
    if (_temp95 instanceof Completion) _temp95 = _temp95.Value;
    relativeEnd = _temp95;
  }
  let final;
  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }
  const count = Math.max(final - k, 0);
  /* ReturnIfAbrupt */
  let _temp96 = yield* ArraySpeciesCreate(O, count);
  /* node:coverage ignore next */
  if (_temp96 instanceof AbruptCompletion) return _temp96;
  /* node:coverage ignore next */
  if (_temp96 instanceof Completion) _temp96 = _temp96.Value;
  const A = _temp96;
  let n = 0;
  while (k < final) {
    /* X */
    let _temp97 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp97 && typeof _temp97 === 'object' && 'next' in _temp97) _temp97 = skipDebugger(_temp97);
    /* node:coverage ignore next */
    if (_temp97 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp97
    });
    /* node:coverage ignore next */
    if (_temp97 instanceof Completion) _temp97 = _temp97.Value;
    const Pk = _temp97;
    /* ReturnIfAbrupt */
    let _temp98 = yield* HasProperty(O, Pk);
    /* node:coverage ignore next */
    if (_temp98 instanceof AbruptCompletion) return _temp98;
    /* node:coverage ignore next */
    if (_temp98 instanceof Completion) _temp98 = _temp98.Value;
    const kPresent = _temp98;
    if (kPresent === Value.true) {
      /* ReturnIfAbrupt */
      let _temp99 = yield* Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp99 instanceof AbruptCompletion) return _temp99;
      /* node:coverage ignore next */
      if (_temp99 instanceof Completion) _temp99 = _temp99.Value;
      const kValue = _temp99;
      /* X */
      let _temp100 = ToString(F(n));
      /* node:coverage ignore next */
      if (_temp100 && typeof _temp100 === 'object' && 'next' in _temp100) _temp100 = skipDebugger(_temp100);
      /* node:coverage ignore next */
      if (_temp100 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
        cause: _temp100
      });
      /* node:coverage ignore next */
      if (_temp100 instanceof Completion) _temp100 = _temp100.Value;
      const nStr = _temp100;
      /* ReturnIfAbrupt */
      let _temp101 = yield* CreateDataPropertyOrThrow(A, nStr, kValue);
      /* node:coverage ignore next */
      if (_temp101 instanceof AbruptCompletion) return _temp101;
      /* node:coverage ignore next */
      if (_temp101 instanceof Completion) _temp101 = _temp101.Value;
    }
    k += 1;
    n += 1;
  }
  /* ReturnIfAbrupt */
  let _temp102 = yield* Set$1(A, Value('length'), F(n), Value.true);
  /* node:coverage ignore next */
  if (_temp102 instanceof AbruptCompletion) return _temp102;
  /* node:coverage ignore next */
  if (_temp102 instanceof Completion) _temp102 = _temp102.Value;
  return A;
}
ArrayProto_slice.section = 'https://tc39.es/ecma262/#sec-array.prototype.slice';
/** https://tc39.es/ecma262/#sec-array.prototype.sort */
function* ArrayProto_sort([comparefn = Value.undefined], {
  thisValue
}) {
  if (comparefn !== Value.undefined && !IsCallable(comparefn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', comparefn);
  }
  /* ReturnIfAbrupt */
  let _temp103 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp103 && typeof _temp103 === 'object' && 'next' in _temp103) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp103 instanceof AbruptCompletion) return _temp103;
  /* node:coverage ignore next */
  if (_temp103 instanceof Completion) _temp103 = _temp103.Value;
  const obj = _temp103;
  /* ReturnIfAbrupt */
  let _temp104 = yield* LengthOfArrayLike(obj);
  /* node:coverage ignore next */
  if (_temp104 instanceof AbruptCompletion) return _temp104;
  /* node:coverage ignore next */
  if (_temp104 instanceof Completion) _temp104 = _temp104.Value;
  const len = _temp104;
  return yield* ArrayProto_sortBody(obj, len, (x, y) => CompareArrayElements(x, y, comparefn));
}
ArrayProto_sort.section = 'https://tc39.es/ecma262/#sec-array.prototype.sort';
/** https://tc39.es/ecma262/#sec-array.prototype.tosorted */
function* ArrayProto_toSorted([comparator = Value.undefined], {
  thisValue
}) {
  if (comparator !== Value.undefined && !IsCallable(comparator)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', comparator);
  }
  /* ReturnIfAbrupt */
  let _temp105 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp105 && typeof _temp105 === 'object' && 'next' in _temp105) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp105 instanceof AbruptCompletion) return _temp105;
  /* node:coverage ignore next */
  if (_temp105 instanceof Completion) _temp105 = _temp105.Value;
  const O = _temp105;
  /* ReturnIfAbrupt */
  let _temp106 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp106 instanceof AbruptCompletion) return _temp106;
  /* node:coverage ignore next */
  if (_temp106 instanceof Completion) _temp106 = _temp106.Value;
  const len = _temp106;
  /* ReturnIfAbrupt */
  let _temp107 = ArrayCreate(len);
  /* node:coverage ignore next */
  if (_temp107 && typeof _temp107 === 'object' && 'next' in _temp107) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp107 instanceof AbruptCompletion) return _temp107;
  /* node:coverage ignore next */
  if (_temp107 instanceof Completion) _temp107 = _temp107.Value;
  const A = _temp107;
  const SortCompare = function* SortCompare(x, y) {
    return yield* CompareArrayElements(x, y, comparator);
  };
  /* ReturnIfAbrupt */
  let _temp108 = yield* SortIndexedProperties(O, len, SortCompare, 'read-through-holes');
  /* node:coverage ignore next */
  if (_temp108 instanceof AbruptCompletion) return _temp108;
  /* node:coverage ignore next */
  if (_temp108 instanceof Completion) _temp108 = _temp108.Value;
  const sortedList = _temp108;
  let j = 0;
  while (j < len) {
    /* X */
    let _temp110 = ToString(F(j));
    /* node:coverage ignore next */
    if (_temp110 && typeof _temp110 === 'object' && 'next' in _temp110) _temp110 = skipDebugger(_temp110);
    /* node:coverage ignore next */
    if (_temp110 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(j)) returned an abrupt completion", {
      cause: _temp110
    });
    /* node:coverage ignore next */
    if (_temp110 instanceof Completion) _temp110 = _temp110.Value;
    /* X */
    let _temp109 = CreateDataPropertyOrThrow(A, _temp110, sortedList[j]);
    /* node:coverage ignore next */
    if (_temp109 && typeof _temp109 === 'object' && 'next' in _temp109) _temp109 = skipDebugger(_temp109);
    /* node:coverage ignore next */
    if (_temp109 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(F(j))), sortedList[j]) returned an abrupt completion", {
      cause: _temp109
    });
    /* node:coverage ignore next */
    if (_temp109 instanceof Completion) _temp109 = _temp109.Value;
    j += 1;
  }
  return A;
}
ArrayProto_toSorted.section = 'https://tc39.es/ecma262/#sec-array.prototype.tosorted';
/** https://tc39.es/ecma262/#sec-array.prototype.splice */
function* ArrayProto_splice(args, {
  thisValue
}) {
  const [start = Value.undefined, deleteCount = Value.undefined, ...items] = args;
  /* ReturnIfAbrupt */
  let _temp111 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp111 && typeof _temp111 === 'object' && 'next' in _temp111) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp111 instanceof AbruptCompletion) return _temp111;
  /* node:coverage ignore next */
  if (_temp111 instanceof Completion) _temp111 = _temp111.Value;
  const O = _temp111;
  /* ReturnIfAbrupt */
  let _temp112 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp112 instanceof AbruptCompletion) return _temp112;
  /* node:coverage ignore next */
  if (_temp112 instanceof Completion) _temp112 = _temp112.Value;
  const len = _temp112;
  /* ReturnIfAbrupt */
  let _temp113 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp113 instanceof AbruptCompletion) return _temp113;
  /* node:coverage ignore next */
  if (_temp113 instanceof Completion) _temp113 = _temp113.Value;
  const relativeStart = _temp113;
  let actualStart;
  if (relativeStart < 0) {
    actualStart = Math.max(len + relativeStart, 0);
  } else {
    actualStart = Math.min(relativeStart, len);
  }
  let insertCount;
  let actualDeleteCount;
  if (args.length === 0) {
    insertCount = 0;
    actualDeleteCount = 0;
  } else if (args.length === 1) {
    insertCount = 0;
    actualDeleteCount = len - actualStart;
  } else {
    insertCount = args.length - 2;
    /* ReturnIfAbrupt */
    let _temp114 = yield* ToIntegerOrInfinity(deleteCount);
    /* node:coverage ignore next */
    if (_temp114 instanceof AbruptCompletion) return _temp114;
    /* node:coverage ignore next */
    if (_temp114 instanceof Completion) _temp114 = _temp114.Value;
    const dc = _temp114;
    actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);
  }
  if (len + insertCount - actualDeleteCount > 2 ** 53 - 1) {
    return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
  }
  /* ReturnIfAbrupt */
  let _temp115 = yield* ArraySpeciesCreate(O, actualDeleteCount);
  /* node:coverage ignore next */
  if (_temp115 instanceof AbruptCompletion) return _temp115;
  /* node:coverage ignore next */
  if (_temp115 instanceof Completion) _temp115 = _temp115.Value;
  const A = _temp115;
  let k = 0;
  while (k < actualDeleteCount) {
    /* X */
    let _temp116 = ToString(F(actualStart + k));
    /* node:coverage ignore next */
    if (_temp116 && typeof _temp116 === 'object' && 'next' in _temp116) _temp116 = skipDebugger(_temp116);
    /* node:coverage ignore next */
    if (_temp116 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(actualStart + k)) returned an abrupt completion", {
      cause: _temp116
    });
    /* node:coverage ignore next */
    if (_temp116 instanceof Completion) _temp116 = _temp116.Value;
    const from = _temp116;
    /* ReturnIfAbrupt */
    let _temp117 = yield* HasProperty(O, from);
    /* node:coverage ignore next */
    if (_temp117 instanceof AbruptCompletion) return _temp117;
    /* node:coverage ignore next */
    if (_temp117 instanceof Completion) _temp117 = _temp117.Value;
    const fromPresent = _temp117;
    if (fromPresent === Value.true) {
      /* ReturnIfAbrupt */
      let _temp118 = yield* Get(O, from);
      /* node:coverage ignore next */
      if (_temp118 instanceof AbruptCompletion) return _temp118;
      /* node:coverage ignore next */
      if (_temp118 instanceof Completion) _temp118 = _temp118.Value;
      const fromValue = _temp118;
      /* X */
      let _temp120 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp120 && typeof _temp120 === 'object' && 'next' in _temp120) _temp120 = skipDebugger(_temp120);
      /* node:coverage ignore next */
      if (_temp120 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp120
      });
      /* node:coverage ignore next */
      if (_temp120 instanceof Completion) _temp120 = _temp120.Value;
      /* ReturnIfAbrupt */
      let _temp119 = yield* CreateDataPropertyOrThrow(A, _temp120, fromValue);
      /* node:coverage ignore next */
      if (_temp119 instanceof AbruptCompletion) return _temp119;
      /* node:coverage ignore next */
      if (_temp119 instanceof Completion) _temp119 = _temp119.Value;
    }
    k += 1;
  }
  /* ReturnIfAbrupt */
  let _temp121 = yield* Set$1(A, Value('length'), F(actualDeleteCount), Value.true);
  /* node:coverage ignore next */
  if (_temp121 instanceof AbruptCompletion) return _temp121;
  /* node:coverage ignore next */
  if (_temp121 instanceof Completion) _temp121 = _temp121.Value;
  const itemCount = items.length;
  if (itemCount < actualDeleteCount) {
    k = actualStart;
    while (k < len - actualDeleteCount) {
      /* X */
      let _temp122 = ToString(F(k + actualDeleteCount));
      /* node:coverage ignore next */
      if (_temp122 && typeof _temp122 === 'object' && 'next' in _temp122) _temp122 = skipDebugger(_temp122);
      /* node:coverage ignore next */
      if (_temp122 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k + actualDeleteCount)) returned an abrupt completion", {
        cause: _temp122
      });
      /* node:coverage ignore next */
      if (_temp122 instanceof Completion) _temp122 = _temp122.Value;
      const from = _temp122;
      /* X */
      let _temp123 = ToString(F(k + itemCount));
      /* node:coverage ignore next */
      if (_temp123 && typeof _temp123 === 'object' && 'next' in _temp123) _temp123 = skipDebugger(_temp123);
      /* node:coverage ignore next */
      if (_temp123 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k + itemCount)) returned an abrupt completion", {
        cause: _temp123
      });
      /* node:coverage ignore next */
      if (_temp123 instanceof Completion) _temp123 = _temp123.Value;
      const to = _temp123;
      /* ReturnIfAbrupt */
      let _temp124 = yield* HasProperty(O, from);
      /* node:coverage ignore next */
      if (_temp124 instanceof AbruptCompletion) return _temp124;
      /* node:coverage ignore next */
      if (_temp124 instanceof Completion) _temp124 = _temp124.Value;
      const fromPresent = _temp124;
      if (fromPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp125 = yield* Get(O, from);
        /* node:coverage ignore next */
        if (_temp125 instanceof AbruptCompletion) return _temp125;
        /* node:coverage ignore next */
        if (_temp125 instanceof Completion) _temp125 = _temp125.Value;
        const fromValue = _temp125;
        /* ReturnIfAbrupt */
        let _temp126 = yield* Set$1(O, to, fromValue, Value.true);
        /* node:coverage ignore next */
        if (_temp126 instanceof AbruptCompletion) return _temp126;
        /* node:coverage ignore next */
        if (_temp126 instanceof Completion) _temp126 = _temp126.Value;
      } else {
        /* ReturnIfAbrupt */
        let _temp127 = yield* DeletePropertyOrThrow(O, to);
        /* node:coverage ignore next */
        if (_temp127 instanceof AbruptCompletion) return _temp127;
        /* node:coverage ignore next */
        if (_temp127 instanceof Completion) _temp127 = _temp127.Value;
      }
      k += 1;
    }
    k = len;
    while (k > len - actualDeleteCount + itemCount) {
      /* X */
      let _temp129 = ToString(F(k - 1));
      /* node:coverage ignore next */
      if (_temp129 && typeof _temp129 === 'object' && 'next' in _temp129) _temp129 = skipDebugger(_temp129);
      /* node:coverage ignore next */
      if (_temp129 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k - 1)) returned an abrupt completion", {
        cause: _temp129
      });
      /* node:coverage ignore next */
      if (_temp129 instanceof Completion) _temp129 = _temp129.Value;
      /* ReturnIfAbrupt */
      let _temp128 = yield* DeletePropertyOrThrow(O, _temp129);
      /* node:coverage ignore next */
      if (_temp128 instanceof AbruptCompletion) return _temp128;
      /* node:coverage ignore next */
      if (_temp128 instanceof Completion) _temp128 = _temp128.Value;
      k -= 1;
    }
  } else if (itemCount > actualDeleteCount) {
    k = len - actualDeleteCount;
    while (k > actualStart) {
      /* X */
      let _temp130 = ToString(F(k + actualDeleteCount - 1));
      /* node:coverage ignore next */
      if (_temp130 && typeof _temp130 === 'object' && 'next' in _temp130) _temp130 = skipDebugger(_temp130);
      /* node:coverage ignore next */
      if (_temp130 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k + actualDeleteCount - 1)) returned an abrupt completion", {
        cause: _temp130
      });
      /* node:coverage ignore next */
      if (_temp130 instanceof Completion) _temp130 = _temp130.Value;
      const from = _temp130;
      /* X */
      let _temp131 = ToString(F(k + itemCount - 1));
      /* node:coverage ignore next */
      if (_temp131 && typeof _temp131 === 'object' && 'next' in _temp131) _temp131 = skipDebugger(_temp131);
      /* node:coverage ignore next */
      if (_temp131 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k + itemCount - 1)) returned an abrupt completion", {
        cause: _temp131
      });
      /* node:coverage ignore next */
      if (_temp131 instanceof Completion) _temp131 = _temp131.Value;
      const to = _temp131;
      /* ReturnIfAbrupt */
      let _temp132 = yield* HasProperty(O, from);
      /* node:coverage ignore next */
      if (_temp132 instanceof AbruptCompletion) return _temp132;
      /* node:coverage ignore next */
      if (_temp132 instanceof Completion) _temp132 = _temp132.Value;
      const fromPresent = _temp132;
      if (fromPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp133 = yield* Get(O, from);
        /* node:coverage ignore next */
        if (_temp133 instanceof AbruptCompletion) return _temp133;
        /* node:coverage ignore next */
        if (_temp133 instanceof Completion) _temp133 = _temp133.Value;
        const fromValue = _temp133;
        /* ReturnIfAbrupt */
        let _temp134 = yield* Set$1(O, to, fromValue, Value.true);
        /* node:coverage ignore next */
        if (_temp134 instanceof AbruptCompletion) return _temp134;
        /* node:coverage ignore next */
        if (_temp134 instanceof Completion) _temp134 = _temp134.Value;
      } else {
        /* ReturnIfAbrupt */
        let _temp135 = yield* DeletePropertyOrThrow(O, to);
        /* node:coverage ignore next */
        if (_temp135 instanceof AbruptCompletion) return _temp135;
        /* node:coverage ignore next */
        if (_temp135 instanceof Completion) _temp135 = _temp135.Value;
      }
      k -= 1;
    }
  }
  k = actualStart;
  while (items.length > 0) {
    const E = items.shift();
    /* X */
    let _temp137 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp137 && typeof _temp137 === 'object' && 'next' in _temp137) _temp137 = skipDebugger(_temp137);
    /* node:coverage ignore next */
    if (_temp137 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp137
    });
    /* node:coverage ignore next */
    if (_temp137 instanceof Completion) _temp137 = _temp137.Value;
    /* ReturnIfAbrupt */
    let _temp136 = yield* Set$1(O, _temp137, E, Value.true);
    /* node:coverage ignore next */
    if (_temp136 instanceof AbruptCompletion) return _temp136;
    /* node:coverage ignore next */
    if (_temp136 instanceof Completion) _temp136 = _temp136.Value;
    k += 1;
  }
  /* ReturnIfAbrupt */
  let _temp138 = yield* Set$1(O, Value('length'), F(len - actualDeleteCount + itemCount), Value.true);
  /* node:coverage ignore next */
  if (_temp138 instanceof AbruptCompletion) return _temp138;
  /* node:coverage ignore next */
  if (_temp138 instanceof Completion) _temp138 = _temp138.Value;
  return A;
}
ArrayProto_splice.section = 'https://tc39.es/ecma262/#sec-array.prototype.splice';
/** https://tc39.es/ecma262/#sec-array.prototype.tospliced */
function* ArrayProto_toSpliced(args, {
  thisValue
}) {
  const [start = Value.undefined, skipCount = Value.undefined, ...items] = args;
  /* ReturnIfAbrupt */
  let _temp139 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp139 && typeof _temp139 === 'object' && 'next' in _temp139) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp139 instanceof AbruptCompletion) return _temp139;
  /* node:coverage ignore next */
  if (_temp139 instanceof Completion) _temp139 = _temp139.Value;
  const O = _temp139;
  /* ReturnIfAbrupt */
  let _temp140 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp140 instanceof AbruptCompletion) return _temp140;
  /* node:coverage ignore next */
  if (_temp140 instanceof Completion) _temp140 = _temp140.Value;
  const len = _temp140;
  /* ReturnIfAbrupt */
  let _temp141 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp141 instanceof AbruptCompletion) return _temp141;
  /* node:coverage ignore next */
  if (_temp141 instanceof Completion) _temp141 = _temp141.Value;
  const relativeStart = _temp141;
  let actualStart;
  if (relativeStart === -Infinity) {
    actualStart = 0;
  } else if (relativeStart < 0) {
    actualStart = Math.max(len + relativeStart, 0);
  } else {
    actualStart = Math.min(relativeStart, len);
  }
  const insertCount = items.length;
  let actualSkipCount;
  if (args[0] === undefined) {
    actualSkipCount = 0;
  } else if (args[1] === undefined) {
    actualSkipCount = len - actualStart;
  } else {
    /* ReturnIfAbrupt */
    let _temp142 = yield* ToIntegerOrInfinity(skipCount);
    /* node:coverage ignore next */
    if (_temp142 instanceof AbruptCompletion) return _temp142;
    /* node:coverage ignore next */
    if (_temp142 instanceof Completion) _temp142 = _temp142.Value;
    const sc = _temp142;
    actualSkipCount = Math.min(Math.max(sc, 0), len - actualStart);
  }
  const newLen = len - actualSkipCount + insertCount;
  if (newLen > 2 ** 53 - 1) {
    return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
  }
  /* ReturnIfAbrupt */
  let _temp143 = ArrayCreate(newLen);
  /* node:coverage ignore next */
  if (_temp143 && typeof _temp143 === 'object' && 'next' in _temp143) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp143 instanceof AbruptCompletion) return _temp143;
  /* node:coverage ignore next */
  if (_temp143 instanceof Completion) _temp143 = _temp143.Value;
  const A = _temp143;
  let i = 0;
  let r = actualStart + actualSkipCount;
  while (i < actualStart) {
    /* X */
    let _temp144 = ToString(F(i));
    /* node:coverage ignore next */
    if (_temp144 && typeof _temp144 === 'object' && 'next' in _temp144) _temp144 = skipDebugger(_temp144);
    /* node:coverage ignore next */
    if (_temp144 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(i)) returned an abrupt completion", {
      cause: _temp144
    });
    /* node:coverage ignore next */
    if (_temp144 instanceof Completion) _temp144 = _temp144.Value;
    const Pi = _temp144;
    /* ReturnIfAbrupt */
    let _temp145 = yield* Get(O, Pi);
    /* node:coverage ignore next */
    if (_temp145 instanceof AbruptCompletion) return _temp145;
    /* node:coverage ignore next */
    if (_temp145 instanceof Completion) _temp145 = _temp145.Value;
    const iValue = _temp145;
    /* X */
    let _temp146 = CreateDataPropertyOrThrow(A, Pi, iValue);
    /* node:coverage ignore next */
    if (_temp146 && typeof _temp146 === 'object' && 'next' in _temp146) _temp146 = skipDebugger(_temp146);
    /* node:coverage ignore next */
    if (_temp146 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Pi, iValue) returned an abrupt completion", {
      cause: _temp146
    });
    /* node:coverage ignore next */
    if (_temp146 instanceof Completion) _temp146 = _temp146.Value;
    i += 1;
  }
  for (const E of items) {
    /* X */
    let _temp147 = ToString(F(i));
    /* node:coverage ignore next */
    if (_temp147 && typeof _temp147 === 'object' && 'next' in _temp147) _temp147 = skipDebugger(_temp147);
    /* node:coverage ignore next */
    if (_temp147 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(i)) returned an abrupt completion", {
      cause: _temp147
    });
    /* node:coverage ignore next */
    if (_temp147 instanceof Completion) _temp147 = _temp147.Value;
    const Pi = _temp147;
    /* X */
    let _temp148 = CreateDataPropertyOrThrow(A, Pi, E);
    /* node:coverage ignore next */
    if (_temp148 && typeof _temp148 === 'object' && 'next' in _temp148) _temp148 = skipDebugger(_temp148);
    /* node:coverage ignore next */
    if (_temp148 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Pi, E) returned an abrupt completion", {
      cause: _temp148
    });
    /* node:coverage ignore next */
    if (_temp148 instanceof Completion) _temp148 = _temp148.Value;
    i += 1;
  }
  while (i < newLen) {
    /* X */
    let _temp149 = ToString(F(i));
    /* node:coverage ignore next */
    if (_temp149 && typeof _temp149 === 'object' && 'next' in _temp149) _temp149 = skipDebugger(_temp149);
    /* node:coverage ignore next */
    if (_temp149 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(i)) returned an abrupt completion", {
      cause: _temp149
    });
    /* node:coverage ignore next */
    if (_temp149 instanceof Completion) _temp149 = _temp149.Value;
    const Pi = _temp149;
    /* X */
    let _temp150 = ToString(F(r));
    /* node:coverage ignore next */
    if (_temp150 && typeof _temp150 === 'object' && 'next' in _temp150) _temp150 = skipDebugger(_temp150);
    /* node:coverage ignore next */
    if (_temp150 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(r)) returned an abrupt completion", {
      cause: _temp150
    });
    /* node:coverage ignore next */
    if (_temp150 instanceof Completion) _temp150 = _temp150.Value;
    const from = _temp150;
    /* ReturnIfAbrupt */
    let _temp151 = yield* Get(O, from);
    /* node:coverage ignore next */
    if (_temp151 instanceof AbruptCompletion) return _temp151;
    /* node:coverage ignore next */
    if (_temp151 instanceof Completion) _temp151 = _temp151.Value;
    const fromValue = _temp151;
    /* X */
    let _temp152 = CreateDataPropertyOrThrow(A, Pi, fromValue);
    /* node:coverage ignore next */
    if (_temp152 && typeof _temp152 === 'object' && 'next' in _temp152) _temp152 = skipDebugger(_temp152);
    /* node:coverage ignore next */
    if (_temp152 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Pi, fromValue) returned an abrupt completion", {
      cause: _temp152
    });
    /* node:coverage ignore next */
    if (_temp152 instanceof Completion) _temp152 = _temp152.Value;
    i += 1;
    r += 1;
  }
  return A;
}
ArrayProto_toSpliced.section = 'https://tc39.es/ecma262/#sec-array.prototype.tospliced';
/** https://tc39.es/ecma262/#sec-array.prototype.with */
function* ArrayProto_with([index = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp153 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp153 && typeof _temp153 === 'object' && 'next' in _temp153) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp153 instanceof AbruptCompletion) return _temp153;
  /* node:coverage ignore next */
  if (_temp153 instanceof Completion) _temp153 = _temp153.Value;
  const O = _temp153;
  /* ReturnIfAbrupt */
  let _temp154 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp154 instanceof AbruptCompletion) return _temp154;
  /* node:coverage ignore next */
  if (_temp154 instanceof Completion) _temp154 = _temp154.Value;
  const len = _temp154;
  /* ReturnIfAbrupt */
  let _temp155 = yield* ToIntegerOrInfinity(index);
  /* node:coverage ignore next */
  if (_temp155 instanceof AbruptCompletion) return _temp155;
  /* node:coverage ignore next */
  if (_temp155 instanceof Completion) _temp155 = _temp155.Value;
  const relativeIndex = _temp155;
  let actualIndex;
  if (relativeIndex >= 0) {
    actualIndex = relativeIndex;
  } else {
    actualIndex = len + relativeIndex;
  }
  if (actualIndex >= len || actualIndex < 0) {
    return surroundingAgent.Throw('RangeError', 'OutOfRange', index);
  }
  /* ReturnIfAbrupt */
  let _temp156 = ArrayCreate(len);
  /* node:coverage ignore next */
  if (_temp156 && typeof _temp156 === 'object' && 'next' in _temp156) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp156 instanceof AbruptCompletion) return _temp156;
  /* node:coverage ignore next */
  if (_temp156 instanceof Completion) _temp156 = _temp156.Value;
  const A = _temp156;
  let k = 0;
  while (k < len) {
    /* X */
    let _temp157 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp157 && typeof _temp157 === 'object' && 'next' in _temp157) _temp157 = skipDebugger(_temp157);
    /* node:coverage ignore next */
    if (_temp157 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp157
    });
    /* node:coverage ignore next */
    if (_temp157 instanceof Completion) _temp157 = _temp157.Value;
    const Pk = _temp157;
    let fromValue;
    if (k === actualIndex) {
      fromValue = value;
    } else {
      /* ReturnIfAbrupt */
      let _temp158 = yield* Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp158 instanceof AbruptCompletion) return _temp158;
      /* node:coverage ignore next */
      if (_temp158 instanceof Completion) _temp158 = _temp158.Value;
      fromValue = _temp158;
    }
    /* X */
    let _temp159 = CreateDataPropertyOrThrow(A, Pk, fromValue);
    /* node:coverage ignore next */
    if (_temp159 && typeof _temp159 === 'object' && 'next' in _temp159) _temp159 = skipDebugger(_temp159);
    /* node:coverage ignore next */
    if (_temp159 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Pk, fromValue) returned an abrupt completion", {
      cause: _temp159
    });
    /* node:coverage ignore next */
    if (_temp159 instanceof Completion) _temp159 = _temp159.Value;
    k += 1;
  }
  return A;
}
ArrayProto_with.section = 'https://tc39.es/ecma262/#sec-array.prototype.with';
/** https://tc39.es/ecma262/#sec-array.prototype.tostring */
function* ArrayProto_toString(_a, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp160 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp160 && typeof _temp160 === 'object' && 'next' in _temp160) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp160 instanceof AbruptCompletion) return _temp160;
  /* node:coverage ignore next */
  if (_temp160 instanceof Completion) _temp160 = _temp160.Value;
  const array = _temp160;
  /* ReturnIfAbrupt */
  let _temp161 = yield* Get(array, Value('join'));
  /* node:coverage ignore next */
  if (_temp161 instanceof AbruptCompletion) return _temp161;
  /* node:coverage ignore next */
  if (_temp161 instanceof Completion) _temp161 = _temp161.Value;
  let func = _temp161;
  if (!IsCallable(func)) {
    func = surroundingAgent.intrinsic('%Object.prototype.toString%');
  }
  return yield* Call(func, array);
}
ArrayProto_toString.section = 'https://tc39.es/ecma262/#sec-array.prototype.tostring';
/** https://tc39.es/ecma262/#sec-array.prototype.unshift */
function* ArrayProto_unshift(args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp162 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp162 && typeof _temp162 === 'object' && 'next' in _temp162) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp162 instanceof AbruptCompletion) return _temp162;
  /* node:coverage ignore next */
  if (_temp162 instanceof Completion) _temp162 = _temp162.Value;
  const O = _temp162;
  /* ReturnIfAbrupt */
  let _temp163 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp163 instanceof AbruptCompletion) return _temp163;
  /* node:coverage ignore next */
  if (_temp163 instanceof Completion) _temp163 = _temp163.Value;
  const len = _temp163;
  const argCount = args.length;
  if (argCount > 0) {
    if (len + argCount > 2 ** 53 - 1) {
      return surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength');
    }
    let k = len;
    while (k > 0) {
      /* X */
      let _temp164 = ToString(F(k - 1));
      /* node:coverage ignore next */
      if (_temp164 && typeof _temp164 === 'object' && 'next' in _temp164) _temp164 = skipDebugger(_temp164);
      /* node:coverage ignore next */
      if (_temp164 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k - 1)) returned an abrupt completion", {
        cause: _temp164
      });
      /* node:coverage ignore next */
      if (_temp164 instanceof Completion) _temp164 = _temp164.Value;
      const from = _temp164;
      /* X */
      let _temp165 = ToString(F(k + argCount - 1));
      /* node:coverage ignore next */
      if (_temp165 && typeof _temp165 === 'object' && 'next' in _temp165) _temp165 = skipDebugger(_temp165);
      /* node:coverage ignore next */
      if (_temp165 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k + argCount - 1)) returned an abrupt completion", {
        cause: _temp165
      });
      /* node:coverage ignore next */
      if (_temp165 instanceof Completion) _temp165 = _temp165.Value;
      const to = _temp165;
      /* ReturnIfAbrupt */
      let _temp166 = yield* HasProperty(O, from);
      /* node:coverage ignore next */
      if (_temp166 instanceof AbruptCompletion) return _temp166;
      /* node:coverage ignore next */
      if (_temp166 instanceof Completion) _temp166 = _temp166.Value;
      const fromPresent = _temp166;
      if (fromPresent === Value.true) {
        /* ReturnIfAbrupt */
        let _temp167 = yield* Get(O, from);
        /* node:coverage ignore next */
        if (_temp167 instanceof AbruptCompletion) return _temp167;
        /* node:coverage ignore next */
        if (_temp167 instanceof Completion) _temp167 = _temp167.Value;
        const fromValue = _temp167;
        /* ReturnIfAbrupt */
        let _temp168 = yield* Set$1(O, to, fromValue, Value.true);
        /* node:coverage ignore next */
        if (_temp168 instanceof AbruptCompletion) return _temp168;
        /* node:coverage ignore next */
        if (_temp168 instanceof Completion) _temp168 = _temp168.Value;
      } else {
        /* ReturnIfAbrupt */
        let _temp169 = yield* DeletePropertyOrThrow(O, to);
        /* node:coverage ignore next */
        if (_temp169 instanceof AbruptCompletion) return _temp169;
        /* node:coverage ignore next */
        if (_temp169 instanceof Completion) _temp169 = _temp169.Value;
      }
      k -= 1;
    }
    let j = 0;
    const items = [...args];
    while (items.length !== 0) {
      const E = items.shift();
      /* X */
      let _temp170 = ToString(F(j));
      /* node:coverage ignore next */
      if (_temp170 && typeof _temp170 === 'object' && 'next' in _temp170) _temp170 = skipDebugger(_temp170);
      /* node:coverage ignore next */
      if (_temp170 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(j)) returned an abrupt completion", {
        cause: _temp170
      });
      /* node:coverage ignore next */
      if (_temp170 instanceof Completion) _temp170 = _temp170.Value;
      const jStr = _temp170;
      /* ReturnIfAbrupt */
      let _temp171 = yield* Set$1(O, jStr, E, Value.true);
      /* node:coverage ignore next */
      if (_temp171 instanceof AbruptCompletion) return _temp171;
      /* node:coverage ignore next */
      if (_temp171 instanceof Completion) _temp171 = _temp171.Value;
      j += 1;
    }
  }
  /* ReturnIfAbrupt */
  let _temp172 = yield* Set$1(O, Value('length'), F(len + argCount), Value.true);
  /* node:coverage ignore next */
  if (_temp172 instanceof AbruptCompletion) return _temp172;
  /* node:coverage ignore next */
  if (_temp172 instanceof Completion) _temp172 = _temp172.Value;
  return F(len + argCount);
}
ArrayProto_unshift.section = 'https://tc39.es/ecma262/#sec-array.prototype.unshift';
/** https://tc39.es/ecma262/#sec-array.prototype.values */
function ArrayProto_values(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp173 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp173 && typeof _temp173 === 'object' && 'next' in _temp173) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp173 instanceof AbruptCompletion) return _temp173;
  /* node:coverage ignore next */
  if (_temp173 instanceof Completion) _temp173 = _temp173.Value;
  const O = _temp173;
  return CreateArrayIterator(O, 'value');
}
ArrayProto_values.section = 'https://tc39.es/ecma262/#sec-array.prototype.values';
/** https://tc39.es/ecma262/#sec-array.prototype.at */
function* ArrayProto_at([index = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp174 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp174 && typeof _temp174 === 'object' && 'next' in _temp174) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp174 instanceof AbruptCompletion) return _temp174;
  /* node:coverage ignore next */
  if (_temp174 instanceof Completion) _temp174 = _temp174.Value;
  // 1. Let O be ? ToObject(this value).
  const O = _temp174;
  // 2. Let len be ? LengthOfArrayLike(O).
  /* ReturnIfAbrupt */
  let _temp175 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp175 instanceof AbruptCompletion) return _temp175;
  /* node:coverage ignore next */
  if (_temp175 instanceof Completion) _temp175 = _temp175.Value;
  const len = _temp175;
  // 3. Let relativeIndex be ? ToIntegerOrInfinity(index).
  /* ReturnIfAbrupt */
  let _temp176 = yield* ToIntegerOrInfinity(index);
  /* node:coverage ignore next */
  if (_temp176 instanceof AbruptCompletion) return _temp176;
  /* node:coverage ignore next */
  if (_temp176 instanceof Completion) _temp176 = _temp176.Value;
  const relativeIndex = _temp176;
  let k;
  // 4. If relativeIndex ≥ 0, then
  if (relativeIndex >= 0) {
    // a. Let k be relativeIndex.
    k = relativeIndex;
  } else {
    // 5. Else,
    // a. Let k be len + relativeIndex.
    k = len + relativeIndex;
  }
  // 6. If k < 0 or k ≥ len, then return undefined.
  if (k < 0 || k >= len) {
    return Value.undefined;
  }
  // 7. Return ? Get(O, ! ToString(k)).
  /* X */
  let _temp177 = ToString(F(k));
  /* node:coverage ignore next */
  if (_temp177 && typeof _temp177 === 'object' && 'next' in _temp177) _temp177 = skipDebugger(_temp177);
  /* node:coverage ignore next */
  if (_temp177 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
    cause: _temp177
  });
  /* node:coverage ignore next */
  if (_temp177 instanceof Completion) _temp177 = _temp177.Value;
  return yield* Get(O, _temp177);
}
ArrayProto_at.section = 'https://tc39.es/ecma262/#sec-array.prototype.at';
/** https://tc39.es/ecma262/#sec-array.prototype.toreversed */
function* ArrayProto_toReversed(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp178 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp178 && typeof _temp178 === 'object' && 'next' in _temp178) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp178 instanceof AbruptCompletion) return _temp178;
  /* node:coverage ignore next */
  if (_temp178 instanceof Completion) _temp178 = _temp178.Value;
  const O = _temp178;
  /* ReturnIfAbrupt */
  let _temp179 = yield* LengthOfArrayLike(O);
  /* node:coverage ignore next */
  if (_temp179 instanceof AbruptCompletion) return _temp179;
  /* node:coverage ignore next */
  if (_temp179 instanceof Completion) _temp179 = _temp179.Value;
  const len = _temp179;
  /* ReturnIfAbrupt */
  let _temp180 = ArrayCreate(len);
  /* node:coverage ignore next */
  if (_temp180 && typeof _temp180 === 'object' && 'next' in _temp180) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp180 instanceof AbruptCompletion) return _temp180;
  /* node:coverage ignore next */
  if (_temp180 instanceof Completion) _temp180 = _temp180.Value;
  const A = _temp180;
  let k = 0;
  while (k < len) {
    /* X */
    let _temp181 = ToString(F(len - 1 - k));
    /* node:coverage ignore next */
    if (_temp181 && typeof _temp181 === 'object' && 'next' in _temp181) _temp181 = skipDebugger(_temp181);
    /* node:coverage ignore next */
    if (_temp181 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(len - 1 - k)) returned an abrupt completion", {
      cause: _temp181
    });
    /* node:coverage ignore next */
    if (_temp181 instanceof Completion) _temp181 = _temp181.Value;
    const from = _temp181;
    /* X */
    let _temp182 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp182 && typeof _temp182 === 'object' && 'next' in _temp182) _temp182 = skipDebugger(_temp182);
    /* node:coverage ignore next */
    if (_temp182 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp182
    });
    /* node:coverage ignore next */
    if (_temp182 instanceof Completion) _temp182 = _temp182.Value;
    const Pk = _temp182;
    /* ReturnIfAbrupt */
    let _temp183 = yield* Get(O, from);
    /* node:coverage ignore next */
    if (_temp183 instanceof AbruptCompletion) return _temp183;
    /* node:coverage ignore next */
    if (_temp183 instanceof Completion) _temp183 = _temp183.Value;
    const fromValue = _temp183;
    /* X */
    let _temp184 = CreateDataPropertyOrThrow(A, Pk, fromValue);
    /* node:coverage ignore next */
    if (_temp184 && typeof _temp184 === 'object' && 'next' in _temp184) _temp184 = skipDebugger(_temp184);
    /* node:coverage ignore next */
    if (_temp184 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Pk, fromValue) returned an abrupt completion", {
      cause: _temp184
    });
    /* node:coverage ignore next */
    if (_temp184 instanceof Completion) _temp184 = _temp184.Value;
    k += 1;
  }
  return A;
}
ArrayProto_toReversed.section = 'https://tc39.es/ecma262/#sec-array.prototype.toreversed';
function bootstrapArrayPrototype(realmRec) {
  /* X */
  let _temp185 = ArrayCreate(0, realmRec.Intrinsics['%Object.prototype%']);
  /* node:coverage ignore next */
  if (_temp185 && typeof _temp185 === 'object' && 'next' in _temp185) _temp185 = skipDebugger(_temp185);
  /* node:coverage ignore next */
  if (_temp185 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0, realmRec.Intrinsics['%Object.prototype%']) returned an abrupt completion", {
    cause: _temp185
  });
  /* node:coverage ignore next */
  if (_temp185 instanceof Completion) _temp185 = _temp185.Value;
  const proto = _temp185;
  assignProps(realmRec, proto, [['concat', ArrayProto_concat, 1], ['copyWithin', ArrayProto_copyWithin, 2], ['entries', ArrayProto_entries, 0], ['fill', ArrayProto_fill, 1], ['filter', ArrayProto_filter, 1], ['flat', ArrayProto_flat, 0], ['flatMap', ArrayProto_flatMap, 1], ['at', ArrayProto_at, 1], ['keys', ArrayProto_keys, 0], ['map', ArrayProto_map, 1], ['pop', ArrayProto_pop, 0], ['push', ArrayProto_push, 1], ['shift', ArrayProto_shift, 0], ['slice', ArrayProto_slice, 2], ['sort', ArrayProto_sort, 1], ['toSorted', ArrayProto_toSorted, 1], ['splice', ArrayProto_splice, 2], ['toSpliced', ArrayProto_toSpliced, 2], ['toString', ArrayProto_toString, 0], ['unshift', ArrayProto_unshift, 1], ['values', ArrayProto_values, 0], ['with', ArrayProto_with, 2], ['toReversed', ArrayProto_toReversed, 0]]);
  bootstrapArrayPrototypeShared(realmRec, proto,
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {},
  // TODO: remove skipDebugger
  O => skipDebugger(LengthOfArrayLike(O)));
  /* X */
  let _temp205 = proto.GetOwnProperty(Value('values'));
  /* node:coverage ignore next */
  if (_temp205 && typeof _temp205 === 'object' && 'next' in _temp205) _temp205 = skipDebugger(_temp205);
  /* node:coverage ignore next */
  if (_temp205 instanceof AbruptCompletion) throw new Assert.Error("! proto.GetOwnProperty(Value('values')) returned an abrupt completion", {
    cause: _temp205
  });
  /* node:coverage ignore next */
  if (_temp205 instanceof Completion) _temp205 = _temp205.Value;
  /* X */
  let _temp186 = proto.DefineOwnProperty(wellKnownSymbols.iterator, _temp205);
  /* node:coverage ignore next */
  if (_temp186 && typeof _temp186 === 'object' && 'next' in _temp186) _temp186 = skipDebugger(_temp186);
  /* node:coverage ignore next */
  if (_temp186 instanceof AbruptCompletion) throw new Assert.Error("! proto.DefineOwnProperty(wellKnownSymbols.iterator, X(proto.GetOwnProperty(Value('values'))) as Descriptor) returned an abrupt completion", {
    cause: _temp186
  });
  /* node:coverage ignore next */
  if (_temp186 instanceof Completion) _temp186 = _temp186.Value;
  {
    const unscopableList = OrdinaryObjectCreate(Value.null);
    /* X */
    let _temp187 = CreateDataProperty(unscopableList, Value('at'), Value.true);
    /* node:coverage ignore next */
    if (_temp187 && typeof _temp187 === 'object' && 'next' in _temp187) _temp187 = skipDebugger(_temp187);
    /* node:coverage ignore next */
    if (_temp187 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('at'), Value.true) returned an abrupt completion", {
      cause: _temp187
    });
    /* node:coverage ignore next */
    if (_temp187 instanceof Completion) _temp187 = _temp187.Value;
    Assert(_temp187 === Value.true, "X(CreateDataProperty(unscopableList, Value('at'), Value.true)) === Value.true");
    /* X */
    let _temp188 = CreateDataProperty(unscopableList, Value('copyWithin'), Value.true);
    /* node:coverage ignore next */
    if (_temp188 && typeof _temp188 === 'object' && 'next' in _temp188) _temp188 = skipDebugger(_temp188);
    /* node:coverage ignore next */
    if (_temp188 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('copyWithin'), Value.true) returned an abrupt completion", {
      cause: _temp188
    });
    /* node:coverage ignore next */
    if (_temp188 instanceof Completion) _temp188 = _temp188.Value;
    Assert(_temp188 === Value.true, "X(CreateDataProperty(unscopableList, Value('copyWithin'), Value.true)) === Value.true");
    /* X */
    let _temp189 = CreateDataProperty(unscopableList, Value('entries'), Value.true);
    /* node:coverage ignore next */
    if (_temp189 && typeof _temp189 === 'object' && 'next' in _temp189) _temp189 = skipDebugger(_temp189);
    /* node:coverage ignore next */
    if (_temp189 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('entries'), Value.true) returned an abrupt completion", {
      cause: _temp189
    });
    /* node:coverage ignore next */
    if (_temp189 instanceof Completion) _temp189 = _temp189.Value;
    Assert(_temp189 === Value.true, "X(CreateDataProperty(unscopableList, Value('entries'), Value.true)) === Value.true");
    /* X */
    let _temp190 = CreateDataProperty(unscopableList, Value('fill'), Value.true);
    /* node:coverage ignore next */
    if (_temp190 && typeof _temp190 === 'object' && 'next' in _temp190) _temp190 = skipDebugger(_temp190);
    /* node:coverage ignore next */
    if (_temp190 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('fill'), Value.true) returned an abrupt completion", {
      cause: _temp190
    });
    /* node:coverage ignore next */
    if (_temp190 instanceof Completion) _temp190 = _temp190.Value;
    Assert(_temp190 === Value.true, "X(CreateDataProperty(unscopableList, Value('fill'), Value.true)) === Value.true");
    /* X */
    let _temp191 = CreateDataProperty(unscopableList, Value('find'), Value.true);
    /* node:coverage ignore next */
    if (_temp191 && typeof _temp191 === 'object' && 'next' in _temp191) _temp191 = skipDebugger(_temp191);
    /* node:coverage ignore next */
    if (_temp191 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('find'), Value.true) returned an abrupt completion", {
      cause: _temp191
    });
    /* node:coverage ignore next */
    if (_temp191 instanceof Completion) _temp191 = _temp191.Value;
    Assert(_temp191 === Value.true, "X(CreateDataProperty(unscopableList, Value('find'), Value.true)) === Value.true");
    /* X */
    let _temp192 = CreateDataProperty(unscopableList, Value('findIndex'), Value.true);
    /* node:coverage ignore next */
    if (_temp192 && typeof _temp192 === 'object' && 'next' in _temp192) _temp192 = skipDebugger(_temp192);
    /* node:coverage ignore next */
    if (_temp192 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('findIndex'), Value.true) returned an abrupt completion", {
      cause: _temp192
    });
    /* node:coverage ignore next */
    if (_temp192 instanceof Completion) _temp192 = _temp192.Value;
    Assert(_temp192 === Value.true, "X(CreateDataProperty(unscopableList, Value('findIndex'), Value.true)) === Value.true");
    /* X */
    let _temp193 = CreateDataProperty(unscopableList, Value('findLast'), Value.true);
    /* node:coverage ignore next */
    if (_temp193 && typeof _temp193 === 'object' && 'next' in _temp193) _temp193 = skipDebugger(_temp193);
    /* node:coverage ignore next */
    if (_temp193 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('findLast'), Value.true) returned an abrupt completion", {
      cause: _temp193
    });
    /* node:coverage ignore next */
    if (_temp193 instanceof Completion) _temp193 = _temp193.Value;
    Assert(_temp193 === Value.true, "X(CreateDataProperty(unscopableList, Value('findLast'), Value.true)) === Value.true");
    /* X */
    let _temp194 = CreateDataProperty(unscopableList, Value('findLastIndex'), Value.true);
    /* node:coverage ignore next */
    if (_temp194 && typeof _temp194 === 'object' && 'next' in _temp194) _temp194 = skipDebugger(_temp194);
    /* node:coverage ignore next */
    if (_temp194 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('findLastIndex'), Value.true) returned an abrupt completion", {
      cause: _temp194
    });
    /* node:coverage ignore next */
    if (_temp194 instanceof Completion) _temp194 = _temp194.Value;
    Assert(_temp194 === Value.true, "X(CreateDataProperty(unscopableList, Value('findLastIndex'), Value.true)) === Value.true");
    /* X */
    let _temp195 = CreateDataProperty(unscopableList, Value('flat'), Value.true);
    /* node:coverage ignore next */
    if (_temp195 && typeof _temp195 === 'object' && 'next' in _temp195) _temp195 = skipDebugger(_temp195);
    /* node:coverage ignore next */
    if (_temp195 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('flat'), Value.true) returned an abrupt completion", {
      cause: _temp195
    });
    /* node:coverage ignore next */
    if (_temp195 instanceof Completion) _temp195 = _temp195.Value;
    Assert(_temp195 === Value.true, "X(CreateDataProperty(unscopableList, Value('flat'), Value.true)) === Value.true");
    /* X */
    let _temp196 = CreateDataProperty(unscopableList, Value('flatMap'), Value.true);
    /* node:coverage ignore next */
    if (_temp196 && typeof _temp196 === 'object' && 'next' in _temp196) _temp196 = skipDebugger(_temp196);
    /* node:coverage ignore next */
    if (_temp196 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('flatMap'), Value.true) returned an abrupt completion", {
      cause: _temp196
    });
    /* node:coverage ignore next */
    if (_temp196 instanceof Completion) _temp196 = _temp196.Value;
    Assert(_temp196 === Value.true, "X(CreateDataProperty(unscopableList, Value('flatMap'), Value.true)) === Value.true");
    /* X */
    let _temp197 = CreateDataProperty(unscopableList, Value('includes'), Value.true);
    /* node:coverage ignore next */
    if (_temp197 && typeof _temp197 === 'object' && 'next' in _temp197) _temp197 = skipDebugger(_temp197);
    /* node:coverage ignore next */
    if (_temp197 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('includes'), Value.true) returned an abrupt completion", {
      cause: _temp197
    });
    /* node:coverage ignore next */
    if (_temp197 instanceof Completion) _temp197 = _temp197.Value;
    Assert(_temp197 === Value.true, "X(CreateDataProperty(unscopableList, Value('includes'), Value.true)) === Value.true");
    /* X */
    let _temp198 = CreateDataProperty(unscopableList, Value('keys'), Value.true);
    /* node:coverage ignore next */
    if (_temp198 && typeof _temp198 === 'object' && 'next' in _temp198) _temp198 = skipDebugger(_temp198);
    /* node:coverage ignore next */
    if (_temp198 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('keys'), Value.true) returned an abrupt completion", {
      cause: _temp198
    });
    /* node:coverage ignore next */
    if (_temp198 instanceof Completion) _temp198 = _temp198.Value;
    Assert(_temp198 === Value.true, "X(CreateDataProperty(unscopableList, Value('keys'), Value.true)) === Value.true");
    /* X */
    let _temp199 = CreateDataProperty(unscopableList, Value('toReversed'), Value.true);
    /* node:coverage ignore next */
    if (_temp199 && typeof _temp199 === 'object' && 'next' in _temp199) _temp199 = skipDebugger(_temp199);
    /* node:coverage ignore next */
    if (_temp199 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('toReversed'), Value.true) returned an abrupt completion", {
      cause: _temp199
    });
    /* node:coverage ignore next */
    if (_temp199 instanceof Completion) _temp199 = _temp199.Value;
    Assert(_temp199 === Value.true, "X(CreateDataProperty(unscopableList, Value('toReversed'), Value.true)) === Value.true");
    /* X */
    let _temp200 = CreateDataProperty(unscopableList, Value('toSorted'), Value.true);
    /* node:coverage ignore next */
    if (_temp200 && typeof _temp200 === 'object' && 'next' in _temp200) _temp200 = skipDebugger(_temp200);
    /* node:coverage ignore next */
    if (_temp200 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('toSorted'), Value.true) returned an abrupt completion", {
      cause: _temp200
    });
    /* node:coverage ignore next */
    if (_temp200 instanceof Completion) _temp200 = _temp200.Value;
    Assert(_temp200 === Value.true, "X(CreateDataProperty(unscopableList, Value('toSorted'), Value.true)) === Value.true");
    /* X */
    let _temp201 = CreateDataProperty(unscopableList, Value('toSpliced'), Value.true);
    /* node:coverage ignore next */
    if (_temp201 && typeof _temp201 === 'object' && 'next' in _temp201) _temp201 = skipDebugger(_temp201);
    /* node:coverage ignore next */
    if (_temp201 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('toSpliced'), Value.true) returned an abrupt completion", {
      cause: _temp201
    });
    /* node:coverage ignore next */
    if (_temp201 instanceof Completion) _temp201 = _temp201.Value;
    Assert(_temp201 === Value.true, "X(CreateDataProperty(unscopableList, Value('toSpliced'), Value.true)) === Value.true");
    /* X */
    let _temp202 = CreateDataProperty(unscopableList, Value('values'), Value.true);
    /* node:coverage ignore next */
    if (_temp202 && typeof _temp202 === 'object' && 'next' in _temp202) _temp202 = skipDebugger(_temp202);
    /* node:coverage ignore next */
    if (_temp202 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(unscopableList, Value('values'), Value.true) returned an abrupt completion", {
      cause: _temp202
    });
    /* node:coverage ignore next */
    if (_temp202 instanceof Completion) _temp202 = _temp202.Value;
    Assert(_temp202 === Value.true, "X(CreateDataProperty(unscopableList, Value('values'), Value.true)) === Value.true");
    /* X */
    let _temp203 = proto.DefineOwnProperty(wellKnownSymbols.unscopables, _Descriptor({
      Value: unscopableList,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    /* node:coverage ignore next */
    if (_temp203 && typeof _temp203 === 'object' && 'next' in _temp203) _temp203 = skipDebugger(_temp203);
    /* node:coverage ignore next */
    if (_temp203 instanceof AbruptCompletion) throw new Assert.Error("! proto.DefineOwnProperty(wellKnownSymbols.unscopables, Descriptor({\n      Value: unscopableList,\n      Writable: Value.false,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    })) returned an abrupt completion", {
      cause: _temp203
    });
    /* node:coverage ignore next */
    if (_temp203 instanceof Completion) _temp203 = _temp203.Value;
  }

  // Used in `arguments` objects.
  /* X */
  let _temp204 = Get(proto, Value('values'));
  /* node:coverage ignore next */
  if (_temp204 && typeof _temp204 === 'object' && 'next' in _temp204) _temp204 = skipDebugger(_temp204);
  /* node:coverage ignore next */
  if (_temp204 instanceof AbruptCompletion) throw new Assert.Error("! Get(proto, Value('values')) returned an abrupt completion", {
    cause: _temp204
  });
  /* node:coverage ignore next */
  if (_temp204 instanceof Completion) _temp204 = _temp204.Value;
  realmRec.Intrinsics['%Array.prototype.values%'] = _temp204;
  realmRec.Intrinsics['%Array.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-array-constructor */
function* ArrayConstructor(argumentsList, {
  NewTarget
}) {
  const numberOfArgs = argumentsList.length;
  if (numberOfArgs === 0) {
    /** https://tc39.es/ecma262/#sec-array-constructor-array */
    Assert(numberOfArgs === 0, "numberOfArgs === 0");
    if (NewTarget instanceof UndefinedValue) {
      NewTarget = surroundingAgent.activeFunctionObject;
    }
    /* X */
    let _temp = GetPrototypeFromConstructor(NewTarget, '%Array.prototype%');
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! GetPrototypeFromConstructor(NewTarget, '%Array.prototype%') returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const proto = _temp;
    return ArrayCreate(0, proto);
  } else if (numberOfArgs === 1) {
    /** https://tc39.es/ecma262/#sec-array-len */
    const [len] = argumentsList;
    Assert(numberOfArgs === 1, "numberOfArgs === 1");
    if (NewTarget instanceof UndefinedValue) {
      NewTarget = surroundingAgent.activeFunctionObject;
    }
    /* X */
    let _temp2 = GetPrototypeFromConstructor(NewTarget, '%Array.prototype%');
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! GetPrototypeFromConstructor(NewTarget, '%Array.prototype%') returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const proto = _temp2;
    /* X */
    let _temp3 = ArrayCreate(0, proto);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0, proto) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    const array = _temp3;
    let intLen;
    if (!(len instanceof NumberValue)) {
      /* X */
      let _temp4 = CreateDataProperty(array, Value('0'), len);
      /* node:coverage ignore next */
      if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(array, Value('0'), len) returned an abrupt completion", {
        cause: _temp4
      });
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      const defineStatus = _temp4;
      Assert(defineStatus === Value.true, "defineStatus === Value.true");
      intLen = F(1);
    } else {
      /* X */
      let _temp5 = ToUint32(len);
      /* node:coverage ignore next */
      if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! ToUint32(len) returned an abrupt completion", {
        cause: _temp5
      });
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      intLen = _temp5;
      if (R(intLen) !== R(len)) {
        return surroundingAgent.Throw('RangeError', 'InvalidArrayLength', len);
      }
    }
    yield* Set$1(array, Value('length'), intLen, Value.true);
    return array;
  } else if (numberOfArgs >= 2) {
    /** https://tc39.es/ecma262/#sec-array-items */
    const items = argumentsList;
    Assert(numberOfArgs >= 2, "numberOfArgs >= 2");
    if (NewTarget instanceof UndefinedValue) {
      NewTarget = surroundingAgent.activeFunctionObject;
    }
    /* ReturnIfAbrupt */
    let _temp6 = yield* GetPrototypeFromConstructor(NewTarget, '%Array.prototype%');
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    const proto = _temp6;
    /* X */
    let _temp7 = ArrayCreate(0, proto);
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0, proto) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const array = _temp7;
    let k = 0;
    while (k < numberOfArgs) {
      /* X */
      let _temp8 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp8
      });
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
      const Pk = _temp8;
      const itemK = items[k];
      /* X */
      let _temp9 = CreateDataProperty(array, Pk, itemK);
      /* node:coverage ignore next */
      if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
      /* node:coverage ignore next */
      if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(array, Pk, itemK) returned an abrupt completion", {
        cause: _temp9
      });
      /* node:coverage ignore next */
      if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
      const defineStatus = _temp9;
      Assert(defineStatus === Value.true, "defineStatus === Value.true");
      k += 1;
    }
    /* X */
    let _temp10 = Get(array, Value('length'));
    /* node:coverage ignore next */
    if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! Get(array, Value('length')) returned an abrupt completion", {
      cause: _temp10
    });
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    Assert(R(_temp10) === numberOfArgs, "R(X(Get(array, Value('length'))) as NumberValue) === numberOfArgs");
    return array;
  }
  /* node:coverage ignore next */
  throw new OutOfRange$1('ArrayConstructor', numberOfArgs);
}
ArrayConstructor.section = 'https://tc39.es/ecma262/#sec-array-constructor';
/** https://tc39.es/ecma262/#sec-array.from */
function* Array_from([items = Value.undefined, mapper = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  const C = thisValue;
  let mapping;
  let A;
  if (mapper === Value.undefined) {
    mapping = false;
  } else {
    if (!IsCallable(mapper)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', mapper);
    }
    mapping = true;
  }
  /* ReturnIfAbrupt */
  let _temp11 = yield* GetMethod(items, wellKnownSymbols.iterator);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const usingIterator = _temp11;
  if (!(usingIterator instanceof UndefinedValue)) {
    if (IsConstructor(C)) {
      /* ReturnIfAbrupt */
      let _temp12 = yield* Construct(C);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) return _temp12;
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
      A = _temp12;
    } else {
      /* X */
      let _temp13 = ArrayCreate(0);
      /* node:coverage ignore next */
      if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
        cause: _temp13
      });
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      A = _temp13;
    }
    /* ReturnIfAbrupt */
    let _temp14 = yield* GetIteratorFromMethod(items, usingIterator);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) return _temp14;
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    const iteratorRecord = _temp14;
    let k = 0;
    while (true) {
      // eslint-disable-line no-constant-condition
      if (k >= 2 ** 53 - 1) {
        const error = ThrowCompletion(surroundingAgent.Throw('TypeError', 'ArrayPastSafeLength').Value);
        return yield* IteratorClose(iteratorRecord, error);
      }
      /* X */
      let _temp15 = ToString(F(k));
      /* node:coverage ignore next */
      if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
      /* node:coverage ignore next */
      if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
        cause: _temp15
      });
      /* node:coverage ignore next */
      if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
      const Pk = _temp15;
      /* ReturnIfAbrupt */
      let _temp16 = yield* IteratorStepValue(iteratorRecord);
      /* node:coverage ignore next */
      if (_temp16 instanceof AbruptCompletion) return _temp16;
      /* node:coverage ignore next */
      if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
      const next = _temp16;
      if (next === 'done') {
        /* ReturnIfAbrupt */
        let _temp17 = yield* Set$1(A, Value('length'), F(k), Value.true);
        /* node:coverage ignore next */
        if (_temp17 instanceof AbruptCompletion) return _temp17;
        /* node:coverage ignore next */
        if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
        return A;
      }
      let mappedValue;
      if (mapping) {
        mappedValue = yield* Call(mapper, thisArg, [next, F(k)]);
        /* IfAbruptCloseIterator */
        /* node:coverage ignore next */
        if (mappedValue instanceof AbruptCompletion) return skipDebugger(IteratorClose(iteratorRecord, mappedValue));
        /* node:coverage ignore next */
        if (mappedValue instanceof Completion) mappedValue = mappedValue.Value;
      } else {
        mappedValue = next;
      }
      let defineStatus = yield* CreateDataPropertyOrThrow(A, Pk, mappedValue);
      /* IfAbruptCloseIterator */
      /* node:coverage ignore next */
      if (defineStatus instanceof AbruptCompletion) return skipDebugger(IteratorClose(iteratorRecord, defineStatus));
      /* node:coverage ignore next */
      if (defineStatus instanceof Completion) defineStatus = defineStatus.Value;
      k += 1;
    }
  }
  /* X */
  let _temp18 = ToObject(items);
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! ToObject(items) returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  const arrayLike = _temp18;
  /* ReturnIfAbrupt */
  let _temp19 = yield* LengthOfArrayLike(arrayLike);
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) return _temp19;
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  const len = _temp19;
  if (IsConstructor(C)) {
    /* ReturnIfAbrupt */
    let _temp20 = yield* Construct(C, [F(len)]);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    A = _temp20;
  } else {
    /* ReturnIfAbrupt */
    let _temp21 = ArrayCreate(len);
    /* node:coverage ignore next */
    if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) return _temp21;
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    A = _temp21;
  }
  let k = 0;
  while (k < len) {
    /* X */
    let _temp22 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) _temp22 = skipDebugger(_temp22);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp22
    });
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    const Pk = _temp22;
    /* ReturnIfAbrupt */
    let _temp23 = yield* Get(arrayLike, Pk);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    const kValue = _temp23;
    let mappedValue;
    if (mapping === true) {
      /* ReturnIfAbrupt */
      let _temp24 = yield* Call(mapper, thisArg, [kValue, F(k)]);
      /* node:coverage ignore next */
      if (_temp24 instanceof AbruptCompletion) return _temp24;
      /* node:coverage ignore next */
      if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
      mappedValue = _temp24;
    } else {
      mappedValue = kValue;
    }
    /* ReturnIfAbrupt */
    let _temp25 = yield* CreateDataPropertyOrThrow(A, Pk, mappedValue);
    /* node:coverage ignore next */
    if (_temp25 instanceof AbruptCompletion) return _temp25;
    /* node:coverage ignore next */
    if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
    k += 1;
  }
  /* ReturnIfAbrupt */
  let _temp26 = yield* Set$1(A, Value('length'), F(len), Value.true);
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  return A;
}
Array_from.section = 'https://tc39.es/ecma262/#sec-array.from';
/** https://tc39.es/ecma262/#sec-array.isarray */
function Array_isArray([arg = Value.undefined]) {
  return IsArray(arg);
}
Array_isArray.section = 'https://tc39.es/ecma262/#sec-array.isarray';
/** https://tc39.es/ecma262/#sec-array.of */
function* Array_of(items, {
  thisValue
}) {
  const len = items.length;
  // Let items be the List of arguments passed to this function.
  const C = thisValue;
  let A;
  if (IsConstructor(C)) {
    /* ReturnIfAbrupt */
    let _temp27 = yield* Construct(C, [F(len)]);
    /* node:coverage ignore next */
    if (_temp27 instanceof AbruptCompletion) return _temp27;
    /* node:coverage ignore next */
    if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
    A = _temp27;
  } else {
    /* ReturnIfAbrupt */
    let _temp28 = ArrayCreate(len);
    /* node:coverage ignore next */
    if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) return _temp28;
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    A = _temp28;
  }
  let k = 0;
  while (k < len) {
    const kValue = items[k];
    /* X */
    let _temp29 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) _temp29 = skipDebugger(_temp29);
    /* node:coverage ignore next */
    if (_temp29 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp29
    });
    /* node:coverage ignore next */
    if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
    const Pk = _temp29;
    /* ReturnIfAbrupt */
    let _temp30 = yield* CreateDataPropertyOrThrow(A, Pk, kValue);
    /* node:coverage ignore next */
    if (_temp30 instanceof AbruptCompletion) return _temp30;
    /* node:coverage ignore next */
    if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
    k += 1;
  }
  /* ReturnIfAbrupt */
  let _temp31 = yield* Set$1(A, Value('length'), F(len), Value.true);
  /* node:coverage ignore next */
  if (_temp31 instanceof AbruptCompletion) return _temp31;
  /* node:coverage ignore next */
  if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
  return A;
}
Array_of.section = 'https://tc39.es/ecma262/#sec-array.of';
/** https://tc39.es/ecma262/#sec-get-array-@@species */
function Array_speciesGetter(_args, {
  thisValue
}) {
  return thisValue;
}
Array_speciesGetter.section = 'https://tc39.es/ecma262/#sec-get-array-@@species';
function bootstrapArray(realmRec) {
  const proto = realmRec.Intrinsics['%Array.prototype%'];
  const cons = bootstrapConstructor(realmRec, ArrayConstructor, 'Array', 1, proto, [['from', Array_from, 1], ['isArray', Array_isArray, 1], ['of', Array_of, 0], [wellKnownSymbols.species, [Array_speciesGetter]]]);
  realmRec.Intrinsics['%Array%'] = cons;
}

function isBigIntObject(o) {
  return 'BigIntData' in o;
}
/** https://tc39.es/ecma262/#sec-bigint-constructor */
function* BigIntConstructor([value], {
  NewTarget
}) {
  // 1. If NewTarget is not undefined, throw a TypeError exception.
  if (NewTarget !== Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', 'BigInt');
  }
  // 2. Let prim be ? ToPrimitive(value, number).
  /* ReturnIfAbrupt */
  let _temp = yield* ToPrimitive(value, 'number');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const prim = _temp;
  // 3. If Type(prim) is Number, return ? NumberToBigInt(prim).
  // 4. Otherwise, return ? ToBigInt(prim).
  if (prim instanceof NumberValue) {
    return NumberToBigInt(prim);
  } else {
    return yield* ToBigInt(prim);
  }
}
BigIntConstructor.section = 'https://tc39.es/ecma262/#sec-bigint-constructor';
/** https://tc39.es/ecma262/#sec-bigint.asintn */
function* BigInt_asIntN([_bits = Value.undefined, _bigint = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToIndex(_bits);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Set bits to ? ToIndex(bits).
  const bits = _temp2;
  // 2. Set bigint to ? ToBigInt(bigint).
  /* ReturnIfAbrupt */
  let _temp3 = yield* ToBigInt(_bigint);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const bigint = _temp3;
  // 3. Let mod be the BigInt value that represents bigint modulo 2bits.
  // 4. If mod ≥ 2^bits - 1, return mod - 2^bits; otherwise, return mod.
  return Z(BigInt.asIntN(bits, R(bigint)));
}
BigInt_asIntN.section = 'https://tc39.es/ecma262/#sec-bigint.asintn';
/** https://tc39.es/ecma262/#sec-bigint.asuintn */
function* BigInt_asUintN([_bits = Value.undefined, _bigint = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp4 = yield* ToIndex(_bits);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 1. Set bits to ? ToIndex(bits).
  const bits = _temp4;
  // 2. Set bigint to ? ToBigInt(bigint).
  /* ReturnIfAbrupt */
  let _temp5 = yield* ToBigInt(_bigint);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const bigint = _temp5;
  // 3. Let mod be ℝ(bigint) modulo 2 ** bits.
  // 4. If mod ≥ 2 ** (bits - 1), return Z(mod - 2 ** bits); otherwise, return Z(mod).
  return Z(BigInt.asUintN(bits, R(bigint)));
}
BigInt_asUintN.section = 'https://tc39.es/ecma262/#sec-bigint.asuintn';
function bootstrapBigInt(realmRec) {
  const bigintConstructor = bootstrapConstructor(realmRec, BigIntConstructor, 'BigInt', 1, realmRec.Intrinsics['%BigInt.prototype%'], [['asIntN', BigInt_asIntN, 2], ['asUintN', BigInt_asUintN, 2]]);
  realmRec.Intrinsics['%BigInt%'] = bigintConstructor;
}

/** https://tc39.es/ecma262/#sec-thisbigintvalue */
function thisBigIntValue(value) {
  // 1. If Type(value) is BigInt, return value.
  if (value instanceof BigIntValue) {
    return value;
  }
  // 2. If Type(value) is Object and value has a [[BigIntData]] internal slot, then
  if (value instanceof ObjectValue && 'BigIntData' in value) {
    // a. Assert: Type(value.[[BigIntData]]) is BigInt.
    Assert(value.BigIntData instanceof BigIntValue, "value.BigIntData instanceof BigIntValue");
    // b. Return value.[[BigIntData]].
    return value.BigIntData;
  }
  // 3. Throw a TypeError exception.
  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'BigInt', value);
}
thisBigIntValue.section = 'https://tc39.es/ecma262/#sec-thisbigintvalue';
/** https://tc39.es/ecma262/#sec-bigint.prototype.tolocalestring */
function BigIntProto_toLocalString(args, context) {
  return BigIntProto_toString(args, context);
}
BigIntProto_toLocalString.section = 'https://tc39.es/ecma262/#sec-bigint.prototype.tolocalestring';
/** https://tc39.es/ecma262/#sec-bigint.prototype.tostring */
function* BigIntProto_toString([radix], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp = thisBigIntValue(thisValue);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let x be ? thisBigIntValue(this value).
  const x = _temp;
  // 2. If radix is not present, let radixNumber be 10.
  let radixNumber;
  if (radix === undefined) {
    radixNumber = 10;
  } else if (radix === Value.undefined) {
    // 3. Else if radix is undefined, let radixNumber be 10.
    radixNumber = 10;
  } else {
    /* ReturnIfAbrupt */
    let _temp2 = yield* ToIntegerOrInfinity(radix);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // 4. Else, let radixNumber be ? ToIntegerOrInfinity(radix).
    radixNumber = _temp2;
  }
  // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.
  if (radixNumber < 2 || radixNumber > 36) {
    return surroundingAgent.Throw('RangeError', 'InvalidRadix');
  }
  // 6. If radixNumber = 10, return ! ToString(x).
  if (radixNumber === 10) {
    /* X */
    let _temp3 = ToString(x);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToString(x) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    return _temp3;
  }
  // 7. Return the String representation of this Number value using the radix specified by
  //    radixNumber. Letters a-z are used for digits with values 10 through 35. The precise
  //    algorithm is implementation-dependent, however the algorithm should be a
  //    generalization of that specified in 6.1.6.2.23.
  // TODO: Implementation stringification
  return Value(R(x).toString(radixNumber));
}
BigIntProto_toString.section = 'https://tc39.es/ecma262/#sec-bigint.prototype.tostring';
/** https://tc39.es/ecma262/#sec-bigint.prototype.tostring */
function BigIntProto_valueOf(_args, {
  thisValue
}) {
  // Return ? thisBigIntValue(this value).
  return thisBigIntValue(thisValue);
}
BigIntProto_valueOf.section = 'https://tc39.es/ecma262/#sec-bigint.prototype.tostring';
function bootstrapBigIntPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['toLocaleString', BigIntProto_toLocalString, 0], ['toString', BigIntProto_toString, 0], ['valueOf', BigIntProto_valueOf, 0]], realmRec.Intrinsics['%Object.prototype%'], 'BigInt');
  realmRec.Intrinsics['%BigInt.prototype%'] = proto;
}

function thisBooleanValue(value) {
  if (value instanceof BooleanValue) {
    return value;
  }
  if (value instanceof ObjectValue && 'BooleanData' in value) {
    const b = value.BooleanData;
    Assert(b instanceof BooleanValue, "b instanceof BooleanValue");
    return b;
  }
  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Boolean', value);
}

/** https://tc39.es/ecma262/#sec-boolean.prototype.tostring */
function BooleanProto_toString(_argList, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp = thisBooleanValue(thisValue);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let b be ? thisBooleanValue(this value).
  const b = _temp;
  // 2. If b is true, return "true"; else return "false".
  if (b === Value.true) {
    return Value('true');
  }
  return Value('false');
}
BooleanProto_toString.section = 'https://tc39.es/ecma262/#sec-boolean.prototype.tostring';
/** https://tc39.es/ecma262/#sec-boolean.prototype.valueof */
function BooleanProto_valueOf(_argList, {
  thisValue
}) {
  // 1. Return ? thisBooleanValue(this value).
  return thisBooleanValue(thisValue);
}
BooleanProto_valueOf.section = 'https://tc39.es/ecma262/#sec-boolean.prototype.valueof';
function bootstrapBooleanPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['toString', BooleanProto_toString, 0], ['valueOf', BooleanProto_valueOf, 0]], realmRec.Intrinsics['%Object.prototype%']);
  proto.BooleanData = Value.false;
  realmRec.Intrinsics['%Boolean.prototype%'] = proto;
}

function isBooleanObject(o) {
  return 'BooleanData' in o;
}
/** https://tc39.es/ecma262/#sec-boolean-constructor-boolean-value */
function* BooleanConstructor([value = Value.undefined], {
  NewTarget
}) {
  /* X */
  let _temp = ToBoolean(value);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! ToBoolean(value) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let b be ! ToBoolean(value).
  const b = _temp;
  // 2. If NewTarget is undefined, return b.
  if (NewTarget instanceof UndefinedValue) {
    return b;
  }
  // 3. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%Boolean.prototype%", « [[BooleanData]] »).
  /* ReturnIfAbrupt */
  let _temp2 = yield* OrdinaryCreateFromConstructor(NewTarget, '%Boolean.prototype%', ['BooleanData']);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const O = _temp2;
  // 4. Set O.[[BooleanData]] to b.
  O.BooleanData = b;
  // 5. Return O.
  return O;
}
BooleanConstructor.section = 'https://tc39.es/ecma262/#sec-boolean-constructor-boolean-value';
function bootstrapBoolean(realmRec) {
  const cons = bootstrapConstructor(realmRec, BooleanConstructor, 'Boolean', 1, realmRec.Intrinsics['%Boolean.prototype%'], []);
  realmRec.Intrinsics['%Boolean%'] = cons;
}

function thisNumberValue(value) {
  if (value instanceof NumberValue) {
    return value;
  }
  if (value instanceof ObjectValue && 'NumberData' in value) {
    const n = value.NumberData;
    Assert(n instanceof NumberValue, "n instanceof NumberValue");
    return n;
  }
  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Number', value);
}

/** https://tc39.es/ecma262/#sec-number.prototype.toexponential */
function* NumberProto_toExponential([fractionDigits = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp = thisNumberValue(thisValue);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const x = _temp;
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToIntegerOrInfinity(fractionDigits);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const f = _temp2;
  Assert(fractionDigits !== Value.undefined || f === 0, "fractionDigits !== Value.undefined || f === 0");
  if (!x.isFinite()) {
    return NumberValue.toString(x, 10);
  }
  if (f < 0 || f > 100) {
    return surroundingAgent.Throw('RangeError', 'NumberFormatRange', 'toExponential');
  }
  return Value(R(x).toExponential(fractionDigits === Value.undefined ? undefined : f));
}
NumberProto_toExponential.section = 'https://tc39.es/ecma262/#sec-number.prototype.toexponential';
/** https://tc39.es/ecma262/#sec-number.prototype.tofixed */
function* NumberProto_toFixed([fractionDigits = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp3 = thisNumberValue(thisValue);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const x = _temp3;
  /* ReturnIfAbrupt */
  let _temp4 = yield* ToIntegerOrInfinity(fractionDigits);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const f = _temp4;
  Assert(fractionDigits !== Value.undefined || f === 0, "fractionDigits !== Value.undefined || f === 0");
  if (f < 0 || f > 100) {
    return surroundingAgent.Throw('RangeError', 'NumberFormatRange', 'toFixed');
  }
  if (!x.isFinite()) {
    /* X */
    let _temp5 = NumberValue.toString(x, 10);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! NumberValue.toString(x, 10) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    return _temp5;
  }
  return Value(R(x).toFixed(f));
}
NumberProto_toFixed.section = 'https://tc39.es/ecma262/#sec-number.prototype.tofixed';
/** https://tc39.es/ecma262/#sec-number.prototype.tolocalestring */
function NumberProto_toLocaleString(_args, context) {
  return NumberProto_toString([], context);
}
NumberProto_toLocaleString.section = 'https://tc39.es/ecma262/#sec-number.prototype.tolocalestring';
/** https://tc39.es/ecma262/#sec-number.prototype.toprecision */
function* NumberProto_toPrecision([precision = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp6 = thisNumberValue(thisValue);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const x = _temp6;
  if (precision === Value.undefined) {
    /* X */
    let _temp7 = ToString(x);
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! ToString(x) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    return _temp7;
  }
  /* ReturnIfAbrupt */
  let _temp8 = yield* ToIntegerOrInfinity(precision);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const p = _temp8;
  if (!x.isFinite()) {
    /* X */
    let _temp9 = NumberValue.toString(x, 10);
    /* node:coverage ignore next */
    if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! NumberValue.toString(x, 10) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    return _temp9;
  }
  if (p < 1 || p > 100) {
    return surroundingAgent.Throw('RangeError', 'NumberFormatRange', 'toPrecision');
  }
  return Value(R(x).toPrecision(p));
}
NumberProto_toPrecision.section = 'https://tc39.es/ecma262/#sec-number.prototype.toprecision';
/** https://tc39.es/ecma262/#sec-number.prototype.tostring */
function* NumberProto_toString([radix = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp10 = thisNumberValue(thisValue);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const x = _temp10;
  let radixNumber;
  if (radix === Value.undefined) {
    radixNumber = 10;
  } else {
    /* ReturnIfAbrupt */
    let _temp11 = yield* ToIntegerOrInfinity(radix);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) return _temp11;
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    radixNumber = _temp11;
  }
  if (radixNumber < 2 || radixNumber > 36) {
    return surroundingAgent.Throw('RangeError', 'NumberFormatRange', 'toString');
  }
  if (radixNumber === 10) {
    /* X */
    let _temp12 = ToString(x);
    /* node:coverage ignore next */
    if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! ToString(x) returned an abrupt completion", {
      cause: _temp12
    });
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    return _temp12;
  }
  // FIXME(devsnek): Return the String representation of this Number
  // value using the radix specified by radixNumber. Letters a-z are
  // used for digits with values 10 through 35. The precise algorithm
  // is implementation-dependent, however the algorithm should be a
  // generalization of that specified in 7.1.12.1.
  return Value(R(x).toString(radixNumber));
}
NumberProto_toString.section = 'https://tc39.es/ecma262/#sec-number.prototype.tostring';
/** https://tc39.es/ecma262/#sec-number.prototype.valueof */
function NumberProto_valueOf(_args, {
  thisValue
}) {
  return thisNumberValue(thisValue);
}
NumberProto_valueOf.section = 'https://tc39.es/ecma262/#sec-number.prototype.valueof';
function bootstrapNumberPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['toExponential', NumberProto_toExponential, 1], ['toFixed', NumberProto_toFixed, 1], ['toLocaleString', NumberProto_toLocaleString, 0], ['toPrecision', NumberProto_toPrecision, 1], ['toString', NumberProto_toString, 1], ['valueOf', NumberProto_valueOf, 0]], realmRec.Intrinsics['%Object.prototype%']);
  proto.NumberData = F(0);
  realmRec.Intrinsics['%Number.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-number-constructor-number-value */
function* NumberConstructor([value], {
  NewTarget
}) {
  let n;
  if (value !== undefined) {
    /* ReturnIfAbrupt */
    let _temp = yield* ToNumeric(value);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const prim = _temp;
    if (prim instanceof BigIntValue) {
      n = F(Number(R(prim)));
    } else {
      n = prim;
    }
  } else {
    n = F(0);
  }
  if (NewTarget instanceof UndefinedValue) {
    return n;
  }
  const O = yield* OrdinaryCreateFromConstructor(NewTarget, '%Number.prototype%', ['NumberData']);
  O.NumberData = n;
  return O;
}
NumberConstructor.section = 'https://tc39.es/ecma262/#sec-number-constructor-number-value';
/** https://tc39.es/ecma262/#sec-number.isfinite */
function Number_isFinite([number = Value.undefined]) {
  if (!(number instanceof NumberValue)) {
    return Value.false;
  }
  if (number.isNaN() || number.isInfinity()) {
    return Value.false;
  }
  return Value.true;
}
Number_isFinite.section = 'https://tc39.es/ecma262/#sec-number.isfinite';
/** https://tc39.es/ecma262/#sec-number.isinteger */
function Number_isInteger([number = Value.undefined]) {
  /* X */
  let _temp2 = IsIntegralNumber(number);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! IsIntegralNumber(number) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  return _temp2;
}
Number_isInteger.section = 'https://tc39.es/ecma262/#sec-number.isinteger';
/** https://tc39.es/ecma262/#sec-number.isnan */
function Number_isNaN([number = Value.undefined]) {
  if (!(number instanceof NumberValue)) {
    return Value.false;
  }
  if (number.isNaN()) {
    return Value.true;
  }
  return Value.false;
}
Number_isNaN.section = 'https://tc39.es/ecma262/#sec-number.isnan';
/** https://tc39.es/ecma262/#sec-number.issafeinteger */
function Number_isSafeInteger([number = Value.undefined]) {
  if (!(number instanceof NumberValue)) {
    return Value.false;
  }
  /* X */
  let _temp3 = IsIntegralNumber(number);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! IsIntegralNumber(number) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  if (_temp3 === Value.true) {
    if (Math.abs(R(number)) <= 2 ** 53 - 1) {
      return Value.true;
    }
  }
  return Value.false;
}
Number_isSafeInteger.section = 'https://tc39.es/ecma262/#sec-number.issafeinteger';
function bootstrapNumber(realmRec) {
  const override = {
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  };
  const numberConstructor = bootstrapConstructor(realmRec, NumberConstructor, 'Number', 1, realmRec.Intrinsics['%Number.prototype%'], [['EPSILON', F(Number.EPSILON), undefined, override], ['MAX_SAFE_INTEGER', F(Number.MAX_SAFE_INTEGER), undefined, override], ['MAX_VALUE', F(Number.MAX_VALUE), undefined, override], ['MIN_SAFE_INTEGER', F(Number.MIN_SAFE_INTEGER), undefined, override], ['MIN_VALUE', F(Number.MIN_VALUE), undefined, override], ['NaN', F(NaN), undefined, override], ['NEGATIVE_INFINITY', F(-Infinity), undefined, override], ['POSITIVE_INFINITY', F(+Infinity), undefined, override], ['isFinite', Number_isFinite, 1], ['isInteger', Number_isInteger, 1], ['isNaN', Number_isNaN, 1], ['isSafeInteger', Number_isSafeInteger, 1]]);

  /** https://tc39.es/ecma262/#sec-number.parsefloat */
  // The value of the Number.parseFloat data property is the same built-in function object that is the value of the parseFloat property of the global object defined in 18.2.4.
  /* X */
  let _temp4 = numberConstructor.DefineOwnProperty(Value('parseFloat'), _Descriptor({
    Value: realmRec.Intrinsics['%parseFloat%'],
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! numberConstructor.DefineOwnProperty(Value('parseFloat'), Descriptor({\n    Value: realmRec.Intrinsics['%parseFloat%'],\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;

  /** https://tc39.es/ecma262/#sec-number.parseint */
  // The value of the Number.parseInt data property is the same built-in function object that is the value of the parseInt property of the global object defined in 18.2.5.
  /* X */
  let _temp5 = numberConstructor.DefineOwnProperty(Value('parseInt'), _Descriptor({
    Value: realmRec.Intrinsics['%parseInt%'],
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! numberConstructor.DefineOwnProperty(Value('parseInt'), Descriptor({\n    Value: realmRec.Intrinsics['%parseInt%'],\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  realmRec.Intrinsics['%Number%'] = numberConstructor;
}

/** https://tc39.es/ecma262/#sec-function-p1-p2-pn-body */
function* FunctionConstructor(args, {
  NewTarget
}) {
  // 1. Let C be the active function object.
  const C = surroundingAgent.activeFunctionObject;
  // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
  // 3. Return ? CreateDynamicFunction(C, NewTarget, normal, args).
  return yield* CreateDynamicFunction(C, NewTarget, 'normal', args);
}
FunctionConstructor.section = 'https://tc39.es/ecma262/#sec-function-p1-p2-pn-body';
function bootstrapFunction(realmRec) {
  const cons = bootstrapConstructor(realmRec, FunctionConstructor, 'Function', 1, realmRec.Intrinsics['%Function.prototype%'], []);
  realmRec.Intrinsics['%Function%'] = cons;
}

/** https://tc39.es/ecma262/#sec-thissymbolvalue */
function thisSymbolValue(value) {
  // 1. If Type(value) is Symbol, return value.
  if (value instanceof SymbolValue) {
    return value;
  }
  // 2. If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  if (value instanceof ObjectValue && 'SymbolData' in value) {
    // a. Let s be value.[[SymbolData]].
    const s = value.SymbolData;
    // b. Assert: Type(s) is Symbol.
    Assert(s instanceof SymbolValue, "s instanceof SymbolValue");
    // c. Return s.
    return s;
  }
  // 3. Throw a TypeError exception.
  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Symbol', value);
}
thisSymbolValue.section = 'https://tc39.es/ecma262/#sec-thissymbolvalue';
/** https://tc39.es/ecma262/#sec-symbol.prototype.description */
function SymbolProto_descriptionGetter(_argList, {
  thisValue
}) {
  // 1. Let s be the this value.
  const s = thisValue;
  // 2. Let sym be ? thisSymbolValue(s).
  /* ReturnIfAbrupt */
  let _temp = thisSymbolValue(s);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const sym = _temp;
  // 3. Return sym.[[Description]].
  return sym.Description;
}
SymbolProto_descriptionGetter.section = 'https://tc39.es/ecma262/#sec-symbol.prototype.description';
/** https://tc39.es/ecma262/#sec-symbol.prototype.tostring */
function SymbolProto_toString(_argList, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp2 = thisSymbolValue(thisValue);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Let sym be ? thisSymbolValue(this value).
  const sym = _temp2;
  // 2. Return SymbolDescriptiveString(sym).
  return SymbolDescriptiveString(sym);
}
SymbolProto_toString.section = 'https://tc39.es/ecma262/#sec-symbol.prototype.tostring';
/** https://tc39.es/ecma262/#sec-symbol.prototype.valueof */
function SymbolProto_valueOf(_argList, {
  thisValue
}) {
  // 1. Return ? thisSymbolValue(this value).
  return thisSymbolValue(thisValue);
}
SymbolProto_valueOf.section = 'https://tc39.es/ecma262/#sec-symbol.prototype.valueof';
/** https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive */
function SymbolProto_toPrimitive(_argList, {
  thisValue
}) {
  // 1. Return ? thisSymbolValue(this value).
  return thisSymbolValue(thisValue);
}
SymbolProto_toPrimitive.section = 'https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive';
function bootstrapSymbolPrototype(realmRec) {
  const override = {
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  };
  const proto = bootstrapPrototype(realmRec, [['toString', SymbolProto_toString, 0], ['description', [SymbolProto_descriptionGetter]], ['valueOf', SymbolProto_valueOf, 0], [wellKnownSymbols.toPrimitive, SymbolProto_toPrimitive, 1, override]], realmRec.Intrinsics['%Object.prototype%'], 'Symbol');
  realmRec.Intrinsics['%Symbol.prototype%'] = proto;
}

const GlobalSymbolRegistry = [];
/** https://tc39.es/ecma262/#sec-symbol-description */
function* SymbolConstructor([description = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is not undefined, throw a TypeError exception.
  if (NewTarget !== Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', this);
  }
  // 2. If description is undefined, let descString be undefined.
  let descString;
  if (description === Value.undefined) {
    descString = Value.undefined;
  } else {
    /* ReturnIfAbrupt */
    let _temp = yield* ToString(description);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // 3. Else, let descString be ? ToString(description).
    descString = _temp;
  }
  // 4. Return a new unique Symbol value whose [[Description]] value is descString.
  return new SymbolValue(descString);
}
SymbolConstructor.section = 'https://tc39.es/ecma262/#sec-symbol-description';
/** https://tc39.es/ecma262/#sec-symbol.for */
function* Symbol_for([key = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToString(key);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Let stringKey be ? ToString(key).
  const stringKey = _temp2;
  // 2. For each element e of the GlobalSymbolRegistry List, do
  for (const e of GlobalSymbolRegistry) {
    // a. If SameValue(e.[[Key]], stringKey) is true, return e.[[Symbol]].
    if (SameValue(e.Key, stringKey) === Value.true) {
      return e.Symbol;
    }
  }
  // 3. Assert: GlobalSymbolRegistry does not currently contain an entry for stringKey.
  // 4. Let newSymbol be a new unique Symbol value whose [[Description]] value is stringKey.
  const newSymbol = new SymbolValue(stringKey);
  // 5. Append the Record { [[Key]]: stringKey, [[Symbol]]: newSymbol } to the GlobalSymbolRegistry List.
  GlobalSymbolRegistry.push({
    Key: stringKey,
    Symbol: newSymbol
  });
  // 6. Return newSymbol.
  return newSymbol;
}
Symbol_for.section = 'https://tc39.es/ecma262/#sec-symbol.for';
/** https://tc39.es/ecma262/#sec-symbol.keyfor */
function Symbol_keyFor([sym = Value.undefined]) {
  // 1. If Type(sym) is not Symbol, throw a TypeError exception.
  if (!(sym instanceof SymbolValue)) {
    return surroundingAgent.Throw('TypeError', 'NotASymbol', sym);
  }
  // 2. Return KeyForSymbol(sym).
  return KeyForSymbol(sym);
}
Symbol_keyFor.section = 'https://tc39.es/ecma262/#sec-symbol.keyfor';
function bootstrapSymbol(realmRec) {
  const symbolConstructor = bootstrapConstructor(realmRec, SymbolConstructor, 'Symbol', 0, realmRec.Intrinsics['%Symbol.prototype%'], [['for', Symbol_for, 1], ['keyFor', Symbol_keyFor, 1]]);
  for (const [name, sym] of Object.entries(wellKnownSymbols)) {
    /* X */
    let _temp3 = symbolConstructor.DefineOwnProperty(Value(name), _Descriptor({
      Value: sym,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! symbolConstructor.DefineOwnProperty(Value(name), Descriptor({\n      Value: sym,\n      Writable: Value.false,\n      Enumerable: Value.false,\n      Configurable: Value.false,\n    })) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }
  /* X */
  let _temp4 = symbolConstructor.DefineOwnProperty(Value('prototype'), _Descriptor({
    Value: realmRec.Intrinsics['%Symbol.prototype%'],
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! symbolConstructor.DefineOwnProperty(Value('prototype'), Descriptor({\n    Value: realmRec.Intrinsics['%Symbol.prototype%'],\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  realmRec.Intrinsics['%Symbol%'] = symbolConstructor;
}

/** https://tc39.es/ecma262/#sec-math.abs */
function* Math_abs([x = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp = yield* ToNumber(x);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const n = _temp;
  if (n.isNaN()) {
    return n;
  } else if (Object.is(R(n), -0)) {
    return F(0);
  } else if (n.isInfinity()) {
    return F(Infinity);
  }
  if (R(n) < 0) {
    return F(-R(n));
  }
  return n;
}
Math_abs.section = 'https://tc39.es/ecma262/#sec-math.abs';
/** https://tc39.es/ecma262/#sec-math.acos */
function* Math_acos([x = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToNumber(x);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const n = _temp2;
  if (n.isNaN()) {
    return n;
  } else if (R(n) > 1) {
    return F(NaN);
  } else if (R(n) < -1) {
    return F(NaN);
  } else if (R(n) === 1) {
    return F(0);
  }
  return F(Math.acos(R(n)));
}
Math_acos.section = 'https://tc39.es/ecma262/#sec-math.acos';
/** https://tc39.es/ecma262/#sec-math.pow */
function* Math_pow([base = Value.undefined, exponent = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp3 = yield* ToNumber(base);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 1. Set base to ? ToNumber(base).
  base = _temp3;
  // 2. Set exponent to ? ToNumber(exponent).
  /* ReturnIfAbrupt */
  let _temp4 = yield* ToNumber(exponent);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  exponent = _temp4;
  // 3. Return ! Number::exponentiate(base, exponent).
  /* X */
  let _temp5 = NumberValue.exponentiate(base, exponent);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! NumberValue.exponentiate(base, exponent) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  return _temp5;
}
Math_pow.section = 'https://tc39.es/ecma262/#sec-math.pow';
/** @param {bigint} h */
function fmix64(h) {
  h ^= h >> 33n;
  h *= 0xFF51AFD7ED558CCDn;
  h ^= h >> 33n;
  h *= 0xC4CEB9FE1A85EC53n;
  h ^= h >> 33n;
  return h;
}
const floatView = new Float64Array(1);
const big64View = new BigUint64Array(floatView.buffer);
/** https://tc39.es/ecma262/#sec-math.random */
function Math_random() {
  const realm = surroundingAgent.currentRealmRecord;
  if (realm.randomState === undefined) {
    let seed;
    if (realm.HostDefined.randomSeed) {
      /* X */
      let _temp6 = realm.HostDefined.randomSeed();
      /* node:coverage ignore next */
      if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("!  returned an abrupt completion", {
        cause: _temp6
      });
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      seed = BigInt(_temp6);
    } else {
      seed = BigInt(Math.round(Math.random() * 2 ** 32));
    }
    realm.randomState = new BigUint64Array([fmix64(BigInt.asUintN(64, seed)), fmix64(BigInt.asUintN(64, ~seed))]);
  }
  const s = realm.randomState;

  // XorShift128+
  let s1 = s[0];
  const s0 = s[1];
  s[0] = s0;
  s1 ^= s1 << 23n;
  s1 ^= s1 >> 17n;
  s1 ^= s0;
  s1 ^= s0 >> 26n;
  s[1] = s1;

  // Convert to double in [0, 1) range
  big64View[0] = s0 >> 12n | 0x3FF0000000000000n;
  const result = floatView[0] - 1;
  return F(result);
}
Math_random.section = 'https://tc39.es/ecma262/#sec-math.random';
/** https://tc39.es/ecma262/#sec-math-object */
function bootstrapMath(realmRec) {
  /** https://tc39.es/ecma262/#sec-value-properties-of-the-math-object */
  const readonly = {
    Writable: Value.false,
    Configurable: Value.false
  };

  // @@toStringTag is handled in the bootstrapPrototype() call.
  const mathObj = bootstrapPrototype(realmRec, [['E', F(2.718281828459045), undefined, readonly], ['LN10', F(2.302585092994046), undefined, readonly], ['LN2', F(0.6931471805599453), undefined, readonly], ['LOG10E', F(0.4342944819032518), undefined, readonly], ['LOG2E', F(1.4426950408889634), undefined, readonly], ['PI', F(3.141592653589793), undefined, readonly], ['SQRT1_2', F(0.7071067811865476), undefined, readonly], ['SQRT2', F(1.4142135623730951), undefined, readonly], ['abs', Math_abs, 1], ['acos', Math_acos, 1], ['pow', Math_pow, 2], ['random', Math_random, 0]], realmRec.Intrinsics['%Object.prototype%'], 'Math');

  /** https://tc39.es/ecma262/#sec-function-properties-of-the-math-object */

  [['acosh', 1], ['asin', 1], ['asinh', 1], ['atan', 1], ['atanh', 1], ['atan2', 2], ['cbrt', 1], ['ceil', 1], ['clz32', 1], ['cos', 1], ['cosh', 1], ['exp', 1], ['expm1', 1], ['floor', 1], ['fround', 1], ['hypot', 2], ['imul', 2], ['log', 1], ['log1p', 1], ['log10', 1], ['log2', 1], ['max', 2], ['min', 2], ['round', 1], ['sign', 1], ['sin', 1], ['sinh', 1], ['sqrt', 1], ['tan', 1], ['tanh', 1], ['trunc', 1]].forEach(([name, length]) => {
    // TODO(18): Math
    /** https://tc39.es/ecma262/#sec-function-properties-of-the-math-object */
    const method = function* method(args) {
      const nextArgs = [];
      for (let i = 0; i < args.length; i += 1) {
        /* ReturnIfAbrupt */
        let _temp7 = yield* ToNumber(args[i]);
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) return _temp7;
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        nextArgs[i] = R(_temp7);
      }
      // we're calling host Math functions here.
      return F(Math[name](...nextArgs));
    };
    method.section = 'https://tc39.es/ecma262/#sec-function-properties-of-the-math-object';
    const func = CreateBuiltinFunction(method, length, Value(name), [], realmRec);
    /* X */
    let _temp8 = mathObj.DefineOwnProperty(Value(name), _Descriptor({
      Value: func,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! mathObj.DefineOwnProperty(Value(name), Descriptor({\n      Value: func,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    })) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  });
  realmRec.Intrinsics['%Math%'] = mathObj;
}
bootstrapMath.section = 'https://tc39.es/ecma262/#sec-math-object';

function thisTimeValue(value) {
  if (value instanceof ObjectValue && 'DateValue' in value) {
    return value.DateValue;
  }
  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', value);
}

/** https://tc39.es/ecma262/#sec-date.prototype.getdate */
function DateProto_getDate(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const t = _temp;
  if (t.isNaN()) {
    return F(NaN);
  }
  return DateFromTime(LocalTime(t));
}
DateProto_getDate.section = 'https://tc39.es/ecma262/#sec-date.prototype.getdate';
/** https://tc39.es/ecma262/#sec-date.prototype.getday */
function DateProto_getDay(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp2 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const t = _temp2;
  if (t.isNaN()) {
    return F(NaN);
  }
  return WeekDay(LocalTime(t));
}
DateProto_getDay.section = 'https://tc39.es/ecma262/#sec-date.prototype.getday';
/** https://tc39.es/ecma262/#sec-date.prototype.getfullyear */
function DateProto_getFullYear(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp3 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const t = _temp3;
  if (t.isNaN()) {
    return F(NaN);
  }
  return YearFromTime(LocalTime(t));
}
DateProto_getFullYear.section = 'https://tc39.es/ecma262/#sec-date.prototype.getfullyear';
/** https://tc39.es/ecma262/#sec-date.prototype.gethours */
function DateProto_getHours(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp4 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const t = _temp4;
  if (t.isNaN()) {
    return F(NaN);
  }
  return HourFromTime(LocalTime(t));
}
DateProto_getHours.section = 'https://tc39.es/ecma262/#sec-date.prototype.gethours';
/** https://tc39.es/ecma262/#sec-date.prototype.getmilliseconds */
function DateProto_getMilliseconds(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp5 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const t = _temp5;
  if (t.isNaN()) {
    return F(NaN);
  }
  return msFromTime(LocalTime(t));
}
DateProto_getMilliseconds.section = 'https://tc39.es/ecma262/#sec-date.prototype.getmilliseconds';
/** https://tc39.es/ecma262/#sec-date.prototype.getminutes */
function DateProto_getMinutes(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp6 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const t = _temp6;
  if (t.isNaN()) {
    return F(NaN);
  }
  return MinFromTime(LocalTime(t));
}
DateProto_getMinutes.section = 'https://tc39.es/ecma262/#sec-date.prototype.getminutes';
/** https://tc39.es/ecma262/#sec-date.prototype.getmonth */
function DateProto_getMonth(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp7 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const t = _temp7;
  if (t.isNaN()) {
    return F(NaN);
  }
  return MonthFromTime(LocalTime(t));
}
DateProto_getMonth.section = 'https://tc39.es/ecma262/#sec-date.prototype.getmonth';
/** https://tc39.es/ecma262/#sec-date.prototype.getseconds */
function DateProto_getSeconds(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp8 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const t = _temp8;
  if (t.isNaN()) {
    return F(NaN);
  }
  return SecFromTime(LocalTime(t));
}
DateProto_getSeconds.section = 'https://tc39.es/ecma262/#sec-date.prototype.getseconds';
/** https://tc39.es/ecma262/#sec-date.prototype.gettime */
function DateProto_getTime(_args, {
  thisValue
}) {
  return thisTimeValue(thisValue);
}
DateProto_getTime.section = 'https://tc39.es/ecma262/#sec-date.prototype.gettime';
/** https://tc39.es/ecma262/#sec-date.prototype.gettimezoneoffset */
function DateProto_getTimezoneOffset(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp9 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const t = _temp9;
  if (t.isNaN()) {
    return F(NaN);
  }
  return F((R(t) - R(LocalTime(t))) / msPerMinute);
}
DateProto_getTimezoneOffset.section = 'https://tc39.es/ecma262/#sec-date.prototype.gettimezoneoffset';
/** https://tc39.es/ecma262/#sec-date.prototype.getutcdate */
function DateProto_getUTCDate(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp10 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const t = _temp10;
  if (t.isNaN()) {
    return F(NaN);
  }
  return DateFromTime(t);
}
DateProto_getUTCDate.section = 'https://tc39.es/ecma262/#sec-date.prototype.getutcdate';
/** https://tc39.es/ecma262/#sec-date.prototype.getutcday */
function DateProto_getUTCDay(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp11 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const t = _temp11;
  if (t.isNaN()) {
    return F(NaN);
  }
  return WeekDay(t);
}
DateProto_getUTCDay.section = 'https://tc39.es/ecma262/#sec-date.prototype.getutcday';
/** https://tc39.es/ecma262/#sec-date.prototype.getutcfullyear */
function DateProto_getUTCFullYear(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp12 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  const t = _temp12;
  if (t.isNaN()) {
    return F(NaN);
  }
  return YearFromTime(t);
}
DateProto_getUTCFullYear.section = 'https://tc39.es/ecma262/#sec-date.prototype.getutcfullyear';
/** https://tc39.es/ecma262/#sec-date.prototype.getutchours */
function DateProto_getUTCHours(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp13 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  const t = _temp13;
  if (t.isNaN()) {
    return F(NaN);
  }
  return HourFromTime(t);
}
DateProto_getUTCHours.section = 'https://tc39.es/ecma262/#sec-date.prototype.getutchours';
/** https://tc39.es/ecma262/#sec-date.prototype.getutcmilliseconds */
function DateProto_getUTCMilliseconds(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp14 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const t = _temp14;
  if (t.isNaN()) {
    return F(NaN);
  }
  return msFromTime(t);
}
DateProto_getUTCMilliseconds.section = 'https://tc39.es/ecma262/#sec-date.prototype.getutcmilliseconds';
/** https://tc39.es/ecma262/#sec-date.prototype.getutcminutes */
function DateProto_getUTCMinutes(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp15 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const t = _temp15;
  if (t.isNaN()) {
    return F(NaN);
  }
  return MinFromTime(t);
}
DateProto_getUTCMinutes.section = 'https://tc39.es/ecma262/#sec-date.prototype.getutcminutes';
/** https://tc39.es/ecma262/#sec-date.prototype.getutcmonth */
function DateProto_getUTCMonth(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp16 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  const t = _temp16;
  if (t.isNaN()) {
    return F(NaN);
  }
  return MonthFromTime(t);
}
DateProto_getUTCMonth.section = 'https://tc39.es/ecma262/#sec-date.prototype.getutcmonth';
/** https://tc39.es/ecma262/#sec-date.prototype.getutcseconds */
function DateProto_getUTCSeconds(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp17 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  const t = _temp17;
  if (t.isNaN()) {
    return F(NaN);
  }
  return SecFromTime(t);
}
DateProto_getUTCSeconds.section = 'https://tc39.es/ecma262/#sec-date.prototype.getutcseconds';
/** https://tc39.es/ecma262/#sec-date.prototype.setdate */
function* DateProto_setDate([date = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp18 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) return _temp18;
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  let t = _temp18;
  /* ReturnIfAbrupt */
  let _temp19 = yield* ToNumber(date);
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) return _temp19;
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  const dt = _temp19;
  if (t.isNaN()) {
    return t;
  }
  t = LocalTime(t);
  const newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t));
  const u = TimeClip(UTC(newDate));
  /* ReturnIfAbrupt */
  let _temp20 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  thisValue.DateValue = u;
  return u;
}
DateProto_setDate.section = 'https://tc39.es/ecma262/#sec-date.prototype.setdate';
/** https://tc39.es/ecma262/#sec-date.prototype.setfullyear */
function* DateProto_setFullYear([year = Value.undefined, month, date], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp21 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  let t = _temp21;
  t = t.isNaN() ? F(0) : LocalTime(t);
  /* ReturnIfAbrupt */
  let _temp22 = yield* ToNumber(year);
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) return _temp22;
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  const y = _temp22;
  let m;
  if (month !== undefined) {
    /* ReturnIfAbrupt */
    let _temp23 = yield* ToNumber(month);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) return _temp23;
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    m = _temp23;
  } else {
    m = MonthFromTime(t);
  }
  let dt;
  if (date !== undefined) {
    /* ReturnIfAbrupt */
    let _temp24 = yield* ToNumber(date);
    /* node:coverage ignore next */
    if (_temp24 instanceof AbruptCompletion) return _temp24;
    /* node:coverage ignore next */
    if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
    dt = _temp24;
  } else {
    dt = DateFromTime(t);
  }
  const newDate = MakeDate(MakeDay(y, m, dt), TimeWithinDay(t));
  const u = TimeClip(UTC(newDate));
  /* ReturnIfAbrupt */
  let _temp25 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp25 && typeof _temp25 === 'object' && 'next' in _temp25) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  thisValue.DateValue = u;
  return u;
}
DateProto_setFullYear.section = 'https://tc39.es/ecma262/#sec-date.prototype.setfullyear';
/** https://tc39.es/ecma262/#sec-date.prototype.sethours */
function* DateProto_setHours([hour = Value.undefined, min, sec, ms], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp26 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp26 && typeof _temp26 === 'object' && 'next' in _temp26) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  const t = LocalTime(_temp26);
  /* ReturnIfAbrupt */
  let _temp27 = yield* ToNumber(hour);
  /* node:coverage ignore next */
  if (_temp27 instanceof AbruptCompletion) return _temp27;
  /* node:coverage ignore next */
  if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
  const h = _temp27;
  let m;
  if (min !== undefined) {
    /* ReturnIfAbrupt */
    let _temp28 = yield* ToNumber(min);
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) return _temp28;
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    m = _temp28;
  } else {
    m = MinFromTime(t);
  }
  let s;
  if (sec !== undefined) {
    /* ReturnIfAbrupt */
    let _temp29 = yield* ToNumber(sec);
    /* node:coverage ignore next */
    if (_temp29 instanceof AbruptCompletion) return _temp29;
    /* node:coverage ignore next */
    if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
    s = _temp29;
  } else {
    s = SecFromTime(t);
  }
  let milli;
  if (ms !== undefined) {
    /* ReturnIfAbrupt */
    let _temp30 = yield* ToNumber(ms);
    /* node:coverage ignore next */
    if (_temp30 instanceof AbruptCompletion) return _temp30;
    /* node:coverage ignore next */
    if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
    milli = _temp30;
  } else {
    milli = msFromTime(t);
  }
  const date = MakeDate(Day(t), MakeTime(h, m, s, milli));
  const u = TimeClip(UTC(date));
  /* ReturnIfAbrupt */
  let _temp31 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp31 && typeof _temp31 === 'object' && 'next' in _temp31) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp31 instanceof AbruptCompletion) return _temp31;
  /* node:coverage ignore next */
  if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
  thisValue.DateValue = u;
  return u;
}
DateProto_setHours.section = 'https://tc39.es/ecma262/#sec-date.prototype.sethours';
/** https://tc39.es/ecma262/#sec-date.prototype.setmilliseconds */
function* DateProto_setMilliseconds([ms = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp32 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp32 && typeof _temp32 === 'object' && 'next' in _temp32) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp32 instanceof AbruptCompletion) return _temp32;
  /* node:coverage ignore next */
  if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
  const t = LocalTime(_temp32);
  /* ReturnIfAbrupt */
  let _temp33 = yield* ToNumber(ms);
  /* node:coverage ignore next */
  if (_temp33 instanceof AbruptCompletion) return _temp33;
  /* node:coverage ignore next */
  if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
  ms = _temp33;
  const time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms);
  const u = TimeClip(UTC(MakeDate(Day(t), time)));
  /* ReturnIfAbrupt */
  let _temp34 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp34 && typeof _temp34 === 'object' && 'next' in _temp34) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp34 instanceof AbruptCompletion) return _temp34;
  /* node:coverage ignore next */
  if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
  thisValue.DateValue = u;
  return u;
}
DateProto_setMilliseconds.section = 'https://tc39.es/ecma262/#sec-date.prototype.setmilliseconds';
/** https://tc39.es/ecma262/#sec-date.prototype.setminutes */
function* DateProto_setMinutes([min = Value.undefined, sec, ms], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp35 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp35 && typeof _temp35 === 'object' && 'next' in _temp35) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp35 instanceof AbruptCompletion) return _temp35;
  /* node:coverage ignore next */
  if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
  // 1. Let t be LocalTime(? thisTimeValue(this value)).
  const t = LocalTime(_temp35);
  // 2. Let m be ? ToNumber(min).
  /* ReturnIfAbrupt */
  let _temp36 = yield* ToNumber(min);
  /* node:coverage ignore next */
  if (_temp36 instanceof AbruptCompletion) return _temp36;
  /* node:coverage ignore next */
  if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
  const m = _temp36;
  let s;
  // 3. If sec is not present, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).
  if (sec !== undefined) {
    /* ReturnIfAbrupt */
    let _temp37 = yield* ToNumber(sec);
    /* node:coverage ignore next */
    if (_temp37 instanceof AbruptCompletion) return _temp37;
    /* node:coverage ignore next */
    if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
    s = _temp37;
  } else {
    s = SecFromTime(t);
  }
  let milli;
  // 4. If ms is not present, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
  if (ms !== undefined) {
    /* ReturnIfAbrupt */
    let _temp38 = yield* ToNumber(ms);
    /* node:coverage ignore next */
    if (_temp38 instanceof AbruptCompletion) return _temp38;
    /* node:coverage ignore next */
    if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
    milli = _temp38;
  } else {
    milli = msFromTime(t);
  }
  // 5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).
  const date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli));
  // 6. Let u be TimeClip(UTC(date)).
  const u = TimeClip(UTC(date));
  // 7. Set the [[DateValue]] internal slot of this Date object to u.
  /* ReturnIfAbrupt */
  let _temp39 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp39 && typeof _temp39 === 'object' && 'next' in _temp39) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp39 instanceof AbruptCompletion) return _temp39;
  /* node:coverage ignore next */
  if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
  thisValue.DateValue = u;
  // 8. Return u.
  return u;
}
DateProto_setMinutes.section = 'https://tc39.es/ecma262/#sec-date.prototype.setminutes';
/** https://tc39.es/ecma262/#sec-date.prototype.setmonth */
function* DateProto_setMonth([month = Value.undefined, date], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp40 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp40 && typeof _temp40 === 'object' && 'next' in _temp40) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp40 instanceof AbruptCompletion) return _temp40;
  /* node:coverage ignore next */
  if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
  const t = LocalTime(_temp40);
  /* ReturnIfAbrupt */
  let _temp41 = yield* ToNumber(month);
  /* node:coverage ignore next */
  if (_temp41 instanceof AbruptCompletion) return _temp41;
  /* node:coverage ignore next */
  if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
  const m = _temp41;
  let dt;
  if (date !== undefined) {
    /* ReturnIfAbrupt */
    let _temp42 = yield* ToNumber(date);
    /* node:coverage ignore next */
    if (_temp42 instanceof AbruptCompletion) return _temp42;
    /* node:coverage ignore next */
    if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
    dt = _temp42;
  } else {
    dt = DateFromTime(t);
  }
  const newDate = MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t));
  const u = TimeClip(UTC(newDate));
  /* ReturnIfAbrupt */
  let _temp43 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp43 && typeof _temp43 === 'object' && 'next' in _temp43) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp43 instanceof AbruptCompletion) return _temp43;
  /* node:coverage ignore next */
  if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
  thisValue.DateValue = u;
  return u;
}
DateProto_setMonth.section = 'https://tc39.es/ecma262/#sec-date.prototype.setmonth';
/** https://tc39.es/ecma262/#sec-date.prototype.setseconds */
function* DateProto_setSeconds([sec = Value.undefined, ms], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp44 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp44 && typeof _temp44 === 'object' && 'next' in _temp44) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp44 instanceof AbruptCompletion) return _temp44;
  /* node:coverage ignore next */
  if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
  const t = LocalTime(_temp44);
  /* ReturnIfAbrupt */
  let _temp45 = yield* ToNumber(sec);
  /* node:coverage ignore next */
  if (_temp45 instanceof AbruptCompletion) return _temp45;
  /* node:coverage ignore next */
  if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
  const s = _temp45;
  let milli;
  if (ms !== undefined) {
    /* ReturnIfAbrupt */
    let _temp46 = yield* ToNumber(ms);
    /* node:coverage ignore next */
    if (_temp46 instanceof AbruptCompletion) return _temp46;
    /* node:coverage ignore next */
    if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
    milli = _temp46;
  } else {
    milli = msFromTime(t);
  }
  const date = MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli));
  const u = TimeClip(UTC(date));
  /* ReturnIfAbrupt */
  let _temp47 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp47 && typeof _temp47 === 'object' && 'next' in _temp47) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp47 instanceof AbruptCompletion) return _temp47;
  /* node:coverage ignore next */
  if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
  thisValue.DateValue = u;
  return u;
}
DateProto_setSeconds.section = 'https://tc39.es/ecma262/#sec-date.prototype.setseconds';
/** https://tc39.es/ecma262/#sec-date.prototype.settime */
function* DateProto_setTime([time = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp48 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp48 && typeof _temp48 === 'object' && 'next' in _temp48) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp48 instanceof AbruptCompletion) return _temp48;
  /* node:coverage ignore next */
  if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
  /* ReturnIfAbrupt */
  let _temp49 = yield* ToNumber(time);
  /* node:coverage ignore next */
  if (_temp49 instanceof AbruptCompletion) return _temp49;
  /* node:coverage ignore next */
  if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
  const t = _temp49;
  const v = TimeClip(t);
  /* ReturnIfAbrupt */
  let _temp50 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp50 && typeof _temp50 === 'object' && 'next' in _temp50) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp50 instanceof AbruptCompletion) return _temp50;
  /* node:coverage ignore next */
  if (_temp50 instanceof Completion) _temp50 = _temp50.Value;
  thisValue.DateValue = v;
  return v;
}
DateProto_setTime.section = 'https://tc39.es/ecma262/#sec-date.prototype.settime';
/** https://tc39.es/ecma262/#sec-date.prototype.setutcdate */
function* DateProto_setUTCDate([date = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp51 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp51 && typeof _temp51 === 'object' && 'next' in _temp51) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp51 instanceof AbruptCompletion) return _temp51;
  /* node:coverage ignore next */
  if (_temp51 instanceof Completion) _temp51 = _temp51.Value;
  const t = _temp51;
  /* ReturnIfAbrupt */
  let _temp52 = yield* ToNumber(date);
  /* node:coverage ignore next */
  if (_temp52 instanceof AbruptCompletion) return _temp52;
  /* node:coverage ignore next */
  if (_temp52 instanceof Completion) _temp52 = _temp52.Value;
  const dt = _temp52;
  if (t.isNaN()) {
    return t;
  }
  const newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t));
  const v = TimeClip(newDate);
  /* ReturnIfAbrupt */
  let _temp53 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp53 && typeof _temp53 === 'object' && 'next' in _temp53) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp53 instanceof AbruptCompletion) return _temp53;
  /* node:coverage ignore next */
  if (_temp53 instanceof Completion) _temp53 = _temp53.Value;
  thisValue.DateValue = v;
  return v;
}
DateProto_setUTCDate.section = 'https://tc39.es/ecma262/#sec-date.prototype.setutcdate';
/** https://tc39.es/ecma262/#sec-date.prototype.setutcfullyear */
function* DateProto_setUTCFullYear([year = Value.undefined, month, date], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp54 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp54 && typeof _temp54 === 'object' && 'next' in _temp54) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp54 instanceof AbruptCompletion) return _temp54;
  /* node:coverage ignore next */
  if (_temp54 instanceof Completion) _temp54 = _temp54.Value;
  let t = _temp54;
  if (t.isNaN()) {
    t = F(0);
  }
  /* ReturnIfAbrupt */
  let _temp55 = yield* ToNumber(year);
  /* node:coverage ignore next */
  if (_temp55 instanceof AbruptCompletion) return _temp55;
  /* node:coverage ignore next */
  if (_temp55 instanceof Completion) _temp55 = _temp55.Value;
  const y = _temp55;
  let m;
  if (month !== undefined) {
    /* ReturnIfAbrupt */
    let _temp56 = yield* ToNumber(month);
    /* node:coverage ignore next */
    if (_temp56 instanceof AbruptCompletion) return _temp56;
    /* node:coverage ignore next */
    if (_temp56 instanceof Completion) _temp56 = _temp56.Value;
    m = _temp56;
  } else {
    m = MonthFromTime(t);
  }
  let dt;
  if (date !== undefined) {
    /* ReturnIfAbrupt */
    let _temp57 = yield* ToNumber(date);
    /* node:coverage ignore next */
    if (_temp57 instanceof AbruptCompletion) return _temp57;
    /* node:coverage ignore next */
    if (_temp57 instanceof Completion) _temp57 = _temp57.Value;
    dt = _temp57;
  } else {
    dt = DateFromTime(t);
  }
  const newDate = MakeDate(MakeDay(y, m, dt), TimeWithinDay(t));
  const v = TimeClip(newDate);
  /* ReturnIfAbrupt */
  let _temp58 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp58 && typeof _temp58 === 'object' && 'next' in _temp58) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp58 instanceof AbruptCompletion) return _temp58;
  /* node:coverage ignore next */
  if (_temp58 instanceof Completion) _temp58 = _temp58.Value;
  thisValue.DateValue = v;
  return v;
}
DateProto_setUTCFullYear.section = 'https://tc39.es/ecma262/#sec-date.prototype.setutcfullyear';
/** https://tc39.es/ecma262/#sec-date.prototype.setutchours */
function* DateProto_setUTCHours([hour = Value.undefined, min, sec, ms], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp59 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp59 && typeof _temp59 === 'object' && 'next' in _temp59) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp59 instanceof AbruptCompletion) return _temp59;
  /* node:coverage ignore next */
  if (_temp59 instanceof Completion) _temp59 = _temp59.Value;
  const t = _temp59;
  /* ReturnIfAbrupt */
  let _temp60 = yield* ToNumber(hour);
  /* node:coverage ignore next */
  if (_temp60 instanceof AbruptCompletion) return _temp60;
  /* node:coverage ignore next */
  if (_temp60 instanceof Completion) _temp60 = _temp60.Value;
  const h = _temp60;
  let m;
  if (min !== undefined) {
    /* ReturnIfAbrupt */
    let _temp61 = yield* ToNumber(min);
    /* node:coverage ignore next */
    if (_temp61 instanceof AbruptCompletion) return _temp61;
    /* node:coverage ignore next */
    if (_temp61 instanceof Completion) _temp61 = _temp61.Value;
    m = _temp61;
  } else {
    m = MinFromTime(t);
  }
  let s;
  if (sec !== undefined) {
    /* ReturnIfAbrupt */
    let _temp62 = yield* ToNumber(sec);
    /* node:coverage ignore next */
    if (_temp62 instanceof AbruptCompletion) return _temp62;
    /* node:coverage ignore next */
    if (_temp62 instanceof Completion) _temp62 = _temp62.Value;
    s = _temp62;
  } else {
    s = SecFromTime(t);
  }
  let milli;
  if (ms !== undefined) {
    /* ReturnIfAbrupt */
    let _temp63 = yield* ToNumber(ms);
    /* node:coverage ignore next */
    if (_temp63 instanceof AbruptCompletion) return _temp63;
    /* node:coverage ignore next */
    if (_temp63 instanceof Completion) _temp63 = _temp63.Value;
    milli = _temp63;
  } else {
    milli = msFromTime(t);
  }
  const newDate = MakeDate(Day(t), MakeTime(h, m, s, milli));
  const v = TimeClip(newDate);
  /* ReturnIfAbrupt */
  let _temp64 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp64 && typeof _temp64 === 'object' && 'next' in _temp64) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp64 instanceof AbruptCompletion) return _temp64;
  /* node:coverage ignore next */
  if (_temp64 instanceof Completion) _temp64 = _temp64.Value;
  thisValue.DateValue = v;
  return v;
}
DateProto_setUTCHours.section = 'https://tc39.es/ecma262/#sec-date.prototype.setutchours';
/** https://tc39.es/ecma262/#sec-date.prototype.setutcmilliseconds */
function* DateProto_setUTCMilliseconds([ms = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp65 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp65 && typeof _temp65 === 'object' && 'next' in _temp65) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp65 instanceof AbruptCompletion) return _temp65;
  /* node:coverage ignore next */
  if (_temp65 instanceof Completion) _temp65 = _temp65.Value;
  const t = _temp65;
  /* ReturnIfAbrupt */
  let _temp66 = yield* ToNumber(ms);
  /* node:coverage ignore next */
  if (_temp66 instanceof AbruptCompletion) return _temp66;
  /* node:coverage ignore next */
  if (_temp66 instanceof Completion) _temp66 = _temp66.Value;
  const milli = _temp66;
  const time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli);
  const v = TimeClip(MakeDate(Day(t), time));
  /* ReturnIfAbrupt */
  let _temp67 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp67 && typeof _temp67 === 'object' && 'next' in _temp67) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp67 instanceof AbruptCompletion) return _temp67;
  /* node:coverage ignore next */
  if (_temp67 instanceof Completion) _temp67 = _temp67.Value;
  thisValue.DateValue = v;
  return v;
}
DateProto_setUTCMilliseconds.section = 'https://tc39.es/ecma262/#sec-date.prototype.setutcmilliseconds';
/** https://tc39.es/ecma262/#sec-date.prototype.setutcminutes */
function* DateProto_setUTCMinutes([min = Value.undefined, sec, ms], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp68 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp68 && typeof _temp68 === 'object' && 'next' in _temp68) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp68 instanceof AbruptCompletion) return _temp68;
  /* node:coverage ignore next */
  if (_temp68 instanceof Completion) _temp68 = _temp68.Value;
  const t = _temp68;
  /* ReturnIfAbrupt */
  let _temp69 = yield* ToNumber(min);
  /* node:coverage ignore next */
  if (_temp69 instanceof AbruptCompletion) return _temp69;
  /* node:coverage ignore next */
  if (_temp69 instanceof Completion) _temp69 = _temp69.Value;
  const m = _temp69;
  let s;
  if (sec !== undefined) {
    /* ReturnIfAbrupt */
    let _temp70 = yield* ToNumber(sec);
    /* node:coverage ignore next */
    if (_temp70 instanceof AbruptCompletion) return _temp70;
    /* node:coverage ignore next */
    if (_temp70 instanceof Completion) _temp70 = _temp70.Value;
    s = _temp70;
  } else {
    s = SecFromTime(t);
  }
  let milli;
  if (ms !== undefined) {
    /* ReturnIfAbrupt */
    let _temp71 = yield* ToNumber(ms);
    /* node:coverage ignore next */
    if (_temp71 instanceof AbruptCompletion) return _temp71;
    /* node:coverage ignore next */
    if (_temp71 instanceof Completion) _temp71 = _temp71.Value;
    milli = _temp71;
  } else {
    milli = msFromTime(t);
  }
  const date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli));
  const v = TimeClip(date);
  /* ReturnIfAbrupt */
  let _temp72 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp72 && typeof _temp72 === 'object' && 'next' in _temp72) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp72 instanceof AbruptCompletion) return _temp72;
  /* node:coverage ignore next */
  if (_temp72 instanceof Completion) _temp72 = _temp72.Value;
  thisValue.DateValue = v;
  return v;
}
DateProto_setUTCMinutes.section = 'https://tc39.es/ecma262/#sec-date.prototype.setutcminutes';
/** https://tc39.es/ecma262/#sec-date.prototype.setutcmonth */
function* DateProto_setUTCMonth([month = Value.undefined, date], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp73 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp73 && typeof _temp73 === 'object' && 'next' in _temp73) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp73 instanceof AbruptCompletion) return _temp73;
  /* node:coverage ignore next */
  if (_temp73 instanceof Completion) _temp73 = _temp73.Value;
  const t = _temp73;
  /* ReturnIfAbrupt */
  let _temp74 = yield* ToNumber(month);
  /* node:coverage ignore next */
  if (_temp74 instanceof AbruptCompletion) return _temp74;
  /* node:coverage ignore next */
  if (_temp74 instanceof Completion) _temp74 = _temp74.Value;
  const m = _temp74;
  let dt;
  if (date !== undefined) {
    /* ReturnIfAbrupt */
    let _temp75 = yield* ToNumber(date);
    /* node:coverage ignore next */
    if (_temp75 instanceof AbruptCompletion) return _temp75;
    /* node:coverage ignore next */
    if (_temp75 instanceof Completion) _temp75 = _temp75.Value;
    dt = _temp75;
  } else {
    dt = DateFromTime(t);
  }
  const newDate = MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t));
  const v = TimeClip(newDate);
  /* ReturnIfAbrupt */
  let _temp76 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp76 && typeof _temp76 === 'object' && 'next' in _temp76) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp76 instanceof AbruptCompletion) return _temp76;
  /* node:coverage ignore next */
  if (_temp76 instanceof Completion) _temp76 = _temp76.Value;
  thisValue.DateValue = v;
  return v;
}
DateProto_setUTCMonth.section = 'https://tc39.es/ecma262/#sec-date.prototype.setutcmonth';
/** https://tc39.es/ecma262/#sec-date.prototype.setutcseconds */
function* DateProto_setUTCSeconds([sec = Value.undefined, ms], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp77 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp77 && typeof _temp77 === 'object' && 'next' in _temp77) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp77 instanceof AbruptCompletion) return _temp77;
  /* node:coverage ignore next */
  if (_temp77 instanceof Completion) _temp77 = _temp77.Value;
  const t = _temp77;
  /* ReturnIfAbrupt */
  let _temp78 = yield* ToNumber(sec);
  /* node:coverage ignore next */
  if (_temp78 instanceof AbruptCompletion) return _temp78;
  /* node:coverage ignore next */
  if (_temp78 instanceof Completion) _temp78 = _temp78.Value;
  const s = _temp78;
  let milli;
  if (ms !== undefined) {
    /* ReturnIfAbrupt */
    let _temp79 = yield* ToNumber(ms);
    /* node:coverage ignore next */
    if (_temp79 instanceof AbruptCompletion) return _temp79;
    /* node:coverage ignore next */
    if (_temp79 instanceof Completion) _temp79 = _temp79.Value;
    milli = _temp79;
  } else {
    milli = msFromTime(t);
  }
  const date = MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli));
  const v = TimeClip(date);
  /* ReturnIfAbrupt */
  let _temp80 = surroundingAgent.debugger_tryTouchDuringPreview(thisValue);
  /* node:coverage ignore next */
  if (_temp80 && typeof _temp80 === 'object' && 'next' in _temp80) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp80 instanceof AbruptCompletion) return _temp80;
  /* node:coverage ignore next */
  if (_temp80 instanceof Completion) _temp80 = _temp80.Value;
  thisValue.DateValue = v;
  return v;
}
DateProto_setUTCSeconds.section = 'https://tc39.es/ecma262/#sec-date.prototype.setutcseconds';
/** https://tc39.es/ecma262/#sec-date.prototype.todatestring */
function* DateProto_toDateString(_args, {
  thisValue
}) {
  const O = thisValue;
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', O);
  }
  /* ReturnIfAbrupt */
  let _temp81 = thisTimeValue(O);
  /* node:coverage ignore next */
  if (_temp81 && typeof _temp81 === 'object' && 'next' in _temp81) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp81 instanceof AbruptCompletion) return _temp81;
  /* node:coverage ignore next */
  if (_temp81 instanceof Completion) _temp81 = _temp81.Value;
  const tv = _temp81;
  if (tv.isNaN()) {
    return Value('Invalid Date');
  }
  const t = LocalTime(tv);
  return DateString(t);
}
DateProto_toDateString.section = 'https://tc39.es/ecma262/#sec-date.prototype.todatestring';
/** https://tc39.es/ecma262/#sec-date.prototype.toisostring */
function DateProto_toISOString(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp82 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp82 && typeof _temp82 === 'object' && 'next' in _temp82) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp82 instanceof AbruptCompletion) return _temp82;
  /* node:coverage ignore next */
  if (_temp82 instanceof Completion) _temp82 = _temp82.Value;
  const t = _temp82;
  if (!Number.isFinite(R(t))) {
    return surroundingAgent.Throw('RangeError', 'DateInvalidTime');
  }
  const year = R(YearFromTime(t));
  const month = R(MonthFromTime(t)) + 1;
  const date = R(DateFromTime(t));
  const hour = R(HourFromTime(t));
  const min = R(MinFromTime(t));
  const sec = R(SecFromTime(t));
  const ms = R(msFromTime(t));

  // TODO: figure out if there can be invalid years.
  let YYYY = String(year);
  if (year < 0 || year > 9999) {
    YYYY = year < 0 ? `${String(year).padStart(6, '0')}` : `+${String(year).padStart(6, '0')}`;
  }
  const MM = String(month).padStart(2, '0');
  const DD = String(date).padStart(2, '0');
  const HH = String(hour).padStart(2, '0');
  const mm = String(min).padStart(2, '0');
  const ss = String(sec).padStart(2, '0');
  const sss = String(ms).padStart(3, '0');
  const format = `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}.${sss}Z`;
  return Value(format);
}
DateProto_toISOString.section = 'https://tc39.es/ecma262/#sec-date.prototype.toisostring';
/** https://tc39.es/ecma262/#sec-date.prototype.tojson */
function* DateProto_toJSON(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp83 = ToObject(thisValue);
  /* node:coverage ignore next */
  if (_temp83 && typeof _temp83 === 'object' && 'next' in _temp83) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp83 instanceof AbruptCompletion) return _temp83;
  /* node:coverage ignore next */
  if (_temp83 instanceof Completion) _temp83 = _temp83.Value;
  const O = _temp83;
  /* ReturnIfAbrupt */
  let _temp84 = yield* ToPrimitive(O, 'number');
  /* node:coverage ignore next */
  if (_temp84 instanceof AbruptCompletion) return _temp84;
  /* node:coverage ignore next */
  if (_temp84 instanceof Completion) _temp84 = _temp84.Value;
  const tv = _temp84;
  if (tv instanceof NumberValue && !Number.isFinite(R(tv))) {
    return Value.null;
  }
  return yield* Invoke(O, Value('toISOString'));
}
DateProto_toJSON.section = 'https://tc39.es/ecma262/#sec-date.prototype.tojson';
/** https://tc39.es/ecma262/#sec-date.prototype.tolocaledatestring */
function DateProto_toLocaleDateString() {
  // TODO: implement this function.
  return surroundingAgent.Throw('Error', 'Raw', 'Date.prototype.toLocaleDateString is not implemented');
}
DateProto_toLocaleDateString.section = 'https://tc39.es/ecma262/#sec-date.prototype.tolocaledatestring';
/** https://tc39.es/ecma262/#sec-date.prototype.tolocalestring */
function DateProto_toLocaleString() {
  // TODO: implement this function.
  return surroundingAgent.Throw('Error', 'Raw', 'Date.prototype.toLocaleString is not implemented');
}
DateProto_toLocaleString.section = 'https://tc39.es/ecma262/#sec-date.prototype.tolocalestring';
/** https://tc39.es/ecma262/#sec-date.prototype.tolocaletimestring */
function DateProto_toLocaleTimeString() {
  // TODO: implement this function.
  return surroundingAgent.Throw('Error', 'Raw', 'Date.prototype.toLocaleTimeString is not implemented');
}
DateProto_toLocaleTimeString.section = 'https://tc39.es/ecma262/#sec-date.prototype.tolocaletimestring';
/** https://tc39.es/ecma262/#sec-date.prototype.tostring */
function DateProto_toString(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp85 = thisTimeValue(thisValue);
  /* node:coverage ignore next */
  if (_temp85 && typeof _temp85 === 'object' && 'next' in _temp85) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp85 instanceof AbruptCompletion) return _temp85;
  /* node:coverage ignore next */
  if (_temp85 instanceof Completion) _temp85 = _temp85.Value;
  const tv = _temp85;
  return ToDateString(tv);
}
DateProto_toString.section = 'https://tc39.es/ecma262/#sec-date.prototype.tostring';
/** https://tc39.es/ecma262/#sec-timestring */
function TimeString(tv) {
  Assert(tv instanceof NumberValue, "tv instanceof NumberValue");
  Assert(!tv.isNaN(), "!tv.isNaN()");
  const hour = String(R(HourFromTime(tv))).padStart(2, '0');
  const minute = String(R(MinFromTime(tv))).padStart(2, '0');
  const second = String(R(SecFromTime(tv))).padStart(2, '0');
  return Value(`${hour}:${minute}:${second} GMT`);
}
TimeString.section = 'https://tc39.es/ecma262/#sec-timestring';
/** https://tc39.es/ecma262/#sec-todatestring-day-names */
const daysOfTheWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
/** https://tc39.es/ecma262/#sec-todatestring-month-names */
const monthsOfTheYear = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

/** https://tc39.es/ecma262/#sec-datestring */
function DateString(tv) {
  Assert(tv instanceof NumberValue, "tv instanceof NumberValue");
  Assert(!tv.isNaN(), "!tv.isNaN()");
  const weekday = daysOfTheWeek[R(WeekDay(tv))];
  const month = monthsOfTheYear[R(MonthFromTime(tv))];
  const day = String(R(DateFromTime(tv))).padStart(2, '0');
  const yv = R(YearFromTime(tv));
  const yearSign = yv >= 0 ? '' : '-';
  const year = Value(String(Math.abs(yv)));
  /* X */
  let _temp86 = StringPad(year, F(4), Value('0'), 'start');
  /* node:coverage ignore next */
  if (_temp86 && typeof _temp86 === 'object' && 'next' in _temp86) _temp86 = skipDebugger(_temp86);
  /* node:coverage ignore next */
  if (_temp86 instanceof AbruptCompletion) throw new Assert.Error("! StringPad(year, F(4), Value('0'), 'start') returned an abrupt completion", {
    cause: _temp86
  });
  /* node:coverage ignore next */
  if (_temp86 instanceof Completion) _temp86 = _temp86.Value;
  const paddedYear = _temp86.stringValue();
  return Value(`${weekday} ${month} ${day} ${yearSign}${paddedYear}`);
}
DateString.section = 'https://tc39.es/ecma262/#sec-datestring';
/** https://tc39.es/ecma262/#sec-timezoneestring */
function TimeZoneString(tv) {
  Assert(tv instanceof NumberValue, "tv instanceof NumberValue");
  Assert(!tv.isNaN(), "!tv.isNaN()");
  const offset = LocalTZA();
  const offsetSign = '+' ;
  const offsetMin = String(R(MinFromTime(F(Math.abs(offset))))).padStart(2, '0');
  const offsetHour = String(R(HourFromTime(F(Math.abs(offset))))).padStart(2, '0');
  const tzName = '';
  return Value(`${offsetSign}${offsetHour}${offsetMin}${tzName}`);
}
TimeZoneString.section = 'https://tc39.es/ecma262/#sec-timezoneestring';
/** https://tc39.es/ecma262/#sec-todatestring */
function ToDateString(tv) {
  Assert(tv instanceof NumberValue, "tv instanceof NumberValue");
  if (tv.isNaN()) {
    return Value('Invalid Date');
  }
  const t = LocalTime(tv);
  return Value(`${DateString(t).stringValue()} ${TimeString(t).stringValue()}${TimeZoneString(t).stringValue()}`);
}
ToDateString.section = 'https://tc39.es/ecma262/#sec-todatestring';
/** https://tc39.es/ecma262/#sec-date.prototype.totimestring */
function DateProto_toTimeString(_args, {
  thisValue
}) {
  const O = thisValue;
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', O);
  }
  /* ReturnIfAbrupt */
  let _temp87 = thisTimeValue(O);
  /* node:coverage ignore next */
  if (_temp87 && typeof _temp87 === 'object' && 'next' in _temp87) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp87 instanceof AbruptCompletion) return _temp87;
  /* node:coverage ignore next */
  if (_temp87 instanceof Completion) _temp87 = _temp87.Value;
  const tv = _temp87;
  if (tv.isNaN()) {
    return Value('Invalid Date');
  }
  const t = LocalTime(tv);
  return Value(`${TimeString(t).stringValue()}${TimeZoneString(tv).stringValue()}`);
}
DateProto_toTimeString.section = 'https://tc39.es/ecma262/#sec-date.prototype.totimestring';
/** https://tc39.es/ecma262/#sec-date.prototype.toutcstring */
function DateProto_toUTCString(_args, {
  thisValue
}) {
  const O = thisValue;
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', O);
  }
  /* ReturnIfAbrupt */
  let _temp88 = thisTimeValue(O);
  /* node:coverage ignore next */
  if (_temp88 && typeof _temp88 === 'object' && 'next' in _temp88) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp88 instanceof AbruptCompletion) return _temp88;
  /* node:coverage ignore next */
  if (_temp88 instanceof Completion) _temp88 = _temp88.Value;
  const tv = _temp88;
  if (tv.isNaN()) {
    return Value('Invalid Date');
  }
  const weekday = daysOfTheWeek[R(WeekDay(tv))];
  const month = monthsOfTheYear[R(MonthFromTime(tv))];
  const day = String(R(DateFromTime(tv))).padStart(2, '0');
  const yv = R(YearFromTime(tv));
  const yearSign = yv >= 0 ? '' : '-';
  const year = Value(String(Math.abs(yv)));
  /* X */
  let _temp89 = StringPad(year, F(4), Value('0'), 'start');
  /* node:coverage ignore next */
  if (_temp89 && typeof _temp89 === 'object' && 'next' in _temp89) _temp89 = skipDebugger(_temp89);
  /* node:coverage ignore next */
  if (_temp89 instanceof AbruptCompletion) throw new Assert.Error("! StringPad(year, F(4), Value('0'), 'start') returned an abrupt completion", {
    cause: _temp89
  });
  /* node:coverage ignore next */
  if (_temp89 instanceof Completion) _temp89 = _temp89.Value;
  const paddedYear = _temp89.stringValue();
  return Value(`${weekday}, ${day} ${month} ${yearSign}${paddedYear} ${TimeString(tv).stringValue()}`);
}
DateProto_toUTCString.section = 'https://tc39.es/ecma262/#sec-date.prototype.toutcstring';
/** https://tc39.es/ecma262/#sec-date.prototype.valueof */
function DateProto_valueOf(_args, {
  thisValue
}) {
  return thisTimeValue(thisValue);
}
DateProto_valueOf.section = 'https://tc39.es/ecma262/#sec-date.prototype.valueof';
/** https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive */
function* DateProto_toPrimitive([hint = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Date', O);
  }
  let tryFirst;
  if (hint instanceof JSStringValue && (hint.stringValue() === 'string' || hint.stringValue() === 'default')) {
    tryFirst = 'string';
  } else if (hint instanceof JSStringValue && hint.stringValue() === 'number') {
    tryFirst = 'number';
  } else {
    return surroundingAgent.Throw('TypeError', 'InvalidHint', hint);
  }
  return yield* OrdinaryToPrimitive(O, tryFirst);
}
DateProto_toPrimitive.section = 'https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive';
function bootstrapDatePrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['getDate', DateProto_getDate, 0], ['getDay', DateProto_getDay, 0], ['getFullYear', DateProto_getFullYear, 0], ['getHours', DateProto_getHours, 0], ['getMilliseconds', DateProto_getMilliseconds, 0], ['getMinutes', DateProto_getMinutes, 0], ['getMonth', DateProto_getMonth, 0], ['getSeconds', DateProto_getSeconds, 0], ['getTime', DateProto_getTime, 0], ['getTimezoneOffset', DateProto_getTimezoneOffset, 0], ['getUTCDate', DateProto_getUTCDate, 0], ['getUTCDay', DateProto_getUTCDay, 0], ['getUTCFullYear', DateProto_getUTCFullYear, 0], ['getUTCHours', DateProto_getUTCHours, 0], ['getUTCMilliseconds', DateProto_getUTCMilliseconds, 0], ['getUTCMinutes', DateProto_getUTCMinutes, 0], ['getUTCMonth', DateProto_getUTCMonth, 0], ['getUTCSeconds', DateProto_getUTCSeconds, 0], ['setDate', DateProto_setDate, 1], ['setFullYear', DateProto_setFullYear, 3], ['setHours', DateProto_setHours, 4], ['setMilliseconds', DateProto_setMilliseconds, 1], ['setMinutes', DateProto_setMinutes, 3], ['setMonth', DateProto_setMonth, 2], ['setSeconds', DateProto_setSeconds, 2], ['setTime', DateProto_setTime, 1], ['setUTCDate', DateProto_setUTCDate, 1], ['setUTCFullYear', DateProto_setUTCFullYear, 3], ['setUTCHours', DateProto_setUTCHours, 4], ['setUTCMilliseconds', DateProto_setUTCMilliseconds, 1], ['setUTCMinutes', DateProto_setUTCMinutes, 3], ['setUTCMonth', DateProto_setUTCMonth, 2], ['setUTCSeconds', DateProto_setUTCSeconds, 2], ['toDateString', DateProto_toDateString, 0], ['toISOString', DateProto_toISOString, 0], ['toJSON', DateProto_toJSON, 1], ['toLocaleDateString', DateProto_toLocaleDateString, 0], ['toLocaleString', DateProto_toLocaleString, 0], ['toLocaleTimeString', DateProto_toLocaleTimeString, 0], ['toString', DateProto_toString, 0], ['toTimeString', DateProto_toTimeString, 0], ['toUTCString', DateProto_toUTCString, 0], ['valueOf', DateProto_valueOf, 0], [wellKnownSymbols.toPrimitive, DateProto_toPrimitive, 1, {
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Date.prototype%'] = proto;
}

function isDateObject(value) {
  return 'DateValue' in value;
}
/** https://tc39.es/ecma262/#sec-date-constructor */
function* DateConstructor(args, {
  NewTarget
}) {
  const numberOfArgs = args.length;
  if (numberOfArgs >= 2) {
    /** https://tc39.es/ecma262/#sec-date-year-month-date-hours-minutes-seconds-ms */
    const [year, month, date, hours, minutes, seconds, ms] = args;
    Assert(numberOfArgs >= 2, "numberOfArgs >= 2");
    if (NewTarget === Value.undefined) {
      const now = Date.now();
      return ToDateString(F(now));
    } else {
      /* ReturnIfAbrupt */
      let _temp = yield* ToNumber(year);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) return _temp;
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      const y = _temp;
      /* ReturnIfAbrupt */
      let _temp2 = yield* ToNumber(month);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      const m = _temp2;
      let dt;
      if (date !== undefined) {
        /* ReturnIfAbrupt */
        let _temp3 = yield* ToNumber(date);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) return _temp3;
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        dt = _temp3;
      } else {
        dt = F(1);
      }
      let h;
      if (hours !== undefined) {
        /* ReturnIfAbrupt */
        let _temp4 = yield* ToNumber(hours);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        h = _temp4;
      } else {
        h = F(0);
      }
      let min;
      if (minutes !== undefined) {
        /* ReturnIfAbrupt */
        let _temp5 = yield* ToNumber(minutes);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) return _temp5;
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        min = _temp5;
      } else {
        min = F(0);
      }
      let s;
      if (seconds !== undefined) {
        /* ReturnIfAbrupt */
        let _temp6 = yield* ToNumber(seconds);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        s = _temp6;
      } else {
        s = F(0);
      }
      let milli;
      if (ms !== undefined) {
        /* ReturnIfAbrupt */
        let _temp7 = yield* ToNumber(ms);
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) return _temp7;
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        milli = _temp7;
      } else {
        milli = F(0);
      }
      let yr;
      if (y.isNaN()) {
        yr = F(NaN);
      } else {
        /* X */
        let _temp8 = ToIntegerOrInfinity(y);
        /* node:coverage ignore next */
        if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
        /* node:coverage ignore next */
        if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(y) returned an abrupt completion", {
          cause: _temp8
        });
        /* node:coverage ignore next */
        if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        const yi = _temp8;
        if (yi >= 0 && yi <= 99) {
          yr = F(1900 + yi);
        } else {
          yr = y;
        }
      }
      const finalDate = MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli));
      /* ReturnIfAbrupt */
      let _temp9 = yield* OrdinaryCreateFromConstructor(NewTarget, '%Date.prototype%', ['DateValue']);
      /* node:coverage ignore next */
      if (_temp9 instanceof AbruptCompletion) return _temp9;
      /* node:coverage ignore next */
      if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
      const O = _temp9;
      O.DateValue = TimeClip(UTC(finalDate));
      return O;
    }
  } else if (numberOfArgs === 1) {
    const [value] = args;
    /** https://tc39.es/ecma262/#sec-date-value */
    Assert(numberOfArgs === 1, "numberOfArgs === 1");
    if (NewTarget === Value.undefined) {
      const now = Date.now();
      return ToDateString(F(now));
    } else {
      let tv;
      if (value instanceof ObjectValue && 'DateValue' in value) {
        /* X */
        let _temp10 = thisTimeValue(value);
        /* node:coverage ignore next */
        if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
        /* node:coverage ignore next */
        if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! thisTimeValue(value) returned an abrupt completion", {
          cause: _temp10
        });
        /* node:coverage ignore next */
        if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
        tv = _temp10;
      } else {
        /* ReturnIfAbrupt */
        let _temp11 = yield* ToPrimitive(value);
        /* node:coverage ignore next */
        if (_temp11 instanceof AbruptCompletion) return _temp11;
        /* node:coverage ignore next */
        if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
        const v = _temp11;
        if (v instanceof JSStringValue) {
          // Assert: The next step never returns an abrupt completion because Type(v) is String.
          tv = parseDate(v);
        } else {
          /* ReturnIfAbrupt */
          let _temp12 = yield* ToNumber(v);
          /* node:coverage ignore next */
          if (_temp12 instanceof AbruptCompletion) return _temp12;
          /* node:coverage ignore next */
          if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
          tv = _temp12;
        }
      }
      /* ReturnIfAbrupt */
      let _temp13 = yield* OrdinaryCreateFromConstructor(NewTarget, '%Date.prototype%', ['DateValue']);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      const O = _temp13;
      O.DateValue = TimeClip(tv);
      return O;
    }
  } else {
    /** https://tc39.es/ecma262/#sec-date-constructor-date */
    Assert(numberOfArgs === 0, "numberOfArgs === 0");
    if (NewTarget === Value.undefined) {
      const now = Date.now();
      return ToDateString(F(now));
    } else {
      /* ReturnIfAbrupt */
      let _temp14 = yield* OrdinaryCreateFromConstructor(NewTarget, '%Date.prototype%', ['DateValue']);
      /* node:coverage ignore next */
      if (_temp14 instanceof AbruptCompletion) return _temp14;
      /* node:coverage ignore next */
      if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
      const O = _temp14;
      O.DateValue = F(Date.now());
      return O;
    }
  }
}
DateConstructor.section = 'https://tc39.es/ecma262/#sec-date-constructor';
/** https://tc39.es/ecma262/#sec-date.now */
function Date_now() {
  const now = Date.now();
  return F(now);
}
Date_now.section = 'https://tc39.es/ecma262/#sec-date.now';
/** https://tc39.es/ecma262/#sec-date.parse */
function* Date_parse([string = Value.undefined]) {
  const str = yield* ToString(string);
  if (str instanceof AbruptCompletion) {
    return str;
  }
  return parseDate(ValueOfNormalCompletion(str));
}
Date_parse.section = 'https://tc39.es/ecma262/#sec-date.parse';
/** https://tc39.es/ecma262/#sec-date.utc */
function* Date_UTC([year = Value.undefined, month, date, hours, minutes, seconds, ms]) {
  /* ReturnIfAbrupt */
  let _temp15 = yield* ToNumber(year);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const y = _temp15;
  let m;
  if (month !== undefined) {
    /* ReturnIfAbrupt */
    let _temp16 = yield* ToNumber(month);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) return _temp16;
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    m = _temp16;
  } else {
    m = F(0);
  }
  let dt;
  if (date !== undefined) {
    /* ReturnIfAbrupt */
    let _temp17 = yield* ToNumber(date);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) return _temp17;
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    dt = _temp17;
  } else {
    dt = F(1);
  }
  let h;
  if (hours !== undefined) {
    /* ReturnIfAbrupt */
    let _temp18 = yield* ToNumber(hours);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) return _temp18;
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    h = _temp18;
  } else {
    h = F(0);
  }
  let min;
  if (minutes !== undefined) {
    /* ReturnIfAbrupt */
    let _temp19 = yield* ToNumber(minutes);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) return _temp19;
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    min = _temp19;
  } else {
    min = F(0);
  }
  let s;
  if (seconds !== undefined) {
    /* ReturnIfAbrupt */
    let _temp20 = yield* ToNumber(seconds);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    s = _temp20;
  } else {
    s = F(0);
  }
  let milli;
  if (ms !== undefined) {
    /* ReturnIfAbrupt */
    let _temp21 = yield* ToNumber(ms);
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) return _temp21;
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    milli = _temp21;
  } else {
    milli = F(0);
  }
  let yr;
  if (y.isNaN()) {
    yr = F(NaN);
  } else {
    /* X */
    let _temp22 = ToIntegerOrInfinity(y);
    /* node:coverage ignore next */
    if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) _temp22 = skipDebugger(_temp22);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(y) returned an abrupt completion", {
      cause: _temp22
    });
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    const yi = _temp22;
    if (yi >= 0 && yi <= 99) {
      yr = F(1900 + yi);
    } else {
      yr = y;
    }
  }
  return TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)));
}
Date_UTC.section = 'https://tc39.es/ecma262/#sec-date.utc';
function parseDate(dateTimeString) {
  /** https://tc39.es/ecma262/#sec-date-time-string-format */
  // TODO: implement parsing without the host.
  const parsed = Date.parse(dateTimeString.stringValue());
  return F(parsed);
}
function bootstrapDate(realmRec) {
  const cons = bootstrapConstructor(realmRec, DateConstructor, 'Date', 7, realmRec.Intrinsics['%Date.prototype%'], [['now', Date_now, 0], ['parse', Date_parse, 1], ['UTC', Date_UTC, 7]]);
  realmRec.Intrinsics['%Date%'] = cons;
}

/** https://tc39.es/ecma262/#sec-createregexpstringiterator */
function CreateRegExpStringIterator(R$1, S, global, fullUnicode) {
  // 4. Let closure be a new Abstract Closure with no parameters that captures R, S, global, and fullUnicode and performs the following steps when called:
  const closure = function* closure() {
    // a. Repeat,
    while (true) {
      /* ReturnIfAbrupt */
      let _temp = yield* RegExpExec(R$1, S);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) return _temp;
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      // i. Let match be ? RegExpExec(R, S).
      const match = _temp;
      // ii. If match is null, return undefined.
      if (match instanceof NullValue) {
        return Value.undefined;
      }
      // iii. If global is false, then
      if (!global) {
        /* ReturnIfAbrupt */
        let _temp2 = yield* Yield(match);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        // 2. Return undefined.
        return Value.undefined;
      }
      // iv. Let matchStr be ? ToString(? Get(match, "0")).
      /* ReturnIfAbrupt */
      let _temp9 = yield* Get(match, Value('0'));
      /* node:coverage ignore next */
      if (_temp9 instanceof AbruptCompletion) return _temp9;
      /* node:coverage ignore next */
      if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
      /* ReturnIfAbrupt */
      let _temp3 = yield* ToString(_temp9);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      const matchStr = _temp3;
      // v. If matchStr is the empty String, then
      if (matchStr.stringValue() === '') {
        /* ReturnIfAbrupt */
        let _temp7 = yield* Get(R$1, Value('lastIndex'));
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) return _temp7;
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        /* ReturnIfAbrupt */
        let _temp4 = yield* ToLength(_temp7);
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        // i. Let thisIndex be ℝ(? ToLength(? Get(R, "lastIndex"))).
        const thisIndex = R(_temp4);
        // ii. Let nextIndex be ! AdvanceStringIndex(S, thisIndex, fullUnicode).
        /* X */
        let _temp5 = AdvanceStringIndex(S, thisIndex, fullUnicode);
        /* node:coverage ignore next */
        if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! AdvanceStringIndex(S, thisIndex, fullUnicode) returned an abrupt completion", {
          cause: _temp5
        });
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        const nextIndex = _temp5;
        // iii. Perform ? Set(R, "lastIndex", 𝔽(nextIndex), true).
        /* ReturnIfAbrupt */
        let _temp6 = yield* Set$1(R$1, Value('lastIndex'), F(nextIndex), Value.true);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      }
      // vi. Perform ? Yield(match).
      /* ReturnIfAbrupt */
      let _temp8 = yield* Yield(match);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) return _temp8;
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    }
  };
  // 4. Return ! CreateIteratorFromClosure(closure, "%RegExpStringIteratorPrototype%", %RegExpStringIteratorPrototype%).
  /* X */
  let _temp10 = CreateIteratorFromClosure(closure, Value('%RegExpStringIteratorPrototype%'), surroundingAgent.intrinsic('%RegExpStringIteratorPrototype%'));
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorFromClosure(closure, Value('%RegExpStringIteratorPrototype%'), surroundingAgent.intrinsic('%RegExpStringIteratorPrototype%')) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  return _temp10;
}
CreateRegExpStringIterator.section = 'https://tc39.es/ecma262/#sec-createregexpstringiterator';
/** https://tc39.es/ecma262/#sec-%regexpstringiteratorprototype%.next */
function* RegExpStringIteratorPrototype_next(_args, {
  thisValue
}) {
  // 1. Return ? GeneratorResume(this value, empty, "%RegExpStringIteratorPrototype%").
  return yield* GeneratorResume(thisValue, undefined, Value('%RegExpStringIteratorPrototype%'));
}
RegExpStringIteratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-%regexpstringiteratorprototype%.next';
function bootstrapRegExpStringIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', RegExpStringIteratorPrototype_next, 0]], realmRec.Intrinsics['%Iterator.prototype%'], 'RegExp String Iterator');
  realmRec.Intrinsics['%RegExpStringIteratorPrototype%'] = proto;
}

const WHITESPACE = [' ', '\t', '\r', '\n'];
const NUMERIC = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
const VALID_HEX = [...NUMERIC, 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'];
const ESCAPABLE = ['"', '\\', '/', 'b', 'f', 'n', 'r', 't'];
class JSONValidator {
  input;
  pos = 0;
  char;
  constructor(input) {
    this.input = input;
    this.char = input.charAt(0);
  }
  validate() {
    /* X */
    let _temp = this.eatWhitespace();
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    /* ReturnIfAbrupt */
    let _temp2 = this.parseValue();
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    if (this.pos < this.input.length) {
      return surroundingAgent.Throw('SyntaxError', 'JSONUnexpectedToken');
    }
    return NormalCompletion(undefined);
  }
  advance() {
    this.pos += 1;
    if (this.pos === this.input.length) {
      this.char = null;
    } else if (this.pos > this.input.length) {
      return surroundingAgent.Throw('SyntaxError', 'JSONUnexpectedToken');
    } else {
      this.char = this.input.charAt(this.pos);
    }
    return this.char;
  }
  eatWhitespace() {
    while (this.eat(WHITESPACE)) {
      // nothing
    }
  }
  eat(c) {
    if (Array.isArray(c) && c.includes(this.char)) {
      /* X */
      let _temp3 = this.advance();
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! this.advance() returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      return true;
    } else if (this.char === c) {
      /* X */
      let _temp4 = this.advance();
      /* node:coverage ignore next */
      if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! this.advance() returned an abrupt completion", {
        cause: _temp4
      });
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      return true;
    }
    return false;
  }
  expect(c) {
    const {
      char
    } = this;
    if (!this.eat(c)) {
      return surroundingAgent.Throw('SyntaxError', 'JSONExpected', c, this.char);
    }
    return char;
  }
  parseValue() {
    switch (this.char) {
      case '"':
        return this.parseString();
      case '{':
        return this.parseObject();
      case '[':
        return this.parseArray();
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        return this.parseNumber();
      case 'f':
        /* X */
        let _temp5 = this.expect('f');
        /* node:coverage ignore next */
        if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! this.expect('f') returned an abrupt completion", {
          cause: _temp5
        });
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
        /* ReturnIfAbrupt */
        let _temp6 = this.expect('a');
        /* node:coverage ignore next */
        if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) return _temp6;
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        /* ReturnIfAbrupt */
        let _temp7 = this.expect('l');
        /* node:coverage ignore next */
        if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) return _temp7;
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        /* ReturnIfAbrupt */
        let _temp8 = this.expect('s');
        /* node:coverage ignore next */
        if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp8 instanceof AbruptCompletion) return _temp8;
        /* node:coverage ignore next */
        if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        /* ReturnIfAbrupt */
        let _temp9 = this.expect('e');
        /* node:coverage ignore next */
        if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp9 instanceof AbruptCompletion) return _temp9;
        /* node:coverage ignore next */
        if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
        /* X */
        let _temp10 = this.eatWhitespace();
        /* node:coverage ignore next */
        if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
        /* node:coverage ignore next */
        if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
          cause: _temp10
        });
        /* node:coverage ignore next */
        if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
        return _temp10;
      case 't':
        /* X */
        let _temp11 = this.expect('t');
        /* node:coverage ignore next */
        if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
        /* node:coverage ignore next */
        if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! this.expect('t') returned an abrupt completion", {
          cause: _temp11
        });
        /* node:coverage ignore next */
        if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
        /* ReturnIfAbrupt */
        let _temp12 = this.expect('r');
        /* node:coverage ignore next */
        if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp12 instanceof AbruptCompletion) return _temp12;
        /* node:coverage ignore next */
        if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
        /* ReturnIfAbrupt */
        let _temp13 = this.expect('u');
        /* node:coverage ignore next */
        if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp13 instanceof AbruptCompletion) return _temp13;
        /* node:coverage ignore next */
        if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
        /* ReturnIfAbrupt */
        let _temp14 = this.expect('e');
        /* node:coverage ignore next */
        if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp14 instanceof AbruptCompletion) return _temp14;
        /* node:coverage ignore next */
        if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
        /* X */
        let _temp15 = this.eatWhitespace();
        /* node:coverage ignore next */
        if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
        /* node:coverage ignore next */
        if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
          cause: _temp15
        });
        /* node:coverage ignore next */
        if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
        return _temp15;
      case 'n':
        /* X */
        let _temp16 = this.expect('n');
        /* node:coverage ignore next */
        if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
        /* node:coverage ignore next */
        if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! this.expect('n') returned an abrupt completion", {
          cause: _temp16
        });
        /* node:coverage ignore next */
        if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
        /* ReturnIfAbrupt */
        let _temp17 = this.expect('u');
        /* node:coverage ignore next */
        if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp17 instanceof AbruptCompletion) return _temp17;
        /* node:coverage ignore next */
        if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
        /* ReturnIfAbrupt */
        let _temp18 = this.expect('l');
        /* node:coverage ignore next */
        if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp18 instanceof AbruptCompletion) return _temp18;
        /* node:coverage ignore next */
        if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
        /* ReturnIfAbrupt */
        let _temp19 = this.expect('l');
        /* node:coverage ignore next */
        if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp19 instanceof AbruptCompletion) return _temp19;
        /* node:coverage ignore next */
        if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
        /* X */
        let _temp20 = this.eatWhitespace();
        /* node:coverage ignore next */
        if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) _temp20 = skipDebugger(_temp20);
        /* node:coverage ignore next */
        if (_temp20 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
          cause: _temp20
        });
        /* node:coverage ignore next */
        if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
        return _temp20;
      default:
        return surroundingAgent.Throw('SyntaxError', 'JSONUnexpectedChar', this.char);
    }
  }
  parseString() {
    /* ReturnIfAbrupt */
    let _temp21 = this.expect('"');
    /* node:coverage ignore next */
    if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) return _temp21;
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    while (!this.eat('"')) {
      if (this.eat('\\')) {
        if (!this.eat(ESCAPABLE)) {
          /* ReturnIfAbrupt */
          let _temp22 = this.expect('u');
          /* node:coverage ignore next */
          if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (_temp22 instanceof AbruptCompletion) return _temp22;
          /* node:coverage ignore next */
          if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
          /* ReturnIfAbrupt */
          let _temp23 = this.expect(VALID_HEX);
          /* node:coverage ignore next */
          if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (_temp23 instanceof AbruptCompletion) return _temp23;
          /* node:coverage ignore next */
          if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
          /* ReturnIfAbrupt */
          let _temp24 = this.expect(VALID_HEX);
          /* node:coverage ignore next */
          if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (_temp24 instanceof AbruptCompletion) return _temp24;
          /* node:coverage ignore next */
          if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
          /* ReturnIfAbrupt */
          let _temp25 = this.expect(VALID_HEX);
          /* node:coverage ignore next */
          if (_temp25 && typeof _temp25 === 'object' && 'next' in _temp25) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (_temp25 instanceof AbruptCompletion) return _temp25;
          /* node:coverage ignore next */
          if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
          /* ReturnIfAbrupt */
          let _temp26 = this.expect(VALID_HEX);
          /* node:coverage ignore next */
          if (_temp26 && typeof _temp26 === 'object' && 'next' in _temp26) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (_temp26 instanceof AbruptCompletion) return _temp26;
          /* node:coverage ignore next */
          if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
        }
      } else {
        if (this.char < ' ') {
          return surroundingAgent.Throw('SyntaxError', 'JSONUnexpectedChar', this.char);
        }
        /* ReturnIfAbrupt */
        let _temp27 = this.advance();
        /* node:coverage ignore next */
        if (_temp27 && typeof _temp27 === 'object' && 'next' in _temp27) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp27 instanceof AbruptCompletion) return _temp27;
        /* node:coverage ignore next */
        if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
      }
    }
    /* X */
    let _temp28 = this.eatWhitespace();
    /* node:coverage ignore next */
    if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) _temp28 = skipDebugger(_temp28);
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
      cause: _temp28
    });
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    return _temp28;
  }
  parseNumber() {
    this.eat('-');
    if (!this.eat('0')) {
      /* ReturnIfAbrupt */
      let _temp29 = this.expect(NUMERIC);
      /* node:coverage ignore next */
      if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp29 instanceof AbruptCompletion) return _temp29;
      /* node:coverage ignore next */
      if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
      while (this.eat(NUMERIC)) {
        // nothing
      }
    }
    if (this.eat('.')) {
      /* ReturnIfAbrupt */
      let _temp30 = this.expect(NUMERIC);
      /* node:coverage ignore next */
      if (_temp30 && typeof _temp30 === 'object' && 'next' in _temp30) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp30 instanceof AbruptCompletion) return _temp30;
      /* node:coverage ignore next */
      if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
      while (this.eat(NUMERIC)) {
        // nothing
      }
    }
    if (this.eat(['e', 'E'])) {
      this.eat(['-', '+']);
      /* ReturnIfAbrupt */
      let _temp31 = this.expect(NUMERIC);
      /* node:coverage ignore next */
      if (_temp31 && typeof _temp31 === 'object' && 'next' in _temp31) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp31 instanceof AbruptCompletion) return _temp31;
      /* node:coverage ignore next */
      if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
      while (this.eat(NUMERIC)) {
        // nothing
      }
    }
    /* X */
    let _temp32 = this.eatWhitespace();
    /* node:coverage ignore next */
    if (_temp32 && typeof _temp32 === 'object' && 'next' in _temp32) _temp32 = skipDebugger(_temp32);
    /* node:coverage ignore next */
    if (_temp32 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
      cause: _temp32
    });
    /* node:coverage ignore next */
    if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
  }
  parseObject() {
    /* ReturnIfAbrupt */
    let _temp33 = this.expect('{');
    /* node:coverage ignore next */
    if (_temp33 && typeof _temp33 === 'object' && 'next' in _temp33) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp33 instanceof AbruptCompletion) return _temp33;
    /* node:coverage ignore next */
    if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
    /* X */
    let _temp34 = this.eatWhitespace();
    /* node:coverage ignore next */
    if (_temp34 && typeof _temp34 === 'object' && 'next' in _temp34) _temp34 = skipDebugger(_temp34);
    /* node:coverage ignore next */
    if (_temp34 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
      cause: _temp34
    });
    /* node:coverage ignore next */
    if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
    let first = true;
    while (!this.eat('}')) {
      if (first) {
        first = false;
      } else {
        /* ReturnIfAbrupt */
        let _temp35 = this.expect(',');
        /* node:coverage ignore next */
        if (_temp35 && typeof _temp35 === 'object' && 'next' in _temp35) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp35 instanceof AbruptCompletion) return _temp35;
        /* node:coverage ignore next */
        if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
        /* X */
        let _temp36 = this.eatWhitespace();
        /* node:coverage ignore next */
        if (_temp36 && typeof _temp36 === 'object' && 'next' in _temp36) _temp36 = skipDebugger(_temp36);
        /* node:coverage ignore next */
        if (_temp36 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
          cause: _temp36
        });
        /* node:coverage ignore next */
        if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
      }
      /* ReturnIfAbrupt */
      let _temp37 = this.parseString();
      /* node:coverage ignore next */
      if (_temp37 && typeof _temp37 === 'object' && 'next' in _temp37) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp37 instanceof AbruptCompletion) return _temp37;
      /* node:coverage ignore next */
      if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
      /* X */
      let _temp38 = this.eatWhitespace();
      /* node:coverage ignore next */
      if (_temp38 && typeof _temp38 === 'object' && 'next' in _temp38) _temp38 = skipDebugger(_temp38);
      /* node:coverage ignore next */
      if (_temp38 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
        cause: _temp38
      });
      /* node:coverage ignore next */
      if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
      /* ReturnIfAbrupt */
      let _temp39 = this.expect(':');
      /* node:coverage ignore next */
      if (_temp39 && typeof _temp39 === 'object' && 'next' in _temp39) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp39 instanceof AbruptCompletion) return _temp39;
      /* node:coverage ignore next */
      if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
      /* X */
      let _temp40 = this.eatWhitespace();
      /* node:coverage ignore next */
      if (_temp40 && typeof _temp40 === 'object' && 'next' in _temp40) _temp40 = skipDebugger(_temp40);
      /* node:coverage ignore next */
      if (_temp40 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
        cause: _temp40
      });
      /* node:coverage ignore next */
      if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
      /* ReturnIfAbrupt */
      let _temp41 = this.parseValue();
      /* node:coverage ignore next */
      if (_temp41 && typeof _temp41 === 'object' && 'next' in _temp41) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp41 instanceof AbruptCompletion) return _temp41;
      /* node:coverage ignore next */
      if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
      /* X */
      let _temp42 = this.eatWhitespace();
      /* node:coverage ignore next */
      if (_temp42 && typeof _temp42 === 'object' && 'next' in _temp42) _temp42 = skipDebugger(_temp42);
      /* node:coverage ignore next */
      if (_temp42 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
        cause: _temp42
      });
      /* node:coverage ignore next */
      if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
    }
    /* X */
    let _temp43 = this.eatWhitespace();
    /* node:coverage ignore next */
    if (_temp43 && typeof _temp43 === 'object' && 'next' in _temp43) _temp43 = skipDebugger(_temp43);
    /* node:coverage ignore next */
    if (_temp43 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
      cause: _temp43
    });
    /* node:coverage ignore next */
    if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
  }
  parseArray() {
    /* ReturnIfAbrupt */
    let _temp44 = this.expect('[');
    /* node:coverage ignore next */
    if (_temp44 && typeof _temp44 === 'object' && 'next' in _temp44) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp44 instanceof AbruptCompletion) return _temp44;
    /* node:coverage ignore next */
    if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
    /* X */
    let _temp45 = this.eatWhitespace();
    /* node:coverage ignore next */
    if (_temp45 && typeof _temp45 === 'object' && 'next' in _temp45) _temp45 = skipDebugger(_temp45);
    /* node:coverage ignore next */
    if (_temp45 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
      cause: _temp45
    });
    /* node:coverage ignore next */
    if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
    let first = true;
    while (!this.eat(']')) {
      if (first) {
        first = false;
      } else {
        /* ReturnIfAbrupt */
        let _temp46 = this.expect(',');
        /* node:coverage ignore next */
        if (_temp46 && typeof _temp46 === 'object' && 'next' in _temp46) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp46 instanceof AbruptCompletion) return _temp46;
        /* node:coverage ignore next */
        if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
        /* X */
        let _temp47 = this.eatWhitespace();
        /* node:coverage ignore next */
        if (_temp47 && typeof _temp47 === 'object' && 'next' in _temp47) _temp47 = skipDebugger(_temp47);
        /* node:coverage ignore next */
        if (_temp47 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
          cause: _temp47
        });
        /* node:coverage ignore next */
        if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
      }
      /* ReturnIfAbrupt */
      let _temp48 = this.parseValue();
      /* node:coverage ignore next */
      if (_temp48 && typeof _temp48 === 'object' && 'next' in _temp48) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp48 instanceof AbruptCompletion) return _temp48;
      /* node:coverage ignore next */
      if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
      /* X */
      let _temp49 = this.eatWhitespace();
      /* node:coverage ignore next */
      if (_temp49 && typeof _temp49 === 'object' && 'next' in _temp49) _temp49 = skipDebugger(_temp49);
      /* node:coverage ignore next */
      if (_temp49 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
        cause: _temp49
      });
      /* node:coverage ignore next */
      if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
    }
    /* X */
    let _temp50 = this.eatWhitespace();
    /* node:coverage ignore next */
    if (_temp50 && typeof _temp50 === 'object' && 'next' in _temp50) _temp50 = skipDebugger(_temp50);
    /* node:coverage ignore next */
    if (_temp50 instanceof AbruptCompletion) throw new Assert.Error("! this.eatWhitespace() returned an abrupt completion", {
      cause: _temp50
    });
    /* node:coverage ignore next */
    if (_temp50 instanceof Completion) _temp50 = _temp50.Value;
  }
  static validate(input) {
    const v = new JSONValidator(input);
    return v.validate();
  }
}
function* InternalizeJSONProperty(holder, name, reviver) {
  /* ReturnIfAbrupt */
  let _temp51 = yield* Get(holder, name);
  /* node:coverage ignore next */
  if (_temp51 instanceof AbruptCompletion) return _temp51;
  /* node:coverage ignore next */
  if (_temp51 instanceof Completion) _temp51 = _temp51.Value;
  const val = _temp51;
  if (val instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp52 = IsArray(val);
    /* node:coverage ignore next */
    if (_temp52 && typeof _temp52 === 'object' && 'next' in _temp52) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp52 instanceof AbruptCompletion) return _temp52;
    /* node:coverage ignore next */
    if (_temp52 instanceof Completion) _temp52 = _temp52.Value;
    const isArray = _temp52;
    if (isArray === Value.true) {
      let I = 0;
      /* ReturnIfAbrupt */
      let _temp53 = yield* LengthOfArrayLike(val);
      /* node:coverage ignore next */
      if (_temp53 instanceof AbruptCompletion) return _temp53;
      /* node:coverage ignore next */
      if (_temp53 instanceof Completion) _temp53 = _temp53.Value;
      const len = _temp53;
      while (I < len) {
        /* X */
        let _temp54 = ToString(F(I));
        /* node:coverage ignore next */
        if (_temp54 && typeof _temp54 === 'object' && 'next' in _temp54) _temp54 = skipDebugger(_temp54);
        /* node:coverage ignore next */
        if (_temp54 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(I)) returned an abrupt completion", {
          cause: _temp54
        });
        /* node:coverage ignore next */
        if (_temp54 instanceof Completion) _temp54 = _temp54.Value;
        const Istr = _temp54;
        /* ReturnIfAbrupt */
        let _temp55 = yield* InternalizeJSONProperty(val, Istr, reviver);
        /* node:coverage ignore next */
        if (_temp55 instanceof AbruptCompletion) return _temp55;
        /* node:coverage ignore next */
        if (_temp55 instanceof Completion) _temp55 = _temp55.Value;
        const newElement = _temp55;
        if (newElement instanceof UndefinedValue) {
          /* ReturnIfAbrupt */
          let _temp56 = yield* val.Delete(Istr);
          /* node:coverage ignore next */
          if (_temp56 instanceof AbruptCompletion) return _temp56;
          /* node:coverage ignore next */
          if (_temp56 instanceof Completion) _temp56 = _temp56.Value;
        } else {
          /* ReturnIfAbrupt */
          let _temp57 = yield* CreateDataProperty(val, Istr, newElement);
          /* node:coverage ignore next */
          if (_temp57 instanceof AbruptCompletion) return _temp57;
          /* node:coverage ignore next */
          if (_temp57 instanceof Completion) _temp57 = _temp57.Value;
        }
        I += 1;
      }
    } else {
      /* ReturnIfAbrupt */
      let _temp58 = yield* EnumerableOwnPropertyNames(val, 'key');
      /* node:coverage ignore next */
      if (_temp58 instanceof AbruptCompletion) return _temp58;
      /* node:coverage ignore next */
      if (_temp58 instanceof Completion) _temp58 = _temp58.Value;
      const keys = _temp58;
      for (const P of keys) {
        /* ReturnIfAbrupt */
        let _temp59 = yield* InternalizeJSONProperty(val, P, reviver);
        /* node:coverage ignore next */
        if (_temp59 instanceof AbruptCompletion) return _temp59;
        /* node:coverage ignore next */
        if (_temp59 instanceof Completion) _temp59 = _temp59.Value;
        const newElement = _temp59;
        if (newElement instanceof UndefinedValue) {
          /* ReturnIfAbrupt */
          let _temp60 = yield* val.Delete(P);
          /* node:coverage ignore next */
          if (_temp60 instanceof AbruptCompletion) return _temp60;
          /* node:coverage ignore next */
          if (_temp60 instanceof Completion) _temp60 = _temp60.Value;
        } else {
          /* ReturnIfAbrupt */
          let _temp61 = yield* CreateDataProperty(val, P, newElement);
          /* node:coverage ignore next */
          if (_temp61 instanceof AbruptCompletion) return _temp61;
          /* node:coverage ignore next */
          if (_temp61 instanceof Completion) _temp61 = _temp61.Value;
        }
      }
    }
  }
  return yield* Call(reviver, holder, [name, val]);
}

/** https://tc39.es/ecma262/#sec-json.parse */
function* JSON_parse([text = Value.undefined, reviver = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp62 = yield* ToString(text);
  /* node:coverage ignore next */
  if (_temp62 instanceof AbruptCompletion) return _temp62;
  /* node:coverage ignore next */
  if (_temp62 instanceof Completion) _temp62 = _temp62.Value;
  // 1. Let jsonString be ? ToString(text).
  const jsonString = _temp62;
  // 2. Parse ! UTF16DecodeString(jsonString) as a JSON text as specified in ECMA-404.
  //    Throw a SyntaxError exception if it is not a valid JSON text as defined in that specification.
  /* ReturnIfAbrupt */
  let _temp63 = JSONValidator.validate(jsonString.stringValue());
  /* node:coverage ignore next */
  if (_temp63 && typeof _temp63 === 'object' && 'next' in _temp63) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp63 instanceof AbruptCompletion) return _temp63;
  /* node:coverage ignore next */
  if (_temp63 instanceof Completion) _temp63 = _temp63.Value;
  // 3. Let scriptString be the string-concatenation of "(", jsonString, and ");".
  const scriptString = `(${jsonString.stringValue()});`;
  // 4. Let completion be the result of parsing and evaluating
  //    ! UTF16DecodeString(scriptString) as if it was the source text of an ECMAScript Script. The
  //    extended PropertyDefinitionEvaluation semantics defined in B.3.1 must not be used during the evaluation.
  const parsed = ParseScript(scriptString, surroundingAgent.currentRealmRecord, {
    [kInternal]: {
      json: true
    }
  });
  Assert(!isArray(parsed), "!isArray(parsed)"); // array means parse error
  /* X */
  let _temp64 = skipDebugger(ScriptEvaluation(parsed));
  /* node:coverage ignore next */
  if (_temp64 && typeof _temp64 === 'object' && 'next' in _temp64) _temp64 = skipDebugger(_temp64);
  /* node:coverage ignore next */
  if (_temp64 instanceof AbruptCompletion) throw new Assert.Error("! skipDebugger(ScriptEvaluation(parsed)) returned an abrupt completion", {
    cause: _temp64
  });
  /* node:coverage ignore next */
  if (_temp64 instanceof Completion) _temp64 = _temp64.Value;
  const completion = _temp64;
  // 5. Let unfiltered be completion.[[Value]].
  const unfiltered = completion;
  // 6. Assert: unfiltered is either a String, Number, Boolean, Null, or an Object that is defined by either an ArrayLiteral or an ObjectLiteral.
  Assert(unfiltered instanceof JSStringValue || unfiltered instanceof NumberValue || unfiltered instanceof BooleanValue || unfiltered instanceof NullValue || unfiltered instanceof ObjectValue, "unfiltered instanceof JSStringValue\n    || unfiltered instanceof NumberValue\n    || unfiltered instanceof BooleanValue\n    || unfiltered instanceof NullValue\n    || unfiltered instanceof ObjectValue");
  // 7. If IsCallable(reviver) is true, then
  if (IsCallable(reviver)) {
    // a. Let root be OrdinaryObjectCreate(%Object.prototype%).
    const root = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
    // b. Let rootName be the empty String.
    const rootName = Value('');
    // c. Perform ! CreateDataPropertyOrThrow(root, rootName, unfiltered).
    /* X */
    let _temp65 = CreateDataPropertyOrThrow(root, rootName, unfiltered);
    /* node:coverage ignore next */
    if (_temp65 && typeof _temp65 === 'object' && 'next' in _temp65) _temp65 = skipDebugger(_temp65);
    /* node:coverage ignore next */
    if (_temp65 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(root, rootName, unfiltered) returned an abrupt completion", {
      cause: _temp65
    });
    /* node:coverage ignore next */
    if (_temp65 instanceof Completion) _temp65 = _temp65.Value;
    // d. Return ? InternalizeJSONProperty(root, rootName, reviver).
    return yield* InternalizeJSONProperty(root, rootName, reviver);
  } else {
    // a. Return unfiltered.
    return unfiltered;
  }
}
JSON_parse.section = 'https://tc39.es/ecma262/#sec-json.parse';
const codeUnitTable = new Map([[0x0008, '\\b'], [0x0009, '\\t'], [0x000A, '\\n'], [0x000C, '\\f'], [0x000D, '\\r'], [0x0022, '\\"'], [0x005C, '\\\\']]);
/** https://tc39.es/ecma262/#sec-serializejsonproperty */
function* SerializeJSONProperty(state, key, holder) {
  /* ReturnIfAbrupt */
  let _temp66 = yield* Get(holder, key);
  /* node:coverage ignore next */
  if (_temp66 instanceof AbruptCompletion) return _temp66;
  /* node:coverage ignore next */
  if (_temp66 instanceof Completion) _temp66 = _temp66.Value;
  let value = _temp66; // eslint-disable-line no-shadow
  if (value instanceof ObjectValue || value instanceof BigIntValue) {
    /* ReturnIfAbrupt */
    let _temp67 = yield* GetV(value, Value('toJSON'));
    /* node:coverage ignore next */
    if (_temp67 instanceof AbruptCompletion) return _temp67;
    /* node:coverage ignore next */
    if (_temp67 instanceof Completion) _temp67 = _temp67.Value;
    const toJSON = _temp67;
    if (IsCallable(toJSON)) {
      /* ReturnIfAbrupt */
      let _temp68 = yield* Call(toJSON, value, [key]);
      /* node:coverage ignore next */
      if (_temp68 instanceof AbruptCompletion) return _temp68;
      /* node:coverage ignore next */
      if (_temp68 instanceof Completion) _temp68 = _temp68.Value;
      value = _temp68;
    }
  }
  if (state.ReplacerFunction !== Value.undefined) {
    /* ReturnIfAbrupt */
    let _temp69 = yield* Call(state.ReplacerFunction, holder, [key, value]);
    /* node:coverage ignore next */
    if (_temp69 instanceof AbruptCompletion) return _temp69;
    /* node:coverage ignore next */
    if (_temp69 instanceof Completion) _temp69 = _temp69.Value;
    value = _temp69;
  }
  if (value instanceof ObjectValue) {
    if ('NumberData' in value) {
      /* ReturnIfAbrupt */
      let _temp70 = yield* ToNumber(value);
      /* node:coverage ignore next */
      if (_temp70 instanceof AbruptCompletion) return _temp70;
      /* node:coverage ignore next */
      if (_temp70 instanceof Completion) _temp70 = _temp70.Value;
      value = _temp70;
    } else if ('StringData' in value) {
      /* ReturnIfAbrupt */
      let _temp71 = yield* ToString(value);
      /* node:coverage ignore next */
      if (_temp71 instanceof AbruptCompletion) return _temp71;
      /* node:coverage ignore next */
      if (_temp71 instanceof Completion) _temp71 = _temp71.Value;
      value = _temp71;
    } else if (isBooleanObject(value)) {
      value = value.BooleanData;
    } else if (isBigIntObject(value)) {
      value = value.BigIntData;
    }
  }
  if (value === Value.null) {
    return Value('null');
  }
  if (value === Value.true) {
    return Value('true');
  }
  if (value === Value.false) {
    return Value('false');
  }
  if (value instanceof JSStringValue) {
    return QuoteJSONString(value);
  }
  if (value instanceof NumberValue) {
    if (value.isFinite()) {
      /* X */
      let _temp72 = ToString(value);
      /* node:coverage ignore next */
      if (_temp72 && typeof _temp72 === 'object' && 'next' in _temp72) _temp72 = skipDebugger(_temp72);
      /* node:coverage ignore next */
      if (_temp72 instanceof AbruptCompletion) throw new Assert.Error("! ToString(value) returned an abrupt completion", {
        cause: _temp72
      });
      /* node:coverage ignore next */
      if (_temp72 instanceof Completion) _temp72 = _temp72.Value;
      return _temp72;
    }
    return Value('null');
  }
  if (value instanceof BigIntValue) {
    return surroundingAgent.Throw('TypeError', 'CannotJSONSerializeBigInt');
  }
  if (value instanceof ObjectValue && !IsCallable(value)) {
    /* ReturnIfAbrupt */
    let _temp73 = IsArray(value);
    /* node:coverage ignore next */
    if (_temp73 && typeof _temp73 === 'object' && 'next' in _temp73) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp73 instanceof AbruptCompletion) return _temp73;
    /* node:coverage ignore next */
    if (_temp73 instanceof Completion) _temp73 = _temp73.Value;
    const isArray = _temp73;
    if (isArray === Value.true) {
      return yield* SerializeJSONArray(state, value);
    }
    return yield* SerializeJSONObject(state, value);
  }
  return Value.undefined;
}
SerializeJSONProperty.section = 'https://tc39.es/ecma262/#sec-serializejsonproperty';
function UnicodeEscape(C) {
  const n = C.charCodeAt(0);
  Assert(n < 0xFFFF, "n < 0xFFFF");
  return `\u005Cu${n.toString(16).padStart(4, '0')}`;
}
function QuoteJSONString(value) {
  // eslint-disable-line no-shadow
  let product = '\u0022';
  const cpList = [...value.stringValue()].map(c => c.codePointAt(0));
  for (const C of cpList) {
    if (codeUnitTable.has(C)) {
      product = `${product}${codeUnitTable.get(C)}`;
    } else if (C < 0x0020 || isLeadingSurrogate(C) || isTrailingSurrogate(C)) {
      const unit = String.fromCodePoint(C);
      product += UnicodeEscape(unit);
    } else {
      product += UTF16EncodeCodePoint(C);
    }
  }
  product = `${product}\u0022`;
  return Value(product);
}

/** https://tc39.es/ecma262/#sec-serializejsonobject */
function* SerializeJSONObject(state, value) {
  if (state.Stack.includes(value)) {
    return surroundingAgent.Throw('TypeError', 'JSONCircular');
  }
  state.Stack.push(value);
  const stepback = state.Indent;
  state.Indent = `${state.Indent}${state.Gap}`;
  let K;
  if (!(state.PropertyList instanceof UndefinedValue)) {
    K = state.PropertyList.keys();
  } else {
    /* ReturnIfAbrupt */
    let _temp74 = yield* EnumerableOwnPropertyNames(value, 'key');
    /* node:coverage ignore next */
    if (_temp74 instanceof AbruptCompletion) return _temp74;
    /* node:coverage ignore next */
    if (_temp74 instanceof Completion) _temp74 = _temp74.Value;
    K = _temp74.values();
  }
  const partial = [];
  for (const P of K) {
    /* ReturnIfAbrupt */
    let _temp75 = yield* SerializeJSONProperty(state, P, value);
    /* node:coverage ignore next */
    if (_temp75 instanceof AbruptCompletion) return _temp75;
    /* node:coverage ignore next */
    if (_temp75 instanceof Completion) _temp75 = _temp75.Value;
    const strP = _temp75;
    if (!(strP instanceof UndefinedValue)) {
      let member = QuoteJSONString(P).stringValue();
      member = `${member}:`;
      if (state.Gap !== '') {
        member = `${member} `;
      }
      member = `${member}${strP.stringValue()}`;
      partial.push(member);
    }
  }
  let final;
  if (partial.length === 0) {
    final = Value('{}');
  } else {
    if (state.Gap === '') {
      const properties = partial.join(',');
      final = Value(`{${properties}}`);
    } else {
      const separator = `,\u000A${state.Indent}`;
      const properties = partial.join(separator);
      final = Value(`{\u000A${state.Indent}${properties}\u000A${stepback}}`);
    }
  }
  state.Stack.pop();
  state.Indent = stepback;
  return final;
}
SerializeJSONObject.section = 'https://tc39.es/ecma262/#sec-serializejsonobject';
/** https://tc39.es/ecma262/#sec-serializejsonarray */
function* SerializeJSONArray(state, value) {
  if (state.Stack.includes(value)) {
    return surroundingAgent.Throw('TypeError', 'JSONCircular');
  }
  state.Stack.push(value);
  const stepback = state.Indent;
  state.Indent = `${state.Indent}${state.Gap}`;
  const partial = [];
  /* ReturnIfAbrupt */
  let _temp76 = yield* LengthOfArrayLike(value);
  /* node:coverage ignore next */
  if (_temp76 instanceof AbruptCompletion) return _temp76;
  /* node:coverage ignore next */
  if (_temp76 instanceof Completion) _temp76 = _temp76.Value;
  const len = _temp76;
  let index = 0;
  while (index < len) {
    /* X */
    let _temp77 = ToString(F(index));
    /* node:coverage ignore next */
    if (_temp77 && typeof _temp77 === 'object' && 'next' in _temp77) _temp77 = skipDebugger(_temp77);
    /* node:coverage ignore next */
    if (_temp77 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(index)) returned an abrupt completion", {
      cause: _temp77
    });
    /* node:coverage ignore next */
    if (_temp77 instanceof Completion) _temp77 = _temp77.Value;
    const indexStr = _temp77;
    /* ReturnIfAbrupt */
    let _temp78 = yield* SerializeJSONProperty(state, indexStr, value);
    /* node:coverage ignore next */
    if (_temp78 instanceof AbruptCompletion) return _temp78;
    /* node:coverage ignore next */
    if (_temp78 instanceof Completion) _temp78 = _temp78.Value;
    const strP = _temp78;
    if (strP instanceof UndefinedValue) {
      partial.push('null');
    } else {
      partial.push(strP.stringValue());
    }
    index += 1;
  }
  let final;
  if (partial.length === 0) {
    final = Value('[]');
  } else {
    if (state.Gap === '') {
      const properties = partial.join(',');
      final = Value(`[${properties}]`);
    } else {
      const separator = `,\u000A${state.Indent}`;
      const properties = partial.join(separator);
      final = Value(`[\u000A${state.Indent}${properties}\u000A${stepback}]`);
    }
  }
  state.Stack.pop();
  state.Indent = stepback;
  return final;
}
SerializeJSONArray.section = 'https://tc39.es/ecma262/#sec-serializejsonarray';
/** https://tc39.es/ecma262/#sec-json.stringify */
function* JSON_stringify([value = Value.undefined, replacer = Value.undefined, _space = Value.undefined]) {
  const stack = [];
  const indent = '';
  let PropertyList = Value.undefined;
  let ReplacerFunction = Value.undefined;
  if (replacer instanceof ObjectValue) {
    if (IsCallable(replacer)) {
      ReplacerFunction = replacer;
    } else {
      /* ReturnIfAbrupt */
      let _temp79 = IsArray(replacer);
      /* node:coverage ignore next */
      if (_temp79 && typeof _temp79 === 'object' && 'next' in _temp79) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp79 instanceof AbruptCompletion) return _temp79;
      /* node:coverage ignore next */
      if (_temp79 instanceof Completion) _temp79 = _temp79.Value;
      const isArray = _temp79;
      if (isArray === Value.true) {
        PropertyList = new JSStringSet();
        /* ReturnIfAbrupt */
        let _temp80 = yield* LengthOfArrayLike(replacer);
        /* node:coverage ignore next */
        if (_temp80 instanceof AbruptCompletion) return _temp80;
        /* node:coverage ignore next */
        if (_temp80 instanceof Completion) _temp80 = _temp80.Value;
        const len = _temp80;
        let k = 0;
        while (k < len) {
          /* X */
          let _temp81 = ToString(F(k));
          /* node:coverage ignore next */
          if (_temp81 && typeof _temp81 === 'object' && 'next' in _temp81) _temp81 = skipDebugger(_temp81);
          /* node:coverage ignore next */
          if (_temp81 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
            cause: _temp81
          });
          /* node:coverage ignore next */
          if (_temp81 instanceof Completion) _temp81 = _temp81.Value;
          const vStr = _temp81;
          /* ReturnIfAbrupt */
          let _temp82 = yield* Get(replacer, vStr);
          /* node:coverage ignore next */
          if (_temp82 instanceof AbruptCompletion) return _temp82;
          /* node:coverage ignore next */
          if (_temp82 instanceof Completion) _temp82 = _temp82.Value;
          const v = _temp82;
          let item = Value.undefined;
          if (v instanceof JSStringValue) {
            item = v;
          } else if (v instanceof NumberValue) {
            /* X */
            let _temp83 = ToString(v);
            /* node:coverage ignore next */
            if (_temp83 && typeof _temp83 === 'object' && 'next' in _temp83) _temp83 = skipDebugger(_temp83);
            /* node:coverage ignore next */
            if (_temp83 instanceof AbruptCompletion) throw new Assert.Error("! ToString(v) returned an abrupt completion", {
              cause: _temp83
            });
            /* node:coverage ignore next */
            if (_temp83 instanceof Completion) _temp83 = _temp83.Value;
            item = _temp83;
          } else if (v instanceof ObjectValue) {
            if ('StringData' in v || 'NumberData' in v) {
              /* ReturnIfAbrupt */
              let _temp84 = yield* ToString(v);
              /* node:coverage ignore next */
              if (_temp84 instanceof AbruptCompletion) return _temp84;
              /* node:coverage ignore next */
              if (_temp84 instanceof Completion) _temp84 = _temp84.Value;
              item = _temp84;
            }
          }
          if (!(item instanceof UndefinedValue) && !PropertyList.has(item)) {
            PropertyList.add(item);
          }
          k += 1;
        }
      }
    }
  }
  let space = _space;
  if (space instanceof ObjectValue) {
    if ('NumberData' in space) {
      /* ReturnIfAbrupt */
      let _temp85 = yield* ToNumber(space);
      /* node:coverage ignore next */
      if (_temp85 instanceof AbruptCompletion) return _temp85;
      /* node:coverage ignore next */
      if (_temp85 instanceof Completion) _temp85 = _temp85.Value;
      space = _temp85;
    } else if ('StringData' in space) {
      /* ReturnIfAbrupt */
      let _temp86 = yield* ToString(space);
      /* node:coverage ignore next */
      if (_temp86 instanceof AbruptCompletion) return _temp86;
      /* node:coverage ignore next */
      if (_temp86 instanceof Completion) _temp86 = _temp86.Value;
      space = _temp86;
    }
  }
  let gap;
  if (space instanceof NumberValue) {
    /* X */
    let _temp87 = ToIntegerOrInfinity(space);
    /* node:coverage ignore next */
    if (_temp87 && typeof _temp87 === 'object' && 'next' in _temp87) _temp87 = skipDebugger(_temp87);
    /* node:coverage ignore next */
    if (_temp87 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(space) returned an abrupt completion", {
      cause: _temp87
    });
    /* node:coverage ignore next */
    if (_temp87 instanceof Completion) _temp87 = _temp87.Value;
    space = Math.min(10, _temp87);
    if (space < 1) {
      gap = '';
    } else {
      gap = ' '.repeat(space);
    }
  } else if (space instanceof JSStringValue) {
    if (space.stringValue().length <= 10) {
      gap = space.stringValue();
    } else {
      gap = space.stringValue().slice(0, 10);
    }
  } else {
    gap = '';
  }
  const wrapper = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* X */
  let _temp88 = CreateDataPropertyOrThrow(wrapper, Value(''), value);
  /* node:coverage ignore next */
  if (_temp88 && typeof _temp88 === 'object' && 'next' in _temp88) _temp88 = skipDebugger(_temp88);
  /* node:coverage ignore next */
  if (_temp88 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(wrapper, Value(''), value) returned an abrupt completion", {
    cause: _temp88
  });
  /* node:coverage ignore next */
  if (_temp88 instanceof Completion) _temp88 = _temp88.Value;
  const state = {
    ReplacerFunction,
    Stack: stack,
    Indent: indent,
    Gap: gap,
    PropertyList
  };
  return yield* SerializeJSONProperty(state, Value(''), wrapper);
}
JSON_stringify.section = 'https://tc39.es/ecma262/#sec-json.stringify';
function bootstrapJSON(realmRec) {
  const json = bootstrapPrototype(realmRec, [['parse', JSON_parse, 2], ['stringify', JSON_stringify, 3]], realmRec.Intrinsics['%Object.prototype%'], 'JSON');
  realmRec.Intrinsics['%JSON%'] = json;
  /* X */
  let _temp89 = Get(json, Value('parse'));
  /* node:coverage ignore next */
  if (_temp89 && typeof _temp89 === 'object' && 'next' in _temp89) _temp89 = skipDebugger(_temp89);
  /* node:coverage ignore next */
  if (_temp89 instanceof AbruptCompletion) throw new Assert.Error("! Get(json, Value('parse')) returned an abrupt completion", {
    cause: _temp89
  });
  /* node:coverage ignore next */
  if (_temp89 instanceof Completion) _temp89 = _temp89.Value;
  realmRec.Intrinsics['%JSON.parse%'] = _temp89;
  /* X */
  let _temp90 = Get(json, Value('stringify'));
  /* node:coverage ignore next */
  if (_temp90 && typeof _temp90 === 'object' && 'next' in _temp90) _temp90 = skipDebugger(_temp90);
  /* node:coverage ignore next */
  if (_temp90 instanceof AbruptCompletion) throw new Assert.Error("! Get(json, Value('stringify')) returned an abrupt completion", {
    cause: _temp90
  });
  /* node:coverage ignore next */
  if (_temp90 instanceof Completion) _temp90 = _temp90.Value;
  realmRec.Intrinsics['%JSON.stringify%'] = _temp90;
}

function isRegExpObject(o) {
  return 'RegExpMatcher' in o;
}
/** https://tc39.es/ecma262/#sec-regexp-constructor */
function* RegExpConstructor([pattern = Value.undefined, flags = Value.undefined], {
  NewTarget
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* IsRegExp(pattern);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let patternIsRegExp be ? IsRegExp(pattern).
  const patternIsRegExp = _temp;
  let newTarget;
  // 2. If NewTarget is undefined, then
  if (NewTarget === Value.undefined) {
    // a. Let newTarget be the active function object.
    newTarget = surroundingAgent.activeFunctionObject;
    // b. If patternIsRegExp is true and flags is undefined, then
    if (patternIsRegExp === Value.true && flags === Value.undefined) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* Get(pattern, Value('constructor'));
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      // i. Let patternConstructor be ? Get(pattern, "constructor").
      const patternConstructor = _temp2;
      // ii. If SameValue(newTarget, patternConstructor) is true, return pattern.
      if (SameValue(newTarget, patternConstructor) === Value.true) {
        return pattern;
      }
    }
  } else {
    // 3. Else, let newTarget be NewTarget.
    newTarget = NewTarget;
  }
  let P;
  let F;
  // 4. If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, then
  if (isRegExpObject(pattern)) {
    // a. Let P be pattern.[[OriginalSource]].
    P = pattern.OriginalSource;
    // b. If flags is undefined, let F be pattern.[[OriginalFlags]].
    if (flags === Value.undefined) {
      F = pattern.OriginalFlags;
    } else {
      // c. Else, let F be flags.
      F = flags;
    }
  } else if (patternIsRegExp === Value.true) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* Get(pattern, Value('source'));
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // 5. Else if patternIsRegExp is true, then
    // a. Else if patternIsRegExp is true, then
    P = _temp3;
    // b. If flags is undefined, then
    if (flags === Value.undefined) {
      /* ReturnIfAbrupt */
      let _temp4 = yield* Get(pattern, Value('flags'));
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      // i. Let F be ? Get(pattern, "flags").
      F = _temp4;
    } else {
      // c. Else, let F be flags.
      F = flags;
    }
  } else {
    // 6. Else,
    // a. Let P be pattern.
    P = pattern;
    // b. Let F be flags.
    F = flags;
  }
  // 7. Let O be ? RegExpAlloc(newTarget).
  /* ReturnIfAbrupt */
  let _temp5 = yield* RegExpAlloc(newTarget);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const O = _temp5;
  // 8. Return ? RegExpInitialize(O, P, F).
  return yield* RegExpInitialize(O, P, F);
}
RegExpConstructor.section = 'https://tc39.es/ecma262/#sec-regexp-constructor';
/** https://tc39.es/ecma262/#sec-regexp.escape */
function* RegExp_escape([S = Value.undefined]) {
  if (!(S instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAString', S);
  }
  let escaped = '';
  const cpList = StringToCodePoints(S.stringValue());
  for (const cp of cpList) {
    if (escaped === '' && (isDecimalDigit$1(String.fromCodePoint(cp)) || isAsciiLetter(cp))) {
      const numericValue = cp;
      const hex = numericValue.toString(16);
      Assert(hex.length === 2, "hex.length === 2");
      escaped += `\u{005C}x${hex}`;
    } else {
      escaped += EncodeForRegExpEscape(cp);
    }
  }
  return Value(escaped);
}
RegExp_escape.section = 'https://tc39.es/ecma262/#sec-regexp.escape';
const table67 = {
  9: 't',
  10: 'n',
  11: 'v',
  12: 'f',
  13: 'r'
};
function EncodeForRegExpEscape(cp) {
  const ch = String.fromCharCode(cp);
  if (cp === 0x002F || isSyntaxCharacter(ch)) {
    return `\u{005C}${UTF16EncodeCodePoint(cp)}`;
  } else if (isControlEscape(cp)) {
    return `\u{005C}${table67[cp]}`;
  }
  const otherPunctuators = ",-=<>#&!%:;@~'`\u{0022}";
  const toEscape = StringToCodePoints(otherPunctuators);
  if (toEscape.includes(cp) || isWhitespace(ch) || isLineTerminator(ch) || isLeadingSurrogate(cp) || isTrailingSurrogate(cp)) {
    const cpNum = cp;
    if (cpNum <= 0xFF) {
      const hex = cpNum.toString(16);
      return `\u{005C}x${hex.padStart(2, '0')}`;
    }
    let escaped = '';
    const codeUnits = UTF16EncodeCodePoint(cp);
    for (const cu of codeUnits) {
      escaped += UnicodeEscape(cu);
    }
    return escaped;
  }
  return UTF16EncodeCodePoint(cp);
}

/** https://tc39.es/ecma262/#sec-get-regexp-@@species */
function RegExp_speciesGetter(_args, {
  thisValue
}) {
  return thisValue;
}
RegExp_speciesGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp-@@species';
function bootstrapRegExp(realmRec) {
  const proto = realmRec.Intrinsics['%RegExp.prototype%'];
  const cons = bootstrapConstructor(realmRec, RegExpConstructor, 'RegExp', 2, proto, [[wellKnownSymbols.species, [RegExp_speciesGetter]], ['escape', RegExp_escape, 1]]);
  realmRec.Intrinsics['%RegExp%'] = cons;
}

/** https://tc39.es/ecma262/#sec-regexp.prototype.exec */
function* RegExpProto_exec([string = Value.undefined], {
  thisValue
}) {
  const R = thisValue;
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(R, 'RegExpMatcher');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToString(string);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const S = _temp2;
  return yield* RegExpBuiltinExec(R, S);
}
RegExpProto_exec.section = 'https://tc39.es/ecma262/#sec-regexp.prototype.exec';
/** https://tc39.es/ecma262/#sec-regexpexec */
function* RegExpExec(R, S) {
  Assert(R instanceof ObjectValue, "R instanceof ObjectValue");
  Assert(S instanceof JSStringValue, "S instanceof JSStringValue");
  /* ReturnIfAbrupt */
  let _temp3 = yield* Get(R, Value('exec'));
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const exec = _temp3;
  if (IsCallable(exec)) {
    /* ReturnIfAbrupt */
    let _temp4 = yield* Call(exec, R, [S]);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    const result = _temp4;
    if (!(result instanceof ObjectValue) && !(result instanceof NullValue)) {
      return surroundingAgent.Throw('TypeError', 'RegExpExecNotObject', result);
    }
    return result;
  }
  /* ReturnIfAbrupt */
  let _temp5 = RequireInternalSlot(R, 'RegExpMatcher');
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  return yield* RegExpBuiltinExec(R, S);
}
RegExpExec.section = 'https://tc39.es/ecma262/#sec-regexpexec';
/** https://tc39.es/ecma262/#sec-regexpbuiltinexec */
function* RegExpBuiltinExec(R$1, S) {
  // Let length be the number of code units in S.
  const length = S.stringValue().length;
  /* ReturnIfAbrupt */
  let _temp20 = yield* Get(R$1, Value('lastIndex'));
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  /* ReturnIfAbrupt */
  let _temp6 = yield* ToLength(_temp20);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  let lastIndex = R(_temp6);
  const flags = R$1.OriginalFlags.stringValue();
  const global = flags.includes('g');
  const sticky = flags.includes('y');
  const hasIndices = flags.includes('d');
  if (!global && !sticky) {
    lastIndex = 0;
  }
  const matcher = R$1.RegExpMatcher;
  const fullUnicode = flags.includes('u') || flags.includes('v');
  let matchSucceeded = false;
  // If fullUnicode is true, let input be StringToCodePoints(S). Otherwise, let input be a List whose elements are the code units that are the elements of S.
  const input = MatchState.createRegExpMatchingSource(fullUnicode ? Array.from(S.stringValue()) : S.stringValue().split(''), S.stringValue());

  // used to calculate inputIndex below
  const accumulatedInputLength = [];
  if (fullUnicode) {
    for (let index = 0; index < input.length; index += 1) {
      const codePoint = input[index];
      accumulatedInputLength[index] = (accumulatedInputLength[index - 1] ?? 0) + codePoint.length;
    }
  }
  let r;
  while (matchSucceeded === false) {
    if (lastIndex > length) {
      if (global || sticky) {
        /* ReturnIfAbrupt */
        let _temp7 = yield* Set$1(R$1, Value('lastIndex'), F(0), Value.true);
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) return _temp7;
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
      }
      return Value.null;
    }
    // Let inputIndex be the index into input of the character that was obtained from element lastIndex of S.
    let inputIndex;
    if (fullUnicode) {
      inputIndex = accumulatedInputLength.findIndex(x => lastIndex < x);
      if (inputIndex === -1) {
        // lastIndex is greater than all code points
        inputIndex = accumulatedInputLength.length;
      }
    } else {
      inputIndex = lastIndex;
    }
    r = matcher(input, inputIndex);
    if (r === 'failure') {
      if (sticky) {
        /* ReturnIfAbrupt */
        let _temp8 = yield* Set$1(R$1, Value('lastIndex'), F(0), Value.true);
        /* node:coverage ignore next */
        if (_temp8 instanceof AbruptCompletion) return _temp8;
        /* node:coverage ignore next */
        if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        return Value.null;
      }
      lastIndex = AdvanceStringIndex(S, lastIndex, fullUnicode);
    } else {
      Assert(r instanceof MatchState, "r instanceof RegExpState");
      matchSucceeded = true;
    }
  }
  let e = r.endIndex;
  if (fullUnicode) {
    e = GetStringIndex(S, input, e);
  }
  if (global || sticky) {
    /* ReturnIfAbrupt */
    let _temp9 = yield* Set$1(R$1, Value('lastIndex'), F(e), Value.true);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) return _temp9;
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  }
  // Let n be the number of elements in r's captures List.
  // Note: this list is used as 1-indexed, so the 0th element is a hole and do not count as "the number of elements"
  const n = Math.max(0, r.captures.length - 1);
  Assert(r.captures[0] === undefined, "r.captures[0] === undefined");
  Assert(n === R$1.RegExpRecord.CapturingGroupsCount, "n === R.RegExpRecord.CapturingGroupsCount");
  Assert(n < 2 ** 32 - 1, "n < (2 ** 32) - 1");
  /* X */
  let _temp10 = ArrayCreate(n + 1);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(n + 1) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const A = _temp10;
  /* X */
  let _temp11 = Get(A, Value('length'));
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! Get(A, Value('length')) returned an abrupt completion", {
    cause: _temp11
  });
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  Assert(R(_temp11) === n + 1, "MathematicalValue(X(Get(A, Value('length'))) as NumberValue) === n + 1");
  /* X */
  let _temp12 = CreateDataPropertyOrThrow(A, Value('index'), F(lastIndex));
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Value('index'), F(lastIndex)) returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  /* X */
  let _temp13 = CreateDataPropertyOrThrow(A, Value('input'), S);
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Value('input'), S) returned an abrupt completion", {
    cause: _temp13
  });
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  const match = {
    StartIndex: lastIndex,
    EndIndex: e
  };
  const indices = [];
  const groupNames = [];
  indices.push(match);
  const matchedSubStr = GetMatchString(S, match);
  /* X */
  let _temp14 = CreateDataPropertyOrThrow(A, Value('0'), matchedSubStr);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Value('0'), matchedSubStr) returned an abrupt completion", {
    cause: _temp14
  });
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  let groups;
  let hasGroups;
  if (R$1.parsedPattern.capturingGroups.filter(x => x.GroupName).length > 0) {
    groups = OrdinaryObjectCreate(Value.null);
    hasGroups = Value.true;
  } else {
    groups = Value.undefined;
    hasGroups = Value.false;
  }
  /* X */
  let _temp15 = CreateDataPropertyOrThrow(A, Value('groups'), groups);
  /* node:coverage ignore next */
  if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Value('groups'), groups) returned an abrupt completion", {
    cause: _temp15
  });
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const matchedGroupNames = [];
  for (let i = 1; i <= n; i += 1) {
    const captureI = r.captures[i];
    let capturedValue;
    if (!captureI) {
      capturedValue = Value.undefined;
      indices.push(Value.undefined);
    } else {
      let captureStart = captureI.startIndex;
      let captureEnd = captureI.endIndex;
      if (fullUnicode) {
        captureStart = GetStringIndex(S, input, captureStart);
        captureEnd = GetStringIndex(S, input, captureEnd);
      }
      const capture = {
        StartIndex: captureStart,
        EndIndex: captureEnd
      };
      capturedValue = GetMatchString(S, capture);
      indices.push(capture);
    }
    /* X */
    let _temp18 = ToString(F(i));
    /* node:coverage ignore next */
    if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(i)) returned an abrupt completion", {
      cause: _temp18
    });
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    /* X */
    let _temp16 = CreateDataPropertyOrThrow(A, _temp18, capturedValue);
    /* node:coverage ignore next */
    if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(F(i))), capturedValue) returned an abrupt completion", {
      cause: _temp16
    });
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    const i_th = i - 1;
    if (R$1.parsedPattern.capturingGroups[i_th].GroupName) {
      const s = Value(R$1.parsedPattern.capturingGroups[i_th].GroupName);
      if (matchedGroupNames.includes(s.stringValue())) {
        Assert(capturedValue === Value.undefined, "capturedValue === Value.undefined");
        groupNames.push(Value.undefined);
      } else {
        if (capturedValue !== Value.undefined) {
          matchedGroupNames.push(s.stringValue());
        }
        /* X */
        let _temp17 = CreateDataPropertyOrThrow(groups, s, capturedValue);
        /* node:coverage ignore next */
        if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
        /* node:coverage ignore next */
        if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(groups as ObjectValue, s, capturedValue) returned an abrupt completion", {
          cause: _temp17
        });
        /* node:coverage ignore next */
        if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
        groupNames.push(s);
      }
    } else {
      groupNames.push(Value.undefined);
    }
  }
  if (hasIndices) {
    const indicesArray = MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups);
    /* X */
    let _temp19 = CreateDataPropertyOrThrow(A, Value('indices'), indicesArray);
    /* node:coverage ignore next */
    if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Value('indices'), indicesArray) returned an abrupt completion", {
      cause: _temp19
    });
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  }
  return A;
}
RegExpBuiltinExec.section = 'https://tc39.es/ecma262/#sec-regexpbuiltinexec';
/** https://tc39.es/ecma262/#sec-advancestringindex */
function AdvanceStringIndex(S, index, unicode) {
  Assert(index <= 2 ** 53 - 1, "index <= (2 ** 53) - 1");
  if (!unicode) {
    return index + 1;
  }
  const length = S.stringValue().length;
  if (index + 1 >= length) {
    return index + 1;
  }
  const cp = CodePointAt(S.stringValue(), index);
  return index + cp.CodeUnitCount;
}
AdvanceStringIndex.section = 'https://tc39.es/ecma262/#sec-advancestringindex';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.dotAll */
function RegExpProto_dotAllGetter(_args, {
  thisValue
}) {
  // 1. Let R be the this value.
  const R = thisValue;
  // 2. Let cu be the code unit 0x0073 (LATIN SMALL LETTER S).
  const cu = 's';
  // 3. Return ? RegExpHasFlag(R, cu).
  return RegExpHasFlag(R, cu);
}
RegExpProto_dotAllGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.dotAll';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.flags */
function* RegExpProto_flagsGetter(_args, {
  thisValue
}) {
  const R = thisValue;
  if (!(R instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  let result = '';
  /* ReturnIfAbrupt */
  let _temp21 = yield* Get(R, Value('hasIndices'));
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  const hasIndices = ToBoolean(_temp21);
  if (hasIndices === Value.true) {
    result += 'd';
  }
  /* ReturnIfAbrupt */
  let _temp22 = yield* Get(R, Value('global'));
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) return _temp22;
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  const global = ToBoolean(_temp22);
  if (global === Value.true) {
    result += 'g';
  }
  /* ReturnIfAbrupt */
  let _temp23 = yield* Get(R, Value('ignoreCase'));
  /* node:coverage ignore next */
  if (_temp23 instanceof AbruptCompletion) return _temp23;
  /* node:coverage ignore next */
  if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
  const ignoreCase = ToBoolean(_temp23);
  if (ignoreCase === Value.true) {
    result += 'i';
  }
  /* ReturnIfAbrupt */
  let _temp24 = yield* Get(R, Value('multiline'));
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) return _temp24;
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  const multiline = ToBoolean(_temp24);
  if (multiline === Value.true) {
    result += 'm';
  }
  /* ReturnIfAbrupt */
  let _temp25 = yield* Get(R, Value('dotAll'));
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  const dotAll = ToBoolean(_temp25);
  if (dotAll === Value.true) {
    result += 's';
  }
  /* ReturnIfAbrupt */
  let _temp26 = yield* Get(R, Value('unicode'));
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  const unicode = ToBoolean(_temp26);
  if (unicode === Value.true) {
    result += 'u';
  }
  /* ReturnIfAbrupt */
  let _temp27 = yield* Get(R, Value('unicodeSets'));
  /* node:coverage ignore next */
  if (_temp27 instanceof AbruptCompletion) return _temp27;
  /* node:coverage ignore next */
  if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
  const unicodeSet = ToBoolean(_temp27);
  if (unicodeSet === Value.true) {
    result += 'v';
  }
  /* ReturnIfAbrupt */
  let _temp28 = yield* Get(R, Value('sticky'));
  /* node:coverage ignore next */
  if (_temp28 instanceof AbruptCompletion) return _temp28;
  /* node:coverage ignore next */
  if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
  const sticky = ToBoolean(_temp28);
  if (sticky === Value.true) {
    result += 'y';
  }
  return Value(result);
}
RegExpProto_flagsGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.flags';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.global */
function RegExpProto_globalGetter(_args, {
  thisValue
}) {
  const R = thisValue;
  if (!(R instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  if (!('OriginalFlags' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value.undefined;
    }
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  const flags = R.OriginalFlags;
  if (flags.stringValue().includes('g')) {
    return Value.true;
  }
  return Value.false;
}
RegExpProto_globalGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.global';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.hasIndices */
function RegExpProto_hasIndicesGetter(_args, {
  thisValue
}) {
  // 1. Let R be the this value.
  const R = thisValue;
  // 2. Let cu be the code unit 0x0073 (LATIN SMALL LETTER D).
  const cu = 'd';
  // 3. Return ? RegExpHasFlag(R, cu).
  return RegExpHasFlag(R, cu);
}
RegExpProto_hasIndicesGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.hasIndices';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.ignorecase */
function RegExpProto_ignoreCaseGetter(_args, {
  thisValue
}) {
  // 1. Let R be the this value.
  const R = thisValue;
  // 2. Let cu be the code unit 0x0069 (LATIN SMALL LETTER I).
  const cu = 'i';
  // 3. Return ? RegExpHasFlag(R, cu).
  return RegExpHasFlag(R, cu);
}
RegExpProto_ignoreCaseGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.ignorecase';
/** https://tc39.es/ecma262/#sec-regexp.prototype-@@match */
function* RegExpProto_match([string = Value.undefined], {
  thisValue
}) {
  // 1. Let rx be the this value.
  const rx = thisValue;
  // 2. If Type(rx) is not Object, throw a TypeError exception.
  if (!(rx instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', rx);
  }
  // 3. Let S be ? ToString(string).
  /* ReturnIfAbrupt */
  let _temp29 = yield* ToString(string);
  /* node:coverage ignore next */
  if (_temp29 instanceof AbruptCompletion) return _temp29;
  /* node:coverage ignore next */
  if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
  const S = _temp29;
  // 4. Let flags be ? ToString(? Get(rx, "flags")).
  /* ReturnIfAbrupt */
  let _temp41 = yield* Get(rx, Value('flags'));
  /* node:coverage ignore next */
  if (_temp41 instanceof AbruptCompletion) return _temp41;
  /* node:coverage ignore next */
  if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
  /* ReturnIfAbrupt */
  let _temp30 = yield* ToString(_temp41);
  /* node:coverage ignore next */
  if (_temp30 instanceof AbruptCompletion) return _temp30;
  /* node:coverage ignore next */
  if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
  const flags = _temp30;
  // 5. If flags does not contain "g", then
  if (!flags.stringValue().includes('g')) {
    // a. Return ? RegExpExec(rx, S).
    return yield* RegExpExec(rx, S);
  } else {
    // 6. Else,
    // a. If flags contains "u", let fullUnicode be true. Otherwise, let fullUnicode be false.
    const fullUnicode = flags.stringValue().includes('u');
    // b. Perform ? Set(rx, "lastIndex", +0𝔽, true).
    /* ReturnIfAbrupt */
    let _temp31 = yield* Set$1(rx, Value('lastIndex'), F(0), Value.true);
    /* node:coverage ignore next */
    if (_temp31 instanceof AbruptCompletion) return _temp31;
    /* node:coverage ignore next */
    if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
    // c. Let A be ! ArrayCreate(0).
    /* X */
    let _temp32 = ArrayCreate(0);
    /* node:coverage ignore next */
    if (_temp32 && typeof _temp32 === 'object' && 'next' in _temp32) _temp32 = skipDebugger(_temp32);
    /* node:coverage ignore next */
    if (_temp32 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
      cause: _temp32
    });
    /* node:coverage ignore next */
    if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
    const A = _temp32;
    // d. Let n be 0.
    let n = 0;
    // e. Repeat,
    while (true) {
      /* ReturnIfAbrupt */
      let _temp33 = yield* RegExpExec(rx, S);
      /* node:coverage ignore next */
      if (_temp33 instanceof AbruptCompletion) return _temp33;
      /* node:coverage ignore next */
      if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
      // i. Let result be ? RegExpExec(rx, S).
      const result = _temp33;
      // ii. If result is null, then
      if (result instanceof NullValue) {
        // 1. If n = 0, return null.
        if (n === 0) {
          return Value.null;
        }
        // 2. Return A.
        return A;
      } else {
        /* ReturnIfAbrupt */
        let _temp39 = yield* Get(result, Value('0'));
        /* node:coverage ignore next */
        if (_temp39 instanceof AbruptCompletion) return _temp39;
        /* node:coverage ignore next */
        if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
        /* ReturnIfAbrupt */
        let _temp34 = yield* ToString(_temp39);
        /* node:coverage ignore next */
        if (_temp34 instanceof AbruptCompletion) return _temp34;
        /* node:coverage ignore next */
        if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
        // iii. Else,
        // 1. Let matchStr be ? ToString(? Get(result, "0")).
        const matchStr = _temp34;
        // 2. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), matchStr).
        /* X */
        let _temp40 = ToString(F(n));
        /* node:coverage ignore next */
        if (_temp40 && typeof _temp40 === 'object' && 'next' in _temp40) _temp40 = skipDebugger(_temp40);
        /* node:coverage ignore next */
        if (_temp40 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
          cause: _temp40
        });
        /* node:coverage ignore next */
        if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
        /* X */
        let _temp35 = CreateDataPropertyOrThrow(A, _temp40, matchStr);
        /* node:coverage ignore next */
        if (_temp35 && typeof _temp35 === 'object' && 'next' in _temp35) _temp35 = skipDebugger(_temp35);
        /* node:coverage ignore next */
        if (_temp35 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(F(n))), matchStr) returned an abrupt completion", {
          cause: _temp35
        });
        /* node:coverage ignore next */
        if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
        // 3. If matchStr is the empty String, then
        if (matchStr.stringValue() === '') {
          /* ReturnIfAbrupt */
          let _temp38 = yield* Get(rx, Value('lastIndex'));
          /* node:coverage ignore next */
          if (_temp38 instanceof AbruptCompletion) return _temp38;
          /* node:coverage ignore next */
          if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
          /* ReturnIfAbrupt */
          let _temp36 = yield* ToLength(_temp38);
          /* node:coverage ignore next */
          if (_temp36 instanceof AbruptCompletion) return _temp36;
          /* node:coverage ignore next */
          if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
          // a. Let thisIndex be ℝ(? ToLength(? Get(rx, "lastIndex"))).
          const thisIndex = R(_temp36);
          // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).
          const nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
          // c. Perform ? Set(rx, "lastIndex", 𝔽(nextIndex), true).
          /* ReturnIfAbrupt */
          let _temp37 = yield* Set$1(rx, Value('lastIndex'), F(nextIndex), Value.true);
          /* node:coverage ignore next */
          if (_temp37 instanceof AbruptCompletion) return _temp37;
          /* node:coverage ignore next */
          if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
        }
        // 4. Set n to n + 1.
        n += 1;
      }
    }
  }
}
RegExpProto_match.section = 'https://tc39.es/ecma262/#sec-regexp.prototype-@@match';
/** https://tc39.es/ecma262/#sec-regexp-prototype-matchall */
function* RegExpProto_matchAll([string = Value.undefined], {
  thisValue
}) {
  const R = thisValue;
  if (!(R instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  /* ReturnIfAbrupt */
  let _temp42 = yield* ToString(string);
  /* node:coverage ignore next */
  if (_temp42 instanceof AbruptCompletion) return _temp42;
  /* node:coverage ignore next */
  if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
  const S = _temp42;
  /* ReturnIfAbrupt */
  let _temp43 = yield* SpeciesConstructor(R, surroundingAgent.intrinsic('%RegExp%'));
  /* node:coverage ignore next */
  if (_temp43 instanceof AbruptCompletion) return _temp43;
  /* node:coverage ignore next */
  if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
  const C = _temp43;
  /* ReturnIfAbrupt */
  let _temp48 = yield* Get(R, Value('flags'));
  /* node:coverage ignore next */
  if (_temp48 instanceof AbruptCompletion) return _temp48;
  /* node:coverage ignore next */
  if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
  /* ReturnIfAbrupt */
  let _temp44 = yield* ToString(_temp48);
  /* node:coverage ignore next */
  if (_temp44 instanceof AbruptCompletion) return _temp44;
  /* node:coverage ignore next */
  if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
  const flags = _temp44;
  /* ReturnIfAbrupt */
  let _temp45 = yield* Construct(C, [R, flags]);
  /* node:coverage ignore next */
  if (_temp45 instanceof AbruptCompletion) return _temp45;
  /* node:coverage ignore next */
  if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
  const matcher = _temp45;
  /* ReturnIfAbrupt */
  let _temp49 = yield* Get(R, Value('lastIndex'));
  /* node:coverage ignore next */
  if (_temp49 instanceof AbruptCompletion) return _temp49;
  /* node:coverage ignore next */
  if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
  /* ReturnIfAbrupt */
  let _temp46 = yield* ToLength(_temp49);
  /* node:coverage ignore next */
  if (_temp46 instanceof AbruptCompletion) return _temp46;
  /* node:coverage ignore next */
  if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
  const lastIndex = _temp46;
  /* ReturnIfAbrupt */
  let _temp47 = yield* Set$1(matcher, Value('lastIndex'), lastIndex, Value.true);
  /* node:coverage ignore next */
  if (_temp47 instanceof AbruptCompletion) return _temp47;
  /* node:coverage ignore next */
  if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
  const global = flags.stringValue().includes('g');
  const fullUnicode = flags.stringValue().includes('u') || flags.stringValue().includes('v');
  return CreateRegExpStringIterator(matcher, S, global, fullUnicode);
}
RegExpProto_matchAll.section = 'https://tc39.es/ecma262/#sec-regexp-prototype-matchall';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.multiline */
function RegExpProto_multilineGetter(_args, {
  thisValue
}) {
  // 1. Let R be the this value.
  const R = thisValue;
  // 2. Let cu be the code unit 0x006D (LATIN SMALL LETTER M).
  const cu = 'm';
  // 3. Return ? RegExpHasFlag(R, cu).
  return RegExpHasFlag(R, cu);
}
RegExpProto_multilineGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.multiline';
/** https://tc39.es/ecma262/#sec-regexp.prototype-@@replace */
function* RegExpProto_replace([string = Value.undefined, replaceValue = Value.undefined], {
  thisValue
}) {
  // 1. Let rx be the this value.
  const rx = thisValue;
  // 2. If rx is not an Object, throw a TypeError exception.
  if (!(rx instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', rx);
  }
  // 3. Let S be ? ToString(string).
  /* ReturnIfAbrupt */
  let _temp50 = yield* ToString(string);
  /* node:coverage ignore next */
  if (_temp50 instanceof AbruptCompletion) return _temp50;
  /* node:coverage ignore next */
  if (_temp50 instanceof Completion) _temp50 = _temp50.Value;
  const S = _temp50;
  // 4. Let lengthS be the length of S.
  const lengthS = S.stringValue().length;
  // 5. Let functionalReplace be IsCallable(replaceValue).
  const functionalReplace = IsCallable(replaceValue);
  // 6. If functionalReplace is false, then
  if (!functionalReplace) {
    /* ReturnIfAbrupt */
    let _temp51 = yield* ToString(replaceValue);
    /* node:coverage ignore next */
    if (_temp51 instanceof AbruptCompletion) return _temp51;
    /* node:coverage ignore next */
    if (_temp51 instanceof Completion) _temp51 = _temp51.Value;
    // a. Set replaceValue to ? ToString(replaceValue).
    replaceValue = _temp51;
  }
  // 7. Let flags be ? ToString(? Get(rx, "flags")).
  /* ReturnIfAbrupt */
  let _temp73 = yield* Get(rx, Value('flags'));
  /* node:coverage ignore next */
  if (_temp73 instanceof AbruptCompletion) return _temp73;
  /* node:coverage ignore next */
  if (_temp73 instanceof Completion) _temp73 = _temp73.Value;
  /* ReturnIfAbrupt */
  let _temp52 = yield* ToString(_temp73);
  /* node:coverage ignore next */
  if (_temp52 instanceof AbruptCompletion) return _temp52;
  /* node:coverage ignore next */
  if (_temp52 instanceof Completion) _temp52 = _temp52.Value;
  const flags = _temp52;
  // 8. If flags contains "g", let global be true. Otherwise, let global be false.
  const global = flags.stringValue().includes('g') ? Value.true : Value.false;
  let fullUnicode;
  // 9. If global is true, then
  if (global === Value.true) {
    // a. If flags contains "u", let fullUnicode be true. Otherwise, let fullUnicode be false.
    fullUnicode = flags.stringValue().includes('u');
    // b. Perform ? Set(rx, "lastIndex", +0𝔽, true).
    /* ReturnIfAbrupt */
    let _temp53 = yield* Set$1(rx, Value('lastIndex'), F(0), Value.true);
    /* node:coverage ignore next */
    if (_temp53 instanceof AbruptCompletion) return _temp53;
    /* node:coverage ignore next */
    if (_temp53 instanceof Completion) _temp53 = _temp53.Value;
  }
  // 10. Let results be a new empty List.
  const results = [];
  // 11. Let done be false.
  let done = false;
  // 12. Repeat, while done is false,
  while (!done) {
    /* ReturnIfAbrupt */
    let _temp54 = yield* RegExpExec(rx, S);
    /* node:coverage ignore next */
    if (_temp54 instanceof AbruptCompletion) return _temp54;
    /* node:coverage ignore next */
    if (_temp54 instanceof Completion) _temp54 = _temp54.Value;
    // a. Let result be ? RegExpExec(rx, S).
    const result = _temp54;
    // b. If result is null, set done to true.
    if (result instanceof NullValue) {
      done = true;
    } else {
      // c. Else,
      // i. Append result to results.
      results.push(result);
      // ii. If global is false, set done to true.
      if (global === Value.false) {
        done = true;
      } else {
        /* ReturnIfAbrupt */
        let _temp59 = yield* Get(result, Value('0'));
        /* node:coverage ignore next */
        if (_temp59 instanceof AbruptCompletion) return _temp59;
        /* node:coverage ignore next */
        if (_temp59 instanceof Completion) _temp59 = _temp59.Value;
        /* ReturnIfAbrupt */
        let _temp55 = yield* ToString(_temp59);
        /* node:coverage ignore next */
        if (_temp55 instanceof AbruptCompletion) return _temp55;
        /* node:coverage ignore next */
        if (_temp55 instanceof Completion) _temp55 = _temp55.Value;
        // iii. Else,
        // 1. Let matchStr be ? ToString(? Get(result, "0")).
        const matchStr = _temp55;
        // 2. If matchStr is the empty String, then
        if (matchStr.stringValue() === '') {
          /* ReturnIfAbrupt */
          let _temp58 = yield* Get(rx, Value('lastIndex'));
          /* node:coverage ignore next */
          if (_temp58 instanceof AbruptCompletion) return _temp58;
          /* node:coverage ignore next */
          if (_temp58 instanceof Completion) _temp58 = _temp58.Value;
          /* ReturnIfAbrupt */
          let _temp56 = yield* ToLength(_temp58);
          /* node:coverage ignore next */
          if (_temp56 instanceof AbruptCompletion) return _temp56;
          /* node:coverage ignore next */
          if (_temp56 instanceof Completion) _temp56 = _temp56.Value;
          // a. Let thisIndex be ℝ(? ToLength(? Get(rx, "lastIndex"))).
          const thisIndex = R(_temp56);
          // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).
          const nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
          // c. Perform ? Set(rx, "lastIndex", 𝔽(nextIndex), true).
          /* ReturnIfAbrupt */
          let _temp57 = yield* Set$1(rx, Value('lastIndex'), F(nextIndex), Value.true);
          /* node:coverage ignore next */
          if (_temp57 instanceof AbruptCompletion) return _temp57;
          /* node:coverage ignore next */
          if (_temp57 instanceof Completion) _temp57 = _temp57.Value;
        }
      }
    }
  }
  // 13. Let accumulatedResult be the empty String.
  let accumulatedResult = '';
  // 14. Let nextSourcePosition be 0.
  let nextSourcePosition = 0;
  // 15. For each element result of results, do
  for (const result of results) {
    /* ReturnIfAbrupt */
    let _temp60 = yield* LengthOfArrayLike(result);
    /* node:coverage ignore next */
    if (_temp60 instanceof AbruptCompletion) return _temp60;
    /* node:coverage ignore next */
    if (_temp60 instanceof Completion) _temp60 = _temp60.Value;
    // a. Let resultLength be ? LengthOfArrayLike(result).
    let nCaptures = _temp60;
    // b. Let nCaptures be max(resultLength - 1, 0).
    nCaptures = Math.max(nCaptures - 1, 0);
    // c. Let matched be ? ToString(? Get(result, "0")).
    /* ReturnIfAbrupt */
    let _temp71 = yield* Get(result, Value('0'));
    /* node:coverage ignore next */
    if (_temp71 instanceof AbruptCompletion) return _temp71;
    /* node:coverage ignore next */
    if (_temp71 instanceof Completion) _temp71 = _temp71.Value;
    /* ReturnIfAbrupt */
    let _temp61 = yield* ToString(_temp71);
    /* node:coverage ignore next */
    if (_temp61 instanceof AbruptCompletion) return _temp61;
    /* node:coverage ignore next */
    if (_temp61 instanceof Completion) _temp61 = _temp61.Value;
    const matched = _temp61;
    // d. Let matchLength be the length of matched.
    const matchLength = matched.stringValue().length;
    // e. Let position be ? ToIntegerOrInfinity(? Get(result, "index")).
    /* ReturnIfAbrupt */
    let _temp72 = yield* Get(result, Value('index'));
    /* node:coverage ignore next */
    if (_temp72 instanceof AbruptCompletion) return _temp72;
    /* node:coverage ignore next */
    if (_temp72 instanceof Completion) _temp72 = _temp72.Value;
    /* ReturnIfAbrupt */
    let _temp62 = yield* ToIntegerOrInfinity(_temp72);
    /* node:coverage ignore next */
    if (_temp62 instanceof AbruptCompletion) return _temp62;
    /* node:coverage ignore next */
    if (_temp62 instanceof Completion) _temp62 = _temp62.Value;
    let position = _temp62;
    // f. Set position to the result of clamping position between 0 and lengthS.
    position = Math.max(Math.min(position, lengthS), 0);
    // g. Let captures be a new empty List.
    const captures = [];
    // h. Let n be 1.
    let n = 1;
    // i. Repeat, while n ≤ nCaptures,
    while (n <= nCaptures) {
      /* X */
      let _temp65 = ToString(F(n));
      /* node:coverage ignore next */
      if (_temp65 && typeof _temp65 === 'object' && 'next' in _temp65) _temp65 = skipDebugger(_temp65);
      /* node:coverage ignore next */
      if (_temp65 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
        cause: _temp65
      });
      /* node:coverage ignore next */
      if (_temp65 instanceof Completion) _temp65 = _temp65.Value;
      /* ReturnIfAbrupt */
      let _temp63 = yield* Get(result, _temp65);
      /* node:coverage ignore next */
      if (_temp63 instanceof AbruptCompletion) return _temp63;
      /* node:coverage ignore next */
      if (_temp63 instanceof Completion) _temp63 = _temp63.Value;
      // i. Let capN be ? Get(result, ! ToString(𝔽(n))).
      let capN = _temp63;
      // ii. If capN is not undefined, then
      if (capN !== Value.undefined) {
        /* ReturnIfAbrupt */
        let _temp64 = yield* ToString(capN);
        /* node:coverage ignore next */
        if (_temp64 instanceof AbruptCompletion) return _temp64;
        /* node:coverage ignore next */
        if (_temp64 instanceof Completion) _temp64 = _temp64.Value;
        // 1. Set capN to ? ToString(capN).
        capN = _temp64;
      }
      // iii. Append capN to captures.
      captures.push(capN);
      // iv. NOTE: When n = 1, the preceding step puts the first element into captures
      //     (at index 0). More generally, the nth capture (the characters captured by
      //     the nth set of capturing parentheses) is at captures[n - 1].
      // v. Set n to n + 1.
      n += 1;
    }
    // j. Let namedCaptures be ? Get(result, "groups").
    /* ReturnIfAbrupt */
    let _temp66 = yield* Get(result, Value('groups'));
    /* node:coverage ignore next */
    if (_temp66 instanceof AbruptCompletion) return _temp66;
    /* node:coverage ignore next */
    if (_temp66 instanceof Completion) _temp66 = _temp66.Value;
    let namedCaptures = _temp66;
    let replacement;
    // k. If functionalReplace is true, then
    if (functionalReplace) {
      // i. Let replacerArgs be the list-concatenation of « matched », captures, and « 𝔽(position), S ».
      const replacerArgs = [matched, ...captures, F(position), S];
      // ii. If namedCaptures is not undefined, then
      if (namedCaptures !== Value.undefined) {
        // 1. Append namedCaptures to replacerArgs.
        replacerArgs.push(namedCaptures);
      }
      // iii. Let replValue be ? Call(replaceValue, undefined, replacerArgs).
      /* ReturnIfAbrupt */
      let _temp67 = yield* Call(replaceValue, Value.undefined, replacerArgs);
      /* node:coverage ignore next */
      if (_temp67 instanceof AbruptCompletion) return _temp67;
      /* node:coverage ignore next */
      if (_temp67 instanceof Completion) _temp67 = _temp67.Value;
      const replValue = _temp67;
      // iv. Let replacement be ? ToString(replValue).
      /* ReturnIfAbrupt */
      let _temp68 = yield* ToString(replValue);
      /* node:coverage ignore next */
      if (_temp68 instanceof AbruptCompletion) return _temp68;
      /* node:coverage ignore next */
      if (_temp68 instanceof Completion) _temp68 = _temp68.Value;
      replacement = _temp68;
    } else {
      // l. Else,
      // i. If namedCaptures is not undefined, then
      if (namedCaptures !== Value.undefined) {
        /* ReturnIfAbrupt */
        let _temp69 = ToObject(namedCaptures);
        /* node:coverage ignore next */
        if (_temp69 && typeof _temp69 === 'object' && 'next' in _temp69) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp69 instanceof AbruptCompletion) return _temp69;
        /* node:coverage ignore next */
        if (_temp69 instanceof Completion) _temp69 = _temp69.Value;
        // 1. Set namedCaptures to ? ToObject(namedCaptures).
        namedCaptures = _temp69;
      }
      // ii. Let replacement be ? GetSubstitution(matched, S, position, captures, namedCaptures, replaceValue).
      /* ReturnIfAbrupt */
      let _temp70 = yield* GetSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      /* node:coverage ignore next */
      if (_temp70 instanceof AbruptCompletion) return _temp70;
      /* node:coverage ignore next */
      if (_temp70 instanceof Completion) _temp70 = _temp70.Value;
      replacement = _temp70;
    }
    // m. If position ≥ nextSourcePosition, then
    if (position >= nextSourcePosition) {
      // i. NOTE: position should not normally move backwards. If it does, it is an indication of an
      //          ill-behaving RegExp subclass or use of an access triggered side-effect to change the
      //          global flag or other characteristics of rx. In such cases, the corresponding substitution is ignored.
      // ii. Set accumulatedResult to the string-concatenation of accumulatedResult, the substring of S from nextSourcePosition to position, and replacement.
      accumulatedResult = accumulatedResult + S.stringValue().substring(nextSourcePosition, position) + replacement.stringValue();
      // iii. Set nextSourcePosition to position + matchLength.
      nextSourcePosition = position + matchLength;
    }
  }
  // 16. If nextSourcePosition ≥ lengthS, return accumulatedResult.
  if (nextSourcePosition >= lengthS) {
    return Value(accumulatedResult);
  }
  // 17. Return the string-concatenation of accumulatedResult and the substring of S from nextSourcePosition.
  return Value(accumulatedResult + S.stringValue().substring(nextSourcePosition));
}
RegExpProto_replace.section = 'https://tc39.es/ecma262/#sec-regexp.prototype-@@replace';
/** https://tc39.es/ecma262/#sec-regexp.prototype-@@search */
function* RegExpProto_search([string = Value.undefined], {
  thisValue
}) {
  const rx = thisValue;
  if (!(rx instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', rx);
  }
  /* ReturnIfAbrupt */
  let _temp74 = yield* ToString(string);
  /* node:coverage ignore next */
  if (_temp74 instanceof AbruptCompletion) return _temp74;
  /* node:coverage ignore next */
  if (_temp74 instanceof Completion) _temp74 = _temp74.Value;
  const S = _temp74;
  /* ReturnIfAbrupt */
  let _temp75 = yield* Get(rx, Value('lastIndex'));
  /* node:coverage ignore next */
  if (_temp75 instanceof AbruptCompletion) return _temp75;
  /* node:coverage ignore next */
  if (_temp75 instanceof Completion) _temp75 = _temp75.Value;
  const previousLastIndex = _temp75;
  if (SameValue(previousLastIndex, F(0)) === Value.false) {
    /* ReturnIfAbrupt */
    let _temp76 = yield* Set$1(rx, Value('lastIndex'), F(0), Value.true);
    /* node:coverage ignore next */
    if (_temp76 instanceof AbruptCompletion) return _temp76;
    /* node:coverage ignore next */
    if (_temp76 instanceof Completion) _temp76 = _temp76.Value;
  }
  /* ReturnIfAbrupt */
  let _temp77 = yield* RegExpExec(rx, S);
  /* node:coverage ignore next */
  if (_temp77 instanceof AbruptCompletion) return _temp77;
  /* node:coverage ignore next */
  if (_temp77 instanceof Completion) _temp77 = _temp77.Value;
  const result = _temp77;
  /* ReturnIfAbrupt */
  let _temp78 = yield* Get(rx, Value('lastIndex'));
  /* node:coverage ignore next */
  if (_temp78 instanceof AbruptCompletion) return _temp78;
  /* node:coverage ignore next */
  if (_temp78 instanceof Completion) _temp78 = _temp78.Value;
  const currentLastIndex = _temp78;
  if (SameValue(currentLastIndex, previousLastIndex) === Value.false) {
    /* ReturnIfAbrupt */
    let _temp79 = yield* Set$1(rx, Value('lastIndex'), previousLastIndex, Value.true);
    /* node:coverage ignore next */
    if (_temp79 instanceof AbruptCompletion) return _temp79;
    /* node:coverage ignore next */
    if (_temp79 instanceof Completion) _temp79 = _temp79.Value;
  }
  if (result instanceof NullValue) {
    return F(-1);
  }
  return yield* Get(result, Value('index'));
}
RegExpProto_search.section = 'https://tc39.es/ecma262/#sec-regexp.prototype-@@search';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.source */
function RegExpProto_sourceGetter(_args, {
  thisValue
}) {
  const R = thisValue;
  if (!(R instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  if (!('OriginalSource' in R)) {
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value('(?:)');
    }
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  Assert(isRegExpObject(R), "isRegExpObject(R)");
  const src = R.OriginalSource;
  R.OriginalFlags;
  return EscapeRegExpPattern(src);
}
RegExpProto_sourceGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.source';
/** https://tc39.es/ecma262/#sec-regexp.prototype-@@split */
function* RegExpProto_split([string = Value.undefined, limit = Value.undefined], {
  thisValue
}) {
  const rx = thisValue;
  if (!(rx instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', rx);
  }
  /* ReturnIfAbrupt */
  let _temp80 = yield* ToString(string);
  /* node:coverage ignore next */
  if (_temp80 instanceof AbruptCompletion) return _temp80;
  /* node:coverage ignore next */
  if (_temp80 instanceof Completion) _temp80 = _temp80.Value;
  const S = _temp80;
  /* ReturnIfAbrupt */
  let _temp81 = yield* SpeciesConstructor(rx, surroundingAgent.intrinsic('%RegExp%'));
  /* node:coverage ignore next */
  if (_temp81 instanceof AbruptCompletion) return _temp81;
  /* node:coverage ignore next */
  if (_temp81 instanceof Completion) _temp81 = _temp81.Value;
  const C = _temp81;
  /* ReturnIfAbrupt */
  let _temp82 = yield* Get(rx, Value('flags'));
  /* node:coverage ignore next */
  if (_temp82 instanceof AbruptCompletion) return _temp82;
  /* node:coverage ignore next */
  if (_temp82 instanceof Completion) _temp82 = _temp82.Value;
  const flagsValue = _temp82;
  /* ReturnIfAbrupt */
  let _temp83 = yield* ToString(flagsValue);
  /* node:coverage ignore next */
  if (_temp83 instanceof AbruptCompletion) return _temp83;
  /* node:coverage ignore next */
  if (_temp83 instanceof Completion) _temp83 = _temp83.Value;
  const flags = _temp83.stringValue();
  const unicodeMatching = flags.includes('u');
  const newFlags = flags.includes('y') ? Value(flags) : Value(`${flags}y`);
  /* ReturnIfAbrupt */
  let _temp84 = yield* Construct(C, [rx, newFlags]);
  /* node:coverage ignore next */
  if (_temp84 instanceof AbruptCompletion) return _temp84;
  /* node:coverage ignore next */
  if (_temp84 instanceof Completion) _temp84 = _temp84.Value;
  const splitter = _temp84;
  /* X */
  let _temp85 = ArrayCreate(0);
  /* node:coverage ignore next */
  if (_temp85 && typeof _temp85 === 'object' && 'next' in _temp85) _temp85 = skipDebugger(_temp85);
  /* node:coverage ignore next */
  if (_temp85 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
    cause: _temp85
  });
  /* node:coverage ignore next */
  if (_temp85 instanceof Completion) _temp85 = _temp85.Value;
  const A = _temp85;
  let lengthA = 0;
  let lim;
  if (limit === Value.undefined) {
    lim = 2 ** 32 - 1;
  } else {
    /* ReturnIfAbrupt */
    let _temp86 = yield* ToUint32(limit);
    /* node:coverage ignore next */
    if (_temp86 instanceof AbruptCompletion) return _temp86;
    /* node:coverage ignore next */
    if (_temp86 instanceof Completion) _temp86 = _temp86.Value;
    lim = R(_temp86);
  }
  const size = S.stringValue().length;
  let p = 0;
  if (lim === 0) {
    return A;
  }
  if (size === 0) {
    /* ReturnIfAbrupt */
    let _temp87 = yield* RegExpExec(splitter, S);
    /* node:coverage ignore next */
    if (_temp87 instanceof AbruptCompletion) return _temp87;
    /* node:coverage ignore next */
    if (_temp87 instanceof Completion) _temp87 = _temp87.Value;
    const z = _temp87;
    if (z !== Value.null) {
      return A;
    }
    /* X */
    let _temp88 = CreateDataProperty(A, Value('0'), S);
    /* node:coverage ignore next */
    if (_temp88 && typeof _temp88 === 'object' && 'next' in _temp88) _temp88 = skipDebugger(_temp88);
    /* node:coverage ignore next */
    if (_temp88 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(A, Value('0'), S) returned an abrupt completion", {
      cause: _temp88
    });
    /* node:coverage ignore next */
    if (_temp88 instanceof Completion) _temp88 = _temp88.Value;
    return A;
  }
  let q = p;
  while (q < size) {
    /* ReturnIfAbrupt */
    let _temp89 = yield* Set$1(splitter, Value('lastIndex'), F(q), Value.true);
    /* node:coverage ignore next */
    if (_temp89 instanceof AbruptCompletion) return _temp89;
    /* node:coverage ignore next */
    if (_temp89 instanceof Completion) _temp89 = _temp89.Value;
    /* ReturnIfAbrupt */
    let _temp90 = yield* RegExpExec(splitter, S);
    /* node:coverage ignore next */
    if (_temp90 instanceof AbruptCompletion) return _temp90;
    /* node:coverage ignore next */
    if (_temp90 instanceof Completion) _temp90 = _temp90.Value;
    const z = _temp90;
    if (z instanceof NullValue) {
      q = AdvanceStringIndex(S, q, unicodeMatching);
    } else {
      /* ReturnIfAbrupt */
      let _temp91 = yield* Get(splitter, Value('lastIndex'));
      /* node:coverage ignore next */
      if (_temp91 instanceof AbruptCompletion) return _temp91;
      /* node:coverage ignore next */
      if (_temp91 instanceof Completion) _temp91 = _temp91.Value;
      const lastIndex = _temp91;
      /* ReturnIfAbrupt */
      let _temp92 = yield* ToLength(lastIndex);
      /* node:coverage ignore next */
      if (_temp92 instanceof AbruptCompletion) return _temp92;
      /* node:coverage ignore next */
      if (_temp92 instanceof Completion) _temp92 = _temp92.Value;
      let e = R(_temp92);
      e = Math.min(e, size);
      if (e === p) {
        q = AdvanceStringIndex(S, q, unicodeMatching);
      } else {
        const T = Value(S.stringValue().substring(p, q));
        /* X */
        let _temp99 = ToString(F(lengthA));
        /* node:coverage ignore next */
        if (_temp99 && typeof _temp99 === 'object' && 'next' in _temp99) _temp99 = skipDebugger(_temp99);
        /* node:coverage ignore next */
        if (_temp99 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(lengthA)) returned an abrupt completion", {
          cause: _temp99
        });
        /* node:coverage ignore next */
        if (_temp99 instanceof Completion) _temp99 = _temp99.Value;
        /* X */
        let _temp93 = CreateDataProperty(A, _temp99, T);
        /* node:coverage ignore next */
        if (_temp93 && typeof _temp93 === 'object' && 'next' in _temp93) _temp93 = skipDebugger(_temp93);
        /* node:coverage ignore next */
        if (_temp93 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(A, X(ToString(F(lengthA))), T) returned an abrupt completion", {
          cause: _temp93
        });
        /* node:coverage ignore next */
        if (_temp93 instanceof Completion) _temp93 = _temp93.Value;
        lengthA += 1;
        if (lengthA === lim) {
          return A;
        }
        p = e;
        /* ReturnIfAbrupt */
        let _temp94 = yield* LengthOfArrayLike(z);
        /* node:coverage ignore next */
        if (_temp94 instanceof AbruptCompletion) return _temp94;
        /* node:coverage ignore next */
        if (_temp94 instanceof Completion) _temp94 = _temp94.Value;
        let numberOfCaptures = _temp94;
        numberOfCaptures = Math.max(numberOfCaptures - 1, 0);
        let i = 1;
        while (i <= numberOfCaptures) {
          /* X */
          let _temp97 = ToString(F(i));
          /* node:coverage ignore next */
          if (_temp97 && typeof _temp97 === 'object' && 'next' in _temp97) _temp97 = skipDebugger(_temp97);
          /* node:coverage ignore next */
          if (_temp97 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(i)) returned an abrupt completion", {
            cause: _temp97
          });
          /* node:coverage ignore next */
          if (_temp97 instanceof Completion) _temp97 = _temp97.Value;
          /* ReturnIfAbrupt */
          let _temp95 = yield* Get(z, _temp97);
          /* node:coverage ignore next */
          if (_temp95 instanceof AbruptCompletion) return _temp95;
          /* node:coverage ignore next */
          if (_temp95 instanceof Completion) _temp95 = _temp95.Value;
          const nextCapture = _temp95;
          /* X */
          let _temp98 = ToString(F(lengthA));
          /* node:coverage ignore next */
          if (_temp98 && typeof _temp98 === 'object' && 'next' in _temp98) _temp98 = skipDebugger(_temp98);
          /* node:coverage ignore next */
          if (_temp98 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(lengthA)) returned an abrupt completion", {
            cause: _temp98
          });
          /* node:coverage ignore next */
          if (_temp98 instanceof Completion) _temp98 = _temp98.Value;
          /* X */
          let _temp96 = CreateDataProperty(A, _temp98, nextCapture);
          /* node:coverage ignore next */
          if (_temp96 && typeof _temp96 === 'object' && 'next' in _temp96) _temp96 = skipDebugger(_temp96);
          /* node:coverage ignore next */
          if (_temp96 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(A, X(ToString(F(lengthA))), nextCapture) returned an abrupt completion", {
            cause: _temp96
          });
          /* node:coverage ignore next */
          if (_temp96 instanceof Completion) _temp96 = _temp96.Value;
          i += 1;
          lengthA += 1;
          if (lengthA === lim) {
            return A;
          }
        }
        q = p;
      }
    }
  }
  const T = Value(S.stringValue().substring(p, size));
  /* X */
  let _temp101 = ToString(F(lengthA));
  /* node:coverage ignore next */
  if (_temp101 && typeof _temp101 === 'object' && 'next' in _temp101) _temp101 = skipDebugger(_temp101);
  /* node:coverage ignore next */
  if (_temp101 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(lengthA)) returned an abrupt completion", {
    cause: _temp101
  });
  /* node:coverage ignore next */
  if (_temp101 instanceof Completion) _temp101 = _temp101.Value;
  /* X */
  let _temp100 = CreateDataProperty(A, _temp101, T);
  /* node:coverage ignore next */
  if (_temp100 && typeof _temp100 === 'object' && 'next' in _temp100) _temp100 = skipDebugger(_temp100);
  /* node:coverage ignore next */
  if (_temp100 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(A, X(ToString(F(lengthA))), T) returned an abrupt completion", {
    cause: _temp100
  });
  /* node:coverage ignore next */
  if (_temp100 instanceof Completion) _temp100 = _temp100.Value;
  return A;
}
RegExpProto_split.section = 'https://tc39.es/ecma262/#sec-regexp.prototype-@@split';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.sticky */
function RegExpProto_stickyGetter(_args, {
  thisValue
}) {
  // 1. Let R be the this value.
  const R = thisValue;
  // 2. Let cu be the code unit 0x0097 (LATIN SMALL LETTER Y).
  const cu = 'y';
  // 3. Return ? RegExpHasFlag(R, cu).
  return RegExpHasFlag(R, cu);
}
RegExpProto_stickyGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.sticky';
/** https://tc39.es/ecma262/#sec-regexp.prototype.test */
function* RegExpProto_test([S = Value.undefined], {
  thisValue
}) {
  const R = thisValue;
  if (!(R instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  /* ReturnIfAbrupt */
  let _temp102 = yield* ToString(S);
  /* node:coverage ignore next */
  if (_temp102 instanceof AbruptCompletion) return _temp102;
  /* node:coverage ignore next */
  if (_temp102 instanceof Completion) _temp102 = _temp102.Value;
  const string = _temp102;
  /* ReturnIfAbrupt */
  let _temp103 = yield* RegExpExec(R, string);
  /* node:coverage ignore next */
  if (_temp103 instanceof AbruptCompletion) return _temp103;
  /* node:coverage ignore next */
  if (_temp103 instanceof Completion) _temp103 = _temp103.Value;
  const match = _temp103;
  if (match !== Value.null) {
    return Value.true;
  }
  return Value.false;
}
RegExpProto_test.section = 'https://tc39.es/ecma262/#sec-regexp.prototype.test';
/** https://tc39.es/ecma262/#sec-regexp.prototype.tostring */
function* RegExpProto_toString(_args, {
  thisValue
}) {
  const R = thisValue;
  if (!(R instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  /* ReturnIfAbrupt */
  let _temp106 = yield* Get(R, Value('source'));
  /* node:coverage ignore next */
  if (_temp106 instanceof AbruptCompletion) return _temp106;
  /* node:coverage ignore next */
  if (_temp106 instanceof Completion) _temp106 = _temp106.Value;
  /* ReturnIfAbrupt */
  let _temp104 = yield* ToString(_temp106);
  /* node:coverage ignore next */
  if (_temp104 instanceof AbruptCompletion) return _temp104;
  /* node:coverage ignore next */
  if (_temp104 instanceof Completion) _temp104 = _temp104.Value;
  const pattern = _temp104;
  /* ReturnIfAbrupt */
  let _temp107 = yield* Get(R, Value('flags'));
  /* node:coverage ignore next */
  if (_temp107 instanceof AbruptCompletion) return _temp107;
  /* node:coverage ignore next */
  if (_temp107 instanceof Completion) _temp107 = _temp107.Value;
  /* ReturnIfAbrupt */
  let _temp105 = yield* ToString(_temp107);
  /* node:coverage ignore next */
  if (_temp105 instanceof AbruptCompletion) return _temp105;
  /* node:coverage ignore next */
  if (_temp105 instanceof Completion) _temp105 = _temp105.Value;
  const flags = _temp105;
  const result = `/${pattern.stringValue()}/${flags.stringValue()}`;
  return Value(result);
}
RegExpProto_toString.section = 'https://tc39.es/ecma262/#sec-regexp.prototype.tostring';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.unicode */
function RegExpProto_unicodeGetter(_args, {
  thisValue
}) {
  // 1. Let R be the this value.
  const R = thisValue;
  // 2. Let cu be the code unit 0x0075 (LATIN SMALL LETTER U).
  const cu = 'u';
  // 3. Return ? RegExpHasFlag(R, cu).
  return RegExpHasFlag(R, cu);
}
RegExpProto_unicodeGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.unicode';
/** https://tc39.es/ecma262/#sec-get-regexp.prototype.unicodeSets */
function RegExpProto_unicodeSetsGetter(_args, {
  thisValue
}) {
  // 1. Let R be the this value.
  const R = thisValue;
  // 2. Let cu be the code unit 0x0076 (LATIN SMALL LETTER V).
  const cu = 'v';
  // 3. Return ? RegExpHasFlag(R, cu).
  return RegExpHasFlag(R, cu);
}
RegExpProto_unicodeSetsGetter.section = 'https://tc39.es/ecma262/#sec-get-regexp.prototype.unicodeSets';
function bootstrapRegExpPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['exec', RegExpProto_exec, 1], ['dotAll', [RegExpProto_dotAllGetter]], ['flags', [RegExpProto_flagsGetter]], ['global', [RegExpProto_globalGetter]], ['hasIndices', [RegExpProto_hasIndicesGetter]], ['ignoreCase', [RegExpProto_ignoreCaseGetter]], [wellKnownSymbols.match, RegExpProto_match, 1], [wellKnownSymbols.matchAll, RegExpProto_matchAll, 1], ['multiline', [RegExpProto_multilineGetter]], [wellKnownSymbols.replace, RegExpProto_replace, 2], [wellKnownSymbols.search, RegExpProto_search, 1], ['source', [RegExpProto_sourceGetter]], [wellKnownSymbols.split, RegExpProto_split, 2], ['sticky', [RegExpProto_stickyGetter]], ['test', RegExpProto_test, 1], ['toString', RegExpProto_toString, 0], ['unicode', [RegExpProto_unicodeGetter]], ['unicodeSets', [RegExpProto_unicodeSetsGetter]]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%RegExp.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-promise.prototype.catch */
function* PromiseProto_catch([onRejected = Value.undefined], {
  thisValue
}) {
  // 1. Let promise be the this value.
  const promise = thisValue;
  // 2. Return ? Invoke(promise, "then", « undefined, onRejected »).
  return yield* Invoke(promise, Value('then'), [Value.undefined, onRejected]);
}
PromiseProto_catch.section = 'https://tc39.es/ecma262/#sec-promise.prototype.catch';
/** https://tc39.es/ecma262/#sec-promise.prototype.finally */
function* PromiseProto_finally([onFinally = Value.undefined], {
  thisValue
}) {
  // 1. Let promise be the this value.
  const promise = thisValue;
  // 2. If Type(promise) is not Object, throw a TypeError exception.
  if (!(promise instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Promise', promise);
  }
  // 3. Let C be ? SpeciesConstructor(promise, %Promise%).
  /* ReturnIfAbrupt */
  let _temp = yield* SpeciesConstructor(promise, surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const C = _temp;
  // 4. Assert: IsConstructor(C) is true.
  Assert(IsConstructor(C), "IsConstructor(C)");
  let thenFinally;
  let catchFinally;
  // 5. If IsCallable(onFinally) is false, then
  if (!IsCallable(onFinally)) {
    // a. Let thenFinally be onFinally.
    thenFinally = onFinally;
    // b. Let catchFinally be onFinally.
    catchFinally = onFinally;
  } else {
    // 6. Else,
    // a. Let thenFinallyClosure be a new Abstract Closure with parameters (value) that captures onFinally and C and performs the following steps when called:
    const thenFinallyClosure = function* thenFinallyClosure([value = Value.undefined]) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* Call(onFinally, Value.undefined);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      // i. Let result be ? Call(onFinally, undefined).
      const result = _temp2;
      // ii. Let promise be ? PromiseResolve(C, result).
      /* ReturnIfAbrupt */
      let _temp3 = yield* PromiseResolve(C, result);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      const promiseInner = _temp3;
      // iii. Let returnValue be a new Abstract Closure with no parameters that captures value and performs the following steps when called:
      //   1. Return value.
      const returnValue = () => value;
      // iv. Let valueThunk be ! CreateBuiltinFunction(returnValue, 0, "", « »).
      /* X */
      let _temp4 = CreateBuiltinFunction(returnValue, 0, Value(''), []);
      /* node:coverage ignore next */
      if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(returnValue, 0, Value(''), []) returned an abrupt completion", {
        cause: _temp4
      });
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      const valueThunk = _temp4;
      // v. Return ? Invoke(promise, "then", « valueThunk »).
      return yield* Invoke(promiseInner, Value('then'), [valueThunk]);
    };
    // b. Let thenFinally be ! CreateBuiltinFunction(thenFinallyClosure, 1, "", « »).
    /* X */
    let _temp5 = CreateBuiltinFunction(thenFinallyClosure, 1, Value(''), ['HostCapturedValues']);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(thenFinallyClosure, 1, Value(''), ['HostCapturedValues']) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    thenFinally = _temp5;
    // NON-SPEC
    thenFinally.HostCapturedValues = [onFinally];
    // c. Let catchFinallyClosure be a new Abstract Closure with parameters (reason) that captures onFinally and C and performs the following steps when called:
    const catchFinallyClosure = function* catchFinallyClosure([reason = Value.undefined]) {
      /* ReturnIfAbrupt */
      let _temp6 = yield* Call(onFinally, Value.undefined);
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) return _temp6;
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      // i. Let result be ? Call(onFinally, undefined).
      const result = _temp6;
      // ii. Let promise be ? PromiseResolve(C, result).
      /* ReturnIfAbrupt */
      let _temp7 = yield* PromiseResolve(C, result);
      /* node:coverage ignore next */
      if (_temp7 instanceof AbruptCompletion) return _temp7;
      /* node:coverage ignore next */
      if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
      const promiseInner = _temp7;
      // iii. Let throwReason be a new Abstract Closure with no parameters that captures reason and performs the following steps when called:
      //   1. Return ThrowCompletion(reason).
      const throwReason = () => ThrowCompletion(reason);
      // iv. Let thrower be ! CreateBuiltinFunction(throwReason, 0, "", « »).
      /* X */
      let _temp8 = CreateBuiltinFunction(throwReason, 0, Value(''), []);
      /* node:coverage ignore next */
      if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(throwReason, 0, Value(''), []) returned an abrupt completion", {
        cause: _temp8
      });
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
      const thrower = _temp8;
      // v. Return ? Invoke(promise, "then", « thrower »).
      return yield* Invoke(promiseInner, Value('then'), [thrower]);
    };
    // d. Let catchFinally be ! CreateBuiltinFunction(catchFinallyClosure, 1, "", « »).
    /* X */
    let _temp9 = CreateBuiltinFunction(catchFinallyClosure, 1, Value(''), ['HostCapturedValues']);
    /* node:coverage ignore next */
    if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(catchFinallyClosure, 1, Value(''), ['HostCapturedValues']) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    catchFinally = _temp9;
    // NON-SPEC
    catchFinally.HostCapturedValues = [onFinally];
  }
  // 7. Return ? Invoke(promise, "then", « thenFinally, catchFinally »).
  return yield* Invoke(promise, Value('then'), [thenFinally, catchFinally]);
}
PromiseProto_finally.section = 'https://tc39.es/ecma262/#sec-promise.prototype.finally';
/** https://tc39.es/ecma262/#sec-promise.prototype.then */
function* PromiseProto_then([onFulfilled = Value.undefined, onRejected = Value.undefined], {
  thisValue
}) {
  // 1. Let promise be the this value.
  const promise = thisValue;
  // 2. If IsPromise(promise) is false, throw a TypeError exception.
  if (IsPromise(promise) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'Promise', promise);
  }
  // 3. Let C be ? SpeciesConstructor(promise, %Promise%).
  /* ReturnIfAbrupt */
  let _temp10 = yield* SpeciesConstructor(promise, surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const C = _temp10;
  // 4. Let resultCapability be ? NewPromiseCapability(C).
  /* ReturnIfAbrupt */
  let _temp11 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const resultCapability = _temp11;
  // 5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).
  /* ReturnIfAbrupt */
  let _temp12 = surroundingAgent.debugger_tryTouchDuringPreview(promise);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability);
}
PromiseProto_then.section = 'https://tc39.es/ecma262/#sec-promise.prototype.then';
function bootstrapPromisePrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['catch', PromiseProto_catch, 1], ['finally', PromiseProto_finally, 1], ['then', PromiseProto_then, 2]], realmRec.Intrinsics['%Object.prototype%'], 'Promise');
  /* X */
  let _temp13 = Get(proto, Value('then'));
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! Get(proto, Value('then')) returned an abrupt completion", {
    cause: _temp13
  });
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  realmRec.Intrinsics['%Promise.prototype.then%'] = _temp13;
  realmRec.Intrinsics['%Promise.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#table-internal-slots-of-promise-instances */

function isPromiseObject(value) {
  return 'PromiseState' in value;
}

/** https://tc39.es/ecma262/#sec-promise-executor */
function* PromiseConstructor([executor = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. If IsCallable(executor) is false, throw a TypeError exception.
  if (!IsCallable(executor)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', executor);
  }
  // 3. Let promise be ? OrdinaryCreateFromConstructor(NewTarget, "%Promise.prototype%", « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(NewTarget, '%Promise.prototype%', ['PromiseState', 'PromiseResult', 'PromiseFulfillReactions', 'PromiseRejectReactions', 'PromiseIsHandled']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const promise = _temp;
  // 4. Set promise.[[PromiseState]] to pending.
  promise.PromiseState = 'pending';
  // 5. Set promise.[[PromiseFulfillReactions]] to a new empty List.
  promise.PromiseFulfillReactions = [];
  // 6. Set promise.[[PromiseFulfillReactions]] to a new empty List.
  promise.PromiseRejectReactions = [];
  // 7. Set promise.[[PromiseIsHandled]] to false.
  promise.PromiseIsHandled = Value.false;
  // 8. Let resolvingFunctions be CreateResolvingFunctions(promise).
  const resolvingFunctions = CreateResolvingFunctions(promise);
  // 9. Let completion be Call(executor, undefined, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »).
  const completion = yield* Call(executor, Value.undefined, [resolvingFunctions.Resolve, resolvingFunctions.Reject]);
  // 10. If completion is an abrupt completion, then
  if (completion instanceof AbruptCompletion) {
    /* ReturnIfAbrupt */
    let _temp2 = yield* Call(resolvingFunctions.Reject, Value.undefined, [completion.Value]);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  }
  // 11. Return promise.
  return promise;
}
PromiseConstructor.section = 'https://tc39.es/ecma262/#sec-promise-executor';
/** https://tc39.es/ecma262/#sec-promise.all-resolve-element-functions */
function* PromiseAllResolveElementFunctions([x = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  const alreadyCalled = F.AlreadyCalled;
  if (alreadyCalled.Value === true) {
    return Value.undefined;
  }
  alreadyCalled.Value = true;
  const index = F.Index;
  const values = F.Values;
  const promiseCapability = F.Capability;
  const remainingElementsCount = F.RemainingElements;
  values[index] = x;
  remainingElementsCount.Value -= 1;
  if (remainingElementsCount.Value === 0) {
    const valuesArray = CreateArrayFromList(values);
    return yield* Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
  }
  return Value.undefined;
}
PromiseAllResolveElementFunctions.section = 'https://tc39.es/ecma262/#sec-promise.all-resolve-element-functions';
/** https://tc39.es/ecma262/#sec-getpromiseresolve */
function* GetPromiseResolve(promiseConstructor) {
  // 1. Assert: IsConstructor(promiseConstructor) is true.
  Assert(IsConstructor(promiseConstructor), "IsConstructor(promiseConstructor)");
  // 2. Let promiseResolve be ? Get(promiseConstructor, "resolve").
  /* ReturnIfAbrupt */
  let _temp3 = yield* Get(promiseConstructor, Value('resolve'));
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const promiseResolve = _temp3;
  // 3. If IsCallable(promiseResolve) is false, throw a TypeError exception.
  if (!IsCallable(promiseResolve)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', promiseResolve);
  }
  // 4. Return promiseResolve.
  return promiseResolve;
}
GetPromiseResolve.section = 'https://tc39.es/ecma262/#sec-getpromiseresolve';
/** https://tc39.es/ecma262/#sec-performpromiseall */
function* PerformPromiseAll(iteratorRecord, constructor, resultCapability, promiseResolve) {
  // 1. Assert: IsConstructor(constructor) is true.
  Assert(IsConstructor(constructor), "IsConstructor(constructor)");
  // 2. Assert: resultCapability is a PromiseCapability Record.
  Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
  // 3. Assert: IsCallable(promiseResolve) is true.
  Assert(IsCallable(promiseResolve), "IsCallable(promiseResolve)");
  // 4. Let values be a new empty List.
  const values = [];
  // 5. Let remainingElementsCount be the Record { [[Value]]: 1 }.
  const remainingElementsCount = {
    Value: 1
  };
  // 6. Let index be 0.
  let index = 0;
  // 7. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp4 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // a. Let next be ? IteratorStepValue(iteratorRecord).
    const next = _temp4;
    // d. If next is done, then
    if (next === 'done') {
      // ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.
      remainingElementsCount.Value -= 1;
      // iii. If remainingElementsCount.[[Value]] is 0, then
      if (remainingElementsCount.Value === 0) {
        // 1. Let valuesArray be ! CreateArrayFromList(values).
        const valuesArray = CreateArrayFromList(values);
        // 2. Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).
        /* ReturnIfAbrupt */
        let _temp5 = yield* Call(resultCapability.Resolve, Value.undefined, [valuesArray]);
        /* node:coverage ignore next */
        if (_temp5 instanceof AbruptCompletion) return _temp5;
        /* node:coverage ignore next */
        if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      }
      // iv. Return resultCapability.[[Promise]].
      return resultCapability.Promise;
    }
    // h. Append undefined to values.
    values.push(Value.undefined);
    // i. Let nextPromise be ? Call(promiseResolve, constructor, « next »).
    /* ReturnIfAbrupt */
    let _temp6 = yield* Call(promiseResolve, constructor, [next]);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    const nextPromise = _temp6;
    // j. Let steps be the algorithm steps defined in Promise.all Resolve Element Functions.
    const steps = PromiseAllResolveElementFunctions;
    // k. Let length be the number of non-optional parameters of the function definition in Promise.all Resolve Element Functions.
    const length = 1;
    // l. Let onFulfilled be ! CreateBuiltinFunction(steps, length, "", « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
    /* X */
    let _temp7 = CreateBuiltinFunction(steps, length, Value(''), ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(steps, length, Value(''), [\n      'AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements',\n    ]) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const onFulfilled = _temp7;
    // m. Set onFulfilled.[[AlreadyCalled]] to the Record { [[Value]]: false }.
    onFulfilled.AlreadyCalled = {
      Value: false
    };
    // n. Set onFulfilled.[[Index]] to index.
    onFulfilled.Index = index;
    // o. Set onFulfilled.[[Values]] to values.
    onFulfilled.Values = values;
    // p. Set onFulfilled.[[Capability]] to resultCapability.
    onFulfilled.Capability = resultCapability;
    // q. Set onFulfilled.[[RemainingElements]] to remainingElementsCount.
    onFulfilled.RemainingElements = remainingElementsCount;
    // r. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.
    remainingElementsCount.Value += 1;
    // s. Perform ? Invoke(nextPromise, "then", « onFulfilled, resultCapability.[[Reject]] »).
    /* ReturnIfAbrupt */
    let _temp8 = yield* Invoke(nextPromise, Value('then'), [onFulfilled, resultCapability.Reject]);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    // t. Set index to index + 1.
    index += 1;
  }
}
PerformPromiseAll.section = 'https://tc39.es/ecma262/#sec-performpromiseall';
/** https://tc39.es/ecma262/#sec-promise.all */
function* Promise_all([iterable = Value.undefined], {
  thisValue
}) {
  // 1. Let C be the this value.
  const C = thisValue;
  // 2. Let promiseCapability be ? NewPromiseCapability(C).
  /* ReturnIfAbrupt */
  let _temp9 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const promiseCapability = _temp9;
  // 3. Let promiseResolve be GetPromiseResolve(C).
  let promiseResolve = yield* GetPromiseResolve(C);
  // 4. IfAbruptRejectPromise(promiseResolve, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (promiseResolve instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [promiseResolve.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (promiseResolve instanceof Completion) promiseResolve = promiseResolve.Value;
  // 5. Let iteratorRecord be GetIterator(iterable).
  let iteratorRecord = yield* GetIterator(iterable, 'sync');
  // 6. IfAbruptRejectPromise(iteratorRecord, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (iteratorRecord instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (iteratorRecord instanceof Completion) iteratorRecord = iteratorRecord.Value;
  // 7. Let result be PerformPromiseAll(iteratorRecord, C, promiseCapability, promiseResolve).
  let result = yield* PerformPromiseAll(iteratorRecord, C, promiseCapability, promiseResolve);
  // 8. If result is an abrupt completion, then
  if (result instanceof AbruptCompletion) {
    // a. If iteratorRecord.[[Done]] is false, set result to IteratorClose(iteratorRecord, result).
    if (iteratorRecord.Done === Value.false) {
      result = yield* IteratorClose(iteratorRecord, result);
    }
    // b. IfAbruptRejectPromise(result, promiseCapability).
    /* IfAbruptRejectPromise */
    /* node:coverage disable */
    if (result instanceof AbruptCompletion) {
      const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
      if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
      return promiseCapability.Promise;
    }
    if (result instanceof Completion) result = result.Value;
    /* node:coverage enable */
  }
  // 9. Return ? result.
  return result;
}
Promise_all.section = 'https://tc39.es/ecma262/#sec-promise.all';
function* PromiseAllSettledResolveElementFunctions([x = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  const alreadyCalled = F.AlreadyCalled;
  if (alreadyCalled.Value === true) {
    return Value.undefined;
  }
  alreadyCalled.Value = true;
  const index = F.Index;
  const values = F.Values;
  const promiseCapability = F.Capability;
  const remainingElementsCount = F.RemainingElements;
  /* X */
  let _temp10 = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%')) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const obj = _temp10;
  /* X */
  let _temp11 = CreateDataProperty(obj, Value('status'), Value('fulfilled'));
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('status'), Value('fulfilled')) returned an abrupt completion", {
    cause: _temp11
  });
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  /* X */
  let _temp12 = CreateDataProperty(obj, Value('value'), x);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('value'), x) returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  values[index] = obj;
  remainingElementsCount.Value -= 1;
  if (remainingElementsCount.Value === 0) {
    /* X */
    let _temp13 = CreateArrayFromList(values);
    /* node:coverage ignore next */
    if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList(values) returned an abrupt completion", {
      cause: _temp13
    });
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    const valuesArray = _temp13;
    return yield* Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
  }
  return Value.undefined;
}
function* PromiseAllSettledRejectElementFunctions([x = Value.undefined]) {
  const F = surroundingAgent.activeFunctionObject;
  const alreadyCalled = F.AlreadyCalled;
  if (alreadyCalled.Value === true) {
    return Value.undefined;
  }
  alreadyCalled.Value = true;
  const index = F.Index;
  const values = F.Values;
  const promiseCapability = F.Capability;
  const remainingElementsCount = F.RemainingElements;
  /* X */
  let _temp14 = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%')) returned an abrupt completion", {
    cause: _temp14
  });
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const obj = _temp14;
  /* X */
  let _temp15 = CreateDataProperty(obj, Value('status'), Value('rejected'));
  /* node:coverage ignore next */
  if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('status'), Value('rejected')) returned an abrupt completion", {
    cause: _temp15
  });
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  /* X */
  let _temp16 = CreateDataProperty(obj, Value('reason'), x);
  /* node:coverage ignore next */
  if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('reason'), x) returned an abrupt completion", {
    cause: _temp16
  });
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  values[index] = obj;
  remainingElementsCount.Value -= 1;
  if (remainingElementsCount.Value === 0) {
    /* X */
    let _temp17 = CreateArrayFromList(values);
    /* node:coverage ignore next */
    if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList(values) returned an abrupt completion", {
      cause: _temp17
    });
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    const valuesArray = _temp17;
    return yield* Call(promiseCapability.Resolve, Value.undefined, [valuesArray]);
  }
  return Value.undefined;
}

/** https://tc39.es/ecma262/#sec-performpromiseallsettled */
function* PerformPromiseAllSettled(iteratorRecord, constructor, resultCapability, promiseResolve) {
  // 1. Assert: ! IsConstructor(constructor) is true.
  Assert(IsConstructor(constructor), "IsConstructor(constructor)");
  // 2. Assert: resultCapability is a PromiseCapability Record.
  Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
  // 3. Assert: IsCallable(promiseResolve) is true.
  Assert(IsCallable(promiseResolve), "IsCallable(promiseResolve)");
  // 4. Let values be a new empty List.
  const values = [];
  // 5. Let remainingElementsCount be the Record { [[Value]]: 1 }.
  const remainingElementsCount = {
    Value: 1
  };
  // 6. Let index be 0.
  let index = 0;
  // 7. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp18 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) return _temp18;
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    // a. Let next be ? IteratorStepValue(iteratorRecord).
    const next = _temp18;
    // d. If next is done,
    if (next === 'done') {
      // ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.
      remainingElementsCount.Value -= 1;
      // iii. If remainingElementsCount.[[Value]] is 0, then
      if (remainingElementsCount.Value === 0) {
        /* X */
        let _temp19 = CreateArrayFromList(values);
        /* node:coverage ignore next */
        if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
        /* node:coverage ignore next */
        if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList(values) returned an abrupt completion", {
          cause: _temp19
        });
        /* node:coverage ignore next */
        if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
        // 1. Let valuesArray be ! CreateArrayFromList(values).
        const valuesArray = _temp19;
        // 2. Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).
        /* ReturnIfAbrupt */
        let _temp20 = yield* Call(resultCapability.Resolve, Value.undefined, [valuesArray]);
        /* node:coverage ignore next */
        if (_temp20 instanceof AbruptCompletion) return _temp20;
        /* node:coverage ignore next */
        if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
      }
      // iv. Return resultCapability.[[Promise]].
      return resultCapability.Promise;
    }
    // h. Append undefined to values.
    values.push(Value.undefined);
    // i. Let nextPromise be ? Call(promiseResolve, constructor, « next »).
    /* ReturnIfAbrupt */
    let _temp21 = yield* Call(promiseResolve, constructor, [next]);
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) return _temp21;
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    const nextPromise = _temp21;
    // j. Let stepsFulfilled be the algorithm steps defined in Promise.allSettled Resolve Element Functions.
    const stepsFulfilled = PromiseAllSettledResolveElementFunctions;
    // k. Let lengthFulfilled be the number of non-optional parameters of the function definition in Promise.allSettled Resolve Element Functions.
    const lengthFulfilled = 1;
    // l. Let onFulfilled be ! CreateBuiltinFunction(stepsFulfilled, lengthFulfilled, "", « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
    /* X */
    let _temp22 = CreateBuiltinFunction(stepsFulfilled, lengthFulfilled, Value(''), ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);
    /* node:coverage ignore next */
    if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) _temp22 = skipDebugger(_temp22);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(stepsFulfilled, lengthFulfilled, Value(''), [\n      'AlreadyCalled',\n      'Index',\n      'Values',\n      'Capability',\n      'RemainingElements',\n    ]) returned an abrupt completion", {
      cause: _temp22
    });
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    const onFulfilled = _temp22;
    // m. Let alreadyCalled be the Record { [[Value]]: false }.
    const alreadyCalled = {
      Value: false
    };
    // n. Set onFulfilled.[[AlreadyCalled]] to alreadyCalled.
    onFulfilled.AlreadyCalled = alreadyCalled;
    // o. Set onFulfilled.[[Index]] to index.
    onFulfilled.Index = index;
    // p. Set onFulfilled.[[Values]] to values.
    onFulfilled.Values = values;
    // q. Set onFulfilled.[[Capability]] to resultCapability.
    onFulfilled.Capability = resultCapability;
    // r. Set onFulfilled.[[RemainingElements]] to remainingElementsCount.
    onFulfilled.RemainingElements = remainingElementsCount;
    // s. Let rejectSteps be the algorithm steps defined in Promise.allSettled Reject Element Functions.
    const stepsRejected = PromiseAllSettledRejectElementFunctions;
    // t. Let lengthRejected be the number of non-optional parameters of the function definition in Promise.allSettled Reject Element Functions.
    const lengthRejected = 1;
    // u. Let onRejected be ! CreateBuiltinFunction(stepsRejected, lengthRejected, "", « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
    /* X */
    let _temp23 = CreateBuiltinFunction(stepsRejected, lengthRejected, Value(''), ['AlreadyCalled', 'Index', 'Values', 'Capability', 'RemainingElements']);
    /* node:coverage ignore next */
    if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) _temp23 = skipDebugger(_temp23);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(stepsRejected, lengthRejected, Value(''), [\n      'AlreadyCalled',\n      'Index',\n      'Values',\n      'Capability',\n      'RemainingElements',\n    ]) returned an abrupt completion", {
      cause: _temp23
    });
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    const onRejected = _temp23;
    // v. Set onRejected.[[AlreadyCalled]] to alreadyCalled.
    onRejected.AlreadyCalled = alreadyCalled;
    // w. Set onRejected.[[Index]] to index.
    onRejected.Index = index;
    // x. Set onRejected.[[Values]] to values.
    onRejected.Values = values;
    // y. Set onRejected.[[Capability]] to resultCapability.
    onRejected.Capability = resultCapability;
    // z. Set onRejected.[[RemainingElements]] to remainingElementsCount.
    onRejected.RemainingElements = remainingElementsCount;
    // aa. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.
    remainingElementsCount.Value += 1;
    // ab. Perform ? Invoke(nextPromise, "then", « onFulfilled, onRejected »).
    /* ReturnIfAbrupt */
    let _temp24 = yield* Invoke(nextPromise, Value('then'), [onFulfilled, onRejected]);
    /* node:coverage ignore next */
    if (_temp24 instanceof AbruptCompletion) return _temp24;
    /* node:coverage ignore next */
    if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
    // ac. Set index to index + 1.
    index += 1;
  }
}
PerformPromiseAllSettled.section = 'https://tc39.es/ecma262/#sec-performpromiseallsettled';
/** https://tc39.es/ecma262/#sec-promise.allsettled */
function* Promise_allSettled([iterable = Value.undefined], {
  thisValue
}) {
  // 1. Let C be the this value.
  const C = thisValue;
  // 2. Let promiseCapability be ? NewPromiseCapability(C).
  /* ReturnIfAbrupt */
  let _temp25 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  const promiseCapability = _temp25;
  // 3. Let promiseResolve be GetPromiseResolve(C).
  let promiseResolve = yield* GetPromiseResolve(C);
  // 4. IfAbruptRejectPromise(promiseResolve, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (promiseResolve instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [promiseResolve.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (promiseResolve instanceof Completion) promiseResolve = promiseResolve.Value;
  /* node:coverage enable */
  // 5. Let iteratorRecord be GetIterator(iterable).
  let iteratorRecord = yield* GetIterator(iterable, 'sync');
  // 6. IfAbruptRejectPromise(iteratorRecord, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (iteratorRecord instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (iteratorRecord instanceof Completion) iteratorRecord = iteratorRecord.Value;
  // 7. Let result be PerformPromiseAllSettled(iteratorRecord, C, promiseCapability, promiseResolve).
  let result = yield* PerformPromiseAllSettled(iteratorRecord, C, promiseCapability, promiseResolve);
  // 8. If result is an abrupt completion, then
  if (result instanceof AbruptCompletion) {
    // a. If iteratorRecord.[[Done]] is false, set result to IteratorClose(iteratorRecord, result).
    if (iteratorRecord.Done === Value.false) {
      result = yield* IteratorClose(iteratorRecord, result);
    }
    // b. IfAbruptRejectPromise(result, promiseCapability).
    /* IfAbruptRejectPromise */
    /* node:coverage disable */
    if (result instanceof AbruptCompletion) {
      const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
      if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
      return promiseCapability.Promise;
    }
    if (result instanceof Completion) result = result.Value;
    /* node:coverage enable */
  }
  // 9. Return ? result.
  return result;
}
Promise_allSettled.section = 'https://tc39.es/ecma262/#sec-promise.allsettled';
/** https://tc39.es/ecma262/#sec-promise.any-reject-element-functions */
function* PromiseAnyRejectElementFunctions([x = Value.undefined]) {
  // 1. Let F be the active function object.
  const F = surroundingAgent.activeFunctionObject;
  // 2. Let alreadyCalled be F.[[AlreadyCalled]].
  const alreadyCalled = F.AlreadyCalled;
  // 3. If alreadyCalled.[[Value]] is true, return undefined.
  if (alreadyCalled.Value) {
    return Value.undefined;
  }
  // 4. Set alreadyCalled.[[Value]] to true.
  alreadyCalled.Value = true;
  // 5. Let index be F.[[Index]].
  const index = F.Index;
  // 6. Let errors be F.[[Errors]].
  const errors = F.Errors;
  // 7. Let promiseCapability be F.[[Capability]].
  const promiseCapability = F.Capability;
  // 8. Let remainingElementsCount be F.[[RemainingElements]].
  const remainingElementsCount = F.RemainingElements;
  // 9. Set errors[index] to x.
  errors[index] = x;
  // 10. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.
  remainingElementsCount.Value -= 1;
  // 11. If remainingElementsCount.[[Value]] is 0, then
  if (remainingElementsCount.Value === 0) {
    // a. Let error be a newly created AggregateError object.
    const error = surroundingAgent.Throw('AggregateError', 'PromiseAnyRejected').Value;
    // b. Perform ! DefinePropertyOrThrow(error, "errors", Property Descriptor { [[Configurable]]: true, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: errors }).
    /* X */
    let _temp27 = CreateArrayFromList(errors);
    /* node:coverage ignore next */
    if (_temp27 && typeof _temp27 === 'object' && 'next' in _temp27) _temp27 = skipDebugger(_temp27);
    /* node:coverage ignore next */
    if (_temp27 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList(errors) returned an abrupt completion", {
      cause: _temp27
    });
    /* node:coverage ignore next */
    if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
    /* X */
    let _temp26 = DefinePropertyOrThrow(error, Value('errors'), _Descriptor({
      Configurable: Value.true,
      Enumerable: Value.false,
      Writable: Value.true,
      Value: _temp27
    }));
    /* node:coverage ignore next */
    if (_temp26 && typeof _temp26 === 'object' && 'next' in _temp26) _temp26 = skipDebugger(_temp26);
    /* node:coverage ignore next */
    if (_temp26 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(error, Value('errors'), Descriptor({\n      Configurable: Value.true,\n      Enumerable: Value.false,\n      Writable: Value.true,\n      Value: X(CreateArrayFromList(errors)),\n    })) returned an abrupt completion", {
      cause: _temp26
    });
    /* node:coverage ignore next */
    if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
    // c. Return ? Call(promiseCapability.[[Reject]], undefined, « error »).
    return yield* Call(promiseCapability.Reject, Value.undefined, [error]);
  }
  // 12. Return undefined.
  return Value.undefined;
}
PromiseAnyRejectElementFunctions.section = 'https://tc39.es/ecma262/#sec-promise.any-reject-element-functions';
/** https://tc39.es/ecma262/#sec-performpromiseany */
function* PerformPromiseAny(iteratorRecord, constructor, resultCapability, promiseResolve) {
  // 1. Assert: ! IsConstructor(constructor) is true.
  Assert(IsConstructor(constructor), "IsConstructor(constructor)");
  // 2. Assert: resultCapability is a PromiseCapability Record.
  Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
  // 3. Assert: ! IsCallable(promiseResolve) is true.
  Assert(IsCallable(promiseResolve), "IsCallable(promiseResolve)");
  // 4. Let errors be a new empty List.
  const errors = [];
  // 5. Let remainingElementsCount be a new Record { [[Value]]: 1 }.
  const remainingElementsCount = {
    Value: 1
  };
  // 6. Let index be 0.
  let index = 0;
  // 7. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp28 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) return _temp28;
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    // a. Let next be ? IteratorStepValue(iteratorRecord).
    const next = _temp28;
    // d. If next is done, then
    if (next === 'done') {
      // ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.
      remainingElementsCount.Value -= 1;
      // iii. If remainingElementsCount.[[Value]] is 0, then
      if (remainingElementsCount.Value === 0) {
        // 1. Let error be a newly created AggregateError object.
        const error = surroundingAgent.Throw('AggregateError', 'PromiseAnyRejected').Value;
        // 2. Perform ! DefinePropertyOrThrow(error, "errors", Property Descriptor { [[Configurable]]: true, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: errors }).
        /* X */
        let _temp30 = CreateArrayFromList(errors);
        /* node:coverage ignore next */
        if (_temp30 && typeof _temp30 === 'object' && 'next' in _temp30) _temp30 = skipDebugger(_temp30);
        /* node:coverage ignore next */
        if (_temp30 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList(errors) returned an abrupt completion", {
          cause: _temp30
        });
        /* node:coverage ignore next */
        if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
        /* X */
        let _temp29 = DefinePropertyOrThrow(error, Value('errors'), _Descriptor({
          Configurable: Value.true,
          Enumerable: Value.false,
          Writable: Value.true,
          Value: _temp30
        }));
        /* node:coverage ignore next */
        if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) _temp29 = skipDebugger(_temp29);
        /* node:coverage ignore next */
        if (_temp29 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(error, Value('errors'), Descriptor({\n          Configurable: Value.true,\n          Enumerable: Value.false,\n          Writable: Value.true,\n          Value: X(CreateArrayFromList(errors)),\n        })) returned an abrupt completion", {
          cause: _temp29
        });
        /* node:coverage ignore next */
        if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
        // 3. Return ThrowCompletion(error).
        return ThrowCompletion(error);
      }
      // iv. Return resultCapability.[[Promise]].
      return resultCapability.Promise;
    }
    // h. Append undefined to errors.
    errors.push(Value.undefined);
    // i. Let nextPromise be ? Call(promiseResolve, constructor, « next »).
    /* ReturnIfAbrupt */
    let _temp31 = yield* Call(promiseResolve, constructor, [next]);
    /* node:coverage ignore next */
    if (_temp31 instanceof AbruptCompletion) return _temp31;
    /* node:coverage ignore next */
    if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
    const nextPromise = _temp31;
    // j. Let stepsRejected be the algorithm steps defined in Promise.any Reject Element Functions.
    const stepsRejected = PromiseAnyRejectElementFunctions;
    // k. Let lengthRejected be the number of non-optional parameters of the function definition in Promise.any Reject Element Functions.
    const lengthRejected = 1;
    // l. Let onRejected be ! CreateBuiltinFunction(stepsRejected, lengthRejected, "", « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »).
    /* X */
    let _temp32 = CreateBuiltinFunction(stepsRejected, lengthRejected, Value(''), ['AlreadyCalled', 'Index', 'Errors', 'Capability', 'RemainingElements']);
    /* node:coverage ignore next */
    if (_temp32 && typeof _temp32 === 'object' && 'next' in _temp32) _temp32 = skipDebugger(_temp32);
    /* node:coverage ignore next */
    if (_temp32 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(stepsRejected, lengthRejected, Value(''), ['AlreadyCalled', 'Index', 'Errors', 'Capability', 'RemainingElements']) returned an abrupt completion", {
      cause: _temp32
    });
    /* node:coverage ignore next */
    if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
    const onRejected = _temp32;
    // m. Set onRejected.[[AlreadyCalled]] to a new Record { [[Value]]: false }.
    onRejected.AlreadyCalled = {
      Value: false
    };
    // n. Set onRejected.[[Index]] to index.
    onRejected.Index = index;
    // o. Set onRejected.[[Errors]] to errors.
    onRejected.Errors = errors;
    // p. Set onRejected.[[Capability]] to resultCapability.
    onRejected.Capability = resultCapability;
    // q. Set onRejected.[[RemainingElements]] to remainingElementsCount.
    onRejected.RemainingElements = remainingElementsCount;
    // r. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.
    remainingElementsCount.Value += 1;
    // s. Perform ? Invoke(nextPromise, "then", « resultCapability.[[Resolve]], onRejected »).
    /* ReturnIfAbrupt */
    let _temp33 = yield* Invoke(nextPromise, Value('then'), [resultCapability.Resolve, onRejected]);
    /* node:coverage ignore next */
    if (_temp33 instanceof AbruptCompletion) return _temp33;
    /* node:coverage ignore next */
    if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
    // t. Increase index by 1.
    index += 1;
  }
}
PerformPromiseAny.section = 'https://tc39.es/ecma262/#sec-performpromiseany';
/** https://tc39.es/ecma262/#sec-promise.any */
function* Promise_any([iterable = Value.undefined], {
  thisValue
}) {
  // 1. Let C be the this value.
  const C = thisValue;
  // 2. Let promiseCapability be ? NewPromiseCapability(C).
  /* ReturnIfAbrupt */
  let _temp34 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp34 instanceof AbruptCompletion) return _temp34;
  /* node:coverage ignore next */
  if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
  const promiseCapability = _temp34;
  // 3. Let promiseResolve be GetPromiseResolve(C).
  let promiseResolve = yield* GetPromiseResolve(C);
  // 4. IfAbruptRejectPromise(promiseResolve, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (promiseResolve instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [promiseResolve.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (promiseResolve instanceof Completion) promiseResolve = promiseResolve.Value;
  // 5. Let iteratorRecord be GetIterator(iterable).
  let iteratorRecord = yield* GetIterator(iterable, 'sync');
  // 6. IfAbruptRejectPromise(iteratorRecord, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (iteratorRecord instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (iteratorRecord instanceof Completion) iteratorRecord = iteratorRecord.Value;
  // 7. Let result be PerformPromiseAny(iteratorRecord, C, promiseCapability).
  let result = yield* PerformPromiseAny(iteratorRecord, C, promiseCapability, promiseResolve);
  // 8. If result is an abrupt completion, then
  if (result instanceof AbruptCompletion) {
    // a. If iteratorRecord.[[Done]] is false, set result to IteratorClose(iteratorRecord, result).
    if (iteratorRecord.Done === Value.false) {
      result = yield* IteratorClose(iteratorRecord, result);
    }
    // b. IfAbruptRejectPromise(result, promiseCapability).
    /* IfAbruptRejectPromise */
    /* node:coverage disable */
    if (result instanceof AbruptCompletion) {
      const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
      if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
      return promiseCapability.Promise;
    }
    if (result instanceof Completion) result = result.Value;
    /* node:coverage enable */
  }
  // 9. Return ? result.
  return result;
}
Promise_any.section = 'https://tc39.es/ecma262/#sec-promise.any';
function* PerformPromiseRace(iteratorRecord, constructor, resultCapability, promiseResolve) {
  // 1. Assert: IsConstructor(constructor) is true.
  Assert(IsConstructor(constructor), "IsConstructor(constructor)");
  // 2. Assert: resultCapability is a PromiseCapability Record.
  Assert(resultCapability instanceof PromiseCapabilityRecord, "resultCapability instanceof PromiseCapabilityRecord");
  // 3. Assert: IsCallable(promiseResolve) is true.
  Assert(IsCallable(promiseResolve), "IsCallable(promiseResolve)");
  // 4. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp35 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp35 instanceof AbruptCompletion) return _temp35;
    /* node:coverage ignore next */
    if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
    // a. Let next be ? IteratorStepValue(iteratorRecord).
    const next = _temp35;
    // d. If next is done, then
    if (next === 'done') {
      // ii. Return resultCapability.[[Promise]].
      return resultCapability.Promise;
    }
    // h. Let nextPromise be ? Call(promiseResolve, constructor, « next »).
    /* ReturnIfAbrupt */
    let _temp36 = yield* Call(promiseResolve, constructor, [next]);
    /* node:coverage ignore next */
    if (_temp36 instanceof AbruptCompletion) return _temp36;
    /* node:coverage ignore next */
    if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
    const nextPromise = _temp36;
    // i. Perform ? Invoke(nextPromise, "then", « resultCapability.[[Resolve]], resultCapability.[[Reject]] »).
    /* ReturnIfAbrupt */
    let _temp37 = yield* Invoke(nextPromise, Value('then'), [resultCapability.Resolve, resultCapability.Reject]);
    /* node:coverage ignore next */
    if (_temp37 instanceof AbruptCompletion) return _temp37;
    /* node:coverage ignore next */
    if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
  }
}

/** https://tc39.es/ecma262/#sec-promise.race */
function* Promise_race([iterable = Value.undefined], {
  thisValue
}) {
  // 1. Let C be the this value.
  const C = thisValue;
  // 2. Let promiseCapability be ? NewPromiseCapability(C).
  /* ReturnIfAbrupt */
  let _temp38 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp38 instanceof AbruptCompletion) return _temp38;
  /* node:coverage ignore next */
  if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
  const promiseCapability = _temp38;
  // 3. Let promiseResolve be GetPromiseResolve(C).
  let promiseResolve = yield* GetPromiseResolve(C);
  // 4. IfAbruptRejectPromise(promiseResolve, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (promiseResolve instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [promiseResolve.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (promiseResolve instanceof Completion) promiseResolve = promiseResolve.Value;
  /* node:coverage enable */
  // 5. Let iteratorRecord be GetIterator(iterable).
  let iteratorRecord = yield* GetIterator(iterable, 'sync');
  // 6. IfAbruptRejectPromise(iteratorRecord, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (iteratorRecord instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [iteratorRecord.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (iteratorRecord instanceof Completion) iteratorRecord = iteratorRecord.Value;
  // 7. Let result be PerformPromiseRace(iteratorRecord, C, promiseCapability, promiseResolve).
  let result = yield* PerformPromiseRace(iteratorRecord, C, promiseCapability, promiseResolve);
  // 8. If result is an abrupt completion, then
  if (result instanceof AbruptCompletion) {
    // a. If iteratorRecord.[[Done]] is false, set result to IteratorClose(iteratorRecord, result).
    if (iteratorRecord.Done === Value.false) {
      result = yield* IteratorClose(iteratorRecord, result);
    }
    // b. IfAbruptRejectPromise(result, promiseCapability).
    /* IfAbruptRejectPromise */
    /* node:coverage disable */
    if (result instanceof AbruptCompletion) {
      const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
      if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
      return promiseCapability.Promise;
    }
    if (result instanceof Completion) result = result.Value;
    /* node:coverage enable */
  }
  // 9. Return ? result.
  return result;
}
Promise_race.section = 'https://tc39.es/ecma262/#sec-promise.race';
/** https://tc39.es/ecma262/#sec-promise.reject */
function* Promise_reject([r = Value.undefined], {
  thisValue
}) {
  // 1. Let C be this value.
  const C = thisValue;
  // 2. Let promiseCapability be ? NewPromiseCapability(C).
  /* ReturnIfAbrupt */
  let _temp39 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp39 instanceof AbruptCompletion) return _temp39;
  /* node:coverage ignore next */
  if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
  const promiseCapability = _temp39;
  // 3. Perform ? Call(promiseCapability.[[Reject]], undefined, « r »).
  /* ReturnIfAbrupt */
  let _temp40 = yield* Call(promiseCapability.Reject, Value.undefined, [r]);
  /* node:coverage ignore next */
  if (_temp40 instanceof AbruptCompletion) return _temp40;
  /* node:coverage ignore next */
  if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
  // 4. Return promiseCapability.[[Promise]].
  return promiseCapability.Promise;
}
Promise_reject.section = 'https://tc39.es/ecma262/#sec-promise.reject';
/** https://tc39.es/ecma262/#sec-promise.resolve */
function* Promise_resolve([x = Value.undefined], {
  thisValue
}) {
  // 1. Let C be the this value.
  const C = thisValue;
  // 2. If Type(C) is not Object, throw a TypeError exception.
  if (!(C instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'InvalidReceiver', 'Promise.resolve', C);
  }
  // 3. Return ? PromiseResolve(C, x).
  return yield* PromiseResolve(C, x);
}
Promise_resolve.section = 'https://tc39.es/ecma262/#sec-promise.resolve';
/** https://tc39.es/ecma262/#sec-get-promise-@@species */
function Promise_symbolSpecies(_args, {
  thisValue
}) {
  // 1. Return the this value.
  return thisValue;
}
Promise_symbolSpecies.section = 'https://tc39.es/ecma262/#sec-get-promise-@@species';
/** https://tc39.es/ecma262/#sec-promise.try */
function* Promise_try([callback, ...args], {
  thisValue
}) {
  // 1. Let C be the this value.
  const C = thisValue;
  // 2. If C is not an Object, throw a TypeError exception.
  if (!(C instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'InvalidReceiver', 'Promise.try', C);
  }
  // 3. Let promiseCapability be ? NewPromiseCapability(C).
  /* ReturnIfAbrupt */
  let _temp41 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp41 instanceof AbruptCompletion) return _temp41;
  /* node:coverage ignore next */
  if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
  const promiseCapability = _temp41;
  // 4. Let status be Completion(Call(callback, undefined, args)).
  const status = EnsureCompletion(yield* Call(callback, Value.undefined, args));
  if (status instanceof AbruptCompletion) {
    /* ReturnIfAbrupt */
    let _temp42 = yield* Call(promiseCapability.Reject, Value.undefined, [status.Value]);
    /* node:coverage ignore next */
    if (_temp42 instanceof AbruptCompletion) return _temp42;
    /* node:coverage ignore next */
    if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
  } else {
    /* ReturnIfAbrupt */
    let _temp43 = yield* Call(promiseCapability.Resolve, Value.undefined, [status.Value]);
    /* node:coverage ignore next */
    if (_temp43 instanceof AbruptCompletion) return _temp43;
    /* node:coverage ignore next */
    if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
  }
  // 7. Return promiseCapability.[[Promise]].
  return EnsureCompletion(promiseCapability.Promise);
}
Promise_try.section = 'https://tc39.es/ecma262/#sec-promise.try';
/** https://tc39.es/ecma262/#sec-promise.withResolvers */
function* Promise_withResolvers(_args, {
  thisValue
}) {
  // 1. Let C be the this value.
  const C = thisValue;
  // 2. Let promiseCapability be ? NewPromiseCapability(C).
  /* ReturnIfAbrupt */
  let _temp44 = yield* NewPromiseCapability(C);
  /* node:coverage ignore next */
  if (_temp44 instanceof AbruptCompletion) return _temp44;
  /* node:coverage ignore next */
  if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
  const promiseCapability = _temp44;
  // 3. Let obj be OrdinaryObjectCreate(%Object.prototype%).
  /* X */
  let _temp45 = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* node:coverage ignore next */
  if (_temp45 && typeof _temp45 === 'object' && 'next' in _temp45) _temp45 = skipDebugger(_temp45);
  /* node:coverage ignore next */
  if (_temp45 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%')) returned an abrupt completion", {
    cause: _temp45
  });
  /* node:coverage ignore next */
  if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
  const obj = _temp45;
  // 4. Perform ! CreateDataPropertyOrThrow(obj, "promise", promiseCapability.[[Promise]]).
  /* X */
  let _temp46 = CreateDataPropertyOrThrow(obj, Value('promise'), promiseCapability.Promise);
  /* node:coverage ignore next */
  if (_temp46 && typeof _temp46 === 'object' && 'next' in _temp46) _temp46 = skipDebugger(_temp46);
  /* node:coverage ignore next */
  if (_temp46 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(obj, Value('promise'), promiseCapability.Promise) returned an abrupt completion", {
    cause: _temp46
  });
  /* node:coverage ignore next */
  if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
  // 5. Perform ! CreateDataPropertyOrThrow(obj, "resolve", promiseCapability.[[Resolve]]).
  /* X */
  let _temp47 = CreateDataPropertyOrThrow(obj, Value('resolve'), promiseCapability.Resolve);
  /* node:coverage ignore next */
  if (_temp47 && typeof _temp47 === 'object' && 'next' in _temp47) _temp47 = skipDebugger(_temp47);
  /* node:coverage ignore next */
  if (_temp47 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(obj, Value('resolve'), promiseCapability.Resolve) returned an abrupt completion", {
    cause: _temp47
  });
  /* node:coverage ignore next */
  if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
  // 6. Perform ! CreateDataPropertyOrThrow(obj, "reject", promiseCapability.[[Reject]]).
  /* X */
  let _temp48 = CreateDataPropertyOrThrow(obj, Value('reject'), promiseCapability.Reject);
  /* node:coverage ignore next */
  if (_temp48 && typeof _temp48 === 'object' && 'next' in _temp48) _temp48 = skipDebugger(_temp48);
  /* node:coverage ignore next */
  if (_temp48 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(obj, Value('reject'), promiseCapability.Reject) returned an abrupt completion", {
    cause: _temp48
  });
  /* node:coverage ignore next */
  if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
  // 7. Return obj.
  return EnsureCompletion(obj);
}
Promise_withResolvers.section = 'https://tc39.es/ecma262/#sec-promise.withResolvers';
function bootstrapPromise(realmRec) {
  const promiseConstructor = bootstrapConstructor(realmRec, PromiseConstructor, 'Promise', 1, realmRec.Intrinsics['%Promise.prototype%'], [['all', Promise_all, 1], ['allSettled', Promise_allSettled, 1], ['any', Promise_any, 1], ['race', Promise_race, 1], ['reject', Promise_reject, 1], ['resolve', Promise_resolve, 1], ['try', Promise_try, 1], ['withResolvers', Promise_withResolvers, 0], [wellKnownSymbols.species, [Promise_symbolSpecies]]]);
  /* X */
  let _temp49 = promiseConstructor.DefineOwnProperty(Value('prototype'), _Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp49 && typeof _temp49 === 'object' && 'next' in _temp49) _temp49 = skipDebugger(_temp49);
  /* node:coverage ignore next */
  if (_temp49 instanceof AbruptCompletion) throw new Assert.Error("! promiseConstructor.DefineOwnProperty(Value('prototype'), Descriptor({\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp49
  });
  /* node:coverage ignore next */
  if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
  realmRec.Intrinsics['%Promise%'] = promiseConstructor;
}

function isProxyExoticObject(O) {
  return 'ProxyHandler' in O;
}
/** https://tc39.es/ecma262/#sec-proxy-target-handler */
function ProxyConstructor([target = Value.undefined, handler = Value.undefined], {
  NewTarget
}) {
  // 1. f NewTarget is undefined, throw a TypeError exception.
  if (NewTarget === Value.undefined) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. Return ? ProxyCreate(target, handler).
  return ProxyCreate(target, handler);
}
ProxyConstructor.section = 'https://tc39.es/ecma262/#sec-proxy-target-handler';
/** https://tc39.es/ecma262/#sec-proxy-revocation-functions */
function ProxyRevocationFunctions() {
  // 1. Let F be the active function object.
  const F = surroundingAgent.activeFunctionObject;
  // 2. Let p be F.[[RevocableProxy]].
  const p = F.RevocableProxy;
  // 3. If p is null, return undefined.
  if (p === Value.null) {
    return Value.undefined;
  }
  // 4. Set F.[[RevocableProxy]] to null.
  F.RevocableProxy = Value.null;
  // 5. Assert: p is a Proxy object.
  Assert(isProxyExoticObject(p), "isProxyExoticObject(p)");
  // 6. Set p.[[ProxyTarget]] to null.
  p.ProxyTarget = Value.null;
  // 7. Set p.[[ProxyHandler]] to null.
  p.ProxyHandler = Value.null;
  // 8. Return undefined.
  return Value.undefined;
}
ProxyRevocationFunctions.section = 'https://tc39.es/ecma262/#sec-proxy-revocation-functions';
/** https://tc39.es/ecma262/#sec-proxy.revocable */
function Proxy_revocable([target = Value.undefined, handler = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp = ProxyCreate(target, handler);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let p be ? ProxyCreate(target, handler).
  const p = _temp;
  /** https://tc39.es/ecma262/#sec-proxy-revocation-functions. */
  const steps = ProxyRevocationFunctions;
  // 3. Let length be the number of non-optional parameters of the function definition in Proxy Revocation Functions.
  const length = 0;
  // 4. Let revoker be ! CreateBuiltinFunction(steps, length, "", « [[RevocableProxy]] »).
  /* X */
  let _temp2 = CreateBuiltinFunction(steps, length, Value(''), ['RevocableProxy']);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(steps, length, Value(''), ['RevocableProxy']) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const revoker = _temp2;
  // 5. Set revoker.[[RevocableProxy]] to p.
  revoker.RevocableProxy = p;
  // 6. Let result be OrdinaryObjectCreate(%Object.prototype%).
  const result = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  // 7. Perform ! CreateDataPropertyOrThrow(result, "proxy", p).
  /* X */
  let _temp3 = CreateDataProperty(result, Value('proxy'), p);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(result, Value('proxy'), p) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 8. Perform ! CreateDataPropertyOrThrow(result, "revoke", revoker).
  /* X */
  let _temp4 = CreateDataProperty(result, Value('revoke'), revoker);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(result, Value('revoke'), revoker) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 9. Return result.
  return result;
}
Proxy_revocable.section = 'https://tc39.es/ecma262/#sec-proxy.revocable';
function bootstrapProxy(realmRec) {
  const proxyConstructor = CreateBuiltinFunction(ProxyConstructor, 2, Value('Proxy'), [], realmRec, undefined, undefined, Value.true);
  assignProps(realmRec, proxyConstructor, [['revocable', Proxy_revocable, 2]]);
  realmRec.Intrinsics['%Proxy%'] = proxyConstructor;
}

/** https://tc39.es/ecma262/#sec-reflect.apply */
function* Reflect_apply([target = Value.undefined, thisArgument = Value.undefined, argumentsList = Value.undefined]) {
  // 1. If IsCallable(target) is false, throw a TypeError exception.
  if (!IsCallable(target)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', target);
  }
  // 2. Let args be ? CreateListFromArrayLike(argumentsList).
  /* ReturnIfAbrupt */
  let _temp = yield* CreateListFromArrayLike(argumentsList);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const args = _temp;
  // 3. Perform PrepareForTailCall().
  PrepareForTailCall();
  // 4. Return ? Call(target, thisArgument, args).
  return yield* Call(target, thisArgument, args);
}
Reflect_apply.section = 'https://tc39.es/ecma262/#sec-reflect.apply';
/** https://tc39.es/ecma262/#sec-reflect.construct */
function* Reflect_construct([target = Value.undefined, argumentsList = Value.undefined, newTarget]) {
  // 1. If IsConstructor(target) is false, throw a TypeError exception.
  if (!IsConstructor(target)) {
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', target);
  }
  // 2. If newTarget is not present, set newTarget to target.
  if (newTarget === undefined) {
    newTarget = target;
  } else if (!IsConstructor(newTarget)) {
    // 3. Else if IsConstructor(newTarget) is false, throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'NotAConstructor', newTarget);
  }
  // 4. Let args be ? CreateListFromArrayLike(argumentsList).
  /* ReturnIfAbrupt */
  let _temp2 = yield* CreateListFromArrayLike(argumentsList);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const args = _temp2;
  // 5. Return ? Construct(target, args, newTarget).
  return yield* Construct(target, args, newTarget);
}
Reflect_construct.section = 'https://tc39.es/ecma262/#sec-reflect.construct';
/** https://tc39.es/ecma262/#sec-reflect.defineproperty */
function* Reflect_defineProperty([target = Value.undefined, propertyKey = Value.undefined, attributes = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Let key be ? ToPropertyKey(propertyKey).
  /* ReturnIfAbrupt */
  let _temp3 = yield* ToPropertyKey(propertyKey);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const key = _temp3;
  // 3. Let desc be ? ToPropertyDescriptor(attributes).
  /* ReturnIfAbrupt */
  let _temp4 = yield* ToPropertyDescriptor(attributes);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const desc = _temp4;
  // 4. Return ? target.[[DefineOwnProperty]](key, desc).
  return yield* target.DefineOwnProperty(key, desc);
}
Reflect_defineProperty.section = 'https://tc39.es/ecma262/#sec-reflect.defineproperty';
/** https://tc39.es/ecma262/#sec-reflect.deleteproperty */
function* Reflect_deleteProperty([target = Value.undefined, propertyKey = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Let key be ? ToPropertyKey(propertyKey).
  /* ReturnIfAbrupt */
  let _temp5 = yield* ToPropertyKey(propertyKey);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const key = _temp5;
  // 3. Return ? target.[[Delete]](key).
  return yield* target.Delete(key);
}
Reflect_deleteProperty.section = 'https://tc39.es/ecma262/#sec-reflect.deleteproperty';
/** https://tc39.es/ecma262/#sec-reflect.get */
function* Reflect_get([target = Value.undefined, propertyKey = Value.undefined, receiver]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Let key be ? ToPropertyKey(propertyKey).
  /* ReturnIfAbrupt */
  let _temp6 = yield* ToPropertyKey(propertyKey);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const key = _temp6;
  // 3. If receiver is not present, then
  if (receiver === undefined) {
    // a. Set receiver to target.
    receiver = target;
  }
  // 4. Return ? target.[[Get]](key, receiver).
  return yield* target.Get(key, receiver);
}
Reflect_get.section = 'https://tc39.es/ecma262/#sec-reflect.get';
/** https://tc39.es/ecma262/#sec-reflect.getownpropertydescriptor */
function* Reflect_getOwnPropertyDescriptor([target = Value.undefined, propertyKey = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Let key be ? ToPropertyKey(propertyKey).
  /* ReturnIfAbrupt */
  let _temp7 = yield* ToPropertyKey(propertyKey);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const key = _temp7;
  // 3. Let desc be ? target.[[GetOwnProperty]](key).
  /* ReturnIfAbrupt */
  let _temp8 = yield* target.GetOwnProperty(key);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const desc = _temp8;
  // 4. Return FromPropertyDescriptor(desc).
  return FromPropertyDescriptor(desc);
}
Reflect_getOwnPropertyDescriptor.section = 'https://tc39.es/ecma262/#sec-reflect.getownpropertydescriptor';
/** https://tc39.es/ecma262/#sec-reflect.getprototypeof */
function* Reflect_getPrototypeOf([target = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Return ? target.[[GetPrototypeOf]]().
  return yield* target.GetPrototypeOf();
}
Reflect_getPrototypeOf.section = 'https://tc39.es/ecma262/#sec-reflect.getprototypeof';
/** https://tc39.es/ecma262/#sec-reflect.has */
function* Reflect_has([target = Value.undefined, propertyKey = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Let key be ? ToPropertyKey(propertyKey).
  /* ReturnIfAbrupt */
  let _temp9 = yield* ToPropertyKey(propertyKey);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const key = _temp9;
  // 3. Return ? target.[[HasProperty]](key).
  return yield* target.HasProperty(key);
}
Reflect_has.section = 'https://tc39.es/ecma262/#sec-reflect.has';
/** https://tc39.es/ecma262/#sec-reflect.isextensible */
function* Reflect_isExtensible([target = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Return ? target.[[IsExtensible]]().
  return yield* target.IsExtensible();
}
Reflect_isExtensible.section = 'https://tc39.es/ecma262/#sec-reflect.isextensible';
/** https://tc39.es/ecma262/#sec-reflect.ownkeys */
function* Reflect_ownKeys([target = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Let keys be ? target.[[OwnPropertyKeys]]().
  /* ReturnIfAbrupt */
  let _temp10 = yield* target.OwnPropertyKeys();
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const keys = _temp10;
  // 3. Return CreateArrayFromList(keys).
  return CreateArrayFromList(keys);
}
Reflect_ownKeys.section = 'https://tc39.es/ecma262/#sec-reflect.ownkeys';
/** https://tc39.es/ecma262/#sec-reflect.preventextensions */
function* Reflect_preventExtensions([target = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Return ? target.[[PreventExtensions]]().
  return yield* target.PreventExtensions();
}
Reflect_preventExtensions.section = 'https://tc39.es/ecma262/#sec-reflect.preventextensions';
/** https://tc39.es/ecma262/#sec-reflect.set */
function* Reflect_set([target = Value.undefined, propertyKey = Value.undefined, V = Value.undefined, receiver]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. Let key be ? ToPropertyKey(propertyKey).
  /* ReturnIfAbrupt */
  let _temp11 = yield* ToPropertyKey(propertyKey);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const key = _temp11;
  // 3. If receiver is not present, then
  if (receiver === undefined) {
    receiver = target;
  }
  // 4. Return ? target.[[Set]](key, V, receiver).
  return yield* target.Set(key, V, receiver);
}
Reflect_set.section = 'https://tc39.es/ecma262/#sec-reflect.set';
/** https://tc39.es/ecma262/#sec-reflect.setprototypeof */
function* Reflect_setPrototypeOf([target = Value.undefined, proto = Value.undefined]) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', target);
  }
  // 2. If Type(proto) is not Object and proto is not null, throw a TypeError exception.
  if (!(proto instanceof ObjectValue) && proto !== Value.null) {
    return surroundingAgent.Throw('TypeError', 'ObjectPrototypeType');
  }
  // 3. Return ? target.[[SetPrototypeOf]](proto).
  return yield* target.SetPrototypeOf(proto);
}
Reflect_setPrototypeOf.section = 'https://tc39.es/ecma262/#sec-reflect.setprototypeof';
function bootstrapReflect(realmRec) {
  const reflect = bootstrapPrototype(realmRec, [['apply', Reflect_apply, 3], ['construct', Reflect_construct, 2], ['defineProperty', Reflect_defineProperty, 3], ['deleteProperty', Reflect_deleteProperty, 2], ['get', Reflect_get, 2], ['getOwnPropertyDescriptor', Reflect_getOwnPropertyDescriptor, 2], ['getPrototypeOf', Reflect_getPrototypeOf, 1], ['has', Reflect_has, 2], ['isExtensible', Reflect_isExtensible, 1], ['ownKeys', Reflect_ownKeys, 1], ['preventExtensions', Reflect_preventExtensions, 1], ['set', Reflect_set, 3], ['setPrototypeOf', Reflect_setPrototypeOf, 2]], realmRec.Intrinsics['%Object.prototype%'], 'Reflect');
  realmRec.Intrinsics['%Reflect%'] = reflect;
}

function thisStringValue(value) {
  if (value instanceof JSStringValue) {
    return value;
  }
  if (value instanceof ObjectValue && 'StringData' in value) {
    const s = value.StringData;
    Assert(s instanceof JSStringValue, "s instanceof JSStringValue");
    return s;
  }
  return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'String', value);
}

/** https://tc39.es/ecma262/#sec-string.prototype.charat */
function* StringProto_charAt([pos = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const O = _temp;
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const S = _temp2;
  /* ReturnIfAbrupt */
  let _temp3 = yield* ToIntegerOrInfinity(pos);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const position = _temp3;
  const size = S.stringValue().length;
  if (position < 0 || position >= size) {
    return Value('');
  }
  return Value(S.stringValue()[position]);
}
StringProto_charAt.section = 'https://tc39.es/ecma262/#sec-string.prototype.charat';
/** https://tc39.es/ecma262/#sec-string.prototype.charcodeat */
function* StringProto_charCodeAt([pos = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp4 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const O = _temp4;
  /* ReturnIfAbrupt */
  let _temp5 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const S = _temp5;
  /* ReturnIfAbrupt */
  let _temp6 = yield* ToIntegerOrInfinity(pos);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const position = _temp6;
  const size = S.stringValue().length;
  if (position < 0 || position >= size) {
    return F(NaN);
  }
  return F(S.stringValue().charCodeAt(position));
}
StringProto_charCodeAt.section = 'https://tc39.es/ecma262/#sec-string.prototype.charcodeat';
/** https://tc39.es/ecma262/#sec-string.prototype.codepointat */
function* StringProto_codePointAt([pos = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp7 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const O = _temp7;
  /* ReturnIfAbrupt */
  let _temp8 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const S = _temp8;
  /* ReturnIfAbrupt */
  let _temp9 = yield* ToIntegerOrInfinity(pos);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const position = _temp9;
  const size = S.stringValue().length;
  if (position < 0 || position >= size) {
    return Value.undefined;
  }
  /* X */
  let _temp10 = CodePointAt(S.stringValue(), position);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! CodePointAt(S.stringValue(), position) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const cp = _temp10;
  return F(cp.CodePoint);
}
StringProto_codePointAt.section = 'https://tc39.es/ecma262/#sec-string.prototype.codepointat';
/** https://tc39.es/ecma262/#sec-string.prototype.concat */
function* StringProto_concat(args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp11 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const O = _temp11;
  /* ReturnIfAbrupt */
  let _temp12 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  const S = _temp12;
  let R = S.stringValue();
  const _args = [...args];
  while (_args.length > 0) {
    const next = _args.shift();
    /* ReturnIfAbrupt */
    let _temp13 = yield* ToString(next);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) return _temp13;
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    const nextString = _temp13;
    R = `${R}${nextString.stringValue()}`;
  }
  return Value(R);
}
StringProto_concat.section = 'https://tc39.es/ecma262/#sec-string.prototype.concat';
/** https://tc39.es/ecma262/#sec-string.prototype.endswith */
function* StringProto_endsWith([searchString = Value.undefined, endPosition = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp14 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const O = _temp14;
  /* ReturnIfAbrupt */
  let _temp15 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const S = _temp15.stringValue();
  /* ReturnIfAbrupt */
  let _temp16 = yield* IsRegExp(searchString);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  const isRegExp = _temp16;
  if (isRegExp === Value.true) {
    return surroundingAgent.Throw('TypeError', 'RegExpArgumentNotAllowed', 'String.prototype.endsWith');
  }
  /* ReturnIfAbrupt */
  let _temp17 = yield* ToString(searchString);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  const searchStr = _temp17.stringValue();
  const len = S.length;
  let pos;
  if (endPosition === Value.undefined) {
    pos = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp18 = yield* ToIntegerOrInfinity(endPosition);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) return _temp18;
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    pos = _temp18;
  }
  const end = Math.min(Math.max(pos, 0), len);
  const searchLength = searchStr.length;
  const start = end - searchLength;
  if (start < 0) {
    return Value.false;
  }
  for (let i = 0; i < searchLength; i += 1) {
    if (S.charCodeAt(start + i) !== searchStr.charCodeAt(i)) {
      return Value.false;
    }
  }
  return Value.true;
}
StringProto_endsWith.section = 'https://tc39.es/ecma262/#sec-string.prototype.endswith';
/** https://tc39.es/ecma262/#sec-string.prototype.includes */
function* StringProto_includes([searchString = Value.undefined, position = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp19 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) return _temp19;
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  const O = _temp19;
  /* ReturnIfAbrupt */
  let _temp20 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  const S = _temp20.stringValue();
  /* ReturnIfAbrupt */
  let _temp21 = yield* IsRegExp(searchString);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  const isRegExp = _temp21;
  if (isRegExp === Value.true) {
    return surroundingAgent.Throw('TypeError', 'RegExpArgumentNotAllowed', 'String.prototype.includes');
  }
  /* ReturnIfAbrupt */
  let _temp22 = yield* ToString(searchString);
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) return _temp22;
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  const searchStr = _temp22.stringValue();
  /* ReturnIfAbrupt */
  let _temp23 = yield* ToIntegerOrInfinity(position);
  /* node:coverage ignore next */
  if (_temp23 instanceof AbruptCompletion) return _temp23;
  /* node:coverage ignore next */
  if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
  const pos = _temp23;
  Assert(!(position === Value.undefined) || pos === 0, "!(position === Value.undefined) || pos === 0");
  const len = S.length;
  const start = Math.min(Math.max(pos, 0), len);
  const searchLen = searchStr.length;
  let k = start;
  while (k + searchLen <= len) {
    let match = true;
    for (let j = 0; j < searchLen; j += 1) {
      if (searchStr[j] !== S[k + j]) {
        match = false;
        break;
      }
    }
    if (match) {
      return Value.true;
    }
    k += 1;
  }
  return Value.false;
}
StringProto_includes.section = 'https://tc39.es/ecma262/#sec-string.prototype.includes';
/** https://tc39.es/ecma262/#sec-string.prototype.indexof */
function* StringProto_indexOf([searchString = Value.undefined, position = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp24 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) return _temp24;
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  // 1. Let O be ? RequireObjectCoercible(this value).
  const O = _temp24;
  // 2. Let S be ? ToString(O).
  /* ReturnIfAbrupt */
  let _temp25 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  const S = _temp25;
  // 3. Let searchStr be ? ToString(searchString).
  /* ReturnIfAbrupt */
  let _temp26 = yield* ToString(searchString);
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  const searchStr = _temp26;
  // 4. Let pos be ? ToIntegerOrInfinity(position).
  /* ReturnIfAbrupt */
  let _temp27 = yield* ToIntegerOrInfinity(position);
  /* node:coverage ignore next */
  if (_temp27 instanceof AbruptCompletion) return _temp27;
  /* node:coverage ignore next */
  if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
  const pos = _temp27;
  // 5. Assert: If position is undefined, then pos is 0.
  Assert(!(position === Value.undefined) || pos === 0, "!(position === Value.undefined) || pos === 0");
  // 6. Let len be the length of S.
  const len = S.stringValue().length;
  // 7. Let start be min(max(pos, 0), len).
  const start = Math.min(Math.max(pos, 0), len);
  // 8. Return ! StringIndexOf(S, searchStr, start).
  /* X */
  let _temp28 = StringIndexOf(S, searchStr, start);
  /* node:coverage ignore next */
  if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) _temp28 = skipDebugger(_temp28);
  /* node:coverage ignore next */
  if (_temp28 instanceof AbruptCompletion) throw new Assert.Error("! StringIndexOf(S, searchStr, start) returned an abrupt completion", {
    cause: _temp28
  });
  /* node:coverage ignore next */
  if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
  return _temp28;
}
StringProto_indexOf.section = 'https://tc39.es/ecma262/#sec-string.prototype.indexof';
/** https://tc39.es/ecma262/#sec-string.prototype.iswellformed */
function* StringProto_isWellFormed(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp29 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp29 instanceof AbruptCompletion) return _temp29;
  /* node:coverage ignore next */
  if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
  // 1. Let O be ? RequireObjectCoercible(this value).
  const O = _temp29;
  // 2. Let S be ? ToString(O).
  /* ReturnIfAbrupt */
  let _temp30 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp30 instanceof AbruptCompletion) return _temp30;
  /* node:coverage ignore next */
  if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
  const S = _temp30;
  // 3. Return IsStringWellFormedUnicode(S).
  return IsStringWellFormedUnicode(S) ? Value.true : Value.false;
}
StringProto_isWellFormed.section = 'https://tc39.es/ecma262/#sec-string.prototype.iswellformed';
/** https://tc39.es/ecma262/#sec-string.prototype.lastindexof */
function* StringProto_lastIndexOf([searchString = Value.undefined, position = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp31 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp31 && typeof _temp31 === 'object' && 'next' in _temp31) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp31 instanceof AbruptCompletion) return _temp31;
  /* node:coverage ignore next */
  if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
  const O = _temp31;
  /* ReturnIfAbrupt */
  let _temp32 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp32 instanceof AbruptCompletion) return _temp32;
  /* node:coverage ignore next */
  if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
  const S = _temp32.stringValue();
  /* ReturnIfAbrupt */
  let _temp33 = yield* ToString(searchString);
  /* node:coverage ignore next */
  if (_temp33 instanceof AbruptCompletion) return _temp33;
  /* node:coverage ignore next */
  if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
  const searchStr = _temp33.stringValue();
  /* ReturnIfAbrupt */
  let _temp34 = yield* ToNumber(position);
  /* node:coverage ignore next */
  if (_temp34 instanceof AbruptCompletion) return _temp34;
  /* node:coverage ignore next */
  if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
  const numPos = _temp34;
  Assert(!(position === Value.undefined) || numPos.isNaN(), "!(position === Value.undefined) || numPos.isNaN()");
  let pos;
  if (numPos.isNaN()) {
    pos = Infinity;
  } else {
    /* X */
    let _temp35 = ToIntegerOrInfinity(numPos);
    /* node:coverage ignore next */
    if (_temp35 && typeof _temp35 === 'object' && 'next' in _temp35) _temp35 = skipDebugger(_temp35);
    /* node:coverage ignore next */
    if (_temp35 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(numPos) returned an abrupt completion", {
      cause: _temp35
    });
    /* node:coverage ignore next */
    if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
    pos = _temp35;
  }
  const len = S.length;
  const start = Math.min(Math.max(pos, 0), len);
  const searchLen = searchStr.length;
  let k = start;
  while (k >= 0) {
    if (k + searchLen <= len) {
      let match = true;
      for (let j = 0; j < searchLen; j += 1) {
        if (searchStr[j] !== S[k + j]) {
          match = false;
          break;
        }
      }
      if (match) {
        return F(k);
      }
    }
    k -= 1;
  }
  return F(-1);
}
StringProto_lastIndexOf.section = 'https://tc39.es/ecma262/#sec-string.prototype.lastindexof';
/** https://tc39.es/ecma262/#sec-string.prototype.localecompare */
function* StringProto_localeCompare([that = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp36 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp36 && typeof _temp36 === 'object' && 'next' in _temp36) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp36 instanceof AbruptCompletion) return _temp36;
  /* node:coverage ignore next */
  if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
  const O = _temp36;
  /* ReturnIfAbrupt */
  let _temp37 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp37 instanceof AbruptCompletion) return _temp37;
  /* node:coverage ignore next */
  if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
  const S = _temp37.stringValue();
  /* ReturnIfAbrupt */
  let _temp38 = yield* ToString(that);
  /* node:coverage ignore next */
  if (_temp38 instanceof AbruptCompletion) return _temp38;
  /* node:coverage ignore next */
  if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
  const That = _temp38.stringValue();
  if (S === That) {
    return F(0);
  } else if (S < That) {
    return F(-1);
  } else {
    return F(1);
  }
}
StringProto_localeCompare.section = 'https://tc39.es/ecma262/#sec-string.prototype.localecompare';
/** https://tc39.es/ecma262/#sec-string.prototype.match */
function* StringProto_match([regexp = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp39 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp39 && typeof _temp39 === 'object' && 'next' in _temp39) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp39 instanceof AbruptCompletion) return _temp39;
  /* node:coverage ignore next */
  if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
  const O = _temp39;
  if (regexp instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp40 = yield* GetMethod(regexp, wellKnownSymbols.match);
    /* node:coverage ignore next */
    if (_temp40 instanceof AbruptCompletion) return _temp40;
    /* node:coverage ignore next */
    if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
    const matcher = _temp40;
    if (matcher !== Value.undefined) {
      return yield* Call(matcher, regexp, [O]);
    }
  }
  /* ReturnIfAbrupt */
  let _temp41 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp41 instanceof AbruptCompletion) return _temp41;
  /* node:coverage ignore next */
  if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
  const S = _temp41;
  /* ReturnIfAbrupt */
  let _temp42 = yield* RegExpCreate(regexp, Value.undefined);
  /* node:coverage ignore next */
  if (_temp42 instanceof AbruptCompletion) return _temp42;
  /* node:coverage ignore next */
  if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
  const rx = _temp42;
  return yield* Invoke(rx, wellKnownSymbols.match, [S]);
}
StringProto_match.section = 'https://tc39.es/ecma262/#sec-string.prototype.match';
/** https://tc39.es/ecma262/#sec-string.prototype.matchall */
function* StringProto_matchAll([regexp = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp43 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp43 && typeof _temp43 === 'object' && 'next' in _temp43) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp43 instanceof AbruptCompletion) return _temp43;
  /* node:coverage ignore next */
  if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
  // 1. Let O be ? RequireObjectCoercible(this value).
  const O = _temp43;
  // 2. If regexp is an Object, then
  if (regexp instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp44 = yield* IsRegExp(regexp);
    /* node:coverage ignore next */
    if (_temp44 instanceof AbruptCompletion) return _temp44;
    /* node:coverage ignore next */
    if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
    // a. Let isRegExp be ? IsRegExp(regexp).
    const isRegExp = _temp44;
    // b. If isRegExp is true, then
    if (isRegExp === Value.true) {
      /* ReturnIfAbrupt */
      let _temp45 = yield* Get(regexp, Value('flags'));
      /* node:coverage ignore next */
      if (_temp45 instanceof AbruptCompletion) return _temp45;
      /* node:coverage ignore next */
      if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
      // i. Let flags be ? Get(regexp, "flags").
      const flags = _temp45;
      // ii. Perform ? RequireObjectCoercible(flags).
      /* ReturnIfAbrupt */
      let _temp46 = RequireObjectCoercible(flags);
      /* node:coverage ignore next */
      if (_temp46 && typeof _temp46 === 'object' && 'next' in _temp46) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp46 instanceof AbruptCompletion) return _temp46;
      /* node:coverage ignore next */
      if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
      // iii. If ? ToString(flags) does not contain "g", throw a TypeError exception.
      /* ReturnIfAbrupt */
      let _temp47 = yield* ToString(flags);
      /* node:coverage ignore next */
      if (_temp47 instanceof AbruptCompletion) return _temp47;
      /* node:coverage ignore next */
      if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
      if (!_temp47.stringValue().includes('g')) {
        return surroundingAgent.Throw('TypeError', 'StringPrototypeMethodGlobalRegExp', 'matchAll');
      }
    }
    // c. Let matcher be ? GetMethod(regexp, @@matchAll).
    /* ReturnIfAbrupt */
    let _temp48 = yield* GetMethod(regexp, wellKnownSymbols.matchAll);
    /* node:coverage ignore next */
    if (_temp48 instanceof AbruptCompletion) return _temp48;
    /* node:coverage ignore next */
    if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
    const matcher = _temp48;
    // d. If matcher is not undefined, then
    if (matcher !== Value.undefined) {
      // i. Return ? Call(matcher, regexp, « O »).
      return yield* Call(matcher, regexp, [O]);
    }
  }
  // 3. Let S be ? ToString(O).
  /* ReturnIfAbrupt */
  let _temp49 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp49 instanceof AbruptCompletion) return _temp49;
  /* node:coverage ignore next */
  if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
  const S = _temp49;
  // 4. Let rx be ? RegExpCreate(regexp, "g").
  /* ReturnIfAbrupt */
  let _temp50 = yield* RegExpCreate(regexp, Value('g'));
  /* node:coverage ignore next */
  if (_temp50 instanceof AbruptCompletion) return _temp50;
  /* node:coverage ignore next */
  if (_temp50 instanceof Completion) _temp50 = _temp50.Value;
  const rx = _temp50;
  // 5. Return ? Invoke(rx, @@matchAll, « S »).
  return yield* Invoke(rx, wellKnownSymbols.matchAll, [S]);
}
StringProto_matchAll.section = 'https://tc39.es/ecma262/#sec-string.prototype.matchall';
/** https://tc39.es/ecma262/#sec-string.prototype.normalize */
function* StringProto_normalize([form = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp51 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp51 && typeof _temp51 === 'object' && 'next' in _temp51) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp51 instanceof AbruptCompletion) return _temp51;
  /* node:coverage ignore next */
  if (_temp51 instanceof Completion) _temp51 = _temp51.Value;
  const O = _temp51;
  /* ReturnIfAbrupt */
  let _temp52 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp52 instanceof AbruptCompletion) return _temp52;
  /* node:coverage ignore next */
  if (_temp52 instanceof Completion) _temp52 = _temp52.Value;
  const S = _temp52;
  if (form === Value.undefined) {
    form = Value('NFC');
  } else {
    /* ReturnIfAbrupt */
    let _temp53 = yield* ToString(form);
    /* node:coverage ignore next */
    if (_temp53 instanceof AbruptCompletion) return _temp53;
    /* node:coverage ignore next */
    if (_temp53 instanceof Completion) _temp53 = _temp53.Value;
    form = _temp53;
  }
  const f = form.stringValue();
  if (!['NFC', 'NFD', 'NFKC', 'NFKD'].includes(f)) {
    return surroundingAgent.Throw('RangeError', 'NormalizeInvalidForm');
  }
  const ns = S.stringValue().normalize(f);
  return Value(ns);
}
StringProto_normalize.section = 'https://tc39.es/ecma262/#sec-string.prototype.normalize';
/** https://tc39.es/ecma262/#sec-string.prototype.padend */
function* StringProto_padEnd([maxLength = Value.undefined, fillString = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp54 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp54 && typeof _temp54 === 'object' && 'next' in _temp54) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp54 instanceof AbruptCompletion) return _temp54;
  /* node:coverage ignore next */
  if (_temp54 instanceof Completion) _temp54 = _temp54.Value;
  const O = _temp54;
  return yield* StringPad(O, maxLength, fillString, 'end');
}
StringProto_padEnd.section = 'https://tc39.es/ecma262/#sec-string.prototype.padend';
/** https://tc39.es/ecma262/#sec-string.prototype.padstart */
function* StringProto_padStart([maxLength = Value.undefined, fillString = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp55 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp55 && typeof _temp55 === 'object' && 'next' in _temp55) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp55 instanceof AbruptCompletion) return _temp55;
  /* node:coverage ignore next */
  if (_temp55 instanceof Completion) _temp55 = _temp55.Value;
  const O = _temp55;
  return yield* StringPad(O, maxLength, fillString, 'start');
}
StringProto_padStart.section = 'https://tc39.es/ecma262/#sec-string.prototype.padstart';
/** https://tc39.es/ecma262/#sec-string.prototype.repeat */
function* StringProto_repeat([count = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp56 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp56 && typeof _temp56 === 'object' && 'next' in _temp56) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp56 instanceof AbruptCompletion) return _temp56;
  /* node:coverage ignore next */
  if (_temp56 instanceof Completion) _temp56 = _temp56.Value;
  const O = _temp56;
  /* ReturnIfAbrupt */
  let _temp57 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp57 instanceof AbruptCompletion) return _temp57;
  /* node:coverage ignore next */
  if (_temp57 instanceof Completion) _temp57 = _temp57.Value;
  const S = _temp57;
  /* ReturnIfAbrupt */
  let _temp58 = yield* ToIntegerOrInfinity(count);
  /* node:coverage ignore next */
  if (_temp58 instanceof AbruptCompletion) return _temp58;
  /* node:coverage ignore next */
  if (_temp58 instanceof Completion) _temp58 = _temp58.Value;
  const n = _temp58;
  if (n < 0) {
    return surroundingAgent.Throw('RangeError', 'StringRepeatCount', n);
  }
  if (n === Infinity || n === -Infinity) {
    return surroundingAgent.Throw('RangeError', 'StringRepeatCount', n);
  }
  if (n === 0) {
    return Value('');
  }
  let T = '';
  for (let i = 0; i < n; i += 1) {
    T += S.stringValue();
  }
  return Value(T);
}
StringProto_repeat.section = 'https://tc39.es/ecma262/#sec-string.prototype.repeat';
/** https://tc39.es/ecma262/#sec-string.prototype.replace */
function* StringProto_replace([searchValue = Value.undefined, replaceValue = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp59 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp59 && typeof _temp59 === 'object' && 'next' in _temp59) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp59 instanceof AbruptCompletion) return _temp59;
  /* node:coverage ignore next */
  if (_temp59 instanceof Completion) _temp59 = _temp59.Value;
  const O = _temp59;
  if (searchValue instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp60 = yield* GetMethod(searchValue, wellKnownSymbols.replace);
    /* node:coverage ignore next */
    if (_temp60 instanceof AbruptCompletion) return _temp60;
    /* node:coverage ignore next */
    if (_temp60 instanceof Completion) _temp60 = _temp60.Value;
    const replacer = _temp60;
    if (replacer !== Value.undefined) {
      return yield* Call(replacer, searchValue, [O, replaceValue]);
    }
  }
  /* ReturnIfAbrupt */
  let _temp61 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp61 instanceof AbruptCompletion) return _temp61;
  /* node:coverage ignore next */
  if (_temp61 instanceof Completion) _temp61 = _temp61.Value;
  const string = _temp61;
  /* ReturnIfAbrupt */
  let _temp62 = yield* ToString(searchValue);
  /* node:coverage ignore next */
  if (_temp62 instanceof AbruptCompletion) return _temp62;
  /* node:coverage ignore next */
  if (_temp62 instanceof Completion) _temp62 = _temp62.Value;
  const searchString = _temp62;
  const functionalReplace = IsCallable(replaceValue);
  if (!functionalReplace) {
    /* ReturnIfAbrupt */
    let _temp63 = yield* ToString(replaceValue);
    /* node:coverage ignore next */
    if (_temp63 instanceof AbruptCompletion) return _temp63;
    /* node:coverage ignore next */
    if (_temp63 instanceof Completion) _temp63 = _temp63.Value;
    replaceValue = _temp63;
  }
  const searchLength = searchString.stringValue().length;
  const position = string.stringValue().indexOf(searchString.stringValue(), 0);
  if (position === -1) {
    return string;
  }
  const preceding = string.stringValue().slice(0, position);
  const following = string.stringValue().slice(position + searchLength);
  let replacement;
  if (functionalReplace) {
    /* ReturnIfAbrupt */
    let _temp65 = yield* Call(replaceValue, Value.undefined, [searchString, F(position), string]);
    /* node:coverage ignore next */
    if (_temp65 instanceof AbruptCompletion) return _temp65;
    /* node:coverage ignore next */
    if (_temp65 instanceof Completion) _temp65 = _temp65.Value;
    /* ReturnIfAbrupt */
    let _temp64 = yield* ToString(_temp65);
    /* node:coverage ignore next */
    if (_temp64 instanceof AbruptCompletion) return _temp64;
    /* node:coverage ignore next */
    if (_temp64 instanceof Completion) _temp64 = _temp64.Value;
    replacement = _temp64;
  } else {
    Assert(replaceValue instanceof JSStringValue, "replaceValue instanceof JSStringValue");
    const captures = [];
    /* X */
    let _temp66 = GetSubstitution(searchString, string, position, captures, Value.undefined, replaceValue);
    /* node:coverage ignore next */
    if (_temp66 && typeof _temp66 === 'object' && 'next' in _temp66) _temp66 = skipDebugger(_temp66);
    /* node:coverage ignore next */
    if (_temp66 instanceof AbruptCompletion) throw new Assert.Error("! GetSubstitution(searchString, string, position, captures, Value.undefined, replaceValue) returned an abrupt completion", {
      cause: _temp66
    });
    /* node:coverage ignore next */
    if (_temp66 instanceof Completion) _temp66 = _temp66.Value;
    replacement = _temp66;
  }
  return Value(preceding + replacement.stringValue() + following);
}
StringProto_replace.section = 'https://tc39.es/ecma262/#sec-string.prototype.replace';
/** https://tc39.es/ecma262/#sec-string.prototype.replaceall */
function* StringProto_replaceAll([searchValue = Value.undefined, replaceValue = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp67 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp67 && typeof _temp67 === 'object' && 'next' in _temp67) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp67 instanceof AbruptCompletion) return _temp67;
  /* node:coverage ignore next */
  if (_temp67 instanceof Completion) _temp67 = _temp67.Value;
  // 1. Let O be ? RequireObjectCoercible(this value).
  const O = _temp67;
  // 2.If searchValue is an Object, then
  if (searchValue instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp68 = yield* IsRegExp(searchValue);
    /* node:coverage ignore next */
    if (_temp68 instanceof AbruptCompletion) return _temp68;
    /* node:coverage ignore next */
    if (_temp68 instanceof Completion) _temp68 = _temp68.Value;
    // a. Let isRegExp be ? IsRegExp(searchValue).
    const isRegExp = _temp68;
    // b. If isRegExp is true, then
    if (isRegExp === Value.true) {
      /* ReturnIfAbrupt */
      let _temp69 = yield* Get(searchValue, Value('flags'));
      /* node:coverage ignore next */
      if (_temp69 instanceof AbruptCompletion) return _temp69;
      /* node:coverage ignore next */
      if (_temp69 instanceof Completion) _temp69 = _temp69.Value;
      // i. Let flags be ? Get(searchValue, "flags").
      const flags = _temp69;
      // ii. Perform ? RequireObjectCoercible(flags).
      /* ReturnIfAbrupt */
      let _temp70 = RequireObjectCoercible(flags);
      /* node:coverage ignore next */
      if (_temp70 && typeof _temp70 === 'object' && 'next' in _temp70) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp70 instanceof AbruptCompletion) return _temp70;
      /* node:coverage ignore next */
      if (_temp70 instanceof Completion) _temp70 = _temp70.Value;
      // iii. If ? ToString(flags) does not contain "g", throw a TypeError exception.
      /* ReturnIfAbrupt */
      let _temp71 = yield* ToString(flags);
      /* node:coverage ignore next */
      if (_temp71 instanceof AbruptCompletion) return _temp71;
      /* node:coverage ignore next */
      if (_temp71 instanceof Completion) _temp71 = _temp71.Value;
      if (!_temp71.stringValue().includes('g')) {
        return surroundingAgent.Throw('TypeError', 'StringPrototypeMethodGlobalRegExp', 'replaceAll');
      }
    }
    // c. Let replacer be ? GetMethod(searchValue, @@replace).
    /* ReturnIfAbrupt */
    let _temp72 = yield* GetMethod(searchValue, wellKnownSymbols.replace);
    /* node:coverage ignore next */
    if (_temp72 instanceof AbruptCompletion) return _temp72;
    /* node:coverage ignore next */
    if (_temp72 instanceof Completion) _temp72 = _temp72.Value;
    const replacer = _temp72;
    // d. If replacer is not undefined, then
    if (replacer !== Value.undefined) {
      // i. Return ? Call(replacer, searchValue, « O, replaceValue »).
      return yield* Call(replacer, searchValue, [O, replaceValue]);
    }
  }
  // 3. Let string be ? ToString(O).
  /* ReturnIfAbrupt */
  let _temp73 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp73 instanceof AbruptCompletion) return _temp73;
  /* node:coverage ignore next */
  if (_temp73 instanceof Completion) _temp73 = _temp73.Value;
  const string = _temp73;
  // 4. Let searchString be ? ToString(searchValue).
  /* ReturnIfAbrupt */
  let _temp74 = yield* ToString(searchValue);
  /* node:coverage ignore next */
  if (_temp74 instanceof AbruptCompletion) return _temp74;
  /* node:coverage ignore next */
  if (_temp74 instanceof Completion) _temp74 = _temp74.Value;
  const searchString = _temp74;
  // 5. Let functionalReplace be IsCallable(replaceValue).
  const functionalReplace = IsCallable(replaceValue);
  // 6. If functionalReplace is false, then
  if (!functionalReplace) {
    /* ReturnIfAbrupt */
    let _temp75 = yield* ToString(replaceValue);
    /* node:coverage ignore next */
    if (_temp75 instanceof AbruptCompletion) return _temp75;
    /* node:coverage ignore next */
    if (_temp75 instanceof Completion) _temp75 = _temp75.Value;
    // a. Let replaceValue be ? ToString(replaceValue).
    replaceValue = _temp75;
  }
  // 7. Let searchLength be the length of searchString.
  const searchLength = searchString.stringValue().length;
  // 8. Let advanceBy be max(1, searchLength).
  const advanceBy = Math.max(1, searchLength);
  // 9. Let matchPositions be a new empty List.
  const matchPositions = [];
  // 10. Let position be ! StringIndexOf(string, searchString, 0).
  /* X */
  let _temp76 = StringIndexOf(string, searchString, 0);
  /* node:coverage ignore next */
  if (_temp76 && typeof _temp76 === 'object' && 'next' in _temp76) _temp76 = skipDebugger(_temp76);
  /* node:coverage ignore next */
  if (_temp76 instanceof AbruptCompletion) throw new Assert.Error("! StringIndexOf(string, searchString, 0) returned an abrupt completion", {
    cause: _temp76
  });
  /* node:coverage ignore next */
  if (_temp76 instanceof Completion) _temp76 = _temp76.Value;
  let position = R(_temp76);
  // 11. Repeat, while position is not -1
  while (position !== -1) {
    // a. Append position to the end of matchPositions.
    matchPositions.push(position);
    // b. Let position be ! StringIndexOf(string, searchString, position + advanceBy).
    /* X */
    let _temp77 = StringIndexOf(string, searchString, position + advanceBy);
    /* node:coverage ignore next */
    if (_temp77 && typeof _temp77 === 'object' && 'next' in _temp77) _temp77 = skipDebugger(_temp77);
    /* node:coverage ignore next */
    if (_temp77 instanceof AbruptCompletion) throw new Assert.Error("! StringIndexOf(string, searchString, position + advanceBy) returned an abrupt completion", {
      cause: _temp77
    });
    /* node:coverage ignore next */
    if (_temp77 instanceof Completion) _temp77 = _temp77.Value;
    position = R(_temp77);
  }
  // 12. Let endOfLastMatch be 0.
  let endOfLastMatch = 0;
  // 13. Let result be the empty string value.
  let result = '';
  // 14. For each position in matchPositions, do
  for (position of matchPositions) {
    let replacement;
    // a. If functionalReplace is true, then
    if (functionalReplace) {
      /* ReturnIfAbrupt */
      let _temp79 = yield* Call(replaceValue, Value.undefined, [searchString, F(position), string]);
      /* node:coverage ignore next */
      if (_temp79 instanceof AbruptCompletion) return _temp79;
      /* node:coverage ignore next */
      if (_temp79 instanceof Completion) _temp79 = _temp79.Value;
      /* ReturnIfAbrupt */
      let _temp78 = yield* ToString(_temp79);
      /* node:coverage ignore next */
      if (_temp78 instanceof AbruptCompletion) return _temp78;
      /* node:coverage ignore next */
      if (_temp78 instanceof Completion) _temp78 = _temp78.Value;
      // i. Let replacement be ? ToString(? Call(replaceValue, undefined, « searchString, 𝔽(position), string »).
      replacement = _temp78;
    } else {
      // b. Else,
      // i. Assert: Type(replaceValue) is String.
      Assert(replaceValue instanceof JSStringValue, "replaceValue instanceof JSStringValue");
      // ii. Let captures be a new empty List.
      const captures = [];
      // iii. Let replacement be GetSubstitution(searchString, string, position, captures, undefined, replaceValue).
      /* X */
      let _temp80 = GetSubstitution(searchString, string, position, captures, Value.undefined, replaceValue);
      /* node:coverage ignore next */
      if (_temp80 && typeof _temp80 === 'object' && 'next' in _temp80) _temp80 = skipDebugger(_temp80);
      /* node:coverage ignore next */
      if (_temp80 instanceof AbruptCompletion) throw new Assert.Error("! GetSubstitution(searchString, string, position, captures, Value.undefined, replaceValue) returned an abrupt completion", {
        cause: _temp80
      });
      /* node:coverage ignore next */
      if (_temp80 instanceof Completion) _temp80 = _temp80.Value;
      replacement = _temp80;
    }
    // c. Let stringSlice be the substring of string consisting of the code units from endOfLastMatch (inclusive) up through position (exclusive).
    const stringSlice = string.stringValue().slice(endOfLastMatch, position);
    // d. Let result be the string-concatenation of result, stringSlice, and replacement.
    result = result + stringSlice + replacement.stringValue();
    // e. Let endOfLastMatch be position + searchLength.
    endOfLastMatch = position + searchLength;
  }
  // 15. If endOfLastMatch < the length of string, then
  if (endOfLastMatch < string.stringValue().length) {
    // a. Let result be the string-concatenation of result and the substring of string consisting of the code units from endOfLastMatch (inclusive) up through the final code unit of string (inclusive).
    result += string.stringValue().slice(endOfLastMatch);
  }
  // 16. Return result.
  return Value(result);
}
StringProto_replaceAll.section = 'https://tc39.es/ecma262/#sec-string.prototype.replaceall';
/** https://tc39.es/ecma262/#sec-string.prototype.slice */
function* StringProto_search([regexp = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp81 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp81 && typeof _temp81 === 'object' && 'next' in _temp81) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp81 instanceof AbruptCompletion) return _temp81;
  /* node:coverage ignore next */
  if (_temp81 instanceof Completion) _temp81 = _temp81.Value;
  const O = _temp81;
  if (regexp instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp82 = yield* GetMethod(regexp, wellKnownSymbols.search);
    /* node:coverage ignore next */
    if (_temp82 instanceof AbruptCompletion) return _temp82;
    /* node:coverage ignore next */
    if (_temp82 instanceof Completion) _temp82 = _temp82.Value;
    const searcher = _temp82;
    if (searcher !== Value.undefined) {
      return yield* Call(searcher, regexp, [O]);
    }
  }
  /* ReturnIfAbrupt */
  let _temp83 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp83 instanceof AbruptCompletion) return _temp83;
  /* node:coverage ignore next */
  if (_temp83 instanceof Completion) _temp83 = _temp83.Value;
  const string = _temp83;
  /* ReturnIfAbrupt */
  let _temp84 = yield* RegExpCreate(regexp, Value.undefined);
  /* node:coverage ignore next */
  if (_temp84 instanceof AbruptCompletion) return _temp84;
  /* node:coverage ignore next */
  if (_temp84 instanceof Completion) _temp84 = _temp84.Value;
  const rx = _temp84;
  return yield* Invoke(rx, wellKnownSymbols.search, [string]);
}
StringProto_search.section = 'https://tc39.es/ecma262/#sec-string.prototype.slice';
/** https://tc39.es/ecma262/#sec-string.prototype.slice */
function* StringProto_slice([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp85 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp85 && typeof _temp85 === 'object' && 'next' in _temp85) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp85 instanceof AbruptCompletion) return _temp85;
  /* node:coverage ignore next */
  if (_temp85 instanceof Completion) _temp85 = _temp85.Value;
  const O = _temp85;
  /* ReturnIfAbrupt */
  let _temp86 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp86 instanceof AbruptCompletion) return _temp86;
  /* node:coverage ignore next */
  if (_temp86 instanceof Completion) _temp86 = _temp86.Value;
  const S = _temp86.stringValue();
  const len = S.length;
  /* ReturnIfAbrupt */
  let _temp87 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp87 instanceof AbruptCompletion) return _temp87;
  /* node:coverage ignore next */
  if (_temp87 instanceof Completion) _temp87 = _temp87.Value;
  const intStart = _temp87;
  let intEnd;
  if (end === Value.undefined) {
    intEnd = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp88 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp88 instanceof AbruptCompletion) return _temp88;
    /* node:coverage ignore next */
    if (_temp88 instanceof Completion) _temp88 = _temp88.Value;
    intEnd = _temp88;
  }
  let from;
  if (intStart < 0) {
    from = Math.max(len + intStart, 0);
  } else {
    from = Math.min(intStart, len);
  }
  let to;
  if (intEnd < 0) {
    to = Math.max(len + intEnd, 0);
  } else {
    to = Math.min(intEnd, len);
  }
  const span = Math.max(to - from, 0);
  return Value(S.slice(from, from + span));
}
StringProto_slice.section = 'https://tc39.es/ecma262/#sec-string.prototype.slice';
/** https://tc39.es/ecma262/#sec-string.prototype.split */
function* StringProto_split([separator = Value.undefined, limit = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp89 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp89 && typeof _temp89 === 'object' && 'next' in _temp89) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp89 instanceof AbruptCompletion) return _temp89;
  /* node:coverage ignore next */
  if (_temp89 instanceof Completion) _temp89 = _temp89.Value;
  const O = _temp89;
  if (separator instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp90 = yield* GetMethod(separator, wellKnownSymbols.split);
    /* node:coverage ignore next */
    if (_temp90 instanceof AbruptCompletion) return _temp90;
    /* node:coverage ignore next */
    if (_temp90 instanceof Completion) _temp90 = _temp90.Value;
    const splitter = _temp90;
    if (splitter !== Value.undefined) {
      return yield* Call(splitter, separator, [O, limit]);
    }
  }
  /* ReturnIfAbrupt */
  let _temp91 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp91 instanceof AbruptCompletion) return _temp91;
  /* node:coverage ignore next */
  if (_temp91 instanceof Completion) _temp91 = _temp91.Value;
  const S = _temp91;
  /* X */
  let _temp92 = ArrayCreate(0);
  /* node:coverage ignore next */
  if (_temp92 && typeof _temp92 === 'object' && 'next' in _temp92) _temp92 = skipDebugger(_temp92);
  /* node:coverage ignore next */
  if (_temp92 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(0) returned an abrupt completion", {
    cause: _temp92
  });
  /* node:coverage ignore next */
  if (_temp92 instanceof Completion) _temp92 = _temp92.Value;
  const A = _temp92;
  let lengthA = 0;
  let lim;
  if (limit === Value.undefined) {
    lim = F(2 ** 32 - 1);
  } else {
    /* ReturnIfAbrupt */
    let _temp93 = yield* ToUint32(limit);
    /* node:coverage ignore next */
    if (_temp93 instanceof AbruptCompletion) return _temp93;
    /* node:coverage ignore next */
    if (_temp93 instanceof Completion) _temp93 = _temp93.Value;
    lim = _temp93;
  }
  const s = S.stringValue().length;
  let p = 0;
  /* ReturnIfAbrupt */
  let _temp94 = yield* ToString(separator);
  /* node:coverage ignore next */
  if (_temp94 instanceof AbruptCompletion) return _temp94;
  /* node:coverage ignore next */
  if (_temp94 instanceof Completion) _temp94 = _temp94.Value;
  const R$1 = _temp94;
  if (R(lim) === 0) {
    return A;
  }
  if (separator === Value.undefined) {
    /* X */
    let _temp95 = CreateDataPropertyOrThrow(A, Value('0'), S);
    /* node:coverage ignore next */
    if (_temp95 && typeof _temp95 === 'object' && 'next' in _temp95) _temp95 = skipDebugger(_temp95);
    /* node:coverage ignore next */
    if (_temp95 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Value('0'), S) returned an abrupt completion", {
      cause: _temp95
    });
    /* node:coverage ignore next */
    if (_temp95 instanceof Completion) _temp95 = _temp95.Value;
    return A;
  }
  if (s === 0) {
    if (R$1.stringValue() !== '') {
      /* X */
      let _temp96 = CreateDataPropertyOrThrow(A, Value('0'), S);
      /* node:coverage ignore next */
      if (_temp96 && typeof _temp96 === 'object' && 'next' in _temp96) _temp96 = skipDebugger(_temp96);
      /* node:coverage ignore next */
      if (_temp96 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Value('0'), S) returned an abrupt completion", {
        cause: _temp96
      });
      /* node:coverage ignore next */
      if (_temp96 instanceof Completion) _temp96 = _temp96.Value;
    }
    return A;
  }
  let q = p;
  while (q !== s) {
    const e = yield* SplitMatch(S, q, R$1);
    if (e === false) {
      q += 1;
    } else {
      if (e === p) {
        q += 1;
      } else {
        const T = Value(S.stringValue().substring(p, q));
        /* X */
        let _temp98 = ToString(F(lengthA));
        /* node:coverage ignore next */
        if (_temp98 && typeof _temp98 === 'object' && 'next' in _temp98) _temp98 = skipDebugger(_temp98);
        /* node:coverage ignore next */
        if (_temp98 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(lengthA)) returned an abrupt completion", {
          cause: _temp98
        });
        /* node:coverage ignore next */
        if (_temp98 instanceof Completion) _temp98 = _temp98.Value;
        /* X */
        let _temp97 = CreateDataPropertyOrThrow(A, _temp98, T);
        /* node:coverage ignore next */
        if (_temp97 && typeof _temp97 === 'object' && 'next' in _temp97) _temp97 = skipDebugger(_temp97);
        /* node:coverage ignore next */
        if (_temp97 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(F(lengthA))), T) returned an abrupt completion", {
          cause: _temp97
        });
        /* node:coverage ignore next */
        if (_temp97 instanceof Completion) _temp97 = _temp97.Value;
        lengthA += 1;
        if (lengthA === R(lim)) {
          return A;
        }
        p = e;
        q = p;
      }
    }
  }
  const T = Value(S.stringValue().substring(p, s));
  /* X */
  let _temp100 = ToString(F(lengthA));
  /* node:coverage ignore next */
  if (_temp100 && typeof _temp100 === 'object' && 'next' in _temp100) _temp100 = skipDebugger(_temp100);
  /* node:coverage ignore next */
  if (_temp100 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(lengthA)) returned an abrupt completion", {
    cause: _temp100
  });
  /* node:coverage ignore next */
  if (_temp100 instanceof Completion) _temp100 = _temp100.Value;
  /* X */
  let _temp99 = CreateDataPropertyOrThrow(A, _temp100, T);
  /* node:coverage ignore next */
  if (_temp99 && typeof _temp99 === 'object' && 'next' in _temp99) _temp99 = skipDebugger(_temp99);
  /* node:coverage ignore next */
  if (_temp99 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(F(lengthA))), T) returned an abrupt completion", {
    cause: _temp99
  });
  /* node:coverage ignore next */
  if (_temp99 instanceof Completion) _temp99 = _temp99.Value;
  return A;
}
StringProto_split.section = 'https://tc39.es/ecma262/#sec-string.prototype.split';
/** https://tc39.es/ecma262/#sec-splitmatch */
function* SplitMatch(S, q, R) {
  Assert(R instanceof JSStringValue, "R instanceof JSStringValue");
  const r = R.stringValue().length;
  const s = S.stringValue().length;
  if (q + r > s) {
    return false;
  }
  for (let i = 0; i < r; i += 1) {
    if (S.stringValue().charCodeAt(q + i) !== R.stringValue().charCodeAt(i)) {
      return false;
    }
  }
  return q + r;
}
SplitMatch.section = 'https://tc39.es/ecma262/#sec-splitmatch';
/** https://tc39.es/ecma262/#sec-string.prototype.startswith */
function* StringProto_startsWith([searchString = Value.undefined, position = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp101 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp101 && typeof _temp101 === 'object' && 'next' in _temp101) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp101 instanceof AbruptCompletion) return _temp101;
  /* node:coverage ignore next */
  if (_temp101 instanceof Completion) _temp101 = _temp101.Value;
  const O = _temp101;
  /* ReturnIfAbrupt */
  let _temp102 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp102 instanceof AbruptCompletion) return _temp102;
  /* node:coverage ignore next */
  if (_temp102 instanceof Completion) _temp102 = _temp102.Value;
  const S = _temp102.stringValue();
  /* ReturnIfAbrupt */
  let _temp103 = yield* IsRegExp(searchString);
  /* node:coverage ignore next */
  if (_temp103 instanceof AbruptCompletion) return _temp103;
  /* node:coverage ignore next */
  if (_temp103 instanceof Completion) _temp103 = _temp103.Value;
  const isRegExp = _temp103;
  if (isRegExp === Value.true) {
    return surroundingAgent.Throw('TypeError', 'RegExpArgumentNotAllowed', 'String.prototype.startsWith');
  }
  /* ReturnIfAbrupt */
  let _temp104 = yield* ToString(searchString);
  /* node:coverage ignore next */
  if (_temp104 instanceof AbruptCompletion) return _temp104;
  /* node:coverage ignore next */
  if (_temp104 instanceof Completion) _temp104 = _temp104.Value;
  const searchStr = _temp104.stringValue();
  /* ReturnIfAbrupt */
  let _temp105 = yield* ToIntegerOrInfinity(position);
  /* node:coverage ignore next */
  if (_temp105 instanceof AbruptCompletion) return _temp105;
  /* node:coverage ignore next */
  if (_temp105 instanceof Completion) _temp105 = _temp105.Value;
  const pos = _temp105;
  Assert(!(position === Value.undefined) || pos === 0, "!(position === Value.undefined) || pos === 0");
  const len = S.length;
  const start = Math.min(Math.max(pos, 0), len);
  const searchLength = searchStr.length;
  if (searchLength + start > len) {
    return Value.false;
  }
  for (let i = 0; i < searchLength; i += 1) {
    if (S.charCodeAt(start + i) !== searchStr.charCodeAt(i)) {
      return Value.false;
    }
  }
  return Value.true;
}
StringProto_startsWith.section = 'https://tc39.es/ecma262/#sec-string.prototype.startswith';
/** https://tc39.es/ecma262/#sec-string.prototype.substring */
function* StringProto_substring([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp106 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp106 && typeof _temp106 === 'object' && 'next' in _temp106) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp106 instanceof AbruptCompletion) return _temp106;
  /* node:coverage ignore next */
  if (_temp106 instanceof Completion) _temp106 = _temp106.Value;
  const O = _temp106;
  /* ReturnIfAbrupt */
  let _temp107 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp107 instanceof AbruptCompletion) return _temp107;
  /* node:coverage ignore next */
  if (_temp107 instanceof Completion) _temp107 = _temp107.Value;
  const S = _temp107.stringValue();
  const len = S.length;
  /* ReturnIfAbrupt */
  let _temp108 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp108 instanceof AbruptCompletion) return _temp108;
  /* node:coverage ignore next */
  if (_temp108 instanceof Completion) _temp108 = _temp108.Value;
  const intStart = _temp108;
  let intEnd;
  if (end === Value.undefined) {
    intEnd = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp109 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp109 instanceof AbruptCompletion) return _temp109;
    /* node:coverage ignore next */
    if (_temp109 instanceof Completion) _temp109 = _temp109.Value;
    intEnd = _temp109;
  }
  const finalStart = Math.min(Math.max(intStart, 0), len);
  const finalEnd = Math.min(Math.max(intEnd, 0), len);
  const from = Math.min(finalStart, finalEnd);
  const to = Math.max(finalStart, finalEnd);
  return Value(S.slice(from, to));
}
StringProto_substring.section = 'https://tc39.es/ecma262/#sec-string.prototype.substring';
/** https://tc39.es/ecma262/#sec-string.prototype.tolocalelowercase */
function* StringProto_toLocaleLowerCase(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp110 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp110 && typeof _temp110 === 'object' && 'next' in _temp110) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp110 instanceof AbruptCompletion) return _temp110;
  /* node:coverage ignore next */
  if (_temp110 instanceof Completion) _temp110 = _temp110.Value;
  const O = _temp110;
  /* ReturnIfAbrupt */
  let _temp111 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp111 instanceof AbruptCompletion) return _temp111;
  /* node:coverage ignore next */
  if (_temp111 instanceof Completion) _temp111 = _temp111.Value;
  const S = _temp111;
  const L = S.stringValue().toLocaleLowerCase();
  return Value(L);
}
StringProto_toLocaleLowerCase.section = 'https://tc39.es/ecma262/#sec-string.prototype.tolocalelowercase';
/** https://tc39.es/ecma262/#sec-string.prototype.tolocaleuppercase */
function* StringProto_toLocaleUpperCase(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp112 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp112 && typeof _temp112 === 'object' && 'next' in _temp112) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp112 instanceof AbruptCompletion) return _temp112;
  /* node:coverage ignore next */
  if (_temp112 instanceof Completion) _temp112 = _temp112.Value;
  const O = _temp112;
  /* ReturnIfAbrupt */
  let _temp113 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp113 instanceof AbruptCompletion) return _temp113;
  /* node:coverage ignore next */
  if (_temp113 instanceof Completion) _temp113 = _temp113.Value;
  const S = _temp113;
  const L = S.stringValue().toLocaleUpperCase();
  return Value(L);
}
StringProto_toLocaleUpperCase.section = 'https://tc39.es/ecma262/#sec-string.prototype.tolocaleuppercase';
/** https://tc39.es/ecma262/#sec-string.prototype.tolowercase */
function* StringProto_toLowerCase(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp114 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp114 && typeof _temp114 === 'object' && 'next' in _temp114) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp114 instanceof AbruptCompletion) return _temp114;
  /* node:coverage ignore next */
  if (_temp114 instanceof Completion) _temp114 = _temp114.Value;
  const O = _temp114;
  /* ReturnIfAbrupt */
  let _temp115 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp115 instanceof AbruptCompletion) return _temp115;
  /* node:coverage ignore next */
  if (_temp115 instanceof Completion) _temp115 = _temp115.Value;
  const S = _temp115;
  const L = S.stringValue().toLowerCase();
  return Value(L);
}
StringProto_toLowerCase.section = 'https://tc39.es/ecma262/#sec-string.prototype.tolowercase';
/** https://tc39.es/ecma262/#sec-string.prototype.tostring */
function* StringProto_toString(_args, {
  thisValue
}) {
  return thisStringValue(thisValue);
}
StringProto_toString.section = 'https://tc39.es/ecma262/#sec-string.prototype.tostring';
/** https://tc39.es/ecma262/#sec-string.prototype.touppercase */
function* StringProto_toUpperCase(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp116 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp116 && typeof _temp116 === 'object' && 'next' in _temp116) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp116 instanceof AbruptCompletion) return _temp116;
  /* node:coverage ignore next */
  if (_temp116 instanceof Completion) _temp116 = _temp116.Value;
  const O = _temp116;
  /* ReturnIfAbrupt */
  let _temp117 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp117 instanceof AbruptCompletion) return _temp117;
  /* node:coverage ignore next */
  if (_temp117 instanceof Completion) _temp117 = _temp117.Value;
  const S = _temp117;
  const L = S.stringValue().toUpperCase();
  return Value(L);
}
StringProto_toUpperCase.section = 'https://tc39.es/ecma262/#sec-string.prototype.touppercase';
/** https://tc39.es/ecma262/#sec-string.prototype.towellformed */
function* StringProto_toWellFormed(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp118 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp118 && typeof _temp118 === 'object' && 'next' in _temp118) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp118 instanceof AbruptCompletion) return _temp118;
  /* node:coverage ignore next */
  if (_temp118 instanceof Completion) _temp118 = _temp118.Value;
  // 1. Let O be ? RequireObjectCoercible(this value).
  const O = _temp118;
  // 2. Let S be ? ToString(O).
  /* ReturnIfAbrupt */
  let _temp119 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp119 instanceof AbruptCompletion) return _temp119;
  /* node:coverage ignore next */
  if (_temp119 instanceof Completion) _temp119 = _temp119.Value;
  const S = _temp119;
  // 3. Let strLen be the length of S.
  const strLen = S.stringValue().length;
  // 4. Let k be 0.
  let k = 0;
  // 5. Let result be the empty String.
  let result = '';
  // 6. Repeat, while k < strLen,
  while (k < strLen) {
    // a. Let cp be CodePointAt(S, k).
    const cp = CodePointAt(S.stringValue(), k);
    // b. If cp.[[IsUnpairedSurrogate]] is true, then
    if (cp.IsUnpairedSurrogate) {
      // i. Set result to the string-concatenation of result and 0xFFFD (REPLACEMENT CHARACTER).
      result += '\uFFFD';
    } else {
      // c. Else,
      // i. Set result to the string-concatenation of result and UTF16EncodeCodePoint(cp.[[CodePoint]]).
      result += UTF16EncodeCodePoint(cp.CodePoint);
    }
    // d. Set k to k + cp.[[CodeUnitCount]].
    k += cp.CodeUnitCount;
  }
  // 7. Return result.
  return Value(result);
}
StringProto_toWellFormed.section = 'https://tc39.es/ecma262/#sec-string.prototype.towellformed';
/** https://tc39.es/ecma262/#sec-string.prototype.trim */
function* StringProto_trim(_args, {
  thisValue
}) {
  const S = thisValue;
  return yield* TrimString(S, 'start+end');
}
StringProto_trim.section = 'https://tc39.es/ecma262/#sec-string.prototype.trim';
/** https://tc39.es/ecma262/#sec-string.prototype.trimend */
function* StringProto_trimEnd(_args, {
  thisValue
}) {
  const S = thisValue;
  return yield* TrimString(S, 'end');
}
StringProto_trimEnd.section = 'https://tc39.es/ecma262/#sec-string.prototype.trimend';
/** https://tc39.es/ecma262/#sec-string.prototype.trimstart */
function* StringProto_trimStart(_args, {
  thisValue
}) {
  const S = thisValue;
  return yield* TrimString(S, 'start');
}
StringProto_trimStart.section = 'https://tc39.es/ecma262/#sec-string.prototype.trimstart';
/** https://tc39.es/ecma262/#sec-string.prototype.valueof */
function* StringProto_valueOf(_args, {
  thisValue
}) {
  return thisStringValue(thisValue);
}
StringProto_valueOf.section = 'https://tc39.es/ecma262/#sec-string.prototype.valueof';
/** https://tc39.es/ecma262/#sec-string.prototype-@@iterator */
function* StringProto_iterator(_args, {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp120 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp120 && typeof _temp120 === 'object' && 'next' in _temp120) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp120 instanceof AbruptCompletion) return _temp120;
  /* node:coverage ignore next */
  if (_temp120 instanceof Completion) _temp120 = _temp120.Value;
  // 1. Let O be ? RequireObjectCoercible(this value).
  const O = _temp120;
  // 2. Let s be ? ToString(O).
  /* ReturnIfAbrupt */
  let _temp121 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp121 instanceof AbruptCompletion) return _temp121;
  /* node:coverage ignore next */
  if (_temp121 instanceof Completion) _temp121 = _temp121.Value;
  const s = _temp121.stringValue();
  // 3. Let closure be a new Abstract Closure with no parameters that captures s and performs the following steps when called:
  const closure = function* closure() {
    // a. Let position be 0.
    let position = 0;
    // b. Let len be the length of s.
    const len = s.length;
    // c. Repeat, while position < len,
    while (position < len) {
      /* X */
      let _temp122 = CodePointAt(s, position);
      /* node:coverage ignore next */
      if (_temp122 && typeof _temp122 === 'object' && 'next' in _temp122) _temp122 = skipDebugger(_temp122);
      /* node:coverage ignore next */
      if (_temp122 instanceof AbruptCompletion) throw new Assert.Error("! CodePointAt(s, position) returned an abrupt completion", {
        cause: _temp122
      });
      /* node:coverage ignore next */
      if (_temp122 instanceof Completion) _temp122 = _temp122.Value;
      // i. Let cp be ! CodePointAt(s, position).
      const cp = _temp122;
      // ii. Let nextIndex be position + cp.[[CodeUnitCount]].
      const nextIndex = position + cp.CodeUnitCount;
      // iii. Let resultString be the substring of s from position to nextIndex.
      const resultString = Value(s.slice(position, nextIndex));
      // iv. Set position to nextIndex.
      position = nextIndex;
      // v. Perform ? Yield(resultString).
      /* ReturnIfAbrupt */
      let _temp123 = yield* Yield(resultString);
      /* node:coverage ignore next */
      if (_temp123 instanceof AbruptCompletion) return _temp123;
      /* node:coverage ignore next */
      if (_temp123 instanceof Completion) _temp123 = _temp123.Value;
    }
    // NON-SPEC
    generator.HostCapturedValues = undefined;
    // d. Return undefined.
    return Value.undefined;
  };
  // 4. Return ! CreateIteratorFromClosure(closure, "%StringIteratorPrototype%", %StringIteratorPrototype%).
  /* X */
  let _temp124 = CreateIteratorFromClosure(closure, Value('%StringIteratorPrototype%'), surroundingAgent.intrinsic('%StringIteratorPrototype%'), ['HostCapturedValues'], [O]);
  /* node:coverage ignore next */
  if (_temp124 && typeof _temp124 === 'object' && 'next' in _temp124) _temp124 = skipDebugger(_temp124);
  /* node:coverage ignore next */
  if (_temp124 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorFromClosure(closure, Value('%StringIteratorPrototype%'), surroundingAgent.intrinsic('%StringIteratorPrototype%'), ['HostCapturedValues'], [O]) returned an abrupt completion", {
    cause: _temp124
  });
  /* node:coverage ignore next */
  if (_temp124 instanceof Completion) _temp124 = _temp124.Value;
  const generator = _temp124;
  return generator;
}
StringProto_iterator.section = 'https://tc39.es/ecma262/#sec-string.prototype-@@iterator';
/** https://tc39.es/ecma262/#sec-string.prototype.at */
function* StringProto_at([index = Value.undefined], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp125 = RequireObjectCoercible(thisValue);
  /* node:coverage ignore next */
  if (_temp125 && typeof _temp125 === 'object' && 'next' in _temp125) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp125 instanceof AbruptCompletion) return _temp125;
  /* node:coverage ignore next */
  if (_temp125 instanceof Completion) _temp125 = _temp125.Value;
  // 1. Let O be ? RequireObjectCoercible(this value).
  const O = _temp125;
  // 2. Let S be ? ToString(O).
  /* ReturnIfAbrupt */
  let _temp126 = yield* ToString(O);
  /* node:coverage ignore next */
  if (_temp126 instanceof AbruptCompletion) return _temp126;
  /* node:coverage ignore next */
  if (_temp126 instanceof Completion) _temp126 = _temp126.Value;
  const S = _temp126;
  // 3. Let len be the length of S.
  const len = S.stringValue().length;
  // 4. Let relativeIndex be ? ToIntegerOrInfinity(index).
  /* ReturnIfAbrupt */
  let _temp127 = yield* ToIntegerOrInfinity(index);
  /* node:coverage ignore next */
  if (_temp127 instanceof AbruptCompletion) return _temp127;
  /* node:coverage ignore next */
  if (_temp127 instanceof Completion) _temp127 = _temp127.Value;
  const relativeIndex = _temp127;
  let k;
  // 5. If relativeIndex ≥ 0, then
  if (relativeIndex >= 0) {
    // a. Let k be relativeIndex.
    k = relativeIndex;
  } else {
    // 6. Else,
    // a. Let k be len + relativeIndex.
    k = len + relativeIndex;
  }
  // 7. If k < 0 or k ≥ len, then return undefined.
  if (k < 0 || k >= len) {
    return Value.undefined;
  }
  // 8. Return the String value consisting of only the code unit at position k in S.
  return Value(S.stringValue()[k]);
}
StringProto_at.section = 'https://tc39.es/ecma262/#sec-string.prototype.at';
function bootstrapStringPrototype(realmRec) {
  const proto = StringCreate(Value(''), realmRec.Intrinsics['%Object.prototype%']);
  assignProps(realmRec, proto, [['charAt', StringProto_charAt, 1], ['charCodeAt', StringProto_charCodeAt, 1], ['codePointAt', StringProto_codePointAt, 1], ['concat', StringProto_concat, 1], ['endsWith', StringProto_endsWith, 1], ['includes', StringProto_includes, 1], ['indexOf', StringProto_indexOf, 1], ['isWellFormed', StringProto_isWellFormed, 0], ['at', StringProto_at, 1], ['lastIndexOf', StringProto_lastIndexOf, 1], ['localeCompare', StringProto_localeCompare, 1], ['match', StringProto_match, 1], ['matchAll', StringProto_matchAll, 1], ['normalize', StringProto_normalize, 0], ['padEnd', StringProto_padEnd, 1], ['padStart', StringProto_padStart, 1], ['repeat', StringProto_repeat, 1], ['replace', StringProto_replace, 2], ['replaceAll', StringProto_replaceAll, 2], ['search', StringProto_search, 1], ['slice', StringProto_slice, 2], ['split', StringProto_split, 2], ['startsWith', StringProto_startsWith, 1], ['substring', StringProto_substring, 2], ['toLocaleLowerCase', StringProto_toLocaleLowerCase, 0], ['toLocaleUpperCase', StringProto_toLocaleUpperCase, 0], ['toLowerCase', StringProto_toLowerCase, 0], ['toString', StringProto_toString, 0], ['toUpperCase', StringProto_toUpperCase, 0], ['toWellFormed', StringProto_toWellFormed, 0], ['trim', StringProto_trim, 0], ['trimEnd', StringProto_trimEnd, 0], ['trimStart', StringProto_trimStart, 0], ['valueOf', StringProto_valueOf, 0], [wellKnownSymbols.iterator, StringProto_iterator, 0]]);
  realmRec.Intrinsics['%String.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-string-constructor-string-value */
function* StringConstructor([value], {
  NewTarget
}) {
  let s;
  if (value === undefined) {
    s = Value('');
  } else {
    if (NewTarget === Value.undefined && value instanceof SymbolValue) {
      /* X */
      let _temp = SymbolDescriptiveString(value);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! SymbolDescriptiveString(value) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      return _temp;
    }
    /* ReturnIfAbrupt */
    let _temp2 = yield* ToString(value);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    s = _temp2;
  }
  if (NewTarget instanceof UndefinedValue) {
    return s;
  }
  /* ReturnIfAbrupt */
  let _temp4 = yield* GetPrototypeFromConstructor(NewTarget, '%String.prototype%');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  /* X */
  let _temp3 = StringCreate(s, _temp4);
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! StringCreate(s, Q(yield* GetPrototypeFromConstructor(NewTarget, '%String.prototype%'))) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  return _temp3;
}
StringConstructor.section = 'https://tc39.es/ecma262/#sec-string-constructor-string-value';
/** https://tc39.es/ecma262/#sec-string.fromcharcode */
function* String_fromCharCode(codeUnits) {
  const length = codeUnits.length;
  const elements = [];
  let nextIndex = 0;
  while (nextIndex < length) {
    const next = codeUnits[nextIndex];
    /* ReturnIfAbrupt */
    let _temp5 = yield* ToUint16(next);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    const nextCU = _temp5;
    elements.push(nextCU);
    nextIndex += 1;
  }
  const result = elements.reduce((previous, current) => previous + String.fromCharCode(R(current)), '');
  return Value(result);
}
String_fromCharCode.section = 'https://tc39.es/ecma262/#sec-string.fromcharcode';
/** https://tc39.es/ecma262/#sec-string.fromcodepoint */
function* String_fromCodePoint(codePoints) {
  // 1. Let result be the empty String.
  let result = '';
  // 2. For each element next of codePoints, do
  for (const next of codePoints) {
    /* ReturnIfAbrupt */
    let _temp6 = yield* ToNumber(next);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    // a. Let nextCP be ? ToNumber(next).
    const nextCP = _temp6;
    // b. If IsIntegralNumber(nextCP) is false, throw a RangeError exception.
    /* X */
    let _temp7 = IsIntegralNumber(nextCP);
    /* node:coverage ignore next */
    if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! IsIntegralNumber(nextCP) returned an abrupt completion", {
      cause: _temp7
    });
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    if (_temp7 === Value.false) {
      return surroundingAgent.Throw('RangeError', 'StringCodePointInvalid', next);
    }
    // c. If ℝ(nextCP) < 0 or ℝ(nextCP) > 0x10FFFF, throw a RangeError exception.
    if (R(nextCP) < 0 || R(nextCP) > 0x10FFFF) {
      return surroundingAgent.Throw('RangeError', 'StringCodePointInvalid', nextCP);
    }
    // d. Set result to the string-concatenation of result and UTF16EncodeCodePoint(ℝ(nextCP)).
    result += UTF16EncodeCodePoint(R(nextCP));
  }
  // 3. Assert: If codePoints is empty, then result is the empty String.
  Assert(!(codePoints.length === 0) || result.length === 0, "!(codePoints.length === 0) || result.length === 0");
  // 4. Return result.
  return Value(result);
}
String_fromCodePoint.section = 'https://tc39.es/ecma262/#sec-string.fromcodepoint';
/** https://tc39.es/ecma262/#sec-string.raw */
function* String_raw([template = Value.undefined, ...substitutions]) {
  const numberOfSubstitutions = substitutions.length;
  /* ReturnIfAbrupt */
  let _temp8 = ToObject(template);
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  const cooked = _temp8;
  /* ReturnIfAbrupt */
  let _temp15 = yield* Get(cooked, Value('raw'));
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  /* ReturnIfAbrupt */
  let _temp9 = ToObject(_temp15);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const raw = _temp9;
  /* ReturnIfAbrupt */
  let _temp10 = yield* LengthOfArrayLike(raw);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const literalSegments = _temp10;
  if (literalSegments <= 0) {
    return Value('');
  }
  // Not sure why the spec uses a List, but this is really just a String.
  const stringElements = [];
  let nextIndex = 0;
  while (true) {
    /* X */
    let _temp11 = ToString(F(nextIndex));
    /* node:coverage ignore next */
    if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(nextIndex)) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    const nextKey = _temp11;
    /* ReturnIfAbrupt */
    let _temp14 = yield* Get(raw, nextKey);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) return _temp14;
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    /* ReturnIfAbrupt */
    let _temp12 = yield* ToString(_temp14);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) return _temp12;
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    const nextSeg = _temp12;
    stringElements.push(nextSeg.stringValue());
    if (nextIndex + 1 === literalSegments) {
      return Value(stringElements.join(''));
    }
    let next;
    if (nextIndex < numberOfSubstitutions) {
      next = substitutions[nextIndex];
    } else {
      next = Value('');
    }
    /* ReturnIfAbrupt */
    let _temp13 = yield* ToString(next);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) return _temp13;
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    const nextSub = _temp13;
    stringElements.push(nextSub.stringValue());
    nextIndex += 1;
  }
}
String_raw.section = 'https://tc39.es/ecma262/#sec-string.raw';
function bootstrapString(realmRec) {
  const stringConstructor = bootstrapConstructor(realmRec, StringConstructor, 'String', 1, realmRec.Intrinsics['%String.prototype%'], [['fromCharCode', String_fromCharCode, 1], ['fromCodePoint', String_fromCodePoint, 1], ['raw', String_raw, 1]]);
  realmRec.Intrinsics['%String%'] = stringConstructor;
}

/** https://tc39.es/ecma262/#sec-error-constructor */
function* ErrorConstructor([message = Value.undefined, options = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, let newTarget be the active function object; else let newTarget be NewTarget.
  let newTarget;
  if (NewTarget === Value.undefined) {
    newTarget = surroundingAgent.activeFunctionObject;
  } else {
    newTarget = NewTarget;
  }
  // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%Error.prototype%", « [[ErrorData]] »).
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(newTarget, '%Error.prototype%', ['ErrorData', 'HostDefinedErrorStack']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const O = _temp;
  // 3. If message is not undefined, then
  if (message !== Value.undefined) {
    /* ReturnIfAbrupt */
    let _temp2 = yield* ToString(message);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // a. Let msg be ? ToString(message).
    const msg = _temp2;
    // b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
    const msgDesc = _Descriptor({
      Value: msg,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    });
    // c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
    /* X */
    let _temp3 = DefinePropertyOrThrow(O, Value('message'), msgDesc);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(O, Value('message'), msgDesc) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }

  // 4. Perform ? InstallErrorCause(O, options).
  /* ReturnIfAbrupt */
  let _temp4 = yield* InstallErrorCause(O, options);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;

  // NON-SPEC
  const S = captureStack();
  O.HostDefinedErrorStack = S.stack;
  /* X */
  let _temp5 = errorStackToString(O, S.stack, S.nativeStack);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! errorStackToString(O, S.stack, S.nativeStack) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  O.ErrorData = _temp5;

  // 5. Return O.
  return O;
}
ErrorConstructor.section = 'https://tc39.es/ecma262/#sec-error-constructor';
/** https://tc39.es/proposal-is-error/#sec-error.iserror */
function Error_isError([value]) {
  return Value(IsError(value));
}
Error_isError.section = 'https://tc39.es/proposal-is-error/#sec-error.iserror';
function bootstrapError(realmRec) {
  const error = bootstrapConstructor(realmRec, ErrorConstructor, 'Error', 1, realmRec.Intrinsics['%Error.prototype%'], [['isError', Error_isError, 1]]);
  realmRec.Intrinsics['%Error%'] = error;
}

/** https://tc39.es/ecma262/#sec-error.prototype.tostring */
function* ErrorProto_toString(_args, {
  thisValue
}) {
  // 1. Let O be this value.
  const O = thisValue;
  // 2. If Type(O) is not Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let name be ? Get(O, "name").
  /* ReturnIfAbrupt */
  let _temp = yield* Get(O, Value('name'));
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  let name = _temp;
  // 4. If name is undefined, set name to "Error"; otherwise set name to ? ToString(name).
  if (name === Value.undefined) {
    name = Value('Error');
  } else {
    /* ReturnIfAbrupt */
    let _temp2 = yield* ToString(name);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    name = _temp2;
  }
  // 5. Let msg be ? Get(O, "message").
  /* ReturnIfAbrupt */
  let _temp3 = yield* Get(O, Value('message'));
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  let msg = _temp3;
  // 6. If msg is undefined, set msg to the empty String; otherwise set msg to ? ToString(msg).
  if (msg === Value.undefined) {
    msg = Value('');
  } else {
    /* ReturnIfAbrupt */
    let _temp4 = yield* ToString(msg);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    msg = _temp4;
  }
  // 7. If name is the empty String, return msg.
  if (name.stringValue() === '') {
    return msg;
  }
  // 8. If msg is the empty String, return name.
  if (msg.stringValue() === '') {
    return name;
  }
  // 9. Return the string-concatenation of name, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and msg.
  return Value(`${name.stringValue()}: ${msg.stringValue()}`);
}
ErrorProto_toString.section = 'https://tc39.es/ecma262/#sec-error.prototype.tostring';
/** https://tc39.es/proposal-error-stack-accessor/#sec-get-error.prototype.stack */
function* ErrorProto_getStack(_args, {
  thisValue
}) {
  // 1. Let E be the this value.
  const E = thisValue;
  // 2. If E is not an Object, throw a TypeError exception.
  if (!(E instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', E);
  }
  // 3. If E does not have an [[ErrorData]] internal slot, return undefined.
  if (!IsError(E)) {
    return Value.undefined;
  }
  // 4. Return an implementation-defined string that represents the stack trace of E.
  Assert(E.ErrorData instanceof JSStringValue, "E.ErrorData instanceof JSStringValue");
  return E.ErrorData;
}
ErrorProto_getStack.section = 'https://tc39.es/proposal-error-stack-accessor/#sec-get-error.prototype.stack';
/** https://tc39.es/proposal-error-stack-accessor/#sec-set-error.prototype.stack */
function* ErrorProto_setStack(args, {
  thisValue
}) {
  const [v = Value.undefined] = args;

  // 1. Let E be the this value.
  const E = thisValue;
  // 2. If E is not an Object, throw a TypeError exception.
  if (!(E instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', E);
  }
  // 3. Let numberOfArgs be the number of arguments passed to this function call.
  const numberOfArgs = args.length;
  // 4. If numberOfArgs is 0, throw a TypeError exception.
  if (numberOfArgs === 0) {
    return surroundingAgent.Throw('TypeError', 'NotEnoughArguments', numberOfArgs, 1);
  }
  // 5. If E does not have an [[ErrorData]] internal slot, return undefined.
  if (!IsError(E)) {
    return Value.undefined;
  }
  // 6. Perform ? SetterThatIgnoresPrototypeProperties(this value, %Error.prototype%, "stack", v).
  /* ReturnIfAbrupt */
  let _temp5 = yield* SetterThatIgnoresPrototypeProperties(thisValue, surroundingAgent.intrinsic('%Error.prototype%'), Value('stack'), v);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 7. Return undefined.
  return Value.undefined;
}
ErrorProto_setStack.section = 'https://tc39.es/proposal-error-stack-accessor/#sec-set-error.prototype.stack';
function bootstrapErrorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['toString', ErrorProto_toString, 0], ['message', Value('')], ['name', Value('Error')], ['stack', [ErrorProto_getStack, ErrorProto_setStack]]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Error.prototype%'] = proto;
  /* X */
  let _temp6 = Get(proto, Value('toString'));
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! Get(proto, Value('toString')) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  realmRec.Intrinsics['%Error.prototype.toString%'] = _temp6;
}

const nativeErrorNames = ['EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'];
function bootstrapNativeError(realmRec) {
  for (const name of nativeErrorNames) {
    const proto = bootstrapPrototype(realmRec, [['name', Value(name)], ['message', Value('')]], realmRec.Intrinsics['%Error.prototype%']);

    /** https://tc39.es/ecma262/#sec-nativeerror */
    const Constructor = function* Constructor([message = Value.undefined, options = Value.undefined], {
      NewTarget
    }) {
      // 1. If NewTarget is undefined, let newTarget be the active function object; else let newTarget be NewTarget.
      let newTarget;
      if (NewTarget instanceof UndefinedValue) {
        newTarget = surroundingAgent.activeFunctionObject;
      } else {
        newTarget = NewTarget;
      }
      // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%NativeError.prototype%", « [[ErrorData]] »).
      /* ReturnIfAbrupt */
      let _temp = yield* OrdinaryCreateFromConstructor(newTarget, `%${name}.prototype%`, ['ErrorData', 'HostDefinedErrorStack']);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) return _temp;
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      const O = _temp;
      // 3. If message is not undefined, then
      if (message !== Value.undefined) {
        /* ReturnIfAbrupt */
        let _temp2 = yield* ToString(message);
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        // a. Let msg be ? ToString(message).
        const msg = _temp2;
        // b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
        const msgDesc = _Descriptor({
          Value: msg,
          Writable: Value.true,
          Enumerable: Value.false,
          Configurable: Value.true
        });
        // c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
        /* X */
        let _temp3 = DefinePropertyOrThrow(O, Value('message'), msgDesc);
        /* node:coverage ignore next */
        if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(O, Value('message'), msgDesc) returned an abrupt completion", {
          cause: _temp3
        });
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      }
      // 4. Perform ? InstallErrorCause(O, options).
      /* ReturnIfAbrupt */
      let _temp4 = yield* InstallErrorCause(O, options);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      // NON-SPEC
      const S = captureStack();
      O.HostDefinedErrorStack = S.stack;
      /* X */
      let _temp5 = errorStackToString(O, S.stack, S.nativeStack);
      /* node:coverage ignore next */
      if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! errorStackToString(O, S.stack, S.nativeStack) returned an abrupt completion", {
        cause: _temp5
      });
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      O.ErrorData = _temp5;
      // 5. Return O.
      return O;
    };
    Constructor.section = 'https://tc39.es/ecma262/#sec-nativeerror';
    Object.defineProperty(Constructor, 'name', {
      value: `${name}Constructor`,
      configurable: true
    });
    const cons = bootstrapConstructor(realmRec, Constructor, name, 1, proto, []);
    cons.Prototype = realmRec.Intrinsics['%Error%'];
    realmRec.Intrinsics[`%${name}.prototype%`] = proto;
    realmRec.Intrinsics[`%${name}%`] = cons;
  }
}

/** https://tc39.es/ecma262/#sec-%iteratorhelperprototype%.next */
function* IteratorHelperPrototype_next(_args, {
  thisValue
}) {
  // 1. Return ? GeneratorResume(this value, undefined, "Iterator Helper").
  return yield* GeneratorResume(thisValue, Value.undefined, Value('Iterator Helper'));
}
IteratorHelperPrototype_next.section = 'https://tc39.es/ecma262/#sec-%iteratorhelperprototype%.next';
/** https://tc39.es/ecma262/#sec-%iteratorhelperprototype%.return */
function* IteratorHelperPrototype_return(_args, {
  thisValue
}) {
  // 1. Let O be this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[UnderlyingIterator]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(O, 'UnderlyingIterator');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Assert: O has a [[GeneratorState]] internal slot.
  Assert('GeneratorState' in O, "'GeneratorState' in O");

  // 4. If O.[[GeneratorState]] is suspended-start, then
  if (O.GeneratorState === 'suspendedStart') {
    // a. Set O.[[GeneratorState]] to completed.
    O.GeneratorState = 'completed';

    // b. NOTE: Once a generator enters the completed state it never leaves it and its associated execution context is never resumed.
    // Any execution state associated with O can be discarded at this point.
    // c. Perform ? IteratorClose(O.[[UnderlyingIterator]], NormalCompletion(unused)).
    /* ReturnIfAbrupt */
    let _temp2 = yield* IteratorClose(O.UnderlyingIterator, NormalCompletion(undefined));
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;

    // d. Return CreateIteratorResultObject(undefined, true).
    return CreateIteratorResultObject(Value.undefined, Value.true);
  }

  // 5. Let C be ReturnCompletion(undefined).
  const C = ReturnCompletion(Value.undefined);
  // 6. Return ? GeneratorResumeAbrupt(O, C, "Iterator Helper").
  return yield* GeneratorResumeAbrupt(O, C, Value('Iterator Helper'));
}
IteratorHelperPrototype_return.section = 'https://tc39.es/ecma262/#sec-%iteratorhelperprototype%.return';
function bootstrapIteratorHelperPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', IteratorHelperPrototype_next, 0], ['return', IteratorHelperPrototype_return, 0]], realmRec.Intrinsics['%Iterator.prototype%'], 'Iterator Helper');
  realmRec.Intrinsics['%IteratorHelperPrototype%'] = proto;
}

/** https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-get-iterator.prototype.constructor */
function IteratorProto_constructorGetter() {
  // 1. Return %Iterator%.
  return surroundingAgent.intrinsic('%Iterator%');
}
IteratorProto_constructorGetter.section = 'https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-get-iterator.prototype.constructor';
/** https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-set-iterator.prototype.constructor */
function* IteratorProto_constructorSetter([v], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp = yield* SetterThatIgnoresPrototypeProperties(thisValue, surroundingAgent.intrinsic('%Iterator.prototype%'), Value('constructor'), v);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 2. Return undefined.
  return Value.undefined;
}
IteratorProto_constructorSetter.section = 'https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-set-iterator.prototype.constructor';
/** https://tc39.es/ecma262/#sec-iterator.prototype.drop */
function* IteratorPrototype_drop([limit = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. Let numLimit be Completion(ToNumber(limit)).
  let numLimit = EnsureCompletion(yield* ToNumber(limit));
  // 5. IfAbruptCloseIterator(numLimit, iterated).
  /* IfAbruptCloseIterator */
  /* node:coverage ignore next */
  if (numLimit instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, numLimit));
  /* node:coverage ignore next */
  if (numLimit instanceof Completion) numLimit = numLimit.Value;
  // 6. If numLimit is NaN, then
  if (numLimit.isNaN()) {
    // a. Let error be ThrowCompletion(a newly created RangeError object).
    const error = surroundingAgent.Throw('RangeError', 'OutOfRange', numLimit);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 7. Let integerLimit be ! ToIntegerOrInfinity(numLimit).
  /* X */
  let _temp2 = yield* ToIntegerOrInfinity(numLimit instanceof NormalCompletion ? numLimit.Value : numLimit);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! yield* ToIntegerOrInfinity(numLimit instanceof NormalCompletion ? numLimit.Value : numLimit) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const integerLimit = _temp2;
  // 8. If integerLimit < 0, then
  if (integerLimit < 0) {
    // a. Let error be ThrowCompletion(a newly created RangeError object).
    const error = surroundingAgent.Throw('RangeError', 'OutOfRange', numLimit);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 9. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp3 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  iterated = _temp3;
  // 10. Let closure be a new Abstract Closure with no parameters that captures iterated and integerLimit and performs the following steps when called:
  const closure = function* closure() {
    // a. Let remaining be integerLimit.
    let remaining = integerLimit;
    // b. Repeat, while remaining > 0,
    while (remaining > 0) {
      // i. If remaining ≠ +∞, then
      if (remaining !== +Infinity) {
        // 1. Set remaining to remaining - 1.
        remaining -= 1;
      }
      // ii. Let next be ? IteratorStep(iterated).
      /* ReturnIfAbrupt */
      let _temp4 = yield* IteratorStep(iterated);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      const next = _temp4;
      // iii. If next is done, return ReturnCompletion(undefined).
      if (next === 'done') {
        return ReturnCompletion(Value.undefined);
      }
    }
    // c. Repeat,
    while (true) {
      /* ReturnIfAbrupt */
      let _temp5 = yield* IteratorStepValue(iterated);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) return _temp5;
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      // i. Let value be ? IteratorStepValue(iterated).
      const value = _temp5;
      // ii. If value is done, return ReturnCompletion(undefined).
      if (value === 'done') {
        return ReturnCompletion(Value.undefined);
      }
      // iii. Let completion be Completion(Yield(value)).
      let completion = EnsureCompletion(yield* Yield(value));
      // iv. IfAbruptCloseIterator(completion, iterated).
      /* IfAbruptCloseIterator */
      /* node:coverage ignore next */
      if (completion instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, completion));
      /* node:coverage ignore next */
      if (completion instanceof Completion) completion = completion.Value;
    }
  };
  // 11. Let result be CreateIteratorFromClosure(closure, "Iterator Helper", %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
  const result = CreateIteratorFromClosure(closure, Value('Iterator Helper'), surroundingAgent.currentRealmRecord.Intrinsics['%IteratorHelperPrototype%'], ['UnderlyingIterator']);
  // 12. Set result.[[UnderlyingIterator]] to iterated.
  result.UnderlyingIterator = iterated;
  // 13. Return result.
  return result;
}
IteratorPrototype_drop.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.drop';
/** https://tc39.es/ecma262/#sec-iterator.prototype.every */
function* IteratorPrototype_every([predicate = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. If IsCallable(predicate) is false, then
  if (IsCallable(predicate) === false) {
    // a. Let error be ThrowCompletion(a newly created TypeError object).
    const error = surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 5. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp6 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  iterated = _temp6;
  // 6. Let counter be 0.
  let counter = 0;
  // 7. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp7 = yield* IteratorStepValue(iterated);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    // a. Let value be ? IteratorStepValue(iterated).
    const value = _temp7;
    // b. If value is done, return true.
    if (value === 'done') {
      return Value.true;
    }
    // c. Let result be Completion(Call(predicate, undefined, « value, 𝔽(counter) »)).
    let result = yield* Call(predicate, Value.undefined, [value, Value(counter)]);
    // d. IfAbruptCloseIterator(result, iterated).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (result instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, result));
    /* node:coverage ignore next */
    if (result instanceof Completion) result = result.Value;
    // e. If ToBoolean(result) is false, return ? IteratorClose(iterated, NormalCompletion(false)).
    if (ToBoolean(result) === Value.false) {
      return yield* IteratorClose(iterated, EnsureCompletion(Value.false));
    }
    // f. Set counter to counter + 1.
    counter += 1;
  }
}
IteratorPrototype_every.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.every';
/** https://tc39.es/ecma262/#sec-iterator.prototype.filter */
function* IteratorPrototype_filter([predicate = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. If IsCallable(predicate) is false, then
  if (IsCallable(predicate) === false) {
    // a. Let error be ThrowCompletion(a newly created TypeError object).
    const error = surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 5. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp8 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  iterated = _temp8;
  // 6. Let closure be a new Abstract Closure with no parameters that captures iterated and predicate and performs the following steps when called:
  const closure = function* closure() {
    // a. Let counter be 0.
    let counter = 0;
    // b. Repeat,
    while (true) {
      /* ReturnIfAbrupt */
      let _temp9 = yield* IteratorStepValue(iterated);
      /* node:coverage ignore next */
      if (_temp9 instanceof AbruptCompletion) return _temp9;
      /* node:coverage ignore next */
      if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
      // i. Let value be ? IteratorStepValue(iterated).
      const value = _temp9;
      // ii. If value is done, return ReturnCompletion(undefined).
      if (value === 'done') {
        return ReturnCompletion(Value.undefined);
      }
      // iii. Let selected be Completion(Call(predicate, undefined, « value, 𝔽(counter) »)).
      let selected = yield* Call(predicate, Value.undefined, [value, Value(counter)]);
      // iv. IfAbruptCloseIterator(selected, iterated).
      /* IfAbruptCloseIterator */
      /* node:coverage ignore next */
      if (selected instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, selected));
      /* node:coverage ignore next */
      if (selected instanceof Completion) selected = selected.Value;
      if (ToBoolean(selected) === Value.true) {
        // 1. Let completion be Completion(Yield(value)).
        let completion = EnsureCompletion(yield* Yield(value));
        // 2. IfAbruptCloseIterator(completion, iterated).
        /* IfAbruptCloseIterator */
        /* node:coverage ignore next */
        if (completion instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, completion));
        /* node:coverage ignore next */
        if (completion instanceof Completion) completion = completion.Value;
      }
      // vi. Set counter to counter + 1.
      counter += 1;
    }
  };
  // 7. Let result be CreateIteratorFromClosure(closure, "Iterator Helper", %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
  const result = CreateIteratorFromClosure(closure, Value('Iterator Helper'), surroundingAgent.currentRealmRecord.Intrinsics['%IteratorHelperPrototype%'], ['UnderlyingIterator']);
  // 8. Set result.[[UnderlyingIterator]] to iterated.
  result.UnderlyingIterator = iterated;
  // 9. Return result.
  return result;
}
IteratorPrototype_filter.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.filter';
/** https://tc39.es/ecma262/#sec-iterator.prototype.find */
function* IteratorPrototype_find([predicate = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. If IsCallable(predicate) is false, then
  if (IsCallable(predicate) === false) {
    // a. Let error be ThrowCompletion(a newly created TypeError object).
    const error = surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 5. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp10 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  iterated = _temp10;
  // 6. Let counter be 0.
  let counter = 0;
  // 7. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp11 = yield* IteratorStepValue(iterated);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) return _temp11;
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    // a. Let value be ? IteratorStepValue(iterated).
    const value = _temp11;
    // b. If value is done, return undefined.
    if (value === 'done') {
      return Value.undefined;
    }
    // c. Let result be Completion(Call(predicate, undefined, « value, 𝔽(counter) »)).
    let result = yield* Call(predicate, Value.undefined, [value, Value(counter)]);
    // d. IfAbruptCloseIterator(result, iterated).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (result instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, result));
    /* node:coverage ignore next */
    if (result instanceof Completion) result = result.Value;
    if (ToBoolean(result) === Value.true) {
      return yield* IteratorClose(iterated, EnsureCompletion(value));
    }
    // f. Set counter to counter + 1.
    counter += 1;
  }
}
IteratorPrototype_find.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.find';
/** https://tc39.es/ecma262/#sec-iterator.prototype.flatmap */
function* IteratorPrototype_flatMap([mapper = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. If IsCallable(mapper) is false, then
  if (IsCallable(mapper) === false) {
    // a. Let error be ThrowCompletion(a newly created TypeError object).
    const error = surroundingAgent.Throw('TypeError', 'NotAFunction', mapper);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 5. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp12 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  iterated = _temp12;
  // 6. Let closure be a new Abstract Closure with no parameters that captures iterated and mapper and performs the following steps when called:
  const closure = function* closure() {
    //  a. Let counter be 0.
    let counter = 0;
    // b. Repeat,
    while (true) {
      /* ReturnIfAbrupt */
      let _temp13 = yield* IteratorStepValue(iterated);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      // i. Let value be ? IteratorStepValue(iterated).
      const value = _temp13;
      // ii. If value is done, return ReturnCompletion(undefined).
      if (value === 'done') {
        return ReturnCompletion(Value.undefined);
      }
      // iii. Let mapped be Completion(Call(mapper, undefined, « value, 𝔽(counter) »)).
      let mapped = EnsureCompletion(yield* Call(mapper, Value.undefined, [value, Value(counter)]));
      // iv. IfAbruptCloseIterator(mapped, iterated).
      /* IfAbruptCloseIterator */
      /* node:coverage ignore next */
      if (mapped instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, mapped));
      /* node:coverage ignore next */
      if (mapped instanceof Completion) mapped = mapped.Value;
      // v. Let innerIterator be Completion(GetIteratorFlattenable(mapped, reject-primitives)).
      let innerIterator = EnsureCompletion(yield* GetIteratorFlattenable(mapped, 'reject-primitives'));
      // vi. IfAbruptCloseIterator(innerIterator, iterated).
      /* IfAbruptCloseIterator */
      /* node:coverage ignore next */
      if (innerIterator instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, innerIterator));
      /* node:coverage ignore next */
      if (innerIterator instanceof Completion) innerIterator = innerIterator.Value;
      // vii. Let innerAlive be true.
      let innerAlive = true;
      // viii. Repeat, while innerAlive is true,
      while (innerAlive) {
        // 1. Let innerValue be Completion(IteratorStepValue(innerIterator)).
        let innerValue = yield* IteratorStepValue(innerIterator);
        // 2. IfAbruptCloseIterator(innerValue, iterated).
        /* IfAbruptCloseIterator */
        /* node:coverage ignore next */
        if (innerValue instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, innerValue));
        /* node:coverage ignore next */
        if (innerValue instanceof Completion) innerValue = innerValue.Value;
        // 3. If innerValue is done, then
        if (innerValue === 'done') {
          // a. Set innerAlive to false.
          innerAlive = false;
          // 4. Else,
        } else {
          // a. Let completion be Completion(Yield(innerValue)).
          const completion = EnsureCompletion(yield* Yield(innerValue));
          // b. If completion is an abrupt completion, then
          if (completion instanceof AbruptCompletion) {
            // i. Let backupCompletion be Completion(IteratorClose(innerIterator, completion)).
            let backupCompletion = EnsureCompletion(yield* IteratorClose(innerIterator, completion));
            // ii. IfAbruptCloseIterator(backupCompletion, iterated).
            /* IfAbruptCloseIterator */
            /* node:coverage ignore next */
            if (backupCompletion instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, backupCompletion));
            /* node:coverage ignore next */
            if (backupCompletion instanceof Completion) backupCompletion = backupCompletion.Value;
            // iii. Return ? IteratorClose(iterated, completion).
            return yield* IteratorClose(iterated, completion);
          }
        }
      }
      // ix. Set counter to counter + 1.
      counter += 1;
    }
  };

  // 7. Let result be CreateIteratorFromClosure(closure, "Iterator Helper", %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
  const result = CreateIteratorFromClosure(closure, Value('Iterator Helper'), surroundingAgent.currentRealmRecord.Intrinsics['%IteratorHelperPrototype%'], ['UnderlyingIterator']);
  // 8. Set result.[[UnderlyingIterator]] to iterated.
  result.UnderlyingIterator = iterated;
  // 9. Return result.
  return result;
}
IteratorPrototype_flatMap.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.flatmap';
/** https://tc39.es/ecma262/#sec-iterator.prototype.foreach */
function* IteratorPrototype_forEach([procedure = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. If IsCallable(procedure) is false, then
  if (IsCallable(procedure) === false) {
    // a. Let error be ThrowCompletion(a newly created TypeError object).
    const error = surroundingAgent.Throw('TypeError', 'NotAFunction', procedure);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 5. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp14 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  iterated = _temp14;
  // 6. Let counter be 0.
  let counter = 0;
  // 7. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp15 = yield* IteratorStepValue(iterated);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) return _temp15;
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    // a. Let value be ? IteratorStepValue(iterated).
    const value = _temp15;
    // b. If value is done, return undefined.
    if (value === 'done') {
      return Value.undefined;
    }
    // c. Let result be Completion(Call(procedure, undefined, « value, 𝔽(counter) »)).
    let result = yield* Call(procedure, Value.undefined, [value, Value(counter)]);
    // d. IfAbruptCloseIterator(result, iterated).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (result instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, result));
    /* node:coverage ignore next */
    if (result instanceof Completion) result = result.Value;
    // e. Set counter to counter + 1.
    counter += 1;
  }
}
IteratorPrototype_forEach.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.foreach';
/** https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iterator.prototype-%symbol.iterator% */
function IteratorPrototype_iterator(_args, {
  thisValue
}) {
  // 1. Return the this value.
  return thisValue;
}
IteratorPrototype_iterator.section = 'https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iterator.prototype-%symbol.iterator%';
/** https://tc39.es/ecma262/#sec-iterator.prototype.map */
function* IteratorPrototype_map([mapper = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. If IsCallable(mapper) is false, then
  if (IsCallable(mapper) === false) {
    // a. Let error be ThrowCompletion(a newly created TypeError object).
    const error = surroundingAgent.Throw('TypeError', 'NotAFunction', mapper);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 5. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp16 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  iterated = _temp16;
  // 6. Let closure be a new Abstract Closure with no parameters that captures iterated and mapper and performs the following steps when called:
  const closure = function* closure() {
    // a. Let counter be 0.
    let counter = 0;
    // b. Repeat,
    while (true) {
      /* ReturnIfAbrupt */
      let _temp17 = yield* IteratorStepValue(iterated);
      /* node:coverage ignore next */
      if (_temp17 instanceof AbruptCompletion) return _temp17;
      /* node:coverage ignore next */
      if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
      // i. Let value be ? IteratorStepValue(iterated).
      const value = _temp17;
      // ii. If value is done, return ReturnCompletion(undefined).
      if (value === 'done') {
        return ReturnCompletion(Value.undefined);
      }
      // iii. Let mapped be Completion(Call(mapper, undefined, « value, 𝔽(counter) »)).
      let mapped = yield* Call(mapper, Value.undefined, [value, Value(counter)]);
      // iv. IfAbruptCloseIterator(mapped, iterated).
      /* IfAbruptCloseIterator */
      /* node:coverage ignore next */
      if (mapped instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, mapped));
      /* node:coverage ignore next */
      if (mapped instanceof Completion) mapped = mapped.Value;
      let completion = EnsureCompletion(yield* Yield(mapped));
      // vi. IfAbruptCloseIterator(completion, iterated).
      /* IfAbruptCloseIterator */
      /* node:coverage ignore next */
      if (completion instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, completion));
      /* node:coverage ignore next */
      if (completion instanceof Completion) completion = completion.Value;
      // vii. Set counter to counter + 1.
      counter += 1;
    }
  };
  // 7. Let result be CreateIteratorFromClosure(closure, "Iterator Helper", %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
  const result = CreateIteratorFromClosure(closure, Value('Iterator Helper'), surroundingAgent.currentRealmRecord.Intrinsics['%IteratorHelperPrototype%'], ['UnderlyingIterator']);
  // 8. Set result.[[UnderlyingIterator]] to iterated.
  result.UnderlyingIterator = iterated;
  // 9. Return result.
  return result;
}
IteratorPrototype_map.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.map';
/** https://tc39.es/ecma262/#sec-iterator.prototype.reduce */
function* IteratorPrototype_reduce(args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. If IsCallable(reducer) is false, then
  const reducer = args[0] ?? Value.undefined;
  if (IsCallable(reducer) === false) {
    // a. Let error be ThrowCompletion(a newly created TypeError object).
    const error = surroundingAgent.Throw('TypeError', 'NotAFunction', reducer);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 5. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp18 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) return _temp18;
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  iterated = _temp18;
  // 6. If initialValue is not present, then
  let accumulator;
  let counter;
  if (args.length < 2) {
    /* ReturnIfAbrupt */
    let _temp19 = yield* IteratorStepValue(iterated);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) return _temp19;
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    // a. Let accumulator be ? IteratorStepValue(iterated).
    accumulator = _temp19;
    // b. If accumulator is done, throw a TypeError exception.
    if (accumulator === 'done') {
      return surroundingAgent.Throw('TypeError', 'IteratorCompleted');
    }
    // c. Let counter be 1.
    counter = 1;
  } else {
    // 7. Else,
    //   a. Let accumulator be initialValue.
    //   b. Let counter be 0.
    accumulator = args[1] ?? Value.undefined;
    counter = 0;
  }
  // 8. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp20 = yield* IteratorStepValue(iterated);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    // a. Let value be ? IteratorStepValue(iterated).
    const value = _temp20;
    // b. If value is done, return accumulator.
    if (value === 'done') {
      return accumulator;
    }
    // c. Let result be Completion(Call(reducer, undefined, « accumulator, value, 𝔽(counter) »)).
    let result = yield* Call(reducer, Value.undefined, [accumulator, value, Value(counter)]);
    // d. IfAbruptCloseIterator(result, iterated).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (result instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, result));
    /* node:coverage ignore next */
    if (result instanceof Completion) result = result.Value;
    accumulator = result;
    // f. Set counter to counter + 1.
    counter += 1;
  }
}
IteratorPrototype_reduce.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.reduce';
/** https://tc39.es/ecma262/#sec-iterator.prototype.some */
function* IteratorPrototype_some([predicate = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. If IsCallable(predicate) is false, then
  if (IsCallable(predicate) === false) {
    // a. Let error be ThrowCompletion(a newly created TypeError object).
    const error = surroundingAgent.Throw('TypeError', 'NotAFunction', predicate);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 5. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp21 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  iterated = _temp21;
  // 6. Let counter be 0.
  let counter = 0;
  // 7. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp22 = yield* IteratorStepValue(iterated);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    // a. Let value be ? IteratorStepValue(iterated).
    const value = _temp22;
    // b. If value is done, return false.
    if (value === 'done') {
      return Value.false;
    }
    // c. Let result be Completion(Call(predicate, undefined, « value, 𝔽(counter) »)).
    let result = yield* Call(predicate, Value.undefined, [value, Value(counter)]);
    // d. IfAbruptCloseIterator(result, iterated).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (result instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, result));
    /* node:coverage ignore next */
    if (result instanceof Completion) result = result.Value;
    // e. If ToBoolean(result) is true, return ? IteratorClose(iterated, NormalCompletion(true)).
    if (ToBoolean(result) === Value.true) {
      return yield* IteratorClose(iterated, EnsureCompletion(Value.true));
    }
    // f. Set counter to counter + 1.
    counter += 1;
  }
}
IteratorPrototype_some.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.some';
/** https://tc39.es/ecma262/#sec-iterator.prototype.take */
function* IteratorPrototype_take([limit = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be the Iterator Record { [[Iterator]]: O, [[NextMethod]]: undefined, [[Done]]: false }.
  let iterated = {
    Iterator: O,
    NextMethod: Value.undefined,
    Done: Value.false
  };
  // 4. Let numLimit be Completion(ToNumber(limit)).
  let numLimit = yield* ToNumber(limit);
  // 5. IfAbruptCloseIterator(numLimit, iterated).
  /* IfAbruptCloseIterator */
  /* node:coverage ignore next */
  if (numLimit instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, numLimit));
  /* node:coverage ignore next */
  if (numLimit instanceof Completion) numLimit = numLimit.Value;
  // 6. If numLimit is NaN, then
  if (numLimit.isNaN()) {
    // a. Let error be ThrowCompletion(a newly created RangeError object).
    const error = surroundingAgent.Throw('RangeError', 'OutOfRange', numLimit);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 7. Let integerLimit be ! ToIntegerOrInfinity(numLimit).
  /* X */
  let _temp23 = yield* ToIntegerOrInfinity(numLimit instanceof NormalCompletion ? numLimit.Value : numLimit);
  /* node:coverage ignore next */
  if (_temp23 instanceof AbruptCompletion) throw new Assert.Error("! yield* ToIntegerOrInfinity(numLimit instanceof NormalCompletion ? numLimit.Value : numLimit) returned an abrupt completion", {
    cause: _temp23
  });
  /* node:coverage ignore next */
  if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
  const integerLimit = _temp23;
  // 8. If integerLimit < 0, then
  if (integerLimit < 0) {
    // a. Let error be ThrowCompletion(a newly created RangeError object).
    const error = surroundingAgent.Throw('RangeError', 'OutOfRange', numLimit);
    // b. Return ? IteratorClose(iterated, error).
    return yield* IteratorClose(iterated, error);
  }
  // 9. Set iterated to ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp24 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) return _temp24;
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  iterated = _temp24;
  // 10. Let closure be a new Abstract Closure with no parameters that captures iterated and integerLimit and performs the following steps when called:
  const closure = function* closure() {
    // a. Let remaining be integerLimit.
    let remaining = integerLimit;
    //         b. Repeat,
    while (true) {
      // i. If remaining = 0, then
      //   1. Return ? IteratorClose(iterated, ReturnCompletion(undefined)).
      if (remaining === 0) {
        return yield* IteratorClose(iterated, ReturnCompletion(Value.undefined));
      }
      // ii. If remaining ≠ +∞, then
      //   1. Set remaining to remaining - 1.
      if (remaining !== +Infinity) {
        remaining -= 1;
      }
      // iii. Let value be ? IteratorStepValue(iterated).
      /* ReturnIfAbrupt */
      let _temp25 = yield* IteratorStepValue(iterated);
      /* node:coverage ignore next */
      if (_temp25 instanceof AbruptCompletion) return _temp25;
      /* node:coverage ignore next */
      if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
      const value = _temp25;
      // iv. If value is done, return ReturnCompletion(undefined).
      if (value === 'done') {
        return ReturnCompletion(Value.undefined);
      }
      // v. Let completion be Completion(Yield(value)).
      let completion = EnsureCompletion(yield* Yield(value));
      // vi. IfAbruptCloseIterator(completion, iterated).
      /* IfAbruptCloseIterator */
      /* node:coverage ignore next */
      if (completion instanceof AbruptCompletion) return skipDebugger(IteratorClose(iterated, completion));
      /* node:coverage ignore next */
      if (completion instanceof Completion) completion = completion.Value;
    }
  };
  // 11. Let result be CreateIteratorFromClosure(closure, "Iterator Helper", %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
  const result = CreateIteratorFromClosure(closure, Value('Iterator Helper'), surroundingAgent.currentRealmRecord.Intrinsics['%IteratorHelperPrototype%'], ['UnderlyingIterator']);
  // 12. Set result.[[UnderlyingIterator]] to iterated.
  result.UnderlyingIterator = iterated;
  // 13. Return result.
  return result;
}
IteratorPrototype_take.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.take';
/** https://tc39.es/ecma262/#sec-iterator.prototype.toarray */
function* IteratorPrototype_toArray(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If O is not an Object, throw a TypeError exception.
  if (!(O instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', O);
  }
  // 3. Let iterated be ? GetIteratorDirect(O).
  /* ReturnIfAbrupt */
  let _temp26 = yield* GetIteratorDirect(O);
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  const iterated = _temp26;
  // 4. Let items be a new empty List.
  const items = [];
  // 5. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp27 = yield* IteratorStepValue(iterated);
    /* node:coverage ignore next */
    if (_temp27 instanceof AbruptCompletion) return _temp27;
    /* node:coverage ignore next */
    if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
    // a. Let value be ? IteratorStepValue(iterated).
    const value = _temp27;
    // b. If value is done, return CreateArrayFromList(items).
    if (value === 'done') {
      return CreateArrayFromList(items);
    }
    // c. Append value to items.
    items.push(value);
  }
}
IteratorPrototype_toArray.section = 'https://tc39.es/ecma262/#sec-iterator.prototype.toarray';
/** https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-get-iterator.prototype-%symbol.tostringtag% */
function IteratorPrototype_toStringTagGetter() {
  return Value('Iterator');
}
IteratorPrototype_toStringTagGetter.section = 'https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-get-iterator.prototype-%symbol.tostringtag%';
/** https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-set-iterator.prototype-%symbol.tostringtag% */
function* IteratorPrototype_toStringTagSetter([v], {
  thisValue
}) {
  /* ReturnIfAbrupt */
  let _temp28 = yield* SetterThatIgnoresPrototypeProperties(thisValue, surroundingAgent.intrinsic('%Iterator.prototype%'), wellKnownSymbols.toStringTag, v);
  /* node:coverage ignore next */
  if (_temp28 instanceof AbruptCompletion) return _temp28;
  /* node:coverage ignore next */
  if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
  // 2. Return undefined.
  return Value.undefined;
}
IteratorPrototype_toStringTagSetter.section = 'https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-set-iterator.prototype-%symbol.tostringtag%';
function bootstrapIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['constructor', [IteratorProto_constructorGetter, IteratorProto_constructorSetter]], ['drop', IteratorPrototype_drop, 1], ['every', IteratorPrototype_every, 1], ['filter', IteratorPrototype_filter, 1], ['find', IteratorPrototype_find, 1], ['flatMap', IteratorPrototype_flatMap, 1], ['forEach', IteratorPrototype_forEach, 1], ['map', IteratorPrototype_map, 1], ['reduce', IteratorPrototype_reduce, 1], ['some', IteratorPrototype_some, 1], ['take', IteratorPrototype_take, 1], ['toArray', IteratorPrototype_toArray, 0], [wellKnownSymbols.iterator, IteratorPrototype_iterator, 0], [wellKnownSymbols.toStringTag, [IteratorPrototype_toStringTagGetter, IteratorPrototype_toStringTagSetter]]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%Iterator.prototype%'] = proto;
}

/** https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iterator-constructor */
function* IteratorConstructor(_args, {
  NewTarget
}) {
  // 1. If NewTarget is either undefined or the active function object, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  if (NewTarget === surroundingAgent.activeFunctionObject) {
    return surroundingAgent.Throw('TypeError', 'CannotConstructAbstractFunction', NewTarget);
  }

  // 2. Return ? OrdinaryCreateFromConstructor(NewTarget, "%Iterator.prototype%").
  return yield* OrdinaryCreateFromConstructor(NewTarget, '%Iterator.prototype%');
}
IteratorConstructor.section = 'https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iterator-constructor';
/** https://tc39.es/ecma262/#sec-iterator.from */
function* Iterator_from([O]) {
  /* ReturnIfAbrupt */
  let _temp = yield* GetIteratorFlattenable(O, 'iterate-string-primitives');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let iteratorRecord be ? GetIteratorFlattenable(O, iterate-string-primitives).
  const iteratorRecord = _temp;

  // 2. Let hasInstance be ? OrdinaryHasInstance(%Iterator%, iteratorRecord.[[Iterator]]).
  /* ReturnIfAbrupt */
  let _temp2 = yield* OrdinaryHasInstance(surroundingAgent.intrinsic('%Iterator%'), iteratorRecord.Iterator);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const hasInstance = _temp2;
  // 3. If hasInstance is true, then
  if (hasInstance === Value.true) {
    // a. Return iteratorRecord.[[Iterator]].
    return iteratorRecord.Iterator;
  }

  // 4. Let wrapper be OrdinaryObjectCreate(%WrapForValidIteratorPrototype%, « [[Iterated]] »).
  const wrapper = OrdinaryObjectCreate(surroundingAgent.intrinsic('%WrapForValidIteratorPrototype%'), ['Iterated']);
  // 5. Set wrapper.[[Iterated]] to iteratorRecord.
  wrapper.Iterated = iteratorRecord;
  // 6. Return wrapper.
  return wrapper;
}
Iterator_from.section = 'https://tc39.es/ecma262/#sec-iterator.from';
function bootstrapIterator(realmRec) {
  const cons = bootstrapConstructor(realmRec, IteratorConstructor, 'Iterator', 0, realmRec.Intrinsics['%Iterator.prototype%'], [['from', Iterator_from, 1]]);
  realmRec.Intrinsics['%Iterator%'] = cons;
}

/** https://tc39.es/ecma262/#sec-asynciteratorprototype-asynciterator */
function AsyncIteratorPrototype_asyncIterator(_args, {
  thisValue
}) {
  // 1. Return the this value.
  return thisValue;
}
AsyncIteratorPrototype_asyncIterator.section = 'https://tc39.es/ecma262/#sec-asynciteratorprototype-asynciterator';
function bootstrapAsyncIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [[wellKnownSymbols.asyncIterator, AsyncIteratorPrototype_asyncIterator, 0]], realmRec.Intrinsics['%Object.prototype%']);
  realmRec.Intrinsics['%AsyncIteratorPrototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next */
function* ArrayIteratorPrototype_next(_args, {
  thisValue
}) {
  // 1. Return ? GeneratorResume(this value, empty, "%ArrayIteratorPrototype%").
  return yield* GeneratorResume(thisValue, undefined, Value('%ArrayIteratorPrototype%'));
}
ArrayIteratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next';
function bootstrapArrayIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', ArrayIteratorPrototype_next, 0]], realmRec.Intrinsics['%Iterator.prototype%'], 'Array Iterator');
  realmRec.Intrinsics['%ArrayIteratorPrototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-createmapiterator */
function CreateMapIterator(map, kind) {
  Assert(kind === 'key+value' || kind === 'key' || kind === 'value', "kind === 'key+value' || kind === 'key' || kind === 'value'");
  // 1. Perform ? RequireInternalSlot(map, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(map, 'MapData');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 2. Let closure be a new Abstract Closure with no parameters that captures map and kind and performs the following steps when called:
  const closure = function* closure() {
    // a. Let entries be the List that is map.[[MapData]].
    const entries = map.MapData;
    // b. Let index be 0.
    let index = 0;
    // c. Let numEntries be the number of elements of entries.
    let numEntries = entries.length;
    // d. Repeat, while index < numEntries,
    while (index < numEntries) {
      // i. Let e be the Record { [[Key]], [[Value]] } that is the value of entries[index].
      const e = entries[index];
      // ii. Set index to index + 1.
      index += 1;
      // iii. If e.[[Key]] is not empty, then
      if (e.Key !== undefined) {
        let result;
        // 1. If kind is key, let result be e.[[Key]].
        if (kind === 'key') {
          result = e.Key;
        } else if (kind === 'value') {
          // 2. Else if kind is value, let result be e.[[Value]].
          result = e.Value;
        } else {
          // 3. Else,
          // a. Assert: kind is key+value.
          Assert(kind === 'key+value', "kind === 'key+value'");
          // b. Let result be ! CreateArrayFromList(« e.[[Key]], e.[[Value]] »).
          /* X */
          let _temp2 = CreateArrayFromList([e.Key, e.Value]);
          /* node:coverage ignore next */
          if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
          /* node:coverage ignore next */
          if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList([e.Key, e.Value!]) returned an abrupt completion", {
            cause: _temp2
          });
          /* node:coverage ignore next */
          if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
          result = _temp2;
        }
        // 4. Perform ? Yield(result).
        /* ReturnIfAbrupt */
        let _temp3 = yield* Yield(result);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) return _temp3;
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      }
      // iv. Set numEntries to the number of elements of entries.
      numEntries = entries.length;
    }
    // NON-SPEC
    generator.HostCapturedValues = undefined;
    // e. Return undefined.
    return Value.undefined;
  };
  // 3. Return ! CreateIteratorFromClosure(closure, "%MapIteratorPrototype%", %MapIteratorPrototype%).
  /* X */
  let _temp4 = CreateIteratorFromClosure(closure, Value('%MapIteratorPrototype%'), surroundingAgent.intrinsic('%MapIteratorPrototype%'), ['HostCapturedValues'], [map]);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorFromClosure(closure, Value('%MapIteratorPrototype%'), surroundingAgent.intrinsic('%MapIteratorPrototype%'), ['HostCapturedValues'], [map]) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const generator = _temp4;
  return generator;
}
CreateMapIterator.section = 'https://tc39.es/ecma262/#sec-createmapiterator';
/** https://tc39.es/ecma262/#sec-%mapiteratorprototype%.next */
function* MapIteratorPrototype_next(_args, {
  thisValue
}) {
  // 1. Return ? GeneratorResume(this value, empty, "%MapIteratorPrototype%")
  return yield* GeneratorResume(thisValue, undefined, Value('%MapIteratorPrototype%'));
}
MapIteratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-%mapiteratorprototype%.next';
function bootstrapMapIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', MapIteratorPrototype_next, 0]], realmRec.Intrinsics['%Iterator.prototype%'], 'Map Iterator');
  realmRec.Intrinsics['%MapIteratorPrototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-createsetiterator */
function CreateSetIterator(set, kind) {
  // 1. Assert: kind is key+value or value.
  Assert(kind === 'key+value' || kind === 'value', "kind === 'key+value' || kind === 'value'");
  // 2. Perform ? RequireInternalSlot(set, [[SetData]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(set, 'SetData');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Let closure be a new Abstract Closure with no parameters that captures set and kind and performs the following steps when called:
  const closure = function* closure() {
    // a. Let index be 0.
    let index = 0;
    // b. Let entries be the List that is set.[[SetData]].
    const entries = set.SetData;
    // c. Let numEntries be the number of elements of entries.
    let numEntries = entries.length;
    // d. Repeat, while index < numEntries,
    while (index < numEntries) {
      // i. Let e be entries[index].
      const e = entries[index];
      // ii. Set index to index + 1.
      index += 1;
      // iii. If e is not empty, then
      if (e !== undefined) {
        // 1. If kind is key+value, then
        if (kind === 'key+value') {
          /* X */
          let _temp3 = CreateArrayFromList([e, e]);
          /* node:coverage ignore next */
          if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
          /* node:coverage ignore next */
          if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! CreateArrayFromList([e, e]) returned an abrupt completion", {
            cause: _temp3
          });
          /* node:coverage ignore next */
          if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
          /* ReturnIfAbrupt */
          let _temp2 = yield* Yield(_temp3);
          /* node:coverage ignore next */
          if (_temp2 instanceof AbruptCompletion) return _temp2;
          /* node:coverage ignore next */
          if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        } else {
          // 2. Else,
          // a. Assert: kind is value.
          Assert(kind === 'value', "kind === 'value'");
          // b. Perform ? Yield(e).
          /* ReturnIfAbrupt */
          let _temp4 = yield* Yield(e);
          /* node:coverage ignore next */
          if (_temp4 instanceof AbruptCompletion) return _temp4;
          /* node:coverage ignore next */
          if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
        }
      }
      // iv. Set numEntries to the number of elements of entries.
      numEntries = entries.length;
    }
    // NON-SPEC
    generator.HostCapturedValues = undefined;
    // e. Return undefined.
    return Value.undefined;
  };
  // 4. Return ! CreateIteratorFromClosure(closure, "%SetIteratorPrototype%", %SetIteratorPrototype%).
  /* X */
  let _temp5 = CreateIteratorFromClosure(closure, Value('%SetIteratorPrototype%'), surroundingAgent.intrinsic('%SetIteratorPrototype%'), ['HostCapturedValues'], [set]);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorFromClosure(closure, Value('%SetIteratorPrototype%'), surroundingAgent.intrinsic('%SetIteratorPrototype%'), ['HostCapturedValues'], [set]) returned an abrupt completion", {
    cause: _temp5
  });
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const generator = _temp5;
  return generator;
}
CreateSetIterator.section = 'https://tc39.es/ecma262/#sec-createsetiterator';
/** https://tc39.es/ecma262/#sec-%setiteratorprototype%.next */
function* SetIteratorPrototype_next(_args, {
  thisValue
}) {
  // 1. Return ? GeneratorResume(this value, empty, "%SetIteratorPrototype%").
  return yield* GeneratorResume(thisValue, undefined, Value('%SetIteratorPrototype%'));
}
SetIteratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-%setiteratorprototype%.next';
function bootstrapSetIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', SetIteratorPrototype_next, 0]], realmRec.Intrinsics['%Iterator.prototype%'], 'Set Iterator');
  realmRec.Intrinsics['%SetIteratorPrototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next */
function* StringIteratorPrototype_next(_args, {
  thisValue
}) {
  // 1. Return ? GeneratorResume(this value, empty, "%StringIteratorPrototype%").
  return yield* GeneratorResume(thisValue, undefined, Value('%StringIteratorPrototype%'));
}
StringIteratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next';
function bootstrapStringIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', StringIteratorPrototype_next, 0]], realmRec.Intrinsics['%Iterator.prototype%'], 'String Iterator');
  realmRec.Intrinsics['%StringIteratorPrototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-map.prototype.clear */
function MapProto_clear(_args, {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Let entries be the List that is M.[[MapData]].
  const entries = M.MapData;
  // 4. For each Record { [[Key]], [[Value]] } p that is an element of entries, do
  if (entries.length) {
    /* ReturnIfAbrupt */
    let _temp2 = surroundingAgent.debugger_tryTouchDuringPreview(M);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  }
  for (const p of entries) {
    // a. Set p.[[Key]] to empty.
    p.Key = undefined;
    // b. Set p.[[Value]] to empty.
    p.Value = undefined;
  }
  // 5. Return undefined.
  return Value.undefined;
}
MapProto_clear.section = 'https://tc39.es/ecma262/#sec-map.prototype.clear';
/** https://tc39.es/ecma262/#sec-map.prototype.delete */
function MapProto_delete([key = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp3 = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 3. Let entires be M.[[MapData]].
  const entries = M.MapData;
  // 4. For each Record { [[Key]], [[Value]] } p that is an element of entries, do
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      /* ReturnIfAbrupt */
      let _temp4 = surroundingAgent.debugger_tryTouchDuringPreview(M);
      /* node:coverage ignore next */
      if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      // i. Set p.[[Key]] to empty.
      p.Key = undefined;
      // ii. Set p.[[Value]] to empty.
      p.Value = undefined;
      // iii. Return true.
      return Value.true;
    }
  }
  return Value.false;
}
MapProto_delete.section = 'https://tc39.es/ecma262/#sec-map.prototype.delete';
/** https://tc39.es/ecma262/#sec-map.prototype.entries */
function MapProto_entries(_args, {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Return ? CreateMapIterator(M, key+value);
  return CreateMapIterator(M, 'key+value');
}
MapProto_entries.section = 'https://tc39.es/ecma262/#sec-map.prototype.entries';
/** https://tc39.es/ecma262/#sec-map.prototype.foreach */
function* MapProto_forEach([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp5 = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.
  if (!IsCallable(callbackfn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }
  // 4. Let entries be the List that is M.[[MapData]].
  const entries = M.MapData;
  // 5. For each Record { [[Key]], [[Value]] } e that is an element of entries, in original key insertion order, do
  for (const e of entries) {
    // a. If e.[[Key]] is not empty, then
    if (e.Key !== undefined) {
      /* ReturnIfAbrupt */
      let _temp6 = yield* Call(callbackfn, thisArg, [e.Value, e.Key, M]);
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) return _temp6;
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    }
  }
  // 6. Return undefined.
  return Value.undefined;
}
MapProto_forEach.section = 'https://tc39.es/ecma262/#sec-map.prototype.foreach';
/** https://tc39.es/ecma262/#sec-map.prototype.get */
function MapProto_get([key = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp7 = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 3. Let entries be the List that is M.[[MapData]].
  const entries = M.MapData;
  // 4. For each Record { [[Key]], [[Value]] } p that is an element of entries, do
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return p.[[Value]].
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      // i. Return p.[[Value]].
      return p.Value;
    }
  }
  // 5. Return undefined.
  return Value.undefined;
}
MapProto_get.section = 'https://tc39.es/ecma262/#sec-map.prototype.get';
/**  https://tc39.es/proposal-upsert/#sec-map.prototype.getOrInsert */
function MapProto_getOrInsert([key = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp8 = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 3. Set key to CanonicalizeKeyedCollectionKey(key).
  key = CanonicalizeKeyedCollectionKey(key);
  // 4. For each Record { [[Key]], [[Value]] } p of M.[[MapData]], do
  const entries = M.MapData;
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return p.[[Value]].
    if (p.Key !== undefined && SameValue(p.Key, key) === Value.true) {
      return p.Value;
    }
  }
  // 5. Let p be the Record { [[Key]]: key, [[Value]]: value }.
  const p = {
    Key: key,
    Value: value
  };
  // 6. Append p to M.[[MapData]].
  entries.push(p);
  // 7. Return value.
  return value;
}
MapProto_getOrInsert.section = 'https://tc39.es/proposal-upsert/#sec-map.prototype.getOrInsert';
/**  https://tc39.es/proposal-upsert/#sec-map.prototype.getOrInsertComputed */
function* MapProto_getOrInsertComputed([key = Value.undefined, callbackfn = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp9 = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.
  if (!IsCallable(callbackfn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }
  // 4. Set key to CanonicalizeKeyedCollectionKey(key).
  key = CanonicalizeKeyedCollectionKey(key);
  // 5. For each Record { [[Key]], [[Value]] } p of M.[[MapData]], do
  const entries = M.MapData;
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return p.[[Value]].
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      return p.Value;
    }
  }
  // 6. Let value be ? Call(callbackfn, undefined, « key »).
  /* ReturnIfAbrupt */
  let _temp10 = yield* Call(callbackfn, Value.undefined, [key]);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const value = _temp10;
  // 7. NOTE: The Map may have been modified during execution of callbackfn.
  // 8. For each Record { [[Key]], [[Value]] } p of M.[[MapData]], do
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, then
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      // i. Set p.[[Value]] to value.
      p.Value = value;
      // ii. Return value.
      return value;
    }
  }
  // 9. Let p be the Record { [[Key]]: key, [[Value]]: value }.
  const p = {
    Key: key,
    Value: value
  };
  // 10. Append p to M.[[MapData]].
  entries.push(p);
  // 11. Return value.
  return value;
}
MapProto_getOrInsertComputed.section = 'https://tc39.es/proposal-upsert/#sec-map.prototype.getOrInsertComputed';
/** https://tc39.es/ecma262/#sec-map.prototype.has */
function MapProto_has([key = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp11 = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  // 3. Let entries be the List that is M.[[MapData]].
  const entries = M.MapData;
  // 4. For each Record { [[Key]], [[Value]] } p that is an element of entries, do
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return true.
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      return Value.true;
    }
  }
  // 5. Return false.
  return Value.false;
}
MapProto_has.section = 'https://tc39.es/ecma262/#sec-map.prototype.has';
/** https://tc39.es/ecma262/#sec-map.prototype.keys */
function MapProto_keys(_args, {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Return ? CreateMapIterator(M, key).
  return CreateMapIterator(M, 'key');
}
MapProto_keys.section = 'https://tc39.es/ecma262/#sec-map.prototype.keys';
/** https://tc39.es/ecma262/#sec-map.prototype.set */
function MapProto_set([key = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp12 = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  // 3. Let entries be the List that is M.[[MapData]].
  const entries = M.MapData;
  // 4. For each Record { [[Key]], [[Value]] } p that is an element of entries, do
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then
    if (p.Key !== undefined && SameValueZero(p.Key, key) === Value.true) {
      /* ReturnIfAbrupt */
      let _temp13 = surroundingAgent.debugger_tryTouchDuringPreview(M);
      /* node:coverage ignore next */
      if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) return _temp13;
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      p.Value = value;
      // ii. Return M.
      return M;
    }
  }
  // 5. If key is -0𝔽, set key to +0𝔽.
  if (key instanceof NumberValue && Object.is(R(key), -0)) {
    key = F(0);
  }
  // 6. Let p be the Record { [[Key]]: key, [[Value]]: value }.
  const p = {
    Key: key,
    Value: value
  };
  // 7. Append p as the last element of entries.
  /* ReturnIfAbrupt */
  let _temp14 = surroundingAgent.debugger_tryTouchDuringPreview(M);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  entries.push(p);
  // 8. Return M.
  return M;
}
MapProto_set.section = 'https://tc39.es/ecma262/#sec-map.prototype.set';
/** https://tc39.es/ecma262/#sec-get-map.prototype.size */
function MapProto_sizeGetter(_args, {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[MapData]]).
  /* ReturnIfAbrupt */
  let _temp15 = RequireInternalSlot(M, 'MapData');
  /* node:coverage ignore next */
  if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  // 3. Let entries be the List that is M.[[MapData]].
  const entries = M.MapData;
  // 4. Let count be 0.
  let count = 0;
  // 5. For each Record { [[Key]], [[Value]] } p that is an element of entries, do
  for (const p of entries) {
    // a. If p.[[Key]] is not empty, set count to count + 1.
    if (p.Key !== undefined) {
      count += 1;
    }
  }
  // 6. Return 𝔽(count).
  return F(count);
}
MapProto_sizeGetter.section = 'https://tc39.es/ecma262/#sec-get-map.prototype.size';
/** https://tc39.es/ecma262/#sec-map.prototype.values */
function MapProto_values(_args, {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Return ? CreateMapIterator(M, value).
  return CreateMapIterator(M, 'value');
}
MapProto_values.section = 'https://tc39.es/ecma262/#sec-map.prototype.values';
function bootstrapMapPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['clear', MapProto_clear, 0], ['delete', MapProto_delete, 1], ['entries', MapProto_entries, 0], ['forEach', MapProto_forEach, 1], ['get', MapProto_get, 1], ['getOrInsert', MapProto_getOrInsert, 2], ['getOrInsertComputed', MapProto_getOrInsertComputed, 2], ['has', MapProto_has, 1], ['keys', MapProto_keys, 0], ['set', MapProto_set, 2], ['size', [MapProto_sizeGetter]], ['values', MapProto_values, 0]], realmRec.Intrinsics['%Object.prototype%'], 'Map');
  /* X */
  let _temp16 = proto.GetOwnProperty(Value('entries'));
  /* node:coverage ignore next */
  if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! proto.GetOwnProperty(Value('entries')) returned an abrupt completion", {
    cause: _temp16
  });
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  const entriesFunc = _temp16;
  /* X */
  let _temp17 = proto.DefineOwnProperty(wellKnownSymbols.iterator, entriesFunc);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! proto.DefineOwnProperty(wellKnownSymbols.iterator, entriesFunc as Descriptor) returned an abrupt completion", {
    cause: _temp17
  });
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  realmRec.Intrinsics['%Map.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-set.prototype.add */
function SetProto_add([value = Value.undefined], {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[SetData]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(S, 'SetData');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Let entries be the List that is S.[[SetData]].
  const entries = S.SetData;
  // 4. For each e that is an element of entries, do
  for (const e of entries) {
    // a. For each e that is an element of entries, do
    if (e !== undefined && SameValueZero(e, value) === Value.true) {
      // i. Return S.
      return S;
    }
  }
  // 5. If value is -0𝔽, set value to +0𝔽.
  if (value instanceof NumberValue && Object.is(R(value), -0)) {
    value = F(0);
  }
  // 6. Append value as the last element of entries.
  /* ReturnIfAbrupt */
  let _temp2 = surroundingAgent.debugger_tryTouchDuringPreview(S);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  entries.push(value);
  // 7. Return S.
  return S;
}
SetProto_add.section = 'https://tc39.es/ecma262/#sec-set.prototype.add';
/** https://tc39.es/ecma262/#sec-set.prototype.clear */
function SetProto_clear(_args, {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[SetData]]).
  /* ReturnIfAbrupt */
  let _temp3 = RequireInternalSlot(S, 'SetData');
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 3. Let entries be the List that is S.[[SetData]].
  const entries = S.SetData;
  // 4. For each e that is an element of entries, do
  if (entries.length) {
    /* ReturnIfAbrupt */
    let _temp4 = surroundingAgent.debugger_tryTouchDuringPreview(S);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  }
  for (let i = 0; i < entries.length; i += 1) {
    // a. Replace the element of entries whose value is e with an element whose value is empty.
    entries[i] = undefined;
  }
  // 5. Return undefined.
  return Value.undefined;
}
SetProto_clear.section = 'https://tc39.es/ecma262/#sec-set.prototype.clear';
/** https://tc39.es/ecma262/#sec-set.prototype.delete */
function SetProto_delete([value = Value.undefined], {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[SetData]]).
  /* ReturnIfAbrupt */
  let _temp5 = RequireInternalSlot(S, 'SetData');
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 3. Let entries be the List that is S.[[SetData]].
  const entries = S.SetData;
  // 4. For each e that is an element of entries, do
  for (let i = 0; i < entries.length; i += 1) {
    const e = entries[i];
    // a. If e is not empty and SameValueZero(e, value) is true, then
    if (e !== undefined && SameValueZero(e, value) === Value.true) {
      /* ReturnIfAbrupt */
      let _temp6 = surroundingAgent.debugger_tryTouchDuringPreview(S);
      /* node:coverage ignore next */
      if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) return _temp6;
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      entries[i] = undefined;
      // ii. Return true.
      return Value.true;
    }
  }
  // 5. Return false.
  return Value.false;
}
SetProto_delete.section = 'https://tc39.es/ecma262/#sec-set.prototype.delete';
/** https://tc39.es/ecma262/#sec-set.prototype.entries */
function SetProto_entries(_args, {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Return ? CreateSetIterator(S, key+value).
  return CreateSetIterator(S, 'key+value');
}
SetProto_entries.section = 'https://tc39.es/ecma262/#sec-set.prototype.entries';
/** https://tc39.es/ecma262/#sec-set.prototype.foreach */
function* SetProto_forEach([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[SetData]]).
  /* ReturnIfAbrupt */
  let _temp7 = RequireInternalSlot(S, 'SetData');
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 3. If IsCallable(callbackfn) is false, throw a TypeError exception
  if (!IsCallable(callbackfn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }
  // 4. Let entries be the List that is S.[[SetData]].
  const entries = S.SetData;
  // 5. For each element _e_ of _entries_, do
  for (const e of entries) {
    // a. If e is not empty, then
    if (e !== undefined) {
      /* ReturnIfAbrupt */
      let _temp8 = yield* Call(callbackfn, thisArg, [e, e, S]);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) return _temp8;
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    }
  }
  // 6. Return undefined.
  return Value.undefined;
}
SetProto_forEach.section = 'https://tc39.es/ecma262/#sec-set.prototype.foreach';
/** https://tc39.es/ecma262/#sec-set.prototype.has */
function SetProto_has([value = Value.undefined], {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[SetData]]).
  /* ReturnIfAbrupt */
  let _temp9 = RequireInternalSlot(S, 'SetData');
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  // 3. Let entries be the List that is S.[[SetData]].
  const entries = S.SetData;
  // 4. Let entries be the List that is S.[[SetData]].
  for (const e of entries) {
    // a. If e is not empty and SameValueZero(e, value) is true, return true.
    if (e !== undefined && SameValueZero(e, value) === Value.true) {
      return Value.true;
    }
  }
  // 5. Return false.
  return Value.false;
}
SetProto_has.section = 'https://tc39.es/ecma262/#sec-set.prototype.has';
/** https://tc39.es/ecma262/#sec-get-set.prototype.size */
function SetProto_sizeGetter(_args, {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[SetData]]).
  /* ReturnIfAbrupt */
  let _temp10 = RequireInternalSlot(S, 'SetData');
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  // 3. Let entries be the List that is S.[[SetData]].
  const entries = S.SetData;
  // 4. Let count be 0.
  let count = 0;
  // 5. For each e that is an element of entries, do
  for (const e of entries) {
    // a. If e is not empty, set count to count + 1
    if (e !== undefined) {
      count += 1;
    }
  }
  // 6. Return 𝔽(count).
  return F(count);
}
SetProto_sizeGetter.section = 'https://tc39.es/ecma262/#sec-get-set.prototype.size';
/** https://tc39.es/ecma262/#sec-set.prototype.values */
function SetProto_values(_args, {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Return ? CreateSetIterator(S, value).
  return CreateSetIterator(S, 'value');
}
SetProto_values.section = 'https://tc39.es/ecma262/#sec-set.prototype.values';
/** https://tc39.es/ecma262/#sec-set.prototype.union */
function* SetProto_union([other = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;

  // 2. Perform ? RequireInternalSlot(O, [[SetData]]).
  /* ReturnIfAbrupt */
  let _temp11 = RequireInternalSlot(O, 'SetData');
  /* node:coverage ignore next */
  if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;

  // 3. Let otherRec be ? GetSetRecord(other).
  /* ReturnIfAbrupt */
  let _temp12 = yield* GetSetRecord(other);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  const otherRec = _temp12;

  // 4. Let keysIter be ? GetKeysIterator(otherRec).
  /* ReturnIfAbrupt */
  let _temp13 = yield* GetKeysIterator(otherRec);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  const keysIter = _temp13;

  // 5. Let resultSetData be a copy of O.[[SetData]].
  const resultSetData = [...O.SetData];

  // 6. Let next be true.
  let next = Value.true;

  // 7. Repeat, while next is not DONE,
  while (next !== 'done') {
    /* ReturnIfAbrupt */
    let _temp14 = yield* IteratorStep(keysIter);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) return _temp14;
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    // a. Set next to ? IteratorStep(keysIter).
    next = _temp14;

    // b. If next is not DONE, then
    if (next !== 'done') {
      /* ReturnIfAbrupt */
      let _temp15 = yield* IteratorValue(next);
      /* node:coverage ignore next */
      if (_temp15 instanceof AbruptCompletion) return _temp15;
      /* node:coverage ignore next */
      if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
      // i. Let nextValue be ? IteratorValue(next).
      let nextValue = _temp15;

      // ii. If nextValue is -0𝔽, set nextValue to +0𝔽.
      if (nextValue instanceof NumberValue && Object.is(R(nextValue), -0)) {
        nextValue = F(0);
      }

      // iii. If SetDataHas(resultSetData, nextValue) is false, then
      if (SetDataHas(resultSetData, nextValue) === Value.false) {
        // 1. Append nextValue to resultSetData.
        resultSetData.push(nextValue);
      }
    }
  }

  // 8. Let result be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
  const result = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Set.prototype%'), ['SetData']);

  // 9. Set result.[[SetData]] to resultSetData.
  result.SetData = resultSetData;

  // 10. Return result.
  return EnsureCompletion(result);
}
SetProto_union.section = 'https://tc39.es/ecma262/#sec-set.prototype.union';
function bootstrapSetPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['add', SetProto_add, 1], ['clear', SetProto_clear, 0], ['delete', SetProto_delete, 1], ['entries', SetProto_entries, 0], ['forEach', SetProto_forEach, 1], ['has', SetProto_has, 1], ['size', [SetProto_sizeGetter]], ['values', SetProto_values, 0], ['union', SetProto_union, 1]], realmRec.Intrinsics['%Object.prototype%'], 'Set');
  /* X */
  let _temp16 = proto.GetOwnProperty(Value('values'));
  /* node:coverage ignore next */
  if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! proto.GetOwnProperty(Value('values')) returned an abrupt completion", {
    cause: _temp16
  });
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  const valuesFunc = _temp16;
  /* X */
  let _temp17 = proto.DefineOwnProperty(Value('keys'), valuesFunc);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! proto.DefineOwnProperty(Value('keys'), valuesFunc) returned an abrupt completion", {
    cause: _temp17
  });
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  /* X */
  let _temp18 = proto.DefineOwnProperty(wellKnownSymbols.iterator, valuesFunc);
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! proto.DefineOwnProperty(wellKnownSymbols.iterator, valuesFunc) returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  realmRec.Intrinsics['%Set.prototype%'] = proto;
}
/** https://tc39.es/ecma262/#sec-getsetrecord */
function* GetSetRecord(obj) {
  // 1. If obj is not an Object, throw a TypeError exception.
  if (!(obj instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', obj);
  }

  // 2. Let rawSize be ? Get(obj, "size").
  /* ReturnIfAbrupt */
  let _temp19 = yield* Get(obj, Value('size'));
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) return _temp19;
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  const rawSize = _temp19;

  // 3. Let numSize be ? ToNumber(rawSize).
  // 4. NOTE: If rawSize is undefined, then numSize will be NaN.
  /* ReturnIfAbrupt */
  let _temp20 = yield* ToNumber(rawSize);
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  const numSize = _temp20;

  // 5. If numSize is NaN, throw a TypeError exception.
  if (numSize.isNaN()) {
    return surroundingAgent.Throw('TypeError', 'SizeIsNaN');
  }

  // 6. Let intSize be ! ToIntegerOrInfinity(numSize).
  /* X */
  let _temp21 = ToIntegerOrInfinity(numSize);
  /* node:coverage ignore next */
  if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) _temp21 = skipDebugger(_temp21);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(numSize) returned an abrupt completion", {
    cause: _temp21
  });
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  const intSize = _temp21;

  // 7. Let has be ? Get(obj, "has").
  /* ReturnIfAbrupt */
  let _temp22 = yield* Get(obj, Value('has'));
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) return _temp22;
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  const has = _temp22;

  // 8. If IsCallable(has) is false, throw a TypeError exception.
  if (!IsCallable(has)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', has);
  }

  // 9. Let keys be ? Get(obj, "keys").
  /* ReturnIfAbrupt */
  let _temp23 = yield* Get(obj, Value('keys'));
  /* node:coverage ignore next */
  if (_temp23 instanceof AbruptCompletion) return _temp23;
  /* node:coverage ignore next */
  if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
  const keys = _temp23;

  // 10. If IsCallable(keys) is false, throw a TypeError exception.
  if (!IsCallable(keys)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', keys);
  }

  // 11. Return a new Set Record { [[Set]]: obj, [[Size]]: intSize, [[Has]]: has, [[Keys]]: keys }.
  const setRecord = {
    Set: obj,
    Size: intSize,
    Has: has,
    Keys: keys
  };
  return EnsureCompletion(setRecord);
}
GetSetRecord.section = 'https://tc39.es/ecma262/#sec-getsetrecord';
/** https://tc39.es/proposal-set-methods/#sec-getkeysiterator */
function* GetKeysIterator(setRec) {
  /* ReturnIfAbrupt */
  let _temp24 = yield* Call(setRec.Keys, setRec.Set);
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) return _temp24;
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  // 1. Let keysIter be ? Call(setRec.[[Keys]], setRec.[[Set]]).
  const keysIter = _temp24;

  // 2. If keysIter is not an Object, throw a TypeError exception.
  if (!(keysIter instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', keysIter);
  }

  // 3. Let nextMethod be ? Get(keysIter, "next").
  /* ReturnIfAbrupt */
  let _temp25 = yield* Get(keysIter, Value('next'));
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  const nextMethod = _temp25;

  // 4. If IsCallable(nextMethod) is false, throw a TypeError exception.
  if (!IsCallable(nextMethod)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', nextMethod);
  }

  // 5. Return a new Iterator Record { [[Iterator]]: keysIter, [[NextMethod]]: nextMethod, [[Done]]: false }.
  const iteratorRecord = {
    Iterator: keysIter,
    NextMethod: nextMethod,
    Done: Value.false
  };
  return EnsureCompletion(iteratorRecord);
}
GetKeysIterator.section = 'https://tc39.es/proposal-set-methods/#sec-getkeysiterator';
/** https://tc39.es/ecma262/#sec-setdatahas */
function SetDataHas(resultSetData, value) {
  // 1. For each element e of resultSetData, do
  for (const e of resultSetData) {
    // a. If e is not empty and SameValueZero(e, value) is true, return true.
    if (e !== undefined && SameValueZero(e, value) === Value.true) {
      return Value.true;
    }
  }

  // 2. Return false.
  return Value.false;
}
SetDataHas.section = 'https://tc39.es/ecma262/#sec-setdatahas';

function isSetObject(value) {
  return 'SetData' in value;
}
/** https://tc39.es/ecma262/#sec-set-iterable */
function* SetConstructor([iterable = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. Let set be ? OrdinaryCreateFromConstructor(NewTarget, "%Set.prototype%", « [[SetData]] »).
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(NewTarget, '%Set.prototype%', ['SetData']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const set = _temp;
  // 3. Set set.[[SetData]] to a new empty List.
  set.SetData = [];
  // 4. If iterable is either undefined or null, return set.
  if (iterable === Value.undefined || iterable === Value.null) {
    return set;
  }
  // 5. Let adder be ? Get(set, "add").
  /* ReturnIfAbrupt */
  let _temp2 = yield* Get(set, Value('add'));
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const adder = _temp2;
  // 6. If IsCallable(adder) is false, throw a TypeError exception.
  if (!IsCallable(adder)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', adder);
  }
  // 7. Let iteratorRecord be ? GetIterator(iterable).
  /* ReturnIfAbrupt */
  let _temp3 = yield* GetIterator(iterable, 'sync');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const iteratorRecord = _temp3;
  // 8. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp4 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // a. Let next be ? IteratorStepValue(iteratorRecord).
    const next = _temp4;
    // b. If next is false, return set.
    if (next === 'done') {
      return set;
    }
    // d. Let status be Call(adder, set, « next »).
    let status = yield* Call(adder, set, [next]);
    // e. IfAbruptCloseIterator(status, iteratorRecord).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (status instanceof AbruptCompletion) return skipDebugger(IteratorClose(iteratorRecord, status));
    /* node:coverage ignore next */
    if (status instanceof Completion) status = status.Value;
  }
}
SetConstructor.section = 'https://tc39.es/ecma262/#sec-set-iterable';
/** https://tc39.es/ecma262/#sec-get-set-@@species */
function Set_speciesGetter(_args, {
  thisValue
}) {
  // Return the this value.
  return thisValue;
}
Set_speciesGetter.section = 'https://tc39.es/ecma262/#sec-get-set-@@species';
function bootstrapSet(realmRec) {
  const setConstructor = bootstrapConstructor(realmRec, SetConstructor, 'Set', 0, realmRec.Intrinsics['%Set.prototype%'], [[wellKnownSymbols.species, [Set_speciesGetter]]]);
  realmRec.Intrinsics['%Set%'] = setConstructor;
}

/** https://tc39.es/ecma262/#sec-generator.prototype.next */
function* GeneratorProto_next([value = Value.undefined], {
  thisValue
}) {
  // 1. Let g be the this value.
  const g = thisValue;
  // 2. Return ? GeneratorResume(g, value, empty).
  return yield* GeneratorResume(g, value, undefined);
}
GeneratorProto_next.section = 'https://tc39.es/ecma262/#sec-generator.prototype.next';
/** https://tc39.es/ecma262/#sec-generator.prototype.return */
function* GeneratorProto_return([value = Value.undefined], {
  thisValue
}) {
  // 1. Let g be the this value.
  const g = thisValue;
  // 2. Let C be Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
  const C = new Completion({
    Type: 'return',
    Value: value,
    Target: undefined
  });
  // 3. Return ? GeneratorResumeAbrupt(g, C, empty).
  return yield* GeneratorResumeAbrupt(g, C, undefined);
}
GeneratorProto_return.section = 'https://tc39.es/ecma262/#sec-generator.prototype.return';
/** https://tc39.es/ecma262/#sec-generator.prototype.throw */
function* GeneratorProto_throw([exception = Value.undefined], {
  thisValue
}) {
  // 1. Let g be the this value.
  const g = thisValue;
  // 2. Let C be ThrowCompletion(exception).
  const C = ThrowCompletion(exception);
  // 3. Return ? GeneratorResumeAbrupt(g, C, empty).
  return yield* GeneratorResumeAbrupt(g, C, undefined);
}
GeneratorProto_throw.section = 'https://tc39.es/ecma262/#sec-generator.prototype.throw';
function bootstrapGeneratorFunctionPrototypePrototype(realmRec) {
  const generatorPrototype = bootstrapPrototype(realmRec, [['next', GeneratorProto_next, 1], ['return', GeneratorProto_return, 1], ['throw', GeneratorProto_throw, 1]], realmRec.Intrinsics['%Iterator.prototype%'], 'Generator');
  realmRec.Intrinsics['%GeneratorFunction.prototype.prototype%'] = generatorPrototype;
  realmRec.Intrinsics['%GeneratorPrototype%'] = realmRec.Intrinsics['%GeneratorFunction.prototype.prototype%'];

  // Used by `CreateListIteratorRecord`:
  /* X */
  let _temp = generatorPrototype.Get(Value('next'), generatorPrototype);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! generatorPrototype.Get(Value('next'), generatorPrototype) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  realmRec.Intrinsics['%GeneratorFunction.prototype.prototype.next%'] = _temp;
}

function bootstrapGeneratorFunctionPrototype(realmRec) {
  const generatorPrototype = realmRec.Intrinsics['%GeneratorFunction.prototype.prototype%'];
  const generator = bootstrapPrototype(realmRec, [['prototype', generatorPrototype, undefined, {
    Writable: Value.false
  }]], realmRec.Intrinsics['%Function.prototype%'], 'GeneratorFunction');
  /* X */
  let _temp = DefinePropertyOrThrow(generatorPrototype, Value('constructor'), _Descriptor({
    Value: generator,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(generatorPrototype, Value('constructor'), Descriptor({\n    Value: generator,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  realmRec.Intrinsics['%GeneratorFunction.prototype%'] = generator;
}

/** https://tc39.es/ecma262/#sec-generatorfunction */
function* GeneratorFunctionConstructor(args, {
  NewTarget
}) {
  // 1. Let C be the active function object.
  const C = surroundingAgent.activeFunctionObject;
  // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
  // 3. Return ? CreateDynamicFunction(C, NewTarget, generator, args).
  return yield* CreateDynamicFunction(C, NewTarget, 'generator', args);
}
GeneratorFunctionConstructor.section = 'https://tc39.es/ecma262/#sec-generatorfunction';
function bootstrapGeneratorFunction(realmRec) {
  const generator = realmRec.Intrinsics['%GeneratorFunction.prototype%'];
  const cons = bootstrapConstructor(realmRec, GeneratorFunctionConstructor, 'GeneratorFunction', 1, generator, []);
  /* X */
  let _temp = DefinePropertyOrThrow(cons, Value('prototype'), _Descriptor({
    Writable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(cons, Value('prototype'), Descriptor({\n    Writable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  /* X */
  let _temp2 = DefinePropertyOrThrow(generator, Value('constructor'), _Descriptor({
    Writable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(generator, Value('constructor'), Descriptor({\n    Writable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  realmRec.Intrinsics['%GeneratorFunction%'] = cons;
}

function bootstrapAsyncFunctionPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [], realmRec.Intrinsics['%Function.prototype%'], 'AsyncFunction');
  realmRec.Intrinsics['%AsyncFunction.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-async-function-constructor-arguments */
function* AsyncFunctionConstructor(args, {
  NewTarget
}) {
  // 1. Let C be the active function object.
  const C = surroundingAgent.activeFunctionObject;
  // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
  // 3. Return CreateDynamicFunction(C, NewTarget, async, args).
  return yield* CreateDynamicFunction(C, NewTarget, 'async', args);
}
AsyncFunctionConstructor.section = 'https://tc39.es/ecma262/#sec-async-function-constructor-arguments';
function bootstrapAsyncFunction(realmRec) {
  const cons = bootstrapConstructor(realmRec, AsyncFunctionConstructor, 'AsyncFunction', 1, realmRec.Intrinsics['%AsyncFunction.prototype%'], []);
  /* X */
  let _temp = cons.DefineOwnProperty(Value('prototype'), _Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! cons.DefineOwnProperty(Value('prototype'), Descriptor({\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  cons.Prototype = realmRec.Intrinsics['%Function%'];
  realmRec.Intrinsics['%AsyncFunction%'] = cons;
}

/** https://tc39.es/ecma262/#sec-asyncgenerator-prototype-next */
function* AsyncGeneratorPrototype_next([value = Value.undefined], {
  thisValue
}) {
  // 1. Let generator be the this value.
  const generator = thisValue;
  // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  /* X */
  let _temp = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const promiseCapability = _temp;
  // 3. Let result be AsyncGeneratorValidate(generator, empty).
  let result = AsyncGeneratorValidate(generator, undefined);
  // 4. IfAbruptRejectPromise(result, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (result instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (result instanceof Completion) result = result.Value;
  // 5. Let state be generator.[[AsyncGeneratorState]].
  const state = generator.AsyncGeneratorState;
  // 6. If state is completed, then
  if (state === 'completed') {
    /* X */
    let _temp2 = CreateIteratorResultObject(Value.undefined, Value.true);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! CreateIteratorResultObject(Value.undefined, Value.true) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // a. Let iteratorResult be ! CreateIteratorResultObject(undefined, true).
    const iteratorResult = _temp2;
    // b. Perform ! Call(promiseCapability.[[Resolve]], undefined, « iteratorResult »).
    /* X */
    let _temp3 = Call(promiseCapability.Resolve, Value.undefined, [iteratorResult]);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Resolve, Value.undefined, [iteratorResult]) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // c. Return promiseCapability.[[Promise]].
    return promiseCapability.Promise;
  }
  // 7. Let completion be NormalCompletion(value).
  const completion = NormalCompletion(value);
  // 8. Perform ! AsyncGeneratorEnqueue(generator, completion, promiseCapability).
  /* X */
  let _temp4 = AsyncGeneratorEnqueue(generator, completion, promiseCapability);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorEnqueue(generator, completion, promiseCapability) returned an abrupt completion", {
    cause: _temp4
  });
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 9. If state is either suspendedStart or suspendedYield, then
  if (state === 'suspendedStart' || state === 'suspendedYield') {
    /* X */
    let _temp5 = yield* AsyncGeneratorResume(generator, completion);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! yield* AsyncGeneratorResume(generator, completion) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  } else {
    // 10. Else,
    // a. Assert: state is either executing or awaiting-return.
    Assert(state === 'executing' || state === 'awaiting-return', "state === 'executing' || state === 'awaiting-return'");
  }
  // 11. Return promiseCapability.[[Promise]].
  return promiseCapability.Promise;
}
AsyncGeneratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-asyncgenerator-prototype-next';
/** https://tc39.es/ecma262/#sec-asyncgenerator-prototype-return */
function* AsyncGeneratorPrototype_return([value = Value.undefined], {
  thisValue
}) {
  // 1. Let generator be the this value.
  const generator = thisValue;
  // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  /* X */
  let _temp6 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const promiseCapability = _temp6;
  // 3. Let result be AsyncGeneratorValidate(generator, empty).
  let result = AsyncGeneratorValidate(generator, undefined);
  // 4. IfAbruptRejectPromise(result, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (result instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (result instanceof Completion) result = result.Value;
  // 5. Let completion be Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
  const completion = new Completion({
    Type: 'return',
    Value: value,
    Target: undefined
  });
  // 6. Perform ! AsyncGeneratorEnqueue(generator, completion, promiseCapability).
  /* X */
  let _temp7 = AsyncGeneratorEnqueue(generator, completion, promiseCapability);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorEnqueue(generator, completion, promiseCapability) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 7. Let state be generator.[[AsyncGeneratorState]].
  const state = generator.AsyncGeneratorState;
  // 8. If state is either suspendedStart or completed, then
  if (state === 'suspendedStart' || state === 'completed') {
    // a. Set generator.[[AsyncGeneratorState]] to awaiting-return.
    generator.AsyncGeneratorState = 'awaiting-return';
    // b. Perform ! AsyncGeneratorAwaitReturn(generator).
    /* X */
    let _temp8 = AsyncGeneratorAwaitReturn(generator);
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorAwaitReturn(generator) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  } else if (state === 'suspendedYield') {
    /* X */
    let _temp9 = yield* AsyncGeneratorResume(generator, completion);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! yield* AsyncGeneratorResume(generator, completion) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  } else {
    // 10. Else,
    // a. Assert: state is either executing or awaiting-return.
    Assert(state === 'executing' || state === 'awaiting-return', "state === 'executing' || state === 'awaiting-return'");
  }
  // 11. Return promiseCapability.[[Promise]].
  return promiseCapability.Promise;
}
AsyncGeneratorPrototype_return.section = 'https://tc39.es/ecma262/#sec-asyncgenerator-prototype-return';
/** https://tc39.es/ecma262/#sec-asyncgenerator-prototype-throw */
function* AsyncGeneratorPrototype_throw([exception = Value.undefined], {
  thisValue
}) {
  // 1. Let generator be the this value.
  const generator = thisValue;
  // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  /* X */
  let _temp10 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  const promiseCapability = _temp10;
  // 3. Let result be AsyncGeneratorValidate(generator, empty).
  let result = AsyncGeneratorValidate(generator, undefined);
  // 4. IfAbruptRejectPromise(result, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (result instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (result instanceof Completion) result = result.Value;
  // 5. Let state be generator.[[AsyncGeneratorState]].
  let state = generator.AsyncGeneratorState;
  // 6. If state is suspendedStart, then
  if (state === 'suspendedStart') {
    // a. Set generator.[[AsyncGeneratorState]] to completed.
    generator.AsyncGeneratorState = 'completed';
    // b. Set state to completed.
    state = 'completed';
  }
  // 7. If state is completed, then
  if (state === 'completed') {
    /* X */
    let _temp11 = Call(promiseCapability.Reject, Value.undefined, [exception]);
    /* node:coverage ignore next */
    if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [exception]) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    // b. Return promiseCapability.[[Promise]].
    return promiseCapability.Promise;
  }
  // 8. Let completion be ThrowCompletion(exception).
  const completion = ThrowCompletion(exception);
  // 9. Perform ! AsyncGeneratorEnqueue(generator, completion, promiseCapability).
  /* X */
  let _temp12 = AsyncGeneratorEnqueue(generator, completion, promiseCapability);
  /* node:coverage ignore next */
  if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! AsyncGeneratorEnqueue(generator, completion, promiseCapability) returned an abrupt completion", {
    cause: _temp12
  });
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  // 10. If state is suspendedYield, then
  if (state === 'suspendedYield') {
    /* X */
    let _temp13 = yield* AsyncGeneratorResume(generator, completion);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! yield* AsyncGeneratorResume(generator, completion) returned an abrupt completion", {
      cause: _temp13
    });
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  } else {
    // 11. Else,
    // a. Assert: state is either executing or awaiting-return.
    Assert(state === 'executing' || state === 'awaiting-return', "state === 'executing' || state === 'awaiting-return'");
  }
  // 12. Return promiseCapability.[[Promise]].
  return promiseCapability.Promise;
}
AsyncGeneratorPrototype_throw.section = 'https://tc39.es/ecma262/#sec-asyncgenerator-prototype-throw';
function bootstrapAsyncGeneratorFunctionPrototypePrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', AsyncGeneratorPrototype_next, 1], ['return', AsyncGeneratorPrototype_return, 1], ['throw', AsyncGeneratorPrototype_throw, 1]], realmRec.Intrinsics['%AsyncIteratorPrototype%'], 'AsyncGenerator');
  realmRec.Intrinsics['%AsyncGeneratorFunction.prototype.prototype%'] = proto;
}

function bootstrapAsyncGeneratorFunctionPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['prototype', realmRec.Intrinsics['%AsyncGeneratorFunction.prototype.prototype%'], undefined, {
    Writable: Value.false
  }]], realmRec.Intrinsics['%Function.prototype%'], 'AsyncGeneratorFunction');
  /* X */
  let _temp = realmRec.Intrinsics['%AsyncGeneratorFunction.prototype.prototype%'].DefineOwnProperty(Value('constructor'), _Descriptor({
    Value: proto,
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! (realmRec.Intrinsics['%AsyncGeneratorFunction.prototype.prototype%']).DefineOwnProperty(Value('constructor'), Descriptor({\n    Value: proto,\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  realmRec.Intrinsics['%AsyncGeneratorFunction.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-asyncgeneratorfunction */
function* AsyncGeneratorFunctionConstructor(args, {
  NewTarget
}) {
  // 1. Let C be the active function object.
  const C = surroundingAgent.activeFunctionObject;
  // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
  // 3. Return ? CreateDynamicFunction(C, NewTarget, asyncGenerator, args).
  return yield* CreateDynamicFunction(C, NewTarget, 'asyncGenerator', args);
}
AsyncGeneratorFunctionConstructor.section = 'https://tc39.es/ecma262/#sec-asyncgeneratorfunction';
function bootstrapAsyncGeneratorFunction(realmRec) {
  const cons = bootstrapConstructor(realmRec, AsyncGeneratorFunctionConstructor, 'AsyncGeneratorFunction', 1, realmRec.Intrinsics['%AsyncGeneratorFunction.prototype%'], []);
  /* X */
  let _temp = cons.DefineOwnProperty(Value('prototype'), _Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! cons.DefineOwnProperty(Value('prototype'), Descriptor({\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  /* X */
  let _temp2 = realmRec.Intrinsics['%AsyncGeneratorFunction.prototype%'].DefineOwnProperty(Value('constructor'), _Descriptor({
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! (realmRec.Intrinsics['%AsyncGeneratorFunction.prototype%']).DefineOwnProperty(Value('constructor'), Descriptor({\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  cons.Prototype = realmRec.Intrinsics['%Function%'];
  realmRec.Intrinsics['%AsyncGeneratorFunction%'] = cons;
}

/** https://tc39.es/ecma262/#sec-%asyncfromsynciteratorprototype%.next */
function* AsyncFromSyncIteratorPrototype_next([value], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Assert: Type(O) is Object and O has a [[SyncIteratorRecord]] internal slot.
  Assert(O instanceof ObjectValue && 'SyncIteratorRecord' in O, "O instanceof ObjectValue && 'SyncIteratorRecord' in O");
  // 3. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  /* X */
  let _temp = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const promiseCapability = _temp;
  // 4. Let syncIteratorRecord be O.[[SyncIteratorRecord]].
  const syncIteratorRecord = O.SyncIteratorRecord;
  // 5. If value is present, then
  let result;
  if (value !== undefined) {
    // a. Let result be IteratorNext(syncIteratorRecord, value).
    result = yield* IteratorNext(syncIteratorRecord, value);
  } else {
    // 6. Else,
    // a. Let result be IteratorNext(syncIteratorRecord).
    result = yield* IteratorNext(syncIteratorRecord);
  }
  // 7. IfAbruptRejectPromise(result, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (result instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (result instanceof Completion) result = result.Value;
  // 8. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, true).
  /* X */
  let _temp2 = AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, Value.true);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, Value.true) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  return _temp2;
}
AsyncFromSyncIteratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-%asyncfromsynciteratorprototype%.next';
/** https://tc39.es/ecma262/#sec-%asyncfromsynciteratorprototype%.return */
function* AsyncFromSyncIteratorPrototype_return([value], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Assert: Type(O) is Object and O has a [[SyncIteratorRecord]] internal slot.
  Assert(O instanceof ObjectValue && 'SyncIteratorRecord' in O, "O instanceof ObjectValue && 'SyncIteratorRecord' in O");
  // 3. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  /* X */
  let _temp3 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp3
  });
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const promiseCapability = _temp3;
  // 4. Let syncIterator be O.[[SyncIteratorRecord]].[[Iterator]].
  const syncIteratorRecord = O.SyncIteratorRecord;
  const syncIterator = syncIteratorRecord.Iterator;
  // 5. Let return be GetMethod(syncIterator, "return").
  let ret = yield* GetMethod(syncIterator, Value('return'));
  // 6. IfAbruptRejectPromise(return, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (ret instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [ret.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (ret instanceof Completion) ret = ret.Value;
  // 7. If return is undefined, then
  if (ret === Value.undefined) {
    // a. Let iteratorResult be CreateIteratorResultObject(value, true).
    const iteratorResult = CreateIteratorResultObject(value, Value.true);
    // b. Perform ! Call(promiseCapability.[[Resolve]], undefined, « iteratorResult »).
    /* X */
    let _temp4 = Call(promiseCapability.Resolve, Value.undefined, [iteratorResult]);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Resolve, Value.undefined, [iteratorResult]) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // c. Return promiseCapability.[[Promise]].
    return promiseCapability.Promise;
  }
  // 8. If value is present, then
  let result;
  if (value !== undefined) {
    // a. Let result be Call(return, syncIterator, « value »).
    result = yield* Call(ret, syncIterator, [value]);
  } else {
    // 9. Else,
    // a. Let result be Call(return, syncIterator).
    result = yield* Call(ret, syncIterator);
  }
  // 10. IfAbruptRejectPromise(result, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (result instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (result instanceof Completion) result = result.Value;
  // 11. If result is not an Object, then
  if (!(result instanceof ObjectValue)) {
    /* X */
    let _temp5 = Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'NotAnObject', result).Value]);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [\n      surroundingAgent.Throw('TypeError', 'NotAnObject', result).Value,\n    ]) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // b. Return promiseCapability.[[Promise]].
    return promiseCapability.Promise;
  }
  // 12. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, false).
  /* X */
  let _temp6 = AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, Value.false);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, Value.false) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  return _temp6;
}
AsyncFromSyncIteratorPrototype_return.section = 'https://tc39.es/ecma262/#sec-%asyncfromsynciteratorprototype%.return';
/** https://tc39.es/ecma262/#sec-%asyncfromsynciteratorprototype%.throw */
function* AsyncFromSyncIteratorPrototype_throw([value], {
  thisValue
}) {
  // 1. Let O be this value.
  const O = thisValue;
  // 2. Assert: Type(O) is Object and O has a [[SyncIteratorRecord]] internal slot.
  Assert(O instanceof ObjectValue && 'SyncIteratorRecord' in O, "O instanceof ObjectValue && 'SyncIteratorRecord' in O");
  // 3. Let promiseCapability be ! NewPromiseCapability(%Promise%).
  /* X */
  let _temp7 = NewPromiseCapability(surroundingAgent.intrinsic('%Promise%'));
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! NewPromiseCapability(surroundingAgent.intrinsic('%Promise%')) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const promiseCapability = _temp7;
  // 4. Let syncIterator be O.[[SyncIteratorRecord]].[[Iterator]].
  const syncIteratorRecord = O.SyncIteratorRecord;
  const syncIterator = syncIteratorRecord.Iterator;
  // 5. Let throw be GetMethod(syncIterator, "throw").
  let thr = yield* GetMethod(syncIterator, Value('throw'));
  // 6. IfAbruptRejectPromise(throw, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (thr instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [thr.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (thr instanceof Completion) thr = thr.Value;
  // 7. If throw is undefined, then
  if (thr === Value.undefined) {
    const closeCompletion = NormalCompletion(undefined);
    let result = yield* IteratorClose(syncIteratorRecord, closeCompletion);
    /* IfAbruptRejectPromise */
    /* node:coverage disable */
    if (result instanceof AbruptCompletion) {
      const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
      if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
      return promiseCapability.Promise;
    }
    if (result instanceof Completion) result = result.Value;
    /* node:coverage enable */
    /* X */
    let _temp8 = Call(promiseCapability.Reject, Value.undefined, [
    // TODO: error message should be no throw method
    surroundingAgent.Throw('TypeError', 'NotAnObject', value).Value]);
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [\n      // TODO: error message should be no throw method\n      surroundingAgent.Throw('TypeError', 'NotAnObject', value).Value,\n    ]) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    return promiseCapability.Promise;
  }
  // 8. If value is present, then
  let result;
  if (value !== undefined) {
    // a. Let result be Call(throw, syncIterator, « value »).
    result = yield* Call(thr, syncIterator, [value]);
  } else {
    // 9. Else,
    // a. Let result be Call(throw, syncIterator).
    result = yield* Call(thr, syncIterator);
  }
  // 10. IfAbruptRejectPromise(result, promiseCapability).
  /* IfAbruptRejectPromise */
  /* node:coverage disable */
  if (result instanceof AbruptCompletion) {
    const callRejectCompletion = skipDebugger(Call(promiseCapability.Reject, Value.undefined, [result.Value]));
    if (callRejectCompletion instanceof AbruptCompletion) return callRejectCompletion;
    return promiseCapability.Promise;
  }
  if (result instanceof Completion) result = result.Value;
  // 11. If Type(result) is not Object, then
  if (!(result instanceof ObjectValue)) {
    /* X */
    let _temp9 = Call(promiseCapability.Reject, Value.undefined, [surroundingAgent.Throw('TypeError', 'NotAnObject', result).Value]);
    /* node:coverage ignore next */
    if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! Call(promiseCapability.Reject, Value.undefined, [\n      surroundingAgent.Throw('TypeError', 'NotAnObject', result).Value,\n    ]) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    // b. Return promiseCapability.[[Promise]].
    return promiseCapability.Promise;
  }
  // 12. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, true).
  /* X */
  let _temp10 = AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, Value.true);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! AsyncFromSyncIteratorContinuation(result, promiseCapability, syncIteratorRecord, Value.true) returned an abrupt completion", {
    cause: _temp10
  });
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  return _temp10;
}
AsyncFromSyncIteratorPrototype_throw.section = 'https://tc39.es/ecma262/#sec-%asyncfromsynciteratorprototype%.throw';
function bootstrapAsyncFromSyncIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', AsyncFromSyncIteratorPrototype_next, 0], ['return', AsyncFromSyncIteratorPrototype_return, 0], ['throw', AsyncFromSyncIteratorPrototype_throw, 0]], realmRec.Intrinsics['%AsyncIteratorPrototype%']);
  realmRec.Intrinsics['%AsyncFromSyncIteratorPrototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-arraybuffer-length */
function* ArrayBufferConstructor([length = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. Let byteLength be ? ToIndex(length).
  /* ReturnIfAbrupt */
  let _temp = yield* ToIndex(length);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const byteLength = _temp;
  // 3. Return ? AllocateArrayBuffer(NewTarget, byteLength).
  return yield* AllocateArrayBuffer(NewTarget, byteLength);
}
ArrayBufferConstructor.section = 'https://tc39.es/ecma262/#sec-arraybuffer-length';
/** https://tc39.es/ecma262/#sec-arraybuffer.isview */
function ArrayBuffer_isView([arg = Value.undefined]) {
  // 1. If Type(arg) is not Object, return false.
  if (!(arg instanceof ObjectValue)) {
    return Value.false;
  }
  // 2. If arg has a [[ViewedArrayBuffer]] internal slot, return true.
  if ('ViewedArrayBuffer' in arg) {
    return Value.true;
  }
  // 3. Return false.
  return Value.false;
}
ArrayBuffer_isView.section = 'https://tc39.es/ecma262/#sec-arraybuffer.isview';
/** https://tc39.es/ecma262/#sec-get-arraybuffer-@@species */
function ArrayBuffer_species(_, {
  thisValue
}) {
  return thisValue;
}
ArrayBuffer_species.section = 'https://tc39.es/ecma262/#sec-get-arraybuffer-@@species';
function bootstrapArrayBuffer(realmRec) {
  const c = bootstrapConstructor(realmRec, ArrayBufferConstructor, 'ArrayBuffer', 1, realmRec.Intrinsics['%ArrayBuffer.prototype%'], [['isView', ArrayBuffer_isView, 1], [wellKnownSymbols.species, [ArrayBuffer_species]]]);
  realmRec.Intrinsics['%ArrayBuffer%'] = c;
}

/** https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength */
function ArrayBufferProto_byteLength(_args, {
  thisValue
}) {
  // 1. Let O be this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[ArrayBufferData]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(O, 'ArrayBufferData');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. If IsSharedArrayBuffer(O) is true, throw a TypeError exception.
  if (IsSharedArrayBuffer() === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferShared');
  }
  // 4. If IsDetachedBuffer(O) is true, return +0𝔽.
  if (IsDetachedBuffer(O) === Value.true) {
    return F(0);
  }
  // 5. Let length be O.[[ArrayBufferByteLength]].
  const length = O.ArrayBufferByteLength;
  // 6. Return length.
  return F(length);
}
ArrayBufferProto_byteLength.section = 'https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength';
/** https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice */
function* ArrayBufferProto_slice([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[ArrayBufferData]]).
  /* ReturnIfAbrupt */
  let _temp2 = RequireInternalSlot(O, 'ArrayBufferData');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 3. If IsSharedArrayBuffer(O) is true, throw a TypeError exception.
  if (IsSharedArrayBuffer() === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferShared');
  }
  // 4. If IsDetachedBuffer(O) is true, throw a TypeError exception.
  if (IsDetachedBuffer(O) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }
  // 5. Let len be O.[[ArrayBufferByteLength]].
  const len = O.ArrayBufferByteLength;
  // 6. Let relativeStart be ? ToIntegerOrInfinity(start).
  /* ReturnIfAbrupt */
  let _temp3 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const relativeStart = _temp3;
  let first;
  // 7. If relativeStart < 0, let first be max((len + relativeStart), 0); else let first be min(relativeStart, len).
  if (relativeStart < 0) {
    first = Math.max(len + relativeStart, 0);
  } else {
    first = Math.min(relativeStart, len);
  }
  let relativeEnd;
  // 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToIntegerOrInfinity(end).
  if (end === Value.undefined) {
    relativeEnd = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp4 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    relativeEnd = _temp4;
  }
  let final;
  // 9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
  if (relativeEnd < 0) {
    final = Math.max(len + relativeEnd, 0);
  } else {
    final = Math.min(relativeEnd, len);
  }
  // 10. Let newLen be max(final - first, 0).
  const newLen = Math.max(final - first, 0);
  // 11. Let ctor be ? SpeciesConstructor(O, %ArrayBuffer%).
  /* ReturnIfAbrupt */
  let _temp5 = yield* SpeciesConstructor(O, surroundingAgent.intrinsic('%ArrayBuffer%'));
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const ctor = _temp5;
  // 12. Let new be ? Construct(ctor, « newLen »).
  /* ReturnIfAbrupt */
  let _temp6 = yield* Construct(ctor, [F(newLen)]);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const newO = _temp6;
  // 13. Perform ? RequireInternalSlot(new, [[ArrayBufferData]]).
  /* ReturnIfAbrupt */
  let _temp7 = RequireInternalSlot(newO, 'ArrayBufferData');
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 14. If IsSharedArrayBuffer(new) is true, throw a TypeError exception.
  if (IsSharedArrayBuffer() === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferShared');
  }
  // 15. If IsDetachedBuffer(new) is true, throw a TypeError exception.
  if (IsDetachedBuffer(newO) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }
  // 16. If SameValue(new, O) is true, throw a TypeError exception.
  if (SameValue(newO, O) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'SubclassSameValue', newO);
  }
  // 17. If new.[[ArrayBufferByteLength]] < newLen, throw a TypeError exception.
  if (newO.ArrayBufferByteLength < newLen) {
    return surroundingAgent.Throw('TypeError', 'SubclassLengthTooSmall', newO);
  }
  // 18. NOTE: Side-effects of the above steps may have detached O.
  // 19. If IsDetachedBuffer(O) is true, throw a TypeError exception.
  if (IsDetachedBuffer(O) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }
  // 20. Let fromBuf be O.[[ArrayBufferData]].
  const fromBuf = O.ArrayBufferData;
  // 21. Let toBuf be new.[[ArrayBufferData]].
  const toBuf = newO.ArrayBufferData;
  // 22. Perform CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen).
  CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen);
  // 23. Return new.
  return newO;
}
ArrayBufferProto_slice.section = 'https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice';
function bootstrapArrayBufferPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['byteLength', [ArrayBufferProto_byteLength]], ['slice', ArrayBufferProto_slice, 2]], realmRec.Intrinsics['%Object.prototype%'], 'ArrayBuffer');
  realmRec.Intrinsics['%ArrayBuffer.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-eval-x */
function* Eval([x = Value.undefined]) {
  // 1. Assert: The execution context stack has at least two elements.
  Assert(surroundingAgent.executionContextStack.length >= 2, "surroundingAgent.executionContextStack.length >= 2");
  // 2. Let callerContext be the second to top element of the execution context stack.
  const callerContext = surroundingAgent.executionContextStack[surroundingAgent.executionContextStack.length - 2];
  // 3. Let callerRealm be callerContext's Realm.
  const callerRealm = callerContext.Realm;
  // 4. Return ? PerformEval(x, callerRealm, false, false).
  return yield* PerformEval(x, callerRealm, false, false);
}
Eval.section = 'https://tc39.es/ecma262/#sec-eval-x';
function bootstrapEval(realmRec) {
  realmRec.Intrinsics['%eval%'] = CreateBuiltinFunction(Eval, 1, Value('eval'), [], realmRec);
}

/** https://tc39.es/ecma262/#sec-isfinite-number */
function* IsFinite([number = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp = yield* ToNumber(number);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let num be ? ToNumber(number).
  const num = _temp;
  // 2. If num is NaN, +∞, or -∞, return false.
  if (num.isNaN() || num.isInfinity()) {
    return Value.false;
  }
  // 3. Otherwise, return true.
  return Value.true;
}
IsFinite.section = 'https://tc39.es/ecma262/#sec-isfinite-number';
function bootstrapIsFinite(realmRec) {
  realmRec.Intrinsics['%isFinite%'] = CreateBuiltinFunction(IsFinite, 1, Value('isFinite'), [], realmRec);
}

/** https://tc39.es/ecma262/#sec-isnan-number */
function* IsNaN([number = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp = yield* ToNumber(number);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let num be ? ToNumber(number).
  const num = _temp;
  // 2. If num is NaN, return true.
  if (num.isNaN()) {
    return Value.true;
  }
  // 3. Otherwise, return false.
  return Value.false;
}
IsNaN.section = 'https://tc39.es/ecma262/#sec-isnan-number';
function bootstrapIsNaN(realmRec) {
  realmRec.Intrinsics['%isNaN%'] = CreateBuiltinFunction(IsNaN, 1, Value('isNaN'), [], realmRec);
}

/** https://tc39.es/ecma262/#sec-parsefloat-string */
function* ParseFloat([string = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp = yield* ToString(string);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 1. Let inputString be ? ToString(string).
  const inputString = _temp;
  // 2. Let trimmedString be ! TrimString(inputString, start).
  /* X */
  let _temp2 = TrimString(inputString, 'start');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! TrimString(inputString, 'start') returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const trimmedString = _temp2.stringValue();
  // 3. If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral (see 7.1.4.1), return NaN.
  // 4. Let numberString be the longest prefix of trimmedString, which might be trimmedString itself, that satisfies the syntax of a StrDecimalLiteral.
  // 5. Let mathFloat be MV of numberString.
  // 6. If mathFloat = 0ℝ, then
  //   a. If the first code unit of trimmedString is the code unit 0x002D (HYPHEN-MINUS), return -0.
  //   b. Return +0.
  // 7. Return the Number value for mathFloat.
  let numberString = trimmedString;
  if (/^[+-]/.test(numberString)) {
    numberString = numberString.slice(1);
  }
  const multiplier = trimmedString.startsWith('-') ? -1 : 1;
  if (numberString.startsWith('Infinity')) {
    return F(Infinity * multiplier);
  }
  let index = 0;
  done: {
    // eslint-disable-line no-labels
    // Eat leading zeros
    while (numberString[index] === '0') {
      index += 1;
      if (index === numberString.length) {
        return F(0 * multiplier);
      }
    }
    // Eat integer part
    if (numberString[index] !== '.') {
      while (/[0-9]/.test(numberString[index])) {
        index += 1;
      }
    }
    // Eat fractional part
    if (numberString[index] === '.') {
      if (!/[0-9eE]/.test(numberString[index + 1])) {
        break done; // eslint-disable-line no-labels
      }
      index += 1;
      while (/[0-9]/.test(numberString[index])) {
        index += 1;
      }
    }
    // Eat exponent part
    if (numberString[index] === 'e' || numberString[index] === 'E') {
      if (!/[-+0-9]/.test(numberString[index + 1])) {
        break done; // eslint-disable-line no-labels
      }
      index += 1;
      if (numberString[index] === '-' || numberString[index] === '+') {
        index += 1;
      }
      while (/[0-9]/.test(numberString[index])) {
        index += 1;
      }
    }
  }
  return F(parseFloat(numberString.slice(0, index)) * multiplier);
}
ParseFloat.section = 'https://tc39.es/ecma262/#sec-parsefloat-string';
function bootstrapParseFloat(realmRec) {
  realmRec.Intrinsics['%parseFloat%'] = CreateBuiltinFunction(ParseFloat, 1, Value('parseFloat'), [], realmRec);
}

function digitToNumber(_digit) {
  let digit = _digit.charCodeAt(0);
  if (digit < 0x30 /* 0 */) {
    return NaN;
  }
  if (digit <= 0x39 /* 9 */) {
    return digit - 0x30;
  }
  // Convert to lower case.
  digit &= -33; // eslint-disable-line no-bitwise
  if (digit < 0x41 /* A */) {
    return NaN;
  }
  if (digit <= 0x5a /* Z */) {
    return digit - 0x41 /* A */ + 10;
  }
  return NaN;
}
function stringToRadixNumber(str, R) {
  let num = 0;
  for (let i = 0; i < str.length; i += 1) {
    const power = str.length - i - 1;
    const multiplier = R ** power;
    const dig = digitToNumber(str[i]);
    Assert(!Number.isNaN(dig) && dig < R, "!Number.isNaN(dig) && dig < R");
    num += dig * multiplier;
  }
  return num;
}
function searchNotRadixDigit(str, R) {
  for (let i = 0; i < str.length; i += 1) {
    const num = digitToNumber(str[i]);
    if (Number.isNaN(num) || num >= R) {
      return i;
    }
  }
  return str.length;
}

/** https://tc39.es/ecma262/#sec-parseint-string-radix */
function* ParseInt([string = Value.undefined, radix = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp = yield* ToString(string);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const inputString = _temp;
  /* X */
  let _temp2 = TrimString(inputString, 'start');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! TrimString(inputString, 'start') returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  let S = _temp2.stringValue();
  let sign = 1;
  if (S !== '' && S[0] === '\x2D') {
    sign = -1;
  }
  if (S !== '' && (S[0] === '\x2B' || S[0] === '\x2D')) {
    S = S.slice(1);
  }
  /* ReturnIfAbrupt */
  let _temp3 = yield* ToInt32(radix);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  let R$1 = R(_temp3);
  let stripPrefix = true;
  if (R$1 !== 0) {
    if (R$1 < 2 || R$1 > 36) {
      return F(NaN);
    }
    if (R$1 !== 16) {
      stripPrefix = false;
    }
  } else {
    R$1 = 10;
  }
  if (stripPrefix === true) {
    if (S.length >= 2 && (S.startsWith('0x') || S.startsWith('0X'))) {
      S = S.slice(2);
      R$1 = 16;
    }
  }
  const Z = S.slice(0, searchNotRadixDigit(S, R$1));
  if (Z === '') {
    return F(NaN);
  }
  const mathInt = stringToRadixNumber(Z, R$1);
  if (mathInt === 0) {
    if (sign === -1) {
      return F(-0);
    }
    return F(0);
  }
  const number = mathInt;
  return F(sign * number);
}
ParseInt.section = 'https://tc39.es/ecma262/#sec-parseint-string-radix';
function bootstrapParseInt(realmRec) {
  realmRec.Intrinsics['%parseInt%'] = CreateBuiltinFunction(ParseInt, 2, Value('parseInt'), [], realmRec);
}

function utf8Encode(utf) {
  if (utf <= 0x7F) {
    return [utf];
  }
  if (utf <= 0x07FF) {
    return [utf >> 6 & 0x1F | 0xC0, utf >> 0 & 0x3F | 0x80];
  }
  if (utf <= 0xFFFF) {
    return [utf >> 12 & 0x0F | 0xE0, utf >> 6 & 0x3F | 0x80, utf >> 0 & 0x3F | 0x80];
  }
  if (utf <= 0x10FFFF) {
    return [utf >> 18 & 0x07 | 0xF0, utf >> 12 & 0x3F | 0x80, utf >> 6 & 0x3F | 0x80, utf >> 0 & 0x3F | 0x80];
  }
  return null;
}
function utf8Decode(octets) {
  const b0 = octets[0];
  if (b0 <= 0x7F) {
    return b0;
  }
  if (b0 < 0xC2 || b0 > 0xF4) {
    return null;
  }
  const b1 = octets[1];
  switch (b0) {
    case 0xE0:
      if (b1 < 0xA0 || b1 > 0xBF) {
        return null;
      }
      break;
    case 0xED:
      if (b1 < 0x80 || b1 > 0x9F) {
        return null;
      }
      break;
    case 0xF0:
      if (b1 < 0x90 || b1 > 0xBF) {
        return null;
      }
      break;
    case 0xF4:
      if (b1 < 0x80 || b1 > 0x8F) {
        return null;
      }
      break;
    default:
      if (b1 < 0x80 || b1 > 0xBF) {
        return null;
      }
      break;
  }
  if (b0 <= 0xDF) {
    return (b0 & 0x1F) << 6 | b0 & 0x3F;
  }
  const b2 = octets[2];
  if (b2 < 0x80 || b2 > 0xBF) {
    return null;
  }
  if (b0 <= 0xEF) {
    return (b0 & 0x0F) << 12 | (b1 & 0x3F) << 6 | b2 & 0x3F;
  }
  const b3 = octets[3];
  if (b3 < 0x80 || b3 > 0xBF) {
    return null;
  }
  return (b0 & 0x07) << 18 | (b1 & 0x3F) << 12 | (b2 & 0x3F) << 6 | b3 & 0x3F;
}
const uriReserved = ';/?:@&=+$,';
const uriAlpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
const uriMark = '-_.!~*\'()';
const DecimalDigit = '0123456789';
const uriUnescaped = uriAlpha + DecimalDigit + uriMark;

/** https://tc39.es/ecma262/#sec-encode */
function Encode(_string, unescapedSet) {
  const string = _string.stringValue();
  // 1. Let strLen be the number of code units in string.
  const strLen = string.length;
  // 2. Let R be the empty String.
  let R = '';
  // 3. Let k be 0.
  let k = 0;
  // 4. Repeat,
  while (true) {
    // a. If k equals strLen, return R.
    if (k === strLen) {
      return Value(R);
    }
    // b. Let C be the code unit at index k within string.
    const C = string[k];
    // c. If C is in unescapedSet, then
    if (unescapedSet.includes(C)) {
      // i. Set k to k + 1.
      k += 1;
      // ii. Set R to the string-concatenation of the previous value of R and C.
      R = `${R}${C}`;
    } else {
      /* X */
      let _temp = CodePointAt(string, k);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! CodePointAt(string, k) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
      // d. Else,
      // i. Let cp be ! CodePointAt(string, k).
      const cp = _temp;
      // ii. If cp.[[IsUnpairedSurrogate]] is true, throw a URIError exception.
      if (cp.IsUnpairedSurrogate) {
        return surroundingAgent.Throw('URIError', 'URIMalformed');
      }
      // iii. Set k to k + cp.[[CodeUnitCount]].
      k += cp.CodeUnitCount;
      // iv. Let Octets be the List of octets resulting by applying the UTF-8 transformation to cp.[[CodePoint]].
      const Octets = utf8Encode(cp.CodePoint);
      // v. For each element octet of Octets in List order, do
      Octets.forEach(octet => {
        // 1. Set R to the string-concatenation of:
        //   * the previous value of R
        //   * "%"
        //   * the String representation of octet, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary
        R = `${R}%${octet.toString(16).toUpperCase().padStart(2, '0')}`;
      });
    }
  }
}
Encode.section = 'https://tc39.es/ecma262/#sec-encode';
/** https://tc39.es/ecma262/#sec-decode */
function Decode(_string, reservedSet) {
  const string = _string.stringValue();
  // 1. Let strLen be the number of code units in string.
  const strLen = string.length;
  // 2. Let R be the empty String.
  let R = '';
  // 3. Let k be 0.
  let k = 0;
  // 4. Repeat,
  while (true) {
    // a. If k equals strLen, return R.
    if (k === strLen) {
      return Value(R);
    }
    // b. Let C be the code unit at index k within string.
    const C = string[k];
    let S;
    // c. If C is not the code unit 0x0025 (PERCENT SIGN), then
    if (C !== '\u{0025}') {
      S = C;
    } else {
      // d. Else,
      // i. Let start be k.
      const start = k;
      // ii. If k + 2 is greater than or equal to strLen, throw a URIError exception.
      if (k + 2 >= strLen) {
        return surroundingAgent.Throw('URIError', 'URIMalformed');
      }
      // iii. If the code units at index (k + 1) and (k + 2) within string do not represent hexadecimal digits, throw a URIError exception.
      if (!isHexDigit(string[k + 1]) || !isHexDigit(string[k + 2])) {
        return surroundingAgent.Throw('URIError', 'URIMalformed');
      }
      // iv. Let B be the 8-bit value represented by the two hexadecimal digits at index (k + 1) and (k + 2).
      const B = Number.parseInt(string.slice(k + 1, k + 3), 16);
      // v. Set k to k + 2.
      k += 2;
      // vi. If the most significant bit in B is 0, then
      if ((B & 0b10000000) === 0) {
        // 1. Let C be the code unit whose value is B.
        const innerC = String.fromCharCode(B);
        // 2. If C is not in reservedSet, then
        if (!reservedSet.includes(C)) {
          // a. Let S be the String value containing only the code unit C.
          S = innerC;
        } else {
          // 3. Else,
          // a. Let S be the substring of string from index start to index k inclusive.
          S = string.slice(start, k + 1);
        }
      } else {
        // vii. Else,
        // 1. Assert: the most significant bit in B is 1.
        Assert(!!(B & 0b10000000), "!!(B & 0b10000000)");
        // 2. Let n be the smallest nonnegative integer such that (B << n) & 0x80 is equal to 0.
        let n = 0;
        while ((B << n & 0x80) !== 0) {
          n += 1;
          if (n > 4) {
            break;
          }
        }
        // 3. If n equals 1 or n is greater than 4, throw a URIError exception.
        if (n === 1 || n > 4) {
          return surroundingAgent.Throw('URIError', 'URIMalformed');
        }
        // 4. Let Octets be a List of 8-bit integers of size n.
        const Octets = [];
        // 5. Set Octets[0] to B.
        Octets[0] = B;
        // 6. If k + (3 × (n - 1)) is greater than or equal to strLen, throw a URIError exception.
        if (k + 3 * (n - 1) >= strLen) {
          return surroundingAgent.Throw('URIError', 'URIMalformed');
        }
        // 7. Let j be 1.
        let j = 1;
        // 8. Repeat, while j < n,
        while (j < n) {
          // a. Set k to k + 1.
          k += 1;
          // b. If the code unit at index k within string is not the code unit 0x0025 (PERCENT SIGN), throw a URIError exception.
          if (string[k] !== '\u{0025}') {
            return surroundingAgent.Throw('URIError', 'URIMalformed');
          }
          // c. If the code units at index (k + 1) and (k + 2) within string do not represent hexadecimal digits, throw a URIError exception.
          if (!isHexDigit(string[k + 1]) || !isHexDigit(string[k + 2])) {
            return surroundingAgent.Throw('URIError', 'URIMalformed');
          }
          // d. Let B be the 8-bit value represented by the two hexadecimal digits at index (k + 1) and (k + 2).
          const innerB = Number.parseInt(string.slice(k + 1, k + 3), 16);
          // e. If the two most significant bits in B are not 10, throw a URIError exception.
          if (innerB >> 6 !== 0b10) {
            return surroundingAgent.Throw('URIError', 'URIMalformed');
          }
          // f. Set k to k + 2.
          k += 2;
          // g. Set Octets[j] to B.
          Octets[j] = innerB;
          // h. Set j to j + 1.
          j += 1;
        }
        // 9. If Octets does not contain a valid UTF-8 encoding of a Unicode code point, throw a URIError exception.
        // 10. Let V be the value obtained by applying the UTF-8 transformation to Octets, that is, from a List of octets into a 21-bit value.
        const V = utf8Decode(Octets);
        if (V === null) {
          return surroundingAgent.Throw('URIError', 'URIMalformed');
        }
        // 11. Let S be the String value whose code units are, in order, the elements in UTF16Encoding(V).
        S = String.fromCodePoint(V);
      }
    }
    // e. Set R to the string-concatenation of the previous value of R and S.
    R = `${R}${S}`;
    // f. Set k to k + 1.
    k += 1;
  }
}
Decode.section = 'https://tc39.es/ecma262/#sec-decode';
/** https://tc39.es/ecma262/#sec-decodeuri-encodeduri */
function* decodeURI([encodedURI = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToString(encodedURI);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Let uriString be ? ToString(encodedURI).
  const uriString = _temp2;
  // 2. Let reservedURISet be a String containing one instance of each code unit valid in uriReserved plus "#".
  const reservedURISet = `${uriReserved}#`;
  // 3. Return ? Decode(uriString, reservedURISet).
  return Decode(uriString, reservedURISet);
}
decodeURI.section = 'https://tc39.es/ecma262/#sec-decodeuri-encodeduri';
/** https://tc39.es/ecma262/#sec-decodeuricomponent-encodeduricomponent */
function* decodeURIComponent([encodedURIComponent = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp3 = yield* ToString(encodedURIComponent);
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 1. Let componentString be ? ToString(encodedURIComponent).
  const componentString = _temp3;
  // 2. Let reservedURIComponentSet be the empty String.
  const reservedURIComponentSet = '';
  // 3. Return ? Decode(componentString, reservedURIComponentSet).
  return Decode(componentString, reservedURIComponentSet);
}
decodeURIComponent.section = 'https://tc39.es/ecma262/#sec-decodeuricomponent-encodeduricomponent';
/** https://tc39.es/ecma262/#sec-encodeuri-uri */
function* encodeURI([uri = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp4 = yield* ToString(uri);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 1. Let uriString be ? ToString(uri).
  const uriString = _temp4;
  // 2. Let unescapedURISet be a String containing one instance of each code unit valid in uriReserved and uriUnescaped plus "#".
  const unescapedURISet = `${uriReserved}${uriUnescaped}#`;
  // 3. Return ? Encode(uriString, unescapedURISet).
  return Encode(uriString, unescapedURISet);
}
encodeURI.section = 'https://tc39.es/ecma262/#sec-encodeuri-uri';
/** https://tc39.es/ecma262/#sec-encodeuricomponent-uricomponent */
function* encodeURIComponent([uriComponent = Value.undefined]) {
  /* ReturnIfAbrupt */
  let _temp5 = yield* ToString(uriComponent);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 1. Let componentString be ? ToString(uriComponent).
  const componentString = _temp5;
  // 2. Let unescapedURIComponentSet be a String containing one instance of each code unit valid in uriUnescaped.
  const unescapedURIComponentSet = uriUnescaped;
  // 3. Return ? Encode(componentString, unescapedURIComponentSet).
  return Encode(componentString, unescapedURIComponentSet);
}
encodeURIComponent.section = 'https://tc39.es/ecma262/#sec-encodeuricomponent-uricomponent';
function bootstrapURIHandling(realmRec) {
  [['decodeURI', decodeURI, 1], ['decodeURIComponent', decodeURIComponent, 1], ['encodeURI', encodeURI, 1], ['encodeURIComponent', encodeURIComponent, 1]].forEach(([name, f, length]) => {
    realmRec.Intrinsics[`%${name}%`] = CreateBuiltinFunction(f, length, Value(name), [], realmRec);
  });
}

/** https://tc39.es/ecma262/#sec-%throwtypeerror% */
function ThrowTypeError() {
  // 1. Throw a TypeError exception.
  return surroundingAgent.Throw('TypeError', 'StrictPoisonPill');
}
ThrowTypeError.section = 'https://tc39.es/ecma262/#sec-%throwtypeerror%';
function bootstrapThrowTypeError(realmRec) {
  /* X */
  let _temp = CreateBuiltinFunction(ThrowTypeError, 0, Value(''), [], realmRec);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! CreateBuiltinFunction(ThrowTypeError, 0, Value(''), [], realmRec) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const f = _temp;
  /* X */
  let _temp2 = SetIntegrityLevel(f, 'frozen');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! SetIntegrityLevel(f, 'frozen') returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  Assert(_temp2 === Value.true, "X(SetIntegrityLevel(f, 'frozen')) === Value.true");
  realmRec.Intrinsics['%ThrowTypeError%'] = f;
}

/** https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.buffer */
function TypedArrayProto_buffer(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[TypedArrayName]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(O, 'TypedArrayName');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Assert: O has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  // 4. Let buffer be O.[[ViewedArrayBuffer]].
  const buffer = O.ViewedArrayBuffer;
  // 5. Return buffer.
  return buffer;
}
TypedArrayProto_buffer.section = 'https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.buffer';
/** https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.bytelength */
function TypedArrayProto_byteLength(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[TypedArrayName]]).
  /* ReturnIfAbrupt */
  let _temp2 = RequireInternalSlot(O, 'TypedArrayName');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 3. Assert: O has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
  const size = TypedArrayByteLength(taRecord);
  return F(size);
}
TypedArrayProto_byteLength.section = 'https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.bytelength';
/** https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.byteoffset */
function TypedArrayProto_byteOffset(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[TypedArrayName]]).
  /* ReturnIfAbrupt */
  let _temp3 = RequireInternalSlot(O, 'TypedArrayName');
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 3. Assert: O has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return F(0);
  }
  const offset = O.ByteOffset;
  return F(offset);
}
TypedArrayProto_byteOffset.section = 'https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.byteoffset';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin */
function* TypedArrayProto_copyWithin([target = Value.undefined, start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp4 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  let taRecord = _temp4;
  let len = TypedArrayLength(taRecord);
  /* ReturnIfAbrupt */
  let _temp5 = yield* ToIntegerOrInfinity(target);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const relativeTarget = _temp5;
  let targetIndex;
  if (relativeTarget === -Infinity) {
    targetIndex = 0;
  } else if (relativeTarget < 0) {
    targetIndex = Math.max(len + relativeTarget, 0);
  } else {
    targetIndex = Math.min(relativeTarget, len);
  }
  /* ReturnIfAbrupt */
  let _temp6 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const relativeStart = _temp6;
  let startIndex;
  if (relativeStart === -Infinity) {
    startIndex = 0;
  } else if (relativeStart < 0) {
    startIndex = Math.max(len + relativeStart, 0);
  } else {
    startIndex = Math.min(relativeStart, len);
  }
  let relativeEnd;
  if (end === Value.undefined) {
    relativeEnd = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp7 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    relativeEnd = _temp7;
  }
  let endIndex;
  if (relativeEnd === -Infinity) {
    endIndex = 0;
  } else if (relativeEnd < 0) {
    endIndex = Math.max(len + relativeEnd, 0);
  } else {
    endIndex = Math.min(relativeEnd, len);
  }
  const count = Math.min(endIndex - startIndex, len - targetIndex);
  if (count > 0) {
    const buffer = O.ViewedArrayBuffer;
    taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
    if (IsTypedArrayOutOfBounds(taRecord)) {
      return surroundingAgent.Throw('TypeError', 'TypedArrayOOB');
    }
    len = TypedArrayLength(taRecord);
    const elementSize = TypedArrayElementSize(O);
    const byteOffset = O.ByteOffset;
    const bufferByteLimit = len * elementSize + byteOffset;
    let toByteIndex = targetIndex * elementSize + byteOffset;
    let fromByteIndex = startIndex * elementSize + byteOffset;
    let countBytes = count * elementSize;
    let direction;
    if (fromByteIndex < toByteIndex && toByteIndex < fromByteIndex + countBytes) {
      direction = -1;
      fromByteIndex = fromByteIndex + countBytes - 1;
      toByteIndex = toByteIndex + countBytes - 1;
    } else {
      direction = 1;
    }
    while (countBytes > 0) {
      if (fromByteIndex < bufferByteLimit && toByteIndex < bufferByteLimit) {
        const value = GetValueFromBuffer(buffer, fromByteIndex, 'Uint8');
        /* ReturnIfAbrupt */
        let _temp8 = yield* SetValueInBuffer(buffer, toByteIndex, 'Uint8', value);
        /* node:coverage ignore next */
        if (_temp8 instanceof AbruptCompletion) return _temp8;
        /* node:coverage ignore next */
        if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
        fromByteIndex += direction;
        toByteIndex += direction;
        countBytes -= 1;
      } else {
        countBytes = 0;
      }
    }
  }
  return O;
}
TypedArrayProto_copyWithin.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries */
function TypedArrayProto_entries(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? ValidateTypedArray(O).
  /* ReturnIfAbrupt */
  let _temp9 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  // 3. Return CreateArrayIterator(O, key+value).
  return CreateArrayIterator(O, 'key+value');
}
TypedArrayProto_entries.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill */
function* TypedArrayProto_fill([value = Value.undefined, start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp10 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  let taRecord = _temp10;
  let len = TypedArrayLength(taRecord);
  if (O.ContentType === 'BigInt') {
    /* ReturnIfAbrupt */
    let _temp11 = yield* ToBigInt(value);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) return _temp11;
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    value = _temp11;
  } else {
    /* ReturnIfAbrupt */
    let _temp12 = yield* ToNumber(value);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) return _temp12;
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    value = _temp12;
  }
  /* ReturnIfAbrupt */
  let _temp13 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  const relativeStart = _temp13;
  let startIndex;
  if (relativeStart === -Infinity) {
    startIndex = 0;
  } else if (relativeStart < 0) {
    startIndex = Math.max(len + relativeStart, 0);
  } else {
    startIndex = Math.min(relativeStart, len);
  }
  let relativeEnd;
  if (end === Value.undefined) {
    relativeEnd = len;
  } else {
    /* ReturnIfAbrupt */
    let _temp14 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) return _temp14;
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    relativeEnd = _temp14;
  }
  let endIndex;
  if (relativeEnd === -Infinity) {
    endIndex = 0;
  } else if (relativeEnd < 0) {
    endIndex = Math.max(len + relativeEnd, 0);
  } else {
    endIndex = Math.min(relativeEnd, len);
  }
  taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOOB');
  }
  len = TypedArrayLength(taRecord);
  endIndex = Math.min(endIndex, len);
  let k = startIndex;
  while (k < endIndex) {
    /* X */
    let _temp15 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp15 && typeof _temp15 === 'object' && 'next' in _temp15) _temp15 = skipDebugger(_temp15);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp15
    });
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    const Pk = _temp15;
    /* X */
    let _temp16 = Set$1(O, Pk, value, Value.true);
    /* node:coverage ignore next */
    if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! Set(O, Pk, value, Value.true) returned an abrupt completion", {
      cause: _temp16
    });
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    k += 1;
  }
  return O;
}
TypedArrayProto_fill.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter */
function* TypedArrayProto_filter([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp17 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  const taRecord = _temp17;
  const len = TypedArrayLength(taRecord);
  if (!IsCallable(callbackfn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }
  const kept = [];
  let captured = 0;
  let k = 0;
  while (k < len) {
    /* X */
    let _temp18 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp18
    });
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    const Pk = _temp18;
    /* X */
    let _temp19 = Get(O, Pk);
    /* node:coverage ignore next */
    if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! Get(O, Pk) returned an abrupt completion", {
      cause: _temp19
    });
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    const kValue = _temp19;
    /* ReturnIfAbrupt */
    let _temp20 = yield* Call(callbackfn, thisArg, [kValue, F(k), O]);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    const selected = ToBoolean(_temp20);
    if (selected === Value.true) {
      kept.push(kValue);
      captured += 1;
    }
    k += 1;
  }
  /* ReturnIfAbrupt */
  let _temp21 = yield* TypedArraySpeciesCreate(O, [F(captured)]);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  const A = _temp21;
  let n = 0;
  for (const e of kept) {
    /* X */
    let _temp23 = ToString(F(n));
    /* node:coverage ignore next */
    if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) _temp23 = skipDebugger(_temp23);
    /* node:coverage ignore next */
    if (_temp23 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
      cause: _temp23
    });
    /* node:coverage ignore next */
    if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
    /* X */
    let _temp22 = Set$1(A, _temp23, e, Value.true);
    /* node:coverage ignore next */
    if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) _temp22 = skipDebugger(_temp22);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) throw new Assert.Error("! Set(A, X(ToString(F(n))), e, Value.true) returned an abrupt completion", {
      cause: _temp22
    });
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    n += 1;
  }
  return A;
}
TypedArrayProto_filter.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys */
function TypedArrayProto_keys(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? ValidateTypedArray(O).
  /* ReturnIfAbrupt */
  let _temp24 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) return _temp24;
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  // 3. Return CreateArrayIterator(O, key).
  return CreateArrayIterator(O, 'key');
}
TypedArrayProto_keys.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys';
/** https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.length */
function TypedArrayProto_length(_args, {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp25 = RequireInternalSlot(O, 'TypedArrayName');
  /* node:coverage ignore next */
  if (_temp25 && typeof _temp25 === 'object' && 'next' in _temp25) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) return _temp25;
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return F(0);
  }
  const length = TypedArrayLength(taRecord);
  return F(length);
}
TypedArrayProto_length.section = 'https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.length';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.map */
function* TypedArrayProto_map([callbackfn = Value.undefined, thisArg = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp26 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp26 && typeof _temp26 === 'object' && 'next' in _temp26) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp26 instanceof AbruptCompletion) return _temp26;
  /* node:coverage ignore next */
  if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
  const taRecord = _temp26;
  const len = TypedArrayLength(taRecord);
  if (!IsCallable(callbackfn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }
  /* ReturnIfAbrupt */
  let _temp27 = yield* TypedArraySpeciesCreate(O, [F(len)]);
  /* node:coverage ignore next */
  if (_temp27 instanceof AbruptCompletion) return _temp27;
  /* node:coverage ignore next */
  if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
  const A = _temp27;
  let k = 0;
  while (k < len) {
    /* X */
    let _temp28 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) _temp28 = skipDebugger(_temp28);
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp28
    });
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    const Pk = _temp28;
    /* X */
    let _temp29 = Get(O, Pk);
    /* node:coverage ignore next */
    if (_temp29 && typeof _temp29 === 'object' && 'next' in _temp29) _temp29 = skipDebugger(_temp29);
    /* node:coverage ignore next */
    if (_temp29 instanceof AbruptCompletion) throw new Assert.Error("! Get(O, Pk) returned an abrupt completion", {
      cause: _temp29
    });
    /* node:coverage ignore next */
    if (_temp29 instanceof Completion) _temp29 = _temp29.Value;
    const kValue = _temp29;
    /* ReturnIfAbrupt */
    let _temp30 = yield* Call(callbackfn, thisArg, [kValue, F(k), O]);
    /* node:coverage ignore next */
    if (_temp30 instanceof AbruptCompletion) return _temp30;
    /* node:coverage ignore next */
    if (_temp30 instanceof Completion) _temp30 = _temp30.Value;
    const mappedValue = _temp30;
    /* X */
    let _temp31 = Set$1(A, Pk, mappedValue, Value.true);
    /* node:coverage ignore next */
    if (_temp31 && typeof _temp31 === 'object' && 'next' in _temp31) _temp31 = skipDebugger(_temp31);
    /* node:coverage ignore next */
    if (_temp31 instanceof AbruptCompletion) throw new Assert.Error("! Set(A, Pk, mappedValue, Value.true) returned an abrupt completion", {
      cause: _temp31
    });
    /* node:coverage ignore next */
    if (_temp31 instanceof Completion) _temp31 = _temp31.Value;
    k += 1;
  }
  return A;
}
TypedArrayProto_map.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.map';
/** https://tc39.es/ecma262/#sec-settypedarrayfromtypedarray */
function* SetTypedArrayFromTypedArray(target, targetOffset, source) {
  const targetBuffer = target.ViewedArrayBuffer;
  const targetRecord = MakeTypedArrayWithBufferWitnessRecord(target);
  if (IsTypedArrayOutOfBounds(targetRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOOB');
  }
  const targetLength = TypedArrayLength(targetRecord);
  let srcBuffer = source.ViewedArrayBuffer;
  const srcRecord = MakeTypedArrayWithBufferWitnessRecord(source);
  if (IsTypedArrayOutOfBounds(srcRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOOB');
  }
  const srcLength = TypedArrayLength(srcRecord);
  const targetType = TypedArrayElementType(target);
  const targetElementSize = TypedArrayElementSize(target);
  const targetByteOffset = target.ByteOffset;
  const srcType = TypedArrayElementType(source);
  const srcElementSize = TypedArrayElementSize(source);
  const srcByteOffset = source.ByteOffset;
  if (targetOffset === +Infinity) {
    return surroundingAgent.Throw('RangeError', 'TypedArrayOOB');
  }
  if (srcLength + targetOffset > targetLength) {
    return surroundingAgent.Throw('RangeError', 'TypedArrayOOB');
  }
  if (target.ContentType !== source.ContentType) {
    return surroundingAgent.Throw('TypeError', 'BufferContentTypeMismatch');
  }
  let sameSharedArrayBuffer;
  if (IsSharedArrayBuffer() === Value.true && IsSharedArrayBuffer() === Value.true && srcBuffer.ArrayBufferData === targetBuffer.ArrayBufferData) {
    sameSharedArrayBuffer = true;
  } else {
    sameSharedArrayBuffer = false;
  }
  let srcByteIndex;
  if (SameValue(srcBuffer, targetBuffer) === Value.true || sameSharedArrayBuffer) {
    const srcByteLength = TypedArrayByteLength(srcRecord);
    /* ReturnIfAbrupt */
    let _temp32 = yield* CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength);
    /* node:coverage ignore next */
    if (_temp32 instanceof AbruptCompletion) return _temp32;
    /* node:coverage ignore next */
    if (_temp32 instanceof Completion) _temp32 = _temp32.Value;
    srcBuffer = _temp32;
    srcByteIndex = 0;
  } else {
    srcByteIndex = srcByteOffset;
  }
  let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;
  const limit = targetByteIndex + targetElementSize * srcLength;
  if (srcType === targetType) {
    while (targetByteIndex < limit) {
      const value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'Uint8');
      /* ReturnIfAbrupt */
      let _temp33 = yield* SetValueInBuffer(targetBuffer, targetByteIndex, 'Uint8', value);
      /* node:coverage ignore next */
      if (_temp33 instanceof AbruptCompletion) return _temp33;
      /* node:coverage ignore next */
      if (_temp33 instanceof Completion) _temp33 = _temp33.Value;
      srcByteIndex += 1;
      targetByteIndex += 1;
    }
  } else {
    while (targetByteIndex < limit) {
      const value = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType);
      /* ReturnIfAbrupt */
      let _temp34 = yield* SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value);
      /* node:coverage ignore next */
      if (_temp34 instanceof AbruptCompletion) return _temp34;
      /* node:coverage ignore next */
      if (_temp34 instanceof Completion) _temp34 = _temp34.Value;
      srcByteIndex += srcElementSize;
      targetByteIndex += targetElementSize;
    }
  }
  return undefined;
}
SetTypedArrayFromTypedArray.section = 'https://tc39.es/ecma262/#sec-settypedarrayfromtypedarray';
/** https://tc39.es/ecma262/#sec-settypedarrayfromarraylike */
function* SetTypedArrayFromArrayLike(target, targetOffset, source) {
  const targetRecord = MakeTypedArrayWithBufferWitnessRecord(target);
  if (IsTypedArrayOutOfBounds(targetRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOOB');
  }
  const targetLength = TypedArrayLength(targetRecord);
  /* ReturnIfAbrupt */
  let _temp35 = ToObject(source);
  /* node:coverage ignore next */
  if (_temp35 && typeof _temp35 === 'object' && 'next' in _temp35) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp35 instanceof AbruptCompletion) return _temp35;
  /* node:coverage ignore next */
  if (_temp35 instanceof Completion) _temp35 = _temp35.Value;
  const src = _temp35;
  /* ReturnIfAbrupt */
  let _temp36 = yield* LengthOfArrayLike(src);
  /* node:coverage ignore next */
  if (_temp36 instanceof AbruptCompletion) return _temp36;
  /* node:coverage ignore next */
  if (_temp36 instanceof Completion) _temp36 = _temp36.Value;
  const srcLength = _temp36;
  if (targetOffset === +Infinity) {
    return surroundingAgent.Throw('RangeError', 'TypedArrayOOB');
  }
  if (srcLength + targetOffset > targetLength) {
    return surroundingAgent.Throw('RangeError', 'TypedArrayOOB');
  }
  let k = 0;
  while (k < srcLength) {
    /* X */
    let _temp37 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp37 && typeof _temp37 === 'object' && 'next' in _temp37) _temp37 = skipDebugger(_temp37);
    /* node:coverage ignore next */
    if (_temp37 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp37
    });
    /* node:coverage ignore next */
    if (_temp37 instanceof Completion) _temp37 = _temp37.Value;
    const Pk = _temp37;
    /* ReturnIfAbrupt */
    let _temp38 = yield* Get(src, Pk);
    /* node:coverage ignore next */
    if (_temp38 instanceof AbruptCompletion) return _temp38;
    /* node:coverage ignore next */
    if (_temp38 instanceof Completion) _temp38 = _temp38.Value;
    const value = _temp38;
    const targetIndex = F(targetOffset + k);
    /* ReturnIfAbrupt */
    let _temp39 = yield* TypedArraySetElement(target, targetIndex, value);
    /* node:coverage ignore next */
    if (_temp39 instanceof AbruptCompletion) return _temp39;
    /* node:coverage ignore next */
    if (_temp39 instanceof Completion) _temp39 = _temp39.Value;
    k += 1;
  }
  return undefined;
}
SetTypedArrayFromArrayLike.section = 'https://tc39.es/ecma262/#sec-settypedarrayfromarraylike';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.set-overloaded-offset */
function* TypedArrayProto_set([source = Value.undefined, offset = Value.undefined], {
  thisValue
}) {
  // 1. Let target be the this value.
  const target = thisValue;
  // 2. Perform ? RequireInternalSlot(target, [[TypedArrayName]]).
  /* ReturnIfAbrupt */
  let _temp40 = RequireInternalSlot(target, 'TypedArrayName');
  /* node:coverage ignore next */
  if (_temp40 && typeof _temp40 === 'object' && 'next' in _temp40) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp40 instanceof AbruptCompletion) return _temp40;
  /* node:coverage ignore next */
  if (_temp40 instanceof Completion) _temp40 = _temp40.Value;
  // 3. Assert: target has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in target, "'ViewedArrayBuffer' in target");
  // 4. Let targetOffset be ? ToIntegerOrInfinity(offset).
  /* ReturnIfAbrupt */
  let _temp41 = yield* ToIntegerOrInfinity(offset);
  /* node:coverage ignore next */
  if (_temp41 instanceof AbruptCompletion) return _temp41;
  /* node:coverage ignore next */
  if (_temp41 instanceof Completion) _temp41 = _temp41.Value;
  const targetOffset = _temp41;
  // 5. If targetOffset < 0, throw a RangeError exception.
  if (targetOffset < 0) {
    return surroundingAgent.Throw('RangeError', 'NegativeIndex', 'Offset');
  }
  // 6. If source is an Object that has a [[TypedArrayName]] internal slot, then
  if (source instanceof ObjectValue && 'TypedArrayName' in source) {
    /* ReturnIfAbrupt */
    let _temp42 = yield* SetTypedArrayFromTypedArray(target, targetOffset, source);
    /* node:coverage ignore next */
    if (_temp42 instanceof AbruptCompletion) return _temp42;
    /* node:coverage ignore next */
    if (_temp42 instanceof Completion) _temp42 = _temp42.Value;
  } else {
    /* ReturnIfAbrupt */
    let _temp43 = yield* SetTypedArrayFromArrayLike(target, targetOffset, source);
    /* node:coverage ignore next */
    if (_temp43 instanceof AbruptCompletion) return _temp43;
    /* node:coverage ignore next */
    if (_temp43 instanceof Completion) _temp43 = _temp43.Value;
  }
  // 8. Return undefined.
  return Value.undefined;
}
TypedArrayProto_set.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.set-overloaded-offset';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice */
function* TypedArrayProto_slice([start = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp44 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp44 && typeof _temp44 === 'object' && 'next' in _temp44) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp44 instanceof AbruptCompletion) return _temp44;
  /* node:coverage ignore next */
  if (_temp44 instanceof Completion) _temp44 = _temp44.Value;
  let taRecord = _temp44;
  const srcArrayLength = TypedArrayLength(taRecord);
  /* ReturnIfAbrupt */
  let _temp45 = yield* ToIntegerOrInfinity(start);
  /* node:coverage ignore next */
  if (_temp45 instanceof AbruptCompletion) return _temp45;
  /* node:coverage ignore next */
  if (_temp45 instanceof Completion) _temp45 = _temp45.Value;
  const relativeStart = _temp45;
  let startIndex;
  if (relativeStart === -Infinity) {
    startIndex = 0;
  } else if (relativeStart < 0) {
    startIndex = Math.max(srcArrayLength + relativeStart, 0);
  } else {
    startIndex = Math.min(relativeStart, srcArrayLength);
  }
  let relativeEnd;
  if (end === Value.undefined) {
    relativeEnd = srcArrayLength;
  } else {
    /* ReturnIfAbrupt */
    let _temp46 = yield* ToIntegerOrInfinity(end);
    /* node:coverage ignore next */
    if (_temp46 instanceof AbruptCompletion) return _temp46;
    /* node:coverage ignore next */
    if (_temp46 instanceof Completion) _temp46 = _temp46.Value;
    relativeEnd = _temp46;
  }
  let endIndex;
  if (relativeEnd === -Infinity) {
    endIndex = 0;
  } else if (relativeEnd < 0) {
    endIndex = Math.max(srcArrayLength + relativeEnd, 0);
  } else {
    endIndex = Math.min(relativeEnd, srcArrayLength);
  }
  let countBytes = Math.max(endIndex - startIndex, 0);
  /* ReturnIfAbrupt */
  let _temp47 = yield* TypedArraySpeciesCreate(O, [F(countBytes)]);
  /* node:coverage ignore next */
  if (_temp47 instanceof AbruptCompletion) return _temp47;
  /* node:coverage ignore next */
  if (_temp47 instanceof Completion) _temp47 = _temp47.Value;
  const A = _temp47;
  if (countBytes > 0) {
    taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
    if (IsTypedArrayOutOfBounds(taRecord)) {
      return surroundingAgent.Throw('TypeError', 'TypedArrayOOB');
    }
    endIndex = Math.min(endIndex, TypedArrayLength(taRecord));
    countBytes = Math.max(endIndex - startIndex, 0);
    const srcType = TypedArrayElementType(O);
    const targetType = TypedArrayElementType(A);
    if (srcType === targetType) {
      const srcBuffer = O.ViewedArrayBuffer;
      const targetBuffer = A.ViewedArrayBuffer;
      const elementSize = TypedArrayElementSize(O);
      const srcByteOffset = O.ByteOffset;
      let srcByteIndex = startIndex * elementSize + srcByteOffset;
      let targetByteIndex = A.ByteOffset;
      const endByteIndex = targetByteIndex + countBytes * elementSize;
      while (targetByteIndex < endByteIndex) {
        const value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'Uint8');
        /* ReturnIfAbrupt */
        let _temp48 = yield* SetValueInBuffer(targetBuffer, targetByteIndex, 'Uint8', value);
        /* node:coverage ignore next */
        if (_temp48 instanceof AbruptCompletion) return _temp48;
        /* node:coverage ignore next */
        if (_temp48 instanceof Completion) _temp48 = _temp48.Value;
        srcByteIndex += 1;
        targetByteIndex += 1;
      }
    } else {
      let n = 0;
      let k = startIndex;
      while (k < endIndex) {
        /* X */
        let _temp49 = ToString(F(k));
        /* node:coverage ignore next */
        if (_temp49 && typeof _temp49 === 'object' && 'next' in _temp49) _temp49 = skipDebugger(_temp49);
        /* node:coverage ignore next */
        if (_temp49 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
          cause: _temp49
        });
        /* node:coverage ignore next */
        if (_temp49 instanceof Completion) _temp49 = _temp49.Value;
        const Pk = _temp49;
        /* X */
        let _temp50 = Get(O, Pk);
        /* node:coverage ignore next */
        if (_temp50 && typeof _temp50 === 'object' && 'next' in _temp50) _temp50 = skipDebugger(_temp50);
        /* node:coverage ignore next */
        if (_temp50 instanceof AbruptCompletion) throw new Assert.Error("! Get(O, Pk) returned an abrupt completion", {
          cause: _temp50
        });
        /* node:coverage ignore next */
        if (_temp50 instanceof Completion) _temp50 = _temp50.Value;
        const kValue = _temp50;
        /* X */
        let _temp52 = ToString(F(n));
        /* node:coverage ignore next */
        if (_temp52 && typeof _temp52 === 'object' && 'next' in _temp52) _temp52 = skipDebugger(_temp52);
        /* node:coverage ignore next */
        if (_temp52 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(n)) returned an abrupt completion", {
          cause: _temp52
        });
        /* node:coverage ignore next */
        if (_temp52 instanceof Completion) _temp52 = _temp52.Value;
        /* X */
        let _temp51 = Set$1(A, _temp52, kValue, Value.true);
        /* node:coverage ignore next */
        if (_temp51 && typeof _temp51 === 'object' && 'next' in _temp51) _temp51 = skipDebugger(_temp51);
        /* node:coverage ignore next */
        if (_temp51 instanceof AbruptCompletion) throw new Assert.Error("! Set(A, X(ToString(F(n))), kValue, Value.true) returned an abrupt completion", {
          cause: _temp51
        });
        /* node:coverage ignore next */
        if (_temp51 instanceof Completion) _temp51 = _temp51.Value;
        k += 1;
        n += 1;
      }
    }
  }
  return A;
}
TypedArrayProto_slice.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort */
function* TypedArrayProto_sort([comparator = Value.undefined], {
  thisValue
}) {
  if (comparator !== Value.undefined && !IsCallable(comparator)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', comparator);
  }
  const obj = thisValue;
  /* ReturnIfAbrupt */
  let _temp53 = ValidateTypedArray(obj);
  /* node:coverage ignore next */
  if (_temp53 && typeof _temp53 === 'object' && 'next' in _temp53) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp53 instanceof AbruptCompletion) return _temp53;
  /* node:coverage ignore next */
  if (_temp53 instanceof Completion) _temp53 = _temp53.Value;
  const taRecord = _temp53;
  const len = TypedArrayLength(taRecord);
  const SortCompare = function* SortCompare(x, y) {
    Assert(x instanceof NumberValue || x instanceof BigIntValue, "x instanceof NumberValue || x instanceof BigIntValue");
    Assert(y instanceof NumberValue || y instanceof BigIntValue, "y instanceof NumberValue || y instanceof BigIntValue");
    return yield* CompareTypedArrayElements(x, y, comparator);
  };
  /* ReturnIfAbrupt */
  let _temp54 = yield* SortIndexedProperties(obj, len, SortCompare, 'read-through-holes');
  /* node:coverage ignore next */
  if (_temp54 instanceof AbruptCompletion) return _temp54;
  /* node:coverage ignore next */
  if (_temp54 instanceof Completion) _temp54 = _temp54.Value;
  const sortedList = _temp54;
  let j = 0;
  while (j < len) {
    /* X */
    let _temp56 = ToString(F(j));
    /* node:coverage ignore next */
    if (_temp56 && typeof _temp56 === 'object' && 'next' in _temp56) _temp56 = skipDebugger(_temp56);
    /* node:coverage ignore next */
    if (_temp56 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(j)) returned an abrupt completion", {
      cause: _temp56
    });
    /* node:coverage ignore next */
    if (_temp56 instanceof Completion) _temp56 = _temp56.Value;
    /* X */
    let _temp55 = Set$1(obj, _temp56, sortedList[j], Value.true);
    /* node:coverage ignore next */
    if (_temp55 && typeof _temp55 === 'object' && 'next' in _temp55) _temp55 = skipDebugger(_temp55);
    /* node:coverage ignore next */
    if (_temp55 instanceof AbruptCompletion) throw new Assert.Error("! Set(obj, X(ToString(F(j))), sortedList[j], Value.true) returned an abrupt completion", {
      cause: _temp55
    });
    /* node:coverage ignore next */
    if (_temp55 instanceof Completion) _temp55 = _temp55.Value;
    j += 1;
  }
  return obj;
}
TypedArrayProto_sort.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.tosorted */
function* TypedArrayProto_toSorted([comparator = Value.undefined], {
  thisValue
}) {
  if (comparator !== Value.undefined && !IsCallable(comparator)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', comparator);
  }
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp57 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp57 && typeof _temp57 === 'object' && 'next' in _temp57) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp57 instanceof AbruptCompletion) return _temp57;
  /* node:coverage ignore next */
  if (_temp57 instanceof Completion) _temp57 = _temp57.Value;
  const taRecord = _temp57;
  const len = TypedArrayLength(taRecord);
  /* ReturnIfAbrupt */
  let _temp58 = yield* TypedArrayCreateSameType(O, [F(len)]);
  /* node:coverage ignore next */
  if (_temp58 instanceof AbruptCompletion) return _temp58;
  /* node:coverage ignore next */
  if (_temp58 instanceof Completion) _temp58 = _temp58.Value;
  const A = _temp58;
  const SortCompare = function* SortCompare(x, y) {
    Assert(x instanceof NumberValue || x instanceof BigIntValue, "x instanceof NumberValue || x instanceof BigIntValue");
    Assert(y instanceof NumberValue || y instanceof BigIntValue, "y instanceof NumberValue || y instanceof BigIntValue");
    return yield* CompareTypedArrayElements(x, y, comparator);
  };
  /* ReturnIfAbrupt */
  let _temp59 = yield* SortIndexedProperties(O, len, SortCompare, 'read-through-holes');
  /* node:coverage ignore next */
  if (_temp59 instanceof AbruptCompletion) return _temp59;
  /* node:coverage ignore next */
  if (_temp59 instanceof Completion) _temp59 = _temp59.Value;
  const sortedList = _temp59;
  let j = 0;
  while (j < len) {
    /* X */
    let _temp61 = ToString(F(j));
    /* node:coverage ignore next */
    if (_temp61 && typeof _temp61 === 'object' && 'next' in _temp61) _temp61 = skipDebugger(_temp61);
    /* node:coverage ignore next */
    if (_temp61 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(j)) returned an abrupt completion", {
      cause: _temp61
    });
    /* node:coverage ignore next */
    if (_temp61 instanceof Completion) _temp61 = _temp61.Value;
    /* X */
    let _temp60 = Set$1(A, _temp61, sortedList[j], Value.true);
    /* node:coverage ignore next */
    if (_temp60 && typeof _temp60 === 'object' && 'next' in _temp60) _temp60 = skipDebugger(_temp60);
    /* node:coverage ignore next */
    if (_temp60 instanceof AbruptCompletion) throw new Assert.Error("! Set(A, X(ToString(F(j))), sortedList[j], Value.true) returned an abrupt completion", {
      cause: _temp60
    });
    /* node:coverage ignore next */
    if (_temp60 instanceof Completion) _temp60 = _temp60.Value;
    j += 1;
  }
  return A;
}
TypedArrayProto_toSorted.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.tosorted';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray */
function* TypedArrayProto_subarray([begin = Value.undefined, end = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp62 = RequireInternalSlot(O, 'TypedArrayName');
  /* node:coverage ignore next */
  if (_temp62 && typeof _temp62 === 'object' && 'next' in _temp62) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp62 instanceof AbruptCompletion) return _temp62;
  /* node:coverage ignore next */
  if (_temp62 instanceof Completion) _temp62 = _temp62.Value;
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  const buffer = O.ViewedArrayBuffer;
  const srcRecord = MakeTypedArrayWithBufferWitnessRecord(O);
  let srcLength;
  if (IsTypedArrayOutOfBounds(srcRecord)) {
    srcLength = 0;
  } else {
    srcLength = TypedArrayLength(srcRecord);
  }
  /* ReturnIfAbrupt */
  let _temp63 = yield* ToIntegerOrInfinity(begin);
  /* node:coverage ignore next */
  if (_temp63 instanceof AbruptCompletion) return _temp63;
  /* node:coverage ignore next */
  if (_temp63 instanceof Completion) _temp63 = _temp63.Value;
  const relativeStart = _temp63;
  let startIndex;
  if (relativeStart === -Infinity) {
    startIndex = 0;
  } else if (relativeStart < 0) {
    startIndex = Math.max(srcLength + relativeStart, 0);
  } else {
    startIndex = Math.min(relativeStart, srcLength);
  }
  const elementSize = TypedArrayElementSize(O);
  const srcByteOffset = O.ByteOffset;
  const beginByteOffset = srcByteOffset + startIndex * elementSize;
  let argumentsList;
  if (O.ArrayLength === 'auto' && end === Value.undefined) {
    argumentsList = [buffer, F(beginByteOffset)];
  } else {
    let relativeEnd;
    if (end === Value.undefined) {
      relativeEnd = srcLength;
    } else {
      /* ReturnIfAbrupt */
      let _temp64 = yield* ToIntegerOrInfinity(end);
      /* node:coverage ignore next */
      if (_temp64 instanceof AbruptCompletion) return _temp64;
      /* node:coverage ignore next */
      if (_temp64 instanceof Completion) _temp64 = _temp64.Value;
      relativeEnd = _temp64;
    }
    let endIndex;
    if (relativeEnd === -Infinity) {
      endIndex = 0;
    } else if (relativeEnd < 0) {
      endIndex = Math.max(srcLength + relativeEnd, 0);
    } else {
      endIndex = Math.min(relativeEnd, srcLength);
    }
    const newLength = Math.max(endIndex - startIndex, 0);
    argumentsList = [buffer, F(beginByteOffset), F(newLength)];
  }
  return yield* TypedArraySpeciesCreate(O, argumentsList);
}
TypedArrayProto_subarray.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.values */
function TypedArrayProto_values(_args, {
  thisValue
}) {
  // 1. Let o be the this value.
  const O = thisValue;
  // 2. Perform ? ValidateTypedArray(O).
  /* ReturnIfAbrupt */
  let _temp65 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp65 && typeof _temp65 === 'object' && 'next' in _temp65) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp65 instanceof AbruptCompletion) return _temp65;
  /* node:coverage ignore next */
  if (_temp65 instanceof Completion) _temp65 = _temp65.Value;
  // Return CreateArrayIterator(O, value).
  return CreateArrayIterator(O, 'value');
}
TypedArrayProto_values.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.values';
/** https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag */
function TypedArrayProto_toStringTag(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. If Type(O) is not Object, return undefined.
  if (!(O instanceof ObjectValue)) {
    return Value.undefined;
  }
  // 3. If O does not have a [[TypedArrayName]] internal slot, return undefined.
  if (!('TypedArrayName' in O)) {
    return Value.undefined;
  }
  // 4. Let name be O.[[TypedArrayName]].
  const name = O.TypedArrayName;
  // 5. Assert: Type(name) is String.
  Assert(name instanceof JSStringValue, "name instanceof JSStringValue");
  // 6. Return name.
  return name;
}
TypedArrayProto_toStringTag.section = 'https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.at */
function* TypedArrayProto_at([index = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp66 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp66 && typeof _temp66 === 'object' && 'next' in _temp66) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp66 instanceof AbruptCompletion) return _temp66;
  /* node:coverage ignore next */
  if (_temp66 instanceof Completion) _temp66 = _temp66.Value;
  const taRecord = _temp66;
  const len = TypedArrayLength(taRecord);
  /* ReturnIfAbrupt */
  let _temp67 = yield* ToIntegerOrInfinity(index);
  /* node:coverage ignore next */
  if (_temp67 instanceof AbruptCompletion) return _temp67;
  /* node:coverage ignore next */
  if (_temp67 instanceof Completion) _temp67 = _temp67.Value;
  const relativeIndex = _temp67;
  let k;
  if (relativeIndex >= 0) {
    k = relativeIndex;
  } else {
    k = len + relativeIndex;
  }
  if (k < 0 || k >= len) {
    return Value.undefined;
  }
  /* X */
  let _temp69 = ToString(F(k));
  /* node:coverage ignore next */
  if (_temp69 && typeof _temp69 === 'object' && 'next' in _temp69) _temp69 = skipDebugger(_temp69);
  /* node:coverage ignore next */
  if (_temp69 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
    cause: _temp69
  });
  /* node:coverage ignore next */
  if (_temp69 instanceof Completion) _temp69 = _temp69.Value;
  /* X */
  let _temp68 = Get(O, _temp69);
  /* node:coverage ignore next */
  if (_temp68 && typeof _temp68 === 'object' && 'next' in _temp68) _temp68 = skipDebugger(_temp68);
  /* node:coverage ignore next */
  if (_temp68 instanceof AbruptCompletion) throw new Assert.Error("! Get(O, X(ToString(F(k)))) returned an abrupt completion", {
    cause: _temp68
  });
  /* node:coverage ignore next */
  if (_temp68 instanceof Completion) _temp68 = _temp68.Value;
  return _temp68;
}
TypedArrayProto_at.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.at';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.with */
function* TypedArrayProto_with([index = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp70 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp70 && typeof _temp70 === 'object' && 'next' in _temp70) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp70 instanceof AbruptCompletion) return _temp70;
  /* node:coverage ignore next */
  if (_temp70 instanceof Completion) _temp70 = _temp70.Value;
  const taRecord = _temp70;
  const len = TypedArrayLength(taRecord);
  /* ReturnIfAbrupt */
  let _temp71 = yield* ToIntegerOrInfinity(index);
  /* node:coverage ignore next */
  if (_temp71 instanceof AbruptCompletion) return _temp71;
  /* node:coverage ignore next */
  if (_temp71 instanceof Completion) _temp71 = _temp71.Value;
  const relativeIndex = _temp71;
  let actualIndex;
  if (relativeIndex >= 0) {
    actualIndex = relativeIndex;
  } else {
    actualIndex = len + relativeIndex;
  }
  let numericValue;
  if (O.ContentType === 'BigInt') {
    /* ReturnIfAbrupt */
    let _temp72 = yield* ToBigInt(value);
    /* node:coverage ignore next */
    if (_temp72 instanceof AbruptCompletion) return _temp72;
    /* node:coverage ignore next */
    if (_temp72 instanceof Completion) _temp72 = _temp72.Value;
    numericValue = _temp72;
  } else {
    /* ReturnIfAbrupt */
    let _temp73 = yield* ToNumber(value);
    /* node:coverage ignore next */
    if (_temp73 instanceof AbruptCompletion) return _temp73;
    /* node:coverage ignore next */
    if (_temp73 instanceof Completion) _temp73 = _temp73.Value;
    numericValue = _temp73;
  }
  if (IsValidIntegerIndex(O, F(actualIndex)) === Value.false) {
    return surroundingAgent.Throw('RangeError', 'TypedArrayOOB');
  }
  /* ReturnIfAbrupt */
  let _temp74 = yield* TypedArrayCreateSameType(O, [F(len)]);
  /* node:coverage ignore next */
  if (_temp74 instanceof AbruptCompletion) return _temp74;
  /* node:coverage ignore next */
  if (_temp74 instanceof Completion) _temp74 = _temp74.Value;
  const A = _temp74;
  let k = 0;
  while (k < len) {
    /* X */
    let _temp75 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp75 && typeof _temp75 === 'object' && 'next' in _temp75) _temp75 = skipDebugger(_temp75);
    /* node:coverage ignore next */
    if (_temp75 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp75
    });
    /* node:coverage ignore next */
    if (_temp75 instanceof Completion) _temp75 = _temp75.Value;
    const Pk = _temp75;
    let fromValue;
    if (k === actualIndex) {
      fromValue = numericValue;
    } else {
      /* X */
      let _temp76 = Get(O, Pk);
      /* node:coverage ignore next */
      if (_temp76 && typeof _temp76 === 'object' && 'next' in _temp76) _temp76 = skipDebugger(_temp76);
      /* node:coverage ignore next */
      if (_temp76 instanceof AbruptCompletion) throw new Assert.Error("! Get(O, Pk) returned an abrupt completion", {
        cause: _temp76
      });
      /* node:coverage ignore next */
      if (_temp76 instanceof Completion) _temp76 = _temp76.Value;
      fromValue = _temp76;
    }
    /* X */
    let _temp77 = Set$1(A, Pk, fromValue, Value.true);
    /* node:coverage ignore next */
    if (_temp77 && typeof _temp77 === 'object' && 'next' in _temp77) _temp77 = skipDebugger(_temp77);
    /* node:coverage ignore next */
    if (_temp77 instanceof AbruptCompletion) throw new Assert.Error("! Set(A, Pk, fromValue, Value.true) returned an abrupt completion", {
      cause: _temp77
    });
    /* node:coverage ignore next */
    if (_temp77 instanceof Completion) _temp77 = _temp77.Value;
    k += 1;
  }
  return A;
}
TypedArrayProto_with.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.with';
/** https://tc39.es/ecma262/#sec-%typedarray%.prototype.toreversed */
function* TypedArrayProto_toReversed(_args, {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp78 = ValidateTypedArray(O);
  /* node:coverage ignore next */
  if (_temp78 && typeof _temp78 === 'object' && 'next' in _temp78) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp78 instanceof AbruptCompletion) return _temp78;
  /* node:coverage ignore next */
  if (_temp78 instanceof Completion) _temp78 = _temp78.Value;
  const taRecord = _temp78;
  const length = TypedArrayLength(taRecord);
  /* ReturnIfAbrupt */
  let _temp79 = yield* TypedArrayCreateSameType(O, [F(length)]);
  /* node:coverage ignore next */
  if (_temp79 instanceof AbruptCompletion) return _temp79;
  /* node:coverage ignore next */
  if (_temp79 instanceof Completion) _temp79 = _temp79.Value;
  const A = _temp79;
  let k = 0;
  while (k < length) {
    /* X */
    let _temp80 = ToString(F(length - k - 1));
    /* node:coverage ignore next */
    if (_temp80 && typeof _temp80 === 'object' && 'next' in _temp80) _temp80 = skipDebugger(_temp80);
    /* node:coverage ignore next */
    if (_temp80 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(length - k - 1)) returned an abrupt completion", {
      cause: _temp80
    });
    /* node:coverage ignore next */
    if (_temp80 instanceof Completion) _temp80 = _temp80.Value;
    const from = _temp80;
    /* X */
    let _temp81 = ToString(F(k));
    /* node:coverage ignore next */
    if (_temp81 && typeof _temp81 === 'object' && 'next' in _temp81) _temp81 = skipDebugger(_temp81);
    /* node:coverage ignore next */
    if (_temp81 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(k)) returned an abrupt completion", {
      cause: _temp81
    });
    /* node:coverage ignore next */
    if (_temp81 instanceof Completion) _temp81 = _temp81.Value;
    const Pk = _temp81;
    /* X */
    let _temp82 = Get(O, from);
    /* node:coverage ignore next */
    if (_temp82 && typeof _temp82 === 'object' && 'next' in _temp82) _temp82 = skipDebugger(_temp82);
    /* node:coverage ignore next */
    if (_temp82 instanceof AbruptCompletion) throw new Assert.Error("! Get(O, from) returned an abrupt completion", {
      cause: _temp82
    });
    /* node:coverage ignore next */
    if (_temp82 instanceof Completion) _temp82 = _temp82.Value;
    const fromValue = _temp82;
    /* X */
    let _temp83 = Set$1(A, Pk, fromValue, Value.true);
    /* node:coverage ignore next */
    if (_temp83 && typeof _temp83 === 'object' && 'next' in _temp83) _temp83 = skipDebugger(_temp83);
    /* node:coverage ignore next */
    if (_temp83 instanceof AbruptCompletion) throw new Assert.Error("! Set(A, Pk, fromValue, Value.true) returned an abrupt completion", {
      cause: _temp83
    });
    /* node:coverage ignore next */
    if (_temp83 instanceof Completion) _temp83 = _temp83.Value;
    k += 1;
  }
  return A;
}
TypedArrayProto_toReversed.section = 'https://tc39.es/ecma262/#sec-%typedarray%.prototype.toreversed';
function bootstrapTypedArrayPrototype(realmRec) {
  /* X */
  let _temp84 = Get(realmRec.Intrinsics['%Array.prototype%'], Value('toString'));
  /* node:coverage ignore next */
  if (_temp84 && typeof _temp84 === 'object' && 'next' in _temp84) _temp84 = skipDebugger(_temp84);
  /* node:coverage ignore next */
  if (_temp84 instanceof AbruptCompletion) throw new Assert.Error("! Get(realmRec.Intrinsics['%Array.prototype%'], Value('toString')) returned an abrupt completion", {
    cause: _temp84
  });
  /* node:coverage ignore next */
  if (_temp84 instanceof Completion) _temp84 = _temp84.Value;
  const ArrayProto_toString = _temp84;
  Assert(ArrayProto_toString instanceof ObjectValue, "ArrayProto_toString instanceof ObjectValue");
  const proto = bootstrapPrototype(realmRec, [['buffer', [TypedArrayProto_buffer]], ['byteLength', [TypedArrayProto_byteLength]], ['byteOffset', [TypedArrayProto_byteOffset]], ['copyWithin', TypedArrayProto_copyWithin, 2], ['entries', TypedArrayProto_entries, 0], ['fill', TypedArrayProto_fill, 1], ['filter', TypedArrayProto_filter, 1], ['at', TypedArrayProto_at, 1], ['keys', TypedArrayProto_keys, 0], ['length', [TypedArrayProto_length]], ['map', TypedArrayProto_map, 1], ['set', TypedArrayProto_set, 1], ['slice', TypedArrayProto_slice, 2], ['sort', TypedArrayProto_sort, 1], ['toSorted', TypedArrayProto_toSorted, 1], ['subarray', TypedArrayProto_subarray, 2], ['values', TypedArrayProto_values, 0], ['with', TypedArrayProto_with, 2], ['toReversed', TypedArrayProto_toReversed, 0], ['toString', ArrayProto_toString], [wellKnownSymbols.toStringTag, [TypedArrayProto_toStringTag]]], realmRec.Intrinsics['%Object.prototype%']);
  bootstrapArrayPrototypeShared(realmRec, proto, thisValue => ValidateTypedArray(thisValue), O => {
    /* ReturnIfAbrupt */
    let _temp85 = ValidateTypedArray(O);
    /* node:coverage ignore next */
    if (_temp85 && typeof _temp85 === 'object' && 'next' in _temp85) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp85 instanceof AbruptCompletion) return _temp85;
    /* node:coverage ignore next */
    if (_temp85 instanceof Completion) _temp85 = _temp85.Value;
    const rec = _temp85;
    return TypedArrayLength(rec);
  });

  /** https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator */
  {
    /* X */
    let _temp86 = Get(proto, Value('values'));
    /* node:coverage ignore next */
    if (_temp86 && typeof _temp86 === 'object' && 'next' in _temp86) _temp86 = skipDebugger(_temp86);
    /* node:coverage ignore next */
    if (_temp86 instanceof AbruptCompletion) throw new Assert.Error("! Get(proto, Value('values')) returned an abrupt completion", {
      cause: _temp86
    });
    /* node:coverage ignore next */
    if (_temp86 instanceof Completion) _temp86 = _temp86.Value;
    const fn = _temp86;
    /* X */
    let _temp87 = proto.DefineOwnProperty(wellKnownSymbols.iterator, _Descriptor({
      Value: fn,
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    /* node:coverage ignore next */
    if (_temp87 && typeof _temp87 === 'object' && 'next' in _temp87) _temp87 = skipDebugger(_temp87);
    /* node:coverage ignore next */
    if (_temp87 instanceof AbruptCompletion) throw new Assert.Error("! proto.DefineOwnProperty(wellKnownSymbols.iterator, Descriptor({\n      Value: fn,\n      Writable: Value.true,\n      Enumerable: Value.false,\n      Configurable: Value.true,\n    })) returned an abrupt completion", {
      cause: _temp87
    });
    /* node:coverage ignore next */
    if (_temp87 instanceof Completion) _temp87 = _temp87.Value;
  }
  realmRec.Intrinsics['%TypedArray.prototype%'] = proto;
}

function bootstrapTypedArrayConstructors(realmRec) {
  Object.entries(typedArrayInfoByName).forEach(([TypedArray, info]) => {
    /** https://tc39.es/ecma262/#sec-typedarray-constructors */
    function* TypedArrayConstructor(args, {
      NewTarget
    }) {
      if (NewTarget instanceof UndefinedValue) {
        return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
      }
      const constructorName = Value(TypedArray);
      const proto = `%${TypedArray}.prototype%`;
      const numberOfArgs = args.length;
      if (numberOfArgs === 0) {
        return yield* AllocateTypedArray(constructorName, NewTarget, proto, 0);
      } else {
        const firstArgument = args[0];
        if (firstArgument instanceof ObjectValue) {
          /* ReturnIfAbrupt */
          let _temp = yield* AllocateTypedArray(constructorName, NewTarget, proto);
          /* node:coverage ignore next */
          if (_temp instanceof AbruptCompletion) return _temp;
          /* node:coverage ignore next */
          if (_temp instanceof Completion) _temp = _temp.Value;
          const O = _temp;
          if (isTypedArrayObject(firstArgument)) {
            /* ReturnIfAbrupt */
            let _temp2 = yield* InitializeTypedArrayFromTypedArray(O, firstArgument);
            /* node:coverage ignore next */
            if (_temp2 instanceof AbruptCompletion) return _temp2;
            /* node:coverage ignore next */
            if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
          } else if (isArrayBufferObject(firstArgument)) {
            let byteOffset;
            let length;
            if (numberOfArgs > 1) {
              byteOffset = args[1];
            } else {
              byteOffset = Value.undefined;
            }
            if (numberOfArgs > 2) {
              length = args[2];
            } else {
              length = Value.undefined;
            }
            /* ReturnIfAbrupt */
            let _temp3 = yield* InitializeTypedArrayFromArrayBuffer(O, firstArgument, byteOffset, length);
            /* node:coverage ignore next */
            if (_temp3 instanceof AbruptCompletion) return _temp3;
            /* node:coverage ignore next */
            if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
          } else {
            Assert(firstArgument instanceof ObjectValue && !isTypedArrayObject(firstArgument) && !isArrayBufferObject(firstArgument), "firstArgument instanceof ObjectValue && !isTypedArrayObject(firstArgument) && !isArrayBufferObject(firstArgument)");
            /* ReturnIfAbrupt */
            let _temp4 = yield* GetMethod(firstArgument, wellKnownSymbols.iterator);
            /* node:coverage ignore next */
            if (_temp4 instanceof AbruptCompletion) return _temp4;
            /* node:coverage ignore next */
            if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
            const usingIterator = _temp4;
            if (!(usingIterator instanceof UndefinedValue)) {
              /* ReturnIfAbrupt */
              let _temp7 = yield* GetIteratorFromMethod(firstArgument, usingIterator);
              /* node:coverage ignore next */
              if (_temp7 instanceof AbruptCompletion) return _temp7;
              /* node:coverage ignore next */
              if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
              /* ReturnIfAbrupt */
              let _temp5 = yield* IteratorToList(_temp7);
              /* node:coverage ignore next */
              if (_temp5 instanceof AbruptCompletion) return _temp5;
              /* node:coverage ignore next */
              if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
              const values = _temp5;
              /* ReturnIfAbrupt */
              let _temp6 = yield* InitializeTypedArrayFromList(O, values);
              /* node:coverage ignore next */
              if (_temp6 instanceof AbruptCompletion) return _temp6;
              /* node:coverage ignore next */
              if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
            } else {
              /* ReturnIfAbrupt */
              let _temp8 = yield* InitializeTypedArrayFromArrayLike(O, firstArgument);
              /* node:coverage ignore next */
              if (_temp8 instanceof AbruptCompletion) return _temp8;
              /* node:coverage ignore next */
              if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
            }
          }
          return O;
        } else {
          Assert(!(firstArgument instanceof ObjectValue), "!(firstArgument instanceof ObjectValue)");
          /* ReturnIfAbrupt */
          let _temp9 = yield* ToIndex(firstArgument);
          /* node:coverage ignore next */
          if (_temp9 instanceof AbruptCompletion) return _temp9;
          /* node:coverage ignore next */
          if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
          const elementLength = _temp9;
          return yield* AllocateTypedArray(constructorName, NewTarget, proto, elementLength);
        }
      }
    }
    TypedArrayConstructor.section = 'https://tc39.es/ecma262/#sec-typedarray-constructors';
    const taConstructor = bootstrapConstructor(realmRec, TypedArrayConstructor, TypedArray, 3, realmRec.Intrinsics[`%${TypedArray}.prototype%`], [['BYTES_PER_ELEMENT', F(info.ElementSize), undefined, {
      Writable: Value.false,
      Configurable: Value.false
    }]]);
    /* X */
    let _temp10 = taConstructor.SetPrototypeOf(realmRec.Intrinsics['%TypedArray%']);
    /* node:coverage ignore next */
    if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! taConstructor.SetPrototypeOf(realmRec.Intrinsics['%TypedArray%']) returned an abrupt completion", {
      cause: _temp10
    });
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    realmRec.Intrinsics[`%${TypedArray}%`] = taConstructor;
  });
}

/** https://tc39.es/ecma262/#sec-properties-of-typedarray-prototype-objects */
function bootstrapTypedArrayPrototypes(realmRec) {
  Object.entries(typedArrayInfoByName).forEach(([TypedArray, info]) => {
    const proto = bootstrapPrototype(realmRec, [['BYTES_PER_ELEMENT', F(info.ElementSize), undefined, {
      Writable: Value.false,
      Configurable: Value.false
    }]], realmRec.Intrinsics['%TypedArray.prototype%']);
    realmRec.Intrinsics[`%${TypedArray}.prototype%`] = proto;
  });
}
bootstrapTypedArrayPrototypes.section = 'https://tc39.es/ecma262/#sec-properties-of-typedarray-prototype-objects';

/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.tobase64 */
function* Uint8Array_prototype_toBase64([options = Value.undefined], {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp = ValidateUint8Array(O);
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  /* ReturnIfAbrupt */
  let _temp2 = GetOptionsObject(options);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const opts = _temp2;
  /* ReturnIfAbrupt */
  let _temp3 = yield* Get(opts, Value('alphabet'));
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  let alphabet = _temp3;
  if (alphabet instanceof UndefinedValue) {
    alphabet = Value('base64');
  }
  if (!(alphabet instanceof JSStringValue) || alphabet.stringValue() !== 'base64' && alphabet.stringValue() !== 'base64url') {
    return surroundingAgent.Throw('TypeError', 'InvalidAlphabet');
  }
  /* ReturnIfAbrupt */
  let _temp4 = yield* Get(opts, Value('omitPadding'));
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const omitPadding = ToBoolean(_temp4);
  /* ReturnIfAbrupt */
  let _temp5 = GetUint8ArrayBytes(O);
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const toEncode = _temp5;
  let outAscii;
  if (alphabet.stringValue() === 'base64') {
    outAscii = btoa(String.fromCharCode(...toEncode));
    if (omitPadding !== Value.false) {
      outAscii = outAscii.replace(/=/g, '');
    }
  } else {
    Assert(alphabet.stringValue() === 'base64url', "alphabet.stringValue() === 'base64url'");
    outAscii = btoa(String.fromCharCode(...toEncode)).replace(/\+/g, '-').replace(/\//g, '_');
    if (omitPadding !== Value.false) {
      outAscii = outAscii.replace(/=/g, '');
    }
  }
  return Value(CodePointsToString(outAscii));
}
Uint8Array_prototype_toBase64.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.tobase64';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.tohex */
function Uint8Array_prototype_toHex(_args, {
  thisValue
}) {
  const O = thisValue;
  /* ReturnIfAbrupt */
  let _temp6 = ValidateUint8Array(O);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  /* ReturnIfAbrupt */
  let _temp7 = GetUint8ArrayBytes(O);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const toEncode = _temp7;
  let out = '';
  for (const byte of toEncode) {
    let hex = NumberValue.toString(F(byte), 16);
    /* X */
    let _temp8 = StringPad(hex, Value(2), Value('0'), 'start');
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! StringPad(hex, Value(2), Value('0'), 'start') returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    hex = _temp8;
    out += hex.stringValue();
  }
  return Value(out);
}
Uint8Array_prototype_toHex.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.tohex';
function* Uint8Array_fromBase64([string, options = Value.undefined]) {
  if (!(string instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAString', string);
  }
  /* ReturnIfAbrupt */
  let _temp9 = GetOptionsObject(options);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const opts = _temp9;
  /* ReturnIfAbrupt */
  let _temp10 = yield* Get(opts, Value('alphabet'));
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  let alphabet = _temp10;
  if (alphabet instanceof UndefinedValue) {
    alphabet = Value('base64');
  }
  if (!(alphabet instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'InvalidAlphabet');
  }
  const alphabetStr = alphabet.stringValue();
  if (alphabetStr !== 'base64' && alphabetStr !== 'base64url') {
    return surroundingAgent.Throw('TypeError', 'InvalidAlphabet');
  }
  /* ReturnIfAbrupt */
  let _temp11 = yield* Get(opts, Value('lastChunkHandling'));
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  let lastChunkHandling = _temp11;
  if (lastChunkHandling instanceof UndefinedValue) {
    lastChunkHandling = Value('loose');
  }
  if (!(lastChunkHandling instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'InvalidLastChunkHandling');
  }
  const lastChunkHandlingStr = lastChunkHandling.stringValue();
  if (lastChunkHandlingStr !== 'loose' && lastChunkHandlingStr !== 'strict' && lastChunkHandlingStr !== 'stop-before-partial') {
    return surroundingAgent.Throw('TypeError', 'InvalidLastChunkHandling');
  }
  const result = FromBase64(string.stringValue(), alphabetStr, lastChunkHandlingStr);
  if (result.Error) {
    return ThrowCompletion(result.Error);
  }
  const resultLength = result.Bytes.length;
  /* ReturnIfAbrupt */
  let _temp12 = yield* AllocateTypedArray(Value('Uint8Array'), surroundingAgent.intrinsic('%Uint8Array%'), '%Uint8Array.prototype%', resultLength);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  const ta = _temp12;
  for (let i = 0; i < resultLength; i += 1) {
    const byte = result.Bytes[i];
    yield* SetValueInBuffer(ta.ViewedArrayBuffer, ta.ByteOffset + i, 'Uint8', F(byte));
  }
  return ta;
}

/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.setfrombase64 */
function* Uint8Array_prototype_setFromBase64([string, options = Value.undefined], {
  thisValue
}) {
  const into = thisValue;
  /* ReturnIfAbrupt */
  let _temp13 = ValidateUint8Array(into);
  /* node:coverage ignore next */
  if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  if (!(string instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAString', string);
  }
  /* ReturnIfAbrupt */
  let _temp14 = GetOptionsObject(options);
  /* node:coverage ignore next */
  if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  const opts = _temp14;
  /* ReturnIfAbrupt */
  let _temp15 = yield* Get(opts, Value('alphabet'));
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  let alphabet = _temp15;
  if (alphabet instanceof UndefinedValue) {
    alphabet = Value('base64');
  }
  if (!(alphabet instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'InvalidAlphabet');
  }
  const alphabetStr = alphabet.stringValue();
  if (alphabetStr !== 'base64' && alphabetStr !== 'base64url') {
    return surroundingAgent.Throw('TypeError', 'InvalidAlphabet');
  }
  /* ReturnIfAbrupt */
  let _temp16 = yield* Get(opts, Value('lastChunkHandling'));
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  let lastChunkHandling = _temp16;
  if (lastChunkHandling instanceof UndefinedValue) {
    lastChunkHandling = Value('loose');
  }
  if (!(lastChunkHandling instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'InvalidLastChunkHandling');
  }
  const lastChunkHandlingStr = lastChunkHandling.stringValue();
  if (lastChunkHandlingStr !== 'loose' && lastChunkHandlingStr !== 'strict' && lastChunkHandlingStr !== 'stop-before-partial') {
    return surroundingAgent.Throw('TypeError', 'InvalidLastChunkHandling');
  }
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(into);
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOutOfBounds');
  }
  const byteLength = TypedArrayLength(taRecord);
  const result = FromBase64(string.stringValue(), alphabetStr, lastChunkHandlingStr, byteLength);
  const bytes = result.Bytes;
  const written = bytes.length;
  Assert(written <= byteLength, "written <= byteLength");
  yield* SetUint8ArrayBytes(into, bytes);
  if (result.Error) {
    return ThrowCompletion(result.Error);
  }
  const resultObject = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* X */
  let _temp17 = CreateDataPropertyOrThrow(resultObject, Value('read'), F(result.Read));
  /* node:coverage ignore next */
  if (_temp17 && typeof _temp17 === 'object' && 'next' in _temp17) _temp17 = skipDebugger(_temp17);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(resultObject, Value('read'), F(result.Read)) returned an abrupt completion", {
    cause: _temp17
  });
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  /* X */
  let _temp18 = CreateDataPropertyOrThrow(resultObject, Value('written'), F(written));
  /* node:coverage ignore next */
  if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
  /* node:coverage ignore next */
  if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(resultObject, Value('written'), F(written)) returned an abrupt completion", {
    cause: _temp18
  });
  /* node:coverage ignore next */
  if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
  return resultObject;
}
Uint8Array_prototype_setFromBase64.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.setfrombase64';
function* Uint8Array_fromHex([string]) {
  if (!(string instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAString', string);
  }
  const result = FromHex(string.stringValue());
  if (result.Error) {
    return ThrowCompletion(result.Error);
  }
  const resultLength = result.Bytes.length;
  /* ReturnIfAbrupt */
  let _temp19 = yield* AllocateTypedArray(Value('Uint8Array'), surroundingAgent.intrinsic('%Uint8Array%'), '%Uint8Array.prototype%', resultLength);
  /* node:coverage ignore next */
  if (_temp19 instanceof AbruptCompletion) return _temp19;
  /* node:coverage ignore next */
  if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
  const ta = _temp19;
  for (let i = 0; i < resultLength; i += 1) {
    const byte = result.Bytes[i];
    yield* SetValueInBuffer(ta.ViewedArrayBuffer, ta.ByteOffset + i, 'Uint8', F(byte));
  }
  return ta;
}

/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.setfromhex */
function* Uint8Array_prototype_setFromHex([string], {
  thisValue
}) {
  const into = thisValue;
  /* ReturnIfAbrupt */
  let _temp20 = ValidateUint8Array(into);
  /* node:coverage ignore next */
  if (_temp20 && typeof _temp20 === 'object' && 'next' in _temp20) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp20 instanceof AbruptCompletion) return _temp20;
  /* node:coverage ignore next */
  if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
  if (!(string instanceof JSStringValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAString', string);
  }
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(into);
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOutOfBounds');
  }
  const byteLength = TypedArrayLength(taRecord);
  const result = FromHex(string.stringValue(), byteLength);
  const bytes = result.Bytes;
  const written = bytes.length;
  Assert(written <= byteLength, "written <= byteLength");
  yield* SetUint8ArrayBytes(into, bytes);
  if (result.Error) {
    return ThrowCompletion(result.Error);
  }
  const resultObject = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  /* X */
  let _temp21 = CreateDataPropertyOrThrow(resultObject, Value('read'), F(result.Read));
  /* node:coverage ignore next */
  if (_temp21 && typeof _temp21 === 'object' && 'next' in _temp21) _temp21 = skipDebugger(_temp21);
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(resultObject, Value('read'), F(result.Read)) returned an abrupt completion", {
    cause: _temp21
  });
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  /* X */
  let _temp22 = CreateDataPropertyOrThrow(resultObject, Value('written'), F(written));
  /* node:coverage ignore next */
  if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) _temp22 = skipDebugger(_temp22);
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(resultObject, Value('written'), F(written)) returned an abrupt completion", {
    cause: _temp22
  });
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  return resultObject;
}
Uint8Array_prototype_setFromHex.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.setfromhex';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-validateuint8array */
function ValidateUint8Array(ta) {
  /* ReturnIfAbrupt */
  let _temp23 = RequireInternalSlot(ta, 'TypedArrayName');
  /* node:coverage ignore next */
  if (_temp23 && typeof _temp23 === 'object' && 'next' in _temp23) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp23 instanceof AbruptCompletion) return _temp23;
  /* node:coverage ignore next */
  if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
  if (ta.TypedArrayName.stringValue() !== 'Uint8Array') {
    return surroundingAgent.Throw('TypeError', 'NotUint8Array');
  }
  return undefined;
}
ValidateUint8Array.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-validateuint8array';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-getuint8arraybytes */
function GetUint8ArrayBytes(ta) {
  const buffer = ta.ViewedArrayBuffer;
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(ta);
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return surroundingAgent.Throw('TypeError', 'TypedArrayOutOfBounds');
  }
  const len = TypedArrayLength(taRecord);
  const byteOffset = ta.ByteOffset;
  const bytes = [];
  let index = 0;
  while (index < len) {
    const byteIndex = byteOffset + index;
    const byte = R(GetValueFromBuffer(buffer, byteIndex, 'Uint8'));
    Assert(typeof byte === 'number', "typeof byte === 'number'");
    bytes.push(byte);
    index += 1;
  }
  return bytes;
}
GetUint8ArrayBytes.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-getuint8arraybytes';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-writeuint8arraybytes */
function* SetUint8ArrayBytes(into, bytes) {
  const offset = into.ByteOffset;
  const len = bytes.length;
  let index = 0;
  while (index < len) {
    const byte = bytes[index];
    const byteIndexInBuffer = index + offset;
    yield* SetValueInBuffer(into.ViewedArrayBuffer, byteIndexInBuffer, 'Uint8', F(byte));
    index += 1;
  }
}
SetUint8ArrayBytes.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-writeuint8arraybytes';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-skipasciiwhitespace */
function SkipAsciiWhitespace(string, index) {
  const length = string.length;
  while (index < length) {
    const char = string.charCodeAt(index);
    if (char !== 0x09 && char !== 0x0A && char !== 0x0C && char !== 0x0D && char !== 0x20) {
      return index;
    }
    index += 1;
  }
  return index;
}
SkipAsciiWhitespace.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-skipasciiwhitespace';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-decodebase64chunk */
function DecodeBase64Chunk(chunk, throwOnExtraBits) {
  const chunkLength = chunk.length;
  if (chunkLength === 2) {
    chunk += 'AA';
  } else if (chunkLength === 3) {
    chunk += 'A';
  } else {
    Assert(chunkLength === 4, "chunkLength === 4");
  }
  const byteSequence = [...atob(chunk)].map(c => c.charCodeAt(0));
  const bytes = [...byteSequence];
  if (chunkLength === 2) {
    Assert(throwOnExtraBits !== undefined, "throwOnExtraBits !== undefined");
    if (throwOnExtraBits && bytes[1] !== 0) {
      return surroundingAgent.Throw('SyntaxError', 'InvalidBase64String');
    }
    return [bytes[0]];
  } else if (chunkLength === 3) {
    Assert(throwOnExtraBits !== undefined, "throwOnExtraBits !== undefined");
    if (throwOnExtraBits && bytes[2] !== 0) {
      return surroundingAgent.Throw('SyntaxError', 'InvalidBase64String');
    }
    return [bytes[0], bytes[1]];
  }
  return bytes;
}
DecodeBase64Chunk.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-decodebase64chunk';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64 */
function FromBase64(string, alphabet, lastChunkHandling, maxLength = 2 ** 53 - 1) {
  if (maxLength === 0) {
    return {
      Read: 0,
      Bytes: [],
      Error: undefined
    };
  }
  let read = 0;
  const bytes = [];
  let chunk = '';
  let chunkLength = 0;
  let index = 0;
  const length = string.length;
  while (true) {
    index = SkipAsciiWhitespace(string, index);
    if (index === length) {
      if (chunkLength > 0) {
        if (lastChunkHandling === 'stop-before-partial') {
          return {
            Read: read,
            Bytes: bytes,
            Error: undefined
          };
        } else if (lastChunkHandling === 'loose') {
          if (chunkLength === 1) {
            const error = surroundingAgent.Throw('SyntaxError', 'InvalidBase64String').Value;
            return {
              Read: read,
              Bytes: bytes,
              Error: error
            };
          }
          /* X */
          let _temp24 = DecodeBase64Chunk(chunk, false);
          /* node:coverage ignore next */
          if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) _temp24 = skipDebugger(_temp24);
          /* node:coverage ignore next */
          if (_temp24 instanceof AbruptCompletion) throw new Assert.Error("! DecodeBase64Chunk(chunk, false) returned an abrupt completion", {
            cause: _temp24
          });
          /* node:coverage ignore next */
          if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
          bytes.push(..._temp24);
        } else {
          Assert(lastChunkHandling === 'strict', "lastChunkHandling === 'strict'");
          const error = surroundingAgent.Throw('SyntaxError', 'InvalidBase64String').Value;
          return {
            Read: read,
            Bytes: bytes,
            Error: error
          };
        }
      }
      return {
        Read: length,
        Bytes: bytes,
        Error: undefined
      };
    }
    let char = string.substring(index, index + 1);
    index += 1;
    if (char === '=') {
      if (chunkLength < 2) {
        const error = surroundingAgent.Throw('SyntaxError', 'InvalidBase64String').Value;
        return {
          Read: read,
          Bytes: bytes,
          Error: error
        };
      }
      index = SkipAsciiWhitespace(string, index);
      if (chunkLength === 2) {
        if (index === length) {
          if (lastChunkHandling === 'stop-before-partial') {
            return {
              Read: read,
              Bytes: bytes,
              Error: undefined
            };
          }
          const error = surroundingAgent.Throw('SyntaxError', 'InvalidBase64String').Value;
          return {
            Read: read,
            Bytes: bytes,
            Error: error
          };
        }
        char = string.substring(index, index + 1);
        if (char === '=') {
          index = SkipAsciiWhitespace(string, index + 1);
        }
      }
      if (index < length) {
        const error = surroundingAgent.Throw('SyntaxError', 'InvalidBase64String').Value;
        return {
          Read: read,
          Bytes: bytes,
          Error: error
        };
      }
      let throwOnExtraBits;
      if (lastChunkHandling === 'strict') {
        throwOnExtraBits = true;
      } else {
        throwOnExtraBits = false;
      }
      const decodeResult = EnsureCompletion(DecodeBase64Chunk(chunk, throwOnExtraBits));
      if (decodeResult instanceof ThrowCompletion) {
        return {
          Read: read,
          Bytes: bytes,
          Error: decodeResult.Value
        };
      }
      /* X */
      let _temp25 = decodeResult;
      /* node:coverage ignore next */
      if (_temp25 && typeof _temp25 === 'object' && 'next' in _temp25) _temp25 = skipDebugger(_temp25);
      /* node:coverage ignore next */
      if (_temp25 instanceof AbruptCompletion) throw new Assert.Error("! decodeResult returned an abrupt completion", {
        cause: _temp25
      });
      /* node:coverage ignore next */
      if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
      bytes.push(..._temp25);
      return {
        Read: length,
        Bytes: bytes,
        Error: undefined
      };
    }
    if (alphabet === 'base64url') {
      if (char === '+' || char === '/') {
        const error = surroundingAgent.Throw('SyntaxError', 'InvalidBase64String').Value;
        return {
          Read: read,
          Bytes: bytes,
          Error: error
        };
      } else if (char === '-') {
        char = '+';
      } else if (char === '_') {
        char = '/';
      }
    }
    if (!/[A-Za-z0-9+/]/.test(char)) {
      const error = surroundingAgent.Throw('SyntaxError', 'InvalidBase64String').Value;
      return {
        Read: read,
        Bytes: bytes,
        Error: error
      };
    }
    const remaining = maxLength - bytes.length;
    if (remaining === 1 && chunkLength === 2 || remaining === 2 && chunkLength === 3) {
      return {
        Read: read,
        Bytes: bytes,
        Error: undefined
      };
    }
    chunk += char;
    chunkLength = chunk.length;
    if (chunkLength === 4) {
      /* X */
      let _temp26 = DecodeBase64Chunk(chunk);
      /* node:coverage ignore next */
      if (_temp26 && typeof _temp26 === 'object' && 'next' in _temp26) _temp26 = skipDebugger(_temp26);
      /* node:coverage ignore next */
      if (_temp26 instanceof AbruptCompletion) throw new Assert.Error("! DecodeBase64Chunk(chunk) returned an abrupt completion", {
        cause: _temp26
      });
      /* node:coverage ignore next */
      if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
      bytes.push(..._temp26);
      chunk = '';
      chunkLength = 0;
      read = index;
      if (bytes.length === maxLength) {
        return {
          Read: read,
          Bytes: bytes,
          Error: undefined
        };
      }
    }
  }
}
FromBase64.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-fromhex */
function FromHex(string, maxLength = 2 ** 53 - 1) {
  const length = string.length;
  const bytes = [];
  let read = 0;
  if (length % 2 !== 0) {
    const error = surroundingAgent.Throw('SyntaxError', 'InvalidHexString').Value;
    return {
      Read: read,
      Bytes: bytes,
      Error: error
    };
  }
  while (read < length && bytes.length < maxLength) {
    const hexits = string.substring(read, read + 2);
    if ([...hexits].some(c => !/[0-9a-fA-F]/.test(c))) {
      const error = surroundingAgent.Throw('SyntaxError', 'InvalidHexString').Value;
      return {
        Read: read,
        Bytes: bytes,
        Error: error
      };
    }
    read += 2;
    const byte = parseInt(hexits, 16);
    bytes.push(byte);
  }
  return {
    Read: read,
    Bytes: bytes,
    Error: undefined
  };
}
FromHex.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-fromhex';
/** https://tc39.es/proposal-arraybuffer-base64/spec/#sec-getoptionsobject */
function GetOptionsObject(options) {
  if (options instanceof UndefinedValue) {
    return OrdinaryObjectCreate(Value.null);
  }
  if (options instanceof ObjectValue) {
    return options;
  }
  return surroundingAgent.Throw('TypeError', 'NotAnObject', options);
}
GetOptionsObject.section = 'https://tc39.es/proposal-arraybuffer-base64/spec/#sec-getoptionsobject';
function bootstrapUint8Array(realmRec) {
  if (!surroundingAgent.feature('uint8array-base64')) {
    return;
  }
  const proto = realmRec.Intrinsics['%Uint8Array.prototype%'];
  const constructor = realmRec.Intrinsics['%Uint8Array%'];
  assignProps(realmRec, proto, [['toBase64', Uint8Array_prototype_toBase64, 0], ['setFromBase64', Uint8Array_prototype_setFromBase64, 1], ['toHex', Uint8Array_prototype_toHex, 0], ['setFromHex', Uint8Array_prototype_setFromHex, 1]]);
  assignProps(realmRec, constructor, [['fromBase64', Uint8Array_fromBase64, 1], ['fromHex', Uint8Array_fromHex, 1]]);
}

function isDataViewObject(V) {
  return 'DataView' in V;
}
/** https://tc39.es/ecma262/#sec-dataview-constructor */
function* DataViewConstructor([buffer = Value.undefined, byteOffset = Value.undefined, byteLength = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. Perform ? RequireInternalSlot(buffer, [[ArrayBufferData]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(buffer, 'ArrayBufferData');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Let offset be ? ToIndex(byteOffset).
  /* ReturnIfAbrupt */
  let _temp2 = yield* ToIndex(byteOffset);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const offset = _temp2;
  if (IsDetachedBuffer(buffer) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }
  // 5. Let bufferByteLength be buffer.[[ArrayBufferByteLength]].
  const bufferByteLength = buffer.ArrayBufferByteLength;
  // 6. If offset > bufferByteLength, throw a RangeError exception.
  if (offset > bufferByteLength) {
    return surroundingAgent.Throw('RangeError', 'DataViewOOB');
  }
  let viewByteLength;
  // 7. If byteLength is undefined, then
  if (byteLength === Value.undefined) {
    // a. Let viewByteLength be bufferByteLength - offset.
    viewByteLength = bufferByteLength - offset;
  } else {
    /* ReturnIfAbrupt */
    let _temp3 = yield* ToIndex(byteLength);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // a. Let viewByteLength be ? ToIndex(byteLength).
    viewByteLength = _temp3;
    // b. If offset + viewByteLength > bufferByteLength, throw a RangeError exception.
    if (offset + viewByteLength > bufferByteLength) {
      return surroundingAgent.Throw('RangeError', 'DataViewOOB');
    }
  }
  // 9. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%DataView.prototype%", « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).
  /* ReturnIfAbrupt */
  let _temp4 = yield* OrdinaryCreateFromConstructor(NewTarget, '%DataView.prototype%', ['DataView', 'ViewedArrayBuffer', 'ByteLength', 'ByteOffset']);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  const O = _temp4;
  // 10. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
  if (IsDetachedBuffer(buffer) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }
  // 11. Set O.[[ViewedArrayBuffer]] to buffer.
  O.ViewedArrayBuffer = buffer;
  // 12. Set O.[[ByteLength]] to viewByteLength.
  O.ByteLength = viewByteLength;
  // 13. Set O.[[ByteOffset]] to offset.
  O.ByteOffset = offset;
  // 14. Return O.
  return O;
}
DataViewConstructor.section = 'https://tc39.es/ecma262/#sec-dataview-constructor';
function bootstrapDataView(realmRec) {
  const dvConstructor = bootstrapConstructor(realmRec, DataViewConstructor, 'DataView', 1, realmRec.Intrinsics['%DataView.prototype%'], []);
  realmRec.Intrinsics['%DataView%'] = dvConstructor;
}

/** https://tc39.es/ecma262/#sec-get-dataview.prototype.buffer */
function DataViewProto_buffer(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[DataView]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(O, 'DataView');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Assert: O has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  // 4. Let buffer be O.[[ViewedArrayBuffer]].
  const buffer = O.ViewedArrayBuffer;
  // 5. Return buffer.
  return buffer;
}
DataViewProto_buffer.section = 'https://tc39.es/ecma262/#sec-get-dataview.prototype.buffer';
/** https://tc39.es/ecma262/#sec-get-dataview.prototype.bytelength */
function* DataViewProto_byteLength(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[DataView]]).
  /* ReturnIfAbrupt */
  let _temp2 = RequireInternalSlot(O, 'DataView');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 3. Assert: O has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  // 4. Let buffer be O.[[ViewedArrayBuffer]].
  const buffer = O.ViewedArrayBuffer;
  // 5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
  if (IsDetachedBuffer(buffer) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }
  // 6. Let size be O.[[ByteLength]].
  const size = O.ByteLength;
  // 7. Return 𝔽(size).
  return F(size);
}
DataViewProto_byteLength.section = 'https://tc39.es/ecma262/#sec-get-dataview.prototype.bytelength';
/** https://tc39.es/ecma262/#sec-get-dataview.prototype.byteoffset */
function* DataViewProto_byteOffset(_args, {
  thisValue
}) {
  // 1. Let O be the this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[DataView]]).
  /* ReturnIfAbrupt */
  let _temp3 = RequireInternalSlot(O, 'DataView');
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 3. Assert: O has a [[ViewedArrayBuffer]] internal slot.
  Assert('ViewedArrayBuffer' in O, "'ViewedArrayBuffer' in O");
  // 4. Let buffer be O.[[ViewedArrayBuffer]].
  const buffer = O.ViewedArrayBuffer;
  // 5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
  if (IsDetachedBuffer(buffer) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'ArrayBufferDetached');
  }
  // 6. Let offset be O.[[ByteOffset]].
  const offset = O.ByteOffset;
  // 7. Return 𝔽(offset).
  return F(offset);
}
DataViewProto_byteOffset.section = 'https://tc39.es/ecma262/#sec-get-dataview.prototype.byteoffset';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getbigint64 */
function* DataViewProto_getBigInt64([byteOffset = Value.undefined, littleEndian = Value.undefined], {
  thisValue
}) {
  // 1. Let v be the this value.
  const v = thisValue;
  // 2. Return ? GetViewValue(v, byteOffset, littleEndian, BigInt64).
  return yield* GetViewValue(v, byteOffset, littleEndian, 'BigInt64');
}
DataViewProto_getBigInt64.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getbigint64';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getbiguint64 */
function* DataViewProto_getBigUint64([byteOffset = Value.undefined, littleEndian = Value.undefined], {
  thisValue
}) {
  // 1. Let v be the this value.
  const v = thisValue;
  // 2. Return ? GetViewValue(v, byteOffset, littleEndian, BigUint64).
  return yield* GetViewValue(v, byteOffset, littleEndian, 'BigUint64');
}
DataViewProto_getBigUint64.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getbiguint64';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getfloat32 */
function* DataViewProto_getFloat32([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* GetViewValue(v, byteOffset, littleEndian, 'Float32');
}
DataViewProto_getFloat32.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getfloat32';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getfloat64 */
function* DataViewProto_getFloat64([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* GetViewValue(v, byteOffset, littleEndian, 'Float64');
}
DataViewProto_getFloat64.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getfloat64';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getint8 */
function* DataViewProto_getInt8([byteOffset = Value.undefined], {
  thisValue
}) {
  const v = thisValue;
  return yield* GetViewValue(v, byteOffset, Value.true, 'Int8');
}
DataViewProto_getInt8.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getint8';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getint16 */
function* DataViewProto_getInt16([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* GetViewValue(v, byteOffset, littleEndian, 'Int16');
}
DataViewProto_getInt16.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getint16';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getint32 */
function* DataViewProto_getInt32([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* GetViewValue(v, byteOffset, littleEndian, 'Int32');
}
DataViewProto_getInt32.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getint32';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getuint8 */
function* DataViewProto_getUint8([byteOffset = Value.undefined], {
  thisValue
}) {
  const v = thisValue;
  return yield* GetViewValue(v, byteOffset, Value.true, 'Uint8');
}
DataViewProto_getUint8.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getuint8';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getuint16 */
function* DataViewProto_getUint16([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* GetViewValue(v, byteOffset, littleEndian, 'Uint16');
}
DataViewProto_getUint16.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getuint16';
/** https://tc39.es/ecma262/#sec-dataview.prototype.getuint32 */
function* DataViewProto_getUint32([byteOffset = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* GetViewValue(v, byteOffset, littleEndian, 'Uint32');
}
DataViewProto_getUint32.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.getuint32';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setbigint64 */
function* DataViewProto_setBigInt64([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  // 1. Let v be the this value.
  const v = thisValue;
  // 2. If littleEndian is not present, set littleEndian to undefined.
  if (littleEndian === undefined) {
    littleEndian = Value.undefined;
  }
  // 3. Return ? SetViewValue(v, byteOffset, littleEndian, BigInt64, value).
  return yield* SetViewValue(v, byteOffset, littleEndian, 'BigInt64', value);
}
DataViewProto_setBigInt64.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setbigint64';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setbiguint64 */
function* DataViewProto_setBigUint64([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  // 1. Let v be the this value.
  const v = thisValue;
  // 2. If littleEndian is not present, set littleEndian to undefined.
  if (littleEndian === undefined) {
    littleEndian = Value.undefined;
  }
  // 3. Return ? SetViewValue(v, byteOffset, littleEndian, BigUint64, value).
  return yield* SetViewValue(v, byteOffset, littleEndian, 'BigUint64', value);
}
DataViewProto_setBigUint64.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setbiguint64';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setfloat32 */
function* DataViewProto_setFloat32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* SetViewValue(v, byteOffset, littleEndian, 'Float32', value);
}
DataViewProto_setFloat32.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setfloat32';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setfloat64 */
function* DataViewProto_setFloat64([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* SetViewValue(v, byteOffset, littleEndian, 'Float64', value);
}
DataViewProto_setFloat64.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setfloat64';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setint8 */
function* DataViewProto_setInt8([byteOffset = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  const v = thisValue;
  return yield* SetViewValue(v, byteOffset, Value.true, 'Int8', value);
}
DataViewProto_setInt8.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setint8';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setint16 */
function* DataViewProto_setInt16([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* SetViewValue(v, byteOffset, littleEndian, 'Int16', value);
}
DataViewProto_setInt16.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setint16';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setint32 */
function* DataViewProto_setInt32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* SetViewValue(v, byteOffset, littleEndian, 'Int32', value);
}
DataViewProto_setInt32.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setint32';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setuint8 */
function* DataViewProto_setUint8([byteOffset = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  const v = thisValue;
  return yield* SetViewValue(v, byteOffset, Value.true, 'Uint8', value);
}
DataViewProto_setUint8.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setuint8';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setuint16 */
function* DataViewProto_setUint16([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* SetViewValue(v, byteOffset, littleEndian, 'Uint16', value);
}
DataViewProto_setUint16.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setuint16';
/** https://tc39.es/ecma262/#sec-dataview.prototype.setuint32 */
function* DataViewProto_setUint32([byteOffset = Value.undefined, value = Value.undefined, littleEndian], {
  thisValue
}) {
  const v = thisValue;
  if (littleEndian === undefined) {
    littleEndian = Value.false;
  }
  return yield* SetViewValue(v, byteOffset, littleEndian, 'Uint32', value);
}
DataViewProto_setUint32.section = 'https://tc39.es/ecma262/#sec-dataview.prototype.setuint32';
function bootstrapDataViewPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['buffer', [DataViewProto_buffer]], ['byteLength', [DataViewProto_byteLength]], ['byteOffset', [DataViewProto_byteOffset]], ['getBigInt64', DataViewProto_getBigInt64, 1], ['getBigUint64', DataViewProto_getBigUint64, 1], ['getFloat32', DataViewProto_getFloat32, 1], ['getFloat64', DataViewProto_getFloat64, 1], ['getInt8', DataViewProto_getInt8, 1], ['getInt16', DataViewProto_getInt16, 1], ['getInt32', DataViewProto_getInt32, 1], ['getUint8', DataViewProto_getUint8, 1], ['getUint16', DataViewProto_getUint16, 1], ['getUint32', DataViewProto_getUint32, 1], ['setBigInt64', DataViewProto_setBigInt64, 2], ['setBigUint64', DataViewProto_setBigUint64, 2], ['setFloat32', DataViewProto_setFloat32, 2], ['setFloat64', DataViewProto_setFloat64, 2], ['setInt8', DataViewProto_setInt8, 2], ['setInt16', DataViewProto_setInt16, 2], ['setInt32', DataViewProto_setInt32, 2], ['setUint8', DataViewProto_setUint8, 2], ['setUint16', DataViewProto_setUint16, 2], ['setUint32', DataViewProto_setUint32, 2]], realmRec.Intrinsics['%Object.prototype%'], 'DataView');
  realmRec.Intrinsics['%DataView.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-weakmap.prototype.delete */
function WeakMapProto_delete([key = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[WeakMapData]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(M, 'WeakMapData');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. If CanBeHeldWeakly(key) is false, return false.
  if (CanBeHeldWeakly(key) === Value.false) {
    return Value.false;
  }
  // 4. For each Record { [[Key]], [[Value]] } p that is an element of entries, do
  const entries = M.WeakMapData;
  for (let i = 0; i < entries.length; i += 1) {
    const p = entries[i];
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, then
    if (p.Key !== undefined && SameValue(p.Key, key) === Value.true) {
      /* ReturnIfAbrupt */
      let _temp2 = surroundingAgent.debugger_tryTouchDuringPreview(M);
      /* node:coverage ignore next */
      if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      p.Key = undefined;
      // ii. Set p.[[Value]] to empty.
      p.Value = undefined;
      // iii. return true.
      return Value.true;
    }
  }
  // 5. Return false.
  return Value.false;
}
WeakMapProto_delete.section = 'https://tc39.es/ecma262/#sec-weakmap.prototype.delete';
/** https://tc39.es/ecma262/#sec-weakmap.prototype.get */
function WeakMapProto_get([key = Value.undefined], {
  thisValue
}) {
  // 1. Let m be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[WeakMapData]]).
  /* ReturnIfAbrupt */
  let _temp3 = RequireInternalSlot(M, 'WeakMapData');
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 3. If CanBeHeldWeakly(key) is false, return false.
  if (CanBeHeldWeakly(key) === Value.false) {
    return Value.undefined;
  }
  // 4. For each Record { [[Key]], [[Value]] } p of M.[[WeakMapData]], do
  const entries = M.WeakMapData;
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return p.[[Value]].
    if (p.Key !== undefined && SameValue(p.Key, key) === Value.true) {
      return p.Value;
    }
  }
  // 6. Return undefined.
  return Value.undefined;
}
WeakMapProto_get.section = 'https://tc39.es/ecma262/#sec-weakmap.prototype.get';
/** https://tc39.es/proposal-upsert/#sec-weakmap.prototype.getOrInsert */
function WeakMapProto_getOrInsert([key = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  // 1. Let m be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[WeakMapData]]).
  /* ReturnIfAbrupt */
  let _temp4 = RequireInternalSlot(M, 'WeakMapData');
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 3. If CanBeHeldWeakly(key) is false, throw a TypeError exception.
  if (CanBeHeldWeakly(key) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAWeakKey', key);
  }
  // 4. For each Record { [[Key]], [[Value]] } p of M.[[WeakMapData]], do
  const entries = M.WeakMapData;
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return p.[[Value]].
    if (p.Key !== undefined && SameValue(p.Key, key) === Value.true) {
      return p.Value;
    }
  }
  // 5. Let p be the Record { [[Key]]: key, [[Value]]: value }.
  const p = {
    Key: key,
    Value: value
  };
  // 6. Append p to M.[[WeakMapData]].
  entries.push(p);
  // 7. Return value.
  return value;
}
WeakMapProto_getOrInsert.section = 'https://tc39.es/proposal-upsert/#sec-weakmap.prototype.getOrInsert';
/**  https://tc39.es/proposal-upsert/#sec-weakmap.prototype.getOrInsertComputed */
function* WeakMapProto_getOrInsertComputed([key = Value.undefined, callbackfn = Value.undefined], {
  thisValue
}) {
  // 1. Let m be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[WeakMapData]]).
  /* ReturnIfAbrupt */
  let _temp5 = RequireInternalSlot(M, 'WeakMapData');
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 3. If CanBeHeldWeakly(key) is false, throw a TypeError exception.
  if (CanBeHeldWeakly(key) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAWeakKey', key);
  }
  // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
  if (!IsCallable(callbackfn)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callbackfn);
  }
  // 5. For each Record { [[Key]], [[Value]] } p of M.[[WeakMapData]], do
  const entries = M.WeakMapData;
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return p.[[Value]].
    if (p.Key !== undefined && SameValue(p.Key, key) === Value.true) {
      return p.Value;
    }
  }
  // 6. Let value be ? Call(callbackfn, undefined, « key »).
  /* ReturnIfAbrupt */
  let _temp6 = yield* Call(callbackfn, Value.undefined, [key]);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const value = _temp6;
  // 7. NOTE: The Map may have been modified during execution of callbackfn.
  // 8. For each Record { [[Key]], [[Value]] } p of M.[[WeakMapData]], do
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, then
    if (p.Key !== undefined && SameValue(p.Key, key) === Value.true) {
      // i. Set p.[[Value]] to value.
      p.Value = value;
      // ii. Return value.
      return value;
    }
  }
  // 9. Let p be the Record { [[Key]]: key, [[Value]]: value }.
  const p = {
    Key: key,
    Value: value
  };
  // 10. Append p to M.[[WeakMapData]].
  entries.push(p);
  // 11. Return value.
  return value;
}
WeakMapProto_getOrInsertComputed.section = 'https://tc39.es/proposal-upsert/#sec-weakmap.prototype.getOrInsertComputed';
/** https://tc39.es/ecma262/#sec-weakmap.prototype.has */
function WeakMapProto_has([key = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[WeakMapData]]).
  /* ReturnIfAbrupt */
  let _temp7 = RequireInternalSlot(M, 'WeakMapData');
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 3. If CanBeHeldWeakly(key) is false, return false.
  if (CanBeHeldWeakly(key) === Value.false) {
    return Value.false;
  }
  // 4. For each Record { [[Key]], [[Value]] } p of M.[[WeakMapData]], do
  const entries = M.WeakMapData;
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return true.
    if (p.Key !== undefined && SameValue(p.Key, key) === Value.true) {
      return Value.true;
    }
  }
  // 6. Return false.
  return Value.false;
}
WeakMapProto_has.section = 'https://tc39.es/ecma262/#sec-weakmap.prototype.has';
/** https://tc39.es/ecma262/#sec-weakmap.prototype.set */
function WeakMapProto_set([key = Value.undefined, value = Value.undefined], {
  thisValue
}) {
  // 1. Let M be the this value.
  const M = thisValue;
  // 2. Perform ? RequireInternalSlot(M, [[WeakMapData]]).
  /* ReturnIfAbrupt */
  let _temp8 = RequireInternalSlot(M, 'WeakMapData');
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 3. If CanBeHeldWeakly(key) is false, throw a TypeError exception.
  if (CanBeHeldWeakly(key) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'WeakCollectionNotObject', key);
  }
  // 4. For each Record { [[Key]], [[Value]] } p that is an element of entries, do
  const entries = M.WeakMapData;
  for (const p of entries) {
    // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, then
    if (p.Key !== undefined && SameValue(p.Key, key) === Value.true) {
      /* ReturnIfAbrupt */
      let _temp9 = surroundingAgent.debugger_tryTouchDuringPreview(M);
      /* node:coverage ignore next */
      if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp9 instanceof AbruptCompletion) return _temp9;
      /* node:coverage ignore next */
      if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
      p.Value = value;
      // ii. Return M.
      return M;
    }
  }
  // 5. Let p be the Record { [[Key]]: key, [[Value]]: value }.
  const p = {
    Key: key,
    Value: value
  };
  // 7. Append p as the last element of entries.
  entries.push(p);
  // 7. Return M.
  return M;
}
WeakMapProto_set.section = 'https://tc39.es/ecma262/#sec-weakmap.prototype.set';
function bootstrapWeakMapPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['delete', WeakMapProto_delete, 1], ['get', WeakMapProto_get, 1], ['getOrInsert', WeakMapProto_getOrInsert, 2], ['getOrInsertComputed', WeakMapProto_getOrInsertComputed, 2], ['has', WeakMapProto_has, 1], ['set', WeakMapProto_set, 2]], realmRec.Intrinsics['%Object.prototype%'], 'WeakMap');
  realmRec.Intrinsics['%WeakMap.prototype%'] = proto;
}

function isWeakMapObject(object) {
  return 'WeakMapData' in object;
}
/** https://tc39.es/ecma262/#sec-weakmap-constructor */
function* WeakMapConstructor([iterable = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. Let map be ? OrdinaryCreateFromConstructor(NewTarget, "%WeakMap.prototype%", « [[WeakMapData]] »).
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(NewTarget, '%WeakMap.prototype%', ['WeakMapData']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const map = _temp;
  // 3. Set map.[[WeakMapData]] to a new empty List.
  map.WeakMapData = [];
  // 4. If iterable is either undefined or null, return map.
  if (iterable === Value.undefined || iterable === Value.null) {
    return map;
  }
  // 5. Let adder be ? Get(map, "set").
  /* ReturnIfAbrupt */
  let _temp2 = yield* Get(map, Value('set'));
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const adder = _temp2;
  if (!IsCallable(adder)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', adder);
  }
  // 6. Return ? AddEntriesFromIterable(map, iterable, adder).
  return yield* AddEntriesFromIterable(map, iterable, adder);
}
WeakMapConstructor.section = 'https://tc39.es/ecma262/#sec-weakmap-constructor';
function bootstrapWeakMap(realmRec) {
  const c = bootstrapConstructor(realmRec, WeakMapConstructor, 'WeakMap', 0, realmRec.Intrinsics['%WeakMap.prototype%'], []);
  realmRec.Intrinsics['%WeakMap%'] = c;
}

/** https://tc39.es/ecma262/#sec-weakset.prototype.add */
function WeakSetProto_add([value = Value.undefined], {
  thisValue
}) {
  // 1. Let S be this value.
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[WeakSetData]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(S, 'WeakSetData');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. If CanBeHeldWeakly(value) is false, throw a TypeError exception.
  if (CanBeHeldWeakly(value) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'WeakCollectionNotObject', value);
  }
  // 4. For each e that is an element of entries, do
  const entries = S.WeakSetData;
  for (const e of entries) {
    // a. If e is not empty and SameValue(e, value) is true, then
    if (e !== undefined && SameValue(e, value) === Value.true) {
      // i. Return S.
      return S;
    }
  }
  // 6. Append value as the last element of entries.
  entries.push(value);
  // 6. Return S.
  return S;
}
WeakSetProto_add.section = 'https://tc39.es/ecma262/#sec-weakset.prototype.add';
/** https://tc39.es/ecma262/#sec-weakset.prototype.delete */
function WeakSetProto_delete([value = Value.undefined], {
  thisValue
}) {
  // 1. Let S be the this value.`
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[WeakSetData]]).
  /* ReturnIfAbrupt */
  let _temp2 = RequireInternalSlot(S, 'WeakSetData');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 3. If CanBeHeldWeakly(value) is false, return false.
  if (CanBeHeldWeakly(value) === Value.false) {
    return Value.false;
  }
  // 4. For each element e of S.[[WeakSetData]], do
  const entries = S.WeakSetData;
  for (let i = 0; i < entries.length; i += 1) {
    const e = entries[i];
    // i. If e is not empty and SameValue(e, value) is true, then
    if (e !== undefined && SameValue(e, value) === Value.true) {
      /* ReturnIfAbrupt */
      let _temp3 = surroundingAgent.debugger_tryTouchDuringPreview(S);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) return _temp3;
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      entries[i] = undefined;
      // ii. Return true.
      return Value.true;
    }
  }
  // 5. Return false.
  return Value.false;
}
WeakSetProto_delete.section = 'https://tc39.es/ecma262/#sec-weakset.prototype.delete';
/** https://tc39.es/ecma262/#sec-weakset.prototype.has */
function WeakSetProto_has([value = Value.undefined], {
  thisValue
}) {
  // 1. Let S be the this value.
  const S = thisValue;
  // 2. Perform ? RequireInternalSlot(S, [[WeakSetData]]).
  /* ReturnIfAbrupt */
  let _temp4 = RequireInternalSlot(S, 'WeakSetData');
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 3. If CanBeHeldWeakly(value) is false, return false.
  if (CanBeHeldWeakly(value) === Value.false) {
    return Value.false;
  }
  // 4. For each element e of S.[[WeakSetData]], do
  const entries = S.WeakSetData;
  for (const e of entries) {
    // a. If e is not empty and SameValue(e, value) is true, return true.
    if (e !== undefined && SameValue(e, value) === Value.true) {
      return Value.true;
    }
  }
  // 5. Return false.
  return Value.false;
}
WeakSetProto_has.section = 'https://tc39.es/ecma262/#sec-weakset.prototype.has';
function bootstrapWeakSetPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['add', WeakSetProto_add, 1], ['delete', WeakSetProto_delete, 1], ['has', WeakSetProto_has, 1]], realmRec.Intrinsics['%Object.prototype%'], 'WeakSet');
  realmRec.Intrinsics['%WeakSet.prototype%'] = proto;
}

function isWeakSetObject(object) {
  return 'WeakSetData' in object;
}
/** https://tc39.es/ecma262/#sec-weakset-iterable */
function* WeakSetConstructor([iterable = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. Let set be ? OrdinaryCreateFromConstructor(NewTarget, "%WeakSet.prototype%", « [[WeakSetData]] »).
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(NewTarget, '%WeakSet.prototype%', ['WeakSetData']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const set = _temp;
  // 3. Set set.[[WeakSetData]] to a new empty List.
  set.WeakSetData = [];
  // 4. If iterable is either undefined or null, return set.
  if (iterable === Value.undefined || iterable === Value.null) {
    return set;
  }
  // 5. Let adder be ? Get(set, "add").
  /* ReturnIfAbrupt */
  let _temp2 = yield* Get(set, Value('add'));
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const adder = _temp2;
  // 6. If IsCallable(adder) is false, throw a TypeError exception.
  if (!IsCallable(adder)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', adder);
  }
  // 7. Let iteratorRecord be ? GetIterator(iterable).
  /* ReturnIfAbrupt */
  let _temp3 = yield* GetIterator(iterable, 'sync');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const iteratorRecord = _temp3;
  // 8. Repeat,
  while (true) {
    /* ReturnIfAbrupt */
    let _temp4 = yield* IteratorStepValue(iteratorRecord);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // a. Let next be ? IteratorStep(iteratorRecord).
    const next = _temp4;
    // b. If next is false, return set.
    if (next === 'done') {
      return set;
    }
    // d. Let status be Call(adder, set, « next »).
    let status = yield* Call(adder, set, [next]);
    // e. IfAbruptCloseIterator(status, iteratorRecord).
    /* IfAbruptCloseIterator */
    /* node:coverage ignore next */
    if (status instanceof AbruptCompletion) return skipDebugger(IteratorClose(iteratorRecord, status));
    /* node:coverage ignore next */
    if (status instanceof Completion) status = status.Value;
  }
}
WeakSetConstructor.section = 'https://tc39.es/ecma262/#sec-weakset-iterable';
function bootstrapWeakSet(realmRec) {
  const c = bootstrapConstructor(realmRec, WeakSetConstructor, 'WeakSet', 0, realmRec.Intrinsics['%WeakSet.prototype%'], []);
  realmRec.Intrinsics['%WeakSet%'] = c;
}

/** https://tc39.es/ecma262/#sec-aggregate-error-constructor */
function* AggregateErrorConstructor([errors = Value.undefined, message = Value.undefined, options = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
  let newTarget;
  if (NewTarget instanceof UndefinedValue) {
    newTarget = surroundingAgent.activeFunctionObject;
  } else {
    newTarget = NewTarget;
  }
  // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%AggregateError.prototype%", « [[ErrorData]] »).
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(newTarget, '%AggregateError.prototype%', ['ErrorData', 'HostDefinedErrorStack']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const O = _temp;
  // 3. If message is not undefined, then
  if (message !== Value.undefined) {
    /* ReturnIfAbrupt */
    let _temp2 = yield* ToString(message);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) return _temp2;
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // a. Let msg be ? ToString(message).
    const msg = _temp2;
    // b. Perform ! CreateMethodProperty(O, "message", msg).
    /* X */
    let _temp3 = CreateNonEnumerableDataPropertyOrThrow(O, Value('message'), msg);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! CreateNonEnumerableDataPropertyOrThrow(O, Value('message'), msg) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }
  /* ReturnIfAbrupt */
  let _temp4 = yield* InstallErrorCause(O, options);
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  // 4. Let errorsList be ? IterableToList(errors).
  /* ReturnIfAbrupt */
  let _temp8 = yield* GetIterator(errors, 'sync');
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  /* ReturnIfAbrupt */
  let _temp5 = yield* IteratorToList(_temp8);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  const errorsList = _temp5;
  // 5. Perform ! DefinePropertyOrThrow(O, "errors", Property Descriptor { [[Configurable]]: true, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: ! CreateArrayFromList(errorsList) }).
  /* X */
  let _temp6 = DefinePropertyOrThrow(O, Value('errors'), _Descriptor({
    Configurable: Value.true,
    Enumerable: Value.false,
    Writable: Value.true,
    Value: CreateArrayFromList(errorsList)
  }));
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(O, Value('errors'), Descriptor({\n    Configurable: Value.true,\n    Enumerable: Value.false,\n    Writable: Value.true,\n    Value: CreateArrayFromList(errorsList),\n  })) returned an abrupt completion", {
    cause: _temp6
  });
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;

  // NON-SPEC
  const S = captureStack();
  O.HostDefinedErrorStack = S.stack;
  /* X */
  let _temp7 = errorStackToString(O, S.stack, S.nativeStack);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! errorStackToString(O, S.stack, S.nativeStack) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  O.ErrorData = _temp7;

  // 7. Return O.
  return O;
}
AggregateErrorConstructor.section = 'https://tc39.es/ecma262/#sec-aggregate-error-constructor';
function bootstrapAggregateError(realmRec) {
  const c = bootstrapConstructor(realmRec, AggregateErrorConstructor, 'AggregateError', 2, realmRec.Intrinsics['%AggregateError.prototype%'], []);
  c.Prototype = realmRec.Intrinsics['%Error%'];
  realmRec.Intrinsics['%AggregateError%'] = c;
}

function bootstrapAggregateErrorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['name', Value('AggregateError')], ['message', Value('')]], realmRec.Intrinsics['%Error.prototype%'], 'AggregateError');
  realmRec.Intrinsics['%AggregateError.prototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-weak-ref.prototype.deref */
function WeakRefProto_deref(_args, {
  thisValue
}) {
  // 1. Let weakRef be the this value.
  const weakRef = thisValue;
  // 2. Perform ? RequireInternalSlot(weakRef, [[WeakRefTarget]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(weakRef, 'WeakRefTarget');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. Return ! WeakRefDeref(weakRef).
  /* X */
  let _temp2 = WeakRefDeref(weakRef);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! WeakRefDeref(weakRef) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  return _temp2;
}
WeakRefProto_deref.section = 'https://tc39.es/ecma262/#sec-weak-ref.prototype.deref';
function bootstrapWeakRefPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['deref', WeakRefProto_deref, 0]], realmRec.Intrinsics['%Object.prototype%'], 'WeakRef');
  realmRec.Intrinsics['%WeakRef.prototype%'] = proto;
}

function isWeakRef(object) {
  return 'WeakRefTarget' in object && !('HeldValue' in object);
}
/** https://tc39.es/ecma262/#sec-weak-ref-target */
function* WeakRefConstructor([target = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. If CanBeHeldWeakly(target) is false, throw a TypeError exception.
  if (CanBeHeldWeakly(target) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAWeakKey', target);
  }
  // 3. Let weakRef be ? OrdinaryCreateFromConstructor(NewTarget, "%WeakRefPrototype%", « [[WeakRefTarget]] »).
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(NewTarget, '%WeakRef.prototype%', ['WeakRefTarget']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const weakRef = _temp;
  // 4. Perform ! AddToKeptObjects(target).
  /* X */
  let _temp2 = AddToKeptObjects(target);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! AddToKeptObjects(target) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 5. Set weakRef.[[WeakRefTarget]] to target.
  weakRef.WeakRefTarget = target;
  // 6. Return weakRef
  return weakRef;
}
WeakRefConstructor.section = 'https://tc39.es/ecma262/#sec-weak-ref-target';
function bootstrapWeakRef(realmRec) {
  const bigintConstructor = bootstrapConstructor(realmRec, WeakRefConstructor, 'WeakRef', 1, realmRec.Intrinsics['%WeakRef.prototype%'], []);
  realmRec.Intrinsics['%WeakRef%'] = bigintConstructor;
}

/** https://tc39.es/ecma262/#sec-%wrapforvaliditeratorprototype%.next */
function* WrapForValidIteratorPrototype_next(_args, {
  thisValue
}) {
  // 1. Let O be this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[Iterated]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(O, 'Iterated');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const iteratorRecord = O.Iterated;
  // 4. Return ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]]).
  return yield* Call(iteratorRecord.NextMethod, iteratorRecord.Iterator);
}
WrapForValidIteratorPrototype_next.section = 'https://tc39.es/ecma262/#sec-%wrapforvaliditeratorprototype%.next';
/** https://tc39.es/ecma262/#sec-%wrapforvaliditeratorprototype%.return */
function* WrapForValidIteratorPrototype_return(_args, {
  thisValue
}) {
  // 1. Let O be this value.
  const O = thisValue;
  // 2. Perform ? RequireInternalSlot(O, [[Iterated]]).
  /* ReturnIfAbrupt */
  let _temp2 = RequireInternalSlot(O, 'Iterated');
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  const iteratorRecord = O.Iterated;
  const iterator = iteratorRecord.Iterator;
  // 4. Assert: iterator is an Object.
  Assert(iterator instanceof ObjectValue, "iterator instanceof ObjectValue");
  // 5. Let returnMethod be ? GetMethod(iterator, "return").
  /* ReturnIfAbrupt */
  let _temp3 = yield* GetMethod(iterator, Value('return'));
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  const returnMethod = _temp3;
  // 6. If returnMethod is undefined, then
  if (returnMethod instanceof UndefinedValue) {
    // a. Return CreateIteratorResultObject(undefined, true).
    return CreateIteratorResultObject(Value.undefined, Value.true);
  }
  // 7. Return ? Call(returnMethod, iterator).
  return yield* Call(returnMethod, iterator);
}
WrapForValidIteratorPrototype_return.section = 'https://tc39.es/ecma262/#sec-%wrapforvaliditeratorprototype%.return';
function bootstrapWrapForValidIteratorPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [['next', WrapForValidIteratorPrototype_next, 0], ['return', WrapForValidIteratorPrototype_return, 0]], realmRec.Intrinsics['%Iterator.prototype%']);
  realmRec.Intrinsics['%WrapForValidIteratorPrototype%'] = proto;
}

/** https://tc39.es/ecma262/#sec-finalization-registry.prototype.cleanupSome */
function* FinalizationRegistryProto_cleanupSome([callback = Value.undefined], {
  thisValue
}) {
  // 1. Let finalizationRegistry be the this value.
  const finalizationRegistry = thisValue;
  // 2. Perform ? RequireInternalSlot(finalizationRegistry, [[Cells]]).
  /* ReturnIfAbrupt */
  let _temp = RequireInternalSlot(finalizationRegistry, 'Cells');
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  // 3. If callback is present and IsCallable(callback) is false, throw a TypeError exception.
  if (callback !== Value.undefined && !IsCallable(callback)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', callback);
  }
  // 4. Perform ? CleanupFinalizationRegistry(finalizationRegistry, callback).
  /* ReturnIfAbrupt */
  let _temp2 = yield* CleanupFinalizationRegistry(finalizationRegistry, {
    Callback: callback});
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 5. Return *undefined*.
  return Value.undefined;
}
FinalizationRegistryProto_cleanupSome.section = 'https://tc39.es/ecma262/#sec-finalization-registry.prototype.cleanupSome';
/** https://tc39.es/ecma262/#sec-finalization-registry.prototype.register */
function FinalizationRegistryProto_register([target = Value.undefined, heldValue = Value.undefined, unregisterToken = Value.undefined], {
  thisValue
}) {
  // 1. Let finalizationRegistry be the this value.
  const finalizationRegistry = thisValue;
  // 2. Perform ? RequireInternalSlot(finalizationRegistry, [[Cells]]).
  /* ReturnIfAbrupt */
  let _temp3 = RequireInternalSlot(finalizationRegistry, 'Cells');
  /* node:coverage ignore next */
  if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp3 instanceof AbruptCompletion) return _temp3;
  /* node:coverage ignore next */
  if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  // 3. If CanBeHeldWeakly(target) is false, throw a TypeError exception.
  if (CanBeHeldWeakly(target) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAWeakKey', target);
  }
  // 4. If SameValue(target, heldValue), throw a TypeError exception.
  if (SameValue(target, heldValue) === Value.true) {
    return surroundingAgent.Throw('TypeError', 'TargetMatchesHeldValue', heldValue);
  }
  // 5. If CanBeHeldWeakly(unregisterToken) is false, then
  if (CanBeHeldWeakly(unregisterToken) === Value.false) {
    // a. If unregisterToken is not undefined, throw a TypeError exception.
    if (unregisterToken !== Value.undefined) {
      return surroundingAgent.Throw('TypeError', 'NotAWeakKey', unregisterToken);
    }
    // b. Set unregisterToken to empty.
    unregisterToken = undefined;
  }
  // 6. Let cell be the Record { [[WeakRefTarget]] : target, [[HeldValue]]: heldValue, [[UnregisterToken]]: unregisterToken }.
  const cell = {
    WeakRefTarget: target,
    HeldValue: heldValue,
    UnregisterToken: unregisterToken
  };
  // 7. Append cell to finalizationRegistry.[[Cells]].
  /* ReturnIfAbrupt */
  let _temp4 = surroundingAgent.debugger_tryTouchDuringPreview(finalizationRegistry);
  /* node:coverage ignore next */
  if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  finalizationRegistry.Cells.push(cell);
  // 8. Return undefined.
  return Value.undefined;
}
FinalizationRegistryProto_register.section = 'https://tc39.es/ecma262/#sec-finalization-registry.prototype.register';
/** https://tc39.es/ecma262/#sec-finalization-registry.prototype.unregister */
function FinalizationRegistryProto_unregister([unregisterToken = Value.undefined], {
  thisValue
}) {
  // 1. Let finalizationRegistry be the this value.
  const finalizationRegistry = thisValue;
  // 2. Perform ? RequireInternalSlot(finalizationRegistry, [[Cells]]).
  /* ReturnIfAbrupt */
  let _temp5 = RequireInternalSlot(finalizationRegistry, 'Cells');
  /* node:coverage ignore next */
  if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 3. If CanBeHeldWeakly(unregisterToken) is false, throw a TypeError exception.
  if (CanBeHeldWeakly(unregisterToken) === Value.false) {
    return surroundingAgent.Throw('TypeError', 'NotAWeakKey', unregisterToken);
  }
  // 4. Let removed be false.
  let removed = Value.false;
  /* ReturnIfAbrupt */
  let _temp6 = surroundingAgent.debugger_tryTouchDuringPreview(finalizationRegistry);
  /* node:coverage ignore next */
  if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  // 5. For each Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } cell that is an element of finalizationRegistry.[[Cells]], do
  finalizationRegistry.Cells = finalizationRegistry.Cells.filter(cell => {
    let r = true;
    // a. If cell.[[UnregisterToken]] is not empty and SameValue(cell.[[UnregisterToken]], unregisterToken) is true, then
    if (cell.UnregisterToken !== undefined && SameValue(cell.UnregisterToken, unregisterToken) === Value.true) {
      // i. Remove cell from finalizationRegistry.Cells.
      r = false;
      // ii. Set removed to true.
      removed = Value.true;
    }
    return r;
  });
  // 6. Return removed.
  return removed;
}
FinalizationRegistryProto_unregister.section = 'https://tc39.es/ecma262/#sec-finalization-registry.prototype.unregister';
function bootstrapFinalizationRegistryPrototype(realmRec) {
  const proto = bootstrapPrototype(realmRec, [surroundingAgent.feature('cleanup-some') ? ['cleanupSome', FinalizationRegistryProto_cleanupSome, 0] : undefined, ['register', FinalizationRegistryProto_register, 2], ['unregister', FinalizationRegistryProto_unregister, 1]], realmRec.Intrinsics['%Object.prototype%'], 'FinalizationRegistry');
  realmRec.Intrinsics['%FinalizationRegistry.prototype%'] = proto;
}

function isFinalizationRegistryObject(object) {
  return 'Cells' in object;
}
/** https://tc39.es/ecma262/#sec-finalization-registry-cleanup-callback */
function* FinalizationRegistryConstructor([cleanupCallback = Value.undefined], {
  NewTarget
}) {
  // 1. If NewTarget is undefined, throw a TypeError exception.
  if (NewTarget instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'ConstructorNonCallable', this);
  }
  // 2. If IsCallable(cleanupCallback) is false, throw a TypeError exception.
  if (!IsCallable(cleanupCallback)) {
    return surroundingAgent.Throw('TypeError', 'NotAFunction', cleanupCallback);
  }
  // 3. Let finalizationGroup be ? OrdinaryCreateFromConstructor(NewTarget, "%FinalizationRegistryPrototype%", « [[Realm]], [[CleanupCallback]], [[Cells]] »).
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(NewTarget, '%FinalizationRegistry.prototype%', ['Realm', 'CleanupCallback', 'Cells']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const finalizationGroup = _temp;
  // 4. Let fn be the active function object.
  const fn = surroundingAgent.activeFunctionObject;
  // 5. Set finalizationGroup.[[Realm]] to fn.[[Realm]].
  finalizationGroup.Realm = fn.Realm;
  // 6. Set finalizationGroup.[[CleanupCallback]] to HostMakeJobCallback(cleanupCallback).
  finalizationGroup.CleanupCallback = HostMakeJobCallback(cleanupCallback);
  // 7. Set finalizationGroup.[[Cells]] to be an empty List.
  finalizationGroup.Cells = [];
  // 8. Return finalizationGroup.
  return finalizationGroup;
}
FinalizationRegistryConstructor.section = 'https://tc39.es/ecma262/#sec-finalization-registry-cleanup-callback';
function bootstrapFinalizationRegistry(realmRec) {
  const cons = bootstrapConstructor(realmRec, FinalizationRegistryConstructor, 'FinalizationRegistry', 1, realmRec.Intrinsics['%FinalizationRegistry.prototype%'], []);
  realmRec.Intrinsics['%FinalizationRegistry%'] = cons;
}

/** https://tc39.es/ecma262/#table-well-known-intrinsic-objects */

/** https://tc39.es/ecma262/#sec-code-realms */
class Realm {
  LoadedModules = [];

  // NON-SPEC

  mark(m) {
    m(this.GlobalObject);
    m(this.GlobalEnv);
    for (const v of Object.values(this.Intrinsics)) {
      m(v);
    }
    for (const v of Object.values(this.TemplateMap)) {
      m(v);
    }
    for (const v of this.LoadedModules) {
      m(v.Module);
    }
  }
}
function InitializeHostDefinedRealm() {
  return new ManagedRealm();
}
function AddRestrictedFunctionProperties(F, realm) {
  Assert(!!realm.Intrinsics['%ThrowTypeError%'], "!!realm.Intrinsics['%ThrowTypeError%']");
  const thrower = realm.Intrinsics['%ThrowTypeError%'];
  /* X */
  let _temp = DefinePropertyOrThrow(F, Value('caller'), _Descriptor({
    Get: thrower,
    Set: thrower,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('caller'), Descriptor({\n    Get: thrower,\n    Set: thrower,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  /* X */
  let _temp2 = DefinePropertyOrThrow(F, Value('arguments'), _Descriptor({
    Get: thrower,
    Set: thrower,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(F, Value('arguments'), Descriptor({\n    Get: thrower,\n    Set: thrower,\n    Enumerable: Value.false,\n    Configurable: Value.true,\n  })) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
}

/** https://tc39.es/ecma262/#sec-createintrinsics */
function CreateIntrinsics(realmRec) {
  const intrinsics = Object.create(null);
  realmRec.Intrinsics = intrinsics;
  makeObjectPrototype(realmRec);
  bootstrapFunctionPrototype(realmRec);
  bootstrapObjectPrototype(realmRec);
  bootstrapThrowTypeError(realmRec);
  bootstrapEval(realmRec);
  bootstrapIsFinite(realmRec);
  bootstrapIsNaN(realmRec);
  bootstrapParseFloat(realmRec);
  bootstrapParseInt(realmRec);
  bootstrapURIHandling(realmRec);
  bootstrapObject(realmRec);
  bootstrapErrorPrototype(realmRec);
  bootstrapError(realmRec);
  bootstrapNativeError(realmRec);
  bootstrapAggregateErrorPrototype(realmRec);
  bootstrapAggregateError(realmRec);
  bootstrapFunction(realmRec);
  bootstrapIteratorPrototype(realmRec);
  bootstrapIterator(realmRec);
  bootstrapIteratorHelperPrototype(realmRec);
  bootstrapWrapForValidIteratorPrototype(realmRec);
  bootstrapAsyncIteratorPrototype(realmRec);
  bootstrapArrayIteratorPrototype(realmRec);
  bootstrapMapIteratorPrototype(realmRec);
  bootstrapSetIteratorPrototype(realmRec);
  bootstrapStringIteratorPrototype(realmRec);
  bootstrapRegExpStringIteratorPrototype(realmRec);
  bootstrapForInIteratorPrototype(realmRec);
  bootstrapStringPrototype(realmRec);
  bootstrapString(realmRec);
  bootstrapArrayPrototype(realmRec);
  bootstrapArray(realmRec);
  bootstrapBooleanPrototype(realmRec);
  bootstrapBoolean(realmRec);
  bootstrapNumberPrototype(realmRec);
  bootstrapNumber(realmRec);
  bootstrapBigIntPrototype(realmRec);
  bootstrapBigInt(realmRec);
  bootstrapSymbolPrototype(realmRec);
  bootstrapSymbol(realmRec);
  bootstrapPromisePrototype(realmRec);
  bootstrapPromise(realmRec);
  bootstrapProxy(realmRec);
  bootstrapReflect(realmRec);
  bootstrapMath(realmRec);
  bootstrapDatePrototype(realmRec);
  bootstrapDate(realmRec);
  bootstrapRegExpPrototype(realmRec);
  bootstrapRegExp(realmRec);
  bootstrapSetPrototype(realmRec);
  bootstrapSet(realmRec);
  bootstrapMapPrototype(realmRec);
  bootstrapMap(realmRec);
  bootstrapGeneratorFunctionPrototypePrototype(realmRec);
  bootstrapGeneratorFunctionPrototype(realmRec);
  bootstrapGeneratorFunction(realmRec);
  bootstrapAsyncFunctionPrototype(realmRec);
  bootstrapAsyncFunction(realmRec);
  bootstrapAsyncGeneratorFunctionPrototypePrototype(realmRec);
  bootstrapAsyncGeneratorFunctionPrototype(realmRec);
  bootstrapAsyncGeneratorFunction(realmRec);
  bootstrapAsyncFromSyncIteratorPrototype(realmRec);
  bootstrapArrayBufferPrototype(realmRec);
  bootstrapArrayBuffer(realmRec);
  bootstrapTypedArrayPrototype(realmRec);
  bootstrapTypedArray(realmRec);
  bootstrapTypedArrayPrototypes(realmRec);
  bootstrapTypedArrayConstructors(realmRec);
  bootstrapUint8Array(realmRec);
  bootstrapDataViewPrototype(realmRec);
  bootstrapDataView(realmRec);
  bootstrapJSON(realmRec);
  bootstrapWeakMapPrototype(realmRec);
  bootstrapWeakMap(realmRec);
  bootstrapWeakSetPrototype(realmRec);
  bootstrapWeakSet(realmRec);
  bootstrapWeakRefPrototype(realmRec);
  bootstrapWeakRef(realmRec);
  bootstrapFinalizationRegistryPrototype(realmRec);
  bootstrapFinalizationRegistry(realmRec);
  AddRestrictedFunctionProperties(intrinsics['%Function.prototype%'], realmRec);
  for (const key in intrinsics) {
    if (intrinsics[key] instanceof ObjectValue) {
      Object.defineProperty(intrinsics, '__debug_intrinsic_name__', {
        value: key,
        configurable: true
      });
    }
  }
  return intrinsics;
}
CreateIntrinsics.section = 'https://tc39.es/ecma262/#sec-createintrinsics';
/** https://tc39.es/ecma262/#sec-setdefaultglobalbindings */
function* SetDefaultGlobalBindings(realmRec) {
  const global = realmRec.GlobalObject;

  // Value Properties of the Global Object
  for (const [name, value] of [['Infinity', F(Infinity)], ['NaN', F(NaN)], ['undefined', Value.undefined]]) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* DefinePropertyOrThrow(global, Value(name), _Descriptor({
      Value: value,
      Writable: Value.false,
      Enumerable: Value.false,
      Configurable: Value.false
    }));
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }
  /* ReturnIfAbrupt */
  let _temp4 = yield* DefinePropertyOrThrow(global, Value('globalThis'), _Descriptor({
    Value: realmRec.GlobalEnv.GlobalThisValue,
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.true
  }));
  /* node:coverage ignore next */
  if (_temp4 instanceof AbruptCompletion) return _temp4;
  /* node:coverage ignore next */
  if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  for (const name of [
  // Function Properties of the Global Object
  'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
  // Constructor Properties of the Global Object
  'AggregateError', 'Array', 'ArrayBuffer', 'Boolean', 'BigInt', 'BigInt64Array', 'BigUint64Array', 'DataView', 'Date', 'Error', 'EvalError', 'FinalizationRegistry', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Iterator', 'Map', 'Number', 'Object', 'Promise', 'Proxy', 'RangeError', 'ReferenceError', 'RegExp', 'Set',
  // 'SharedArrayBuffer',
  'String', 'Symbol', 'SyntaxError', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'URIError', 'WeakMap', 'WeakRef', 'WeakSet',
  // Other Properties of the Global Object
  // 'Atomics',
  'JSON', 'Math', 'Reflect']) {
    /* ReturnIfAbrupt */
    let _temp5 = yield* DefinePropertyOrThrow(global, Value(name), _Descriptor({
      Value: realmRec.Intrinsics[`%${name}%`],
      Writable: Value.true,
      Enumerable: Value.false,
      Configurable: Value.true
    }));
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  }
  return global;
}
SetDefaultGlobalBindings.section = 'https://tc39.es/ecma262/#sec-setdefaultglobalbindings';

/** https://tc39.es/ecma262/#sec-ispropertyreference */
function IsPropertyReference(V) {
  // 1. If V.[[Base]] is unresolvable, return false.
  if (V.Base === 'unresolvable') {
    return Value.false;
  }
  // 2. If V.[[Base]] is an Environment Record, return false; otherwise return true.
  return V.Base instanceof EnvironmentRecord ? Value.false : Value.true;
}
IsPropertyReference.section = 'https://tc39.es/ecma262/#sec-ispropertyreference';
/** https://tc39.es/ecma262/#sec-isunresolvablereference */
function IsUnresolvableReference(V) {
  // 1. Assert: V is a Reference Record.
  Assert(V instanceof ReferenceRecord, "V instanceof ReferenceRecord");
  // 2. If V.[[Base]] is unresolvable, return true; otherwise return false.
  return V.Base === 'unresolvable' ? Value.true : Value.false;
}
IsUnresolvableReference.section = 'https://tc39.es/ecma262/#sec-isunresolvablereference';
/** https://tc39.es/ecma262/#sec-issuperreference */
function IsSuperReference(V) {
  // 1. Assert: V is a Reference Record.
  Assert(V instanceof ReferenceRecord, "V instanceof ReferenceRecord");
  // 2. If V.[[ThisValue]] is not empty, return true; otherwise return false.
  return V.ThisValue !== undefined ? Value.true : Value.false;
}
IsSuperReference.section = 'https://tc39.es/ecma262/#sec-issuperreference';
/** https://tc39.es/ecma262/#sec-isprivatereference */
function IsPrivateReference(V) {
  // 1. Assert: V is a Reference Record.
  Assert(V instanceof ReferenceRecord, "V instanceof ReferenceRecord");
  // 2. If V.[[ReferencedName]] is a Private Name, return true; otherwise return false.
  return V.ReferencedName instanceof PrivateName;
}
IsPrivateReference.section = 'https://tc39.es/ecma262/#sec-isprivatereference';
/** https://tc39.es/ecma262/#sec-getvalue */
function* GetValue(V) {
  // 1. If V is not a Reference Record, return V.
  if (!(V instanceof ReferenceRecord)) {
    return V;
  }
  // 2. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.
  if (IsUnresolvableReference(V) === Value.true) {
    return surroundingAgent.Throw('ReferenceError', 'NotDefined', V.ReferencedName);
  }
  // 3. If IsPropertyReference(V) is true, then
  if (IsPropertyReference(V) === Value.true) {
    // a. Let baseObj be ? ToObject(V.[[Base]]).
    /* ReturnIfAbrupt */
    let _temp = ToObject(V.Base);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    const baseObj = _temp;
    // b. If IsPrivateReference(V) is true, then
    if (IsPrivateReference(V)) {
      // i. Return ? PrivateGet(baseObj, V.[[ReferencedName]]).
      return yield* PrivateGet(baseObj, V.ReferencedName);
    }
    if (!IsPropertyKey(V.ReferencedName)) {
      /* ReturnIfAbrupt */
      let _temp2 = yield* ToPropertyKey(V.ReferencedName);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      V.ReferencedName = _temp2;
    }
    // c. Return ? baseObj.[[Get]](V.[[ReferencedName]], GetThisValue(V)).
    return yield* baseObj.Get(V.ReferencedName, GetThisValue(V));
  } else {
    // 5. Else,
    // a. Let base be V.[[Base]].
    const base = V.Base;
    // b. Assert: base is an Environment Record.
    Assert(base instanceof EnvironmentRecord, "base instanceof EnvironmentRecord");
    // c. Return ? base.GetBindingValue(V.[[ReferencedName]], V.[[Strict]]).
    return yield* base.GetBindingValue(V.ReferencedName, V.Strict);
  }
}
GetValue.section = 'https://tc39.es/ecma262/#sec-getvalue';
/** https://tc39.es/ecma262/#sec-putvalue */
function* PutValue(V, W) {
  // 1. If V is not a Reference Record, throw a ReferenceError exception.
  if (!(V instanceof ReferenceRecord)) {
    return surroundingAgent.Throw('ReferenceError', 'InvalidAssignmentTarget');
  }
  // 2. If IsUnresolvableReference(V) is true, then
  if (IsUnresolvableReference(V) === Value.true) {
    // a. If V.[[Strict]] is true, throw a ReferenceError exception.
    if (V.Strict === Value.true) {
      return surroundingAgent.Throw('ReferenceError', 'NotDefined', V.ReferencedName);
    }
    // b. Let globalObj be GetGlobalObject().
    const globalObj = GetGlobalObject();
    // c. Return ? Set(globalObj, V.[[ReferencedName]], W, false).
    /* ReturnIfAbrupt */
    let _temp3 = yield* Set$1(globalObj, V.ReferencedName, W, Value.false);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    return undefined;
  }
  // 5. If IsPropertyReference(V) is true, then
  if (IsPropertyReference(V) === Value.true) {
    /* ReturnIfAbrupt */
    let _temp4 = ToObject(V.Base);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // a. Let baseObj be ? ToObject(V.[[Base]]).
    const baseObj = _temp4;
    // b. If IsPrivateReference(V) is true, then
    if (IsPrivateReference(V)) {
      // i. Return ? PrivateSet(baseObj, V.[[ReferencedName]], W).
      return yield* PrivateSet(baseObj, V.ReferencedName, W);
    }
    if (!IsPropertyKey(V.ReferencedName)) {
      /* ReturnIfAbrupt */
      let _temp5 = yield* ToPropertyKey(V.ReferencedName);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) return _temp5;
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      V.ReferencedName = _temp5;
    }
    // c. Let succeeded be ? baseObj.[[Set]](V.[[ReferencedName]], W, GetThisValue(V)).
    /* ReturnIfAbrupt */
    let _temp6 = yield* baseObj.Set(V.ReferencedName, W, GetThisValue(V));
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    const succeeded = _temp6;
    // d. If succeeded is false and V.[[Strict]] is true, throw a TypeError exception.
    if (succeeded === Value.false && V.Strict === Value.true) {
      return surroundingAgent.Throw('TypeError', 'CannotSetProperty', V.ReferencedName, V.Base);
    }
    // e. Return.
    return undefined;
  } else {
    // 6. Else,
    // a. Let base be V.[[Base]].
    const base = V.Base;
    // b. Assert: base is an Environment Record.
    Assert(base instanceof EnvironmentRecord, "base instanceof EnvironmentRecord");
    // c. Return ? base.SetMutableBinding(V.[[ReferencedName]], W, V.[[Strict]]) (see 9.1).
    return yield* base.SetMutableBinding(V.ReferencedName, W, V.Strict);
  }
}
PutValue.section = 'https://tc39.es/ecma262/#sec-putvalue';
/** https://tc39.es/ecma262/#sec-getthisvalue */
function GetThisValue(V) {
  // 1. Assert: IsPropertyReference(V) is true.
  Assert(IsPropertyReference(V) === Value.true, "IsPropertyReference(V) === Value.true");
  // 2. If IsSuperReference(V) is true, return V.[[ThisValue]]; otherwise return V.[[Base]].
  if (IsSuperReference(V) === Value.true) {
    return V.ThisValue;
  } else {
    return V.Base;
  }
}
GetThisValue.section = 'https://tc39.es/ecma262/#sec-getthisvalue';
/** https://tc39.es/ecma262/#sec-initializereferencedbinding */
function* InitializeReferencedBinding(V, W) {
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (V && typeof V === 'object' && 'next' in V) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (V instanceof AbruptCompletion) return V;
  /* node:coverage ignore next */
  if (V instanceof Completion) V = V.Value;
  // 2. ReturnIfAbrupt(W).
  /* ReturnIfAbrupt */
  /* node:coverage ignore next */
  if (W && typeof W === 'object' && 'next' in W) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (W instanceof AbruptCompletion) return W;
  /* node:coverage ignore next */
  if (W instanceof Completion) W = W.Value;
  // 3. Assert: V is a Reference Record.
  Assert(V instanceof ReferenceRecord, "V instanceof ReferenceRecord");
  // 4. Assert: IsUnresolvableReference(V) is false.
  Assert(IsUnresolvableReference(V) === Value.false, "IsUnresolvableReference(V) === Value.false");
  // 5. Let base be V.[[Base]].
  const base = V.Base;
  // 6. Assert: base is an Environment Record.
  Assert(base instanceof EnvironmentRecord, "base instanceof EnvironmentRecord");
  // 7. Return base.InitializeBinding(V.[[ReferencedName]], W).
  return yield* base.InitializeBinding(V.ReferencedName, W);
}
InitializeReferencedBinding.section = 'https://tc39.es/ecma262/#sec-initializereferencedbinding';
/** https://tc39.es/ecma262/#sec-makeprivatereference */
function MakePrivateReference(baseValue, privateIdentifier) {
  // 1. Let privEnv be the running execution context's PrivateEnvironment.
  const privEnv = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  // 2. Assert: privEnv is not null.
  Assert(!(privEnv instanceof NullValue), "!(privEnv instanceof NullValue)");
  // 3. Let privateName be ! ResolvePrivateIdentifier(privEnv, privateIdentifier).
  /* X */
  let _temp7 = ResolvePrivateIdentifier(privEnv, privateIdentifier);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! ResolvePrivateIdentifier(privEnv, privateIdentifier) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const privateName = _temp7;
  // 4. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: privateName, [[Strict]]: true, [[ThisValue]]: empty }.
  return new ReferenceRecord({
    Base: baseValue,
    ReferencedName: privateName,
    Strict: Value.true,
    ThisValue: undefined
  });
}
MakePrivateReference.section = 'https://tc39.es/ecma262/#sec-makeprivatereference';
/** https://tc39.es/ecma262/#sec-resolve-private-identifier */
function ResolvePrivateIdentifier(privEnv, identifier) {
  // 1. Let names be privEnv.[[Names]].
  const names = privEnv.Names;
  // 2. If names contains a Private Name whose [[Description]] is identifier, then
  const name = names.find(n => n.Description.stringValue() === identifier.stringValue());
  if (name) {
    // a. Let name be that Private Name.
    // b. Return name.
    return name;
  } else {
    // 3. Else,
    // a. Let outerPrivEnv be privEnv.[[OuterPrivateEnvironment]].
    const outerPrivEnv = privEnv.OuterPrivateEnvironment;
    // b. Assert: outerPrivEnv is not null.
    Assert(!(outerPrivEnv instanceof NullValue), "!(outerPrivEnv instanceof NullValue)");
    // c. Return ResolvePrivateIdentifier(outerPrivEnv, identifier).
    return ResolvePrivateIdentifier(outerPrivEnv, identifier);
  }
}
ResolvePrivateIdentifier.section = 'https://tc39.es/ecma262/#sec-resolve-private-identifier';

/** https://tc39.es/ecma262/#sec-regexpalloc */
function* RegExpAlloc(newTarget) {
  /* ReturnIfAbrupt */
  let _temp = yield* OrdinaryCreateFromConstructor(newTarget, '%RegExp.prototype%', ['RegExpMatcher', 'OriginalSource', 'OriginalFlags']);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const obj = _temp;
  /* X */
  let _temp2 = DefinePropertyOrThrow(obj, Value('lastIndex'), _Descriptor({
    Writable: Value.true,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(obj, Value('lastIndex'), Descriptor({\n    Writable: Value.true,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  return obj;
}
RegExpAlloc.section = 'https://tc39.es/ecma262/#sec-regexpalloc';
/** https://tc39.es/ecma262/#sec-regexpinitialize */
function* RegExpInitialize(obj, pattern, flags) {
  let P;
  // 1. If pattern is undefined, let P be the empty String.
  if (pattern === Value.undefined) {
    P = Value('');
  } else {
    /* ReturnIfAbrupt */
    let _temp3 = yield* ToString(pattern);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // 2. Else, let P be ? ToString(pattern).
    P = _temp3;
  }
  let F$1;
  // 3. If flags is undefined, let F be the empty String.
  if (flags === Value.undefined) {
    F$1 = Value('');
  } else {
    /* ReturnIfAbrupt */
    let _temp4 = yield* ToString(flags);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    // 4. Else, let F be ? ToString(flags).
    F$1 = _temp4;
  }
  const f = F$1.stringValue();
  // 5. If F contains any code unit other than "d", "g", "i", "m", "s", "u", "v", or "y" or if it contains the same code unit more than once, throw a SyntaxError exception.
  if (/^[dgimsuvy]*$/.test(f) === false || new globalThis.Set(f).size !== f.length) {
    return surroundingAgent.Throw('SyntaxError', 'InvalidRegExpFlags', f);
  }
  const i = f.includes('i');
  const m = f.includes('m');
  const s = f.includes('s');
  const u = f.includes('u');
  const v = f.includes('v');

  // 11. If u is true or v is true, then
  //   a. Let patternText be StringToCodePoints(P).
  // 12. Else,
  //   a. Let patternText be the result of interpreting each of P's 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.
  const patternText = P.stringValue();
  const parseResult = ParsePattern(patternText, u, v);
  if (Array.isArray(parseResult)) {
    return surroundingAgent.Throw(parseResult[0], 'Raw', parseResult[0]);
  }
  obj.OriginalSource = P;
  obj.OriginalFlags = F$1;
  const capturingGroupsCount = CountLeftCapturingParensWithin(parseResult);
  const rer = {
    IgnoreCase: i,
    Multiline: m,
    DotAll: s,
    Unicode: u,
    UnicodeSets: v,
    CapturingGroupsCount: capturingGroupsCount
  };
  obj.RegExpRecord = rer;
  obj.parsedPattern = parseResult;
  obj.RegExpMatcher = CompilePattern(parseResult, rer);
  /* ReturnIfAbrupt */
  let _temp5 = yield* Set$1(obj, Value('lastIndex'), F(0), Value.true);
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  return obj;
}
RegExpInitialize.section = 'https://tc39.es/ecma262/#sec-regexpinitialize';
/** https://tc39.es/ecma262/#sec-regexpcreate */
function* RegExpCreate(P, F) {
  /* ReturnIfAbrupt */
  let _temp6 = yield* RegExpAlloc(surroundingAgent.intrinsic('%RegExp%'));
  /* node:coverage ignore next */
  if (_temp6 instanceof AbruptCompletion) return _temp6;
  /* node:coverage ignore next */
  if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  const obj = _temp6;
  return yield* RegExpInitialize(obj, P, F);
}
RegExpCreate.section = 'https://tc39.es/ecma262/#sec-regexpcreate';
/** https://tc39.es/ecma262/#sec-escaperegexppattern */
function EscapeRegExpPattern(P, _F) {
  const source = P.stringValue();
  if (source === '') {
    return Value('(?:)');
  }
  let index = 0;
  let escaped = '';
  let inClass = false;
  let isEscape = false;
  while (index < source.length) {
    const c = source[index];
    switch (c) {
      case '\\':
        index += 1;
        if (isLineTerminator(source[index])) ; else {
          isEscape = !isEscape;
          escaped += '\\';
        }
        break;
      case '/':
        index += 1;
        if (inClass || isEscape) {
          isEscape = false;
          escaped += '/';
        } else {
          escaped += '\\/';
        }
        break;
      case '[':
        inClass = !isEscape;
        index += 1;
        escaped += '[';
        break;
      case ']':
        inClass = !isEscape;
        index += 1;
        escaped += ']';
        break;
      case '\n':
        index += 1;
        escaped += '\\n';
        break;
      case '\r':
        index += 1;
        escaped += '\\r';
        break;
      case '\u2028':
        index += 1;
        escaped += '\\u2028';
        break;
      case '\u2029':
        index += 1;
        escaped += '\\u2029';
        break;
      default:
        index += 1;
        escaped += c;
        break;
    }
    if (c !== '\\') {
      isEscape = false;
    }
  }
  return Value(escaped);
}
EscapeRegExpPattern.section = 'https://tc39.es/ecma262/#sec-escaperegexppattern';
/** https://tc39.es/ecma262/#sec-getstringindex */
function GetStringIndex(S, Input, e) {
  // 1. Assert: Type(S) is String.
  Assert(S instanceof JSStringValue, "S instanceof JSStringValue");
  // 2. Assert: Input is a List of the code points of S interpreted as a UTF-16 encoded string.
  Assert(Array.isArray(Input), "Array.isArray(Input)");
  // 3. Assert: e is an integer value ≥ 0.
  Assert(e >= 0, "e >= 0");
  // 4. If S is the empty String, return 0.
  if (S.stringValue() === '') {
    return 0;
  }
  // 5. Let eUTF be the smallest index into S that corresponds to the character at element e of Input.
  //    If e is greater than or equal to the number of elements in Input, then eUTF is the number of code units in S.
  let eUTF = 0;
  if (e >= Input.length) {
    eUTF = S.stringValue().length;
  } else {
    for (let i = 0; i < e; i += 1) {
      eUTF += Input[i].length;
    }
  }
  // 6. Return eUTF.
  return eUTF;
}
GetStringIndex.section = 'https://tc39.es/ecma262/#sec-getstringindex';
/** https://tc39.es/ecma262/#sec-getmatchstring */
function GetMatchString(S, match) {
  // 1. Assert: Type(S) is String.
  Assert(S instanceof JSStringValue, "S instanceof JSStringValue");
  // 2. Assert: match is a Match Record.
  Assert('StartIndex' in match && 'EndIndex' in match, "'StartIndex' in match && 'EndIndex' in match");
  // 3. Assert: match.[[StartIndex]] is an integer value ≥ 0 and ≤ the length of S.
  Assert(match.StartIndex >= 0 && match.StartIndex <= S.stringValue().length, "match.StartIndex >= 0 && match.StartIndex <= S.stringValue().length");
  // 4. Assert: match.[[EndIndex]] is an integer value ≥ match.[[StartIndex]] and ≤ the length of S.
  Assert(match.EndIndex >= match.StartIndex && match.EndIndex <= S.stringValue().length, "match.EndIndex >= match.StartIndex && match.EndIndex <= S.stringValue().length");
  // 5. Return the portion of S between offset match.[[StartIndex]] inclusive and offset match.[[EndIndex]] exclusive.
  return Value(S.stringValue().slice(match.StartIndex, match.EndIndex));
}
GetMatchString.section = 'https://tc39.es/ecma262/#sec-getmatchstring';
/** https://tc39.es/ecma262/#sec-getmatchindexpair */
function GetMatchIndexPair(S, match) {
  // 1. Assert: Type(S) is String.
  Assert(S instanceof JSStringValue, "S instanceof JSStringValue");
  // 2. Assert: match is a Match Record.
  Assert('StartIndex' in match && 'EndIndex' in match, "'StartIndex' in match && 'EndIndex' in match");
  // 3. Assert: match.[[StartIndex]] is an integer value ≥ 0 and ≤ the length of S.
  Assert(match.StartIndex >= 0 && match.StartIndex <= S.stringValue().length, "match.StartIndex >= 0 && match.StartIndex <= S.stringValue().length");
  // 4. Assert: match.[[EndIndex]] is an integer value ≥ match.[[StartIndex]] and ≤ the length of S.
  Assert(match.EndIndex >= match.StartIndex && match.EndIndex <= S.stringValue().length, "match.EndIndex >= match.StartIndex && match.EndIndex <= S.stringValue().length");
  // 1. Return CreateArrayFromList(« 𝔽(match.[[StartIndex]]), 𝔽(match.[[EndIndex]]) »).
  return CreateArrayFromList([F(match.StartIndex), F(match.EndIndex)]);
}
GetMatchIndexPair.section = 'https://tc39.es/ecma262/#sec-getmatchindexpair';
/** https://tc39.es/ecma262/#sec-makematchindicesindexpairarray */
function MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups) {
  // 1. Assert: Type(S) is String.
  Assert(S instanceof JSStringValue, "S instanceof JSStringValue");
  // 2. Assert: indices is a List.
  Assert(Array.isArray(indices), "Array.isArray(indices)");
  // 3. Let n be the number of elements in indices.
  const n = indices.length;
  // 4. Assert: n < 2**32-1.
  Assert(n < 2 ** 32 - 1, "n < (2 ** 32) - 1");
  // 5. Assert: groupNames is a List with _n_ - 1 elements.
  Assert(Array.isArray(groupNames) && groupNames.length === n - 1, "Array.isArray(groupNames) && groupNames.length === n - 1");
  // 6. NOTE: The groupNames List contains elements aligned with the indices List starting at indices[1].
  // 7. Assert: Type(hasGroups) is Boolean.
  Assert(hasGroups instanceof BooleanValue, "hasGroups instanceof BooleanValue");
  // 8. Set A to ! ArrayCreate(n).
  // 9. Assert: The value of A's "length" property is n.
  /* X */
  let _temp7 = ArrayCreate(n);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! ArrayCreate(n) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const A = _temp7;
  // 10. If hasGroups is true, then
  let groups;
  if (hasGroups === Value.true) {
    /* X */
    let _temp8 = OrdinaryObjectCreate(Value.null);
    /* node:coverage ignore next */
    if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryObjectCreate(Value.null) returned an abrupt completion", {
      cause: _temp8
    });
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    // a. Let groups be ! ObjectCreate(null).
    groups = _temp8;
  } else {
    // 9. Else,
    // b. Let groups be undefined.
    groups = Value.undefined;
  }
  // 11. Perform ! CreateDataProperty(A, "groups", groups).
  /* X */
  let _temp9 = CreateDataPropertyOrThrow(A, Value('groups'), groups);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, Value('groups'), groups) returned an abrupt completion", {
    cause: _temp9
  });
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  // 12. For each integer i such that i ≥ 0 and i < n, do
  for (let i = 0; i < n; i += 1) {
    // a. Let matchIndices be indices[i].
    const matchIndices = indices[i];
    // b. If matchIndices is not undefined, then
    let matchIndicesArray;
    if (matchIndices !== Value.undefined) {
      /* X */
      let _temp10 = GetMatchIndexPair(S, matchIndices);
      /* node:coverage ignore next */
      if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
      /* node:coverage ignore next */
      if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! GetMatchIndexPair(S, matchIndices as MatchRecord) returned an abrupt completion", {
        cause: _temp10
      });
      /* node:coverage ignore next */
      if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
      // i. Let matchIndicesArray be ! GetMatchIndexPair(S, matchIndices).
      matchIndicesArray = _temp10;
    } else {
      // c. Else,
      // i. Let matchIndicesArray be undefined.
      matchIndicesArray = Value.undefined;
    }
    // d. Perform ! CreateDataProperty(A, ! ToString(𝔽(i)), matchIndicesArray).
    /* X */
    let _temp13 = ToString(F(i));
    /* node:coverage ignore next */
    if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! ToString(toNumberValue(i)) returned an abrupt completion", {
      cause: _temp13
    });
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    /* X */
    let _temp11 = CreateDataPropertyOrThrow(A, _temp13, matchIndicesArray);
    /* node:coverage ignore next */
    if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(A, X(ToString(toNumberValue(i))), matchIndicesArray) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    // e. If i > 0 and groupNames[i - 1] is not undefined, then
    if (i > 0 && groupNames[i - 1] !== Value.undefined) {
      /* X */
      let _temp12 = CreateDataPropertyOrThrow(groups, groupNames[i - 1], matchIndicesArray);
      /* node:coverage ignore next */
      if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
      /* node:coverage ignore next */
      if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataPropertyOrThrow(groups as ObjectValue, groupNames[i - 1] as JSStringValue, matchIndicesArray) returned an abrupt completion", {
        cause: _temp12
      });
      /* node:coverage ignore next */
      if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    }
  }
  // 13. Return A.
  return A;
}
MakeMatchIndicesIndexPairArray.section = 'https://tc39.es/ecma262/#sec-makematchindicesindexpairarray';
/** https://tc39.es/ecma262/#sec-regexphasflag */
function RegExpHasFlag(R, codeUnit) {
  // 1. If Type(R) is not Object, throw a TypeError exception.
  if (!(R instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  // 2. If R does not have an [[OriginalFlags]] internal slot, then
  if (!('OriginalFlags' in R)) {
    // a. If SameValue(R, %RegExp.prototype%) is true, return undefined.
    if (SameValue(R, surroundingAgent.intrinsic('%RegExp.prototype%')) === Value.true) {
      return Value.undefined;
    }
    // b. Otherwise, throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'NotATypeObject', 'RegExp', R);
  }
  // 3. Let flags be R.[[OriginalFlags]].
  const flags = R.OriginalFlags.stringValue();
  // 4. If flags contains codeUnit, return true.
  if (flags.includes(codeUnit)) {
    return Value.true;
  }
  // 5. Return false.
  return Value.false;
}
RegExpHasFlag.section = 'https://tc39.es/ecma262/#sec-regexphasflag';

// #𝔽
function F(x) {
  Assert(typeof x === 'number', "typeof x === 'number'");
  return Value(x);
}

// #ℤ
function Z(x) {
  Assert(typeof x === 'bigint', "typeof x === 'bigint'");
  return Value(x);
}

// #ℝ

function R(x) {
  if (x instanceof BigIntValue) {
    return x.bigintValue(); // eslint-disable-line @engine262/mathematical-value
  }
  Assert(x instanceof NumberValue, "x instanceof NumberValue");
  return x.numberValue(); // eslint-disable-line @engine262/mathematical-value
}

// 6.2.5.1 IsAccessorDescriptor
function IsAccessorDescriptor(Desc) {
  if (Desc instanceof UndefinedValue) {
    return false;
  }
  if (Desc.Get === undefined && Desc.Set === undefined) {
    return false;
  }
  return true;
}

// 6.2.5.2 IsDataDescriptor
function IsDataDescriptor(Desc) {
  if (Desc instanceof UndefinedValue) {
    return false;
  }
  if (Desc.Value === undefined && Desc.Writable === undefined) {
    return false;
  }
  return true;
}

// 6.2.5.3 IsGenericDescriptor
function IsGenericDescriptor(Desc) {
  if (Desc instanceof UndefinedValue) {
    return false;
  }
  if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
    return true;
  }
  return false;
}

/** https://tc39.es/ecma262/#sec-frompropertydescriptor */
function FromPropertyDescriptor(Desc) {
  if (Desc instanceof UndefinedValue) {
    return Value.undefined;
  }
  const obj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Object.prototype%'));
  if (Desc.Value !== undefined) {
    /* X */
    let _temp = CreateDataProperty(obj, Value('value'), Desc.Value);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('value'), Desc.Value) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
  }
  if (Desc.Writable !== undefined) {
    /* X */
    let _temp2 = CreateDataProperty(obj, Value('writable'), Desc.Writable);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('writable'), Desc.Writable) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  }
  if (Desc.Get !== undefined) {
    /* X */
    let _temp3 = CreateDataProperty(obj, Value('get'), Desc.Get);
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('get'), Desc.Get) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }
  if (Desc.Set !== undefined) {
    /* X */
    let _temp4 = CreateDataProperty(obj, Value('set'), Desc.Set);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('set'), Desc.Set) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
  }
  if (Desc.Enumerable !== undefined) {
    /* X */
    let _temp5 = CreateDataProperty(obj, Value('enumerable'), Desc.Enumerable);
    /* node:coverage ignore next */
    if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('enumerable'), Desc.Enumerable) returned an abrupt completion", {
      cause: _temp5
    });
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  }
  if (Desc.Configurable !== undefined) {
    /* X */
    let _temp6 = CreateDataProperty(obj, Value('configurable'), Desc.Configurable);
    /* node:coverage ignore next */
    if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! CreateDataProperty(obj, Value('configurable'), Desc.Configurable) returned an abrupt completion", {
      cause: _temp6
    });
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
  }
  // Assert: All of the above CreateDataProperty operations return true.
  return obj;
}
FromPropertyDescriptor.section = 'https://tc39.es/ecma262/#sec-frompropertydescriptor';
/** https://tc39.es/ecma262/#sec-topropertydescriptor */
function* ToPropertyDescriptor(Obj) {
  if (!(Obj instanceof ObjectValue)) {
    return surroundingAgent.Throw('TypeError', 'NotAnObject', Obj);
  }
  let desc = _Descriptor({});
  /* ReturnIfAbrupt */
  let _temp7 = yield* HasProperty(Obj, Value('enumerable'));
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const hasEnumerable = _temp7;
  if (hasEnumerable === Value.true) {
    /* ReturnIfAbrupt */
    let _temp8 = yield* Get(Obj, Value('enumerable'));
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    const enumerable = ToBoolean(_temp8);
    desc = _Descriptor({
      ...desc,
      Enumerable: enumerable
    });
  }
  /* ReturnIfAbrupt */
  let _temp9 = yield* HasProperty(Obj, Value('configurable'));
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const hasConfigurable = _temp9;
  if (hasConfigurable === Value.true) {
    /* ReturnIfAbrupt */
    let _temp10 = yield* Get(Obj, Value('configurable'));
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) return _temp10;
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    const conf = ToBoolean(_temp10);
    desc = _Descriptor({
      ...desc,
      Configurable: conf
    });
  }
  /* ReturnIfAbrupt */
  let _temp11 = yield* HasProperty(Obj, Value('value'));
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  const hasValue = _temp11;
  if (hasValue === Value.true) {
    /* ReturnIfAbrupt */
    let _temp12 = yield* Get(Obj, Value('value'));
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) return _temp12;
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    const value = _temp12;
    desc = _Descriptor({
      ...desc,
      Value: value
    });
  }
  /* ReturnIfAbrupt */
  let _temp13 = yield* HasProperty(Obj, Value('writable'));
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  const hasWritable = _temp13;
  if (hasWritable === Value.true) {
    /* ReturnIfAbrupt */
    let _temp14 = yield* Get(Obj, Value('writable'));
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) return _temp14;
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    const writable = ToBoolean(_temp14);
    desc = _Descriptor({
      ...desc,
      Writable: writable
    });
  }
  /* ReturnIfAbrupt */
  let _temp15 = yield* HasProperty(Obj, Value('get'));
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  const hasGet = _temp15;
  if (hasGet === Value.true) {
    /* ReturnIfAbrupt */
    let _temp16 = yield* Get(Obj, Value('get'));
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) return _temp16;
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    const getter = _temp16;
    if (!IsCallable(getter) && !(getter instanceof UndefinedValue)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', getter);
    }
    desc = _Descriptor({
      ...desc,
      Get: getter
    });
  }
  /* ReturnIfAbrupt */
  let _temp17 = yield* HasProperty(Obj, Value('set'));
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  const hasSet = _temp17;
  if (hasSet === Value.true) {
    /* ReturnIfAbrupt */
    let _temp18 = yield* Get(Obj, Value('set'));
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) return _temp18;
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    const setter = _temp18;
    if (!IsCallable(setter) && !(setter instanceof UndefinedValue)) {
      return surroundingAgent.Throw('TypeError', 'NotAFunction', setter);
    }
    desc = _Descriptor({
      ...desc,
      Set: setter
    });
  }
  if (desc.Get !== undefined || desc.Set !== undefined) {
    if (desc.Value !== undefined || desc.Writable !== undefined) {
      return surroundingAgent.Throw('TypeError', 'InvalidPropertyDescriptor');
    }
  }
  return desc;
}
ToPropertyDescriptor.section = 'https://tc39.es/ecma262/#sec-topropertydescriptor';
/** https://tc39.es/ecma262/#sec-completepropertydescriptor */
function CompletePropertyDescriptor(Desc) {
  Assert(Desc instanceof _Descriptor, "Desc instanceof Descriptor");
  const like = _Descriptor({
    Value: Value.undefined,
    Writable: Value.false,
    Get: Value.undefined,
    Set: Value.undefined,
    Enumerable: Value.false,
    Configurable: Value.false
  });
  if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
    if (Desc.Value === undefined) {
      Desc = _Descriptor({
        ...Desc,
        Value: like.Value
      });
    }
    if (Desc.Writable === undefined) {
      Desc = _Descriptor({
        ...Desc,
        Writable: like.Writable
      });
    }
  } else {
    if (Desc.Get === undefined) {
      Desc = _Descriptor({
        ...Desc,
        Get: like.Get
      });
    }
    if (Desc.Set === undefined) {
      Desc = _Descriptor({
        ...Desc,
        Set: like.Set
      });
    }
  }
  if (Desc.Enumerable === undefined) {
    Desc = _Descriptor({
      ...Desc,
      Enumerable: like.Enumerable
    });
  }
  if (Desc.Configurable === undefined) {
    Desc = _Descriptor({
      ...Desc,
      Configurable: like.Configurable
    });
  }
  return Desc;
}
CompletePropertyDescriptor.section = 'https://tc39.es/ecma262/#sec-completepropertydescriptor';
/** https://tc39.es/ecma262/#sec-createbytedatablock */
function CreateByteDataBlock(size) {
  Assert(isNonNegativeInteger(size), "isNonNegativeInteger(size)");
  let db;
  try {
    db = new DataBlock(size);
  } catch (err) {
    return surroundingAgent.Throw('RangeError', 'CannotAllocateDataBlock');
  }
  return db;
}
CreateByteDataBlock.section = 'https://tc39.es/ecma262/#sec-createbytedatablock';
/** https://tc39.es/ecma262/#sec-copydatablockbytes */
function CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) {
  Assert(fromBlock !== toBlock, "fromBlock !== toBlock");
  Assert(Number.isSafeInteger(fromIndex) && fromIndex >= 0, "Number.isSafeInteger(fromIndex) && fromIndex >= 0");
  Assert(Number.isSafeInteger(toIndex) && toIndex >= 0, "Number.isSafeInteger(toIndex) && toIndex >= 0");
  Assert(Number.isSafeInteger(count) && count >= 0, "Number.isSafeInteger(count) && count >= 0");
  const fromSize = fromBlock.byteLength;
  Assert(fromIndex + count <= fromSize, "fromIndex + count <= fromSize");
  const toSize = toBlock.byteLength;
  Assert(toIndex + count <= toSize, "toIndex + count <= toSize");
  while (count > 0) {
    toBlock[toIndex] = fromBlock[fromIndex];
    toIndex += 1;
    fromIndex += 1;
    count -= 1;
  }
  return NormalCompletion(undefined);
}
CopyDataBlockBytes.section = 'https://tc39.es/ecma262/#sec-copydatablockbytes';

const InternalMethods$1 = {
  *GetOwnProperty(P) {
    const S = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    const desc = OrdinaryGetOwnProperty(S, P);
    if (!(desc instanceof UndefinedValue)) {
      return desc;
    }
    /* X */
    let _temp = StringGetOwnProperty(S, P);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! StringGetOwnProperty(S, P) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    return _temp;
  },
  *DefineOwnProperty(P, Desc) {
    const S = this;
    Assert(IsPropertyKey(P), "IsPropertyKey(P)");
    /* X */
    let _temp2 = StringGetOwnProperty(S, P);
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! StringGetOwnProperty(S, P) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const stringDesc = _temp2;
    if (!(stringDesc instanceof UndefinedValue)) {
      const extensible = S.Extensible;
      /* X */
      let _temp3 = IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc);
      /* node:coverage ignore next */
      if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
      /* node:coverage ignore next */
      if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc) returned an abrupt completion", {
        cause: _temp3
      });
      /* node:coverage ignore next */
      if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
      return _temp3;
    }
    /* X */
    let _temp4 = OrdinaryDefineOwnProperty(S, P, Desc);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! OrdinaryDefineOwnProperty(S, P, Desc) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    return _temp4;
  },
  *OwnPropertyKeys() {
    const O = this;
    const keys = [];
    const str = O.StringData;
    Assert(str instanceof JSStringValue, "str instanceof JSStringValue");
    const len = str.stringValue().length;

    // 5. For each non-negative integer i starting with 0 such that i < len, in ascending order, do
    for (let i = 0; i < len; i += 1) {
      /* X */
      let _temp5 = ToString(F(i));
      /* node:coverage ignore next */
      if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(i)) returned an abrupt completion", {
        cause: _temp5
      });
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      // a. Add ! ToString(𝔽(i)) as the last element of keys.
      keys.push(_temp5);
    }

    // For each own property key P of O such that P is an array index and
    // ToIntegerOrInfinity(P) ≥ len, in ascending numeric index order, do
    //   Add P as the last element of keys.
    for (const P of O.properties.keys()) {
      // This is written with two nested ifs to work around https://github.com/devsnek/engine262/issues/24
      if (isArrayIndex(P)) {
        /* X */
        let _temp6 = ToIntegerOrInfinity(P);
        /* node:coverage ignore next */
        if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
        /* node:coverage ignore next */
        if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! ToIntegerOrInfinity(P) returned an abrupt completion", {
          cause: _temp6
        });
        /* node:coverage ignore next */
        if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
        if (_temp6 >= len) {
          keys.push(P);
        }
      }
    }

    // For each own property key P of O such that Type(P) is String and
    // P is not an array index, in ascending chronological order of property creation, do
    //   Add P as the last element of keys.
    for (const P of O.properties.keys()) {
      if (P instanceof JSStringValue && isArrayIndex(P) === false) {
        keys.push(P);
      }
    }

    // For each own property key P of O such that Type(P) is Symbol,
    // in ascending chronological order of property creation, do
    //   Add P as the last element of keys.
    for (const P of O.properties.keys()) {
      if (P instanceof SymbolValue) {
        keys.push(P);
      }
    }
    return keys;
  }
};

/** https://tc39.es/ecma262/#sec-stringcreate */
function StringCreate(value, prototype) {
  // 1. Assert: Type(value) is String.
  Assert(value instanceof JSStringValue, "value instanceof JSStringValue");
  // 2. Let S be ! MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »).
  /* X */
  let _temp7 = MakeBasicObject(['Prototype', 'Extensible', 'StringData']);
  /* node:coverage ignore next */
  if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! MakeBasicObject(['Prototype', 'Extensible', 'StringData']) returned an abrupt completion", {
    cause: _temp7
  });
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  const S = _temp7;
  // 3. Set S.[[Prototype]] to prototype.
  S.Prototype = prototype;
  // 4. Set S.[[StringData]] to value.
  S.StringData = value;
  // 5. Set S.[[GetOwnProperty]] as specified in 9.4.3.1.
  S.GetOwnProperty = InternalMethods$1.GetOwnProperty;
  // 6. Set S.[[DefineOwnProperty]] as specified in 9.4.3.2.
  S.DefineOwnProperty = InternalMethods$1.DefineOwnProperty;
  // 7. Set S.[[OwnPropertyKeys]] as specified in 9.4.3.3.
  S.OwnPropertyKeys = InternalMethods$1.OwnPropertyKeys;
  // 8. Let length be the number of code unit elements in value.
  const length = value.stringValue().length;
  // 9. Perform ! DefinePropertyOrThrow(S, "length", PropertyDescriptor { [[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).
  /* X */
  let _temp8 = DefinePropertyOrThrow(S, Value('length'), _Descriptor({
    Value: F(length),
    Writable: Value.false,
    Enumerable: Value.false,
    Configurable: Value.false
  }));
  /* node:coverage ignore next */
  if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! DefinePropertyOrThrow(S, Value('length'), Descriptor({\n    Value: F(length),\n    Writable: Value.false,\n    Enumerable: Value.false,\n    Configurable: Value.false,\n  })) returned an abrupt completion", {
    cause: _temp8
  });
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 10. Return S.
  return S;
}
StringCreate.section = 'https://tc39.es/ecma262/#sec-stringcreate';
/** https://tc39.es/ecma262/#sec-stringgetownproperty */
function StringGetOwnProperty(S, P) {
  Assert(S instanceof ObjectValue && 'StringData' in S, "S instanceof ObjectValue && 'StringData' in S");
  Assert(IsPropertyKey(P), "IsPropertyKey(P)");
  if (!(P instanceof JSStringValue)) {
    return Value.undefined;
  }
  /* X */
  let _temp9 = CanonicalNumericIndexString(P);
  /* node:coverage ignore next */
  if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! CanonicalNumericIndexString(P) returned an abrupt completion", {
    cause: _temp9
  });
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  const index = _temp9;
  if (index instanceof UndefinedValue) {
    return Value.undefined;
  }
  if (IsIntegralNumber(index) === Value.false) {
    return Value.undefined;
  }
  if (Object.is(R(index), -0)) {
    return Value.undefined;
  }
  const str = S.StringData;
  Assert(str instanceof JSStringValue, "str instanceof JSStringValue");
  const len = str.stringValue().length;
  if (R(index) < 0 || len <= R(index)) {
    return Value.undefined;
  }
  const resultStr = str.stringValue()[R(index)];
  return _Descriptor({
    Value: Value(resultStr),
    Writable: Value.false,
    Enumerable: Value.true,
    Configurable: Value.false
  });
}
StringGetOwnProperty.section = 'https://tc39.es/ecma262/#sec-stringgetownproperty';

/** https://tc39.es/ecma262/#sec-symboldescriptivestring */
function SymbolDescriptiveString(sym) {
  Assert(sym instanceof SymbolValue, "sym instanceof SymbolValue");
  let desc = sym.Description;
  if (desc instanceof UndefinedValue) {
    desc = Value('');
  }
  return Value(`Symbol(${desc.stringValue()})`);
}
SymbolDescriptiveString.section = 'https://tc39.es/ecma262/#sec-symboldescriptivestring';
/** https://tc39.es/ecma262/#sec-keyforsymbol */
function KeyForSymbol(sym) {
  // 1. For each element e of the GlobalSymbolRegistry List, do
  for (const e of GlobalSymbolRegistry) {
    // a. If SameValue(e.[[Symbol]], sym) is true, return e.[[Key]].
    if (SameValue(e.Symbol, sym) === Value.true) {
      return e.Key;
    }
  }

  // 2. Assert: The GlobalSymbolRegistry List does not currently contain an entry for sym.
  // 3. Return undefined.
  return Value.undefined;
}
KeyForSymbol.section = 'https://tc39.es/ecma262/#sec-keyforsymbol';

// This file covers abstract operations defined in
/** https://tc39.es/ecma262/#sec-testing-and-comparison-operations */

/** https://tc39.es/ecma262/#sec-requireobjectcoercible */
function RequireObjectCoercible(argument) {
  if (argument instanceof UndefinedValue) {
    return surroundingAgent.Throw('TypeError', 'CannotConvertToObject', 'undefined');
  }
  if (argument instanceof NullValue) {
    return surroundingAgent.Throw('TypeError', 'CannotConvertToObject', 'null');
  }
  Assert(argument instanceof ObjectValue || argument instanceof BooleanValue || argument instanceof NumberValue || argument instanceof JSStringValue || argument instanceof SymbolValue || argument instanceof BigIntValue, "argument instanceof ObjectValue || argument instanceof BooleanValue || argument instanceof NumberValue || argument instanceof JSStringValue || argument instanceof SymbolValue || argument instanceof BigIntValue");
  return argument;
}
RequireObjectCoercible.section = 'https://tc39.es/ecma262/#sec-testing-and-comparison-operations';
/** https://tc39.es/ecma262/#sec-isarray */
function IsArray(argument) {
  if (!(argument instanceof ObjectValue)) {
    return Value.false;
  }
  if (isArrayExoticObject(argument)) {
    return Value.true;
  }
  if (isProxyExoticObject(argument)) {
    if (argument.ProxyHandler === Value.null) {
      return surroundingAgent.Throw('TypeError', 'ProxyRevoked', 'IsArray');
    }
    const target = argument.ProxyTarget;
    return IsArray(target);
  }
  return Value.false;
}
IsArray.section = 'https://tc39.es/ecma262/#sec-isarray';
/** https://tc39.es/ecma262/#sec-iscallable */
function IsCallable(argument) {
  if (!(argument instanceof ObjectValue)) {
    return false;
  }
  if ('Call' in argument) {
    return true;
  }
  return false;
}
IsCallable.section = 'https://tc39.es/ecma262/#sec-iscallable';
/** https://tc39.es/ecma262/#sec-isconstructor */
function IsConstructor(argument) {
  if (!(argument instanceof ObjectValue)) {
    return false;
  }
  if ('Construct' in argument) {
    return true;
  }
  return false;
}
IsConstructor.section = 'https://tc39.es/ecma262/#sec-isconstructor';
/** https://tc39.es/ecma262/#sec-isextensible-o */
function* IsExtensible(O) {
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  return yield* O.IsExtensible();
}
IsExtensible.section = 'https://tc39.es/ecma262/#sec-isextensible-o';
/** https://tc39.es/ecma262/#sec-isinteger */
function IsIntegralNumber(argument) {
  if (!(argument instanceof NumberValue)) {
    return Value.false;
  }
  if (argument.isNaN() || argument.isInfinity()) {
    return Value.false;
  }
  if (Math.floor(Math.abs(R(argument))) !== Math.abs(R(argument))) {
    return Value.false;
  }
  return Value.true;
}
IsIntegralNumber.section = 'https://tc39.es/ecma262/#sec-isinteger';
/** https://tc39.es/ecma262/#sec-ispropertykey */
function IsPropertyKey(argument) {
  if (argument instanceof JSStringValue) {
    return true;
  }
  if (argument instanceof SymbolValue) {
    return true;
  }
  return false;
}
IsPropertyKey.section = 'https://tc39.es/ecma262/#sec-ispropertykey';
/** https://tc39.es/ecma262/#sec-isregexp */
function* IsRegExp(argument) {
  if (!(argument instanceof ObjectValue)) {
    return Value.false;
  }
  /* ReturnIfAbrupt */
  let _temp = yield* Get(argument, wellKnownSymbols.match);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) return _temp;
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const matcher = _temp;
  if (matcher !== Value.undefined) {
    return ToBoolean(matcher);
  }
  if ('RegExpMatcher' in argument) {
    return Value.true;
  }
  return Value.false;
}
IsRegExp.section = 'https://tc39.es/ecma262/#sec-isregexp';
/** https://tc39.es/ecma262/#sec-isstringprefix */
function IsStringPrefix(p, q) {
  Assert(p instanceof JSStringValue, "p instanceof JSStringValue");
  Assert(q instanceof JSStringValue, "q instanceof JSStringValue");
  return q.stringValue().startsWith(p.stringValue());
}
IsStringPrefix.section = 'https://tc39.es/ecma262/#sec-isstringprefix';
/** https://tc39.es/ecma262/#sec-samevalue */
function SameValue(x, y) {
  // If SameType(x, y) is false, return false.
  if (!SameType(x, y)) {
    return Value.false;
  }
  // If x is a Number, then
  if (x instanceof NumberValue) {
    // a. Return Number::sameValue(x, y).
    return NumberValue.sameValue(x, y);
  }
  // 3. Return SameValueNonNumber(x, y).
  /* X */
  let _temp2 = SameValueNonNumber(x, y);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! SameValueNonNumber(x, y) returned an abrupt completion", {
    cause: _temp2
  });
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  return _temp2;
}
SameValue.section = 'https://tc39.es/ecma262/#sec-samevalue';
/** https://tc39.es/ecma262/#sec-samevaluezero */
function SameValueZero(x, y) {
  // 1. If SameType(x, y) is false, return false.
  if (!SameType(x, y)) {
    return Value.false;
  }
  // 2. If x is a Number, then
  if (x instanceof NumberValue) {
    // a. Return Number::sameValueZero(x, y).
    return NumberValue.sameValueZero(x, y);
  }
  // 3. Return SameValueNonNumber(x, y).
  return SameValueNonNumber(x, y);
}
SameValueZero.section = 'https://tc39.es/ecma262/#sec-samevaluezero';
/** https://tc39.es/ecma262/#sec-samevaluenonnumber */
function SameValueNonNumber(x, y) {
  Assert(SameType(x, y), "SameType(x, y)");
  if (x instanceof UndefinedValue || x instanceof NullValue) {
    return Value.true;
  }
  if (x instanceof BigIntValue) {
    return BigIntValue.equal(x, y);
  }
  if (x instanceof JSStringValue) {
    if (x.stringValue() === y.stringValue()) {
      return Value.true;
    }
    return Value.false;
  }
  if (x instanceof BooleanValue) {
    if (x === y) {
      return Value.true;
    }
    return Value.false;
  }
  return x === y ? Value.true : Value.false;
}
SameValueNonNumber.section = 'https://tc39.es/ecma262/#sec-samevaluenonnumber';
/** https://tc39.es/ecma262/#sec-abstract-relational-comparison */
function* AbstractRelationalComparison(x, y, LeftFirst = true) {
  let px;
  let py;
  // 1. If the LeftFirst flag is true, then
  if (LeftFirst === true) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* ToPrimitive(x, 'number');
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // a. Let px be ? ToPrimitive(x, number).
    px = _temp3;
    // b. Let py be ? ToPrimitive(y, number).
    /* ReturnIfAbrupt */
    let _temp4 = yield* ToPrimitive(y, 'number');
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    py = _temp4;
  } else {
    /* ReturnIfAbrupt */
    let _temp5 = yield* ToPrimitive(y, 'number');
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    // a. NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.
    // b. Let py be ? ToPrimitive(y, number).
    py = _temp5;
    // c. Let px be ? ToPrimitive(x, number).
    /* ReturnIfAbrupt */
    let _temp6 = yield* ToPrimitive(x, 'number');
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    px = _temp6;
  }
  // 3. If Type(px) is String and Type(py) is String, then
  if (px instanceof JSStringValue && py instanceof JSStringValue) {
    // a. If IsStringPrefix(py, px) is true, return false.
    if (IsStringPrefix(py, px)) {
      return Value.false;
    }
    // b. If IsStringPrefix(px, py) is true, return true.
    if (IsStringPrefix(px, py)) {
      return Value.true;
    }
    // c. Let k be the smallest nonnegative integer such that the code unit at index k within px
    //    is different from the code unit at index k within py. (There must be such a k, for
    //    neither String is a prefix of the other.)
    let k = 0;
    while (true) {
      if (px.stringValue()[k] !== py.stringValue()[k]) {
        break;
      }
      k += 1;
    }
    // d. Let m be the integer that is the numeric value of the code unit at index k within px.
    const m = px.stringValue().charCodeAt(k);
    // e. Let n be the integer that is the numeric value of the code unit at index k within py.
    const n = py.stringValue().charCodeAt(k);
    // f. If m < n, return true. Otherwise, return false.
    if (m < n) {
      return Value.true;
    } else {
      return Value.false;
    }
  } else {
    // a. If Type(px) is BigInt and Type(py) is String, then
    if (px instanceof BigIntValue && py instanceof JSStringValue) {
      // i. Let ny be StringToBigInt(py).
      const ny = StringToBigInt(py);
      // ii. If ny is undefined, return undefined.
      if (ny === undefined) {
        return Value.undefined;
      }
      // iii. Return BigInt::lessThan(px, ny).
      return BigIntValue.lessThan(px, ny);
    }
    // b. If Type(px) is String and Type(py) is BigInt, then
    if (px instanceof JSStringValue && py instanceof BigIntValue) {
      // i. Let ny be StringToBigInt(py).
      const nx = StringToBigInt(px);
      // ii. If ny is undefined, return undefined.
      if (nx === undefined) {
        return Value.undefined;
      }
      // iii. Return BigInt::lessThan(px, ny).
      return BigIntValue.lessThan(nx, py);
    }
    // c. Let nx be ? ToNumeric(px). NOTE: Because px and py are primitive values evaluation order is not important.
    /* ReturnIfAbrupt */
    let _temp7 = yield* ToNumeric(px);
    /* node:coverage ignore next */
    if (_temp7 instanceof AbruptCompletion) return _temp7;
    /* node:coverage ignore next */
    if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
    const nx = _temp7;
    // d. Let ny be ? ToNumeric(py).
    /* ReturnIfAbrupt */
    let _temp8 = yield* ToNumeric(py);
    /* node:coverage ignore next */
    if (_temp8 instanceof AbruptCompletion) return _temp8;
    /* node:coverage ignore next */
    if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
    const ny = _temp8;
    // e. If Type(nx) is the same as Type(ny), return Type(nx)::lessThan(nx, ny).
    if (SameType(nx, ny)) {
      if (nx instanceof NumberValue) {
        return NumberValue.lessThan(nx, ny);
      } else {
        Assert(nx instanceof BigIntValue, "nx instanceof BigIntValue");
        return BigIntValue.lessThan(nx, ny);
      }
    }
    // f. Assert: Type(nx) is BigInt and Type(ny) is Number, or Type(nx) is Number and Type(ny) is BigInt.
    Assert(nx instanceof BigIntValue && ny instanceof NumberValue || nx instanceof NumberValue && ny instanceof BigIntValue, "(nx instanceof BigIntValue && ny instanceof NumberValue) || (nx instanceof NumberValue && ny instanceof BigIntValue)");
    // g. If nx or ny is NaN, return undefined.
    if (nx.isNaN && nx.isNaN() || ny.isNaN && ny.isNaN()) {
      return Value.undefined;
    }
    // h. If nx is -∞ or ny is +∞, return true.
    if (nx instanceof NumberValue && R(nx) === -Infinity || ny instanceof NumberValue && R(ny) === +Infinity) {
      return Value.true;
    }
    // i. If nx is +∞ or ny is -∞, return false.
    if (nx instanceof NumberValue && R(nx) === +Infinity || ny instanceof NumberValue && R(ny) === -Infinity) {
      return Value.false;
    }
    // j. If the mathematical value of nx is less than the mathematical value of ny, return true; otherwise return false.
    const a = R(nx);
    const b = R(ny);
    return a < b ? Value.true : Value.false;
  }
}
AbstractRelationalComparison.section = 'https://tc39.es/ecma262/#sec-abstract-relational-comparison';
/** https://tc39.es/ecma262/#sec-islooselyequal */
function* IsLooselyEqual(x, y) {
  // 1. If SameType(x, y) is true, then
  if (SameType(x, y)) {
    // a. Return the result of performing Strict Equality Comparison x === y.
    return IsStrictlyEqual(x, y);
  }
  // 2. If x is null and y is undefined, return true.
  if (x === Value.null && y === Value.undefined) {
    return Value.true;
  }
  // 3. If x is undefined and y is null, return true.
  if (x === Value.undefined && y === Value.null) {
    return Value.true;
  }
  // 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y).
  if (x instanceof NumberValue && y instanceof JSStringValue) {
    /* X */
    let _temp10 = ToNumber(y);
    /* node:coverage ignore next */
    if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
    /* node:coverage ignore next */
    if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! ToNumber(y) returned an abrupt completion", {
      cause: _temp10
    });
    /* node:coverage ignore next */
    if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
    /* X */
    let _temp9 = yield* IsLooselyEqual(x, _temp10);
    /* node:coverage ignore next */
    if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! yield* IsLooselyEqual(x, X(ToNumber(y))) returned an abrupt completion", {
      cause: _temp9
    });
    /* node:coverage ignore next */
    if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
    return _temp9;
  }
  // 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y.
  if (x instanceof JSStringValue && y instanceof NumberValue) {
    /* X */
    let _temp12 = ToNumber(x);
    /* node:coverage ignore next */
    if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
    /* node:coverage ignore next */
    if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! ToNumber(x) returned an abrupt completion", {
      cause: _temp12
    });
    /* node:coverage ignore next */
    if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
    /* X */
    let _temp11 = yield* IsLooselyEqual(_temp12, y);
    /* node:coverage ignore next */
    if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! yield* IsLooselyEqual(X(ToNumber(x)), y) returned an abrupt completion", {
      cause: _temp11
    });
    /* node:coverage ignore next */
    if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
    return _temp11;
  }
  // 6. If Type(x) is BigInt and Type(y) is String, then
  if (x instanceof BigIntValue && y instanceof JSStringValue) {
    // a. Let n be StringToBigInt(y).
    const n = StringToBigInt(y);
    // b. If n is undefined, return false.
    if (n === undefined) {
      return Value.false;
    }
    // c. Return the result of the comparison x == n.
    /* X */
    let _temp13 = yield* IsLooselyEqual(x, n);
    /* node:coverage ignore next */
    if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! yield* IsLooselyEqual(x, n) returned an abrupt completion", {
      cause: _temp13
    });
    /* node:coverage ignore next */
    if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
    return _temp13;
  }
  // 7. If Type(x) is String and Type(y) is BigInt, return the result of the comparison y == x.
  if (x instanceof JSStringValue && y instanceof BigIntValue) {
    /* X */
    let _temp14 = yield* IsLooselyEqual(y, x);
    /* node:coverage ignore next */
    if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! yield* IsLooselyEqual(y, x) returned an abrupt completion", {
      cause: _temp14
    });
    /* node:coverage ignore next */
    if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
    return _temp14;
  }
  // 8. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y.
  if (x instanceof BooleanValue) {
    /* X */
    let _temp16 = ToNumber(x);
    /* node:coverage ignore next */
    if (_temp16 && typeof _temp16 === 'object' && 'next' in _temp16) _temp16 = skipDebugger(_temp16);
    /* node:coverage ignore next */
    if (_temp16 instanceof AbruptCompletion) throw new Assert.Error("! ToNumber(x) returned an abrupt completion", {
      cause: _temp16
    });
    /* node:coverage ignore next */
    if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
    /* X */
    let _temp15 = yield* IsLooselyEqual(_temp16, y);
    /* node:coverage ignore next */
    if (_temp15 instanceof AbruptCompletion) throw new Assert.Error("! yield* IsLooselyEqual(X(ToNumber(x)), y) returned an abrupt completion", {
      cause: _temp15
    });
    /* node:coverage ignore next */
    if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
    return _temp15;
  }
  // 9. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y).
  if (y instanceof BooleanValue) {
    /* X */
    let _temp18 = ToNumber(y);
    /* node:coverage ignore next */
    if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! ToNumber(y) returned an abrupt completion", {
      cause: _temp18
    });
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    /* X */
    let _temp17 = yield* IsLooselyEqual(x, _temp18);
    /* node:coverage ignore next */
    if (_temp17 instanceof AbruptCompletion) throw new Assert.Error("! yield* IsLooselyEqual(x, X(ToNumber(y))) returned an abrupt completion", {
      cause: _temp17
    });
    /* node:coverage ignore next */
    if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
    return _temp17;
  }
  // 10. If Type(x) is either String, Number, BigInt, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).
  if ((x instanceof JSStringValue || x instanceof NumberValue || x instanceof BigIntValue || x instanceof SymbolValue) && y instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp20 = yield* ToPrimitive(y);
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    /* X */
    let _temp19 = yield* IsLooselyEqual(x, _temp20);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! yield* IsLooselyEqual(x, Q(yield* ToPrimitive(y))) returned an abrupt completion", {
      cause: _temp19
    });
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    return _temp19;
  }
  // 11. If Type(x) is Object and Type(y) is either String, Number, BigInt, or Symbol, return the result of the comparison ToPrimitive(x) == y.
  if (x instanceof ObjectValue && (y instanceof JSStringValue || y instanceof NumberValue || y instanceof BigIntValue || y instanceof SymbolValue)) {
    /* ReturnIfAbrupt */
    let _temp22 = yield* ToPrimitive(x);
    /* node:coverage ignore next */
    if (_temp22 instanceof AbruptCompletion) return _temp22;
    /* node:coverage ignore next */
    if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
    /* X */
    let _temp21 = yield* IsLooselyEqual(_temp22, y);
    /* node:coverage ignore next */
    if (_temp21 instanceof AbruptCompletion) throw new Assert.Error("! yield* IsLooselyEqual(Q(yield* ToPrimitive(x)), y) returned an abrupt completion", {
      cause: _temp21
    });
    /* node:coverage ignore next */
    if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
    return _temp21;
  }
  // 12. If Type(x) is BigInt and Type(y) is Number, or if Type(x) is Number and Type(y) is BigInt, then
  if (x instanceof BigIntValue && y instanceof NumberValue || x instanceof NumberValue && y instanceof BigIntValue) {
    // a. If x or y are any of NaN, +∞, or -∞, return false.
    if (x.isNaN && (x.isNaN() || !x.isFinite()) || y.isNaN && (y.isNaN() || !y.isFinite())) {
      return Value.false;
    }
    // b. If the mathematical value of x is equal to the mathematical value of y, return true; otherwise return false.
    const a = R(x);
    const b = R(y);
    return a == b ? Value.true : Value.false; // eslint-disable-line eqeqeq
  }
  // 13. Return false.
  return Value.false;
}
IsLooselyEqual.section = 'https://tc39.es/ecma262/#sec-islooselyequal';
/** https://tc39.es/ecma262/#sec-isstrictlyequal */
function IsStrictlyEqual(x, y) {
  // 1. If SameType(x, y) is false, return false.
  if (!SameType(x, y)) {
    return Value.false;
  }
  // 2. If x is a Number, then
  if (x instanceof NumberValue) {
    // a. Return Number::equal(x, y).
    return NumberValue.equal(x, y);
  }
  // 3. Return SameValueNonNumber(x, y).
  return SameValueNonNumber(x, y);
}
IsStrictlyEqual.section = 'https://tc39.es/ecma262/#sec-isstrictlyequal';

/** https://tc39.es/ecma262/#sec-toprimitive */
function* ToPrimitive(input, preferredType) {
  // 1. Assert: input is an ECMAScript language value.
  Assert(input instanceof Value, "input instanceof Value");
  // 2. If Type(input) is Object, then
  if (input instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp = yield* GetMethod(input, wellKnownSymbols.toPrimitive);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) return _temp;
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // a. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).
    const exoticToPrim = _temp;
    // b. If exoticToPrim is not undefined, then
    if (exoticToPrim !== Value.undefined) {
      let hint;
      // i. If preferredType is not present, let hint be "default".
      if (preferredType === undefined) {
        hint = Value('default');
      } else if (preferredType === 'string') {
        // ii. Else if preferredType is string, let hint be "string".
        hint = Value('string');
      } else {
        // iii. Else,
        // 1. Assert: preferredType is number.
        Assert(preferredType === 'number', "preferredType === 'number'");
        // 2. Let hint be "number".
        hint = Value('number');
      }
      // iv. Let result be ? Call(exoticToPrim, input, « hint »).
      /* ReturnIfAbrupt */
      let _temp2 = yield* Call(exoticToPrim, input, [hint]);
      /* node:coverage ignore next */
      if (_temp2 instanceof AbruptCompletion) return _temp2;
      /* node:coverage ignore next */
      if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
      const result = _temp2;
      // v. If Type(result) is not Object, return result.
      if (!(result instanceof ObjectValue)) {
        return result;
      }
      // vi. Throw a TypeError exception.
      return surroundingAgent.Throw('TypeError', 'ObjectToPrimitive');
    }
    // c. If preferredType is not present, let preferredType be number.
    if (preferredType === undefined) {
      preferredType = 'number';
    }
    // d. Return ? OrdinaryToPrimitive(input, preferredType).
    return yield* OrdinaryToPrimitive(input, preferredType);
  }
  // 3. Return input.
  return input;
}
ToPrimitive.section = 'https://tc39.es/ecma262/#sec-toprimitive';
/** https://tc39.es/ecma262/#sec-ordinarytoprimitive */
function* OrdinaryToPrimitive(O, hint) {
  // 1. Assert: Type(O) is Object.
  Assert(O instanceof ObjectValue, "O instanceof ObjectValue");
  // 2. Assert: hint is either string or number.
  Assert(hint === 'string' || hint === 'number', "hint === 'string' || hint === 'number'");
  let methodNames;
  // 3. If hint is string, then
  if (hint === 'string') {
    // a. Let methodNames be « "toString", "valueOf" ».
    methodNames = [Value('toString'), Value('valueOf')];
  } else {
    // 4. Else,
    // a. Let methodNames be « "valueOf", "toString" ».
    methodNames = [Value('valueOf'), Value('toString')];
  }
  // 5. For each element name of methodNames, do
  for (const name of methodNames) {
    /* ReturnIfAbrupt */
    let _temp3 = yield* Get(O, name);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    // a. Let method be ? Get(O, name).
    const method = _temp3;
    // b. If IsCallable(method) is true, then
    if (IsCallable(method)) {
      /* ReturnIfAbrupt */
      let _temp4 = yield* Call(method, O);
      /* node:coverage ignore next */
      if (_temp4 instanceof AbruptCompletion) return _temp4;
      /* node:coverage ignore next */
      if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      // i. Let result be ? Call(method, O).
      const result = _temp4;
      // ii. If Type(result) is not Object, return result.
      if (!(result instanceof ObjectValue)) {
        return result;
      }
    }
  }
  // 6. Throw a TypeError exception.
  return surroundingAgent.Throw('TypeError', 'ObjectToPrimitive');
}
OrdinaryToPrimitive.section = 'https://tc39.es/ecma262/#sec-ordinarytoprimitive';
/** https://tc39.es/ecma262/#sec-toboolean */
function ToBoolean(argument) {
  if (argument instanceof UndefinedValue) {
    // Return false.
    return Value.false;
  } else if (argument instanceof NullValue) {
    // Return false.
    return Value.false;
  } else if (argument instanceof BooleanValue) {
    // Return argument.
    return argument;
  } else if (argument instanceof NumberValue) {
    // If argument is +0𝔽, -0𝔽, or NaN, return false; otherwise return true.
    if (R(argument) === 0 || argument.isNaN()) {
      return Value.false;
    }
  } else if (argument instanceof JSStringValue) {
    // If argument is the empty String, return false; otherwise return true.
    if (argument.stringValue().length === 0) {
      return Value.false;
    }
  } else if (argument instanceof BigIntValue) {
    // If argument is 0ℤ, return false; otherwise return true.
    if (R(argument) === 0n) {
      return Value.false;
    }
  }
  return Value.true;
}
ToBoolean.section = 'https://tc39.es/ecma262/#sec-toboolean';
/** https://tc39.es/ecma262/#sec-tonumeric */
function* ToNumeric(value) {
  /* ReturnIfAbrupt */
  let _temp5 = yield* ToPrimitive(value, 'number');
  /* node:coverage ignore next */
  if (_temp5 instanceof AbruptCompletion) return _temp5;
  /* node:coverage ignore next */
  if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
  // 1. Let primValue be ? ToPrimitive(value, number).
  const primValue = _temp5;
  // 2. If Type(primValue) is BigInt, return primValue.
  if (primValue instanceof BigIntValue) {
    return primValue;
  }
  // 3. Return ? ToNumber(primValue).
  return yield* ToNumber(primValue);
}
ToNumeric.section = 'https://tc39.es/ecma262/#sec-tonumeric';
/** https://tc39.es/ecma262/#sec-tonumber */
function* ToNumber(argument) {
  if (argument instanceof UndefinedValue) {
    // Return NaN.
    return F(NaN);
  } else if (argument instanceof NullValue) {
    // Return +0𝔽.
    return F(0);
  } else if (argument instanceof BooleanValue) {
    // If argument is true, return 1𝔽.
    if (argument === Value.true) {
      return F(1);
    }
    // If argument is false, return +0𝔽.
    return F(0);
  } else if (argument instanceof NumberValue) {
    // Return argument (no conversion).
    return argument;
  } else if (argument instanceof JSStringValue) {
    return MV_StringNumericLiteral(argument.stringValue());
  } else if (argument instanceof BigIntValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotMixBigInts');
  } else if (argument instanceof SymbolValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotConvertSymbol', 'number');
  } else if (argument instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp6 = yield* ToPrimitive(argument, 'number');
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    // 1. Let primValue be ? ToPrimitive(argument, number).
    const primValue = _temp6;
    // 2. Return ? ToNumber(primValue).
    return yield* ToNumber(primValue);
  }
  /* node:coverage ignore next */
  throw new OutOfRange$1('ToNumber', {
    argument
  });
}
ToNumber.section = 'https://tc39.es/ecma262/#sec-tonumber';
const mod = (n, m) => {
  const r = n % m;
  return Math.floor(r >= 0 ? r : r + m);
};

/** https://tc39.es/ecma262/#sec-tointegerorinfinity */
function* ToIntegerOrInfinity(argument) {
  /* ReturnIfAbrupt */
  let _temp7 = yield* ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp7 instanceof AbruptCompletion) return _temp7;
  /* node:coverage ignore next */
  if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
  // 1. Let number be ? ToNumber(argument).
  const number = _temp7;
  // 2. If number is NaN, +0𝔽, or -0𝔽, return 0.
  if (number.isNaN() || R(number) === 0) {
    return 0;
  }
  // 3. If number is +∞𝔽, return +∞.
  // 4. If number is -∞𝔽, return -∞.
  if (!number.isFinite()) {
    return R(number);
  }
  // 4. Let integer be floor(abs(ℝ(number))).
  let integer = Math.floor(Math.abs(R(number)));
  // 5. If number < +0𝔽, set integer to -integer.
  if (R(number) < 0 && integer !== 0) {
    integer = -integer;
  }
  // 6. Return integer.
  return integer;
}
ToIntegerOrInfinity.section = 'https://tc39.es/ecma262/#sec-tointegerorinfinity';
/** https://tc39.es/ecma262/#sec-toint32 */
function* ToInt32(argument) {
  /* ReturnIfAbrupt */
  let _temp8 = yield* ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp8 instanceof AbruptCompletion) return _temp8;
  /* node:coverage ignore next */
  if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
  // 1. Let number be ? ToNumber(argument).
  const number = R(_temp8);
  // 2. If number is NaN, +0𝔽, -0𝔽, +∞𝔽, or -∞𝔽, return +0𝔽.
  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return F(0);
  }
  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(ℝ(number))).
  const int = Math.sign(number) * Math.floor(Math.abs(number));
  // 4. Let int32bit be int modulo 2^32.
  const int32bit = mod(int, 2 ** 32);
  // 5. If int32bit ≥ 2^31, return 𝔽(int32bit - 2^32); otherwise return 𝔽(int32bit).
  if (int32bit >= 2 ** 31) {
    return F(int32bit - 2 ** 32);
  }
  return F(int32bit);
}
ToInt32.section = 'https://tc39.es/ecma262/#sec-toint32';
/** https://tc39.es/ecma262/#sec-touint32 */
function* ToUint32(argument) {
  /* ReturnIfAbrupt */
  let _temp9 = yield* ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp9 instanceof AbruptCompletion) return _temp9;
  /* node:coverage ignore next */
  if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
  // 1. Let number be ? ToNumber(argument).
  const number = R(_temp9);
  // 2. If number is NaN, +0𝔽, -0𝔽, +∞𝔽, or -∞𝔽, return +0𝔽.
  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return F(0);
  }
  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(ℝ(number))).
  const int = Math.sign(number) * Math.floor(Math.abs(number));
  // 4. Let int32bit be int modulo 2^32.
  const int32bit = mod(int, 2 ** 32);
  // 5. Return 𝔽(int32bit).
  return F(int32bit);
}
ToUint32.section = 'https://tc39.es/ecma262/#sec-touint32';
/** https://tc39.es/ecma262/#sec-toint16 */
function* ToInt16(argument) {
  /* ReturnIfAbrupt */
  let _temp10 = yield* ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp10 instanceof AbruptCompletion) return _temp10;
  /* node:coverage ignore next */
  if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
  // 1. Let number be ? ToNumber(argument).
  const number = R(_temp10);
  // 2. If number is NaN, +0𝔽, -0𝔽, +∞𝔽, or -∞𝔽, return +0𝔽.
  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return F(0);
  }
  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(ℝ(number))).
  const int = Math.sign(number) * Math.floor(Math.abs(number));
  // 4. Let int16bit be int modulo 2^16.
  const int16bit = mod(int, 2 ** 16);
  // 5. If int16bit ≥ 2^31, return 𝔽(int16bit - 2^32); otherwise return 𝔽(int16bit).
  if (int16bit >= 2 ** 15) {
    return F(int16bit - 2 ** 16);
  }
  return F(int16bit);
}
ToInt16.section = 'https://tc39.es/ecma262/#sec-toint16';
/** https://tc39.es/ecma262/#sec-touint16 */
function* ToUint16(argument) {
  /* ReturnIfAbrupt */
  let _temp11 = yield* ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp11 instanceof AbruptCompletion) return _temp11;
  /* node:coverage ignore next */
  if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
  // 1. Let number be ? ToNumber(argument).
  const number = R(_temp11);
  // 2. If number is NaN, +0𝔽, -0𝔽, +∞𝔽, or -∞𝔽, return +0𝔽.
  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return F(0);
  }
  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(ℝ(number))).
  const int = Math.sign(number) * Math.floor(Math.abs(number));
  // 4. Let int16bit be int modulo 2^16.
  const int16bit = mod(int, 2 ** 16);
  // 5. Return 𝔽(int16bit).
  return F(int16bit);
}
ToUint16.section = 'https://tc39.es/ecma262/#sec-touint16';
/** https://tc39.es/ecma262/#sec-toint8 */
function* ToInt8(argument) {
  /* ReturnIfAbrupt */
  let _temp12 = yield* ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp12 instanceof AbruptCompletion) return _temp12;
  /* node:coverage ignore next */
  if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
  // 1. Let number be ? ToNumber(argument).
  const number = R(_temp12);
  // 2. If number is NaN, +0𝔽, -0𝔽, +∞𝔽, or -∞𝔽, return +0𝔽.
  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return F(0);
  }
  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(ℝ(number))).
  const int = Math.sign(number) * Math.floor(Math.abs(number));
  // 4. Let int8bit be int modulo 2^8.
  const int8bit = mod(int, 2 ** 8);
  // 5. If int8bit ≥ 2^7, return 𝔽(int8bit - 2^8); otherwise return 𝔽(int8bit).
  if (int8bit >= 2 ** 7) {
    return F(int8bit - 2 ** 8);
  }
  return F(int8bit);
}
ToInt8.section = 'https://tc39.es/ecma262/#sec-toint8';
/** https://tc39.es/ecma262/#sec-touint8 */
function* ToUint8(argument) {
  /* ReturnIfAbrupt */
  let _temp13 = yield* ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp13 instanceof AbruptCompletion) return _temp13;
  /* node:coverage ignore next */
  if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
  // 1. Let number be ? ToNumber(argument).
  const number = R(_temp13);
  // 2. If number is NaN, +0𝔽, -0𝔽, +∞𝔽, or -∞𝔽, return +0𝔽.
  if (Number.isNaN(number) || number === 0 || !Number.isFinite(number)) {
    return F(0);
  }
  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(ℝ(number))).
  const int = Math.sign(number) * Math.floor(Math.abs(number));
  // 4. Let int8bit be int modulo 2^8.
  const int8bit = mod(int, 2 ** 8);
  // 5. Return 𝔽(int8bit).
  return F(int8bit);
}
ToUint8.section = 'https://tc39.es/ecma262/#sec-touint8';
/** https://tc39.es/ecma262/#sec-touint8clamp */
function* ToUint8Clamp(argument) {
  /* ReturnIfAbrupt */
  let _temp14 = yield* ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp14 instanceof AbruptCompletion) return _temp14;
  /* node:coverage ignore next */
  if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
  // 1. Let number be ? ToNumber(argument).
  const number = R(_temp14);
  // 2. If number is NaN, return +0𝔽.
  if (Number.isNaN(number)) {
    return F(0);
  }
  // 3. If ℝ(number) ≤ 0, return +0𝔽.
  if (number <= 0) {
    return F(0);
  }
  // 4. If ℝ(number) ≥ 255, return 255𝔽.
  if (number >= 255) {
    return F(255);
  }
  // 5. Let f be floor(ℝ(number)).
  const f = Math.floor(number);
  // 6. If f + 0.5 < ℝ(number), return 𝔽(f + 1).
  if (f + 0.5 < number) {
    return F(f + 1);
  }
  // 7. If ℝ(number) < f + 0.5, return 𝔽(f).
  if (number < f + 0.5) {
    return F(f);
  }
  // 8. If f is odd, return 𝔽(f + 1).
  if (f % 2 === 1) {
    return F(f + 1);
  }
  // 9. Return 𝔽(f).
  return F(f);
}
ToUint8Clamp.section = 'https://tc39.es/ecma262/#sec-touint8clamp';
/** https://tc39.es/ecma262/#sec-tobigint */
function* ToBigInt(argument) {
  /* ReturnIfAbrupt */
  let _temp15 = yield* ToPrimitive(argument, 'number');
  /* node:coverage ignore next */
  if (_temp15 instanceof AbruptCompletion) return _temp15;
  /* node:coverage ignore next */
  if (_temp15 instanceof Completion) _temp15 = _temp15.Value;
  // 1. Let prim be ? ToPrimitive(argument, number).
  const prim = _temp15;
  // 2. Return the value that prim corresponds to in Table 12 (#table-tobigint).
  if (prim instanceof UndefinedValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotConvertToBigInt', prim);
  } else if (prim instanceof NullValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotConvertToBigInt', prim);
  } else if (prim instanceof BooleanValue) {
    // Return 1ℤ if prim is true and 0ℤ if prim is false.
    if (prim === Value.true) {
      return Z(1n);
    }
    return Z(0n);
  } else if (prim instanceof BigIntValue) {
    // Return prim.
    return prim;
  } else if (prim instanceof NumberValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotConvertToBigInt', prim);
  } else if (prim instanceof JSStringValue) {
    // 1. Let n be StringToBigInt(prim).
    const n = StringToBigInt(prim);
    // 2. If n is NaN, throw a SyntaxError exception.
    if (n === undefined) {
      return surroundingAgent.Throw('SyntaxError', 'CannotConvertToBigInt', prim);
    }
    // 3. Return n.
    return n;
  } else if (prim instanceof SymbolValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotConvertSymbol', 'bigint');
  }
  /* node:coverage ignore next */
  throw new OutOfRange$1('ToBigInt', argument);
}
ToBigInt.section = 'https://tc39.es/ecma262/#sec-tobigint';
/** https://tc39.es/ecma262/#sec-stringtobigint */
function StringToBigInt(argument) {
  try {
    return Z(BigInt(argument.stringValue()));
  } catch {
    return undefined;
  }
}
StringToBigInt.section = 'https://tc39.es/ecma262/#sec-stringtobigint';
/** https://tc39.es/ecma262/#sec-tobigint64 */
function* ToBigInt64(argument) {
  /* ReturnIfAbrupt */
  let _temp16 = yield* ToBigInt(argument);
  /* node:coverage ignore next */
  if (_temp16 instanceof AbruptCompletion) return _temp16;
  /* node:coverage ignore next */
  if (_temp16 instanceof Completion) _temp16 = _temp16.Value;
  // 1. Let n be ? ToBigInt(argument).
  const n = _temp16;
  // 2. Let int64bit be ℝ(n) modulo 2^64.
  const int64bit = R(n) % 2n ** 64n;
  // 3. If int64bit ≥ 2^63, return ℤ(int64bit - 2^64); otherwise return ℤ(int64bit).
  if (int64bit >= 2n ** 63n) {
    return Z(int64bit - 2n ** 64n);
  }
  return Z(int64bit);
}
ToBigInt64.section = 'https://tc39.es/ecma262/#sec-tobigint64';
/** https://tc39.es/ecma262/#sec-tobiguint64 */
function* ToBigUint64(argument) {
  /* ReturnIfAbrupt */
  let _temp17 = yield* ToBigInt(argument);
  /* node:coverage ignore next */
  if (_temp17 instanceof AbruptCompletion) return _temp17;
  /* node:coverage ignore next */
  if (_temp17 instanceof Completion) _temp17 = _temp17.Value;
  // 1. Let n be ? ToBigInt(argument).
  const n = _temp17;
  // 2. Let int64bit be ℝ(n) modulo 2^64.
  const int64bit = R(n) % 2n ** 64n;
  // 3. Return ℤ(int64bit).
  return Z(int64bit);
}
ToBigUint64.section = 'https://tc39.es/ecma262/#sec-tobiguint64';
/** https://tc39.es/ecma262/#sec-tostring */
function* ToString(argument) {
  if (argument instanceof UndefinedValue) {
    // Return "undefined".
    return Value('undefined');
  } else if (argument instanceof NullValue) {
    // Return "null".
    return Value('null');
  } else if (argument instanceof BooleanValue) {
    // If argument is true, return "true".
    // If argument is false, return "false".
    return Value(argument === Value.true ? 'true' : 'false');
  } else if (argument instanceof NumberValue) {
    /* X */
    let _temp18 = NumberValue.toString(argument, 10);
    /* node:coverage ignore next */
    if (_temp18 && typeof _temp18 === 'object' && 'next' in _temp18) _temp18 = skipDebugger(_temp18);
    /* node:coverage ignore next */
    if (_temp18 instanceof AbruptCompletion) throw new Assert.Error("! NumberValue.toString(argument, 10) returned an abrupt completion", {
      cause: _temp18
    });
    /* node:coverage ignore next */
    if (_temp18 instanceof Completion) _temp18 = _temp18.Value;
    // Return ! Number::toString(argument).
    return _temp18;
  } else if (argument instanceof JSStringValue) {
    // Return argument.
    return argument;
  } else if (argument instanceof SymbolValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotConvertSymbol', 'string');
  } else if (argument instanceof BigIntValue) {
    /* X */
    let _temp19 = BigIntValue.toString(argument, 10);
    /* node:coverage ignore next */
    if (_temp19 && typeof _temp19 === 'object' && 'next' in _temp19) _temp19 = skipDebugger(_temp19);
    /* node:coverage ignore next */
    if (_temp19 instanceof AbruptCompletion) throw new Assert.Error("! BigIntValue.toString(argument, 10) returned an abrupt completion", {
      cause: _temp19
    });
    /* node:coverage ignore next */
    if (_temp19 instanceof Completion) _temp19 = _temp19.Value;
    // Return ! BigInt::toString(argument).
    return _temp19;
  } else if (argument instanceof ObjectValue) {
    /* ReturnIfAbrupt */
    let _temp20 = yield* ToPrimitive(argument, 'string');
    /* node:coverage ignore next */
    if (_temp20 instanceof AbruptCompletion) return _temp20;
    /* node:coverage ignore next */
    if (_temp20 instanceof Completion) _temp20 = _temp20.Value;
    // 1. Let primValue be ? ToPrimitive(argument, string).
    const primValue = _temp20;
    // 2. Return ? ToString(primValue).
    return yield* ToString(primValue);
  }
  /* node:coverage ignore next */
  throw new OutOfRange$1('ToString', {
    argument
  });
}
ToString.section = 'https://tc39.es/ecma262/#sec-tostring';
/** https://tc39.es/ecma262/#sec-toobject */
function ToObject(argument) {
  if (argument instanceof UndefinedValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotConvertToObject', 'undefined');
  } else if (argument instanceof NullValue) {
    // Throw a TypeError exception.
    return surroundingAgent.Throw('TypeError', 'CannotConvertToObject', 'null');
  } else if (argument instanceof BooleanValue) {
    // Return a new Boolean object whose [[BooleanData]] internal slot is set to argument.
    const obj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Boolean.prototype%'), ['BooleanData']);
    obj.BooleanData = argument;
    return obj;
  } else if (argument instanceof NumberValue) {
    // Return a new Number object whose [[NumberData]] internal slot is set to argument.
    const obj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Number.prototype%'), ['NumberData']);
    obj.NumberData = argument;
    return obj;
  } else if (argument instanceof JSStringValue) {
    // Return a new String object whose [[StringData]] internal slot is set to argument.
    return StringCreate(argument, surroundingAgent.intrinsic('%String.prototype%'));
  } else if (argument instanceof SymbolValue) {
    // Return a new Symbol object whose [[SymbolData]] internal slot is set to argument.
    const obj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%Symbol.prototype%'), ['SymbolData']);
    obj.SymbolData = argument;
    return obj;
  } else if (argument instanceof BigIntValue) {
    // Return a new BigInt object whose [[BigIntData]] internal slot is set to argument.
    const obj = OrdinaryObjectCreate(surroundingAgent.intrinsic('%BigInt.prototype%'), ['BigIntData']);
    obj.BigIntData = argument;
    return obj;
  } else if (argument instanceof ObjectValue) {
    // Return argument.
    return argument;
  }
  /* node:coverage ignore next */
  throw new OutOfRange$1('ToObject', {
    argument
  });
}
ToObject.section = 'https://tc39.es/ecma262/#sec-toobject';
/** https://tc39.es/ecma262/#sec-topropertykey */
function* ToPropertyKey(argument) {
  /* ReturnIfAbrupt */
  let _temp21 = yield* ToPrimitive(argument, 'string');
  /* node:coverage ignore next */
  if (_temp21 instanceof AbruptCompletion) return _temp21;
  /* node:coverage ignore next */
  if (_temp21 instanceof Completion) _temp21 = _temp21.Value;
  // 1. Let key be ? ToPrimitive(argument, string).
  const key = _temp21;
  // 2. If Type(key) is Symbol, then
  if (key instanceof SymbolValue) {
    // a. Return key.
    return key;
  }
  // 3. Return ! ToString(key).
  /* X */
  let _temp22 = ToString(key);
  /* node:coverage ignore next */
  if (_temp22 && typeof _temp22 === 'object' && 'next' in _temp22) _temp22 = skipDebugger(_temp22);
  /* node:coverage ignore next */
  if (_temp22 instanceof AbruptCompletion) throw new Assert.Error("! ToString(key) returned an abrupt completion", {
    cause: _temp22
  });
  /* node:coverage ignore next */
  if (_temp22 instanceof Completion) _temp22 = _temp22.Value;
  return _temp22;
}
ToPropertyKey.section = 'https://tc39.es/ecma262/#sec-topropertykey';
/** https://tc39.es/ecma262/#sec-tolength */
function* ToLength(argument) {
  /* ReturnIfAbrupt */
  let _temp23 = yield* ToIntegerOrInfinity(argument);
  /* node:coverage ignore next */
  if (_temp23 instanceof AbruptCompletion) return _temp23;
  /* node:coverage ignore next */
  if (_temp23 instanceof Completion) _temp23 = _temp23.Value;
  // 1. Let len be ? ToIntegerOrInfinity(argument).
  const len = _temp23;
  // 2. If len ≤ 0, return +0𝔽.
  if (len <= 0) {
    return F(0);
  }
  // 3. Return 𝔽(min(len, 253 - 1)).
  return F(Math.min(len, 2 ** 53 - 1));
}
ToLength.section = 'https://tc39.es/ecma262/#sec-tolength';
/** https://tc39.es/ecma262/#sec-canonicalnumericindexstring */
function CanonicalNumericIndexString(argument) {
  // 1. Assert: Type(argument) is String.
  Assert(argument instanceof JSStringValue, "argument instanceof JSStringValue");
  // 2. If argument is "-0", return -0𝔽.
  if (argument.stringValue() === '-0') {
    return F(-0);
  }
  // 3. Let n be ! ToNumber(argument).
  /* X */
  let _temp24 = ToNumber(argument);
  /* node:coverage ignore next */
  if (_temp24 && typeof _temp24 === 'object' && 'next' in _temp24) _temp24 = skipDebugger(_temp24);
  /* node:coverage ignore next */
  if (_temp24 instanceof AbruptCompletion) throw new Assert.Error("! ToNumber(argument) returned an abrupt completion", {
    cause: _temp24
  });
  /* node:coverage ignore next */
  if (_temp24 instanceof Completion) _temp24 = _temp24.Value;
  const n = _temp24;
  // 4. If SameValue(! ToString(n), argument) is false, return undefined.
  /* X */
  let _temp25 = ToString(n);
  /* node:coverage ignore next */
  if (_temp25 && typeof _temp25 === 'object' && 'next' in _temp25) _temp25 = skipDebugger(_temp25);
  /* node:coverage ignore next */
  if (_temp25 instanceof AbruptCompletion) throw new Assert.Error("! ToString(n) returned an abrupt completion", {
    cause: _temp25
  });
  /* node:coverage ignore next */
  if (_temp25 instanceof Completion) _temp25 = _temp25.Value;
  if (SameValue(_temp25, argument) === Value.false) {
    return Value.undefined;
  }
  // 4. Return n.
  return n;
}
CanonicalNumericIndexString.section = 'https://tc39.es/ecma262/#sec-canonicalnumericindexstring';
/** https://tc39.es/ecma262/#sec-toindex */
function* ToIndex(value) {
  // 1. If value is undefined, then
  if (value instanceof UndefinedValue) {
    // a. Return 0.
    return 0;
  } else {
    /* ReturnIfAbrupt */
    let _temp26 = yield* ToIntegerOrInfinity(value);
    /* node:coverage ignore next */
    if (_temp26 instanceof AbruptCompletion) return _temp26;
    /* node:coverage ignore next */
    if (_temp26 instanceof Completion) _temp26 = _temp26.Value;
    // a. Let integerIndex be 𝔽(? ToIntegerOrInfinity(value)).
    const integerIndex = F(_temp26);
    // b. If integerIndex < +0𝔽, throw a RangeError exception.
    if (R(integerIndex) < 0) {
      return surroundingAgent.Throw('RangeError', 'NegativeIndex', 'Index');
    }
    // c. Let index be ! ToLength(integerIndex).
    /* X */
    let _temp27 = ToLength(integerIndex);
    /* node:coverage ignore next */
    if (_temp27 && typeof _temp27 === 'object' && 'next' in _temp27) _temp27 = skipDebugger(_temp27);
    /* node:coverage ignore next */
    if (_temp27 instanceof AbruptCompletion) throw new Assert.Error("! ToLength(integerIndex) returned an abrupt completion", {
      cause: _temp27
    });
    /* node:coverage ignore next */
    if (_temp27 instanceof Completion) _temp27 = _temp27.Value;
    const index = _temp27;
    // d. If ! SameValue(integerIndex, index) is false, throw a RangeError exception.
    /* X */
    let _temp28 = SameValue(integerIndex, index);
    /* node:coverage ignore next */
    if (_temp28 && typeof _temp28 === 'object' && 'next' in _temp28) _temp28 = skipDebugger(_temp28);
    /* node:coverage ignore next */
    if (_temp28 instanceof AbruptCompletion) throw new Assert.Error("! SameValue(integerIndex, index) returned an abrupt completion", {
      cause: _temp28
    });
    /* node:coverage ignore next */
    if (_temp28 instanceof Completion) _temp28 = _temp28.Value;
    if (_temp28 === Value.false) {
      return surroundingAgent.Throw('RangeError', 'OutOfRange', 'Index');
    }
    // e. Return ℝ(index).
    return R(index);
  }
}
ToIndex.section = 'https://tc39.es/ecma262/#sec-toindex';

const InternalMethods = {
  /** https://tc39.es/ecma262/#sec-typedarray-preventextensions */
  *PreventExtensions() {
    const O = this;
    if (!IsTypedArrayFixedLength(O)) {
      return Value.false;
    }
    return OrdinaryPreventExtensions(O);
  },
  /** https://tc39.es/ecma262/#sec-typedarray-getownproperty */
  *GetOwnProperty(P) {
    const O = this;
    // 3. If Type(P) is String, then
    if (P instanceof JSStringValue) {
      // a. Let numericIndex be CanonicalNumericIndexString(P).
      const numericIndex = CanonicalNumericIndexString(P);
      // b. If numericIndex is not undefined, then
      if (!(numericIndex instanceof UndefinedValue)) {
        // i. Let value be TypedArrayGetElement(O, numericIndex).
        const value = TypedArrayGetElement(O, numericIndex);
        // ii. If value is undefined, return undefined.
        if (value === Value.undefined) {
          return Value.undefined;
        }
        // iii. Return the PropertyDescriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
        return _Descriptor({
          Value: value,
          Writable: Value.true,
          Enumerable: Value.true,
          Configurable: Value.true
        });
      }
    }
    // 4. Return OrdinaryGetOwnProperty(O, P).
    return OrdinaryGetOwnProperty(O, P);
  },
  /** https://tc39.es/ecma262/#sec-typedarray-hasproperty */
  *HasProperty(P) {
    const O = this;
    // 3. If Type(P) is String, then
    if (P instanceof JSStringValue) {
      // a. Let numericIndex be CanonicalNumericIndexString(P).
      const numericIndex = CanonicalNumericIndexString(P);
      // b. If numericIndex is not undefined, then
      if (!(numericIndex instanceof UndefinedValue)) {
        return IsValidIntegerIndex(O, numericIndex);
      }
    }
    // 4. Return ? OrdinaryHasProperty(O, P)
    return yield* OrdinaryHasProperty(O, P);
  },
  /** https://tc39.es/ecma262/#sec-typedarray-defineownproperty */
  *DefineOwnProperty(P, Desc) {
    const O = this;
    // 3. If Type(P) is String, then
    if (P instanceof JSStringValue) {
      // a. Let numericIndex be CanonicalNumericIndexString(P).
      const numericIndex = CanonicalNumericIndexString(P);
      // b. If numericIndex is not undefined, then
      if (!(numericIndex instanceof UndefinedValue)) {
        // i. If ! IsValidIntegerIndex(O, numericIndex) is false, return false.
        if (IsValidIntegerIndex(O, numericIndex) === Value.false) {
          return Value.false;
        }
        // iii. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is true, return false.
        if (Desc.Configurable === Value.false) {
          return Value.false;
        }
        // iv. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is false, return false.
        if (Desc.Enumerable === Value.false) {
          return Value.false;
        }
        // ii. If IsAccessorDescriptor(Desc) is true, return false.
        if (IsAccessorDescriptor(Desc)) {
          return Value.false;
        }
        // v. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, return false.
        if (Desc.Writable === Value.false) {
          return Value.false;
        }
        // vi. If Desc has a [[Value]] field, then
        if (Desc.Value !== undefined) {
          return yield* TypedArraySetElement(O, numericIndex, Desc.Value);
        }
        // vii. Return true.
        return Value.true;
      }
    }
    // 4. Return ! OrdinaryDefineOwnProperty(O, P, Desc).
    return yield* OrdinaryDefineOwnProperty(O, P, Desc);
  },
  /** https://tc39.es/ecma262/#sec-typedarray-get */
  *Get(P, Receiver) {
    const O = this;
    // 2. If Type(P) is String, then
    if (P instanceof JSStringValue) {
      // a. Let numericIndex be CanonicalNumericIndexString(P).
      const numericIndex = CanonicalNumericIndexString(P);
      // b. If numericIndex is not undefined, then
      if (!(numericIndex instanceof UndefinedValue)) {
        /* X */
        let _temp = TypedArrayGetElement(O, numericIndex);
        /* node:coverage ignore next */
        if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
        /* node:coverage ignore next */
        if (_temp instanceof AbruptCompletion) throw new Assert.Error("! TypedArrayGetElement(O, numericIndex) returned an abrupt completion", {
          cause: _temp
        });
        /* node:coverage ignore next */
        if (_temp instanceof Completion) _temp = _temp.Value;
        // i. Return ! IntegerIndexedElementGet(O, numericIndex).
        return _temp;
      }
    }
    // 3. Return ? OrdinaryGet(O, P, Receiver).
    return yield* OrdinaryGet(O, P, Receiver);
  },
  /** https://tc39.es/ecma262/#sec-typedarray-set */
  *Set(P, V, Receiver) {
    const O = this;
    // 2. If Type(P) is String, then
    if (P instanceof JSStringValue) {
      // a. Let numericIndex be CanonicalNumericIndexString(P).
      const numericIndex = CanonicalNumericIndexString(P);
      // b. If numericIndex is not undefined, then
      if (!(numericIndex instanceof UndefinedValue)) {
        if (SameValue(O, Receiver) === Value.true) {
          /* ReturnIfAbrupt */
          let _temp2 = yield* TypedArraySetElement(O, numericIndex, V);
          /* node:coverage ignore next */
          if (_temp2 instanceof AbruptCompletion) return _temp2;
          /* node:coverage ignore next */
          if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
          // ii. Return true.
          return Value.true;
        }
        if (IsValidIntegerIndex(O, numericIndex) === Value.false) {
          return Value.true;
        }
      }
    }
    // 3. Return ? OrdinarySet(O, P, V, Receiver).
    return yield* OrdinarySet(O, P, V, Receiver);
  },
  /** https://tc39.es/ecma262/#sec-typedarray-delete */
  *Delete(P) {
    const O = this;
    // 3. If Type(P) is String, then
    if (P instanceof JSStringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      const numericIndex = CanonicalNumericIndexString(P);
      // b. If numericIndex is not undefined, then
      if (!(numericIndex instanceof UndefinedValue)) {
        // ii. If IsValidIntegerIndex(O, numericIndex) is false, return true.
        if (IsValidIntegerIndex(O, numericIndex) === Value.false) {
          return Value.true;
        } else {
          // iii. Return false.
          return Value.false;
        }
      }
    }
    // 4. Return ? OrdinaryDelete(O, P).
    return yield* OrdinaryDelete(O, P);
  },
  /** https://tc39.es/ecma262/#sec-typedarray-ownpropertykeys */
  *OwnPropertyKeys() {
    const O = this;
    const taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
    // 1. Let keys be a new empty List.
    const keys = [];
    if (!IsTypedArrayOutOfBounds(taRecord)) {
      const length = TypedArrayLength(taRecord);
      // 4. For each integer i starting with 0 such that i < len, in ascending order, do
      for (let i = 0; i < length; i += 1) {
        /* X */
        let _temp3 = ToString(F(i));
        /* node:coverage ignore next */
        if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
        /* node:coverage ignore next */
        if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! ToString(F(i)) returned an abrupt completion", {
          cause: _temp3
        });
        /* node:coverage ignore next */
        if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        // a. Add ! ToString(𝔽(i)) as the last element of keys.
        keys.push(_temp3);
      }
    }
    // 5. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation, do
    for (const P of O.properties.keys()) {
      if (P instanceof JSStringValue) {
        if (!isIntegerIndex(P)) {
          // a. Add P as the last element of keys.
          keys.push(P);
        }
      }
    }
    // 6. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation, do
    for (const P of O.properties.keys()) {
      if (P instanceof SymbolValue) {
        // a. Add P as the last element of keys.
        keys.push(P);
      }
    }
    // 7. Return keys.
    return keys;
  }
};

/** https://tc39.es/ecma262/#sec-typedarray-with-buffer-witness-records */

/** https://tc39.es/ecma262/#sec-maketypedarraywithbufferwitnessrecord */
function MakeTypedArrayWithBufferWitnessRecord(obj, order) {
  const buffer = obj.ViewedArrayBuffer;
  let byteLength;
  if (IsDetachedBuffer(buffer) === Value.true) {
    byteLength = 'detached';
  } else {
    byteLength = ArrayBufferByteLength(buffer);
  }
  return {
    Object: obj,
    CachedBufferByteLength: byteLength
  };
}
MakeTypedArrayWithBufferWitnessRecord.section = 'https://tc39.es/ecma262/#sec-maketypedarraywithbufferwitnessrecord';
/** https://tc39.es/ecma262/#sec-typedarraycreate */
function TypedArrayCreate(prototype) {
  const internalSlotsList = ['Prototype', 'Extensible', 'ViewedArrayBuffer', 'TypedArrayName', 'ContentType', 'ByteLength', 'ByteOffset', 'ArrayLength'];
  const A = MakeBasicObject(internalSlotsList);
  A.PreventExtensions = InternalMethods.PreventExtensions;
  A.GetOwnProperty = InternalMethods.GetOwnProperty;
  A.HasProperty = InternalMethods.HasProperty;
  A.DefineOwnProperty = InternalMethods.DefineOwnProperty;
  A.Get = InternalMethods.Get;
  A.Set = InternalMethods.Set;
  A.Delete = InternalMethods.Delete;
  A.OwnPropertyKeys = InternalMethods.OwnPropertyKeys;
  A.Prototype = prototype;
  return A;
}
TypedArrayCreate.section = 'https://tc39.es/ecma262/#sec-typedarraycreate';
/** https://tc39.es/ecma262/#sec-typedarraybytelength */
function TypedArrayByteLength(taRecord) {
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return 0;
  }
  const length = TypedArrayLength(taRecord);
  if (length === 0) {
    return 0;
  }
  const O = taRecord.Object;
  if (O.ByteLength !== 'auto') {
    return O.ByteLength;
  }
  const elementSize = TypedArrayElementSize(O);
  return length * elementSize;
}
TypedArrayByteLength.section = 'https://tc39.es/ecma262/#sec-typedarraybytelength';
/** https://tc39.es/ecma262/#sec-typedarraylength */
function TypedArrayLength(taRecord) {
  Assert(IsTypedArrayOutOfBounds(taRecord) === false, "IsTypedArrayOutOfBounds(taRecord) === false");
  const O = taRecord.Object;
  if (O.ArrayLength !== 'auto') {
    return O.ArrayLength;
  }
  Assert(!IsFixedLengthArrayBuffer(O.ViewedArrayBuffer), "!IsFixedLengthArrayBuffer(O.ViewedArrayBuffer as ArrayBufferObject)");
  const byteOffset = O.ByteOffset;
  const elementSize = TypedArrayElementSize(O);
  const bufferLength = taRecord.CachedBufferByteLength;
  Assert(bufferLength !== 'detached', "bufferLength !== 'detached'");
  return Math.floor((bufferLength - byteOffset) / elementSize);
}
TypedArrayLength.section = 'https://tc39.es/ecma262/#sec-typedarraylength';
/** https://tc39.es/ecma262/#sec-istypedarrayoutofbounds */
function IsTypedArrayOutOfBounds(taRecord) {
  const O = taRecord.Object;
  const bufferByteLength = taRecord.CachedBufferByteLength;
  Assert(IsDetachedBuffer(O.ViewedArrayBuffer) === Value.true && bufferByteLength === 'detached' || IsDetachedBuffer(O.ViewedArrayBuffer) === Value.false && bufferByteLength !== 'detached', "(IsDetachedBuffer(O.ViewedArrayBuffer as ArrayBufferObject) === Value.true && bufferByteLength === 'detached')\n    || (IsDetachedBuffer(O.ViewedArrayBuffer as ArrayBufferObject) === Value.false && bufferByteLength !== 'detached')");
  if (bufferByteLength === 'detached') {
    return true;
  }
  const byteOffsetStart = O.ByteOffset;
  let byteOffsetEnd;
  if (O.ArrayLength === 'auto') {
    byteOffsetEnd = bufferByteLength;
  } else {
    const elementSize = TypedArrayElementSize(O);
    byteOffsetEnd = byteOffsetStart + O.ArrayLength * elementSize;
  }
  if (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {
    return true;
  }
  return false;
}
IsTypedArrayOutOfBounds.section = 'https://tc39.es/ecma262/#sec-istypedarrayoutofbounds';
/** https://tc39.es/ecma262/#sec-istypedarrayfixedlength */
function IsTypedArrayFixedLength(O) {
  if (O.ArrayLength === 'auto') {
    return false;
  }
  const buffer = O.ViewedArrayBuffer;
  if (!IsFixedLengthArrayBuffer(buffer) && IsSharedArrayBuffer() === Value.false) {
    return false;
  }
  return true;
}
IsTypedArrayFixedLength.section = 'https://tc39.es/ecma262/#sec-istypedarrayfixedlength';
/** https://tc39.es/ecma262/#sec-isvalidintegerindex */
function IsValidIntegerIndex(O, index) {
  if (IsDetachedBuffer(O.ViewedArrayBuffer) === Value.true) {
    return Value.false;
  }
  if (IsIntegralNumber(index) === Value.false) {
    return Value.false;
  }
  const index_ = R(index);
  if (Object.is(index_, -0) || index_ < 0) {
    return Value.false;
  }
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
  if (IsTypedArrayOutOfBounds(taRecord)) {
    return Value.false;
  }
  const length = TypedArrayLength(taRecord);
  if (index_ >= length) {
    return Value.false;
  }
  return Value.true;
}
IsValidIntegerIndex.section = 'https://tc39.es/ecma262/#sec-isvalidintegerindex';
/** https://tc39.es/ecma262/#sec-typedarraygetelement */
function TypedArrayGetElement(O, index) {
  if (IsValidIntegerIndex(O, index) === Value.false) {
    return Value.undefined;
  }
  const offset = O.ByteOffset;
  const elementSize = TypedArrayElementSize(O);
  const byteIndexInBuffer = R(index) * elementSize + offset;
  const elementType = TypedArrayElementType(O);
  return GetValueFromBuffer(O.ViewedArrayBuffer, byteIndexInBuffer, elementType);
}
TypedArrayGetElement.section = 'https://tc39.es/ecma262/#sec-typedarraygetelement';
/** https://tc39.es/ecma262/#sec-integerindexedelementset */
function* TypedArraySetElement(O, index, value) {
  // 3. If O.[[ContentType]] is BigInt, let numValue be ? ToBigInt(value).
  // 4. Otherwise, let numValue be ? ToNumber(value).
  let numValue;
  if (O.ContentType === 'BigInt') {
    /* ReturnIfAbrupt */
    let _temp4 = yield* ToBigInt(value);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) return _temp4;
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    numValue = _temp4;
  } else {
    /* ReturnIfAbrupt */
    let _temp5 = yield* ToNumber(value);
    /* node:coverage ignore next */
    if (_temp5 instanceof AbruptCompletion) return _temp5;
    /* node:coverage ignore next */
    if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    numValue = _temp5;
  }
  if (IsValidIntegerIndex(O, index) === Value.true) {
    const offset = O.ByteOffset;
    const elementSize = TypedArrayElementSize(O);
    const byteIndexInBuffer = R(index) * elementSize + offset;
    const elementType = TypedArrayElementType(O);
    /* ReturnIfAbrupt */
    let _temp6 = yield* SetValueInBuffer(O.ViewedArrayBuffer, byteIndexInBuffer, elementType, numValue);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    return Value.true;
  }
  return Value.true;
}
TypedArraySetElement.section = 'https://tc39.es/ecma262/#sec-integerindexedelementset';
/** https://tc39.es/ecma262/#sec-isarraybufferviewoutofbounds */
function IsArrayBufferViewOutOfBounds(O) {
  if (isDataViewObject(O)) {
    const viewRecord = MakeDataViewWithBufferWitnessRecord(O);
    return IsViewOutOfBounds(viewRecord);
  }
  const taRecord = MakeTypedArrayWithBufferWitnessRecord(O);
  return IsTypedArrayOutOfBounds(taRecord);
}
IsArrayBufferViewOutOfBounds.section = 'https://tc39.es/ecma262/#sec-isarraybufferviewoutofbounds';

/** https://tc39.es/ecma262/#sec-clear-kept-objects */
function ClearKeptObjects() {
  // 1. Let agentRecord be the surrounding agent's Agent Record.
  const agentRecord = surroundingAgent.AgentRecord;
  // 2. Set agentRecord.[[KeptAlive]] to a new empty List.
  agentRecord.KeptAlive = new Set();
}
ClearKeptObjects.section = 'https://tc39.es/ecma262/#sec-clear-kept-objects';
/** https://tc39.es/ecma262/#sec-addtokeptobjects */
function AddToKeptObjects(object) {
  // 1. Let agentRecord be the surrounding agent's Agent Record.
  const agentRecord = surroundingAgent.AgentRecord;
  // 2. Append object to agentRecord.[[KeptAlive]].
  agentRecord.KeptAlive.add(object);
}
AddToKeptObjects.section = 'https://tc39.es/ecma262/#sec-addtokeptobjects';
/** https://tc39.es/ecma262/#sec-weakrefderef */
function WeakRefDeref(weakRef) {
  // 1. Let target be weakRef.[[WeakRefTarget]].
  const target = weakRef.WeakRefTarget;
  // 2. If target is not empty, then
  if (target !== undefined) {
    /* X */
    let _temp = AddToKeptObjects(target);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! AddToKeptObjects(target) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    // b. Return target.
    return target;
  }
  // 3. Return undefined.
  return Value.undefined;
}
WeakRefDeref.section = 'https://tc39.es/ecma262/#sec-weakrefderef';
/** https://tc39.es/ecma262/#sec-cleanup-finalization-registry */
function* CleanupFinalizationRegistry(finalizationRegistry, callback) {
  /* ReturnIfAbrupt */
  let _temp2 = surroundingAgent.debugger_tryTouchDuringPreview(finalizationRegistry);
  /* node:coverage ignore next */
  if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
  /* node:coverage ignore next */
  if (_temp2 instanceof AbruptCompletion) return _temp2;
  /* node:coverage ignore next */
  if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
  // 1. Assert: finalizationRegistry has [[Cells]] and [[CleanupCallback]] internal slots.
  Assert('Cells' in finalizationRegistry && 'CleanupCallback' in finalizationRegistry, "'Cells' in finalizationRegistry && 'CleanupCallback' in finalizationRegistry");
  // 2. Set callback to finalizationRegistry.[[CleanupCallback]].
  if (callback === undefined) {
    callback = finalizationRegistry.CleanupCallback;
  }
  // 3. While finalizationRegistry.[[Cells]] contains a Record cell such that cell.[[WeakRefTarget]] is empty, an implementation may perform the following steps:
  for (let i = 0; i < finalizationRegistry.Cells.length; i += 1) {
    // a. Choose any such _cell_.
    const cell = finalizationRegistry.Cells[i];
    if (cell.WeakRefTarget !== undefined) {
      continue;
    }
    // b. Remove cell from finalizationRegistry.[[Cells]].
    finalizationRegistry.Cells.splice(i, 1);
    i -= 1;
    // c. Perform ? HostCallJobCallback(callback, undefined, « cell.[[HeldValue]] »).
    /* ReturnIfAbrupt */
    let _temp3 = yield* HostCallJobCallback(callback, Value.undefined, [cell.HeldValue]);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) return _temp3;
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
  }
  // 4. Return NormalCompletion(undefined).
  return NormalCompletion(Value.undefined);
}
CleanupFinalizationRegistry.section = 'https://tc39.es/ecma262/#sec-cleanup-finalization-registry';
/** https://tc39.es/ecma262/#sec-canbeheldweakly */
function CanBeHeldWeakly(v) {
  // 1. If v is an Object, return true.
  if (v instanceof ObjectValue) {
    return Value.true;
  }

  // 2. If v is a Symbol and KeyForSymbol(v) is undefined, return true.
  if (v instanceof SymbolValue && KeyForSymbol(v) === Value.undefined) {
    return Value.true;
  }

  // 3. Return false.
  return Value.false;
}
CanBeHeldWeakly.section = 'https://tc39.es/ecma262/#sec-canbeheldweakly';

const bareKeyRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
function getObjectTag(value, wrap = false) {
  let s = '';
  try {
    /* X */
    let _temp = Get(value, wellKnownSymbols.toStringTag);
    /* node:coverage ignore next */
    if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
    /* node:coverage ignore next */
    if (_temp instanceof AbruptCompletion) throw new Assert.Error("! Get(value, wellKnownSymbols.toStringTag) returned an abrupt completion", {
      cause: _temp
    });
    /* node:coverage ignore next */
    if (_temp instanceof Completion) _temp = _temp.Value;
    s = _temp.stringValue();
  } catch {}
  try {
    /* X */
    let _temp2 = Get(value, Value('constructor'));
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! Get(value, Value('constructor')) returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    const c = _temp2;
    /* X */
    let _temp3 = Get(c, Value('name'));
    /* node:coverage ignore next */
    if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) _temp3 = skipDebugger(_temp3);
    /* node:coverage ignore next */
    if (_temp3 instanceof AbruptCompletion) throw new Assert.Error("! Get(c as ObjectValue, Value('name')) returned an abrupt completion", {
      cause: _temp3
    });
    /* node:coverage ignore next */
    if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
    s = _temp3.stringValue();
  } catch {}
  if (s) {
    if (wrap) {
      return `[${s}] `;
    }
    return s;
  }
  return '';
}
const compactObject = (realm, value) => {
  try {
    /* X */
    let _temp4 = Get(value, Value('toString'));
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! Get(value, Value('toString')) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    const toString = _temp4;
    const objectToString = realm.Intrinsics['%Object.prototype.toString%'];
    if (toString.nativeFunction === objectToString.nativeFunction) {
      /* X */
      let _temp5 = Call(toString, value);
      /* node:coverage ignore next */
      if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! Call(toString, value) returned an abrupt completion", {
        cause: _temp5
      });
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      return _temp5.stringValue();
    } else {
      const tag = getObjectTag(value, false) || 'Unknown';
      /* X */
      let _temp6 = Get(value, Value('constructor'));
      /* node:coverage ignore next */
      if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) _temp6 = skipDebugger(_temp6);
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) throw new Assert.Error("! Get(value, Value('constructor')) returned an abrupt completion", {
        cause: _temp6
      });
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      const ctor = _temp6;
      if (ctor instanceof ObjectValue) {
        /* X */
        let _temp7 = Get(ctor, Value('name'));
        /* node:coverage ignore next */
        if (_temp7 && typeof _temp7 === 'object' && 'next' in _temp7) _temp7 = skipDebugger(_temp7);
        /* node:coverage ignore next */
        if (_temp7 instanceof AbruptCompletion) throw new Assert.Error("! Get(ctor, Value('name')) returned an abrupt completion", {
          cause: _temp7
        });
        /* node:coverage ignore next */
        if (_temp7 instanceof Completion) _temp7 = _temp7.Value;
        const ctorName = _temp7.stringValue();
        if (ctorName !== '') {
          return `#<${ctorName}>`;
        }
        return `[object ${tag}]`;
      }
      return `[object ${tag}]`;
    }
  } catch (e) {
    return '[object Unknown]';
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any

const INSPECTORS = {
  Null: () => 'null',
  Undefined: () => 'undefined',
  Boolean: v => v.booleanValue().toString(),
  Number: v => {
    const n = R(v);
    if (n === 0 && Object.is(n, -0)) {
      return '-0';
    }
    return n.toString();
  },
  BigInt: v => `${R(v)}n`,
  String: v => {
    const s = JSON.stringify(v.stringValue()).slice(1, -1);
    return `'${s}'`;
  },
  Symbol: v => `Symbol(${v.Description instanceof UndefinedValue ? '' : v.Description.stringValue()})`,
  Object: (v, ctx, i) => {
    if (ctx.inspected.includes(v)) {
      return '[Circular]';
    }
    if ('PromiseState' in v) {
      ctx.indent += 1;
      const result = v.PromiseState === 'pending' ? 'undefined' : i(v.PromiseResult);
      ctx.indent -= 1;
      return `Promise {
  [[PromiseState]]: ${v.PromiseState}
  [[PromiseResult]]: ${result}
}`;
    }
    if ('Call' in v) {
      const name = v.properties.get('name');
      if (name && name.Value.stringValue() !== '') {
        return `[Function: ${name.Value.stringValue()}]`;
      }
      return '[Function]';
    }
    if ('ErrorData' in v) {
      /* X */
      let _temp8 = Get(v, Value('stack'));
      /* node:coverage ignore next */
      if (_temp8 && typeof _temp8 === 'object' && 'next' in _temp8) _temp8 = skipDebugger(_temp8);
      /* node:coverage ignore next */
      if (_temp8 instanceof AbruptCompletion) throw new Assert.Error("! Get(v, Value('stack')) returned an abrupt completion", {
        cause: _temp8
      });
      /* node:coverage ignore next */
      if (_temp8 instanceof Completion) _temp8 = _temp8.Value;
      let e = _temp8;
      if (!e.stringValue) {
        /* X */
        let _temp9 = Get(v, Value('toString'));
        /* node:coverage ignore next */
        if (_temp9 && typeof _temp9 === 'object' && 'next' in _temp9) _temp9 = skipDebugger(_temp9);
        /* node:coverage ignore next */
        if (_temp9 instanceof AbruptCompletion) throw new Assert.Error("! Get(v, Value('toString')) returned an abrupt completion", {
          cause: _temp9
        });
        /* node:coverage ignore next */
        if (_temp9 instanceof Completion) _temp9 = _temp9.Value;
        const toString = _temp9;
        /* X */
        let _temp10 = Call(toString, v);
        /* node:coverage ignore next */
        if (_temp10 && typeof _temp10 === 'object' && 'next' in _temp10) _temp10 = skipDebugger(_temp10);
        /* node:coverage ignore next */
        if (_temp10 instanceof AbruptCompletion) throw new Assert.Error("! Call(toString, v) returned an abrupt completion", {
          cause: _temp10
        });
        /* node:coverage ignore next */
        if (_temp10 instanceof Completion) _temp10 = _temp10.Value;
        e = _temp10;
      }
      return e.stringValue();
    }
    if (isRegExpObject(v)) {
      const P = EscapeRegExpPattern(v.OriginalSource, v.OriginalFlags).stringValue();
      const F = v.OriginalFlags.stringValue();
      return `/${P}/${F}`;
    }
    if ('DateValue' in v) {
      const d = new Date(R(v.DateValue));
      if (Number.isNaN(d.getTime())) {
        return '[Date Invalid]';
      }
      return `[Date ${d.toISOString()}]`;
    }
    if ('BooleanData' in v) {
      return `[Boolean ${i(v.BooleanData)}]`;
    }
    if ('NumberData' in v) {
      return `[Number ${i(v.NumberData)}]`;
    }
    if ('BigIntData' in v) {
      return `[BigInt ${i(v.BigIntData)}]`;
    }
    if ('StringData' in v) {
      return `[String ${i(v.StringData)}]`;
    }
    if ('SymbolData' in v) {
      return `[Symbol ${i(v.SymbolData)}]`;
    }
    ctx.indent += 1;
    ctx.inspected.push(v);
    try {
      const isArray = IsArray(v) === Value.true;
      const isTypedArray = isTypedArrayObject(v);
      if (isArray || isTypedArray) {
        /* X */
        let _temp11 = LengthOfArrayLike(v);
        /* node:coverage ignore next */
        if (_temp11 && typeof _temp11 === 'object' && 'next' in _temp11) _temp11 = skipDebugger(_temp11);
        /* node:coverage ignore next */
        if (_temp11 instanceof AbruptCompletion) throw new Assert.Error("! LengthOfArrayLike(v) returned an abrupt completion", {
          cause: _temp11
        });
        /* node:coverage ignore next */
        if (_temp11 instanceof Completion) _temp11 = _temp11.Value;
        const length = _temp11;
        let holes = 0;
        const flushHoles = () => {
          if (holes > 0) {
            out.push(`<${holes} empty items>`);
            holes = 0;
          }
        };
        const out = [];
        for (let j = 0; j < length; j += 1) {
          /* X */
          let _temp12 = v.GetOwnProperty(Value(j.toString()));
          /* node:coverage ignore next */
          if (_temp12 && typeof _temp12 === 'object' && 'next' in _temp12) _temp12 = skipDebugger(_temp12);
          /* node:coverage ignore next */
          if (_temp12 instanceof AbruptCompletion) throw new Assert.Error("! v.GetOwnProperty(Value(j.toString())) returned an abrupt completion", {
            cause: _temp12
          });
          /* node:coverage ignore next */
          if (_temp12 instanceof Completion) _temp12 = _temp12.Value;
          const elem = _temp12;
          if (elem instanceof UndefinedValue) {
            holes += 1;
          } else {
            flushHoles();
            if (elem.Value) {
              out.push(i(elem.Value));
            } else {
              out.push('<accessor>');
            }
          }
        }
        flushHoles();
        return `${isTypedArray ? `${v.TypedArrayName.stringValue()} ` : ''}[${out.join(', ')}]`;
      }
      /* X */
      let _temp13 = v.OwnPropertyKeys();
      /* node:coverage ignore next */
      if (_temp13 && typeof _temp13 === 'object' && 'next' in _temp13) _temp13 = skipDebugger(_temp13);
      /* node:coverage ignore next */
      if (_temp13 instanceof AbruptCompletion) throw new Assert.Error("! v.OwnPropertyKeys() returned an abrupt completion", {
        cause: _temp13
      });
      /* node:coverage ignore next */
      if (_temp13 instanceof Completion) _temp13 = _temp13.Value;
      const keys = _temp13;
      const cache = [];
      for (const key of keys) {
        /* X */
        let _temp14 = v.GetOwnProperty(key);
        /* node:coverage ignore next */
        if (_temp14 && typeof _temp14 === 'object' && 'next' in _temp14) _temp14 = skipDebugger(_temp14);
        /* node:coverage ignore next */
        if (_temp14 instanceof AbruptCompletion) throw new Assert.Error("! v.GetOwnProperty(key) returned an abrupt completion", {
          cause: _temp14
        });
        /* node:coverage ignore next */
        if (_temp14 instanceof Completion) _temp14 = _temp14.Value;
        const C = _temp14;
        if (C.Enumerable === Value.true) {
          cache.push([key instanceof JSStringValue && bareKeyRe.test(key.stringValue()) ? key.stringValue() : i(key), C.Value ? i(C.Value) : '<accessor>']);
        }
      }
      const tag = getObjectTag(v);
      let out = tag && tag !== 'Object' ? `${tag} {` : '{';
      if (cache.length > 5) {
        cache.forEach(c => {
          out = `${out}\n${'  '.repeat(ctx.indent)}${c[0]}: ${c[1]},`;
        });
        return `${out}\n${'  '.repeat(ctx.indent - 1)}}`;
      } else {
        const oc = ctx.compact;
        ctx.compact = true;
        cache.forEach((c, index) => {
          out = `${out}${index === 0 ? '' : ','} ${c[0]}: ${c[1]}`;
        });
        ctx.compact = oc;
        return `${out} }`;
      }
    } catch {
      return compactObject(ctx.realm, v);
    } finally {
      ctx.indent -= 1;
      ctx.inspected.pop();
    }
  }
};
function inspect(value) {
  const context = {
    realm: surroundingAgent.currentRealmRecord,
    indent: 0,
    inspected: [],
    compact: false
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const inner = v => INSPECTORS[v.type](v, context, inner);
  if (value instanceof Completion) {
    value = value.Value;
  }
  return inner(value);
}

function Throw(type, template, ...templateArgs) {
  return surroundingAgent.Throw(type, template, ...templateArgs);
}

/** https://tc39.es/ecma262/#sec-weakref-execution */
function gc() {
  // At any time, if a set of objects S is not live, an ECMAScript implementation may perform the following steps atomically:
  // 1. For each obj of S, do
  //   a. For each WeakRef ref such that ref.[[WeakRefTarget]] is obj,
  //     i. Set ref.[[WeakRefTarget]] to empty.
  //   b. For each FinalizationRegistry fg such that fg.[[Cells]] contains cell, and cell.[[WeakRefTarget]] is obj,
  //     i. Set cell.[[WeakRefTarget]] to empty.
  //     ii. Optionally, perform ! HostEnqueueFinalizationRegistryCleanupJob(fg).
  //   c. For each WeakMap map such that map.WeakMapData contains a record r such that r.Key is obj,
  //     i. Set r.[[Key]] to empty.
  //     ii. Set r.[[Value]] to empty.
  //   d. For each WeakSet set such that set.[[WeakSetData]] contains obj,
  //     i. Replace the element of set whose value is obj with an element whose value is empty.

  const marked = new Set();
  const weakrefs = new Set();
  const fgs = new Set();
  const weakmaps = new Set();
  const weaksets = new Set();
  const ephemeronQueue = [];
  const markCb = O => {
    if (typeof O !== 'object' || O === null) {
      return;
    }
    if (marked.has(O)) {
      return;
    }
    marked.add(O);
    if (isWeakRef(O)) {
      weakrefs.add(O);
      markCb(O.properties);
      markCb(O.Prototype);
    } else if (isFinalizationRegistryObject(O)) {
      fgs.add(O);
      markCb(O.properties);
      markCb(O.Prototype);
      O.Cells.forEach(cell => {
        markCb(cell.HeldValue);
      });
    } else if (isWeakMapObject(O)) {
      weakmaps.add(O);
      markCb(O.properties);
      markCb(O.Prototype);
      O.WeakMapData.forEach(r => {
        ephemeronQueue.push(r);
      });
    } else if (isWeakSetObject(O)) {
      weaksets.add(O);
      markCb(O.properties);
      markCb(O.Prototype);
    } else if ('mark' in O) {
      O.mark(markCb);
    }
  };
  markCb(surroundingAgent);
  while (ephemeronQueue.length > 0) {
    const item = ephemeronQueue.shift();
    if (marked.has(item.Key)) {
      markCb(item.Value);
    }
  }
  weakrefs.forEach(ref => {
    if (!marked.has(ref.WeakRefTarget)) {
      ref.WeakRefTarget = undefined;
    }
  });
  fgs.forEach(fg => {
    let dirty = false;
    fg.Cells.forEach(cell => {
      if (!marked.has(cell.WeakRefTarget)) {
        cell.WeakRefTarget = undefined;
        dirty = true;
      }
    });
    if (dirty) {
      /* X */
      let _temp = HostEnqueueFinalizationRegistryCleanupJob(fg);
      /* node:coverage ignore next */
      if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
      /* node:coverage ignore next */
      if (_temp instanceof AbruptCompletion) throw new Assert.Error("! HostEnqueueFinalizationRegistryCleanupJob(fg) returned an abrupt completion", {
        cause: _temp
      });
      /* node:coverage ignore next */
      if (_temp instanceof Completion) _temp = _temp.Value;
    }
  });
  weakmaps.forEach(map => {
    map.WeakMapData.forEach(r => {
      if (!marked.has(r.Key)) {
        r.Key = undefined;
        r.Value = undefined;
      }
    });
  });
  weaksets.forEach(set => {
    set.WeakSetData.forEach((obj, i) => {
      if (!marked.has(obj)) {
        set.WeakSetData[i] = undefined;
      }
    });
  });
}
gc.section = 'https://tc39.es/ecma262/#sec-weakref-execution';
/** https://tc39.es/ecma262/#sec-jobs */
function runJobQueue() {
  if (surroundingAgent.executionContextStack.some(e => e.ScriptOrModule !== Value.null)) {
    return;
  }

  // At some future point in time, when there is no running execution context
  // and the execution context stack is empty, the implementation must:
  while (surroundingAgent.jobQueue.length > 0) {
    // eslint-disable-line no-constant-condition
    const {
      job: abstractClosure,
      callerRealm,
      callerScriptOrModule
    } = surroundingAgent.jobQueue.shift();

    // 1. Perform any implementation-defined preparation steps.
    const newContext = new ExecutionContext();
    surroundingAgent.executionContextStack.push(newContext);
    newContext.Function = Value.null;
    newContext.Realm = callerRealm;
    newContext.ScriptOrModule = callerScriptOrModule;
    // 2. Call the abstract closure.
    /* X */
    let _temp2 = abstractClosure();
    /* node:coverage ignore next */
    if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) _temp2 = skipDebugger(_temp2);
    /* node:coverage ignore next */
    if (_temp2 instanceof AbruptCompletion) throw new Assert.Error("! abstractClosure() returned an abrupt completion", {
      cause: _temp2
    });
    /* node:coverage ignore next */
    if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
    // 3. Perform any host-defined cleanup steps, after which the execution context stack must be empty.
    ClearKeptObjects();
    gc();
    surroundingAgent.executionContextStack.pop(newContext);
  }
}
runJobQueue.section = 'https://tc39.es/ecma262/#sec-jobs';
class ManagedRealm extends Realm {
  TemplateMap;
  AgentSignifier;
  Intrinsics;
  randomState;
  GlobalObject;
  GlobalEnv;
  HostDefined;
  topContext;
  active = false;

  /** https://tc39.es/ecma262/#sec-initializehostdefinedrealm */
  constructor(HostDefined = {}) {
    super();
    this.Intrinsics = CreateIntrinsics(this);
    this.AgentSignifier = AgentSignifier();
    this.TemplateMap = [];
    const newContext = new ExecutionContext();
    newContext.Function = Value.null;
    newContext.Realm = this;
    newContext.ScriptOrModule = Value.null;
    surroundingAgent.executionContextStack.push(newContext);
    // TODO: a host hook for exotic global object
    const global = OrdinaryObjectCreate(this.Intrinsics['%Object.prototype%']);
    // TODO: a host hook for global "this" binding
    const thisValue = global;
    this.GlobalObject = global;
    this.GlobalEnv = new GlobalEnvironmentRecord(global, thisValue);
    skipDebugger(SetDefaultGlobalBindings(this));

    // misc
    surroundingAgent.executionContextStack.pop(newContext);
    this.HostDefined = HostDefined;
    this.topContext = newContext;
    surroundingAgent.hostDefinedOptions.onRealmCreated?.(this);
  }
  scope(arg0, arg2) {
    if (typeof arg0 !== 'function') try {
      var _usingCtx$1 = _usingCtx();
      const inspectorPreview = arg0;
      if (this.active) {
        return null;
      }
      this.active = true;
      surroundingAgent.executionContextStack.push(this.topContext);
      const _ = _usingCtx$1.u(inspectorPreview ? surroundingAgent.debugger_scopePreview() : null);
      return {
        [Symbol.dispose]: () => {
          surroundingAgent.executionContextStack.pop(this.topContext);
          this.active = false;
        }
      };
    } catch (_) {
      _usingCtx$1.e = _;
    } finally {
      _usingCtx$1.d();
    } else {
      const callback = arg0;
      if (this.active) {
        return arg0();
      }
      this.active = true;
      surroundingAgent.executionContextStack.push(this.topContext);
      const result = arg2 ? surroundingAgent.debugger_scopePreview(callback) : callback();
      surroundingAgent.executionContextStack.pop(this.topContext);
      this.active = false;
      return result;
    }
  }
  compileScript(sourceText, hostDefined) {
    return this.scope(() => {
      const s = ParseScript(sourceText, this, hostDefined);
      if (Array.isArray(s)) {
        return ThrowCompletion(s[0]);
      }
      return NormalCompletion(s);
    });
  }
  compileModule(sourceText, hostDefined) {
    return this.scope(() => {
      const s = ParseModule(sourceText, this, {
        SourceTextModuleRecord: ManagedSourceTextModuleRecord,
        ...hostDefined
      });
      if (Array.isArray(s)) {
        return ThrowCompletion(s[0]);
      }
      return NormalCompletion(s);
    });
  }

  /**
   * Call surroundingAgent.resumeEvaluate() to continue evaluation.
   *
   * This function will synchronously return a completion if this is a nested evaluation and debugger cannot be triggered.
   */
  evaluate(sourceText, callback) {
    if (!sourceText) {
      throw new TypeError('sourceText is null or undefined');
    }
    let result;
    if (sourceText instanceof AbstractModuleRecord) {
      const old = this.active;
      this.active = true;
      surroundingAgent.executionContextStack.push(this.topContext);
      const loadModuleCompletion = sourceText.LoadRequestedModules();
      const link = (() => {
        if (loadModuleCompletion.PromiseState === 'rejected') {
          /* ReturnIfAbrupt */
          let _temp3 = Throw(loadModuleCompletion.PromiseResult, 'Raw', 'Module load failed');
          /* node:coverage ignore next */
          if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (_temp3 instanceof AbruptCompletion) return _temp3;
          /* node:coverage ignore next */
          if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        } else if (loadModuleCompletion.PromiseState === 'pending') {
          throw new Error('Internal error: .LoadRequestedModules() returned a pending promise');
        }
        /* ReturnIfAbrupt */
        let _temp4 = sourceText.Link();
        /* node:coverage ignore next */
        if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp4 instanceof AbruptCompletion) return _temp4;
        /* node:coverage ignore next */
        if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
      })();
      if (link instanceof ThrowCompletion) {
        callback(link);
        return link;
      }
      surroundingAgent.evaluate(sourceText.Evaluate(), completion => {
        if (completion instanceof NormalCompletion && completion.Value.PromiseState === 'fulfilled') {
          result = GetModuleNamespace(sourceText);
        } else {
          result = completion;
        }
        this.active = old;
        surroundingAgent.executionContextStack.pop(this.topContext);
        callback(EnsureCompletion(result));
      });
      return result;
    } else if (sourceText instanceof ScriptRecord) {
      const old = this.active;
      this.active = true;
      surroundingAgent.executionContextStack.push(this.topContext);
      surroundingAgent.evaluate(ScriptEvaluation(sourceText), completion => {
        this.active = old;
        surroundingAgent.executionContextStack.pop(this.topContext);
        result = completion;
        callback(completion);
      });
      return result;
    } else {
      // this path only called by the inspector
      Assert(!!surroundingAgent.hostDefinedOptions.onDebugger, "!!surroundingAgent.hostDefinedOptions.onDebugger");
      let emptyExecutionStack = false;
      if (!surroundingAgent.runningExecutionContext) {
        emptyExecutionStack = true;
        this.active = true;
        surroundingAgent.executionContextStack.push(this.topContext);
      }
      surroundingAgent.evaluate(sourceText, completion => {
        result = completion;
        if (emptyExecutionStack) {
          this.active = false;
          surroundingAgent.executionContextStack.pop(this.topContext);
        }
        callback(completion);
      });
      return result;
    }
  }
  evaluateScript(sourceText, {
    specifier,
    doNotTrackScriptId
  } = {}) {
    if (sourceText === undefined || sourceText === null) {
      throw new TypeError('sourceText must be a string or a ScriptRecord');
    }
    if (typeof sourceText === 'string') {
      /* ReturnIfAbrupt */
      let _temp5 = this.compileScript(sourceText, {
        specifier,
        doNotTrackScriptId
      });
      /* node:coverage ignore next */
      if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) return _temp5;
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
      sourceText = _temp5;
    }
    let completion;
    completion = this.evaluate(sourceText, c => {
      completion = c;
    });
    if (!completion) {
      surroundingAgent.resumeEvaluate({
        noBreakpoint: true
      });
    }
    if (!completion) {
      throw new Assert.Error('Expect evaluation completes synchronously');
    }
    if (!(completion instanceof AbruptCompletion)) {
      runJobQueue();
    }
    return completion;
  }
  evaluateModule(sourceText, specifier) {
    if (sourceText === undefined || sourceText === null) {
      throw new TypeError('sourceText must be a string or a ModuleRecord');
    }
    if (typeof sourceText === 'string') {
      /* ReturnIfAbrupt */
      let _temp6 = this.compileModule(sourceText, {
        specifier
      });
      /* node:coverage ignore next */
      if (_temp6 && typeof _temp6 === 'object' && 'next' in _temp6) throw new Assert.Error('Forgot to yield* on the completion.');
      /* node:coverage ignore next */
      if (_temp6 instanceof AbruptCompletion) return _temp6;
      /* node:coverage ignore next */
      if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
      sourceText = _temp6;
    }
    let completion;
    completion = this.evaluate(sourceText, c => {
      completion = c;
      if (!(completion instanceof AbruptCompletion)) {
        runJobQueue();
      }
    });
    if (!completion) {
      surroundingAgent.resumeEvaluate({
        noBreakpoint: true
      });
    }
    return sourceText;
  }

  /**
   * @deprecated use compileModule
   */
  createSourceTextModule(specifier, sourceText) {
    if (typeof specifier !== 'string') {
      throw new TypeError('specifier must be a string');
    }
    if (typeof sourceText !== 'string') {
      throw new TypeError('sourceText must be a string');
    }
    const module = this.scope(() => ParseModule(sourceText, this, {
      specifier,
      SourceTextModuleRecord: ManagedSourceTextModuleRecord
    }));
    if (Array.isArray(module)) {
      return ThrowCompletion(module[0]);
    }
    return module;
  }
  createJSONModule(specifier, sourceText) {
    if (typeof specifier !== 'string') {
      throw new TypeError('specifier must be a string');
    }
    if (typeof sourceText !== 'string') {
      throw new TypeError('sourceText must be a string');
    }
    const module = this.scope(() => ParseJSONModule(Value(sourceText), this, {
      specifier
    }));
    return module;
  }
}
class ManagedSourceTextModuleRecord extends SourceTextModuleRecord {
  *Evaluate() {
    const r = yield* super.Evaluate();
    runJobQueue();
    return r;
  }
}

/** https://github.com/tc39/test262/blob/main/INTERPRETING.md */
function createTest262Intrinsics(realm, printCompatMode) {
  return realm.scope(() => {
    let test262PrintHandle;
    const setPrintHandle = f => {
      test262PrintHandle = f;
    };
    const print = CreateBuiltinFunction(args => {
      if (surroundingAgent.debugger_isPreviewing) {
        return NormalCompletion(Value.undefined);
      }
      /* node:coverage ignore next */
      if (test262PrintHandle) {
        if (args[0] instanceof JSStringValue) {
          test262PrintHandle(args[0].stringValue());
          return Value.undefined;
        }
      } else {
        if (printCompatMode) {
          const str = [];
          for (let i = 0; i < args.length; i += 1) {
            const arg = args[i];
            const s = EnsureCompletion(skipDebugger(ToString(arg)));
            if (s.Type === 'throw') {
              return s;
            }
            str.push(s.Value.stringValue());
          }
          // eslint-disable-next-line no-console
          console.log(...str);
          return Value.undefined;
        } else {
          const formatted = args.map((a, i) => {
            if (i === 0 && a instanceof JSStringValue) {
              return a.stringValue();
            }
            return inspect(a);
          }).join(' ');
          console.log(formatted); // eslint-disable-line no-console
        }
      }
      return Value.undefined;
    }, 0, Value('print'), []);
    CreateNonEnumerableDataPropertyOrThrow(realm.GlobalObject, Value('print'), print);
    const $262 = OrdinaryObjectCreate.from({
      // TODO: AbstractModuleSource
      createRealm: function* createRealm() {
        /* ReturnIfAbrupt */
        let _temp = surroundingAgent.debugger_cannotPreview;
        /* node:coverage ignore next */
        if (_temp && typeof _temp === 'object' && 'next' in _temp) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp instanceof AbruptCompletion) return _temp;
        /* node:coverage ignore next */
        if (_temp instanceof Completion) _temp = _temp.Value;
        const realm = new ManagedRealm();
        const {
          $262
        } = createTest262Intrinsics(realm, printCompatMode);
        return $262;
      },
      detachArrayBuffer: function* detachArrayBuffer(arrayBuffer) {
        if (!isArrayBufferObject(arrayBuffer)) {
          return surroundingAgent.Throw('TypeError', 'Raw', 'Argument must be an ArrayBuffer');
        }
        /* ReturnIfAbrupt */
        let _temp2 = DetachArrayBuffer(arrayBuffer);
        /* node:coverage ignore next */
        if (_temp2 && typeof _temp2 === 'object' && 'next' in _temp2) throw new Assert.Error('Forgot to yield* on the completion.');
        /* node:coverage ignore next */
        if (_temp2 instanceof AbruptCompletion) return _temp2;
        /* node:coverage ignore next */
        if (_temp2 instanceof Completion) _temp2 = _temp2.Value;
        return Value.undefined;
      },
      evalScript: function* evalScript(sourceText) {
        if (!(sourceText instanceof JSStringValue)) {
          return surroundingAgent.Throw('TypeError', 'Raw', 'Argument must be a string');
        }
        const s = ParseScript(sourceText.stringValue(), surroundingAgent.currentRealmRecord);
        if (isArray(s)) {
          return ThrowCompletion(s[0]);
        }
        const status = yield* ScriptEvaluation(s);
        return status;
      },
      gc,
      global: realm.GlobalObject,
      // TODO: agent only if we have multi-threading.

      // engine262 only
      spec: function* spec(value) {
        if (isBuiltinFunctionObject(value) && value.nativeFunction.section) {
          return Value(value.nativeFunction.section);
        }
        return Value.undefined;
      },
      debugger: function* hostDebugger(value = Value.undefined, callValue = Value.false) {
        if (surroundingAgent.debugger_isPreviewing) {
          return Value.undefined;
        }
        // eslint-disable-next-line no-debugger
        debugger;
        if (callValue !== Value.false) {
          /* ReturnIfAbrupt */
          let _temp3 = skipDebugger(Call(value, Value.undefined, []));
          /* node:coverage ignore next */
          if (_temp3 && typeof _temp3 === 'object' && 'next' in _temp3) throw new Assert.Error('Forgot to yield* on the completion.');
          /* node:coverage ignore next */
          if (_temp3 instanceof AbruptCompletion) return _temp3;
          /* node:coverage ignore next */
          if (_temp3 instanceof Completion) _temp3 = _temp3.Value;
        }
        return Value.undefined;
      }
    });
    // engine262 only
    CreateNonEnumerableDataPropertyOrThrow(realm.GlobalObject, Value('$262'), $262);
    CreateNonEnumerableDataPropertyOrThrow(realm.GlobalObject, Value('$'), $262);
    return {
      setPrintHandle,
      $262
    };
  });
}
function boostTest262Harness(realm) {
  // test262/harness/regExpUtils.js
  const key = Value('buildString');
  realm.scope(() => {
    /* X */
    let _temp4 = HasProperty(realm.GlobalObject, key);
    /* node:coverage ignore next */
    if (_temp4 && typeof _temp4 === 'object' && 'next' in _temp4) _temp4 = skipDebugger(_temp4);
    /* node:coverage ignore next */
    if (_temp4 instanceof AbruptCompletion) throw new Assert.Error("! HasProperty(realm.GlobalObject, key) returned an abrupt completion", {
      cause: _temp4
    });
    /* node:coverage ignore next */
    if (_temp4 instanceof Completion) _temp4 = _temp4.Value;
    if (_temp4 === Value.true) {
      /* X */
      let _temp5 = Set$1(realm.GlobalObject, key, CreateBuiltinFunction(boostHarness.buildString, 1, key, []), Value.true);
      /* node:coverage ignore next */
      if (_temp5 && typeof _temp5 === 'object' && 'next' in _temp5) _temp5 = skipDebugger(_temp5);
      /* node:coverage ignore next */
      if (_temp5 instanceof AbruptCompletion) throw new Assert.Error("! Set(realm.GlobalObject, key, CreateBuiltinFunction(boostHarness.buildString, 1, key, []), Value.true) returned an abrupt completion", {
        cause: _temp5
      });
      /* node:coverage ignore next */
      if (_temp5 instanceof Completion) _temp5 = _temp5.Value;
    }
  });
}
const boostHarness = {
  *buildString(argumentsList) {
    /* ReturnIfAbrupt */
    let _temp6 = yield* Call(surroundingAgent.intrinsic('%JSON.stringify%'), Value.null, [argumentsList[0]]);
    /* node:coverage ignore next */
    if (_temp6 instanceof AbruptCompletion) return _temp6;
    /* node:coverage ignore next */
    if (_temp6 instanceof Completion) _temp6 = _temp6.Value;
    const json = _temp6;
    Assert(json instanceof JSStringValue, "json instanceof JSStringValue");
    const jsonString = json.stringValue();
    const {
      loneCodePoints,
      ranges
    } = JSON.parse(jsonString);

    // #region test262/harness/regExpUtils.js
    const CHUNK_SIZE = 10000;
    let result = String.fromCodePoint.apply(null, loneCodePoints);
    for (let i = 0; i < ranges.length; i += 1) {
      const range = ranges[i];
      const start = range[0];
      const end = range[1];
      const codePoints = [];
      for (let length = 0, codePoint = start; codePoint <= end; codePoint += 1) {
        codePoints[length] = codePoint;
        length += 1;
        if (length === CHUNK_SIZE) {
          result += String.fromCodePoint.apply(null, codePoints);
          length = 0;
          codePoints.length = 0;
        }
      }
      result += String.fromCodePoint.apply(null, codePoints);
    }
    // #endregion

    return Value(result);
  }
};

const cascadeStack = new WeakMap();
// This is modified based on PerformEval, used internally for devtools console.
function* performDevtoolsEval(source, evalRealm, strictCaller, doNotTrack) {
  let inFunction = false;
  let inMethod = false;
  let inDerivedConstructor = false;
  let inClassFieldInitializer = false;
  let scriptContext;
  if (!surroundingAgent.runningExecutionContext?.LexicalEnvironment) {
    // top level devtools eval
    const globalEnv = evalRealm.GlobalEnv;
    scriptContext = new ExecutionContext();
    scriptContext.Function = Value.null;
    scriptContext.Realm = evalRealm;
    // scriptContext.ScriptOrModule = scriptRecord;
    scriptContext.VariableEnvironment = globalEnv;
    if (!cascadeStack.has(globalEnv)) {
      cascadeStack.set(globalEnv, new DeclarativeEnvironmentRecord(globalEnv));
    }
    scriptContext.LexicalEnvironment = cascadeStack.get(evalRealm.GlobalEnv);
    scriptContext.PrivateEnvironment = Value.null;
    // scriptContext.HostDefined = scriptRecord.HostDefined;
    surroundingAgent.executionContextStack.push(scriptContext);
  }
  /* X */
  let _temp = GetThisEnvironment();
  /* node:coverage ignore next */
  if (_temp && typeof _temp === 'object' && 'next' in _temp) _temp = skipDebugger(_temp);
  /* node:coverage ignore next */
  if (_temp instanceof AbruptCompletion) throw new Assert.Error("! GetThisEnvironment() returned an abrupt completion", {
    cause: _temp
  });
  /* node:coverage ignore next */
  if (_temp instanceof Completion) _temp = _temp.Value;
  const thisEnv = _temp;
  if (thisEnv instanceof FunctionEnvironmentRecord) {
    const F = thisEnv.FunctionObject;
    inFunction = true;
    inMethod = thisEnv.HasSuperBinding() === Value.true;
    if (F.ConstructorKind === 'derived') {
      inDerivedConstructor = true;
    }
    const classFieldInitializerName = F.ClassFieldInitializerName;
    if (classFieldInitializerName !== undefined) {
      inClassFieldInitializer = true;
    }
  }
  const privateIdentifiers = [];
  let pointer = surroundingAgent.runningExecutionContext.PrivateEnvironment;
  while (!(pointer instanceof NullValue)) {
    for (const binding of pointer.Names) {
      privateIdentifiers.push(binding.Description.stringValue());
    }
    pointer = pointer.OuterPrivateEnvironment;
  }
  const script = wrappedParse({
    source
  }, parser => parser.scope.with({
    strict: strictCaller,
    newTarget: inFunction,
    superProperty: inMethod,
    superCall: inDerivedConstructor,
    private: privateIdentifiers.length > 0
  }, () => {
    privateIdentifiers.forEach(name => {
      parser.scope.privateScope.names.set(name, new Set(['field']));
    });
    return parser.parseScript();
  }));
  if (Array.isArray(script)) {
    if (scriptContext) {
      surroundingAgent.executionContextStack.pop(scriptContext);
    }
    return ThrowCompletion(script[0]);
  }
  if (!script.ScriptBody) {
    if (scriptContext) {
      surroundingAgent.executionContextStack.pop(scriptContext);
    }
    return Value.undefined;
  }
  const body = script.ScriptBody;
  if (inClassFieldInitializer && ContainsArguments(body)) {
    return surroundingAgent.Throw('SyntaxError', 'UnexpectedToken');
  }
  const scriptRecord = new ScriptRecord({
    ECMAScriptCode: script,
    HostDefined: {},
    LoadedModules: [],
    Realm: evalRealm
  });
  if (!doNotTrack) {
    surroundingAgent.addParsedSource(scriptRecord);
  }
  if (scriptContext) {
    scriptContext.ScriptOrModule = scriptRecord;
    scriptContext.HostDefined = scriptRecord.HostDefined;
  }
  let strictEval;
  if (strictCaller === true) {
    strictEval = true;
  } else {
    strictEval = IsStrict(script);
  }
  const runningContext = surroundingAgent.runningExecutionContext;
  let parentLexicalEnvironment;
  if (cascadeStack.has(runningContext.LexicalEnvironment)) {
    parentLexicalEnvironment = cascadeStack.get(runningContext.LexicalEnvironment);
  } else {
    parentLexicalEnvironment = runningContext.LexicalEnvironment;
  }
  const lexEnv = new DeclarativeEnvironmentRecord(parentLexicalEnvironment);
  cascadeStack.set(runningContext.LexicalEnvironment, lexEnv);
  let varEnv;
  const privateEnv = runningContext.PrivateEnvironment;
  varEnv = runningContext.VariableEnvironment;
  if (strictEval === true) {
    varEnv = lexEnv;
  }
  const evalContext = new ExecutionContext();
  evalContext.Function = Value.null;
  evalContext.Realm = evalRealm;
  evalContext.ScriptOrModule = runningContext.ScriptOrModule;
  evalContext.VariableEnvironment = varEnv;
  evalContext.LexicalEnvironment = lexEnv;
  evalContext.PrivateEnvironment = privateEnv;
  surroundingAgent.executionContextStack.push(evalContext);
  let result = EnsureCompletion(yield* EvalDeclarationInstantiation(body, varEnv, lexEnv, privateEnv, strictEval));
  if (result.Type === 'normal') {
    result = EnsureCompletion(yield* Evaluate(body));
  }
  if (result.Type === 'normal' && result.Value === undefined) {
    result = NormalCompletion(Value.undefined);
  }
  surroundingAgent.executionContextStack.pop(evalContext);
  if (scriptContext) {
    surroundingAgent.executionContextStack.pop(scriptContext);
  }
  return result;
}

export { AbruptCompletion, AbstractModuleRecord, AbstractRelationalComparison, AddToKeptObjects, Agent, AgentSignifier, AllImportAttributesSupported, AllocateArrayBuffer, ApplyStringOrNumericBinaryOperator, ArgumentListEvaluation, ArrayBufferByteLength, ArrayCreate, ArraySetLength, ArraySpeciesCreate, Assert, AsyncBlockStart, AsyncFromSyncIteratorContinuation, AsyncFunctionStart, AsyncGeneratorAwaitReturn, AsyncGeneratorEnqueue, AsyncGeneratorResume, AsyncGeneratorStart, AsyncGeneratorValidate, AsyncGeneratorYield, AsyncIteratorClose, Await, BigIntValue, BindingClassDeclarationEvaluation, BindingInitialization, BlockDeclarationInstantiation, BodyText, BooleanValue, BoundNames, BreakCompletion, Call, CallSite, CanBeHeldWeakly, CanonicalNumericIndexString, Canonicalize, CanonicalizeKeyedCollectionKey, CharacterValue, ClassDefinitionEvaluation, ClassFieldDefinitionEvaluation, ClassFieldDefinitionRecord, ClassStaticBlockDefinitionEvaluation, ClassStaticBlockDefinitionRecord, CleanupFinalizationRegistry, ClearKeptObjects, CloneArrayBuffer, CodePointAt, CodePointsToString, CompareArrayElements, CompilePattern, CompletePropertyDescriptor, Completion, Construct, ConstructorMethod, ContainsArguments, ContainsExpression, ContinueCompletion, ContinueDynamicImport, ContinueModuleLoading, CopyDataBlockBytes, CopyDataProperties, CountLeftCapturingParensWithin, CreateArrayFromList, CreateArrayIterator, CreateAsyncFromSyncIterator, CreateAsyncIteratorFromClosure, CreateBuiltinFunction, CreateByteDataBlock, CreateDataProperty, CreateDataPropertyOrThrow, CreateDefaultExportSyntheticModule, CreateDynamicFunction, CreateIntrinsics, CreateIteratorFromClosure, CreateIteratorResultObject, CreateListFromArrayLike, CreateListIteratorRecord, CreateMappedArgumentsObject, CreateMethodProperty, CreateNonEnumerableDataPropertyOrThrow, CreateResolvingFunctions, CreateSyntheticModule, CreateUnmappedArgumentsObject, CyclicModuleRecord, DataBlock, DateFromTime, DateProto_toISOString, Day, DayFromYear, DayWithinYear, DaysInYear, DeclarationPart, DeclarativeEnvironmentRecord, DefineField, DefineMethod, DefinePropertyOrThrow, DeletePropertyOrThrow, _Descriptor as Descriptor, DestructuringAssignmentEvaluation, DetachArrayBuffer, EnsureCompletion, EnumerableOwnPropertyNames, EnvironmentRecord, EscapeRegExpPattern, EvalDeclarationInstantiation, Evaluate, EvaluateBody, EvaluateBody_AssignmentExpression, EvaluateBody_AsyncFunctionBody, EvaluateBody_AsyncGeneratorBody, EvaluateBody_ConciseBody, EvaluateBody_FunctionBody, EvaluateBody_GeneratorBody, EvaluateCall, EvaluatePropertyAccessWithExpressionKey, EvaluatePropertyAccessWithIdentifierKey, EvaluateStringOrNumericBinaryExpression, Evaluate_AdditiveExpression, Evaluate_AnyFunctionBody, Evaluate_ArrayLiteral, Evaluate_ArrowFunction, Evaluate_AssignmentExpression, Evaluate_AsyncArrowFunction, Evaluate_AsyncFunctionExpression, Evaluate_AsyncGeneratorExpression, Evaluate_AwaitExpression, Evaluate_BinaryBitwiseExpression, Evaluate_BindingList, Evaluate_Block, Evaluate_BreakStatement, Evaluate_BreakableStatement, Evaluate_CallExpression, Evaluate_CaseClause, Evaluate_ClassDeclaration, Evaluate_ClassExpression, Evaluate_CoalesceExpression, Evaluate_CommaOperator, Evaluate_ConditionalExpression, Evaluate_ContinueStatement, Evaluate_DebuggerStatement, Evaluate_EmptyStatement, Evaluate_EqualityExpression, Evaluate_ExponentiationExpression, Evaluate_ExportDeclaration, Evaluate_ExpressionBody, Evaluate_ExpressionStatement, Evaluate_ForBinding, Evaluate_FunctionDeclaration, Evaluate_FunctionExpression, Evaluate_FunctionStatementList, Evaluate_GeneratorExpression, Evaluate_HoistableDeclaration, Evaluate_IdentifierReference, Evaluate_IfStatement, Evaluate_ImportCall, Evaluate_ImportDeclaration, Evaluate_ImportMeta, Evaluate_LabelledStatement, Evaluate_LexicalBinding, Evaluate_LexicalDeclaration, Evaluate_Literal, Evaluate_LogicalANDExpression, Evaluate_LogicalORExpression, Evaluate_MemberExpression, Evaluate_Module, Evaluate_ModuleBody, Evaluate_MultiplicativeExpression, Evaluate_NewExpression, Evaluate_NewTarget, Evaluate_ObjectLiteral, Evaluate_OptionalExpression, Evaluate_ParenthesizedExpression, Evaluate_PropertyName, Evaluate_RegularExpressionLiteral, Evaluate_RelationalExpression, Evaluate_RelationalExpression_PrivateIdentifier, Evaluate_ReturnStatement, Evaluate_Script, Evaluate_ScriptBody, Evaluate_ShiftExpression, Evaluate_StatementList, Evaluate_SuperCall, Evaluate_SuperProperty, Evaluate_SwitchStatement, Evaluate_TaggedTemplateExpression, Evaluate_TemplateLiteral, Evaluate_This, Evaluate_ThrowStatement, Evaluate_TryStatement, Evaluate_UnaryExpression, Evaluate_UpdateExpression, Evaluate_VariableDeclarationList, Evaluate_VariableStatement, Evaluate_WithStatement, Evaluate_YieldExpression, ExecutionContext, ExpectedArgumentCount, ExportEntries, ExportEntriesForModule, F, FEATURES, FinishLoadingImportedModule, FlagText, FromPropertyDescriptor, FunctionDeclarationInstantiation, FunctionEnvironmentRecord, GeneratorResume, GeneratorResumeAbrupt, GeneratorStart, GeneratorValidate, GeneratorYield, Get, GetActiveScriptOrModule, GetFunctionRealm, GetGeneratorKind, GetGlobalObject, GetIdentifierReference, GetImportedModule, GetIterator, GetIteratorDirect, GetIteratorFlattenable, GetIteratorFromMethod, GetMatchIndexPair, GetMatchString, GetMethod, GetModuleNamespace, GetNewTarget, GetPrototypeFromConstructor, GetStringIndex, GetSubstitution, GetThisEnvironment, GetThisValue, GetV, GetValue, GetValueFromBuffer, GetViewByteLength, GetViewValue, GlobalDeclarationInstantiation, GlobalEnvironmentRecord, GraphLoadingState, HasInitializer, HasName, HasOwnProperty, HasProperty, HostCallJobCallback, HostEnqueueFinalizationRegistryCleanupJob, HostEnqueuePromiseJob, HostEnsureCanCompileStrings, HostFinalizeImportMeta, HostGetImportMetaProperties, HostGetSupportedImportAttributes, HostHasSourceTextAvailable, HostLoadImportedModule, HostMakeJobCallback, HostPromiseRejectionTracker, HourFromTime, HoursPerDay, IfAbruptCloseIterator, IfAbruptRejectPromise, ImportEntries, ImportEntriesForModule, ImportedLocalNames, InLeapYear, IncrementModuleAsyncEvaluationCount, InitializeBoundName, InitializeHostDefinedRealm, InitializeInstanceElements, InitializeReferencedBinding, InnerModuleEvaluation, InnerModuleLinking, InnerModuleLoading, InstallErrorCause, InstanceofOperator, InstantiateArrowFunctionExpression, InstantiateAsyncArrowFunctionExpression, InstantiateAsyncFunctionExpression, InstantiateAsyncGeneratorFunctionExpression, InstantiateFunctionObject, InstantiateFunctionObject_AsyncFunctionDeclaration, InstantiateFunctionObject_AsyncGeneratorDeclaration, InstantiateFunctionObject_FunctionDeclaration, InstantiateFunctionObject_GeneratorDeclaration, InstantiateGeneratorFunctionExpression, InstantiateOrdinaryFunctionExpression, IntrinsicsFunctionToString, Invoke, IsAccessorDescriptor, IsAnonymousFunctionDefinition, IsArray, IsArrayBufferViewOutOfBounds, IsBigIntElementType, IsCallable, IsCharacterClass, IsCompatiblePropertyDescriptor, IsComputedPropertyKey, IsConcatSpreadable, IsConstantDeclaration, IsConstructor, IsDataDescriptor, IsDestructuring, IsDetachedBuffer, IsError, IsExtensible, IsFixedLengthArrayBuffer, IsFunctionDefinition, IsGenericDescriptor, IsIdentifierRef, IsInTailPosition, IsIntegralNumber, IsLooselyEqual, IsPrivateReference, IsPromise, IsPropertyKey, IsPropertyReference, IsRegExp, IsSharedArrayBuffer, IsSimpleParameterList, IsStatic, IsStrict, IsStrictlyEqual, IsStringPrefix, IsStringWellFormedUnicode, IsSuperReference, IsTypedArrayFixedLength, IsTypedArrayOutOfBounds, IsUnresolvableReference, IsValidIntegerIndex, IsViewOutOfBounds, IteratorBindingInitialization_ArrayBindingPattern, IteratorBindingInitialization_FormalParameters, IteratorClose, IteratorComplete, IteratorNext, IteratorStep, IteratorStepValue, IteratorToList, IteratorValue, JSStringMap, JSStringSet, JSStringValue, KeyForSymbol, KeyedBindingInitialization, LabelledEvaluation, LengthOfArrayLike, LexicallyDeclaredNames, LexicallyScopedDeclarations, LocalTZA, LocalTime, MV_StringNumericLiteral, MakeBasicObject, MakeClassConstructor, MakeConstructor, MakeDataViewWithBufferWitnessRecord, MakeDate, MakeDay, MakeMatchIndicesIndexPairArray, MakeMethod, MakePrivateReference, MakeTime, MakeTypedArrayWithBufferWitnessRecord, ManagedRealm, MethodDefinitionEvaluation, MinFromTime, MinutesPerHour, ModuleEnvironmentRecord, ModuleNamespaceCreate, AbstractModuleRecord as ModuleRecord, ModuleRequests, ModuleRequestsEqual, MonthFromTime, NamedEvaluation, NewPromiseCapability, NonConstructorElements, NormalCompletion, NullValue, NumberToBigInt, NumberValue, NumericToRawBytes, NumericValue, ObjectEnvironmentRecord, ObjectValue, OrdinaryCallBindThis, OrdinaryCallEvaluateBody, OrdinaryCreateFromConstructor, OrdinaryDefineOwnProperty, OrdinaryDelete, OrdinaryFunctionCreate, OrdinaryGet, OrdinaryGetOwnProperty, OrdinaryGetPrototypeOf, OrdinaryHasInstance, OrdinaryHasProperty, OrdinaryIsExtensible, OrdinaryObjectCreate, OrdinaryOwnPropertyKeys, OrdinaryPreventExtensions, OrdinarySet, OrdinarySetPrototypeOf, OrdinarySetWithOwnDescriptor, OrdinaryToPrimitive, ParseJSONModule, ParseModule, ParsePattern, ParseScript, Parser, PerformEval, PerformPromiseThen, PrepareForOrdinaryCall, PrepareForTailCall, PrimitiveValue, PrivateBoundIdentifiers, PrivateElementFind, PrivateElementRecord, PrivateEnvironmentRecord, PrivateFieldAdd, PrivateGet, PrivateMethodOrAccessorAdd, PrivateName, PrivateSet, PromiseCapabilityRecord, PromiseReactionRecord, PromiseResolve, PropName, PropertyBindingInitialization, PropertyDefinitionEvaluation_PropertyDefinitionList, PropertyKeyMap, ProxyCreate, PutValue, ReturnIfAbrupt as Q, R, RawBytesToNumeric, Realm, ReferenceRecord, RegExpAlloc, RegExpCreate, RegExpHasFlag, RegExpInitialize, RegExpParser, MatchState as RegExpState, RequireInternalSlot, RequireObjectCoercible, ResolveBinding, ResolvePrivateIdentifier, ResolveThisBinding, ResolvedBindingRecord, RestBindingInitialization, ReturnCompletion, ReturnIfAbrupt, SameType, SameValue, SameValueNonNumber, SameValueZero, ScriptEvaluation, ScriptRecord, SecFromTime, SecondsPerMinute, Set$1 as Set, SetDefaultGlobalBindings, SetFunctionLength, SetFunctionName, SetImmutablePrototype, SetIntegrityLevel, SetValueInBuffer, SetViewValue, SetterThatIgnoresPrototypeProperties, SourceTextModuleRecord, SpeciesConstructor, StringCreate, StringGetOwnProperty, StringIndexOf, StringPad, StringToBigInt, StringToCodePoints, StringValue, SymbolDescriptiveString, SymbolValue, SyntheticModuleRecord, TV, Table69_NonbinaryUnicodeProperties, Table70_BinaryUnicodeProperties, Table71_BinaryPropertyOfStrings, TemplateStrings, TestIntegrityLevel, Throw, ThrowCompletion, TimeClip, TimeFromYear, TimeWithinDay, ToBigInt, ToBigInt64, ToBigUint64, ToBoolean, ToIndex, ToInt16, ToInt32, ToInt8, ToIntegerOrInfinity, ToLength, ToNumber, ToNumeric, ToObject, ToPrimitive, ToPropertyDescriptor, ToPropertyKey, ToString, ToUint16, ToUint32, ToUint8, ToUint8Clamp, TopLevelLexicallyDeclaredNames, TopLevelLexicallyScopedDeclarations, TopLevelVarDeclaredNames, TopLevelVarScopedDeclarations, TrimString, TypedArrayByteLength, TypedArrayCreate, TypedArrayGetElement, TypedArrayLength, TypedArraySetElement, UTC, UTF16EncodeCodePoint, UTF16SurrogatePairToCodePoint, UndefinedValue, Unicode, UpdateEmpty, ValidateAndApplyPropertyDescriptor, Value, ValueOfNormalCompletion, VarDeclaredNames, VarScopedDeclarations, WeakRefDeref, WeekDay, X, YearFromTime, Yield, Z, boostTest262Harness, captureStack, createTest262Intrinsics, evalQ, gc, generatorBrandToErrorMessageType, getCurrentStack, getHostDefinedErrorStack, inspect, isArgumentExoticObject, isArrayBufferObject, isArrayExoticObject, isArrayIndex, isBuiltinFunctionObject, isDataViewObject, isDateObject, isECMAScriptFunctionObject, IsError as isErrorObject, isFunctionObject, isIntegerIndex, isLeadingSurrogate, isMapObject, isModuleNamespaceObject, isNonNegativeInteger, isPromiseObject, isProxyExoticObject, isRegExpObject, isSetObject, isStrictModeCode, isTrailingSurrogate, isTypedArrayObject, isWeakMapObject, isWeakRef, isWeakSetObject, kInternal, msFromTime, msPerAverageYear, msPerDay, msPerHour, msPerMinute, msPerSecond, performDevtoolsEval, refineLeftHandSideExpression, runJobQueue, setSurroundingAgent, skipDebugger, sourceTextMatchedBy, surroundingAgent, unwrapCompletion, wellKnownSymbols, wrappedParse };
//# sourceMappingURL=engine262.mjs.map
